head	1.118;
access;
symbols
	sid-snapshot-20180601:1.118
	sid-snapshot-20180501:1.118
	sid-snapshot-20180401:1.118
	sid-snapshot-20180301:1.118
	sid-snapshot-20180201:1.118
	sid-snapshot-20180101:1.118
	sid-snapshot-20171201:1.118
	sid-snapshot-20171101:1.118
	sid-snapshot-20171001:1.118
	sid-snapshot-20170901:1.118
	sid-snapshot-20170801:1.118
	sid-snapshot-20170701:1.118
	sid-snapshot-20170601:1.118
	sid-snapshot-20170501:1.118
	sid-snapshot-20170401:1.118
	sid-snapshot-20170301:1.118
	sid-snapshot-20170201:1.118
	sid-snapshot-20170101:1.118
	sid-snapshot-20161201:1.118
	sid-snapshot-20161101:1.118
	sid-snapshot-20160901:1.118
	sid-snapshot-20160801:1.118
	sid-snapshot-20160701:1.118
	sid-snapshot-20160601:1.118
	sid-snapshot-20160501:1.118
	sid-snapshot-20160401:1.118
	sid-snapshot-20160301:1.118
	sid-snapshot-20160201:1.118
	sid-snapshot-20160101:1.118
	sid-snapshot-20151201:1.118
	sid-snapshot-20151101:1.118
	sid-snapshot-20151001:1.118
	sid-snapshot-20150901:1.118
	sid-snapshot-20150801:1.118
	sid-snapshot-20150701:1.118
	sid-snapshot-20150601:1.118
	sid-snapshot-20150501:1.118
	sid-snapshot-20150401:1.118
	sid-snapshot-20150301:1.118
	sid-snapshot-20150201:1.118
	sid-snapshot-20150101:1.118
	sid-snapshot-20141201:1.118
	sid-snapshot-20141101:1.118
	sid-snapshot-20141001:1.118
	sid-snapshot-20140901:1.118
	sid-snapshot-20140801:1.118
	sid-snapshot-20140701:1.118
	sid-snapshot-20140601:1.118
	sid-snapshot-20140501:1.118
	sid-snapshot-20140401:1.118
	sid-snapshot-20140301:1.118
	sid-snapshot-20140201:1.118
	sid-snapshot-20140101:1.118
	sid-snapshot-20131201:1.118
	sid-snapshot-20131101:1.118
	sid-snapshot-20131001:1.118
	binutils-2_24-branch:1.118.0.2
	binutils-2_24-branchpoint:1.118
	binutils-2_21_1:1.101.2.1
	sid-snapshot-20130901:1.118
	gdb_7_6_1-2013-08-30-release:1.114
	sid-snapshot-20130801:1.117
	sid-snapshot-20130701:1.116
	sid-snapshot-20130601:1.116
	sid-snapshot-20130501:1.116
	gdb_7_6-2013-04-26-release:1.114
	sid-snapshot-20130401:1.116
	binutils-2_23_2:1.109
	gdb_7_6-branch:1.114.0.2
	gdb_7_6-2013-03-12-branchpoint:1.114
	sid-snapshot-20130301:1.114
	sid-snapshot-20130201:1.111
	sid-snapshot-20130101:1.110
	sid-snapshot-20121201:1.109
	gdb_7_5_1-2012-11-29-release:1.109
	binutils-2_23_1:1.109
	sid-snapshot-20121101:1.109
	binutils-2_23:1.109
	sid-snapshot-20121001:1.109
	sid-snapshot-20120901:1.109
	gdb_7_5-2012-08-17-release:1.109
	sid-snapshot-20120801:1.109
	binutils-2_23-branch:1.109.0.4
	binutils-2_23-branchpoint:1.109
	gdb_7_5-branch:1.109.0.2
	gdb_7_5-2012-07-18-branchpoint:1.109
	sid-snapshot-20120701:1.109
	sid-snapshot-20120601:1.108
	sid-snapshot-20120501:1.106
	binutils-2_22_branch:1.105.0.6
	gdb_7_4_1-2012-04-26-release:1.105
	sid-snapshot-20120401:1.105
	sid-snapshot-20120301:1.105
	sid-snapshot-20120201:1.105
	gdb_7_4-2012-01-24-release:1.105
	sid-snapshot-20120101:1.105
	gdb_7_4-branch:1.105.0.4
	gdb_7_4-2011-12-13-branchpoint:1.105
	sid-snapshot-20111201:1.105
	binutils-2_22:1.105
	sid-snapshot-20111101:1.105
	sid-snapshot-20111001:1.105
	binutils-2_22-branch:1.105.0.2
	binutils-2_22-branchpoint:1.105
	gdb_7_3_1-2011-09-04-release:1.102
	sid-snapshot-20110901:1.105
	sid-snapshot-20110801:1.105
	gdb_7_3-2011-07-26-release:1.102
	sid-snapshot-20110701:1.103
	sid-snapshot-20110601:1.102
	sid-snapshot-20110501:1.102
	gdb_7_3-branch:1.102.0.2
	gdb_7_3-2011-04-01-branchpoint:1.102
	sid-snapshot-20110401:1.102
	sid-snapshot-20110301:1.102
	sid-snapshot-20110201:1.102
	sid-snapshot-20110101:1.102
	binutils-2_21:1.101
	sid-snapshot-20101201:1.102
	binutils-2_21-branch:1.101.0.2
	binutils-2_21-branchpoint:1.101
	sid-snapshot-20101101:1.101
	sid-snapshot-20101001:1.99
	binutils-2_20_1:1.92
	gdb_7_2-2010-09-02-release:1.96
	sid-snapshot-20100901:1.98
	sid-snapshot-20100801:1.96
	gdb_7_2-branch:1.96.0.2
	gdb_7_2-2010-07-07-branchpoint:1.96
	sid-snapshot-20100701:1.96
	sid-snapshot-20100601:1.95
	sid-snapshot-20100501:1.95
	sid-snapshot-20100401:1.95
	gdb_7_1-2010-03-18-release:1.95
	sid-snapshot-20100301:1.95
	gdb_7_1-branch:1.95.0.2
	gdb_7_1-2010-02-18-branchpoint:1.95
	sid-snapshot-20100201:1.94
	sid-snapshot-20100101:1.94
	gdb_7_0_1-2009-12-22-release:1.92
	sid-snapshot-20091201:1.93
	sid-snapshot-20091101:1.92
	binutils-2_20:1.92
	gdb_7_0-2009-10-06-release:1.92
	sid-snapshot-20091001:1.92
	gdb_7_0-branch:1.92.0.8
	gdb_7_0-2009-09-16-branchpoint:1.92
	arc-sim-20090309:1.83
	binutils-arc-20081103-branch:1.87.0.12
	binutils-arc-20081103-branchpoint:1.87
	binutils-2_20-branch:1.92.0.6
	binutils-2_20-branchpoint:1.92
	sid-snapshot-20090901:1.92
	sid-snapshot-20090801:1.92
	msnyder-checkpoint-072509-branch:1.92.0.4
	msnyder-checkpoint-072509-branchpoint:1.92
	sid-snapshot-20090701:1.92
	dje-cgen-play1-branch:1.92.0.2
	dje-cgen-play1-branchpoint:1.92
	sid-snapshot-20090601:1.92
	sid-snapshot-20090501:1.91
	sid-snapshot-20090401:1.91
	arc-20081103-branch:1.87.0.10
	arc-20081103-branchpoint:1.87
	arc-insight_6_8-branch:1.83.0.6
	arc-insight_6_8-branchpoint:1.83
	insight_6_8-branch:1.83.0.4
	insight_6_8-branchpoint:1.83
	sid-snapshot-20090301:1.89
	binutils-2_19_1:1.87
	sid-snapshot-20090201:1.87
	sid-snapshot-20090101:1.87
	reverse-20081226-branch:1.87.0.8
	reverse-20081226-branchpoint:1.87
	sid-snapshot-20081201:1.87
	multiprocess-20081120-branch:1.87.0.6
	multiprocess-20081120-branchpoint:1.87
	sid-snapshot-20081101:1.87
	binutils-2_19:1.87
	sid-snapshot-20081001:1.87
	reverse-20080930-branch:1.87.0.4
	reverse-20080930-branchpoint:1.87
	binutils-2_19-branch:1.87.0.2
	binutils-2_19-branchpoint:1.87
	sid-snapshot-20080901:1.87
	sid-snapshot-20080801:1.87
	reverse-20080717-branch:1.86.0.4
	reverse-20080717-branchpoint:1.86
	sid-snapshot-20080701:1.86
	msnyder-reverse-20080609-branch:1.86.0.2
	msnyder-reverse-20080609-branchpoint:1.86
	drow-reverse-20070409-branch:1.78.0.2
	drow-reverse-20070409-branchpoint:1.78
	sid-snapshot-20080601:1.86
	sid-snapshot-20080501:1.84
	sid-snapshot-20080403:1.84
	sid-snapshot-20080401:1.84
	gdb_6_8-2008-03-27-release:1.83
	sid-snapshot-20080301:1.83
	gdb_6_8-branch:1.83.0.2
	gdb_6_8-2008-02-26-branchpoint:1.83
	sid-snapshot-20080201:1.83
	sid-snapshot-20080101:1.83
	sid-snapshot-20071201:1.82
	sid-snapshot-20071101:1.82
	gdb_6_7_1-2007-10-29-release:1.81
	gdb_6_7-2007-10-10-release:1.81
	sid-snapshot-20071001:1.81
	gdb_6_7-branch:1.81.0.4
	gdb_6_7-2007-09-07-branchpoint:1.81
	binutils-2_18:1.81
	binutils-2_18-branch:1.81.0.2
	binutils-2_18-branchpoint:1.81
	insight_6_6-20070208-release:1.75
	binutils-csl-coldfire-4_1-32:1.70.2.1
	binutils-csl-sourcerygxx-4_1-32:1.70.2.1
	gdb_6_6-2006-12-18-release:1.75
	binutils-csl-innovasic-fido-3_4_4-33:1.70.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.53
	binutils-csl-coldfire-4_1-30:1.70.2.1
	binutils-csl-sourcerygxx-4_1-30:1.70.2.1
	binutils-csl-coldfire-4_1-28:1.70.2.1
	binutils-csl-sourcerygxx-4_1-29:1.70.2.1
	binutils-csl-sourcerygxx-4_1-28:1.70.2.1
	gdb_6_6-branch:1.75.0.2
	gdb_6_6-2006-11-15-branchpoint:1.75
	binutils-csl-arm-2006q3-27:1.70.2.1
	binutils-csl-sourcerygxx-4_1-27:1.70.2.1
	binutils-csl-arm-2006q3-26:1.70.2.1
	binutils-csl-sourcerygxx-4_1-26:1.70.2.1
	binutils-csl-sourcerygxx-4_1-25:1.70.2.1
	binutils-csl-sourcerygxx-4_1-24:1.70.2.1
	binutils-csl-sourcerygxx-4_1-23:1.70.2.1
	insight_6_5-20061003-release:1.71
	gdb-csl-symbian-6_4_50_20060226-12:1.67
	binutils-csl-sourcerygxx-4_1-21:1.70.2.1
	binutils-csl-arm-2006q3-21:1.70.2.1
	binutils-csl-sourcerygxx-4_1-22:1.70.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.70.2.1
	binutils-csl-sourcerygxx-4_1-20:1.70.2.1
	binutils-csl-arm-2006q3-19:1.70.2.1
	binutils-csl-sourcerygxx-4_1-19:1.70.2.1
	binutils-csl-sourcerygxx-4_1-18:1.70.2.1
	binutils-csl-renesas-4_1-9:1.70.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.65
	binutils-csl-sourcerygxx-3_4_4-25:1.53
	nickrob-async-20060828-mergepoint:1.73
	gdb-csl-symbian-6_4_50_20060226-11:1.67
	binutils-csl-renesas-4_1-8:1.70
	binutils-csl-renesas-4_1-7:1.70
	binutils-csl-renesas-4_1-6:1.70
	gdb-csl-sourcerygxx-4_1-17:1.67
	binutils-csl-sourcerygxx-4_1-17:1.70
	gdb-csl-20060226-branch-local-2:1.67
	gdb-csl-sourcerygxx-4_1-14:1.67
	binutils-csl-sourcerygxx-4_1-14:1.70
	binutils-csl-sourcerygxx-4_1-15:1.70
	gdb-csl-sourcerygxx-4_1-13:1.67
	binutils-csl-sourcerygxx-4_1-13:1.70
	binutils-2_17:1.71
	gdb-csl-sourcerygxx-4_1-12:1.67
	binutils-csl-sourcerygxx-4_1-12:1.70
	gdb-csl-sourcerygxx-3_4_4-21:1.67
	binutils-csl-sourcerygxx-3_4_4-21:1.70
	gdb_6_5-20060621-release:1.71
	binutils-csl-wrs-linux-3_4_4-24:1.53
	binutils-csl-wrs-linux-3_4_4-23:1.53
	gdb-csl-sourcerygxx-4_1-9:1.67
	binutils-csl-sourcerygxx-4_1-9:1.70
	gdb-csl-sourcerygxx-4_1-8:1.67
	binutils-csl-sourcerygxx-4_1-8:1.70
	gdb-csl-sourcerygxx-4_1-7:1.67
	binutils-csl-sourcerygxx-4_1-7:1.70
	gdb-csl-arm-2006q1-6:1.67
	binutils-csl-arm-2006q1-6:1.70
	gdb-csl-sourcerygxx-4_1-6:1.67
	binutils-csl-sourcerygxx-4_1-6:1.70
	binutils-csl-wrs-linux-3_4_4-22:1.53
	gdb-csl-symbian-6_4_50_20060226-10:1.67
	gdb-csl-symbian-6_4_50_20060226-9:1.67
	gdb-csl-symbian-6_4_50_20060226-8:1.67
	gdb-csl-coldfire-4_1-11:1.67
	binutils-csl-coldfire-4_1-11:1.70
	gdb-csl-sourcerygxx-3_4_4-19:1.67
	binutils-csl-sourcerygxx-3_4_4-19:1.70
	gdb-csl-coldfire-4_1-10:1.67
	gdb_6_5-branch:1.71.0.10
	gdb_6_5-2006-05-14-branchpoint:1.71
	binutils-csl-coldfire-4_1-10:1.70
	gdb-csl-sourcerygxx-4_1-5:1.67
	binutils-csl-sourcerygxx-4_1-5:1.70
	nickrob-async-20060513-branch:1.71.0.8
	nickrob-async-20060513-branchpoint:1.71
	gdb-csl-sourcerygxx-4_1-4:1.67
	binutils-csl-sourcerygxx-4_1-4:1.70
	msnyder-reverse-20060502-branch:1.71.0.6
	msnyder-reverse-20060502-branchpoint:1.71
	binutils-csl-wrs-linux-3_4_4-21:1.53
	gdb-csl-morpho-4_1-4:1.67
	binutils-csl-morpho-4_1-4:1.70
	gdb-csl-sourcerygxx-3_4_4-17:1.67
	binutils-csl-sourcerygxx-3_4_4-17:1.70
	binutils-csl-wrs-linux-3_4_4-20:1.53
	readline_5_1-import-branch:1.71.0.4
	readline_5_1-import-branchpoint:1.71
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.67
	binutils-2_17-branch:1.71.0.2
	binutils-2_17-branchpoint:1.71
	gdb-csl-symbian-20060226-branch:1.67.0.6
	gdb-csl-symbian-20060226-branchpoint:1.67
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.67
	msnyder-reverse-20060331-branch:1.70.0.4
	msnyder-reverse-20060331-branchpoint:1.70
	binutils-csl-2_17-branch:1.70.0.2
	binutils-csl-2_17-branchpoint:1.70
	gdb-csl-available-20060303-branch:1.67.0.4
	gdb-csl-available-20060303-branchpoint:1.67
	gdb-csl-20060226-branch:1.67.0.2
	gdb-csl-20060226-branchpoint:1.67
	gdb_6_4-20051202-release:1.65
	msnyder-fork-checkpoint-branch:1.66.0.2
	msnyder-fork-checkpoint-branchpoint:1.66
	gdb-csl-gxxpro-6_3-branch:1.65.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.65
	gdb_6_4-branch:1.65.0.4
	gdb_6_4-2005-11-01-branchpoint:1.65
	gdb-csl-arm-20051020-branch:1.65.0.2
	gdb-csl-arm-20051020-branchpoint:1.65
	binutils-csl-gxxpro-3_4-branch:1.53.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.53
	binutils-2_16_1:1.53
	msnyder-tracepoint-checkpoint-branch:1.59.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.59
	gdb-csl-arm-20050325-2005-q1b:1.54
	binutils-csl-arm-2005q1b:1.53
	binutils-2_16:1.53
	gdb-csl-arm-20050325-2005-q1a:1.54
	binutils-csl-arm-2005q1a:1.53
	csl-arm-20050325-branch:1.54.0.2
	csl-arm-20050325-branchpoint:1.54
	binutils-csl-arm-2005q1-branch:1.53.0.4
	binutils-csl-arm-2005q1-branchpoint:1.53
	binutils-2_16-branch:1.53.0.2
	binutils-2_16-branchpoint:1.53
	csl-arm-2004-q3d:1.52
	gdb_6_3-20041109-release:1.52
	gdb_6_3-branch:1.52.0.2
	gdb_6_3-20041019-branchpoint:1.52
	csl-arm-2004-q3:1.51
	drow_intercu-merge-20040921:1.51
	drow_intercu-merge-20040915:1.49
	jimb-gdb_6_2-e500-branch:1.49.0.6
	jimb-gdb_6_2-e500-branchpoint:1.49
	gdb_6_2-20040730-release:1.49
	gdb_6_2-branch:1.49.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.49
	gdb_6_1_1-20040616-release:1.45
	binutils-2_15:1.45.6.2
	binutils-2_15-branchpoint:1.45
	csl-arm-2004-q1a:1.48
	csl-arm-2004-q1:1.48
	gdb_6_1-2004-04-05-release:1.45
	drow_intercu-merge-20040402:1.48
	drow_intercu-merge-20040327:1.47
	ezannoni_pie-20040323-branch:1.46.0.2
	ezannoni_pie-20040323-branchpoint:1.46
	cagney_tramp-20040321-mergepoint:1.46
	cagney_tramp-20040309-branch:1.45.0.12
	cagney_tramp-20040309-branchpoint:1.45
	gdb_6_1-branch:1.45.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.45
	drow_intercu-20040221-branch:1.45.0.8
	drow_intercu-20040221-branchpoint:1.45
	binutils-2_15-branch:1.45.0.6
	cagney_bfdfile-20040213-branch:1.45.0.4
	cagney_bfdfile-20040213-branchpoint:1.45
	drow-cplus-merge-20040208:1.45
	carlton_dictionary-20040126-merge:1.45
	cagney_bigcore-20040122-branch:1.45.0.2
	cagney_bigcore-20040122-branchpoint:1.45
	drow-cplus-merge-20040113:1.45
	csl-arm-2003-q4:1.45
	drow-cplus-merge-20031224:1.45
	drow-cplus-merge-20031220:1.45
	carlton_dictionary-20031215-merge:1.45
	drow-cplus-merge-20031214:1.45
	carlton-dictionary-20031111-merge:1.41
	gdb_6_0-2003-10-04-release:1.32
	kettenis_sparc-20030918-branch:1.38.0.6
	kettenis_sparc-20030918-branchpoint:1.38
	carlton_dictionary-20030917-merge:1.38
	ezannoni_pie-20030916-branchpoint:1.38
	ezannoni_pie-20030916-branch:1.38.0.4
	cagney_x86i386-20030821-branch:1.38.0.2
	cagney_x86i386-20030821-branchpoint:1.38
	carlton_dictionary-20030805-merge:1.36
	carlton_dictionary-20030627-merge:1.33
	gdb_6_0-branch:1.32.0.14
	gdb_6_0-2003-06-23-branchpoint:1.32
	jimb-ppc64-linux-20030613-branch:1.32.0.12
	jimb-ppc64-linux-20030613-branchpoint:1.32
	binutils-2_14:1.31
	cagney_convert-20030606-branch:1.32.0.10
	cagney_convert-20030606-branchpoint:1.32
	cagney_writestrings-20030508-branch:1.32.0.8
	cagney_writestrings-20030508-branchpoint:1.32
	jimb-ppc64-linux-20030528-branch:1.32.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.32
	carlton_dictionary-20030523-merge:1.32
	cagney_fileio-20030521-branch:1.32.0.4
	cagney_fileio-20030521-branchpoint:1.32
	kettenis_i386newframe-20030517-mergepoint:1.32
	jimb-ppc64-linux-20030509-branch:1.32.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.32
	kettenis_i386newframe-20030504-mergepoint:1.31
	carlton_dictionary-20030430-merge:1.31
	binutils-2_14-branch:1.31.0.18
	binutils-2_14-branchpoint:1.31
	kettenis_i386newframe-20030419-branch:1.31.0.16
	kettenis_i386newframe-20030419-branchpoint:1.31
	carlton_dictionary-20030416-merge:1.31
	cagney_frameaddr-20030409-mergepoint:1.31
	kettenis_i386newframe-20030406-branch:1.31.0.14
	kettenis_i386newframe-20030406-branchpoint:1.31
	cagney_frameaddr-20030403-branchpoint:1.31
	cagney_frameaddr-20030403-branch:1.31.0.12
	cagney_framebase-20030330-mergepoint:1.31
	cagney_framebase-20030326-branch:1.31.0.10
	cagney_framebase-20030326-branchpoint:1.31
	cagney_lazyid-20030317-branch:1.31.0.8
	cagney_lazyid-20030317-branchpoint:1.31
	kettenis-i386newframe-20030316-mergepoint:1.31
	offbyone-20030313-branch:1.31.0.6
	offbyone-20030313-branchpoint:1.31
	kettenis-i386newframe-20030308-branch:1.31.0.4
	kettenis-i386newframe-20030308-branchpoint:1.31
	carlton_dictionary-20030305-merge:1.31
	cagney_offbyone-20030303-branch:1.31.0.2
	cagney_offbyone-20030303-branchpoint:1.31
	carlton_dictionary-20030207-merge:1.30
	interps-20030202-branch:1.30.0.4
	interps-20030202-branchpoint:1.30
	cagney-unwind-20030108-branch:1.30.0.2
	cagney-unwind-20030108-branchpoint:1.30
	binutils-2_13_2_1:1.26
	binutils-2_13_2:1.26
	carlton_dictionary-20021223-merge:1.30
	gdb_5_3-2002-12-12-release:1.27
	carlton_dictionary-20021115-merge:1.28
	binutils-2_13_1:1.26
	kseitz_interps-20021105-merge:1.28
	kseitz_interps-20021103-merge:1.28
	drow-cplus-merge-20021020:1.27
	drow-cplus-merge-20021025:1.28
	carlton_dictionary-20021025-merge:1.28
	carlton_dictionary-20021011-merge:1.27
	drow-cplus-branch:1.27.0.12
	drow-cplus-branchpoint:1.27
	kseitz_interps-20020930-merge:1.27
	carlton_dictionary-20020927-merge:1.27
	carlton_dictionary-branch:1.27.0.10
	carlton_dictionary-20020920-branchpoint:1.27
	sid-20020905-branchpoint:1.27
	sid-20020905-branch:1.27.0.8
	gdb_5_3-branch:1.27.0.6
	gdb_5_3-2002-09-04-branchpoint:1.27
	kseitz_interps-20020829-merge:1.27
	cagney_sysregs-20020825-branch:1.27.0.4
	cagney_sysregs-20020825-branchpoint:1.27
	readline_4_3-import-branch:1.27.0.2
	readline_4_3-import-branchpoint:1.27
	binutils-2_13:1.26
	gdb_5_2_1-2002-07-23-release:1.17
	binutils-2_13-branchpoint:1.26
	binutils-2_13-branch:1.26.0.2
	kseitz_interps-20020528-branch:1.18.0.6
	kseitz_interps-20020528-branchpoint:1.18
	cagney_regbuf-20020515-branch:1.18.0.4
	cagney_regbuf-20020515-branchpoint:1.18
	binutils-2_12_1:1.17.2.1
	jimb-macro-020506-branch:1.18.0.2
	jimb-macro-020506-branchpoint:1.18
	gdb_5_2-2002-04-29-release:1.17
	binutils-2_12:1.17
	gdb_5_2-branch:1.17.0.4
	gdb_5_2-2002-03-03-branchpoint:1.17
	binutils-2_12-branch:1.17.0.2
	binutils-2_12-branchpoint:1.17
	gdb_5_1_1-2002-01-24-release:1.13
	gdb_5_1_0_1-2002-01-03-release:1.13
	cygnus_cvs_20020108_pre:1.17
	gdb_5_1_0_1-2002-01-03-branch:1.13.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.13
	gdb_5_1-2001-11-21-release:1.13
	gdb_s390-2001-09-26-branch:1.13.0.4
	gdb_s390-2001-09-26-branchpoint:1.13
	gdb_5_1-2001-07-29-branch:1.13.0.2
	gdb_5_1-2001-07-29-branchpoint:1.13
	binutils-2_11_2:1.10.2.3
	binutils-2_11_1:1.10.2.3
	binutils-2_11:1.10.2.2
	x86_64versiong3:1.12
	binutils-2_11-branch:1.10.0.2
	insight-precleanup-2001-01-01:1.8
	binutils_latest_snapshot:1.118
	gdb-premipsmulti-2000-06-06-branch:1.1.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.118
date	2013.08.31.11.31.42;	author danglin;	state Exp;
branches;
next	1.117;

1.117
date	2013.07.28.23.05.18;	author macro;	state Exp;
branches;
next	1.116;

1.116
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2013.02.21.03.02.30;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2013.02.21.02.29.09;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2013.02.10.04.01.15;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.110;

1.110
date	2012.12.17.16.55.38;	author nickc;	state Exp;
branches;
next	1.109;

1.109
date	2012.06.29.14.46.01;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2012.05.17.15.13.20;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	2012.05.07.03.27.51;	author macro;	state Exp;
branches;
next	1.106;

1.106
date	2012.04.24.05.12.35;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2011.07.28.13.22.26;	author nickc;	state Exp;
branches
	1.105.2.1;
next	1.104;

1.104
date	2011.07.03.13.37.06;	author tschwinge;	state Exp;
branches;
next	1.103;

1.103
date	2011.06.13.00.59.12;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2010.11.08.02.48.56;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2010.10.25.15.54.15;	author drow;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.99;

1.99
date	2010.09.24.12.14.25;	author tschwinge;	state Exp;
branches;
next	1.98;

1.98
date	2010.08.25.14.53.44;	author hjl;	state Exp;
branches;
next	1.97;

1.97
date	2010.08.18.12.24.06;	author palves;	state Exp;
branches;
next	1.96;

1.96
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2010.02.04.09.16.41;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	2009.12.11.13.42.03;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2009.11.08.20.47.24;	author danglin;	state Exp;
branches;
next	1.92;

1.92
date	2009.05.21.14.15.49;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.18.11.27.17;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.01.17.08.54;	author danglin;	state Exp;
branches;
next	1.89;

1.89
date	2009.03.01.02.10.49;	author danglin;	state Exp;
branches;
next	1.88;

1.88
date	2009.02.08.17.08.31;	author danglin;	state Exp;
branches;
next	1.87;

1.87
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2008.05.30.16.13.53;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2008.05.21.12.01.37;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2008.03.12.08.36.59;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2007.12.29.01.36.40;	author danglin;	state Exp;
branches;
next	1.82;

1.82
date	2007.10.16.15.15.50;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2007.07.10.04.08.11;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2007.03.14.02.56.45;	author hjl;	state Exp;
branches;
next	1.76;

1.76
date	2007.01.28.02.13.58;	author hjl;	state Exp;
branches;
next	1.75;

1.75
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2006.06.20.02.22.13;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2006.04.07.14.55.29;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2006.03.20.01.12.30;	author danglin;	state Exp;
branches
	1.70.2.1;
next	1.69;

1.69
date	2006.03.18.18.53.46;	author danglin;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2005.12.04.14.58.11;	author kettenis;	state Exp;
branches;
next	1.66;

1.66
date	2005.11.18.00.48.50;	author danglin;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.14.01.01.32;	author danglin;	state Exp;
branches;
next	1.64;

1.64
date	2005.07.29.02.46.03;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2005.07.08.06.20.02;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.08.00.26.51;	author hjl;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.05.06.23.37;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2005.07.04.01.53.40;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2005.05.07.13.22.52;	author hjl;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.05.14.33.55;	author hjl;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.04.15.53.24;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.04.11.00.17;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.04.07.19.24;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.20.23.36.18;	author hjl;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.02.01.39.00;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2004.10.10.13.58.05;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2004.09.17.07.14.28;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2004.09.16.14.52.06;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.24.04.46.21;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2004.03.25.12.48.38;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2004.03.15.17.53.45;	author danglin;	state Exp;
branches;
next	1.45;

1.45
date	2003.12.12.14.11.58;	author amodra;	state Exp;
branches
	1.45.6.1
	1.45.8.1
	1.45.12.1;
next	1.44;

1.44
date	2003.12.08.13.05.10;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.42;

1.42
date	2003.11.27.16.43.24;	author aoliva;	state Exp;
branches;
next	1.41;

1.41
date	2003.11.11.13.32.38;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.23.00.40.49;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.21.14.00.06;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2003.07.30.02.15.07;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2003.07.25.14.35.56;	author hjl;	state Exp;
branches;
next	1.34;

1.34
date	2003.07.18.21.09.28;	author rth;	state Exp;
branches;
next	1.33;

1.33
date	2003.06.25.06.40.23;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2003.05.09.02.27.05;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2003.02.17.18.24.40;	author nickc;	state Exp;
branches
	1.31.16.1;
next	1.30;

1.30
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.28.11.55.41;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.10.23.12.34.57;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.23.12.29.33;	author amodra;	state Exp;
branches
	1.27.10.1
	1.27.12.1;
next	1.26;

1.26
date	2002.07.07.09.10.40;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.27.22.57.02;	author law;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.23.09.05.59;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.16.15.32.08;	author law;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.12.18.12.25;	author law;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.06.00.29.21;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.06.05.13.32.01;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.06.04.00.51.07;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches
	1.18.4.1
	1.18.6.1;
next	1.17;

1.17
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.11.07.59.54;	author aj;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.03.02.41.58;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.31.13.28.50;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.30.13.40.08;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.14.11.12.52;	author amodra;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.01.14.05.22.51;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.09.01.54.51;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.12.01.28.06;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.05.02.30.24;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2000.08.21.23.41.32;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.20.03.21.59;	author hjl;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.12.05.03.01;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.09.07.23.07;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.24.08.17.57;	author law;	state Exp;
branches;
next	;

1.105.2.1
date	2012.05.11.12.24.29;	author nickc;	state Exp;
branches;
next	;

1.101.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	;

1.70.2.1
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	;

1.45.6.1
date	2004.03.15.18.12.05;	author danglin;	state Exp;
branches;
next	1.45.6.2;

1.45.6.2
date	2004.04.08.12.41.44;	author amodra;	state Exp;
branches;
next	;

1.45.8.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.45.8.2;

1.45.8.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.45.8.3;

1.45.8.3
date	2004.09.16.17.00.29;	author drow;	state Exp;
branches;
next	1.45.8.4;

1.45.8.4
date	2004.09.21.20.44.03;	author drow;	state Exp;
branches;
next	;

1.45.12.1
date	2004.03.21.23.57.27;	author cagney;	state Exp;
branches;
next	;

1.31.16.1
date	2003.05.18.09.43.44;	author kettenis;	state Exp;
branches;
next	;

1.27.10.1
date	2002.10.25.23.49.48;	author carlton;	state Exp;
branches;
next	1.27.10.2;

1.27.10.2
date	2002.12.23.19.37.47;	author carlton;	state Exp;
branches;
next	1.27.10.3;

1.27.10.3
date	2003.03.06.00.56.16;	author carlton;	state Exp;
branches;
next	1.27.10.4;

1.27.10.4
date	2003.05.23.18.40.25;	author carlton;	state Exp;
branches;
next	1.27.10.5;

1.27.10.5
date	2003.06.27.21.49.20;	author carlton;	state Exp;
branches;
next	1.27.10.6;

1.27.10.6
date	2003.08.05.17.12.50;	author carlton;	state Exp;
branches;
next	1.27.10.7;

1.27.10.7
date	2003.09.17.21.27.54;	author carlton;	state Exp;
branches;
next	1.27.10.8;

1.27.10.8
date	2003.11.11.23.50.22;	author carlton;	state Exp;
branches;
next	1.27.10.9;

1.27.10.9
date	2003.12.15.23.59.35;	author carlton;	state Exp;
branches;
next	;

1.27.12.1
date	2002.10.26.17.11.58;	author drow;	state Exp;
branches;
next	1.27.12.2;

1.27.12.2
date	2003.12.14.20.26.43;	author drow;	state Exp;
branches;
next	;

1.18.4.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	1.18.4.2;

1.18.4.2
date	2002.06.21.15.56.24;	author cagney;	state Exp;
branches;
next	;

1.18.6.1
date	2002.06.20.01.30.29;	author kseitz;	state Exp;
branches;
next	1.18.6.2;

1.18.6.2
date	2002.07.22.21.46.45;	author kseitz;	state Exp;
branches;
next	1.18.6.3;

1.18.6.3
date	2002.08.09.18.34.15;	author kseitz;	state Exp;
branches;
next	1.18.6.4;

1.18.6.4
date	2002.11.03.22.01.36;	author ezannoni;	state Exp;
branches;
next	;

1.17.2.1
date	2002.04.04.14.52.59;	author amodra;	state Exp;
branches;
next	;

1.10.2.1
date	2001.01.30.13.40.41;	author amodra;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.01.31.13.29.47;	author amodra;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.06.11.10.04.14;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.118
log
@2013-08-31  John David Anglin  <dave.anglin@@bell.net>

	* elf64-hppa.c (elf_hppa_final_link_relocate): Add missing '%' to
	format string.
@
text
@/* Support for HPPA 64-bit ELF
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "alloca-conf.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/hppa.h"
#include "libhppa.h"
#include "elf64-hppa.h"


#define ARCH_SIZE	       64

#define PLT_ENTRY_SIZE 0x10
#define DLT_ENTRY_SIZE 0x8
#define OPD_ENTRY_SIZE 0x20

#define ELF_DYNAMIC_INTERPRETER "/usr/lib/pa20_64/dld.sl"

/* The stub is supposed to load the target address and target's DP
   value out of the PLT, then do an external branch to the target
   address.

   LDD PLTOFF(%r27),%r1
   BVE (%r1)
   LDD PLTOFF+8(%r27),%r27

   Note that we must use the LDD with a 14 bit displacement, not the one
   with a 5 bit displacement.  */
static char plt_stub[] = {0x53, 0x61, 0x00, 0x00, 0xe8, 0x20, 0xd0, 0x00,
			  0x53, 0x7b, 0x00, 0x00 };

struct elf64_hppa_link_hash_entry
{
  struct elf_link_hash_entry eh;

  /* Offsets for this symbol in various linker sections.  */
  bfd_vma dlt_offset;
  bfd_vma plt_offset;
  bfd_vma opd_offset;
  bfd_vma stub_offset;

  /* The index of the (possibly local) symbol in the input bfd and its
     associated BFD.  Needed so that we can have relocs against local
     symbols in shared libraries.  */
  long sym_indx;
  bfd *owner;

  /* Dynamic symbols may need to have two different values.  One for
     the dynamic symbol table, one for the normal symbol table.

     In such cases we store the symbol's real value and section
     index here so we can restore the real value before we write
     the normal symbol table.  */
  bfd_vma st_value;
  int st_shndx;

  /* Used to count non-got, non-plt relocations for delayed sizing
     of relocation sections.  */
  struct elf64_hppa_dyn_reloc_entry
  {
    /* Next relocation in the chain.  */
    struct elf64_hppa_dyn_reloc_entry *next;

    /* The type of the relocation.  */
    int type;

    /* The input section of the relocation.  */
    asection *sec;

    /* Number of relocs copied in this section.  */
    bfd_size_type count;

    /* The index of the section symbol for the input section of
       the relocation.  Only needed when building shared libraries.  */
    int sec_symndx;

    /* The offset within the input section of the relocation.  */
    bfd_vma offset;

    /* The addend for the relocation.  */
    bfd_vma addend;

  } *reloc_entries;

  /* Nonzero if this symbol needs an entry in one of the linker
     sections.  */
  unsigned want_dlt;
  unsigned want_plt;
  unsigned want_opd;
  unsigned want_stub;
};

struct elf64_hppa_link_hash_table
{
  struct elf_link_hash_table root;

  /* Shortcuts to get to the various linker defined sections.  */
  asection *dlt_sec;
  asection *dlt_rel_sec;
  asection *plt_sec;
  asection *plt_rel_sec;
  asection *opd_sec;
  asection *opd_rel_sec;
  asection *other_rel_sec;

  /* Offset of __gp within .plt section.  When the PLT gets large we want
     to slide __gp into the PLT section so that we can continue to use
     single DP relative instructions to load values out of the PLT.  */
  bfd_vma gp_offset;

  /* Note this is not strictly correct.  We should create a stub section for
     each input section with calls.  The stub section should be placed before
     the section with the call.  */
  asection *stub_sec;

  bfd_vma text_segment_base;
  bfd_vma data_segment_base;

  /* We build tables to map from an input section back to its
     symbol index.  This is the BFD for which we currently have
     a map.  */
  bfd *section_syms_bfd;

  /* Array of symbol numbers for each input section attached to the
     current BFD.  */
  int *section_syms;
};

#define hppa_link_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == HPPA64_ELF_DATA ? ((struct elf64_hppa_link_hash_table *) ((p)->hash)) : NULL)

#define hppa_elf_hash_entry(ent) \
  ((struct elf64_hppa_link_hash_entry *)(ent))

#define eh_name(eh) \
  (eh ? eh->root.root.string : "<undef>")

typedef struct bfd_hash_entry *(*new_hash_entry_func)
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);

static struct bfd_link_hash_table *elf64_hppa_hash_table_create
  (bfd *abfd);

/* This must follow the definitions of the various derived linker
   hash tables and shared functions.  */
#include "elf-hppa.h"

static bfd_boolean elf64_hppa_object_p
  (bfd *);

static void elf64_hppa_post_process_headers
  (bfd *, struct bfd_link_info *);

static bfd_boolean elf64_hppa_create_dynamic_sections
  (bfd *, struct bfd_link_info *);

static bfd_boolean elf64_hppa_adjust_dynamic_symbol
  (struct bfd_link_info *, struct elf_link_hash_entry *);

static bfd_boolean elf64_hppa_mark_milli_and_exported_functions
  (struct elf_link_hash_entry *, void *);

static bfd_boolean elf64_hppa_size_dynamic_sections
  (bfd *, struct bfd_link_info *);

static int elf64_hppa_link_output_symbol_hook
  (struct bfd_link_info *, const char *, Elf_Internal_Sym *,
   asection *, struct elf_link_hash_entry *);

static bfd_boolean elf64_hppa_finish_dynamic_symbol
  (bfd *, struct bfd_link_info *,
   struct elf_link_hash_entry *, Elf_Internal_Sym *);

static bfd_boolean elf64_hppa_finish_dynamic_sections
  (bfd *, struct bfd_link_info *);

static bfd_boolean elf64_hppa_check_relocs
  (bfd *, struct bfd_link_info *,
   asection *, const Elf_Internal_Rela *);

static bfd_boolean elf64_hppa_dynamic_symbol_p
  (struct elf_link_hash_entry *, struct bfd_link_info *);

static bfd_boolean elf64_hppa_mark_exported_functions
  (struct elf_link_hash_entry *, void *);

static bfd_boolean elf64_hppa_finalize_opd
  (struct elf_link_hash_entry *, void *);

static bfd_boolean elf64_hppa_finalize_dlt
  (struct elf_link_hash_entry *, void *);

static bfd_boolean allocate_global_data_dlt
  (struct elf_link_hash_entry *, void *);

static bfd_boolean allocate_global_data_plt
  (struct elf_link_hash_entry *, void *);

static bfd_boolean allocate_global_data_stub
  (struct elf_link_hash_entry *, void *);

static bfd_boolean allocate_global_data_opd
  (struct elf_link_hash_entry *, void *);

static bfd_boolean get_reloc_section
  (bfd *, struct elf64_hppa_link_hash_table *, asection *);

static bfd_boolean count_dyn_reloc
  (bfd *, struct elf64_hppa_link_hash_entry *,
   int, asection *, int, bfd_vma, bfd_vma);

static bfd_boolean allocate_dynrel_entries
  (struct elf_link_hash_entry *, void *);

static bfd_boolean elf64_hppa_finalize_dynreloc
  (struct elf_link_hash_entry *, void *);

static bfd_boolean get_opd
  (bfd *, struct bfd_link_info *, struct elf64_hppa_link_hash_table *);

static bfd_boolean get_plt
  (bfd *, struct bfd_link_info *, struct elf64_hppa_link_hash_table *);

static bfd_boolean get_dlt
  (bfd *, struct bfd_link_info *, struct elf64_hppa_link_hash_table *);

static bfd_boolean get_stub
  (bfd *, struct bfd_link_info *, struct elf64_hppa_link_hash_table *);

static int elf64_hppa_elf_get_symbol_type
  (Elf_Internal_Sym *, int);

/* Initialize an entry in the link hash table.  */

static struct bfd_hash_entry *
hppa64_link_hash_newfunc (struct bfd_hash_entry *entry,
			  struct bfd_hash_table *table,
			  const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf64_hppa_link_hash_entry));
      if (entry == NULL)
        return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf64_hppa_link_hash_entry *hh;

      /* Initialize our local data.  All zeros.  */
      hh = hppa_elf_hash_entry (entry);
      memset (&hh->dlt_offset, 0,
	      (sizeof (struct elf64_hppa_link_hash_entry)
	       - offsetof (struct elf64_hppa_link_hash_entry, dlt_offset)));
    }

  return entry;
}

/* Create the derived linker hash table.  The PA64 ELF port uses this
   derived hash table to keep information specific to the PA ElF
   linker (without using static variables).  */

static struct bfd_link_hash_table*
elf64_hppa_hash_table_create (bfd *abfd)
{
  struct elf64_hppa_link_hash_table *htab;
  bfd_size_type amt = sizeof (*htab);

  htab = bfd_zmalloc (amt);
  if (htab == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&htab->root, abfd,
				      hppa64_link_hash_newfunc,
				      sizeof (struct elf64_hppa_link_hash_entry),
				      HPPA64_ELF_DATA))
    {
      free (htab);
      return NULL;
    }

  htab->text_segment_base = (bfd_vma) -1;
  htab->data_segment_base = (bfd_vma) -1;

  return &htab->root.root;
}

/* Return nonzero if ABFD represents a PA2.0 ELF64 file.

   Additionally we set the default architecture and machine.  */
static bfd_boolean
elf64_hppa_object_p (bfd *abfd)
{
  Elf_Internal_Ehdr * i_ehdrp;
  unsigned int flags;

  i_ehdrp = elf_elfheader (abfd);
  if (strcmp (bfd_get_target (abfd), "elf64-hppa-linux") == 0)
    {
      /* GCC on hppa-linux produces binaries with OSABI=GNU,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_GNU
	  && i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
	return FALSE;
    }
  else
    {
      /* HPUX produces binaries with OSABI=HPUX,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_HPUX
	  && i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
	return FALSE;
    }

  flags = i_ehdrp->e_flags;
  switch (flags & (EF_PARISC_ARCH | EF_PARISC_WIDE))
    {
    case EFA_PARISC_1_0:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 10);
    case EFA_PARISC_1_1:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 11);
    case EFA_PARISC_2_0:
      if (i_ehdrp->e_ident[EI_CLASS] == ELFCLASS64)
        return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 25);
      else
        return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 20);
    case EFA_PARISC_2_0 | EF_PARISC_WIDE:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 25);
    }
  /* Don't be fussy.  */
  return TRUE;
}

/* Given section type (hdr->sh_type), return a boolean indicating
   whether or not the section is an elf64-hppa specific section.  */
static bfd_boolean
elf64_hppa_section_from_shdr (bfd *abfd,
			      Elf_Internal_Shdr *hdr,
			      const char *name,
			      int shindex)
{
  switch (hdr->sh_type)
    {
    case SHT_PARISC_EXT:
      if (strcmp (name, ".PARISC.archext") != 0)
	return FALSE;
      break;
    case SHT_PARISC_UNWIND:
      if (strcmp (name, ".PARISC.unwind") != 0)
	return FALSE;
      break;
    case SHT_PARISC_DOC:
    case SHT_PARISC_ANNOT:
    default:
      return FALSE;
    }

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;

  return TRUE;
}

/* SEC is a section containing relocs for an input BFD when linking; return
   a suitable section for holding relocs in the output BFD for a link.  */

static bfd_boolean
get_reloc_section (bfd *abfd,
		   struct elf64_hppa_link_hash_table *hppa_info,
		   asection *sec)
{
  const char *srel_name;
  asection *srel;
  bfd *dynobj;

  srel_name = (bfd_elf_string_from_elf_section
	       (abfd, elf_elfheader(abfd)->e_shstrndx,
		_bfd_elf_single_rel_hdr(sec)->sh_name));
  if (srel_name == NULL)
    return FALSE;

  dynobj = hppa_info->root.dynobj;
  if (!dynobj)
    hppa_info->root.dynobj = dynobj = abfd;

  srel = bfd_get_linker_section (dynobj, srel_name);
  if (srel == NULL)
    {
      srel = bfd_make_section_anyway_with_flags (dynobj, srel_name,
						 (SEC_ALLOC
						  | SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED
						  | SEC_READONLY));
      if (srel == NULL
	  || !bfd_set_section_alignment (dynobj, srel, 3))
	return FALSE;
    }

  hppa_info->other_rel_sec = srel;
  return TRUE;
}

/* Add a new entry to the list of dynamic relocations against DYN_H.

   We use this to keep a record of all the FPTR relocations against a
   particular symbol so that we can create FPTR relocations in the
   output file.  */

static bfd_boolean
count_dyn_reloc (bfd *abfd,
		 struct elf64_hppa_link_hash_entry *hh,
		 int type,
		 asection *sec,
	         int sec_symndx,
	         bfd_vma offset,
		 bfd_vma addend)
{
  struct elf64_hppa_dyn_reloc_entry *rent;

  rent = (struct elf64_hppa_dyn_reloc_entry *)
  bfd_alloc (abfd, (bfd_size_type) sizeof (*rent));
  if (!rent)
    return FALSE;

  rent->next = hh->reloc_entries;
  rent->type = type;
  rent->sec = sec;
  rent->sec_symndx = sec_symndx;
  rent->offset = offset;
  rent->addend = addend;
  hh->reloc_entries = rent;

  return TRUE;
}

/* Return a pointer to the local DLT, PLT and OPD reference counts
   for ABFD.  Returns NULL if the storage allocation fails.  */

static bfd_signed_vma *
hppa64_elf_local_refcounts (bfd *abfd)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  bfd_signed_vma *local_refcounts;

  local_refcounts = elf_local_got_refcounts (abfd);
  if (local_refcounts == NULL)
    {
      bfd_size_type size;

      /* Allocate space for local DLT, PLT and OPD reference
	 counts.  Done this way to save polluting elf_obj_tdata
	 with another target specific pointer.  */
      size = symtab_hdr->sh_info;
      size *= 3 * sizeof (bfd_signed_vma);
      local_refcounts = bfd_zalloc (abfd, size);
      elf_local_got_refcounts (abfd) = local_refcounts;
    }
  return local_refcounts;
}

/* Scan the RELOCS and record the type of dynamic entries that each
   referenced symbol needs.  */

static bfd_boolean
elf64_hppa_check_relocs (bfd *abfd,
			 struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
{
  struct elf64_hppa_link_hash_table *hppa_info;
  const Elf_Internal_Rela *relend;
  Elf_Internal_Shdr *symtab_hdr;
  const Elf_Internal_Rela *rel;
  unsigned int sec_symndx;

  if (info->relocatable)
    return TRUE;

  /* If this is the first dynamic object found in the link, create
     the special sections required for dynamic linking.  */
  if (! elf_hash_table (info)->dynamic_sections_created)
    {
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	return FALSE;
    }

  hppa_info = hppa_link_hash_table (info);
  if (hppa_info == NULL)
    return FALSE;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* If necessary, build a new table holding section symbols indices
     for this BFD.  */

  if (info->shared && hppa_info->section_syms_bfd != abfd)
    {
      unsigned long i;
      unsigned int highest_shndx;
      Elf_Internal_Sym *local_syms = NULL;
      Elf_Internal_Sym *isym, *isymend;
      bfd_size_type amt;

      /* We're done with the old cache of section index to section symbol
	 index information.  Free it.

	 ?!? Note we leak the last section_syms array.  Presumably we
	 could free it in one of the later routines in this file.  */
      if (hppa_info->section_syms)
	free (hppa_info->section_syms);

      /* Read this BFD's local symbols.  */
      if (symtab_hdr->sh_info != 0)
	{
	  local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (local_syms == NULL)
	    local_syms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					       symtab_hdr->sh_info, 0,
					       NULL, NULL, NULL);
	  if (local_syms == NULL)
	    return FALSE;
	}

      /* Record the highest section index referenced by the local symbols.  */
      highest_shndx = 0;
      isymend = local_syms + symtab_hdr->sh_info;
      for (isym = local_syms; isym < isymend; isym++)
	{
	  if (isym->st_shndx > highest_shndx
	      && isym->st_shndx < SHN_LORESERVE)
	    highest_shndx = isym->st_shndx;
	}

      /* Allocate an array to hold the section index to section symbol index
	 mapping.  Bump by one since we start counting at zero.  */
      highest_shndx++;
      amt = highest_shndx;
      amt *= sizeof (int);
      hppa_info->section_syms = (int *) bfd_malloc (amt);

      /* Now walk the local symbols again.  If we find a section symbol,
	 record the index of the symbol into the section_syms array.  */
      for (i = 0, isym = local_syms; isym < isymend; i++, isym++)
	{
	  if (ELF_ST_TYPE (isym->st_info) == STT_SECTION)
	    hppa_info->section_syms[isym->st_shndx] = i;
	}

      /* We are finished with the local symbols.  */
      if (local_syms != NULL
	  && symtab_hdr->contents != (unsigned char *) local_syms)
	{
	  if (! info->keep_memory)
	    free (local_syms);
	  else
	    {
	      /* Cache the symbols for elf_link_input_bfd.  */
	      symtab_hdr->contents = (unsigned char *) local_syms;
	    }
	}

      /* Record which BFD we built the section_syms mapping for.  */
      hppa_info->section_syms_bfd = abfd;
    }

  /* Record the symbol index for this input section.  We may need it for
     relocations when building shared libraries.  When not building shared
     libraries this value is never really used, but assign it to zero to
     prevent out of bounds memory accesses in other routines.  */
  if (info->shared)
    {
      sec_symndx = _bfd_elf_section_from_bfd_section (abfd, sec);

      /* If we did not find a section symbol for this section, then
	 something went terribly wrong above.  */
      if (sec_symndx == SHN_BAD)
	return FALSE;

      if (sec_symndx < SHN_LORESERVE)
	sec_symndx = hppa_info->section_syms[sec_symndx];
      else
	sec_symndx = 0;
    }
  else
    sec_symndx = 0;

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; ++rel)
    {
      enum
	{
	  NEED_DLT = 1,
	  NEED_PLT = 2,
	  NEED_STUB = 4,
	  NEED_OPD = 8,
	  NEED_DYNREL = 16,
	};

      unsigned long r_symndx = ELF64_R_SYM (rel->r_info);
      struct elf64_hppa_link_hash_entry *hh;
      int need_entry;
      bfd_boolean maybe_dynamic;
      int dynrel_type = R_PARISC_NONE;
      static reloc_howto_type *howto;

      if (r_symndx >= symtab_hdr->sh_info)
	{
	  /* We're dealing with a global symbol -- find its hash entry
	     and mark it as being referenced.  */
	  long indx = r_symndx - symtab_hdr->sh_info;
	  hh = hppa_elf_hash_entry (elf_sym_hashes (abfd)[indx]);
	  while (hh->eh.root.type == bfd_link_hash_indirect
		 || hh->eh.root.type == bfd_link_hash_warning)
	    hh = hppa_elf_hash_entry (hh->eh.root.u.i.link);

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  hh->eh.root.non_ir_ref = 1;
	  hh->eh.ref_regular = 1;
	}
      else
	hh = NULL;

      /* We can only get preliminary data on whether a symbol is
	 locally or externally defined, as not all of the input files
	 have yet been processed.  Do something with what we know, as
	 this may help reduce memory usage and processing time later.  */
      maybe_dynamic = FALSE;
      if (hh && ((info->shared
		 && (!info->symbolic
		     || info->unresolved_syms_in_shared_libs == RM_IGNORE))
		|| !hh->eh.def_regular
		|| hh->eh.root.type == bfd_link_hash_defweak))
	maybe_dynamic = TRUE;

      howto = elf_hppa_howto_table + ELF64_R_TYPE (rel->r_info);
      need_entry = 0;
      switch (howto->type)
	{
	/* These are simple indirect references to symbols through the
	   DLT.  We need to create a DLT entry for any symbols which
	   appears in a DLTIND relocation.  */
	case R_PARISC_DLTIND21L:
	case R_PARISC_DLTIND14R:
	case R_PARISC_DLTIND14F:
	case R_PARISC_DLTIND14WR:
	case R_PARISC_DLTIND14DR:
	  need_entry = NEED_DLT;
	  break;

	/* ?!?  These need a DLT entry.  But I have no idea what to do with
	   the "link time TP value.  */
	case R_PARISC_LTOFF_TP21L:
	case R_PARISC_LTOFF_TP14R:
	case R_PARISC_LTOFF_TP14F:
	case R_PARISC_LTOFF_TP64:
	case R_PARISC_LTOFF_TP14WR:
	case R_PARISC_LTOFF_TP14DR:
	case R_PARISC_LTOFF_TP16F:
	case R_PARISC_LTOFF_TP16WF:
	case R_PARISC_LTOFF_TP16DF:
	  need_entry = NEED_DLT;
	  break;

	/* These are function calls.  Depending on their precise target we
	   may need to make a stub for them.  The stub uses the PLT, so we
	   need to create PLT entries for these symbols too.  */
	case R_PARISC_PCREL12F:
	case R_PARISC_PCREL17F:
	case R_PARISC_PCREL22F:
	case R_PARISC_PCREL32:
	case R_PARISC_PCREL64:
	case R_PARISC_PCREL21L:
	case R_PARISC_PCREL17R:
	case R_PARISC_PCREL17C:
	case R_PARISC_PCREL14R:
	case R_PARISC_PCREL14F:
	case R_PARISC_PCREL22C:
	case R_PARISC_PCREL14WR:
	case R_PARISC_PCREL14DR:
	case R_PARISC_PCREL16F:
	case R_PARISC_PCREL16WF:
	case R_PARISC_PCREL16DF:
	  /* Function calls might need to go through the .plt, and
	     might need a long branch stub.  */
	  if (hh != NULL && hh->eh.type != STT_PARISC_MILLI)
	    need_entry = (NEED_PLT | NEED_STUB);
	  else
	    need_entry = 0;
	  break;

	case R_PARISC_PLTOFF21L:
	case R_PARISC_PLTOFF14R:
	case R_PARISC_PLTOFF14F:
	case R_PARISC_PLTOFF14WR:
	case R_PARISC_PLTOFF14DR:
	case R_PARISC_PLTOFF16F:
	case R_PARISC_PLTOFF16WF:
	case R_PARISC_PLTOFF16DF:
	  need_entry = (NEED_PLT);
	  break;

	case R_PARISC_DIR64:
	  if (info->shared || maybe_dynamic)
	    need_entry = (NEED_DYNREL);
	  dynrel_type = R_PARISC_DIR64;
	  break;

	/* This is an indirect reference through the DLT to get the address
	   of a OPD descriptor.  Thus we need to make a DLT entry that points
	   to an OPD entry.  */
	case R_PARISC_LTOFF_FPTR21L:
	case R_PARISC_LTOFF_FPTR14R:
	case R_PARISC_LTOFF_FPTR14WR:
	case R_PARISC_LTOFF_FPTR14DR:
	case R_PARISC_LTOFF_FPTR32:
	case R_PARISC_LTOFF_FPTR64:
	case R_PARISC_LTOFF_FPTR16F:
	case R_PARISC_LTOFF_FPTR16WF:
	case R_PARISC_LTOFF_FPTR16DF:
	  if (info->shared || maybe_dynamic)
	    need_entry = (NEED_DLT | NEED_OPD | NEED_PLT);
	  else
	    need_entry = (NEED_DLT | NEED_OPD | NEED_PLT);
	  dynrel_type = R_PARISC_FPTR64;
	  break;

	/* This is a simple OPD entry.  */
	case R_PARISC_FPTR64:
	  if (info->shared || maybe_dynamic)
	    need_entry = (NEED_OPD | NEED_PLT | NEED_DYNREL);
	  else
	    need_entry = (NEED_OPD | NEED_PLT);
	  dynrel_type = R_PARISC_FPTR64;
	  break;

	/* Add more cases as needed.  */
	}

      if (!need_entry)
	continue;

      if (hh)
	{
	  /* Stash away enough information to be able to find this symbol
	     regardless of whether or not it is local or global.  */
	  hh->owner = abfd;
	  hh->sym_indx = r_symndx;
	}

      /* Create what's needed.  */
      if (need_entry & NEED_DLT)
	{
	  /* Allocate space for a DLT entry, as well as a dynamic
	     relocation for this entry.  */
	  if (! hppa_info->dlt_sec
	      && ! get_dlt (abfd, info, hppa_info))
	    goto err_out;

	  if (hh != NULL)
	    {
	      hh->want_dlt = 1;
	      hh->eh.got.refcount += 1;
	    }
	  else
	    {
	      bfd_signed_vma *local_dlt_refcounts;

	      /* This is a DLT entry for a local symbol.  */
	      local_dlt_refcounts = hppa64_elf_local_refcounts (abfd);
	      if (local_dlt_refcounts == NULL)
		return FALSE;
	      local_dlt_refcounts[r_symndx] += 1;
	    }
	}

      if (need_entry & NEED_PLT)
	{
	  if (! hppa_info->plt_sec
	      && ! get_plt (abfd, info, hppa_info))
	    goto err_out;

	  if (hh != NULL)
	    {
	      hh->want_plt = 1;
	      hh->eh.needs_plt = 1;
	      hh->eh.plt.refcount += 1;
	    }
	  else
	    {
	      bfd_signed_vma *local_dlt_refcounts;
	      bfd_signed_vma *local_plt_refcounts;

	      /* This is a PLT entry for a local symbol.  */
	      local_dlt_refcounts = hppa64_elf_local_refcounts (abfd);
	      if (local_dlt_refcounts == NULL)
		return FALSE;
	      local_plt_refcounts = local_dlt_refcounts + symtab_hdr->sh_info;
	      local_plt_refcounts[r_symndx] += 1;
	    }
	}

      if (need_entry & NEED_STUB)
	{
	  if (! hppa_info->stub_sec
	      && ! get_stub (abfd, info, hppa_info))
	    goto err_out;
	  if (hh)
	    hh->want_stub = 1;
	}

      if (need_entry & NEED_OPD)
	{
	  if (! hppa_info->opd_sec
	      && ! get_opd (abfd, info, hppa_info))
	    goto err_out;

	  /* FPTRs are not allocated by the dynamic linker for PA64,
	     though it is possible that will change in the future.  */

	  if (hh != NULL)
	    hh->want_opd = 1;
	  else
	    {
	      bfd_signed_vma *local_dlt_refcounts;
	      bfd_signed_vma *local_opd_refcounts;

	      /* This is a OPD for a local symbol.  */
	      local_dlt_refcounts = hppa64_elf_local_refcounts (abfd);
	      if (local_dlt_refcounts == NULL)
		return FALSE;
	      local_opd_refcounts = (local_dlt_refcounts
				     + 2 * symtab_hdr->sh_info);
	      local_opd_refcounts[r_symndx] += 1;
	    }
	}

      /* Add a new dynamic relocation to the chain of dynamic
	 relocations for this symbol.  */
      if ((need_entry & NEED_DYNREL) && (sec->flags & SEC_ALLOC))
	{
	  if (! hppa_info->other_rel_sec
	      && ! get_reloc_section (abfd, hppa_info, sec))
	    goto err_out;

	  /* Count dynamic relocations against global symbols.  */
	  if (hh != NULL
	      && !count_dyn_reloc (abfd, hh, dynrel_type, sec,
				   sec_symndx, rel->r_offset, rel->r_addend))
	    goto err_out;

	  /* If we are building a shared library and we just recorded
	     a dynamic R_PARISC_FPTR64 relocation, then make sure the
	     section symbol for this section ends up in the dynamic
	     symbol table.  */
	  if (info->shared && dynrel_type == R_PARISC_FPTR64
	      && ! (bfd_elf_link_record_local_dynamic_symbol
		    (info, abfd, sec_symndx)))
	    return FALSE;
	}
    }

  return TRUE;

 err_out:
  return FALSE;
}

struct elf64_hppa_allocate_data
{
  struct bfd_link_info *info;
  bfd_size_type ofs;
};

/* Should we do dynamic things to this symbol?  */

static bfd_boolean
elf64_hppa_dynamic_symbol_p (struct elf_link_hash_entry *eh,
			     struct bfd_link_info *info)
{
  /* ??? What, if anything, needs to happen wrt STV_PROTECTED symbols
     and relocations that retrieve a function descriptor?  Assume the
     worst for now.  */
  if (_bfd_elf_dynamic_symbol_p (eh, info, 1))
    {
      /* ??? Why is this here and not elsewhere is_local_label_name.  */
      if (eh->root.root.string[0] == '$' && eh->root.root.string[1] == '$')
	return FALSE;

      return TRUE;
    }
  else
    return FALSE;
}

/* Mark all functions exported by this file so that we can later allocate
   entries in .opd for them.  */

static bfd_boolean
elf64_hppa_mark_exported_functions (struct elf_link_hash_entry *eh, void *data)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  struct bfd_link_info *info = (struct bfd_link_info *)data;
  struct elf64_hppa_link_hash_table *hppa_info;

  hppa_info = hppa_link_hash_table (info);
  if (hppa_info == NULL)
    return FALSE;

  if (eh
      && (eh->root.type == bfd_link_hash_defined
	  || eh->root.type == bfd_link_hash_defweak)
      && eh->root.u.def.section->output_section != NULL
      && eh->type == STT_FUNC)
    {
      if (! hppa_info->opd_sec
	  && ! get_opd (hppa_info->root.dynobj, info, hppa_info))
	return FALSE;

      hh->want_opd = 1;

      /* Put a flag here for output_symbol_hook.  */
      hh->st_shndx = -1;
      eh->needs_plt = 1;
    }

  return TRUE;
}

/* Allocate space for a DLT entry.  */

static bfd_boolean
allocate_global_data_dlt (struct elf_link_hash_entry *eh, void *data)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  struct elf64_hppa_allocate_data *x = (struct elf64_hppa_allocate_data *)data;

  if (hh->want_dlt)
    {
      if (x->info->shared)
	{
	  /* Possibly add the symbol to the local dynamic symbol
	     table since we might need to create a dynamic relocation
	     against it.  */
	  if (eh->dynindx == -1 && eh->type != STT_PARISC_MILLI)
	    {
	      bfd *owner = eh->root.u.def.section->owner;

	      if (! (bfd_elf_link_record_local_dynamic_symbol
		     (x->info, owner, hh->sym_indx)))
		return FALSE;
	    }
	}

      hh->dlt_offset = x->ofs;
      x->ofs += DLT_ENTRY_SIZE;
    }
  return TRUE;
}

/* Allocate space for a DLT.PLT entry.  */

static bfd_boolean
allocate_global_data_plt (struct elf_link_hash_entry *eh, void *data)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  struct elf64_hppa_allocate_data *x = (struct elf64_hppa_allocate_data *) data;

  if (hh->want_plt
      && elf64_hppa_dynamic_symbol_p (eh, x->info)
      && !((eh->root.type == bfd_link_hash_defined
	    || eh->root.type == bfd_link_hash_defweak)
	   && eh->root.u.def.section->output_section != NULL))
    {
      hh->plt_offset = x->ofs;
      x->ofs += PLT_ENTRY_SIZE;
      if (hh->plt_offset < 0x2000)
	{
	  struct elf64_hppa_link_hash_table *hppa_info;

	  hppa_info = hppa_link_hash_table (x->info);
	  if (hppa_info == NULL)
	    return FALSE;

	  hppa_info->gp_offset = hh->plt_offset;
	}
    }
  else
    hh->want_plt = 0;

  return TRUE;
}

/* Allocate space for a STUB entry.  */

static bfd_boolean
allocate_global_data_stub (struct elf_link_hash_entry *eh, void *data)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  struct elf64_hppa_allocate_data *x = (struct elf64_hppa_allocate_data *)data;

  if (hh->want_stub
      && elf64_hppa_dynamic_symbol_p (eh, x->info)
      && !((eh->root.type == bfd_link_hash_defined
	    || eh->root.type == bfd_link_hash_defweak)
	   && eh->root.u.def.section->output_section != NULL))
    {
      hh->stub_offset = x->ofs;
      x->ofs += sizeof (plt_stub);
    }
  else
    hh->want_stub = 0;
  return TRUE;
}

/* Allocate space for a FPTR entry.  */

static bfd_boolean
allocate_global_data_opd (struct elf_link_hash_entry *eh, void *data)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  struct elf64_hppa_allocate_data *x = (struct elf64_hppa_allocate_data *)data;

  if (hh && hh->want_opd)
    {
      /* We never need an opd entry for a symbol which is not
	 defined by this output file.  */
      if (hh && (hh->eh.root.type == bfd_link_hash_undefined
		 || hh->eh.root.type == bfd_link_hash_undefweak
		 || hh->eh.root.u.def.section->output_section == NULL))
	hh->want_opd = 0;

      /* If we are creating a shared library, took the address of a local
	 function or might export this function from this object file, then
	 we have to create an opd descriptor.  */
      else if (x->info->shared
	       || hh == NULL
	       || (hh->eh.dynindx == -1 && hh->eh.type != STT_PARISC_MILLI)
	       || (hh->eh.root.type == bfd_link_hash_defined
		   || hh->eh.root.type == bfd_link_hash_defweak))
	{
	  /* If we are creating a shared library, then we will have to
	     create a runtime relocation for the symbol to properly
	     initialize the .opd entry.  Make sure the symbol gets
	     added to the dynamic symbol table.  */
	  if (x->info->shared
	      && (hh == NULL || (hh->eh.dynindx == -1)))
	    {
	      bfd *owner;
	      /* PR 6511: Default to using the dynamic symbol table.  */
	      owner = (hh->owner ? hh->owner: eh->root.u.def.section->owner);

	      if (!bfd_elf_link_record_local_dynamic_symbol
		    (x->info, owner, hh->sym_indx))
		return FALSE;
	    }

	  /* This may not be necessary or desirable anymore now that
	     we have some support for dealing with section symbols
	     in dynamic relocs.  But name munging does make the result
	     much easier to debug.  ie, the EPLT reloc will reference
	     a symbol like .foobar, instead of .text + offset.  */
	  if (x->info->shared && eh)
	    {
	      char *new_name;
	      struct elf_link_hash_entry *nh;

	      new_name = alloca (strlen (eh->root.root.string) + 2);
	      new_name[0] = '.';
	      strcpy (new_name + 1, eh->root.root.string);

	      nh = elf_link_hash_lookup (elf_hash_table (x->info),
					 new_name, TRUE, TRUE, TRUE);

	      nh->root.type = eh->root.type;
	      nh->root.u.def.value = eh->root.u.def.value;
	      nh->root.u.def.section = eh->root.u.def.section;

	      if (! bfd_elf_link_record_dynamic_symbol (x->info, nh))
		return FALSE;

	     }
	  hh->opd_offset = x->ofs;
	  x->ofs += OPD_ENTRY_SIZE;
	}

      /* Otherwise we do not need an opd entry.  */
      else
	hh->want_opd = 0;
    }
  return TRUE;
}

/* HP requires the EI_OSABI field to be filled in.  The assignment to
   EI_ABIVERSION may not be strictly necessary.  */

static void
elf64_hppa_post_process_headers (bfd *abfd,
			 struct bfd_link_info *link_info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr * i_ehdrp;

  i_ehdrp = elf_elfheader (abfd);

  i_ehdrp->e_ident[EI_OSABI] = get_elf_backend_data (abfd)->elf_osabi;
  i_ehdrp->e_ident[EI_ABIVERSION] = 1;
}

/* Create function descriptor section (.opd).  This section is called .opd
   because it contains "official procedure descriptors".  The "official"
   refers to the fact that these descriptors are used when taking the address
   of a procedure, thus ensuring a unique address for each procedure.  */

static bfd_boolean
get_opd (bfd *abfd,
	 struct bfd_link_info *info ATTRIBUTE_UNUSED,
	 struct elf64_hppa_link_hash_table *hppa_info)
{
  asection *opd;
  bfd *dynobj;

  opd = hppa_info->opd_sec;
  if (!opd)
    {
      dynobj = hppa_info->root.dynobj;
      if (!dynobj)
	hppa_info->root.dynobj = dynobj = abfd;

      opd = bfd_make_section_anyway_with_flags (dynobj, ".opd",
						(SEC_ALLOC
						 | SEC_LOAD
						 | SEC_HAS_CONTENTS
						 | SEC_IN_MEMORY
						 | SEC_LINKER_CREATED));
      if (!opd
	  || !bfd_set_section_alignment (abfd, opd, 3))
	{
	  BFD_ASSERT (0);
	  return FALSE;
	}

      hppa_info->opd_sec = opd;
    }

  return TRUE;
}

/* Create the PLT section.  */

static bfd_boolean
get_plt (bfd *abfd,
	 struct bfd_link_info *info ATTRIBUTE_UNUSED,
	 struct elf64_hppa_link_hash_table *hppa_info)
{
  asection *plt;
  bfd *dynobj;

  plt = hppa_info->plt_sec;
  if (!plt)
    {
      dynobj = hppa_info->root.dynobj;
      if (!dynobj)
	hppa_info->root.dynobj = dynobj = abfd;

      plt = bfd_make_section_anyway_with_flags (dynobj, ".plt",
						(SEC_ALLOC
						 | SEC_LOAD
						 | SEC_HAS_CONTENTS
						 | SEC_IN_MEMORY
						 | SEC_LINKER_CREATED));
      if (!plt
	  || !bfd_set_section_alignment (abfd, plt, 3))
	{
	  BFD_ASSERT (0);
	  return FALSE;
	}

      hppa_info->plt_sec = plt;
    }

  return TRUE;
}

/* Create the DLT section.  */

static bfd_boolean
get_dlt (bfd *abfd,
	 struct bfd_link_info *info ATTRIBUTE_UNUSED,
	 struct elf64_hppa_link_hash_table *hppa_info)
{
  asection *dlt;
  bfd *dynobj;

  dlt = hppa_info->dlt_sec;
  if (!dlt)
    {
      dynobj = hppa_info->root.dynobj;
      if (!dynobj)
	hppa_info->root.dynobj = dynobj = abfd;

      dlt = bfd_make_section_anyway_with_flags (dynobj, ".dlt",
						(SEC_ALLOC
						 | SEC_LOAD
						 | SEC_HAS_CONTENTS
						 | SEC_IN_MEMORY
						 | SEC_LINKER_CREATED));
      if (!dlt
	  || !bfd_set_section_alignment (abfd, dlt, 3))
	{
	  BFD_ASSERT (0);
	  return FALSE;
	}

      hppa_info->dlt_sec = dlt;
    }

  return TRUE;
}

/* Create the stubs section.  */

static bfd_boolean
get_stub (bfd *abfd,
	  struct bfd_link_info *info ATTRIBUTE_UNUSED,
	  struct elf64_hppa_link_hash_table *hppa_info)
{
  asection *stub;
  bfd *dynobj;

  stub = hppa_info->stub_sec;
  if (!stub)
    {
      dynobj = hppa_info->root.dynobj;
      if (!dynobj)
	hppa_info->root.dynobj = dynobj = abfd;

      stub = bfd_make_section_anyway_with_flags (dynobj, ".stub",
						 (SEC_ALLOC | SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_READONLY
						  | SEC_LINKER_CREATED));
      if (!stub
	  || !bfd_set_section_alignment (abfd, stub, 3))
	{
	  BFD_ASSERT (0);
	  return FALSE;
	}

      hppa_info->stub_sec = stub;
    }

  return TRUE;
}

/* Create sections necessary for dynamic linking.  This is only a rough
   cut and will likely change as we learn more about the somewhat
   unusual dynamic linking scheme HP uses.

   .stub:
	Contains code to implement cross-space calls.  The first time one
	of the stubs is used it will call into the dynamic linker, later
	calls will go straight to the target.

	The only stub we support right now looks like

	ldd OFFSET(%dp),%r1
	bve %r0(%r1)
	ldd OFFSET+8(%dp),%dp

	Other stubs may be needed in the future.  We may want the remove
	the break/nop instruction.  It is only used right now to keep the
	offset of a .plt entry and a .stub entry in sync.

   .dlt:
	This is what most people call the .got.  HP used a different name.
	Losers.

   .rela.dlt:
	Relocations for the DLT.

   .plt:
	Function pointers as address,gp pairs.

   .rela.plt:
	Should contain dynamic IPLT (and EPLT?) relocations.

   .opd:
	FPTRS

   .rela.opd:
	EPLT relocations for symbols exported from shared libraries.  */

static bfd_boolean
elf64_hppa_create_dynamic_sections (bfd *abfd,
				    struct bfd_link_info *info)
{
  asection *s;
  struct elf64_hppa_link_hash_table *hppa_info;

  hppa_info = hppa_link_hash_table (info);
  if (hppa_info == NULL)
    return FALSE;

  if (! get_stub (abfd, info, hppa_info))
    return FALSE;

  if (! get_dlt (abfd, info, hppa_info))
    return FALSE;

  if (! get_plt (abfd, info, hppa_info))
    return FALSE;

  if (! get_opd (abfd, info, hppa_info))
    return FALSE;

  s = bfd_make_section_anyway_with_flags (abfd, ".rela.dlt",
					  (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_READONLY
					   | SEC_LINKER_CREATED));
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;
  hppa_info->dlt_rel_sec = s;

  s = bfd_make_section_anyway_with_flags (abfd, ".rela.plt",
					  (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_READONLY
					   | SEC_LINKER_CREATED));
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;
  hppa_info->plt_rel_sec = s;

  s = bfd_make_section_anyway_with_flags (abfd, ".rela.data",
					  (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_READONLY
					   | SEC_LINKER_CREATED));
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;
  hppa_info->other_rel_sec = s;

  s = bfd_make_section_anyway_with_flags (abfd, ".rela.opd",
					  (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_READONLY
					   | SEC_LINKER_CREATED));
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 3))
    return FALSE;
  hppa_info->opd_rel_sec = s;

  return TRUE;
}

/* Allocate dynamic relocations for those symbols that turned out
   to be dynamic.  */

static bfd_boolean
allocate_dynrel_entries (struct elf_link_hash_entry *eh, void *data)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  struct elf64_hppa_allocate_data *x = (struct elf64_hppa_allocate_data *)data;
  struct elf64_hppa_link_hash_table *hppa_info;
  struct elf64_hppa_dyn_reloc_entry *rent;
  bfd_boolean dynamic_symbol, shared;

  hppa_info = hppa_link_hash_table (x->info);
  if (hppa_info == NULL)
    return FALSE;

  dynamic_symbol = elf64_hppa_dynamic_symbol_p (eh, x->info);
  shared = x->info->shared;

  /* We may need to allocate relocations for a non-dynamic symbol
     when creating a shared library.  */
  if (!dynamic_symbol && !shared)
    return TRUE;

  /* Take care of the normal data relocations.  */

  for (rent = hh->reloc_entries; rent; rent = rent->next)
    {
      /* Allocate one iff we are building a shared library, the relocation
	 isn't a R_PARISC_FPTR64, or we don't want an opd entry.  */
      if (!shared && rent->type == R_PARISC_FPTR64 && hh->want_opd)
	continue;

      hppa_info->other_rel_sec->size += sizeof (Elf64_External_Rela);

      /* Make sure this symbol gets into the dynamic symbol table if it is
	 not already recorded.  ?!? This should not be in the loop since
	 the symbol need only be added once.  */
      if (eh->dynindx == -1 && eh->type != STT_PARISC_MILLI)
	if (!bfd_elf_link_record_local_dynamic_symbol
	    (x->info, rent->sec->owner, hh->sym_indx))
	  return FALSE;
    }

  /* Take care of the GOT and PLT relocations.  */

  if ((dynamic_symbol || shared) && hh->want_dlt)
    hppa_info->dlt_rel_sec->size += sizeof (Elf64_External_Rela);

  /* If we are building a shared library, then every symbol that has an
     opd entry will need an EPLT relocation to relocate the symbol's address
     and __gp value based on the runtime load address.  */
  if (shared && hh->want_opd)
    hppa_info->opd_rel_sec->size += sizeof (Elf64_External_Rela);

  if (hh->want_plt && dynamic_symbol)
    {
      bfd_size_type t = 0;

      /* Dynamic symbols get one IPLT relocation.  Local symbols in
	 shared libraries get two REL relocations.  Local symbols in
	 main applications get nothing.  */
      if (dynamic_symbol)
	t = sizeof (Elf64_External_Rela);
      else if (shared)
	t = 2 * sizeof (Elf64_External_Rela);

      hppa_info->plt_rel_sec->size += t;
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  */

static bfd_boolean
elf64_hppa_adjust_dynamic_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				  struct elf_link_hash_entry *eh)
{
  /* ??? Undefined symbols with PLT entries should be re-defined
     to be the PLT entry.  */

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (eh->u.weakdef != NULL)
    {
      BFD_ASSERT (eh->u.weakdef->root.type == bfd_link_hash_defined
		  || eh->u.weakdef->root.type == bfd_link_hash_defweak);
      eh->root.u.def.section = eh->u.weakdef->root.u.def.section;
      eh->root.u.def.value = eh->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* If this is a reference to a symbol defined by a dynamic object which
     is not a function, we might allocate the symbol in our .dynbss section
     and allocate a COPY dynamic relocation.

     But PA64 code is canonically PIC, so as a rule we can avoid this sort
     of hackery.  */

  return TRUE;
}

/* This function is called via elf_link_hash_traverse to mark millicode
   symbols with a dynindx of -1 and to remove the string table reference
   from the dynamic symbol table.  If the symbol is not a millicode symbol,
   elf64_hppa_mark_exported_functions is called.  */

static bfd_boolean
elf64_hppa_mark_milli_and_exported_functions (struct elf_link_hash_entry *eh,
					      void *data)
{
  struct bfd_link_info *info = (struct bfd_link_info *) data;

  if (eh->type == STT_PARISC_MILLI)
    {
      if (eh->dynindx != -1)
	{
	  eh->dynindx = -1;
	  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				  eh->dynstr_index);
	}
      return TRUE;
    }

  return elf64_hppa_mark_exported_functions (eh, data);
}

/* Set the final sizes of the dynamic sections and allocate memory for
   the contents of our special sections.  */

static bfd_boolean
elf64_hppa_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  struct elf64_hppa_link_hash_table *hppa_info;
  struct elf64_hppa_allocate_data data;
  bfd *dynobj;
  bfd *ibfd;
  asection *sec;
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;

  hppa_info = hppa_link_hash_table (info);
  if (hppa_info == NULL)
    return FALSE;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  /* Mark each function this program exports so that we will allocate
     space in the .opd section for each function's FPTR.  If we are
     creating dynamic sections, change the dynamic index of millicode
     symbols to -1 and remove them from the string table for .dynstr.

     We have to traverse the main linker hash table since we have to
     find functions which may not have been mentioned in any relocs.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  (elf_hash_table (info)->dynamic_sections_created
			   ? elf64_hppa_mark_milli_and_exported_functions
			   : elf64_hppa_mark_exported_functions),
			  info);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  sec = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (sec != NULL);
	  sec->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  sec->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }
  else
    {
      /* We may have created entries in the .rela.got section.
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.dlt,
	 which will cause it to get stripped from the output file
	 below.  */
      sec = bfd_get_linker_section (dynobj, ".rela.dlt");
      if (sec != NULL)
	sec->size = 0;
    }

  /* Set up DLT, PLT and OPD offsets for local syms, and space for local
     dynamic relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_dlt;
      bfd_signed_vma *end_local_dlt;
      bfd_signed_vma *local_plt;
      bfd_signed_vma *end_local_plt;
      bfd_signed_vma *local_opd;
      bfd_signed_vma *end_local_opd;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	{
	  struct elf64_hppa_dyn_reloc_entry *hdh_p;

	  for (hdh_p = ((struct elf64_hppa_dyn_reloc_entry *)
		    elf_section_data (sec)->local_dynrel);
	       hdh_p != NULL;
	       hdh_p = hdh_p->next)
	    {
	      if (!bfd_is_abs_section (hdh_p->sec)
		  && bfd_is_abs_section (hdh_p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (hdh_p->count != 0)
		{
		  srel = elf_section_data (hdh_p->sec)->sreloc;
		  srel->size += hdh_p->count * sizeof (Elf64_External_Rela);
		  if ((hdh_p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_dlt = elf_local_got_refcounts (ibfd);
      if (!local_dlt)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_dlt = local_dlt + locsymcount;
      sec = hppa_info->dlt_sec;
      srel = hppa_info->dlt_rel_sec;
      for (; local_dlt < end_local_dlt; ++local_dlt)
	{
	  if (*local_dlt > 0)
	    {
	      *local_dlt = sec->size;
	      sec->size += DLT_ENTRY_SIZE;
	      if (info->shared)
	        {
		  srel->size += sizeof (Elf64_External_Rela);
	        }
	    }
	  else
	    *local_dlt = (bfd_vma) -1;
	}

      local_plt = end_local_dlt;
      end_local_plt = local_plt + locsymcount;
      if (! hppa_info->root.dynamic_sections_created)
	{
	  /* Won't be used, but be safe.  */
	  for (; local_plt < end_local_plt; ++local_plt)
	    *local_plt = (bfd_vma) -1;
	}
      else
	{
	  sec = hppa_info->plt_sec;
	  srel = hppa_info->plt_rel_sec;
	  for (; local_plt < end_local_plt; ++local_plt)
	    {
	      if (*local_plt > 0)
		{
		  *local_plt = sec->size;
		  sec->size += PLT_ENTRY_SIZE;
		  if (info->shared)
		    srel->size += sizeof (Elf64_External_Rela);
		}
	      else
		*local_plt = (bfd_vma) -1;
	    }
	}

      local_opd = end_local_plt;
      end_local_opd = local_opd + locsymcount;
      if (! hppa_info->root.dynamic_sections_created)
	{
	  /* Won't be used, but be safe.  */
	  for (; local_opd < end_local_opd; ++local_opd)
	    *local_opd = (bfd_vma) -1;
	}
      else
	{
	  sec = hppa_info->opd_sec;
	  srel = hppa_info->opd_rel_sec;
	  for (; local_opd < end_local_opd; ++local_opd)
	    {
	      if (*local_opd > 0)
		{
		  *local_opd = sec->size;
		  sec->size += OPD_ENTRY_SIZE;
		  if (info->shared)
		    srel->size += sizeof (Elf64_External_Rela);
		}
	      else
		*local_opd = (bfd_vma) -1;
	    }
	}
    }

  /* Allocate the GOT entries.  */

  data.info = info;
  if (hppa_info->dlt_sec)
    {
      data.ofs = hppa_info->dlt_sec->size;
      elf_link_hash_traverse (elf_hash_table (info),
			      allocate_global_data_dlt, &data);
      hppa_info->dlt_sec->size = data.ofs;
    }

  if (hppa_info->plt_sec)
    {
      data.ofs = hppa_info->plt_sec->size;
      elf_link_hash_traverse (elf_hash_table (info),
		              allocate_global_data_plt, &data);
      hppa_info->plt_sec->size = data.ofs;
    }

  if (hppa_info->stub_sec)
    {
      data.ofs = 0x0;
      elf_link_hash_traverse (elf_hash_table (info),
			      allocate_global_data_stub, &data);
      hppa_info->stub_sec->size = data.ofs;
    }

  /* Allocate space for entries in the .opd section.  */
  if (hppa_info->opd_sec)
    {
      data.ofs = hppa_info->opd_sec->size;
      elf_link_hash_traverse (elf_hash_table (info),
			      allocate_global_data_opd, &data);
      hppa_info->opd_sec->size = data.ofs;
    }

  /* Now allocate space for dynamic relocations, if necessary.  */
  if (hppa_info->root.dynamic_sections_created)
    elf_link_hash_traverse (elf_hash_table (info),
			    allocate_dynrel_entries, &data);

  /* The sizes of all the sections are set.  Allocate memory for them.  */
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
  for (sec = dynobj->sections; sec != NULL; sec = sec->next)
    {
      const char *name;

      if ((sec->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, sec);

      if (strcmp (name, ".plt") == 0)
	{
	  /* Remember whether there is a PLT.  */
	  plt = sec->size != 0;
	}
      else if (strcmp (name, ".opd") == 0
	       || CONST_STRNEQ (name, ".dlt")
	       || strcmp (name, ".stub") == 0
	       || strcmp (name, ".got") == 0)
	{
	  /* Strip this section if we don't need it; see the comment below.  */
	}
      else if (CONST_STRNEQ (name, ".rela"))
	{
	  if (sec->size != 0)
	    {
	      asection *target;

	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
	      if (strcmp (name, ".rela.plt") != 0)
		{
		  const char *outname;

		  relocs = TRUE;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rela.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  sec->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 4);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = TRUE;
		}

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      sec->reloc_count = 0;
	    }
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (sec->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  sec->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((sec->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents if it has not
	 been allocated already.  We use bfd_zalloc here in case
	 unused entries are not reclaimed before the section's
	 contents are written out.  This should not happen, but this
	 way if it does, we get a R_PARISC_NONE reloc instead of
	 garbage.  */
      if (sec->contents == NULL)
	{
	  sec->contents = (bfd_byte *) bfd_zalloc (dynobj, sec->size);
	  if (sec->contents == NULL)
	    return FALSE;
	}
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Always create a DT_PLTGOT.  It actually has nothing to do with
	 the PLT, it is how we communicate the __gp value of a load
	 module to the dynamic linker.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (!add_dynamic_entry (DT_HP_DLD_FLAGS, 0)
	  || !add_dynamic_entry (DT_PLTGOT, 0))
	return FALSE;

      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf64_hppa_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
      if (! info->shared)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0)
	      || !add_dynamic_entry (DT_HP_DLD_HOOK, 0)
	      || !add_dynamic_entry (DT_HP_LOAD_MAP, 0))
	    return FALSE;
	}

      /* Force DT_FLAGS to always be set.
	 Required by HPUX 11.00 patch PHSS_26559.  */
      if (!add_dynamic_entry (DT_FLAGS, (info)->flags))
	return FALSE;

      if (plt)
	{
	  if (!add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
	    return FALSE;
	}

      if (reltext)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	  info->flags |= DF_TEXTREL;
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Called after we have output the symbol into the dynamic symbol
   table, but before we output the symbol into the normal symbol
   table.

   For some symbols we had to change their address when outputting
   the dynamic symbol table.  We undo that change here so that
   the symbols have their expected value in the normal symbol
   table.  Ick.  */

static int
elf64_hppa_link_output_symbol_hook (struct bfd_link_info *info ATTRIBUTE_UNUSED,
				    const char *name,
				    Elf_Internal_Sym *sym,
				    asection *input_sec ATTRIBUTE_UNUSED,
				    struct elf_link_hash_entry *eh)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);

  /* We may be called with the file symbol or section symbols.
     They never need munging, so it is safe to ignore them.  */
  if (!name || !eh)
    return 1;

  /* Function symbols for which we created .opd entries *may* have been
     munged by finish_dynamic_symbol and have to be un-munged here.

     Note that finish_dynamic_symbol sometimes turns dynamic symbols
     into non-dynamic ones, so we initialize st_shndx to -1 in
     mark_exported_functions and check to see if it was overwritten
     here instead of just checking eh->dynindx.  */
  if (hh->want_opd && hh->st_shndx != -1)
    {
      /* Restore the saved value and section index.  */
      sym->st_value = hh->st_value;
      sym->st_shndx = hh->st_shndx;
    }

  return 1;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf64_hppa_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *eh,
				  Elf_Internal_Sym *sym)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  asection *stub, *splt, *sopd, *spltrel;
  struct elf64_hppa_link_hash_table *hppa_info;

  hppa_info = hppa_link_hash_table (info);
  if (hppa_info == NULL)
    return FALSE;

  stub = hppa_info->stub_sec;
  splt = hppa_info->plt_sec;
  sopd = hppa_info->opd_sec;
  spltrel = hppa_info->plt_rel_sec;

  /* Incredible.  It is actually necessary to NOT use the symbol's real
     value when building the dynamic symbol table for a shared library.
     At least for symbols that refer to functions.

     We will store a new value and section index into the symbol long
     enough to output it into the dynamic symbol table, then we restore
     the original values (in elf64_hppa_link_output_symbol_hook).  */
  if (hh->want_opd)
    {
      BFD_ASSERT (sopd != NULL);

      /* Save away the original value and section index so that we
	 can restore them later.  */
      hh->st_value = sym->st_value;
      hh->st_shndx = sym->st_shndx;

      /* For the dynamic symbol table entry, we want the value to be
	 address of this symbol's entry within the .opd section.  */
      sym->st_value = (hh->opd_offset
		       + sopd->output_offset
		       + sopd->output_section->vma);
      sym->st_shndx = _bfd_elf_section_from_bfd_section (output_bfd,
							 sopd->output_section);
    }

  /* Initialize a .plt entry if requested.  */
  if (hh->want_plt
      && elf64_hppa_dynamic_symbol_p (eh, info))
    {
      bfd_vma value;
      Elf_Internal_Rela rel;
      bfd_byte *loc;

      BFD_ASSERT (splt != NULL && spltrel != NULL);

      /* We do not actually care about the value in the PLT entry
	 if we are creating a shared library and the symbol is
	 still undefined, we create a dynamic relocation to fill
	 in the correct value.  */
      if (info->shared && eh->root.type == bfd_link_hash_undefined)
	value = 0;
      else
	value = (eh->root.u.def.value + eh->root.u.def.section->vma);

      /* Fill in the entry in the procedure linkage table.

	 The format of a plt entry is
	 <funcaddr> <__gp>.

	 plt_offset is the offset within the PLT section at which to
	 install the PLT entry.

	 We are modifying the in-memory PLT contents here, so we do not add
	 in the output_offset of the PLT section.  */

      bfd_put_64 (splt->owner, value, splt->contents + hh->plt_offset);
      value = _bfd_get_gp_value (splt->output_section->owner);
      bfd_put_64 (splt->owner, value, splt->contents + hh->plt_offset + 0x8);

      /* Create a dynamic IPLT relocation for this entry.

	 We are creating a relocation in the output file's PLT section,
	 which is included within the DLT secton.  So we do need to include
	 the PLT's output_offset in the computation of the relocation's
	 address.  */
      rel.r_offset = (hh->plt_offset + splt->output_offset
		      + splt->output_section->vma);
      rel.r_info = ELF64_R_INFO (hh->eh.dynindx, R_PARISC_IPLT);
      rel.r_addend = 0;

      loc = spltrel->contents;
      loc += spltrel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (splt->output_section->owner, &rel, loc);
    }

  /* Initialize an external call stub entry if requested.  */
  if (hh->want_stub
      && elf64_hppa_dynamic_symbol_p (eh, info))
    {
      bfd_vma value;
      int insn;
      unsigned int max_offset;

      BFD_ASSERT (stub != NULL);

      /* Install the generic stub template.

	 We are modifying the contents of the stub section, so we do not
	 need to include the stub section's output_offset here.  */
      memcpy (stub->contents + hh->stub_offset, plt_stub, sizeof (plt_stub));

      /* Fix up the first ldd instruction.

	 We are modifying the contents of the STUB section in memory,
	 so we do not need to include its output offset in this computation.

	 Note the plt_offset value is the value of the PLT entry relative to
	 the start of the PLT section.  These instructions will reference
	 data relative to the value of __gp, which may not necessarily have
	 the same address as the start of the PLT section.

	 gp_offset contains the offset of __gp within the PLT section.  */
      value = hh->plt_offset - hppa_info->gp_offset;

      insn = bfd_get_32 (stub->owner, stub->contents + hh->stub_offset);
      if (output_bfd->arch_info->mach >= 25)
	{
	  /* Wide mode allows 16 bit offsets.  */
	  max_offset = 32768;
	  insn &= ~ 0xfff1;
	  insn |= re_assemble_16 ((int) value);
	}
      else
	{
	  max_offset = 8192;
	  insn &= ~ 0x3ff1;
	  insn |= re_assemble_14 ((int) value);
	}

      if ((value & 7) || value + max_offset >= 2*max_offset - 8)
	{
	  (*_bfd_error_handler) (_("stub entry for %s cannot load .plt, dp offset = %ld"),
				 hh->eh.root.root.string,
				 (long) value);
	  return FALSE;
	}

      bfd_put_32 (stub->owner, (bfd_vma) insn,
		  stub->contents + hh->stub_offset);

      /* Fix up the second ldd instruction.  */
      value += 8;
      insn = bfd_get_32 (stub->owner, stub->contents + hh->stub_offset + 8);
      if (output_bfd->arch_info->mach >= 25)
	{
	  insn &= ~ 0xfff1;
	  insn |= re_assemble_16 ((int) value);
	}
      else
	{
	  insn &= ~ 0x3ff1;
	  insn |= re_assemble_14 ((int) value);
	}
      bfd_put_32 (stub->owner, (bfd_vma) insn,
		  stub->contents + hh->stub_offset + 8);
    }

  return TRUE;
}

/* The .opd section contains FPTRs for each function this file
   exports.  Initialize the FPTR entries.  */

static bfd_boolean
elf64_hppa_finalize_opd (struct elf_link_hash_entry *eh, void *data)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  struct bfd_link_info *info = (struct bfd_link_info *)data;
  struct elf64_hppa_link_hash_table *hppa_info;
  asection *sopd;
  asection *sopdrel;

  hppa_info = hppa_link_hash_table (info);
  if (hppa_info == NULL)
    return FALSE;

  sopd = hppa_info->opd_sec;
  sopdrel = hppa_info->opd_rel_sec;

  if (hh->want_opd)
    {
      bfd_vma value;

      /* The first two words of an .opd entry are zero.

	 We are modifying the contents of the OPD section in memory, so we
	 do not need to include its output offset in this computation.  */
      memset (sopd->contents + hh->opd_offset, 0, 16);

      value = (eh->root.u.def.value
	       + eh->root.u.def.section->output_section->vma
	       + eh->root.u.def.section->output_offset);

      /* The next word is the address of the function.  */
      bfd_put_64 (sopd->owner, value, sopd->contents + hh->opd_offset + 16);

      /* The last word is our local __gp value.  */
      value = _bfd_get_gp_value (sopd->output_section->owner);
      bfd_put_64 (sopd->owner, value, sopd->contents + hh->opd_offset + 24);
    }

  /* If we are generating a shared library, we must generate EPLT relocations
     for each entry in the .opd, even for static functions (they may have
     had their address taken).  */
  if (info->shared && hh->want_opd)
    {
      Elf_Internal_Rela rel;
      bfd_byte *loc;
      int dynindx;

      /* We may need to do a relocation against a local symbol, in
	 which case we have to look up it's dynamic symbol index off
	 the local symbol hash table.  */
      if (eh->dynindx != -1)
	dynindx = eh->dynindx;
      else
	dynindx
	  = _bfd_elf_link_lookup_local_dynindx (info, hh->owner,
						hh->sym_indx);

      /* The offset of this relocation is the absolute address of the
	 .opd entry for this symbol.  */
      rel.r_offset = (hh->opd_offset + sopd->output_offset
		      + sopd->output_section->vma);

      /* If H is non-null, then we have an external symbol.

	 It is imperative that we use a different dynamic symbol for the
	 EPLT relocation if the symbol has global scope.

	 In the dynamic symbol table, the function symbol will have a value
	 which is address of the function's .opd entry.

	 Thus, we can not use that dynamic symbol for the EPLT relocation
	 (if we did, the data in the .opd would reference itself rather
	 than the actual address of the function).  Instead we have to use
	 a new dynamic symbol which has the same value as the original global
	 function symbol.

	 We prefix the original symbol with a "." and use the new symbol in
	 the EPLT relocation.  This new symbol has already been recorded in
	 the symbol table, we just have to look it up and use it.

	 We do not have such problems with static functions because we do
	 not make their addresses in the dynamic symbol table point to
	 the .opd entry.  Ultimately this should be safe since a static
	 function can not be directly referenced outside of its shared
	 library.

	 We do have to play similar games for FPTR relocations in shared
	 libraries, including those for static symbols.  See the FPTR
	 handling in elf64_hppa_finalize_dynreloc.  */
      if (eh)
	{
	  char *new_name;
	  struct elf_link_hash_entry *nh;

	  new_name = alloca (strlen (eh->root.root.string) + 2);
	  new_name[0] = '.';
	  strcpy (new_name + 1, eh->root.root.string);

	  nh = elf_link_hash_lookup (elf_hash_table (info),
				     new_name, TRUE, TRUE, FALSE);

	  /* All we really want from the new symbol is its dynamic
	     symbol index.  */
	  if (nh)
	    dynindx = nh->dynindx;
	}

      rel.r_addend = 0;
      rel.r_info = ELF64_R_INFO (dynindx, R_PARISC_EPLT);

      loc = sopdrel->contents;
      loc += sopdrel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (sopd->output_section->owner, &rel, loc);
    }
  return TRUE;
}

/* The .dlt section contains addresses for items referenced through the
   dlt.  Note that we can have a DLTIND relocation for a local symbol, thus
   we can not depend on finish_dynamic_symbol to initialize the .dlt.  */

static bfd_boolean
elf64_hppa_finalize_dlt (struct elf_link_hash_entry *eh, void *data)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  struct bfd_link_info *info = (struct bfd_link_info *)data;
  struct elf64_hppa_link_hash_table *hppa_info;
  asection *sdlt, *sdltrel;

  hppa_info = hppa_link_hash_table (info);
  if (hppa_info == NULL)
    return FALSE;

  sdlt = hppa_info->dlt_sec;
  sdltrel = hppa_info->dlt_rel_sec;

  /* H/DYN_H may refer to a local variable and we know it's
     address, so there is no need to create a relocation.  Just install
     the proper value into the DLT, note this shortcut can not be
     skipped when building a shared library.  */
  if (! info->shared && hh && hh->want_dlt)
    {
      bfd_vma value;

      /* If we had an LTOFF_FPTR style relocation we want the DLT entry
	 to point to the FPTR entry in the .opd section.

	 We include the OPD's output offset in this computation as
	 we are referring to an absolute address in the resulting
	 object file.  */
      if (hh->want_opd)
	{
	  value = (hh->opd_offset
		   + hppa_info->opd_sec->output_offset
		   + hppa_info->opd_sec->output_section->vma);
	}
      else if ((eh->root.type == bfd_link_hash_defined
		|| eh->root.type == bfd_link_hash_defweak)
	       && eh->root.u.def.section)
	{
	  value = eh->root.u.def.value + eh->root.u.def.section->output_offset;
	  if (eh->root.u.def.section->output_section)
	    value += eh->root.u.def.section->output_section->vma;
	  else
	    value += eh->root.u.def.section->vma;
	}
      else
	/* We have an undefined function reference.  */
	value = 0;

      /* We do not need to include the output offset of the DLT section
	 here because we are modifying the in-memory contents.  */
      bfd_put_64 (sdlt->owner, value, sdlt->contents + hh->dlt_offset);
    }

  /* Create a relocation for the DLT entry associated with this symbol.
     When building a shared library the symbol does not have to be dynamic.  */
  if (hh->want_dlt
      && (elf64_hppa_dynamic_symbol_p (eh, info) || info->shared))
    {
      Elf_Internal_Rela rel;
      bfd_byte *loc;
      int dynindx;

      /* We may need to do a relocation against a local symbol, in
	 which case we have to look up it's dynamic symbol index off
	 the local symbol hash table.  */
      if (eh && eh->dynindx != -1)
	dynindx = eh->dynindx;
      else
	dynindx
	  = _bfd_elf_link_lookup_local_dynindx (info, hh->owner,
						hh->sym_indx);

      /* Create a dynamic relocation for this entry.  Do include the output
	 offset of the DLT entry since we need an absolute address in the
	 resulting object file.  */
      rel.r_offset = (hh->dlt_offset + sdlt->output_offset
		      + sdlt->output_section->vma);
      if (eh && eh->type == STT_FUNC)
	  rel.r_info = ELF64_R_INFO (dynindx, R_PARISC_FPTR64);
      else
	  rel.r_info = ELF64_R_INFO (dynindx, R_PARISC_DIR64);
      rel.r_addend = 0;

      loc = sdltrel->contents;
      loc += sdltrel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (sdlt->output_section->owner, &rel, loc);
    }
  return TRUE;
}

/* Finalize the dynamic relocations.  Specifically the FPTR relocations
   for dynamic functions used to initialize static data.  */

static bfd_boolean
elf64_hppa_finalize_dynreloc (struct elf_link_hash_entry *eh,
			      void *data)
{
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  struct bfd_link_info *info = (struct bfd_link_info *)data;
  struct elf64_hppa_link_hash_table *hppa_info;
  int dynamic_symbol;

  dynamic_symbol = elf64_hppa_dynamic_symbol_p (eh, info);

  if (!dynamic_symbol && !info->shared)
    return TRUE;

  if (hh->reloc_entries)
    {
      struct elf64_hppa_dyn_reloc_entry *rent;
      int dynindx;

      hppa_info = hppa_link_hash_table (info);
      if (hppa_info == NULL)
	return FALSE;

      /* We may need to do a relocation against a local symbol, in
	 which case we have to look up it's dynamic symbol index off
	 the local symbol hash table.  */
      if (eh->dynindx != -1)
	dynindx = eh->dynindx;
      else
	dynindx
	  = _bfd_elf_link_lookup_local_dynindx (info, hh->owner,
						hh->sym_indx);

      for (rent = hh->reloc_entries; rent; rent = rent->next)
	{
	  Elf_Internal_Rela rel;
	  bfd_byte *loc;

	  /* Allocate one iff we are building a shared library, the relocation
	     isn't a R_PARISC_FPTR64, or we don't want an opd entry.  */
	  if (!info->shared && rent->type == R_PARISC_FPTR64 && hh->want_opd)
	    continue;

	  /* Create a dynamic relocation for this entry.

	     We need the output offset for the reloc's section because
	     we are creating an absolute address in the resulting object
	     file.  */
	  rel.r_offset = (rent->offset + rent->sec->output_offset
			  + rent->sec->output_section->vma);

	  /* An FPTR64 relocation implies that we took the address of
	     a function and that the function has an entry in the .opd
	     section.  We want the FPTR64 relocation to reference the
	     entry in .opd.

	     We could munge the symbol value in the dynamic symbol table
	     (in fact we already do for functions with global scope) to point
	     to the .opd entry.  Then we could use that dynamic symbol in
	     this relocation.

	     Or we could do something sensible, not munge the symbol's
	     address and instead just use a different symbol to reference
	     the .opd entry.  At least that seems sensible until you
	     realize there's no local dynamic symbols we can use for that
	     purpose.  Thus the hair in the check_relocs routine.

	     We use a section symbol recorded by check_relocs as the
	     base symbol for the relocation.  The addend is the difference
	     between the section symbol and the address of the .opd entry.  */
	  if (info->shared && rent->type == R_PARISC_FPTR64 && hh->want_opd)
	    {
	      bfd_vma value, value2;

	      /* First compute the address of the opd entry for this symbol.  */
	      value = (hh->opd_offset
		       + hppa_info->opd_sec->output_section->vma
		       + hppa_info->opd_sec->output_offset);

	      /* Compute the value of the start of the section with
		 the relocation.  */
	      value2 = (rent->sec->output_section->vma
			+ rent->sec->output_offset);

	      /* Compute the difference between the start of the section
		 with the relocation and the opd entry.  */
	      value -= value2;

	      /* The result becomes the addend of the relocation.  */
	      rel.r_addend = value;

	      /* The section symbol becomes the symbol for the dynamic
		 relocation.  */
	      dynindx
		= _bfd_elf_link_lookup_local_dynindx (info,
						      rent->sec->owner,
						      rent->sec_symndx);
	    }
	  else
	    rel.r_addend = rent->addend;

	  rel.r_info = ELF64_R_INFO (dynindx, rent->type);

	  loc = hppa_info->other_rel_sec->contents;
	  loc += (hppa_info->other_rel_sec->reloc_count++
		  * sizeof (Elf64_External_Rela));
	  bfd_elf64_swap_reloca_out (hppa_info->other_rel_sec->output_section->owner,
				     &rel, loc);
	}
    }

  return TRUE;
}

/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
elf64_hppa_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     const asection *rel_sec ATTRIBUTE_UNUSED,
			     const Elf_Internal_Rela *rela)
{
  if (ELF64_R_SYM (rela->r_info) == STN_UNDEF)
    return reloc_class_relative;

  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_PARISC_IPLT:
      return reloc_class_plt;
    case R_PARISC_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf64_hppa_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sdyn;
  struct elf64_hppa_link_hash_table *hppa_info;

  hppa_info = hppa_link_hash_table (info);
  if (hppa_info == NULL)
    return FALSE;

  /* Finalize the contents of the .opd section.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf64_hppa_finalize_opd,
			  info);

  elf_link_hash_traverse (elf_hash_table (info),
			  elf64_hppa_finalize_dynreloc,
			  info);

  /* Finalize the contents of the .dlt section.  */
  dynobj = elf_hash_table (info)->dynobj;
  /* Finalize the contents of the .dlt section.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf64_hppa_finalize_dlt,
			  info);

  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      Elf64_External_Dyn *dyncon, *dynconend;

      BFD_ASSERT (sdyn != NULL);

      dyncon = (Elf64_External_Dyn *) sdyn->contents;
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  bfd_elf64_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_HP_LOAD_MAP:
	      /* Compute the absolute address of 16byte scratchpad area
		 for the dynamic linker.

		 By convention the linker script will allocate the scratchpad
		 area at the start of the .data section.  So all we have to
		 to is find the start of the .data section.  */
	      s = bfd_get_section_by_name (output_bfd, ".data");
	      if (!s)
		return FALSE;
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTGOT:
	      /* HP's use PLTGOT to set the GOT register.  */
	      dyn.d_un.d_ptr = _bfd_get_gp_value (output_bfd);
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_JMPREL:
	      s = hppa_info->plt_rel_sec;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      s = hppa_info->plt_rel_sec;
	      dyn.d_un.d_val = s->size;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELA:
	      s = hppa_info->other_rel_sec;
	      if (! s || ! s->size)
		s = hppa_info->dlt_rel_sec;
	      if (! s || ! s->size)
		s = hppa_info->opd_rel_sec;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELASZ:
	      s = hppa_info->other_rel_sec;
	      dyn.d_un.d_val = s->size;
	      s = hppa_info->dlt_rel_sec;
	      dyn.d_un.d_val += s->size;
	      s = hppa_info->opd_rel_sec;
	      dyn.d_un.d_val += s->size;
	      /* There is some question about whether or not the size of
		 the PLT relocs should be included here.  HP's tools do
		 it, so we'll emulate them.  */
	      s = hppa_info->plt_rel_sec;
	      dyn.d_un.d_val += s->size;
	      bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    }
	}
    }

  return TRUE;
}

/* Support for core dump NOTE sections.  */

static bfd_boolean
elf64_hppa_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  size_t size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 760:		/* Linux/hppa */
	/* pr_cursig */
	elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 32);

	/* pr_reg */
	offset = 112;
	size = 640;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf64_hppa_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  char * command;
  int n;

  switch (note->descsz)
    {
    default:
      return FALSE;

    case 136:		/* Linux/hppa elf_prpsinfo.  */
      elf_tdata (abfd)->core->program
	= _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
      elf_tdata (abfd)->core->command
	= _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */
  command = elf_tdata (abfd)->core->command;
  n = strlen (command);

  if (0 < n && command[n - 1] == ' ')
    command[n - 1] = '\0';

  return TRUE;
}

/* Return the number of additional phdrs we will need.

   The generic ELF code only creates PT_PHDRs for executables.  The HP
   dynamic linker requires PT_PHDRs for dynamic libraries too.

   This routine indicates that the backend needs one additional program
   header for that case.

   Note we do not have access to the link info structure here, so we have
   to guess whether or not we are building a shared library based on the
   existence of a .interp section.  */

static int
elf64_hppa_additional_program_headers (bfd *abfd,
				struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  asection *s;

  /* If we are creating a shared library, then we have to create a
     PT_PHDR segment.  HP's dynamic linker chokes without it.  */
  s = bfd_get_section_by_name (abfd, ".interp");
  if (! s)
    return 1;
  return 0;
}

/* Allocate and initialize any program headers required by this
   specific backend.

   The generic ELF code only creates PT_PHDRs for executables.  The HP
   dynamic linker requires PT_PHDRs for dynamic libraries too.

   This allocates the PT_PHDR and initializes it in a manner suitable
   for the HP linker.

   Note we do not have access to the link info structure here, so we have
   to guess whether or not we are building a shared library based on the
   existence of a .interp section.  */

static bfd_boolean
elf64_hppa_modify_segment_map (bfd *abfd,
			       struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  struct elf_segment_map *m;
  asection *s;

  s = bfd_get_section_by_name (abfd, ".interp");
  if (! s)
    {
      for (m = elf_seg_map (abfd); m != NULL; m = m->next)
	if (m->p_type == PT_PHDR)
	  break;
      if (m == NULL)
	{
	  m = ((struct elf_segment_map *)
	       bfd_zalloc (abfd, (bfd_size_type) sizeof *m));
	  if (m == NULL)
	    return FALSE;

	  m->p_type = PT_PHDR;
	  m->p_flags = PF_R | PF_X;
	  m->p_flags_valid = 1;
	  m->p_paddr_valid = 1;
	  m->includes_phdrs = 1;

	  m->next = elf_seg_map (abfd);
	  elf_seg_map (abfd) = m;
	}
    }

  for (m = elf_seg_map (abfd); m != NULL; m = m->next)
    if (m->p_type == PT_LOAD)
      {
	unsigned int i;

	for (i = 0; i < m->count; i++)
	  {
	    /* The code "hint" is not really a hint.  It is a requirement
	       for certain versions of the HP dynamic linker.  Worse yet,
	       it must be set even if the shared library does not have
	       any code in its "text" segment (thus the check for .hash
	       to catch this situation).  */
	    if (m->sections[i]->flags & SEC_CODE
		|| (strcmp (m->sections[i]->name, ".hash") == 0))
	      m->p_flags |= (PF_X | PF_HP_CODE);
	  }
      }

  return TRUE;
}

/* Called when writing out an object file to decide the type of a
   symbol.  */
static int
elf64_hppa_elf_get_symbol_type (Elf_Internal_Sym *elf_sym,
				int type)
{
  if (ELF_ST_TYPE (elf_sym->st_info) == STT_PARISC_MILLI)
    return STT_PARISC_MILLI;
  else
    return type;
}

/* Support HP specific sections for core files.  */

static bfd_boolean
elf64_hppa_section_from_phdr (bfd *abfd, Elf_Internal_Phdr *hdr, int sec_index,
			      const char *typename)
{
  if (hdr->p_type == PT_HP_CORE_KERNEL)
    {
      asection *sect;

      if (!_bfd_elf_make_section_from_phdr (abfd, hdr, sec_index, typename))
	return FALSE;

      sect = bfd_make_section_anyway (abfd, ".kernel");
      if (sect == NULL)
	return FALSE;
      sect->size = hdr->p_filesz;
      sect->filepos = hdr->p_offset;
      sect->flags = SEC_HAS_CONTENTS | SEC_READONLY;
      return TRUE;
    }

  if (hdr->p_type == PT_HP_CORE_PROC)
    {
      int sig;

      if (bfd_seek (abfd, hdr->p_offset, SEEK_SET) != 0)
	return FALSE;
      if (bfd_bread (&sig, 4, abfd) != 4)
	return FALSE;

      elf_tdata (abfd)->core->signal = sig;

      if (!_bfd_elf_make_section_from_phdr (abfd, hdr, sec_index, typename))
	return FALSE;

      /* GDB uses the ".reg" section to read register contents.  */
      return _bfd_elfcore_make_pseudosection (abfd, ".reg", hdr->p_filesz,
					      hdr->p_offset);
    }

  if (hdr->p_type == PT_HP_CORE_LOADABLE
      || hdr->p_type == PT_HP_CORE_STACK
      || hdr->p_type == PT_HP_CORE_MMF)
    hdr->p_type = PT_LOAD;

  return _bfd_elf_make_section_from_phdr (abfd, hdr, sec_index, typename);
}

/* Hook called by the linker routine which adds symbols from an object
   file.  HP's libraries define symbols with HP specific section
   indices, which we have to handle.  */

static bfd_boolean
elf_hppa_add_symbol_hook (bfd *abfd,
			  struct bfd_link_info *info ATTRIBUTE_UNUSED,
			  Elf_Internal_Sym *sym,
			  const char **namep ATTRIBUTE_UNUSED,
			  flagword *flagsp ATTRIBUTE_UNUSED,
			  asection **secp,
			  bfd_vma *valp)
{
  unsigned int sec_index = sym->st_shndx;

  switch (sec_index)
    {
    case SHN_PARISC_ANSI_COMMON:
      *secp = bfd_make_section_old_way (abfd, ".PARISC.ansi.common");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;

    case SHN_PARISC_HUGE_COMMON:
      *secp = bfd_make_section_old_way (abfd, ".PARISC.huge.common");
      (*secp)->flags |= SEC_IS_COMMON;
      *valp = sym->st_size;
      break;
    }

  return TRUE;
}

static bfd_boolean
elf_hppa_unmark_useless_dynamic_symbols (struct elf_link_hash_entry *h,
					 void *data)
{
  struct bfd_link_info *info = data;

  /* If we are not creating a shared library, and this symbol is
     referenced by a shared library but is not defined anywhere, then
     the generic code will warn that it is undefined.

     This behavior is undesirable on HPs since the standard shared
     libraries contain references to undefined symbols.

     So we twiddle the flags associated with such symbols so that they
     will not trigger the warning.  ?!? FIXME.  This is horribly fragile.

     Ultimately we should have better controls over the generic ELF BFD
     linker code.  */
  if (! info->relocatable
      && info->unresolved_syms_in_shared_libs != RM_IGNORE
      && h->root.type == bfd_link_hash_undefined
      && h->ref_dynamic
      && !h->ref_regular)
    {
      h->ref_dynamic = 0;
      h->pointer_equality_needed = 1;
    }

  return TRUE;
}

static bfd_boolean
elf_hppa_remark_useless_dynamic_symbols (struct elf_link_hash_entry *h,
					 void *data)
{
  struct bfd_link_info *info = data;

  /* If we are not creating a shared library, and this symbol is
     referenced by a shared library but is not defined anywhere, then
     the generic code will warn that it is undefined.

     This behavior is undesirable on HPs since the standard shared
     libraries contain references to undefined symbols.

     So we twiddle the flags associated with such symbols so that they
     will not trigger the warning.  ?!? FIXME.  This is horribly fragile.

     Ultimately we should have better controls over the generic ELF BFD
     linker code.  */
  if (! info->relocatable
      && info->unresolved_syms_in_shared_libs != RM_IGNORE
      && h->root.type == bfd_link_hash_undefined
      && !h->ref_dynamic
      && !h->ref_regular
      && h->pointer_equality_needed)
    {
      h->ref_dynamic = 1;
      h->pointer_equality_needed = 0;
    }

  return TRUE;
}

static bfd_boolean
elf_hppa_is_dynamic_loader_symbol (const char *name)
{
  return (! strcmp (name, "__CPU_REVISION")
	  || ! strcmp (name, "__CPU_KEYBITS_1")
	  || ! strcmp (name, "__SYSTEM_ID_D")
	  || ! strcmp (name, "__FPU_MODEL")
	  || ! strcmp (name, "__FPU_REVISION")
	  || ! strcmp (name, "__ARGC")
	  || ! strcmp (name, "__ARGV")
	  || ! strcmp (name, "__ENVP")
	  || ! strcmp (name, "__TLS_SIZE_D")
	  || ! strcmp (name, "__LOAD_INFO")
	  || ! strcmp (name, "__systab"));
}

/* Record the lowest address for the data and text segments.  */
static void
elf_hppa_record_segment_addrs (bfd *abfd,
			       asection *section,
			       void *data)
{
  struct elf64_hppa_link_hash_table *hppa_info = data;

  if ((section->flags & (SEC_ALLOC | SEC_LOAD)) == (SEC_ALLOC | SEC_LOAD))
    {
      bfd_vma value;
      Elf_Internal_Phdr *p;

      p = _bfd_elf_find_segment_containing_section (abfd, section->output_section);
      BFD_ASSERT (p != NULL);
      value = p->p_vaddr;

      if (section->flags & SEC_READONLY)
	{
	  if (value < hppa_info->text_segment_base)
	    hppa_info->text_segment_base = value;
	}
      else
	{
	  if (value < hppa_info->data_segment_base)
	    hppa_info->data_segment_base = value;
	}
    }
}

/* Called after we have seen all the input files/sections, but before
   final symbol resolution and section placement has been determined.

   We use this hook to (possibly) provide a value for __gp, then we
   fall back to the generic ELF final link routine.  */

static bfd_boolean
elf_hppa_final_link (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean retval;
  struct elf64_hppa_link_hash_table *hppa_info = hppa_link_hash_table (info);

  if (hppa_info == NULL)
    return FALSE;

  if (! info->relocatable)
    {
      struct elf_link_hash_entry *gp;
      bfd_vma gp_val;

      /* The linker script defines a value for __gp iff it was referenced
	 by one of the objects being linked.  First try to find the symbol
	 in the hash table.  If that fails, just compute the value __gp
	 should have had.  */
      gp = elf_link_hash_lookup (elf_hash_table (info), "__gp", FALSE,
				 FALSE, FALSE);

      if (gp)
	{

	  /* Adjust the value of __gp as we may want to slide it into the
	     .plt section so that the stubs can access PLT entries without
	     using an addil sequence.  */
	  gp->root.u.def.value += hppa_info->gp_offset;

	  gp_val = (gp->root.u.def.section->output_section->vma
		    + gp->root.u.def.section->output_offset
		    + gp->root.u.def.value);
	}
      else
	{
	  asection *sec;

	  /* First look for a .plt section.  If found, then __gp is the
	     address of the .plt + gp_offset.

	     If no .plt is found, then look for .dlt, .opd and .data (in
	     that order) and set __gp to the base address of whichever
	     section is found first.  */

	  sec = hppa_info->plt_sec;
	  if (sec && ! (sec->flags & SEC_EXCLUDE))
	    gp_val = (sec->output_offset
		      + sec->output_section->vma
		      + hppa_info->gp_offset);
	  else
	    {
	      sec = hppa_info->dlt_sec;
	      if (!sec || (sec->flags & SEC_EXCLUDE))
		sec = hppa_info->opd_sec;
	      if (!sec || (sec->flags & SEC_EXCLUDE))
		sec = bfd_get_section_by_name (abfd, ".data");
	      if (!sec || (sec->flags & SEC_EXCLUDE))
		gp_val = 0;
	      else
		gp_val = sec->output_offset + sec->output_section->vma;
	    }
	}

      /* Install whatever value we found/computed for __gp.  */
      _bfd_set_gp_value (abfd, gp_val);
    }

  /* We need to know the base of the text and data segments so that we
     can perform SEGREL relocations.  We will record the base addresses
     when we encounter the first SEGREL relocation.  */
  hppa_info->text_segment_base = (bfd_vma)-1;
  hppa_info->data_segment_base = (bfd_vma)-1;

  /* HP's shared libraries have references to symbols that are not
     defined anywhere.  The generic ELF BFD linker code will complain
     about such symbols.

     So we detect the losing case and arrange for the flags on the symbol
     to indicate that it was never referenced.  This keeps the generic
     ELF BFD link code happy and appears to not create any secondary
     problems.  Ultimately we need a way to control the behavior of the
     generic ELF BFD link code better.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_hppa_unmark_useless_dynamic_symbols,
			  info);

  /* Invoke the regular ELF backend linker to do all the work.  */
  retval = bfd_elf_final_link (abfd, info);

  elf_link_hash_traverse (elf_hash_table (info),
			  elf_hppa_remark_useless_dynamic_symbols,
			  info);

  /* If we're producing a final executable, sort the contents of the
     unwind section. */
  if (retval && !info->relocatable)
    retval = elf_hppa_sort_unwind (abfd);

  return retval;
}

/* Relocate the given INSN.  VALUE should be the actual value we want
   to insert into the instruction, ie by this point we should not be
   concerned with computing an offset relative to the DLT, PC, etc.
   Instead this routine is meant to handle the bit manipulations needed
   to insert the relocation into the given instruction.  */

static int
elf_hppa_relocate_insn (int insn, int sym_value, unsigned int r_type)
{
  switch (r_type)
    {
    /* This is any 22 bit branch.  In PA2.0 syntax it corresponds to
       the "B" instruction.  */
    case R_PARISC_PCREL22F:
    case R_PARISC_PCREL22C:
      return (insn & ~0x3ff1ffd) | re_assemble_22 (sym_value);

      /* This is any 12 bit branch.  */
    case R_PARISC_PCREL12F:
      return (insn & ~0x1ffd) | re_assemble_12 (sym_value);

    /* This is any 17 bit branch.  In PA2.0 syntax it also corresponds
       to the "B" instruction as well as BE.  */
    case R_PARISC_PCREL17F:
    case R_PARISC_DIR17F:
    case R_PARISC_DIR17R:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17R:
      return (insn & ~0x1f1ffd) | re_assemble_17 (sym_value);

    /* ADDIL or LDIL instructions.  */
    case R_PARISC_DLTREL21L:
    case R_PARISC_DLTIND21L:
    case R_PARISC_LTOFF_FPTR21L:
    case R_PARISC_PCREL21L:
    case R_PARISC_LTOFF_TP21L:
    case R_PARISC_DPREL21L:
    case R_PARISC_PLTOFF21L:
    case R_PARISC_DIR21L:
      return (insn & ~0x1fffff) | re_assemble_21 (sym_value);

    /* LDO and integer loads/stores with 14 bit displacements.  */
    case R_PARISC_DLTREL14R:
    case R_PARISC_DLTREL14F:
    case R_PARISC_DLTIND14R:
    case R_PARISC_DLTIND14F:
    case R_PARISC_LTOFF_FPTR14R:
    case R_PARISC_PCREL14R:
    case R_PARISC_PCREL14F:
    case R_PARISC_LTOFF_TP14R:
    case R_PARISC_LTOFF_TP14F:
    case R_PARISC_DPREL14R:
    case R_PARISC_DPREL14F:
    case R_PARISC_PLTOFF14R:
    case R_PARISC_PLTOFF14F:
    case R_PARISC_DIR14R:
    case R_PARISC_DIR14F:
      return (insn & ~0x3fff) | low_sign_unext (sym_value, 14);

    /* PA2.0W LDO and integer loads/stores with 16 bit displacements.  */
    case R_PARISC_LTOFF_FPTR16F:
    case R_PARISC_PCREL16F:
    case R_PARISC_LTOFF_TP16F:
    case R_PARISC_GPREL16F:
    case R_PARISC_PLTOFF16F:
    case R_PARISC_DIR16F:
    case R_PARISC_LTOFF16F:
      return (insn & ~0xffff) | re_assemble_16 (sym_value);

    /* Doubleword loads and stores with a 14 bit displacement.  */
    case R_PARISC_DLTREL14DR:
    case R_PARISC_DLTIND14DR:
    case R_PARISC_LTOFF_FPTR14DR:
    case R_PARISC_LTOFF_FPTR16DF:
    case R_PARISC_PCREL14DR:
    case R_PARISC_PCREL16DF:
    case R_PARISC_LTOFF_TP14DR:
    case R_PARISC_LTOFF_TP16DF:
    case R_PARISC_DPREL14DR:
    case R_PARISC_GPREL16DF:
    case R_PARISC_PLTOFF14DR:
    case R_PARISC_PLTOFF16DF:
    case R_PARISC_DIR14DR:
    case R_PARISC_DIR16DF:
    case R_PARISC_LTOFF16DF:
      return (insn & ~0x3ff1) | (((sym_value & 0x2000) >> 13)
				 | ((sym_value & 0x1ff8) << 1));

    /* Floating point single word load/store instructions.  */
    case R_PARISC_DLTREL14WR:
    case R_PARISC_DLTIND14WR:
    case R_PARISC_LTOFF_FPTR14WR:
    case R_PARISC_LTOFF_FPTR16WF:
    case R_PARISC_PCREL14WR:
    case R_PARISC_PCREL16WF:
    case R_PARISC_LTOFF_TP14WR:
    case R_PARISC_LTOFF_TP16WF:
    case R_PARISC_DPREL14WR:
    case R_PARISC_GPREL16WF:
    case R_PARISC_PLTOFF14WR:
    case R_PARISC_PLTOFF16WF:
    case R_PARISC_DIR16WF:
    case R_PARISC_DIR14WR:
    case R_PARISC_LTOFF16WF:
      return (insn & ~0x3ff9) | (((sym_value & 0x2000) >> 13)
				 | ((sym_value & 0x1ffc) << 1));

    default:
      return insn;
    }
}

/* Compute the value for a relocation (REL) during a final link stage,
   then insert the value into the proper location in CONTENTS.

   VALUE is a tentative value for the relocation and may be overridden
   and modified here based on the specific relocation to be performed.

   For example we do conversions for PC-relative branches in this routine
   or redirection of calls to external routines to stubs.

   The work of actually applying the relocation is left to a helper
   routine in an attempt to reduce the complexity and size of this
   function.  */

static bfd_reloc_status_type
elf_hppa_final_link_relocate (Elf_Internal_Rela *rel,
			      bfd *input_bfd,
			      bfd *output_bfd,
			      asection *input_section,
			      bfd_byte *contents,
			      bfd_vma value,
			      struct bfd_link_info *info,
			      asection *sym_sec,
			      struct elf_link_hash_entry *eh)
{
  struct elf64_hppa_link_hash_table *hppa_info = hppa_link_hash_table (info);
  struct elf64_hppa_link_hash_entry *hh = hppa_elf_hash_entry (eh);
  bfd_vma *local_offsets;
  Elf_Internal_Shdr *symtab_hdr;
  int insn;
  bfd_vma max_branch_offset = 0;
  bfd_vma offset = rel->r_offset;
  bfd_signed_vma addend = rel->r_addend;
  reloc_howto_type *howto = elf_hppa_howto_table + ELF_R_TYPE (rel->r_info);
  unsigned int r_symndx = ELF_R_SYM (rel->r_info);
  unsigned int r_type = howto->type;
  bfd_byte *hit_data = contents + offset;

  if (hppa_info == NULL)
    return bfd_reloc_notsupported;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  local_offsets = elf_local_got_offsets (input_bfd);
  insn = bfd_get_32 (input_bfd, hit_data);

  switch (r_type)
    {
    case R_PARISC_NONE:
      break;

    /* Basic function call support.

       Note for a call to a function defined in another dynamic library
       we want to redirect the call to a stub.  */

    /* PC relative relocs without an implicit offset.  */
    case R_PARISC_PCREL21L:
    case R_PARISC_PCREL14R:
    case R_PARISC_PCREL14F:
    case R_PARISC_PCREL14WR:
    case R_PARISC_PCREL14DR:
    case R_PARISC_PCREL16F:
    case R_PARISC_PCREL16WF:
    case R_PARISC_PCREL16DF:
      {
	/* If this is a call to a function defined in another dynamic
	   library, then redirect the call to the local stub for this
	   function.  */
	if (sym_sec == NULL || sym_sec->output_section == NULL)
	  value = (hh->stub_offset + hppa_info->stub_sec->output_offset
		   + hppa_info->stub_sec->output_section->vma);

	/* Turn VALUE into a proper PC relative address.  */
	value -= (offset + input_section->output_offset
		  + input_section->output_section->vma);

	/* Adjust for any field selectors.  */
	if (r_type == R_PARISC_PCREL21L)
	  value = hppa_field_adjust (value, -8 + addend, e_lsel);
	else if (r_type == R_PARISC_PCREL14F
		 || r_type == R_PARISC_PCREL16F
		 || r_type == R_PARISC_PCREL16WF
		 || r_type == R_PARISC_PCREL16DF)
	  value = hppa_field_adjust (value, -8 + addend, e_fsel);
	else
	  value = hppa_field_adjust (value, -8 + addend, e_rsel);

	/* Apply the relocation to the given instruction.  */
	insn = elf_hppa_relocate_insn (insn, (int) value, r_type);
	break;
      }

    case R_PARISC_PCREL12F:
    case R_PARISC_PCREL22F:
    case R_PARISC_PCREL17F:
    case R_PARISC_PCREL22C:
    case R_PARISC_PCREL17C:
    case R_PARISC_PCREL17R:
      {
	/* If this is a call to a function defined in another dynamic
	   library, then redirect the call to the local stub for this
	   function.  */
	if (sym_sec == NULL || sym_sec->output_section == NULL)
	  value = (hh->stub_offset + hppa_info->stub_sec->output_offset
		   + hppa_info->stub_sec->output_section->vma);

	/* Turn VALUE into a proper PC relative address.  */
	value -= (offset + input_section->output_offset
		  + input_section->output_section->vma);
	addend -= 8;

	if (r_type == (unsigned int) R_PARISC_PCREL22F)
	  max_branch_offset = (1 << (22-1)) << 2;
	else if (r_type == (unsigned int) R_PARISC_PCREL17F)
	  max_branch_offset = (1 << (17-1)) << 2;
	else if (r_type == (unsigned int) R_PARISC_PCREL12F)
	  max_branch_offset = (1 << (12-1)) << 2;

	/* Make sure we can reach the branch target.  */
	if (max_branch_offset != 0
	    && value + addend + max_branch_offset >= 2*max_branch_offset)
	  {
	    (*_bfd_error_handler)
	      (_("%B(%A+0x%" BFD_VMA_FMT "x): cannot reach %s"),
	      input_bfd,
	      input_section,
	      offset,
	      eh ? eh->root.root.string : "unknown");
	    bfd_set_error (bfd_error_bad_value);
	    return bfd_reloc_overflow;
	  }

	/* Adjust for any field selectors.  */
	if (r_type == R_PARISC_PCREL17R)
	  value = hppa_field_adjust (value, addend, e_rsel);
	else
	  value = hppa_field_adjust (value, addend, e_fsel);

	/* All branches are implicitly shifted by 2 places.  */
	value >>= 2;

	/* Apply the relocation to the given instruction.  */
	insn = elf_hppa_relocate_insn (insn, (int) value, r_type);
	break;
      }

    /* Indirect references to data through the DLT.  */
    case R_PARISC_DLTIND14R:
    case R_PARISC_DLTIND14F:
    case R_PARISC_DLTIND14DR:
    case R_PARISC_DLTIND14WR:
    case R_PARISC_DLTIND21L:
    case R_PARISC_LTOFF_FPTR14R:
    case R_PARISC_LTOFF_FPTR14DR:
    case R_PARISC_LTOFF_FPTR14WR:
    case R_PARISC_LTOFF_FPTR21L:
    case R_PARISC_LTOFF_FPTR16F:
    case R_PARISC_LTOFF_FPTR16WF:
    case R_PARISC_LTOFF_FPTR16DF:
    case R_PARISC_LTOFF_TP21L:
    case R_PARISC_LTOFF_TP14R:
    case R_PARISC_LTOFF_TP14F:
    case R_PARISC_LTOFF_TP14WR:
    case R_PARISC_LTOFF_TP14DR:
    case R_PARISC_LTOFF_TP16F:
    case R_PARISC_LTOFF_TP16WF:
    case R_PARISC_LTOFF_TP16DF:
    case R_PARISC_LTOFF16F:
    case R_PARISC_LTOFF16WF:
    case R_PARISC_LTOFF16DF:
      {
	bfd_vma off;

	/* If this relocation was against a local symbol, then we still
	   have not set up the DLT entry (it's not convenient to do so
	   in the "finalize_dlt" routine because it is difficult to get
	   to the local symbol's value).

	   So, if this is a local symbol (h == NULL), then we need to
	   fill in its DLT entry.

	   Similarly we may still need to set up an entry in .opd for
	   a local function which had its address taken.  */
	if (hh == NULL)
	  {
	    bfd_vma *local_opd_offsets, *local_dlt_offsets;

            if (local_offsets == NULL)
              abort ();

	    /* Now do .opd creation if needed.  */
	    if (r_type == R_PARISC_LTOFF_FPTR14R
		|| r_type == R_PARISC_LTOFF_FPTR14DR
		|| r_type == R_PARISC_LTOFF_FPTR14WR
		|| r_type == R_PARISC_LTOFF_FPTR21L
		|| r_type == R_PARISC_LTOFF_FPTR16F
		|| r_type == R_PARISC_LTOFF_FPTR16WF
		|| r_type == R_PARISC_LTOFF_FPTR16DF)
	      {
		local_opd_offsets = local_offsets + 2 * symtab_hdr->sh_info;
		off = local_opd_offsets[r_symndx];

		/* The last bit records whether we've already initialised
		   this local .opd entry.  */
		if ((off & 1) != 0)
		  {
		    BFD_ASSERT (off != (bfd_vma) -1);
		    off &= ~1;
		  }
		else
		  {
		    local_opd_offsets[r_symndx] |= 1;

		    /* The first two words of an .opd entry are zero.  */
		    memset (hppa_info->opd_sec->contents + off, 0, 16);

		    /* The next word is the address of the function.  */
		    bfd_put_64 (hppa_info->opd_sec->owner, value + addend,
				(hppa_info->opd_sec->contents + off + 16));

		    /* The last word is our local __gp value.  */
		    value = _bfd_get_gp_value
			      (hppa_info->opd_sec->output_section->owner);
		    bfd_put_64 (hppa_info->opd_sec->owner, value,
				(hppa_info->opd_sec->contents + off + 24));
		  }

		/* The DLT value is the address of the .opd entry.  */
		value = (off
			 + hppa_info->opd_sec->output_offset
			 + hppa_info->opd_sec->output_section->vma);
		addend = 0;
	      }

	    local_dlt_offsets = local_offsets;
	    off = local_dlt_offsets[r_symndx];

	    if ((off & 1) != 0)
	      {
		BFD_ASSERT (off != (bfd_vma) -1);
		off &= ~1;
	      }
	    else
	      {
		local_dlt_offsets[r_symndx] |= 1;
		bfd_put_64 (hppa_info->dlt_sec->owner,
			    value + addend,
			    hppa_info->dlt_sec->contents + off);
	      }
	  }
	else
	  off = hh->dlt_offset;

	/* We want the value of the DLT offset for this symbol, not
	   the symbol's actual address.  Note that __gp may not point
	   to the start of the DLT, so we have to compute the absolute
	   address, then subtract out the value of __gp.  */
	value = (off
		 + hppa_info->dlt_sec->output_offset
		 + hppa_info->dlt_sec->output_section->vma);
	value -= _bfd_get_gp_value (output_bfd);

	/* All DLTIND relocations are basically the same at this point,
	   except that we need different field selectors for the 21bit
	   version vs the 14bit versions.  */
	if (r_type == R_PARISC_DLTIND21L
	    || r_type == R_PARISC_LTOFF_FPTR21L
	    || r_type == R_PARISC_LTOFF_TP21L)
	  value = hppa_field_adjust (value, 0, e_lsel);
	else if (r_type == R_PARISC_DLTIND14F
		 || r_type == R_PARISC_LTOFF_FPTR16F
		 || r_type == R_PARISC_LTOFF_FPTR16WF
		 || r_type == R_PARISC_LTOFF_FPTR16DF
		 || r_type == R_PARISC_LTOFF16F
		 || r_type == R_PARISC_LTOFF16DF
		 || r_type == R_PARISC_LTOFF16WF
		 || r_type == R_PARISC_LTOFF_TP16F
		 || r_type == R_PARISC_LTOFF_TP16WF
		 || r_type == R_PARISC_LTOFF_TP16DF)
	  value = hppa_field_adjust (value, 0, e_fsel);
	else
	  value = hppa_field_adjust (value, 0, e_rsel);

	insn = elf_hppa_relocate_insn (insn, (int) value, r_type);
	break;
      }

    case R_PARISC_DLTREL14R:
    case R_PARISC_DLTREL14F:
    case R_PARISC_DLTREL14DR:
    case R_PARISC_DLTREL14WR:
    case R_PARISC_DLTREL21L:
    case R_PARISC_DPREL21L:
    case R_PARISC_DPREL14WR:
    case R_PARISC_DPREL14DR:
    case R_PARISC_DPREL14R:
    case R_PARISC_DPREL14F:
    case R_PARISC_GPREL16F:
    case R_PARISC_GPREL16WF:
    case R_PARISC_GPREL16DF:
      {
	/* Subtract out the global pointer value to make value a DLT
	   relative address.  */
	value -= _bfd_get_gp_value (output_bfd);

	/* All DLTREL relocations are basically the same at this point,
	   except that we need different field selectors for the 21bit
	   version vs the 14bit versions.  */
	if (r_type == R_PARISC_DLTREL21L
	    || r_type == R_PARISC_DPREL21L)
	  value = hppa_field_adjust (value, addend, e_lrsel);
	else if (r_type == R_PARISC_DLTREL14F
		 || r_type == R_PARISC_DPREL14F
		 || r_type == R_PARISC_GPREL16F
		 || r_type == R_PARISC_GPREL16WF
		 || r_type == R_PARISC_GPREL16DF)
	  value = hppa_field_adjust (value, addend, e_fsel);
	else
	  value = hppa_field_adjust (value, addend, e_rrsel);

	insn = elf_hppa_relocate_insn (insn, (int) value, r_type);
	break;
      }

    case R_PARISC_DIR21L:
    case R_PARISC_DIR17R:
    case R_PARISC_DIR17F:
    case R_PARISC_DIR14R:
    case R_PARISC_DIR14F:
    case R_PARISC_DIR14WR:
    case R_PARISC_DIR14DR:
    case R_PARISC_DIR16F:
    case R_PARISC_DIR16WF:
    case R_PARISC_DIR16DF:
      {
	/* All DIR relocations are basically the same at this point,
	   except that branch offsets need to be divided by four, and
	   we need different field selectors.  Note that we don't
	   redirect absolute calls to local stubs.  */

	if (r_type == R_PARISC_DIR21L)
	  value = hppa_field_adjust (value, addend, e_lrsel);
	else if (r_type == R_PARISC_DIR17F
		 || r_type == R_PARISC_DIR16F
		 || r_type == R_PARISC_DIR16WF
		 || r_type == R_PARISC_DIR16DF
		 || r_type == R_PARISC_DIR14F)
	  value = hppa_field_adjust (value, addend, e_fsel);
	else
	  value = hppa_field_adjust (value, addend, e_rrsel);

	if (r_type == R_PARISC_DIR17R || r_type == R_PARISC_DIR17F)
	  /* All branches are implicitly shifted by 2 places.  */
	  value >>= 2;

	insn = elf_hppa_relocate_insn (insn, (int) value, r_type);
	break;
      }

    case R_PARISC_PLTOFF21L:
    case R_PARISC_PLTOFF14R:
    case R_PARISC_PLTOFF14F:
    case R_PARISC_PLTOFF14WR:
    case R_PARISC_PLTOFF14DR:
    case R_PARISC_PLTOFF16F:
    case R_PARISC_PLTOFF16WF:
    case R_PARISC_PLTOFF16DF:
      {
	/* We want the value of the PLT offset for this symbol, not
	   the symbol's actual address.  Note that __gp may not point
	   to the start of the DLT, so we have to compute the absolute
	   address, then subtract out the value of __gp.  */
	value = (hh->plt_offset
		 + hppa_info->plt_sec->output_offset
		 + hppa_info->plt_sec->output_section->vma);
	value -= _bfd_get_gp_value (output_bfd);

	/* All PLTOFF relocations are basically the same at this point,
	   except that we need different field selectors for the 21bit
	   version vs the 14bit versions.  */
	if (r_type == R_PARISC_PLTOFF21L)
	  value = hppa_field_adjust (value, addend, e_lrsel);
	else if (r_type == R_PARISC_PLTOFF14F
		 || r_type == R_PARISC_PLTOFF16F
		 || r_type == R_PARISC_PLTOFF16WF
		 || r_type == R_PARISC_PLTOFF16DF)
	  value = hppa_field_adjust (value, addend, e_fsel);
	else
	  value = hppa_field_adjust (value, addend, e_rrsel);

	insn = elf_hppa_relocate_insn (insn, (int) value, r_type);
	break;
      }

    case R_PARISC_LTOFF_FPTR32:
      {
	/* We may still need to create the FPTR itself if it was for
	   a local symbol.  */
	if (hh == NULL)
	  {
	    /* The first two words of an .opd entry are zero.  */
	    memset (hppa_info->opd_sec->contents + hh->opd_offset, 0, 16);

	    /* The next word is the address of the function.  */
	    bfd_put_64 (hppa_info->opd_sec->owner, value + addend,
			(hppa_info->opd_sec->contents
			 + hh->opd_offset + 16));

	    /* The last word is our local __gp value.  */
	    value = _bfd_get_gp_value
		      (hppa_info->opd_sec->output_section->owner);
	    bfd_put_64 (hppa_info->opd_sec->owner, value,
			hppa_info->opd_sec->contents + hh->opd_offset + 24);

	    /* The DLT value is the address of the .opd entry.  */
	    value = (hh->opd_offset
		     + hppa_info->opd_sec->output_offset
		     + hppa_info->opd_sec->output_section->vma);

	    bfd_put_64 (hppa_info->dlt_sec->owner,
			value,
			hppa_info->dlt_sec->contents + hh->dlt_offset);
	  }

	/* We want the value of the DLT offset for this symbol, not
	   the symbol's actual address.  Note that __gp may not point
	   to the start of the DLT, so we have to compute the absolute
	   address, then subtract out the value of __gp.  */
	value = (hh->dlt_offset
		 + hppa_info->dlt_sec->output_offset
		 + hppa_info->dlt_sec->output_section->vma);
	value -= _bfd_get_gp_value (output_bfd);
	bfd_put_32 (input_bfd, value, hit_data);
	return bfd_reloc_ok;
      }

    case R_PARISC_LTOFF_FPTR64:
    case R_PARISC_LTOFF_TP64:
      {
	/* We may still need to create the FPTR itself if it was for
	   a local symbol.  */
	if (eh == NULL && r_type == R_PARISC_LTOFF_FPTR64)
	  {
	    /* The first two words of an .opd entry are zero.  */
	    memset (hppa_info->opd_sec->contents + hh->opd_offset, 0, 16);

	    /* The next word is the address of the function.  */
	    bfd_put_64 (hppa_info->opd_sec->owner, value + addend,
			(hppa_info->opd_sec->contents
			 + hh->opd_offset + 16));

	    /* The last word is our local __gp value.  */
	    value = _bfd_get_gp_value
		      (hppa_info->opd_sec->output_section->owner);
	    bfd_put_64 (hppa_info->opd_sec->owner, value,
			hppa_info->opd_sec->contents + hh->opd_offset + 24);

	    /* The DLT value is the address of the .opd entry.  */
	    value = (hh->opd_offset
		     + hppa_info->opd_sec->output_offset
		     + hppa_info->opd_sec->output_section->vma);

	    bfd_put_64 (hppa_info->dlt_sec->owner,
			value,
			hppa_info->dlt_sec->contents + hh->dlt_offset);
	  }

	/* We want the value of the DLT offset for this symbol, not
	   the symbol's actual address.  Note that __gp may not point
	   to the start of the DLT, so we have to compute the absolute
	   address, then subtract out the value of __gp.  */
	value = (hh->dlt_offset
		 + hppa_info->dlt_sec->output_offset
		 + hppa_info->dlt_sec->output_section->vma);
	value -= _bfd_get_gp_value (output_bfd);
	bfd_put_64 (input_bfd, value, hit_data);
	return bfd_reloc_ok;
      }

    case R_PARISC_DIR32:
      bfd_put_32 (input_bfd, value + addend, hit_data);
      return bfd_reloc_ok;

    case R_PARISC_DIR64:
      bfd_put_64 (input_bfd, value + addend, hit_data);
      return bfd_reloc_ok;

    case R_PARISC_GPREL64:
      /* Subtract out the global pointer value to make value a DLT
	 relative address.  */
      value -= _bfd_get_gp_value (output_bfd);

      bfd_put_64 (input_bfd, value + addend, hit_data);
      return bfd_reloc_ok;

    case R_PARISC_LTOFF64:
	/* We want the value of the DLT offset for this symbol, not
	   the symbol's actual address.  Note that __gp may not point
	   to the start of the DLT, so we have to compute the absolute
	   address, then subtract out the value of __gp.  */
      value = (hh->dlt_offset
	       + hppa_info->dlt_sec->output_offset
	       + hppa_info->dlt_sec->output_section->vma);
      value -= _bfd_get_gp_value (output_bfd);

      bfd_put_64 (input_bfd, value + addend, hit_data);
      return bfd_reloc_ok;

    case R_PARISC_PCREL32:
      {
	/* If this is a call to a function defined in another dynamic
	   library, then redirect the call to the local stub for this
	   function.  */
	if (sym_sec == NULL || sym_sec->output_section == NULL)
	  value = (hh->stub_offset + hppa_info->stub_sec->output_offset
		   + hppa_info->stub_sec->output_section->vma);

	/* Turn VALUE into a proper PC relative address.  */
	value -= (offset + input_section->output_offset
		  + input_section->output_section->vma);

	value += addend;
	value -= 8;
	bfd_put_32 (input_bfd, value, hit_data);
	return bfd_reloc_ok;
      }

    case R_PARISC_PCREL64:
      {
	/* If this is a call to a function defined in another dynamic
	   library, then redirect the call to the local stub for this
	   function.  */
	if (sym_sec == NULL || sym_sec->output_section == NULL)
	  value = (hh->stub_offset + hppa_info->stub_sec->output_offset
		   + hppa_info->stub_sec->output_section->vma);

	/* Turn VALUE into a proper PC relative address.  */
	value -= (offset + input_section->output_offset
		  + input_section->output_section->vma);

	value += addend;
	value -= 8;
	bfd_put_64 (input_bfd, value, hit_data);
	return bfd_reloc_ok;
      }

    case R_PARISC_FPTR64:
      {
	bfd_vma off;

	/* We may still need to create the FPTR itself if it was for
	   a local symbol.  */
	if (hh == NULL)
	  {
	    bfd_vma *local_opd_offsets;

            if (local_offsets == NULL)
              abort ();

	    local_opd_offsets = local_offsets + 2 * symtab_hdr->sh_info;
	    off = local_opd_offsets[r_symndx];

	    /* The last bit records whether we've already initialised
	       this local .opd entry.  */
	    if ((off & 1) != 0)
	      {
		BFD_ASSERT (off != (bfd_vma) -1);
	        off &= ~1;
	      }
	    else
	      {
		/* The first two words of an .opd entry are zero.  */
		memset (hppa_info->opd_sec->contents + off, 0, 16);

		/* The next word is the address of the function.  */
		bfd_put_64 (hppa_info->opd_sec->owner, value + addend,
			    (hppa_info->opd_sec->contents + off + 16));

		/* The last word is our local __gp value.  */
		value = _bfd_get_gp_value
			  (hppa_info->opd_sec->output_section->owner);
		bfd_put_64 (hppa_info->opd_sec->owner, value,
			    hppa_info->opd_sec->contents + off + 24);
	      }
	  }
	else
	  off = hh->opd_offset;

	if (hh == NULL || hh->want_opd)
	  /* We want the value of the OPD offset for this symbol.  */
	  value = (off
		   + hppa_info->opd_sec->output_offset
		   + hppa_info->opd_sec->output_section->vma);
	else
	  /* We want the address of the symbol.  */
	  value += addend;

	bfd_put_64 (input_bfd, value, hit_data);
	return bfd_reloc_ok;
      }

    case R_PARISC_SECREL32:
      if (sym_sec)
	value -= sym_sec->output_section->vma;
      bfd_put_32 (input_bfd, value + addend, hit_data);
      return bfd_reloc_ok;

    case R_PARISC_SEGREL32:
    case R_PARISC_SEGREL64:
      {
	/* If this is the first SEGREL relocation, then initialize
	   the segment base values.  */
	if (hppa_info->text_segment_base == (bfd_vma) -1)
	  bfd_map_over_sections (output_bfd, elf_hppa_record_segment_addrs,
				 hppa_info);

	/* VALUE holds the absolute address.  We want to include the
	   addend, then turn it into a segment relative address.

	   The segment is derived from SYM_SEC.  We assume that there are
	   only two segments of note in the resulting executable/shlib.
	   A readonly segment (.text) and a readwrite segment (.data).  */
	value += addend;

	if (sym_sec->flags & SEC_CODE)
	  value -= hppa_info->text_segment_base;
	else
	  value -= hppa_info->data_segment_base;

	if (r_type == R_PARISC_SEGREL32)
	  bfd_put_32 (input_bfd, value, hit_data);
	else
	  bfd_put_64 (input_bfd, value, hit_data);
	return bfd_reloc_ok;
      }

    /* Something we don't know how to handle.  */
    default:
      return bfd_reloc_notsupported;
    }

  /* Update the instruction word.  */
  bfd_put_32 (input_bfd, (bfd_vma) insn, hit_data);
  return bfd_reloc_ok;
}

/* Relocate an HPPA ELF section.  */

static bfd_boolean
elf64_hppa_relocate_section (bfd *output_bfd,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  struct elf64_hppa_link_hash_table *hppa_info;

  hppa_info = hppa_link_hash_table (info);
  if (hppa_info == NULL)
    return FALSE;

  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto = elf_hppa_howto_table + ELF_R_TYPE (rel->r_info);
      unsigned long r_symndx;
      struct elf_link_hash_entry *eh;
      Elf_Internal_Sym *sym;
      asection *sym_sec;
      bfd_vma relocation;
      bfd_reloc_status_type r;

      r_type = ELF_R_TYPE (rel->r_info);
      if (r_type < 0 || r_type >= (int) R_PARISC_UNIMPLEMENTED)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      if (r_type == (unsigned int) R_PARISC_GNU_VTENTRY
	  || r_type == (unsigned int) R_PARISC_GNU_VTINHERIT)
	continue;

      /* This is a final link.  */
      r_symndx = ELF_R_SYM (rel->r_info);
      eh = NULL;
      sym = NULL;
      sym_sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* This is a local symbol, hh defaults to NULL.  */
	  sym = local_syms + r_symndx;
	  sym_sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sym_sec, rel);
	}
      else
	{
	  /* This is not a local symbol.  */
	  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);

	  /* It seems this can happen with erroneous or unsupported
	     input (mixing a.out and elf in an archive, for example.)  */
	  if (sym_hashes == NULL)
	    return FALSE;

	  eh = sym_hashes[r_symndx - symtab_hdr->sh_info];

	  while (eh->root.type == bfd_link_hash_indirect
		 || eh->root.type == bfd_link_hash_warning)
	    eh = (struct elf_link_hash_entry *) eh->root.u.i.link;

	  relocation = 0;
	  if (eh->root.type == bfd_link_hash_defined
	      || eh->root.type == bfd_link_hash_defweak)
	    {
	      sym_sec = eh->root.u.def.section;
	      if (sym_sec != NULL
		  && sym_sec->output_section != NULL)
		relocation = (eh->root.u.def.value
			      + sym_sec->output_section->vma
			      + sym_sec->output_offset);
	    }
	  else if (eh->root.type == bfd_link_hash_undefweak)
	    ;
	  else if (info->unresolved_syms_in_objects == RM_IGNORE
		   && ELF_ST_VISIBILITY (eh->other) == STV_DEFAULT)
	    ;
	  else if (!info->relocatable
		   && elf_hppa_is_dynamic_loader_symbol (eh->root.root.string))
	    continue;
	  else if (!info->relocatable)
	    {
	      bfd_boolean err;
	      err = (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
		     || ELF_ST_VISIBILITY (eh->other) != STV_DEFAULT);
	      if (!info->callbacks->undefined_symbol (info,
						      eh->root.root.string,
						      input_bfd,
						      input_section,
						      rel->r_offset, err))
		return FALSE;
	    }

          if (!info->relocatable
              && relocation == 0
              && eh->root.type != bfd_link_hash_defined
              && eh->root.type != bfd_link_hash_defweak
              && eh->root.type != bfd_link_hash_undefweak)
            {
              if (info->unresolved_syms_in_objects == RM_IGNORE
                  && ELF_ST_VISIBILITY (eh->other) == STV_DEFAULT
                  && eh->type == STT_PARISC_MILLI)
                {
                  if (! info->callbacks->undefined_symbol
                      (info, eh_name (eh), input_bfd,
                       input_section, rel->r_offset, FALSE))
                    return FALSE;
                }
            }
	}

      if (sym_sec != NULL && discarded_section (sym_sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      r = elf_hppa_final_link_relocate (rel, input_bfd, output_bfd,
					input_section, contents,
					relocation, info, sym_sec,
					eh);

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *sym_name;

		if (eh != NULL)
		  sym_name = NULL;
		else
		  {
		    sym_name = bfd_elf_string_from_elf_section (input_bfd,
								symtab_hdr->sh_link,
								sym->st_name);
		    if (sym_name == NULL)
		      return FALSE;
		    if (*sym_name == '\0')
		      sym_name = bfd_section_name (input_bfd, sym_sec);
		  }

		if (!((*info->callbacks->reloc_overflow)
		      (info, (eh ? &eh->root : NULL), sym_name,
		       howto->name, (bfd_vma) 0, input_bfd,
		       input_section, rel->r_offset)))
		  return FALSE;
	      }
	      break;
	    }
	}
    }
  return TRUE;
}

static const struct bfd_elf_special_section elf64_hppa_special_sections[] =
{
  { STRING_COMMA_LEN (".fini"),  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".init"),  0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".plt"),   0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_PARISC_SHORT },
  { STRING_COMMA_LEN (".dlt"),   0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_PARISC_SHORT },
  { STRING_COMMA_LEN (".sdata"), 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_PARISC_SHORT },
  { STRING_COMMA_LEN (".sbss"),  0, SHT_NOBITS, SHF_ALLOC + SHF_WRITE + SHF_PARISC_SHORT },
  { STRING_COMMA_LEN (".tbss"),  0, SHT_NOBITS, SHF_ALLOC + SHF_WRITE + SHF_HP_TLS },
  { NULL,                    0,  0, 0,            0 }
};

/* The hash bucket size is the standard one, namely 4.  */

const struct elf_size_info hppa64_elf_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_External_Rel),
  sizeof (Elf64_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  4,
  1,
  64, 3,
  ELFCLASS64, EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  bfd_elf64_checksum_contents,
  bfd_elf64_write_relocs,
  bfd_elf64_swap_symbol_in,
  bfd_elf64_swap_symbol_out,
  bfd_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
};

#define TARGET_BIG_SYM			bfd_elf64_hppa_vec
#define TARGET_BIG_NAME			"elf64-hppa"
#define ELF_ARCH			bfd_arch_hppa
#define ELF_TARGET_ID			HPPA64_ELF_DATA
#define ELF_MACHINE_CODE		EM_PARISC
/* This is not strictly correct.  The maximum page size for PA2.0 is
   64M.  But everything still uses 4k.  */
#define ELF_MAXPAGESIZE			0x1000
#define ELF_OSABI			ELFOSABI_HPUX

#define bfd_elf64_bfd_reloc_type_lookup elf_hppa_reloc_type_lookup
#define bfd_elf64_bfd_reloc_name_lookup elf_hppa_reloc_name_lookup
#define bfd_elf64_bfd_is_local_label_name       elf_hppa_is_local_label_name
#define elf_info_to_howto		elf_hppa_info_to_howto
#define elf_info_to_howto_rel		elf_hppa_info_to_howto_rel

#define elf_backend_section_from_shdr	elf64_hppa_section_from_shdr
#define elf_backend_object_p		elf64_hppa_object_p
#define elf_backend_final_write_processing \
					elf_hppa_final_write_processing
#define elf_backend_fake_sections	elf_hppa_fake_sections
#define elf_backend_add_symbol_hook	elf_hppa_add_symbol_hook

#define elf_backend_relocate_section	elf_hppa_relocate_section

#define bfd_elf64_bfd_final_link	elf_hppa_final_link

#define elf_backend_create_dynamic_sections \
					elf64_hppa_create_dynamic_sections
#define elf_backend_post_process_headers	elf64_hppa_post_process_headers

#define elf_backend_omit_section_dynsym \
  ((bfd_boolean (*) (bfd *, struct bfd_link_info *, asection *)) bfd_true)
#define elf_backend_adjust_dynamic_symbol \
					elf64_hppa_adjust_dynamic_symbol

#define elf_backend_size_dynamic_sections \
					elf64_hppa_size_dynamic_sections

#define elf_backend_finish_dynamic_symbol \
					elf64_hppa_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					elf64_hppa_finish_dynamic_sections
#define elf_backend_grok_prstatus	elf64_hppa_grok_prstatus
#define elf_backend_grok_psinfo		elf64_hppa_grok_psinfo

/* Stuff for the BFD linker: */
#define bfd_elf64_bfd_link_hash_table_create \
	elf64_hppa_hash_table_create

#define elf_backend_check_relocs \
	elf64_hppa_check_relocs

#define elf_backend_size_info \
  hppa64_elf_size_info

#define elf_backend_additional_program_headers \
	elf64_hppa_additional_program_headers

#define elf_backend_modify_segment_map \
	elf64_hppa_modify_segment_map

#define elf_backend_link_output_symbol_hook \
	elf64_hppa_link_output_symbol_hook

#define elf_backend_want_got_plt	0
#define elf_backend_plt_readonly	0
#define elf_backend_want_plt_sym	0
#define elf_backend_got_header_size     0
#define elf_backend_type_change_ok	TRUE
#define elf_backend_get_symbol_type	elf64_hppa_elf_get_symbol_type
#define elf_backend_reloc_type_class	elf64_hppa_reloc_type_class
#define elf_backend_rela_normal		1
#define elf_backend_special_sections	elf64_hppa_special_sections
#define elf_backend_action_discarded	elf_hppa_action_discarded
#define elf_backend_section_from_phdr   elf64_hppa_section_from_phdr

#define elf64_bed			elf64_hppa_hpux_bed

#include "elf64-target.h"

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM			bfd_elf64_hppa_linux_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME			"elf64-hppa-linux"
#undef ELF_OSABI
#define ELF_OSABI			ELFOSABI_GNU
#undef elf_backend_post_process_headers
#define elf_backend_post_process_headers _bfd_elf_set_osabi
#undef elf64_bed
#define elf64_bed			elf64_hppa_linux_bed

#include "elf64-target.h"
@


1.117
log
@	* elf64-hppa.c (elf64_hppa_finish_dynamic_sections)
	<DT_HP_LOAD_MAP>: Return unsuccessfully if there's no `.data'
	section.
@
text
@d3280 1
a3280 1
	      (_("%B(%A+0x" BFD_VMA_FMT "x): cannot reach %s"),
@


1.116
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d2527 2
@


1.115
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d647 3
@


1.114
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@a196 3
static enum elf_reloc_type_class elf64_hppa_reloc_type_class
  (const Elf_Internal_Rela *);

d2446 3
a2448 1
elf64_hppa_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.113
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Rename segment_map to seg_map.
	Delete num_locals and num_globals.
	(elf_num_locals, elf_num_globals): Don't define.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_strtab_sec, elf_shstrtab_sec): Define.
	* bfd.c, * elf-eh-frame.c, * elf-nacl.c, * elf-vxworks.c, * elf.c,
	* elf32-arm.c, * elf32-lm32.c, * elf32-ppc.c, * elf32-rx.c,
	* elf32-spu.c, * elf64-hppa.c, * elfcode.h, * elflink.c,
	* elfnn-ia64.c, * elfxx-mips.c: Use newly defined elf_obj_tdata
	accessor macros.
	* elf.c (elf_map_symbols): Add pnum_locals param.  Return
	number of locals syms via new param.
	(swap_out_syms): Adjust to suit elf_map_symbols change.
ld/
	* emultempl/elf-generic.em: Use newly defined elf_obj_tdata
	accessor macros.
@
text
@d2594 1
a2594 1
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d2597 1
a2597 1
	elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 32);
d2623 1
a2623 1
      elf_tdata (abfd)->core_program
d2625 1
a2625 1
      elf_tdata (abfd)->core_command
d2632 1
a2632 1
  command = elf_tdata (abfd)->core_command;
d2775 1
a2775 1
      elf_tdata (abfd)->core_signal = sig;
@


1.112
log
@	* i386linux.c (linux_link_hash_table_create): Allocate table
	with bfd_zmalloc, not bfd_alloc.
	* pdp11.c (link_hash_table_create): Allocate table with
	bfd_malloc, not bfd_alloc.
	* elf32-bfin.c (bfinfdpic_elf_link_hash_table_create): Allocate table
	with bfd_zmalloc, not bfd_zalloc.
	(bfin_link_hash_table_create): Likewise.
	* elf32-frv.c (frvfdpic_elf_link_hash_table_create): Likewise.
	* elf64-hppa.c (elf64_hppa_hash_table_create): Likewise.
@
text
@d2690 1
a2690 1
      for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
d2706 2
a2707 2
	  m->next = elf_tdata (abfd)->segment_map;
	  elf_tdata (abfd)->segment_map = m;
d2711 1
a2711 1
  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
@


1.111
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d302 1
a302 1
  htab = bfd_zalloc (abfd, amt);
d311 1
a311 1
      bfd_release (abfd, htab);
@


1.110
log
@Add copyright notices
@
text
@d479 1
a479 1
                  
d799 1
a799 1
                  
d824 1
a824 1
                  
d858 1
a858 1
                  
d1135 1
a1135 1
  
d1642 1
a1642 1
	      if (info->shared) 
d2216 1
a2216 1
 
d3193 1
a3193 1
  
d3862 1
a3862 1
	  /* It seems this can happen with erroneous or unsupported 
d3869 1
a3869 1
	  while (eh->root.type == bfd_link_hash_indirect 
d4060 1
a4060 1
 
@


1.109
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d2 2
a3 2
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012
@


1.108
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d419 1
a419 1
  srel = bfd_get_section_by_name (dynobj, srel_name);
d422 7
a428 7
      srel = bfd_make_section_with_flags (dynobj, srel_name,
					  (SEC_ALLOC
					   | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_LINKER_CREATED
					   | SEC_READONLY));
d1160 6
a1165 6
      opd = bfd_make_section_with_flags (dynobj, ".opd",
					 (SEC_ALLOC
					  | SEC_LOAD
					  | SEC_HAS_CONTENTS
					  | SEC_IN_MEMORY
					  | SEC_LINKER_CREATED));
d1196 6
a1201 6
      plt = bfd_make_section_with_flags (dynobj, ".plt",
					 (SEC_ALLOC
					  | SEC_LOAD
					  | SEC_HAS_CONTENTS
					  | SEC_IN_MEMORY
					  | SEC_LINKER_CREATED));
d1232 6
a1237 6
      dlt = bfd_make_section_with_flags (dynobj, ".dlt",
					 (SEC_ALLOC
					  | SEC_LOAD
					  | SEC_HAS_CONTENTS
					  | SEC_IN_MEMORY
					  | SEC_LINKER_CREATED));
d1268 6
a1273 6
      stub = bfd_make_section_with_flags (dynobj, ".stub",
					  (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_READONLY
					   | SEC_LINKER_CREATED));
d1348 6
a1353 6
  s = bfd_make_section_with_flags (abfd, ".rela.dlt",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_READONLY
				    | SEC_LINKER_CREATED));
d1359 6
a1364 6
  s = bfd_make_section_with_flags (abfd, ".rela.plt",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_READONLY
				    | SEC_LINKER_CREATED));
d1370 6
a1375 6
  s = bfd_make_section_with_flags (abfd, ".rela.data",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_READONLY
				    | SEC_LINKER_CREATED));
d1381 6
a1386 6
  s = bfd_make_section_with_flags (abfd, ".rela.opd",
				   (SEC_ALLOC | SEC_LOAD
				    | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY
				    | SEC_READONLY
				    | SEC_LINKER_CREATED));
d1565 1
a1565 1
	  sec = bfd_get_section_by_name (dynobj, ".interp");
d1578 1
a1578 1
      sec = bfd_get_section_by_name (dynobj, ".rela.dlt");
d2495 1
a2495 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
@


1.107
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.106
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3925 1
a3925 1
					 rel, relend, howto, contents);
@


1.105
log
@	* elf64-hppa.c (elf_hppa_final_link_relocate): Fix handling of out
	of range branches.
@
text
@d3 2
a4 1
   2010, 2011 Free Software Foundation, Inc.
d3923 1
a3923 1
      if (sym_sec != NULL && elf_discarded_section (sym_sec))
@


1.105.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3922 1
a3922 1
      if (sym_sec != NULL && discarded_section (sym_sec))
@


1.104
log
@ELFOSABI_GNU

	bfd/
	* elf.c (_bfd_elf_set_osabi): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.

	binutils/
	* elfedit.c (osabis): Use ELFOSABI_GNU name instead of ELFOSABI_LINUX
	alias and ELFOSABI_HURD.  Add GNU alias.
	* readelf.c (get_osabi_name, get_symbol_binding, get_symbol_type):
	Likewise.
	* doc/binutils.texi <elfedit>: Update accordingly.

	elfcpp/
	* elfcpp.h (ELFOSABI): Add ELFOSABI_GNU with value of ELFOSABI_LINUX,
	keep ELFOSABI_LINUX as an alias.  Remove ELFOSABI_HURD.

	gas/
	* config/obj-elf.c (obj_elf_type): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* config/tc-ia64.c: Likewise.

	include/elf/
	* common.h (ELFOSABI_GNU): Define, replaces...
	(ELFOSABI_LINUX): ... this, kept as an alias.
	(ELFOSABI_HURD): Remove.

	ld/testsuite/
	* ld-ifunc/ifunc.exp: Update for changed output.
	* ld-unique/unique.exp: Likewise.
@
text
@d3275 1
a3275 1
	      (_("%B(%A+0x%lx): cannot reach %s"),
d3279 1
a3279 1
	      eh->root.root.string);
d3281 1
a3281 1
	    return bfd_reloc_notsupported;
@


1.103
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d332 1
a332 1
      /* GCC on hppa-linux produces binaries with OSABI=Linux,
d334 1
a334 1
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX
d4100 1
a4100 1
#define ELF_OSABI			ELFOSABI_LINUX
@


1.102
log
@bfd/
	* hash.c (bfd_hash_hash): Extract from..
	(bfd_hash_lookup): ..here.
	(bfd_hash_rename): New function.
	* section.c (bfd_rename_section): New function.
	* bfd-in.h (bfd_hash_rename): Declare.
	* bfd-in2.h: Regenerate.
	* elf.c (_bfd_elf_make_section_from_shdr): Rename input sections
	when compressing or decompressing.  Don't assert name match.
	* elf64-hppa.c (get_reloc_section): Don't assert name match.
	* elfxx-ia64.c (get_reloc_section): Likewise.
binutils/
	* objcopy.c (copy_main): No need to rename sections when compressing
	or decompressing.
binutils/testsuite/
	* binutils-all/objdump.W: Adjust expected result for debug section
	rename.
@
text
@d3 1
a3 1
   2010  Free Software Foundation, Inc.
a939 3
  if (eh->root.type == bfd_link_hash_warning)
    eh = (struct elf_link_hash_entry *) eh->root.u.i.link;

a1055 4
      while (hh->eh.root.type == bfd_link_hash_indirect
	     || hh->eh.root.type == bfd_link_hash_warning)
	hh = hppa_elf_hash_entry (hh->eh.root.u.i.link);

d1508 1
a1508 5
  struct elf_link_hash_entry *elf = eh;
  struct bfd_link_info *info = (struct bfd_link_info *)data;

  if (elf->root.type == bfd_link_hash_warning)
    elf = (struct elf_link_hash_entry *) elf->root.u.i.link;
d1510 1
a1510 1
  if (elf->type == STT_PARISC_MILLI)
d1512 1
a1512 1
      if (elf->dynindx != -1)
d1514 1
a1514 1
	  elf->dynindx = -1;
d1516 1
a1516 1
				  elf->dynstr_index);
a2830 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a2861 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.101
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@a413 7
  BFD_ASSERT ((CONST_STRNEQ (srel_name, ".rela")
	       && strcmp (bfd_get_section_name (abfd, sec),
			  srel_name + 5) == 0)
	      || (CONST_STRNEQ (srel_name, ".rel")
		  && strcmp (bfd_get_section_name (abfd, sec),
			     srel_name + 4) == 0));

@


1.101.2.1
log
@backport from mainline
@
text
@d414 7
@


1.100
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d3947 2
a3948 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.99
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d410 1
a410 1
		elf_section_data(sec)->rel_hdr.sh_name));
@


1.98
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2468 1
a2468 1
  if (ELF64_R_SYM (rela->r_info) == 0)
@


1.97
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d4048 1
@


1.96
log
@fix set but unused variable warnings
@
text
@d2614 1
a2614 1
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);
@


1.95
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@a373 2
  asection *newsect;

a391 1
  newsect = hdr->bfd_section;
a514 3
  asection *dlt, *plt, *stubs;
  char *buf;
  size_t buf_len;
a626 4
  dlt = plt = stubs = NULL;
  buf = NULL;
  buf_len = 0;

a899 2
  if (buf)
    free (buf);
a902 2
  if (buf)
    free (buf);
d1968 1
a1968 1
  asection *stub, *splt, *sdlt, *sopd, *spltrel, *sdltrel;
a1976 1
  sdlt = hppa_info->dlt_sec;
a1978 1
  sdltrel = hppa_info->dlt_rel_sec;
a3856 1
      bfd_boolean warned_undef;
a3872 1
      warned_undef = FALSE;
a3882 1
	  bfd_boolean unresolved_reloc;
a3895 2
	  warned_undef = FALSE;
	  unresolved_reloc = FALSE;
d3901 2
a3902 8
	      if (sym_sec == NULL
		  || sym_sec->output_section == NULL)
		/* Set a flag that will be cleared later if we find a
		   relocation value for this symbol.  output_section
		   is typically NULL for symbols satisfied by a shared
		   library.  */
		unresolved_reloc = TRUE;
	      else
a3925 1
	      warned_undef = TRUE;
a3941 1
                  warned_undef = TRUE;
@


1.94
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 2
a3 2
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
d151 2
a152 1
  ((struct elf64_hppa_link_hash_table *) ((p)->hash))
d307 2
a308 1
				      sizeof (struct elf64_hppa_link_hash_entry)))
d535 2
d958 2
d1021 1
a1021 1
  struct elf64_hppa_allocate_data *x = (struct elf64_hppa_allocate_data *)data;
d1032 9
a1040 1
	hppa_link_hash_table (x->info)->gp_offset = hh->plt_offset;
d1357 5
d1363 1
a1363 1
  if (! get_stub (abfd, info, hppa_link_hash_table (info)))
d1366 1
a1366 1
  if (! get_dlt (abfd, info, hppa_link_hash_table (info)))
d1369 1
a1369 1
  if (! get_plt (abfd, info, hppa_link_hash_table (info)))
d1372 1
a1372 1
  if (! get_opd (abfd, info, hppa_link_hash_table (info)))
d1384 1
a1384 1
  hppa_link_hash_table (info)->dlt_rel_sec = s;
d1395 1
a1395 1
  hppa_link_hash_table (info)->plt_rel_sec = s;
d1406 1
a1406 1
  hppa_link_hash_table (info)->other_rel_sec = s;
d1417 1
a1417 1
  hppa_link_hash_table (info)->opd_rel_sec = s;
d1435 3
d1572 2
d1986 2
d2159 3
d2279 2
d2384 2
d2509 2
d2986 3
d3230 3
d3856 3
@


1.93
log
@	* elf32-hppa.c (elf32_hppa_final_link): Don't sort unwind information
	in a relocatable link.
	* elf64-hppa.c (elf_hppa_final_link): Likewise.
@
text
@d2743 1
d2745 1
a2745 1
elf64_hppa_section_from_phdr (bfd *abfd, Elf_Internal_Phdr *hdr, int index,
d2752 1
a2752 1
      if (!_bfd_elf_make_section_from_phdr (abfd, hdr, index, typename))
d2775 1
a2775 1
      if (!_bfd_elf_make_section_from_phdr (abfd, hdr, index, typename))
d2788 1
a2788 1
  return _bfd_elf_make_section_from_phdr (abfd, hdr, index, typename);
d2804 1
a2804 1
  unsigned int index = sym->st_shndx;
d2806 1
a2806 1
  switch (index)
@


1.92
log
@	* elf-bfd.h (struct elf_backend_data
	<elf_backend_link_output_symbol_hook>): Return an int.
	* elf64-ppc.c (ppc64_elf_output_symbol_hook): Return 2 to drop
	symbols on deleted .opd entries.
	* elflink.c (elf_link_output_sym): Return without outputting sym
	if output_symbol_hook returns 2.
	(elf_link_output_extsym): Don't assign h->indx when symbol discarded.
	Abort if we must not discard sym.
	(elf_link_input_bfd): Similarly, don't set finfo->indices for
	local syms.
	(bfd_elf_final_link): Adjust elf_link_output_sym calls.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Adjust for
	elf_backend_link_output_symbol_hook return type change.
	* elf32-arm.c (output_arch_syminfo): Likewise.
	(elf32_arm_output_map_sym, elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_output_arch_local_syms): Likewise.
	* elf32-cr16c.c (elf32_cr16c_link_output_symbol_hook): Likewise.
	* elf32-score.c (s3_bfd_score_elf_link_output_symbol_hook): Likewise.
	(bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score.h (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_link_output_symbol_hook): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Likewise.
	* elf32-spu.c (spu_elf_output_symbol_hook): Likewise.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
@
text
@d3036 1
a3036 1
  if (retval)
@


1.91
log
@include/
	* alloca-conf.h: Revise based on autoconf-2.61, autoconf-2.13
	documentation.
bfd/
	* elf32-m68hc1x.c: Include alloca-conf.h.
	* xsym.c: Likewise.
	* elf64-hppa.c: Likewise.  Remove existing #if's handling alloca.
	* som.c: Likewise.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* sysdep.h: Include alloca-conf.h instead of config.h and remove
	existing #if's handling alloca.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
gas/
	* as.h: Include alloca-conf.h instead of config.h and remove
	existing #if's handling alloca.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* openrisc-opc.c: Regenerate.
ld/
	* ld.h: Remove alloca handling.
@
text
@d187 1
a187 1
static bfd_boolean elf64_hppa_link_output_symbol_hook
d1917 1
a1917 1
static bfd_boolean
d1929 1
a1929 1
    return TRUE;
d1945 1
a1945 1
  return TRUE;
@


1.90
log
@	* elf_hppa_add_symbol_hook (elf_hppa_add_symbol_hook): Move to
	elf64-hppa.c.
	(elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_is_dynamic_loader_symbol): Likewise.
	(elf_hppa_record_segment_addrs): Likewise.
	(elf_hppa_final_link): Likewise.
	(elf_hppa_relocate_insn): Likewise.
	(elf_hppa_final_link_relocate): Likewise.
	(elf64_hppa_relocate_section): Likewise.
	* elf64-hppa.c: Insert above.
@
text
@d22 1
a30 25
/* This is the code recommended in the autoconf documentation, almost
   verbatim.  */
#ifndef __GNUC__
# if HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifdef _AIX
/* Indented so that pre-ansi C compilers will ignore it, rather than
   choke on it.  Some versions of AIX require this to be the first
   thing in the file.  */
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
#    if !defined (__STDC__) && !defined (__hpux)
extern char *alloca ();
#    else
extern void *alloca ();
#    endif /* __STDC__, __hpux */
#   endif /* alloca */
#  endif /* _AIX */
# endif /* HAVE_ALLOCA_H */
#else
extern void *alloca (size_t);
#endif /* __GNUC__ */

@


1.89
log
@	* elf-hppa.h (elf_hppa_final_link): Use elf_hppa_final_link.
	(elf_hppa_final_link_relocate ): Rewrite eliminating dynamic hash table.
	(elf_hppa_relocate_section): Likewise.
	* elf64-hppa.c (struct elf64_hppa_link_hash_entry): Change to derive
	from struct elf_link_hash_entry.  Add count field.
	(struct elf64_hppa_dyn_hash_table): Delete.
	(struct elf64_hppa_link_hash_table): Delete dyn_hash_table field.
	(elf64_hppa_hash_table): Rename to hppa_link_hash_table.
	(hppa_elf_hash_entry, eh_name): Define.
	(elf64_hppa_new_dyn_hash_entry): Delete.
	(elf64_hppa_dyn_hash_lookup): Delete.
	(elf64_hppa_dyn_hash_traverse): Delete.
	(get_dyn_name): Delete.
	(elf64_hppa_finalize_opd): Use struct elf_link_hash_entry * instead
	of struct elf64_hppa_dyn_hash_entry *.
	(elf64_hppa_finalize_dlt, llocate_global_data_dlt,
	allocate_global_data_plt, allocate_global_data_stub,
	allocate_global_data_opd, count_dyn_reloc, allocate_dynrel_entries):
	Likewise.
	(hppa64_link_hash_newfunc): New.
	(elf64_hppa_hash_table_create): Rework.
	(count_dyn_reloc): Likewise.
	(hppa64_elf_local_refcounts): New.
	(elf64_hppa_check_relocs): Rework using standard technique for recording
	local DLT, PLT and OPD reference counts.
	(elf64_hppa_dynamic_symbol_p): Revise using "eh" for struct
	elf_link_hash_entry *.
	(elf64_hppa_mark_exported_functions, allocate_global_data_dlt,
	allocate_global_data_plt, allocate_global_data_stub,
	allocate_global_data_opd, allocate_dynrel_entries,
	elf64_hppa_adjust_dynamic_symbol,
	elf64_hppa_mark_milli_and_exported_functions): Likewise.
	(elf64_hppa_create_dynamic_sections, elf64_hppa_size_dynamic_sections):
	Use hppa_link_hash_table.  Rework.
	(elf64_hppa_link_output_symbol_hook): Rework.
	(elf64_hppa_finish_dynamic_symbol, elf64_hppa_finalize_opd,
	elf64_hppa_finalize_dlt, elf64_hppa_finalize_dynreloc,
	elf64_hppa_finish_dynamic_sections): Likewise.
@
text
@d2814 1195
@


1.88
log
@	* elf64-hppa.c: Remove PARAMS macro.  Replace PTR with void *.  Convert
	functions to C90.
	* elf64-hppa.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d77 1
a77 1
struct elf64_hppa_dyn_hash_entry
d79 1
a79 1
  struct bfd_hash_entry root;
a86 3
  /* The symbol table entry, if any, that this was derived from.  */
  struct elf_link_hash_entry *h;

d115 3
a137 5
struct elf64_hppa_dyn_hash_table
{
  struct bfd_hash_table root;
};

a163 2
  struct elf64_hppa_dyn_hash_table dyn_hash_table;

d174 1
a174 1
#define elf64_hppa_hash_table(p) \
d177 6
a185 4
static struct bfd_hash_entry *elf64_hppa_new_dyn_hash_entry
  (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
   const char *string);

a188 13
static struct elf64_hppa_dyn_hash_entry *elf64_hppa_dyn_hash_lookup
  (struct elf64_hppa_dyn_hash_table *table, const char *string,
   bfd_boolean create, bfd_boolean copy);

static void elf64_hppa_dyn_hash_traverse
  (struct elf64_hppa_dyn_hash_table *table,
   bfd_boolean (*func) (struct elf64_hppa_dyn_hash_entry *, void *),
   void *info);

static const char *get_dyn_name
  (bfd *, struct elf_link_hash_entry *,
   const Elf_Internal_Rela *, char **, size_t *);

d236 1
a236 1
  (struct elf64_hppa_dyn_hash_entry *, void *);
d239 1
a239 1
  (struct elf64_hppa_dyn_hash_entry *, void *);
d242 1
a242 1
  (struct elf64_hppa_dyn_hash_entry *, void *);
d245 1
a245 1
  (struct elf64_hppa_dyn_hash_entry *, void *);
d248 1
a248 1
  (struct elf64_hppa_dyn_hash_entry *, void *);
d251 1
a251 1
  (struct elf64_hppa_dyn_hash_entry *, void *);
d257 1
a257 1
  (bfd *, struct elf64_hppa_dyn_hash_entry *,
d261 1
a261 1
  (struct elf64_hppa_dyn_hash_entry *, void *);
d264 1
a264 1
  (struct elf64_hppa_dyn_hash_entry *, void *);
d281 6
a286 14
static bfd_boolean
elf64_hppa_dyn_hash_table_init (struct elf64_hppa_dyn_hash_table *ht,
				bfd *abfd ATTRIBUTE_UNUSED,
				new_hash_entry_func new,
				unsigned int entsize)
{
  memset (ht, 0, sizeof (*ht));
  return bfd_hash_table_init (&ht->root, new, entsize);
}

static struct bfd_hash_entry*
elf64_hppa_new_dyn_hash_entry (struct bfd_hash_entry *entry,
			       struct bfd_hash_table *table,
			       const char *string)
a287 3
  struct elf64_hppa_dyn_hash_entry *ret;
  ret = (struct elf64_hppa_dyn_hash_entry *) entry;

d290 7
a296 5
  if (!ret)
    ret = bfd_hash_allocate (table, sizeof (*ret));

  if (!ret)
    return 0;
d299 4
a302 2
  ret = ((struct elf64_hppa_dyn_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
d304 6
a309 4
  /* Initialize our local data.  All zeros.  */
  memset (&ret->dlt_offset, 0,
	  (sizeof (struct elf64_hppa_dyn_hash_entry)
	   - offsetof (struct elf64_hppa_dyn_hash_entry, dlt_offset)));
d311 1
a311 1
  return &ret->root;
d321 2
a322 1
  struct elf64_hppa_link_hash_table *ret;
d324 7
a330 6
  ret = bfd_zalloc (abfd, (bfd_size_type) sizeof (*ret));
  if (!ret)
    return 0;
  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
				      _bfd_elf_link_hash_newfunc,
				      sizeof (struct elf_link_hash_entry)))
d332 2
a333 2
      bfd_release (abfd, ret);
      return 0;
d336 2
a337 8
  if (!elf64_hppa_dyn_hash_table_init (&ret->dyn_hash_table, abfd,
				       elf64_hppa_new_dyn_hash_entry,
				       sizeof (struct elf64_hppa_dyn_hash_entry)))
    return 0;
  return &ret->root.root;
}

/* Look up an entry in a PA64 ELF linker hash table.  */
d339 1
a339 20
static struct elf64_hppa_dyn_hash_entry *
elf64_hppa_dyn_hash_lookup(struct elf64_hppa_dyn_hash_table *table,
			   const char *string,
			   bfd_boolean create,
			   bfd_boolean copy)
{
  return ((struct elf64_hppa_dyn_hash_entry *)
	  bfd_hash_lookup (&table->root, string, create, copy));
}

/* Traverse a PA64 ELF linker hash table.  */

static void
elf64_hppa_dyn_hash_traverse (struct elf64_hppa_dyn_hash_table *table,
	bfd_boolean (*func) (struct elf64_hppa_dyn_hash_entry *, void *),
        void *info)
{
  bfd_hash_traverse (&table->root,
		     (bfd_boolean (*) (struct bfd_hash_entry *, void *)) func,
		     info);
a420 58
/* Construct a string for use in the elf64_hppa_dyn_hash_table.  The
   name describes what was once potentially anonymous memory.  We
   allocate memory as necessary, possibly reusing PBUF/PLEN.  */

static const char *
get_dyn_name (bfd *abfd,
	      struct elf_link_hash_entry *h,
	      const Elf_Internal_Rela *rel,
	      char **pbuf,
	      size_t *plen)
{
  asection *sec = abfd->sections;
  size_t nlen, tlen;
  char *buf;
  size_t len;

  if (h && rel->r_addend == 0)
    return h->root.root.string;

  if (h)
    nlen = strlen (h->root.root.string);
  else
    nlen = 8 + 1 + sizeof (rel->r_info) * 2 - 8;
  tlen = nlen + 1 + sizeof (rel->r_addend) * 2 + 1;

  len = *plen;
  buf = *pbuf;
  if (len < tlen)
    {
      if (buf)
	free (buf);
      *pbuf = buf = malloc (tlen);
      *plen = len = tlen;
      if (!buf)
	return NULL;
    }

  if (h)
    {
      memcpy (buf, h->root.root.string, nlen);
      buf[nlen++] = '+';
      sprintf_vma (buf + nlen, rel->r_addend);
    }
  else
    {
      nlen = sprintf (buf, "%x:%lx",
		      sec->id & 0xffffffff,
		      (unsigned long) ELF64_R_SYM (rel->r_info));
      if (rel->r_addend)
	{
	  buf[nlen++] = '+';
	  sprintf_vma (buf + nlen, rel->r_addend);
	}
    }

  return buf;
}

d477 1
a477 1
		 struct elf64_hppa_dyn_hash_entry *dyn_h,
d491 1
a491 1
  rent->next = dyn_h->reloc_entries;
d497 1
a497 1
  dyn_h->reloc_entries = rent;
d502 25
d556 1
a556 1
  hppa_info = elf64_hppa_hash_table (info);
a668 1
      struct elf_link_hash_entry *h = NULL;
d670 1
a670 1
      struct elf64_hppa_dyn_hash_entry *dyn_h;
a671 1
      const char *addr_name;
d681 4
a684 4
	  h = elf_sym_hashes (abfd)[indx];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d686 1
a686 1
	  h->ref_regular = 1;
d688 2
d696 1
a696 1
      if (h && ((info->shared
d699 2
a700 2
		|| !h->def_regular
		|| h->root.type == bfd_link_hash_defweak))
d751 6
a756 1
	  need_entry = (NEED_PLT | NEED_STUB);
d789 1
a789 1
	    need_entry = (NEED_DLT | NEED_OPD);
d791 1
a791 1
	    need_entry = (NEED_DLT | NEED_OPD);
d798 1
a798 1
	    need_entry = (NEED_OPD | NEED_DYNREL);
d800 1
a800 1
	    need_entry = (NEED_OPD);
d810 7
a816 2
      /* Collect a canonical name for this address.  */
      addr_name = get_dyn_name (abfd, h, rel, &buf, &buf_len);
a817 12
      /* Collect the canonical entry data for this address.  */
      dyn_h = elf64_hppa_dyn_hash_lookup (&hppa_info->dyn_hash_table,
					  addr_name, TRUE, TRUE);
      BFD_ASSERT (dyn_h);

      /* Stash away enough information to be able to find this symbol
	 regardless of whether or not it is local or global.  */
      dyn_h->h = h;
      dyn_h->owner = abfd;
      dyn_h->sym_indx = r_symndx;

      /* ?!? We may need to do some error checking in here.  */
d821 2
d826 16
a841 1
	  dyn_h->want_dlt = 1;
d849 19
a867 1
	  dyn_h->want_plt = 1;
d875 2
a876 1
	  dyn_h->want_stub = 1;
d885 2
a886 1
	  dyn_h->want_opd = 1;
d888 15
a902 7
	  /* FPTRs are not allocated by the dynamic linker for PA64, though
	     it is possible that will change in the future.  */

	  /* This could be a local function that had its address taken, in
	     which case H will be NULL.  */
	  if (h)
	    h->needs_plt = 1;
d913 4
a916 2
	  if (!count_dyn_reloc (abfd, dyn_h, dynrel_type, sec,
				sec_symndx, rel->r_offset, rel->r_addend))
d949 1
a949 1
elf64_hppa_dynamic_symbol_p (struct elf_link_hash_entry *h,
d955 1
a955 1
  if (_bfd_elf_dynamic_symbol_p (h, info, 1))
d958 1
a958 1
      if (h->root.root.string[0] == '$' && h->root.root.string[1] == '$')
d971 1
a971 2
elf64_hppa_mark_exported_functions (struct elf_link_hash_entry *h,
				    void *data)
d973 1
d977 1
a977 1
  hppa_info = elf64_hppa_hash_table (info);
d979 2
a980 16
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
      && h->root.u.def.section->output_section != NULL
      && h->type == STT_FUNC)
    {
       struct elf64_hppa_dyn_hash_entry *dyn_h;

      /* Add this symbol to the PA64 linker hash table.  */
      dyn_h = elf64_hppa_dyn_hash_lookup (&hppa_info->dyn_hash_table,
					  h->root.root.string, TRUE, TRUE);
      BFD_ASSERT (dyn_h);
      dyn_h->h = h;
d982 6
d992 2
a993 1
      dyn_h->want_opd = 1;
d995 2
a996 2
      dyn_h->st_shndx = -1;
      h->needs_plt = 1;
d1005 1
a1005 2
allocate_global_data_dlt (struct elf64_hppa_dyn_hash_entry *dyn_h,
			  void *data)
d1007 1
d1010 1
a1010 1
  if (dyn_h->want_dlt)
a1011 2
      struct elf_link_hash_entry *h = dyn_h->h;

d1017 1
a1017 2
	  if (! h
	      || (h->dynindx == -1 && h->type != STT_PARISC_MILLI))
d1019 1
a1019 2
	      bfd *owner;
	      owner = (h ? h->root.u.def.section->owner : dyn_h->owner);
d1022 1
a1022 1
		     (x->info, owner, dyn_h->sym_indx)))
d1027 1
a1027 1
      dyn_h->dlt_offset = x->ofs;
d1036 1
a1036 2
allocate_global_data_plt (struct elf64_hppa_dyn_hash_entry *dyn_h,
			  void *data)
d1038 1
d1041 5
a1045 5
  if (dyn_h->want_plt
      && elf64_hppa_dynamic_symbol_p (dyn_h->h, x->info)
      && !((dyn_h->h->root.type == bfd_link_hash_defined
	    || dyn_h->h->root.type == bfd_link_hash_defweak)
	   && dyn_h->h->root.u.def.section->output_section != NULL))
d1047 1
a1047 1
      dyn_h->plt_offset = x->ofs;
d1049 2
a1050 2
      if (dyn_h->plt_offset < 0x2000)
	elf64_hppa_hash_table (x->info)->gp_offset = dyn_h->plt_offset;
d1053 1
a1053 1
    dyn_h->want_plt = 0;
d1061 1
a1061 2
allocate_global_data_stub (struct elf64_hppa_dyn_hash_entry *dyn_h,
			   void *data)
d1063 1
d1066 5
a1070 5
  if (dyn_h->want_stub
      && elf64_hppa_dynamic_symbol_p (dyn_h->h, x->info)
      && !((dyn_h->h->root.type == bfd_link_hash_defined
	    || dyn_h->h->root.type == bfd_link_hash_defweak)
	   && dyn_h->h->root.u.def.section->output_section != NULL))
d1072 1
a1072 1
      dyn_h->stub_offset = x->ofs;
d1076 1
a1076 1
    dyn_h->want_stub = 0;
d1083 1
a1083 2
allocate_global_data_opd (struct elf64_hppa_dyn_hash_entry *dyn_h,
			  void *data)
d1085 1
d1088 1
a1088 1
  if (dyn_h->want_opd)
d1090 3
a1092 6
      struct elf_link_hash_entry *h = dyn_h->h;

      if (h)
	while (h->root.type == bfd_link_hash_indirect
	       || h->root.type == bfd_link_hash_warning)
	  h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1096 4
a1099 4
      if (h && (h->root.type == bfd_link_hash_undefined
		|| h->root.type == bfd_link_hash_undefweak
		|| h->root.u.def.section->output_section == NULL))
	dyn_h->want_opd = 0;
d1105 4
a1108 4
	       || h == NULL
	       || (h->dynindx == -1 && h->type != STT_PARISC_MILLI)
	       || (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak))
d1115 1
a1115 1
	      && (h == NULL || (h->dynindx == -1)))
d1119 1
a1119 1
	      owner = (dyn_h->owner ? dyn_h->owner: h->root.u.def.section->owner);
d1122 1
a1122 1
		    (x->info, owner, dyn_h->sym_indx))
d1131 1
a1131 1
	  if (x->info->shared && h)
d1136 1
a1136 1
	      new_name = alloca (strlen (h->root.root.string) + 2);
d1138 1
a1138 1
	      strcpy (new_name + 1, h->root.root.string);
d1143 3
a1145 3
	      nh->root.type = h->root.type;
	      nh->root.u.def.value = h->root.u.def.value;
	      nh->root.u.def.section = h->root.u.def.section;
d1151 1
a1151 1
	  dyn_h->opd_offset = x->ofs;
d1157 1
a1157 1
	dyn_h->want_opd = 0;
d1368 1
a1368 1
  if (! get_stub (abfd, info, elf64_hppa_hash_table (info)))
d1371 1
a1371 1
  if (! get_dlt (abfd, info, elf64_hppa_hash_table (info)))
d1374 1
a1374 1
  if (! get_plt (abfd, info, elf64_hppa_hash_table (info)))
d1377 1
a1377 1
  if (! get_opd (abfd, info, elf64_hppa_hash_table (info)))
d1389 1
a1389 1
  elf64_hppa_hash_table (info)->dlt_rel_sec = s;
d1400 1
a1400 1
  elf64_hppa_hash_table (info)->plt_rel_sec = s;
d1411 1
a1411 1
  elf64_hppa_hash_table (info)->other_rel_sec = s;
d1422 1
a1422 1
  elf64_hppa_hash_table (info)->opd_rel_sec = s;
d1431 1
a1431 2
allocate_dynrel_entries (struct elf64_hppa_dyn_hash_entry *dyn_h,
			 void *data)
d1433 1
d1439 2
a1440 2
  hppa_info = elf64_hppa_hash_table (x->info);
  dynamic_symbol = elf64_hppa_dynamic_symbol_p (dyn_h->h, x->info);
d1450 1
a1450 1
  for (rent = dyn_h->reloc_entries; rent; rent = rent->next)
d1454 1
a1454 1
      if (!shared && rent->type == R_PARISC_FPTR64 && dyn_h->want_opd)
d1462 1
a1462 2
      if (dyn_h->h == 0
	  || (dyn_h->h->dynindx == -1 && dyn_h->h->type != STT_PARISC_MILLI))
d1464 1
a1464 1
	    (x->info, rent->sec->owner, dyn_h->sym_indx))
d1470 1
a1470 1
  if ((dynamic_symbol || shared) && dyn_h->want_dlt)
d1476 1
a1476 1
  if (shared && dyn_h->want_opd)
d1479 1
a1479 1
  if (dyn_h->want_plt && dynamic_symbol)
d1502 1
a1502 1
				  struct elf_link_hash_entry *h)
d1510 1
a1510 1
  if (h->u.weakdef != NULL)
d1512 4
a1515 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d1535 1
a1535 1
elf64_hppa_mark_milli_and_exported_functions (struct elf_link_hash_entry *h,
d1538 1
a1539 1
  struct elf_link_hash_entry *elf = h;
d1555 1
a1555 1
  return elf64_hppa_mark_exported_functions (h, data);
d1562 1
a1562 2
elf64_hppa_size_dynamic_sections (bfd *output_bfd,
				  struct bfd_link_info *info)
d1564 2
d1567 2
a1568 1
  asection *s;
a1571 2
  struct elf64_hppa_allocate_data data;
  struct elf64_hppa_link_hash_table *hppa_info;
d1573 1
a1573 1
  hppa_info = elf64_hppa_hash_table (info);
d1596 4
a1599 4
	  s = bfd_get_section_by_name (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
d1609 124
a1732 3
      s = bfd_get_section_by_name (dynobj, ".rela.dlt");
      if (s != NULL)
	s->size = 0;
d1738 1
a1738 1
  if (elf64_hppa_hash_table (info)->dlt_sec)
d1740 3
a1742 3
      data.ofs = 0x0;
      elf64_hppa_dyn_hash_traverse (&hppa_info->dyn_hash_table,
				    allocate_global_data_dlt, &data);
d1744 1
d1746 5
a1750 3
      data.ofs = 0x0;
      elf64_hppa_dyn_hash_traverse (&hppa_info->dyn_hash_table,
				    allocate_global_data_plt, &data);
d1752 1
d1754 2
d1757 2
a1758 2
      elf64_hppa_dyn_hash_traverse (&hppa_info->dyn_hash_table,
				    allocate_global_data_stub, &data);
d1763 1
a1763 1
  if (elf64_hppa_hash_table (info)->opd_sec)
d1765 3
a1767 3
      data.ofs = 0;
      elf64_hppa_dyn_hash_traverse (&hppa_info->dyn_hash_table,
				    allocate_global_data_opd, &data);
d1773 2
a1774 2
    elf64_hppa_dyn_hash_traverse (&hppa_info->dyn_hash_table,
				  allocate_dynrel_entries, &data);
d1780 1
a1780 1
  for (s = dynobj->sections; s != NULL; s = s->next)
d1784 1
a1784 1
      if ((s->flags & SEC_LINKER_CREATED) == 0)
d1789 1
a1789 1
      name = bfd_get_section_name (dynobj, s);
d1794 1
a1794 1
	  plt = s->size != 0;
d1805 1
a1805 1
	  if (s->size != 0)
d1823 1
a1823 1
						  s->output_section);
d1833 1
a1833 1
	      s->reloc_count = 0;
d1842 1
a1842 1
      if (s->size == 0)
d1853 1
a1853 1
	  s->flags |= SEC_EXCLUDE;
d1857 1
a1857 1
      if ((s->flags & SEC_HAS_CONTENTS) == 0)
d1866 1
a1866 1
      if (s->contents == NULL)
d1868 2
a1869 2
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
	  if (s->contents == NULL)
d1942 1
a1942 1
elf64_hppa_link_output_symbol_hook (struct bfd_link_info *info,
d1946 1
a1946 1
				    struct elf_link_hash_entry *h)
d1948 1
a1948 2
  struct elf64_hppa_link_hash_table *hppa_info;
  struct elf64_hppa_dyn_hash_entry *dyn_h;
d1952 1
a1952 8
  if (!name)
    return TRUE;

  /* Get the PA dyn_symbol (if any) associated with NAME.  */
  hppa_info = elf64_hppa_hash_table (info);
  dyn_h = elf64_hppa_dyn_hash_lookup (&hppa_info->dyn_hash_table,
				      name, FALSE, FALSE);
  if (!dyn_h || dyn_h->h != h)
d1961 2
a1962 2
     here instead of just checking dyn_h->h->dynindx.  */
  if (dyn_h->want_opd && dyn_h->st_shndx != -1)
d1965 2
a1966 2
      sym->st_value = dyn_h->st_value;
      sym->st_shndx = dyn_h->st_shndx;
d1978 1
a1978 1
				  struct elf_link_hash_entry *h,
d1981 1
a1983 1
  struct elf64_hppa_dyn_hash_entry *dyn_h;
d1985 1
a1985 3
  hppa_info = elf64_hppa_hash_table (info);
  dyn_h = elf64_hppa_dyn_hash_lookup (&hppa_info->dyn_hash_table,
				      h->root.root.string, FALSE, FALSE);
d2001 1
a2001 1
  if (dyn_h && dyn_h->want_opd)
d2007 2
a2008 2
      dyn_h->st_value = sym->st_value;
      dyn_h->st_shndx = sym->st_shndx;
d2012 1
a2012 1
      sym->st_value = (dyn_h->opd_offset
d2020 2
a2021 2
  if (dyn_h && dyn_h->want_plt
      && elf64_hppa_dynamic_symbol_p (dyn_h->h, info))
d2033 1
a2033 1
      if (info->shared && h->root.type == bfd_link_hash_undefined)
d2036 1
a2036 1
	value = (h->root.u.def.value + h->root.u.def.section->vma);
d2049 1
a2049 1
      bfd_put_64 (splt->owner, value, splt->contents + dyn_h->plt_offset);
d2051 1
a2051 1
      bfd_put_64 (splt->owner, value, splt->contents + dyn_h->plt_offset + 0x8);
d2059 1
a2059 1
      rel.r_offset = (dyn_h->plt_offset + splt->output_offset
d2061 1
a2061 1
      rel.r_info = ELF64_R_INFO (h->dynindx, R_PARISC_IPLT);
d2070 2
a2071 2
  if (dyn_h && dyn_h->want_stub
      && elf64_hppa_dynamic_symbol_p (dyn_h->h, info))
d2083 1
a2083 1
      memcpy (stub->contents + dyn_h->stub_offset, plt_stub, sizeof (plt_stub));
d2096 1
a2096 1
      value = dyn_h->plt_offset - hppa_info->gp_offset;
d2098 1
a2098 1
      insn = bfd_get_32 (stub->owner, stub->contents + dyn_h->stub_offset);
d2116 1
a2116 1
				 dyn_h->root.string,
d2122 1
a2122 1
		  stub->contents + dyn_h->stub_offset);
d2126 1
a2126 1
      insn = bfd_get_32 (stub->owner, stub->contents + dyn_h->stub_offset + 8);
d2138 1
a2138 1
		  stub->contents + dyn_h->stub_offset + 8);
d2148 1
a2148 2
elf64_hppa_finalize_opd (struct elf64_hppa_dyn_hash_entry *dyn_h,
			 void *data)
d2150 1
a2152 1
  struct elf_link_hash_entry *h = dyn_h ? dyn_h->h : NULL;
d2156 1
a2156 1
  hppa_info = elf64_hppa_hash_table (info);
d2160 1
a2160 1
  if (h && dyn_h->want_opd)
d2168 1
a2168 1
      memset (sopd->contents + dyn_h->opd_offset, 0, 16);
d2170 3
a2172 3
      value = (h->root.u.def.value
	       + h->root.u.def.section->output_section->vma
	       + h->root.u.def.section->output_offset);
d2175 1
a2175 1
      bfd_put_64 (sopd->owner, value, sopd->contents + dyn_h->opd_offset + 16);
d2179 1
a2179 1
      bfd_put_64 (sopd->owner, value, sopd->contents + dyn_h->opd_offset + 24);
d2185 1
a2185 1
  if (info->shared && dyn_h && dyn_h->want_opd)
d2194 2
a2195 2
      if (h && h->dynindx != -1)
	dynindx = h->dynindx;
d2198 2
a2199 2
	  = _bfd_elf_link_lookup_local_dynindx (info, dyn_h->owner,
						dyn_h->sym_indx);
d2203 1
a2203 1
      rel.r_offset = (dyn_h->opd_offset + sopd->output_offset
d2233 1
a2233 1
      if (h)
d2238 1
a2238 1
	  new_name = alloca (strlen (h->root.root.string) + 2);
d2240 1
a2240 1
	  strcpy (new_name + 1, h->root.root.string);
d2266 1
a2266 2
elf64_hppa_finalize_dlt (struct elf64_hppa_dyn_hash_entry *dyn_h,
			 void *data)
d2268 1
a2271 1
  struct elf_link_hash_entry *h = dyn_h ? dyn_h->h : NULL;
d2273 1
a2273 1
  hppa_info = elf64_hppa_hash_table (info);
d2282 1
a2282 1
  if (! info->shared && h && dyn_h->want_dlt)
d2292 1
a2292 1
      if (dyn_h->want_opd)
d2294 1
a2294 1
	  value = (dyn_h->opd_offset
d2298 7
a2304 7
      else if ((h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	       && h->root.u.def.section)
	{
	  value = h->root.u.def.value + h->root.u.def.section->output_offset;
	  if (h->root.u.def.section->output_section)
	    value += h->root.u.def.section->output_section->vma;
d2306 1
a2306 1
	    value += h->root.u.def.section->vma;
d2314 1
a2314 1
      bfd_put_64 (sdlt->owner, value, sdlt->contents + dyn_h->dlt_offset);
d2319 2
a2320 2
  if (dyn_h->want_dlt
      && (elf64_hppa_dynamic_symbol_p (dyn_h->h, info) || info->shared))
d2329 2
a2330 2
      if (h && h->dynindx != -1)
	dynindx = h->dynindx;
d2333 2
a2334 2
	  = _bfd_elf_link_lookup_local_dynindx (info, dyn_h->owner,
						dyn_h->sym_indx);
d2339 1
a2339 1
      rel.r_offset = (dyn_h->dlt_offset + sdlt->output_offset
d2341 1
a2341 1
      if (h && h->type == STT_FUNC)
d2358 1
a2358 1
elf64_hppa_finalize_dynreloc (struct elf64_hppa_dyn_hash_entry *dyn_h,
d2361 1
a2363 1
  struct elf_link_hash_entry *h;
d2366 1
a2366 1
  dynamic_symbol = elf64_hppa_dynamic_symbol_p (dyn_h->h, info);
d2371 1
a2371 1
  if (dyn_h->reloc_entries)
d2376 1
a2376 2
      hppa_info = elf64_hppa_hash_table (info);
      h = dyn_h->h;
d2381 2
a2382 2
      if (h && h->dynindx != -1)
	dynindx = h->dynindx;
d2385 2
a2386 2
	  = _bfd_elf_link_lookup_local_dynindx (info, dyn_h->owner,
						dyn_h->sym_indx);
d2388 1
a2388 1
      for (rent = dyn_h->reloc_entries; rent; rent = rent->next)
d2395 1
a2395 1
	  if (!info->shared && rent->type == R_PARISC_FPTR64 && dyn_h->want_opd)
d2425 1
a2425 1
	  if (info->shared && rent->type == R_PARISC_FPTR64 && dyn_h->want_opd)
d2430 1
a2430 1
	      value = (dyn_h->opd_offset
d2499 1
a2499 1
  hppa_info = elf64_hppa_hash_table (info);
d2502 7
a2508 7
  elf64_hppa_dyn_hash_traverse (&hppa_info->dyn_hash_table,
				elf64_hppa_finalize_opd,
				info);

  elf64_hppa_dyn_hash_traverse (&hppa_info->dyn_hash_table,
				elf64_hppa_finalize_dynreloc,
				info);
d2513 3
a2515 3
  elf64_hppa_dyn_hash_traverse (&hppa_info->dyn_hash_table,
				elf64_hppa_finalize_dlt,
				info);
@


1.87
log
@Silence gcc printf warnings
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d185 1
a185 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d188 3
a190 2
  PARAMS ((struct bfd_hash_entry *entry, struct bfd_hash_table *table,
	   const char *string));
d192 2
a193 1
  PARAMS ((bfd *abfd));
d195 3
a197 2
  PARAMS ((struct elf64_hppa_dyn_hash_table *table, const char *string,
	   bfd_boolean create, bfd_boolean copy));
d199 3
a201 3
  PARAMS ((struct elf64_hppa_dyn_hash_table *table,
	   bfd_boolean (*func) (struct elf64_hppa_dyn_hash_entry *, PTR),
	   PTR info));
d204 2
a205 2
  PARAMS ((bfd *, struct elf_link_hash_entry *,
	   const Elf_Internal_Rela *, char **, size_t *));
d212 1
a212 1
  PARAMS ((bfd *));
d215 1
a215 1
  PARAMS ((bfd *, struct bfd_link_info *));
d218 1
a218 1
  PARAMS ((bfd *, struct bfd_link_info *));
d221 1
a221 1
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
d224 1
a224 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d227 1
a227 1
  PARAMS ((bfd *, struct bfd_link_info *));
d230 2
a231 2
  PARAMS ((struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *, struct elf_link_hash_entry *));
d234 2
a235 2
  PARAMS ((bfd *, struct bfd_link_info *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
d238 1
a238 1
  PARAMS ((const Elf_Internal_Rela *));
d241 1
a241 1
  PARAMS ((bfd *, struct bfd_link_info *));
d244 2
a245 2
  PARAMS ((bfd *, struct bfd_link_info *,
	   asection *, const Elf_Internal_Rela *));
d248 1
a248 1
  PARAMS ((struct elf_link_hash_entry *, struct bfd_link_info *));
d251 1
a251 1
  PARAMS ((struct elf_link_hash_entry *, PTR));
d254 1
a254 1
  PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d257 1
a257 1
  PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d260 1
a260 1
  PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d263 1
a263 1
  PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d266 1
a266 1
  PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d269 1
a269 1
  PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d272 1
a272 1
  PARAMS ((bfd *, struct elf64_hppa_link_hash_table *, asection *));
d275 2
a276 2
  PARAMS ((bfd *, struct elf64_hppa_dyn_hash_entry *,
	   int, asection *, int, bfd_vma, bfd_vma));
d279 1
a279 1
  PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d282 1
a282 1
  PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d285 1
a285 1
  PARAMS ((bfd *, struct bfd_link_info *, struct elf64_hppa_link_hash_table *));
d288 1
a288 1
  PARAMS ((bfd *, struct bfd_link_info *, struct elf64_hppa_link_hash_table *));
d291 1
a291 1
  PARAMS ((bfd *, struct bfd_link_info *, struct elf64_hppa_link_hash_table *));
d294 1
a294 1
  PARAMS ((bfd *, struct bfd_link_info *, struct elf64_hppa_link_hash_table *));
d297 1
a297 1
  PARAMS ((Elf_Internal_Sym *, int));
d310 3
a312 4
elf64_hppa_new_dyn_hash_entry (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d342 1
a342 2
elf64_hppa_hash_table_create (abfd)
     bfd *abfd;
d367 4
a370 4
elf64_hppa_dyn_hash_lookup(table, string, create, copy)
     struct elf64_hppa_dyn_hash_table *table;
     const char *string;
     bfd_boolean create, copy;
d379 7
a385 9
elf64_hppa_dyn_hash_traverse (table, func, info)
     struct elf64_hppa_dyn_hash_table *table;
     bfd_boolean (*func) PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
     PTR info;
{
  (bfd_hash_traverse
   (&table->root,
    (bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) func,
    info));
d392 1
a392 2
elf64_hppa_object_p (abfd)
     bfd *abfd;
d472 5
a476 6
get_dyn_name (abfd, h, rel, pbuf, plen)
     bfd *abfd;
     struct elf_link_hash_entry *h;
     const Elf_Internal_Rela *rel;
     char **pbuf;
     size_t *plen;
d529 3
a531 4
get_reloc_section (abfd, hppa_info, sec)
     bfd *abfd;
     struct elf64_hppa_link_hash_table *hppa_info;
     asection *sec;
d580 7
a586 8
count_dyn_reloc (abfd, dyn_h, type, sec, sec_symndx, offset, addend)
     bfd *abfd;
     struct elf64_hppa_dyn_hash_entry *dyn_h;
     int type;
     asection *sec;
     int sec_symndx;
     bfd_vma offset;
     bfd_vma addend;
d610 4
a613 5
elf64_hppa_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d983 2
a984 3
elf64_hppa_dynamic_symbol_p (h, info)
     struct elf_link_hash_entry *h;
     struct bfd_link_info *info;
d1005 2
a1006 3
elf64_hppa_mark_exported_functions (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d1046 2
a1047 3
allocate_global_data_dlt (dyn_h, data)
     struct elf64_hppa_dyn_hash_entry *dyn_h;
     PTR data;
d1081 2
a1082 3
allocate_global_data_plt (dyn_h, data)
     struct elf64_hppa_dyn_hash_entry *dyn_h;
     PTR data;
d1106 2
a1107 3
allocate_global_data_stub (dyn_h, data)
     struct elf64_hppa_dyn_hash_entry *dyn_h;
     PTR data;
d1128 2
a1129 3
allocate_global_data_opd (dyn_h, data)
     struct elf64_hppa_dyn_hash_entry *dyn_h;
     PTR data;
d1214 2
a1215 3
elf64_hppa_post_process_headers (abfd, link_info)
     bfd * abfd;
     struct bfd_link_info * link_info ATTRIBUTE_UNUSED;
d1231 3
a1233 4
get_opd (abfd, info, hppa_info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elf64_hppa_link_hash_table *hppa_info;
d1267 3
a1269 4
get_plt (abfd, info, hppa_info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elf64_hppa_link_hash_table *hppa_info;
d1303 3
a1305 4
get_dlt (abfd, info, hppa_info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elf64_hppa_link_hash_table *hppa_info;
d1339 3
a1341 4
get_stub (abfd, info, hppa_info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elf64_hppa_link_hash_table *hppa_info;
d1411 2
a1412 3
elf64_hppa_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d1479 2
a1480 3
allocate_dynrel_entries (dyn_h, data)
     struct elf64_hppa_dyn_hash_entry *dyn_h;
     PTR data;
d1550 2
a1551 3
elf64_hppa_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     struct elf_link_hash_entry *h;
d1584 2
a1585 3
elf64_hppa_mark_milli_and_exported_functions (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
d1611 2
a1612 3
elf64_hppa_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d1864 5
a1868 6
elf64_hppa_link_output_symbol_hook (info, name, sym, input_sec, h)
     struct bfd_link_info *info;
     const char *name;
     Elf_Internal_Sym *sym;
     asection *input_sec ATTRIBUTE_UNUSED;
     struct elf_link_hash_entry *h;
d1906 4
a1909 5
elf64_hppa_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d2080 2
a2081 3
elf64_hppa_finalize_opd (dyn_h, data)
     struct elf64_hppa_dyn_hash_entry *dyn_h;
     PTR data;
d2199 2
a2200 3
elf64_hppa_finalize_dlt (dyn_h, data)
     struct elf64_hppa_dyn_hash_entry *dyn_h;
     PTR data;
d2292 2
a2293 3
elf64_hppa_finalize_dynreloc (dyn_h, data)
     struct elf64_hppa_dyn_hash_entry *dyn_h;
     PTR data;
d2408 1
a2408 2
elf64_hppa_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d2427 2
a2428 3
elf64_hppa_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d2612 1
a2612 1
				       struct bfd_link_info *info ATTRIBUTE_UNUSED)
d2692 2
a2693 3
elf64_hppa_elf_get_symbol_type (elf_sym, type)
     Elf_Internal_Sym *elf_sym;
     int type;
@


1.86
log
@        PR ld/6511
        * elf64-hppa.c (allocate_global_data_opd): Default to using the
        dynamic symbol table for local function names in shared libraries.
@
text
@d517 1
a517 1
		      (long) ELF64_R_SYM (rel->r_info));
@


1.85
log
@        Multi-GOT support for m68k.

        bfd/

        * elf32-m68k.c (struct elf_m68k_link_hash_entry: got_entry_key,
        glist): New fields.
        (struct elf_m68k_got_entry_key, struct elf_m68k_got_entry,
        struct elf_m68k_got, struct elf_m68k_bfd2got_entry,
        struct elf_m68k_multi_got): New data structures.
        (struct elf_m68k_link_hash_table: local_gp_p, use_neg_got_offsets_p,
        allow_multigot_p, multi_got_): New fields.
        (elf_m68k_multi_got): New macro.
        (elf_m68k_link_hash_newfunc): Initialize new fields of
        struct elf_m68k_link_hash_entry.
        (elf_m68k_link_hash_table_create): Initialize new fields of
        struct elf_m68k_link_hash_table.
        (elf_m68k_link_hash_table_free): New static function implementing hook.
        (elf_m68k_init_got, elf_m68k_clear_got, elf_m68k_create_empty_got): New
        static functions for struct elf_m68k_got.
        (elf_m68k_init_got_entry_key, elf_m68k_got_entry_hash,
        elf_m68k_got_entry_eq): New static functions for
        struct elf_m68k_got_entry.
        (ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT,
        ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): New macros.
        (enum elf_m68k_get_entry_howto): New enum.
        (elf_m68k_get_got_entry, elf_m68k_update_got_entry_type,
        elf_m68k_remove_got_entry_type): New static functions for
        struct elf_m68k_got_entry.
        (elf_m68k_add_entry_to_got): New static function.
        (elf_m68k_bfd2got_entry_hash, elf_m68k_bfd2got_entry_eq,
        elf_m68k_bfd2got_entry_del, elf_m68k_get_bfd2got_entry): New static
        functions for struct elf_m68k_bfd2got_entry.
        (struct elf_m68k_can_merge_gots_arg, elf_m68k_can_merge_gots_1,
        elf_m68k_can_merge_gots): New traversal.
        (struct elf_m68k_merge_gots_arg, elf_m68k_merge_gots_1,
        elf_m68k_merge_gots): Ditto.
        (struct elf_m68k_finalize_got_offsets_arg,
        elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets): Ditto.
        (struct elf_m68k_partition_multi_got_arg,
        elf_m68k_partition_multi_got_1, elf_m68k_init_symndx2h_1,
        elf_m68k_partition_multi_got): Ditto.
        (elf_m68k_find_got_entry_ptr, elf_m68k_remove_got_entry): New static
        functions.
        (elf_m68k_copy_indirect_symbol): New static function implementing
        a hook.
        (elf_m68k_check_relocs): Update to add entries to multi-GOT.
        (elf_m68k_gc_sweep_hook): Update to remove entries from multi-GOT.
        (elf_m68k_always_size_sections): Assign BFDs to GOTs.
        (elf_m68k_relocate_section): Update to properly handle GOT relocations.
        (elf_m68k_finish_dynamic_symbol): Update to traverse all GOT entries
        of a global symbol.
        (bfd_elf_m68k_set_target_options): New function.
        (bfd_elf32_bfd_link_hash_table_free): Define hook.
        (bfd_elf32_bfd_final_link): Change expansion to bfd_elf_final_link
        to skip generic calculation of GOT offsets.
        (elf_backend_copy_indirect_symbol): Define hook.

        * bfd-in.h (bfd_elf_m68k_set_target_options): Declare function.
        * bfd-in2.h: Regenerate.

        ld/

        * configure.in (--enable-got): New option.  Handle it.
        * configure: Regenerate.
        * config.in: Regenerate.

        * emultempl/m68kelf.em: (got_handling_target_default): New shell
        variable.
        (GOT_HANDLING_TARGET_DEFAULT): New macro.
        (GOT_HANDLING_DEFAULT): New macro.  Initialize it from configure
        option if one was given.
        (got_handling): New static variable.
        (elf_m68k_create_output_section_statements): New static function
        implementing hook.
        (PARSE_AND_LIST_PROLOGUE): Define shell variable.
        (OPTION_GOT): New macro.
        (PARSE_AND_LIST_LONGOPTS): Define shell variable.  Specify
        --got option.
        (got): New linker option.
        (PARSE_AND_LIST_OPTIONS): Define shell variable.  Print help string
        for --got option.
        (PARSE_AND_LIST_ARGS_CASES): Define shell variable.  Handle --got
        option.

        * ld.texinfo: Document --got=<type> option.
        * gen-doc.texi: Add M68K.
        * NEWS: Mention the new feature.

        ld/testsuite/

        * ld-m68k/got-12.s: New file.
        * ld-m68k/got-13.s: New file.
        * ld-m68k/got-14.s: New file.
        * ld-m68k/got-15.s: New file.
        * ld-m68k/got-34.s: New file.
        * ld-m68k/got-35.s: New file.
        * ld-m68k/got-single-12-ok.d: New dump test.
        * ld-m68k/got-single-13-er.d: New dump test.
        * ld-m68k/got-negative-14-ok.d: New dump test.
        * ld-m68k/got-negative-15-er.d: New dump test.
        * ld-m68k/got-negative-12-13-14-34-ok.d: New dump test.
        * ld-m68k/got-negative-12-13-14-35-er.d: New dump test.
        * ld-m68k/got-multigot-14-ok.d: New dump test.
        * ld-m68k/got-multigot-15-er.d: New dump test.
        * ld-m68k/got-multigot-12-13-14-34-35-ok.d: New dump test.
        * ld-m68k/xgot-15.s: New source.
        * ld-m68k/got-xgot-15-ok.d: New test.
        * ld-m68k/got-xgot-12-13-14-15-34-35-ok.d: New test.
        * ld-m68k/m68k.exp: Run new tests.
@
text
@d1178 2
a1179 1
	      owner = (h ? h->root.u.def.section->owner : dyn_h->owner);
d2201 2
a2202 2
				     new_name, FALSE, FALSE, FALSE);

@


1.84
log
@include/elf/
	PR 5900
	* common.h (SHN_BAD): Delete.
	(SHN_LORESERVE .. SHN_HIRESERVE): Move to..
	* external.h: ..here.
	* internal.h (SHN_LORESERVE, SHN_HIRESERVE): Define.
	(SHN_LOPROC, SHN_HIPROC, SHN_LOOS, SHN_HIOS): Define.
	(SHN_ABS, SHN_COMMON, SHN_XINDEX, SHN_BAD): Define.
bfd/
	PR 5900
	* elf-bfd.h: Include elf/internal.h after elf/external.h.
	* elfcode.h (elf_swap_symbol_in): Map reserved shndx range.
	(elf_swap_symbol_out): Adjust SHN_XINDEX test.
	(elf_swap_ehdr_out): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.
	(valid_section_index_p): Delete.
	(elf_object_p): Don't increment section numbers over reserved range.
	Simplify test for valid sh_link, sh_info and e_shstrndx fields.
	(elf_write_shdrs_and_ehdr): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.  Don't increment section numbers over
	reserved range.
	* elf.c (bfd_elf_sym_name): Remove redundant tests on st_shndx.
	(bfd_section_from_shdr): Likewise.
	(group_signature): Range check before accessing elf_elfsections.
	(_bfd_elf_setup_sections): Likewise.
	(bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): Don't increment section number over
	reserved sections.
	(assign_file_positions_for_non_load_sections): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(_bfd_elf_write_object_contents): Likewise.
	(assign_section_numbers): Likewise.  Adjust for changed SHN_*.
	(prep_headers): Delete unused variable.
	* elflink.c (bfd_elf_link_record_local_dynamic_symbol): Adjust
	for changed SHN_* values.
	(check_dynsym, elf_link_input_bfd): Likewise.
	(bfd_elf_final_link): Likewise.  Don't skip over reserved section
	range.
	(elf_fixup_link_order): Check that sh_link field is valid.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Make "index" unsigned.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Range check before
	accesssing elf_elfsections.
	* elf32-avr.c (elf32_avr_size_stubs): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Adjust for changed
	SHN_* defines.  Test for SHN_BAD return from
	_bfd_elf_section_from_bfd_section
binutils/
	PR 5900
	* readelf.c (SECTION_HEADER_INDEX, SECTION_HEADER_NUM): Delete.
	Remove use throughout file.
	(SECTION_HEADER): Likewise.
	(dump_relocations): Don't adjust st_shndx for reserved range.
	(process_file_header): Mask SHN_XINDEX to values seen in external
	elf structs.  Simplify valid section index tests.
	(get_32bit_elf_symbols, get_64bit_elf_symbols): Mask SHN_XINDEX.
	Map reserved st_shndx to internal form.
	(process_section_groups): Test that group symbol st_shndx is in
	range, not just non-zero.  Delete reserved range check.
	(get_symbol_index_type): Mask "type" to 16 bits when printing PRC,
	OS or RSV.
gdb/
	PR 5900
	* elfread.c (elf_symtab_read): Make shndx an unsigned int.
	* mipsread.c: Include elf/internal.h.
	(read_alphacoff_dynamic_symtab): Map external reserved sym_shndx
	to internal range.
ld/testsuite/
	PR 5900
	* ld-elf/sec64k.exp: Update.
@
text
@d2204 2
a2205 1
	  dynindx = nh->dynindx;
@


1.83
log
@	PR binutils/5146
	* elf64-hppa.c: Declare alloca when __GNUC__ is defined.
	* som.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d628 1
a628 1
  int sec_symndx;
d680 2
a681 1
	  if (isym->st_shndx > highest_shndx)
d727 1
a727 1
      if (sec_symndx == -1)
d730 4
a733 1
      sec_symndx = hppa_info->section_syms[sec_symndx];
@


1.82
log
@PR 5146
* configure.in (AC_CHECK_HEADERS): Add alloca.h
* configure: Regenerate.
* config.in: Regenerate.
* som.c: Replace alloca-conf.h inclusion with code recommended in autoconf documentation.
* elf64-hppa.c: Likewise.
@
text
@d51 2
@


1.81
log
@	* elf32-arm.c (elf32_arm_size_info): Init checksum_contents field.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (elf64_sparc_size_info): Likewise.
@
text
@a21 1
#include "alloca-conf.h"
d29 25
@


1.80
log
@Switch sources over to use the GPL version 3
@
text
@d2777 1
@


1.79
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.78
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.77
log
@2007-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3826
	* elf-bfd.h (elf_backend_data): Add elf_osabi.
	(_bfd_elf_set_osabi): New.

	* elf.c (_bfd_elf_set_osabi): New.

	* elf32-hppa.c (elf32_hppa_post_process_headers): Removed.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.
	(ELF_OSABI): Properly defined for each target.

	* elf32-i370.c (i370_elf_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf32-i386.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf_i386_post_process_headers): Set EI_OSABI with elf_osabi.

	* elf32-msp430.c (elf32_msp430_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-alpha.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf64_alpha_fbsd_post_process_headers): Set EI_OSABI with
	elf_osabi.

	* elf64-hppa.c (elf64_hppa_post_process_headers): Set EI_OSABI
	with elf_osabi.
	(ELF_OSABI): Properly defined for each target.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi for Linux.

	* elf64-sparc.c (elf64_sparc_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-x86-64.c (elf64_x86_64_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elfcode.h (elf_object_p): Match the ELFOSABI_NONE ELF target
	with any ELF target of the compatible machine for which we do not
	have a specific backend.

	* elfxx-ia64.c (elfNN_hpux_post_process_headers): Set EI_OSABI
	with elf_osabi.

	* elfxx-target.h (ELF_OSABI): Default to ELFOSABI_NONE.
	(elfNN_bed): Initialize elf_osabi with ELF_OSABI.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d2799 1
@


1.76
log
@2076-01-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-hppa.c (elf64_bed): Defined for HPUX and Linux.
@
text
@d1201 3
a1203 10

  if (strcmp (bfd_get_target (abfd), "elf64-hppa-linux") == 0)
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_LINUX;
    }
  else
    {
      i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_HPUX;
      i_ehdrp->e_ident[EI_ABIVERSION] = 1;
    }
d2796 2
d2872 4
@


1.75
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d2869 2
d2877 2
a2879 1
#define INCLUDED_TARGET_FILE 1
@


1.74
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2823 2
@


1.73
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@d520 1
a520 1
  BFD_ASSERT ((strncmp (srel_name, ".rela", 5) == 0
d522 2
a523 2
			  srel_name+5) == 0)
	      || (strncmp (srel_name, ".rel", 4) == 0
d525 1
a525 1
			     srel_name+4) == 0));
d1716 1
a1716 1
	       || strncmp (name, ".dlt", 4) == 0
d1722 1
a1722 1
      else if (strncmp (name, ".rela", 5) == 0)
d2755 8
a2762 8
  { ".fini",   5, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".init",   5, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".plt",    4, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_PARISC_SHORT },
  { ".dlt",    4, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_PARISC_SHORT },
  { ".sdata",  6, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_PARISC_SHORT },
  { ".sbss",   5, 0, SHT_NOBITS, SHF_ALLOC + SHF_WRITE + SHF_PARISC_SHORT },
  { ".tbss",   5, 0, SHT_NOBITS, SHF_ALLOC + SHF_WRITE + SHF_HP_TLS },
  { NULL,      0, 0, 0,            0 }
@


1.72
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@a206 3
static bfd_boolean elf64_hppa_modify_segment_map
  PARAMS ((bfd *, struct bfd_link_info *));

d2641 2
a2642 3
elf64_hppa_modify_segment_map (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
@


1.71
log
@* elf64-hppa.c (elf64_hppa_grok_prstatus): New function.
  (elf64_hppa_grok_psinfo): Likewise.
  (elf_backend_grok_pstatus, elf_backend_grok_psinfo): Define.
@
text
@a206 3
static int elf64_hppa_additional_program_headers
  PARAMS ((bfd *));

d2617 2
a2618 2
elf64_hppa_additional_program_headers (abfd)
     bfd *abfd;
@


1.70
log
@	* elf64-hppa.c (elf64_hppa_special_sections): Change flags for .tbss
	section from SHF_PARISC_WEAKORDER to SHF_HP_TLS.
	(elf_backend_special_sections): Remove #undef.
@
text
@d2545 62
d2840 3
a2842 1

@


1.70.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a2544 62
/* Support for core dump NOTE sections.  */

static bfd_boolean
elf64_hppa_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  size_t size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 760:		/* Linux/hppa */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 32);

	/* pr_reg */
	offset = 112;
	size = 640;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf64_hppa_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  char * command;
  int n;

  switch (note->descsz)
    {
    default:
      return FALSE;

    case 136:		/* Linux/hppa elf_prpsinfo.  */
      elf_tdata (abfd)->core_program
	= _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
      elf_tdata (abfd)->core_command
	= _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */
  command = elf_tdata (abfd)->core_command;
  n = strlen (command);

  if (0 < n && command[n - 1] == ' ')
    command[n - 1] = '\0';

  return TRUE;
}

d2778 1
a2778 3
#define elf_backend_grok_prstatus	elf64_hppa_grok_prstatus
#define elf_backend_grok_psinfo		elf64_hppa_grok_psinfo
 
@


1.69
log
@	* elf64-hppa.c (allocate_global_data_opd): Don't create an OPD entry
	for undefined weak symbols.
@
text
@d2706 1
a2706 1
  { ".tbss",   5, 0, SHT_NOBITS, SHF_ALLOC + SHF_WRITE + SHF_PARISC_WEAKORDER },
a2816 2
#undef elf_backend_special_sections

@


1.68
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d1132 1
@


1.67
log
@* elf64-hppa.c (elf64_hppa_section_from_phdr): Create .kernel
pseudo-section.  Make sure .reg section comes after the proc
section it's generated from.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
a159 3
static bfd_boolean elf64_hppa_dyn_hash_table_init
  PARAMS ((struct elf64_hppa_dyn_hash_table *ht, bfd *abfd,
	   new_hash_entry_func new));
d276 4
a279 4
elf64_hppa_dyn_hash_table_init (ht, abfd, new)
     struct elf64_hppa_dyn_hash_table *ht;
     bfd *abfd ATTRIBUTE_UNUSED;
     new_hash_entry_func new;
d282 1
a282 1
  return bfd_hash_table_init (&ht->root, new);
d328 2
a329 1
				      _bfd_elf_link_hash_newfunc))
d336 2
a337 1
				       elf64_hppa_new_dyn_hash_entry))
@


1.66
log
@	* elf64-hppa.c (elf64_hppa_object_p): Recognize corefiles under
	hppa64-hp-hpux11.11.
	(elf64_hppa_section_from_phdr): New function.
	(elf_backend_section_from_phdr): Define.
@
text
@d2655 16
d2682 1
a2682 3
      /* gdb uses the ".reg" section to read register contents.  */
      if (!_bfd_elfcore_make_pseudosection (abfd, ".reg", hdr->p_filesz,
	  				    hdr->p_offset))
d2684 4
@


1.65
log
@	PR ld/1135
	* elf64-hppa.c (elf64_hppa_special_sections): Add flag definitions for
	.plt, .dlt, .sdata, .sbss and .tbss.
@
text
@d384 2
a385 2
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
d390 4
a393 1
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_HPUX)
d405 4
a408 1
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 20);
d2650 30
d2790 1
@


1.64
log
@	* elf-bfd.h (struct elf_backend_data): Add action_discarded.
	(enum action_discarded): Move from..
	* elflink.c (enum action_discarded): ..here.
	(_bfd_elf_default_action_discarded): Rename from elf_action_discarded.
	Remove target specific section checks.
	(elf_link_input_bfd): Adjust.
	* elfxx-target.h (elf_backend_action_discarded): Define.
	(elfNN_bed): Init new field.
	* bfd-in.h (_bfd_elf_default_action_discarded): Declare.
	* bfd-in2.h: Regenerate.
	* elf-hppa.h (elf_hppa_action_discarded): New function.
	* elf32-hppa.c (elf_backend_action_discarded): Define.
	* elf64-hppa.c (elf_backend_action_discarded): Define.
	* elf32-ppc.c (ppc_elf_action_discarded): New function.
	(elf_backend_action_discarded): Define.
@
text
@d2646 8
a2653 3
  { ".fini",    5, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".init",    5, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { NULL,       0, 0, 0,            0 }
@


1.63
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d2748 1
@


1.62
log
@2005-07-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add special_sections.

	* elf.c (_bfd_elf_get_sec_type_attr): Check special_sections
	first.

	* elf32-arm.c (elf_backend_get_sec_type_attr): Removed.
	(elf_backend_special_sections): New. Defined.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.

	* elfxx-target.h (elf_backend_special_sections): New.
	(elfNN_bed): Initialize special_sections.
@
text
@a1701 1
      bfd_boolean strip;
a1709 2
      strip = 0;

d1712 2
a1713 18
	  /* Strip this section if we don't need it; see the comment below.  */
	  if (s->size == 0)
	    {
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
	}
      else if (strcmp (name, ".dlt") == 0)
	{
	  /* Strip this section if we don't need it; see the comment below.  */
	  if (s->size == 0)
	    {
	      strip = TRUE;
	    }
d1715 4
a1718 1
      else if (strcmp (name, ".opd") == 0)
a1720 4
	  if (s->size == 0)
	    {
	      strip = TRUE;
	    }
d1724 1
a1724 21
	  /* If we don't need this section, strip it from the output file.
	     This is mostly to handle .rela.bss and .rela.plt.  We must
	     create both sections in create_dynamic_sections, because they
	     must be created before the linker maps input sections to output
	     sections.  The linker does that before adjust_dynamic_symbol
	     is called, and it is that function which decides whether
	     anything needs to go into these sections.  */
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
d1755 1
a1755 3
      else if (strncmp (name, ".dlt", 4) != 0
	       && strcmp (name, ".stub") != 0
	       && strcmp (name, ".got") != 0)
d1761 1
a1761 1
      if (strip)
d1763 9
d1776 3
d1788 1
a1788 1
	  if (s->contents == NULL && s->size != 0)
@


1.61
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@a2680 18
static const struct bfd_elf_special_section *
elf64_hppa_get_sec_type_attr (bfd *abfd, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name,
					elf64_hppa_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    return ssect;

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}

d2777 1
a2777 1
#define elf_backend_get_sec_type_attr	elf64_hppa_get_sec_type_attr
d2786 1
a2786 1
#undef elf_backend_get_sec_type_attr
@


1.60
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d2674 1
a2674 1
static struct bfd_elf_special_section const elf64_hppa_special_sections[] =
d2684 1
a2684 1
  const struct bfd_elf_special_section const *ssect;
@


1.59
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d2674 1
a2674 2
static struct bfd_elf_special_section const
  hppa_special_sections_f[]=
a2676 6
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  hppa_special_sections_i[]=
{
d2681 2
a2682 2
static struct bfd_elf_special_section const *
  elf64_hppa_special_sections[27] =
d2684 14
a2697 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  hppa_special_sections_f,	/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  hppa_special_sections_i,	/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  NULL,				/* 'f' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  NULL,				/* 's' */
  NULL,				/* 't' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  NULL				/* other */
};
d2795 1
a2795 1
#define elf_backend_special_sections	elf64_hppa_special_sections
d2804 1
a2804 1
#undef elf_backend_special_sections
@


1.58
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d2674 2
a2675 1
static struct bfd_elf_special_section const elf64_hppa_special_sections[]=
d2678 6
d2688 32
@


1.57
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d535 7
a541 1
      srel = bfd_make_section (dynobj, srel_name);
a542 7
	  || !bfd_set_section_flags (dynobj, srel,
				     (SEC_ALLOC
				      | SEC_LOAD
				      | SEC_HAS_CONTENTS
				      | SEC_IN_MEMORY
				      | SEC_LINKER_CREATED
				      | SEC_READONLY))
d1234 6
a1239 1
      opd = bfd_make_section (dynobj, ".opd");
a1240 6
	  || !bfd_set_section_flags (dynobj, opd,
				     (SEC_ALLOC
				      | SEC_LOAD
				      | SEC_HAS_CONTENTS
				      | SEC_IN_MEMORY
				      | SEC_LINKER_CREATED))
d1271 6
a1276 1
      plt = bfd_make_section (dynobj, ".plt");
a1277 6
	  || !bfd_set_section_flags (dynobj, plt,
				     (SEC_ALLOC
				      | SEC_LOAD
				      | SEC_HAS_CONTENTS
				      | SEC_IN_MEMORY
				      | SEC_LINKER_CREATED))
d1308 6
a1313 1
      dlt = bfd_make_section (dynobj, ".dlt");
a1314 6
	  || !bfd_set_section_flags (dynobj, dlt,
				     (SEC_ALLOC
				      | SEC_LOAD
				      | SEC_HAS_CONTENTS
				      | SEC_IN_MEMORY
				      | SEC_LINKER_CREATED))
d1345 6
a1350 1
      stub = bfd_make_section (dynobj, ".stub");
a1351 7
	  || !bfd_set_section_flags (dynobj, stub,
				     (SEC_ALLOC
				      | SEC_LOAD
				      | SEC_HAS_CONTENTS
				      | SEC_IN_MEMORY
				      | SEC_READONLY
				      | SEC_LINKER_CREATED))
d1421 6
a1426 1
  s = bfd_make_section(abfd, ".rela.dlt");
a1427 5
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_READONLY
					   | SEC_LINKER_CREATED))
d1432 6
a1437 1
  s = bfd_make_section(abfd, ".rela.plt");
a1438 5
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_READONLY
					   | SEC_LINKER_CREATED))
d1443 6
a1448 1
  s = bfd_make_section(abfd, ".rela.data");
a1449 5
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_READONLY
					   | SEC_LINKER_CREATED))
d1454 6
a1459 1
  s = bfd_make_section(abfd, ".rela.opd");
a1460 5
      || !bfd_set_section_flags (abfd, s, (SEC_ALLOC | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY
					   | SEC_READONLY
					   | SEC_LINKER_CREATED))
@


1.56
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.55
log
@Update the FSF address in the copyright/GPL notice
@
text
@d1811 1
a1811 1
	  _bfd_strip_section_from_output (info, s);
@


1.54
log
@2005-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add int to
	elf_backend_section_from_shdr.
	(bfd_elf_section_data): Update comment for this_idx.
	(_bfd_elf_make_section_from_shdr): Add int.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.

	* elf.c (_bfd_elf_make_section_from_shdr): Take section index
	and use it to set this_idx in bfd_elf_section_data.
	(bfd_section_from_shdr): Pass shindex to
	_bfd_elf_make_section_from_shdr.
	(_bfd_elf_section_from_bfd_section): Use this_idx in
	bfd_elf_section_data to find section index.

	* elf32-arm.c (elf32_arm_section_from_shdr): Take section
	index and pass it to _bfd_elf_make_section_from_shdr.
	* elf32-i370.c(i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.53
log
@	* elf64-hppa.c (elf64_hppa_new_dyn_hash_entry): Don't clear everything,
	just the fields specific to hppa64.
@
text
@a186 3
static bfd_boolean elf64_hppa_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));

d413 4
a416 4
elf64_hppa_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d436 1
a436 1
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
@


1.52
log
@	* libbfd-in.h (BFD_ASSERT, BFD_FAIL): Wrap macro body in do while.
	* libbfd.h: Regnerate.
	* elf32-cris.c: Add missing semicolon to BFD_ASSERTs.
	* elf32-frv.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* opncls.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
a307 4
  /* Initialize our local data.  All zeros, and definitely easier
     than setting 8 bit fields.  */
  memset (ret, 0, sizeof (*ret));

d312 5
@


1.51
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d1972 1
a1972 1
      BFD_ASSERT (sopd != NULL)
d1996 1
a1996 1
      BFD_ASSERT (splt != NULL && spltrel != NULL)
d2046 1
a2046 1
      BFD_ASSERT (stub != NULL)
@


1.50
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d1562 1
a1562 1
  if (h->weakdef != NULL)
d1564 4
a1567 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.49
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d746 1
a746 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_REF_REGULAR;
d755 3
a757 2
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
		|| ! (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)
d917 1
a917 1
	    h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d1018 1
a1018 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
@


1.48
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d1506 1
a1506 1
      hppa_info->other_rel_sec->_raw_size += sizeof (Elf64_External_Rela);
d1521 1
a1521 1
    hppa_info->dlt_rel_sec->_raw_size += sizeof (Elf64_External_Rela);
d1527 1
a1527 1
    hppa_info->opd_rel_sec->_raw_size += sizeof (Elf64_External_Rela);
d1541 1
a1541 1
      hppa_info->plt_rel_sec->_raw_size += t;
d1651 1
a1651 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d1664 1
a1664 1
	s->_raw_size = 0;
d1675 1
a1675 1
      hppa_info->dlt_sec->_raw_size = data.ofs;
d1680 1
a1680 1
      hppa_info->plt_sec->_raw_size = data.ofs;
d1685 1
a1685 1
      hppa_info->stub_sec->_raw_size = data.ofs;
d1694 1
a1694 1
      hppa_info->opd_sec->_raw_size = data.ofs;
d1723 1
a1723 1
	  if (s->_raw_size == 0)
d1736 1
a1736 1
	  if (s->_raw_size == 0)
d1744 1
a1744 1
	  if (s->_raw_size == 0)
d1758 1
a1758 1
	  if (s->_raw_size == 0)
d1824 2
a1825 2
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
	  if (s->contents == NULL && s->_raw_size != 0)
d2501 1
a2501 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d2540 1
a2540 1
	      dyn.d_un.d_val = s->_raw_size;
d2546 1
a2546 1
	      if (! s || ! s->_raw_size)
d2548 1
a2548 1
	      if (! s || ! s->_raw_size)
d2556 1
a2556 1
	      dyn.d_un.d_val = s->_raw_size;
d2558 1
a2558 1
	      dyn.d_un.d_val += s->_raw_size;
d2560 1
a2560 1
	      dyn.d_un.d_val += s->_raw_size;
d2565 1
a2565 1
	      dyn.d_un.d_val += s->_raw_size;
@


1.47
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d936 1
a936 1
	      && ! (_bfd_elf64_link_record_local_dynamic_symbol
d1047 1
a1047 1
	      if (! (_bfd_elf64_link_record_local_dynamic_symbol
d1151 1
a1151 1
	      if (!_bfd_elf64_link_record_local_dynamic_symbol
d1177 1
a1177 1
	      if (! bfd_elf64_link_record_dynamic_symbol (x->info, nh))
d1513 1
a1513 1
	if (!_bfd_elf64_link_record_local_dynamic_symbol
@


1.46
log
@	* elf-hppa.h (elf_hppa_relocate_section): Pass input_bfd instead of
	input_section in calls to get_dyn_name.
	* elf64-hppa.c (get_dyn_name): Change type of first argument to "bfd *".	Use section id of first section in input BFD to build dynamic name for
	local symbols.
	(elf64_hppa_check_relocs): Pass abfd in call to get_dyn_name.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d1836 1
a1836 1
  bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.45
log
@	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Check for
	NULL dyn_h.
@
text
@d176 1
a176 1
  PARAMS ((asection *, struct elf_link_hash_entry *,
d449 2
a450 2
get_dyn_name (sec, h, rel, pbuf, plen)
     asection *sec;
d456 1
d862 1
a862 1
      addr_name = get_dyn_name (sec, h, rel, &buf, &buf_len);
@


1.45.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d176 1
a176 1
  PARAMS ((bfd *, struct elf_link_hash_entry *,
d449 2
a450 2
get_dyn_name (abfd, h, rel, pbuf, plen)
     bfd *abfd;
a455 1
  asection *sec = abfd->sections;
d861 1
a861 1
      addr_name = get_dyn_name (abfd, h, rel, &buf, &buf_len);
d1834 1
a1834 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
@


1.45.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d936 1
a936 1
	      && ! (bfd_elf_link_record_local_dynamic_symbol
d1047 1
a1047 1
	      if (! (bfd_elf_link_record_local_dynamic_symbol
d1151 1
a1151 1
	      if (!bfd_elf_link_record_local_dynamic_symbol
d1177 1
a1177 1
	      if (! bfd_elf_link_record_dynamic_symbol (x->info, nh))
d1513 1
a1513 1
	if (!bfd_elf_link_record_local_dynamic_symbol
@


1.45.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1506 1
a1506 1
      hppa_info->other_rel_sec->size += sizeof (Elf64_External_Rela);
d1521 1
a1521 1
    hppa_info->dlt_rel_sec->size += sizeof (Elf64_External_Rela);
d1527 1
a1527 1
    hppa_info->opd_rel_sec->size += sizeof (Elf64_External_Rela);
d1541 1
a1541 1
      hppa_info->plt_rel_sec->size += t;
d1651 1
a1651 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d1664 1
a1664 1
	s->size = 0;
d1675 1
a1675 1
      hppa_info->dlt_sec->size = data.ofs;
d1680 1
a1680 1
      hppa_info->plt_sec->size = data.ofs;
d1685 1
a1685 1
      hppa_info->stub_sec->size = data.ofs;
d1694 1
a1694 1
      hppa_info->opd_sec->size = data.ofs;
d1723 1
a1723 1
	  if (s->size == 0)
d1736 1
a1736 1
	  if (s->size == 0)
d1744 1
a1744 1
	  if (s->size == 0)
d1758 1
a1758 1
	  if (s->size == 0)
d1824 2
a1825 2
	  s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
	  if (s->contents == NULL && s->size != 0)
d2501 1
a2501 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
d2540 1
a2540 1
	      dyn.d_un.d_val = s->size;
d2546 1
a2546 1
	      if (! s || ! s->size)
d2548 1
a2548 1
	      if (! s || ! s->size)
d2556 1
a2556 1
	      dyn.d_un.d_val = s->size;
d2558 1
a2558 1
	      dyn.d_un.d_val += s->size;
d2560 1
a2560 1
	      dyn.d_un.d_val += s->size;
d2565 1
a2565 1
	      dyn.d_un.d_val += s->size;
@


1.45.8.4
log
@Merge from mainline.
@
text
@d746 1
a746 1
	  h->ref_regular = 1;
d755 2
a756 3
		 && (!info->symbolic
		     || info->unresolved_syms_in_shared_libs == RM_IGNORE))
		|| !h->def_regular
d916 1
a916 1
	    h->needs_plt = 1;
d1017 1
a1017 1
      h->needs_plt = 1;
d1561 1
a1561 1
  if (h->u.weakdef != NULL)
d1563 4
a1566 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
@


1.45.12.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d176 1
a176 1
  PARAMS ((bfd *, struct elf_link_hash_entry *,
d449 2
a450 2
get_dyn_name (abfd, h, rel, pbuf, plen)
     bfd *abfd;
a455 1
  asection *sec = abfd->sections;
d861 1
a861 1
      addr_name = get_dyn_name (abfd, h, rel, &buf, &buf_len);
@


1.45.6.1
log
@	* elf-hppa.h (elf_hppa_relocate_section): Pass input_bfd instead of
	input_section in calls to get_dyn_name.
	* elf64-hppa.c (get_dyn_name): Change type of first argument to "bfd *".	Use section id of first section in input BFD to build dynamic name for
	local symbols.
	(elf64_hppa_check_relocs): Pass abfd in call to get_dyn_name.
@
text
@d176 1
a176 1
  PARAMS ((bfd *, struct elf_link_hash_entry *,
d449 2
a450 2
get_dyn_name (abfd, h, rel, pbuf, plen)
     bfd *abfd;
a455 1
  asection *sec = abfd->sections;
d861 1
a861 1
      addr_name = get_dyn_name (abfd, h, rel, &buf, &buf_len);
@


1.45.6.2
log
@Merge from mainline
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d935 1
a935 1
	      && ! (bfd_elf_link_record_local_dynamic_symbol
d1046 1
a1046 1
	      if (! (bfd_elf_link_record_local_dynamic_symbol
d1150 1
a1150 1
	      if (!bfd_elf_link_record_local_dynamic_symbol
d1176 1
a1176 1
	      if (! bfd_elf_link_record_dynamic_symbol (x->info, nh))
d1512 1
a1512 1
	if (!bfd_elf_link_record_local_dynamic_symbol
d1835 1
a1835 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
@


1.44
log
@	* elf-bfd.h (struct elf_backend_data): Remove "bfd *" and add
	"elflink_hash_entry *" param to elf_backend_link_output_symbol_hook.
	Add "elflink_hash_entry *" param to elf_backend_output_arch_syms.
	* elflink.h (elf_link_output_sym): Add "elflink_hash_entry *" param,
	and pass to output_symbol_hook.
	(elf_bfd_final_link): Adjust elf_link_output_sym calls.
	(elf_link_output_extsym): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-sh64.c (sh64_elf_link_output_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_link_output_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_link_output_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_link_output_symbol_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_link_output_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_output_arch_syms): Likewise.
	* elf64-hppa.c (elf64_hppa_link_output_symbol_hook): Likewise.
	Validate dynh->h against h.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add adjust_done bitfield.
	(link_hash_newfunc): Init it.
	(adjust_opd_syms): New function.
	(ppc64_elf_edit_opd): Set adjust_done when global .opd sym adjusted.
	Set opd.adjust for all .opd relocs.  Call adjust_opd_syms.
	(ppc64_elf_tls_optimize): Adjust possible .opd sym values here.
	(ppc64_elf_relocate_section): Also adjust syms not a multiple of 24.
	(ppc64_elf_output_symbol_hook): New function.
	(elf_backend_link_output_symbol_hook): Define.
@
text
@d1915 1
a1915 1
  if (dyn_h->h != h)
d1925 1
a1925 1
  if (dyn_h && dyn_h->want_opd && dyn_h->st_shndx != -1)
@


1.43
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d205 2
a206 2
  PARAMS ((bfd *abfd, struct bfd_link_info *, const char *,
	   Elf_Internal_Sym *, asection *input_sec));
d1896 1
a1896 2
elf64_hppa_link_output_symbol_hook (abfd, info, name, sym, input_sec)
     bfd *abfd ATTRIBUTE_UNUSED;
d1901 1
d1915 2
@


1.42
log
@* elf-bfd.h (elf_backend_data::elf_backend_modify_segment_map):
Add link info argument.
* elf32-i370.c (elf_backend_modify_segment_map): Likewise.
* elf32-ppc.c (ppc_elf_modify_segment_map): Likewise.
* elf32-xtensa.c (elf_xtensa_modify_segment_map): Likewise.
* elf64-hppa.c (elf64_hppa_modify_segment_map): Likewise.
* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
* elfxx-mips.h (_bfd_mips_elf_modify_segment_map): Likewise.
* elf.c (assign_file_positions_except_relocs,
assign_file_positions_for_segments): Likewise.  Adjust calls.
@
text
@d978 1
a978 1
/* Mark all funtions exported by this file so that we can later allocate
d1214 1
a1214 1
   because it contains "official prodecure descriptors".  The "official"
d2284 1
a2284 1
  /* Create a relocation for the DLT entry assocated with this symbol.
@


1.41
log
@Fix decision about when a .interp section should exist
@
text
@d216 1
a216 1
  PARAMS ((bfd *));
d2612 1
a2612 1
elf64_hppa_modify_segment_map (abfd)
d2614 1
@


1.40
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d1645 1
a1645 1
      if (! info->shared)
@


1.39
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@a2774 1
#define elf_backend_plt_header_size     0
@


1.38
log
@For elf32-hppa-linux, objects can have OSABI=Linux or OSABI=SysV; check for
both.
@
text
@d2678 3
a2680 6
  { ".fini",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".init",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.37
log
@Better handking for unresolved symbols
@
text
@d383 4
a386 1
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX)
@


1.36
log
@	* elf-hppa.h (elf_hppa_relocate_section): Look up dyn_h for undefweak.
	* elf64-hppa.c (elf64_hppa_finalize_dlt): Check h->root.type.
@
text
@d713 8
a720 7
      enum {
	NEED_DLT = 1,
	NEED_PLT = 2,
	NEED_STUB = 4,
	NEED_OPD = 8,
	NEED_DYNREL = 16,
      };
d750 1
a750 1
		    && (!info->symbolic || info->allow_shlib_undefined) )
@


1.35
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d2261 3
a2263 1
      else if (h->root.u.def.section)
@


1.34
log
@        * elflink.c (_bfd_elf_dynamic_symbol_p): New.
        * elf-bfd.h (_bfd_elf_dynamic_symbol_p): Declare it.
        (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Use it.
        * elf32-xtensa.c (xtensa_elf_dynamic_symbol_p): Likewise.
        * elf64-alpha.c (alpha_elf_dynamic_symbol_p): Likewise.
        * elf64-hppa.c (elf64_hppa_dynamic_symbol_p): Likewise.
        * elfxx-ia64.c (elfNN_ia64_dynamic_symbol_p): Likewise.
        Update all callers to provide the relocation being resolved.
@
text
@d2670 10
d2777 1
d2785 2
@


1.33
log
@Correct spelling of "relocatable".
@
text
@d959 12
a970 1
  if (h == NULL)
a971 22

  while (h->root.type == bfd_link_hash_indirect
	 || h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  if (h->dynindx == -1)
    return FALSE;

  if (h->root.type == bfd_link_hash_undefweak
      || h->root.type == bfd_link_hash_defweak)
    return TRUE;

  if (h->root.root.string[0] == '$' && h->root.root.string[1] == '$')
    return FALSE;

  if ((info->shared && (!info->symbolic || info->allow_shlib_undefined))
      || ((h->elf_link_hash_flags
	   & (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR))
	  == (ELF_LINK_HASH_DEF_DYNAMIC | ELF_LINK_HASH_REF_REGULAR)))
    return TRUE;

  return FALSE;
@


1.32
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d602 1
a602 1
  if (info->relocateable)
@


1.31
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d609 1
a609 1
      if (! bfd_elf64_link_create_dynamic_sections (abfd, info))
d2695 1
a2695 1
  64, 8,
@


1.31.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d609 1
a609 1
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
d2695 1
a2695 1
  64, 3,
@


1.30
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d4 1
a4 1
This file is part of BFD, the Binary File Descriptor library.
d6 4
a9 4
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.
d11 4
a14 4
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
d16 3
a18 3
You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.29
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d159 1
a159 1
static boolean elf64_hppa_dyn_hash_table_init
d169 1
a169 1
	   boolean create, boolean copy));
d172 1
a172 1
	   boolean (*func) (struct elf64_hppa_dyn_hash_entry *, PTR),
d183 1
a183 1
static boolean elf64_hppa_object_p
d186 1
a186 1
static boolean elf64_hppa_section_from_shdr
d192 1
a192 1
static boolean elf64_hppa_create_dynamic_sections
d195 1
a195 1
static boolean elf64_hppa_adjust_dynamic_symbol
d198 1
a198 1
static boolean elf64_hppa_mark_milli_and_exported_functions
d201 1
a201 1
static boolean elf64_hppa_size_dynamic_sections
d204 3
a206 3
static boolean elf64_hppa_link_output_symbol_hook
PARAMS ((bfd *abfd, struct bfd_link_info *, const char *,
	 Elf_Internal_Sym *, asection *input_sec));
d208 1
a208 1
static boolean elf64_hppa_finish_dynamic_symbol
d212 2
a213 1
static int elf64_hppa_additional_program_headers PARAMS ((bfd *));
d215 2
a216 1
static boolean elf64_hppa_modify_segment_map PARAMS ((bfd *));
d221 1
a221 1
static boolean elf64_hppa_finish_dynamic_sections
d224 1
a224 1
static boolean elf64_hppa_check_relocs
d228 1
a228 1
static boolean elf64_hppa_dynamic_symbol_p
d231 1
a231 1
static boolean elf64_hppa_mark_exported_functions
d234 1
a234 1
static boolean elf64_hppa_finalize_opd
d237 1
a237 1
static boolean elf64_hppa_finalize_dlt
d240 1
a240 1
static boolean allocate_global_data_dlt
d243 1
a243 1
static boolean allocate_global_data_plt
d246 1
a246 1
static boolean allocate_global_data_stub
d249 1
a249 1
static boolean allocate_global_data_opd
d252 1
a252 1
static boolean get_reloc_section
d255 1
a255 1
static boolean count_dyn_reloc
d259 1
a259 1
static boolean allocate_dynrel_entries
d262 1
a262 1
static boolean elf64_hppa_finalize_dynreloc
d265 1
a265 1
static boolean get_opd
d268 1
a268 1
static boolean get_plt
d271 1
a271 1
static boolean get_dlt
d274 1
a274 1
static boolean get_stub
d280 1
a280 1
static boolean
d350 1
a350 1
     boolean create, copy;
d361 1
a361 1
     boolean (*func) PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d366 1
a366 1
    (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) func,
d373 1
a373 1
static boolean
d384 1
a384 1
	return false;
d389 1
a389 1
	return false;
d405 1
a405 1
  return true;
d410 1
a410 1
static boolean
d422 1
a422 1
	return false;
d426 1
a426 1
	return false;
d431 1
a431 1
      return false;
d435 1
a435 1
    return false;
d438 1
a438 1
  return true;
d502 1
a502 1
static boolean
d516 1
a516 1
    return false;
d542 1
a542 1
	return false;
d546 1
a546 1
  return true;
d555 1
a555 1
static boolean
d570 1
a570 1
    return false;
d580 1
a580 1
  return true;
d586 1
a586 1
static boolean
d603 1
a603 1
    return true;
d610 1
a610 1
	return false;
d644 1
a644 1
	    return false;
d699 1
a699 1
	return false;
d726 1
a726 1
      boolean maybe_dynamic;
d747 1
a747 1
      maybe_dynamic = false;
d752 1
a752 1
	maybe_dynamic = true;
d861 1
a861 1
					  addr_name, true, true);
d932 1
a932 1
	    return false;
d938 1
a938 1
  return true;
d943 1
a943 1
  return false;
d954 1
a954 1
static boolean
d960 1
a960 1
    return false;
d967 1
a967 1
    return false;
d971 1
a971 1
    return true;
d974 1
a974 1
    return false;
d980 1
a980 1
    return true;
d982 1
a982 1
  return false;
d988 1
a988 1
static boolean
d1011 1
a1011 1
					  h->root.root.string, true, true);
d1017 1
a1017 1
	return false;
d1025 1
a1025 1
  return true;
d1030 1
a1030 1
static boolean
d1054 1
a1054 1
		return false;
d1061 1
a1061 1
  return true;
d1066 1
a1066 1
static boolean
d1087 1
a1087 1
  return true;
d1092 1
a1092 1
static boolean
d1110 1
a1110 1
  return true;
d1115 1
a1115 1
static boolean
d1158 1
a1158 1
		return false;
d1176 1
a1176 1
					 new_name, true, true, true);
d1183 1
a1183 1
		return false;
d1194 1
a1194 1
  return true;
d1225 1
a1225 1
static boolean
d1252 1
a1252 1
	  return false;
d1258 1
a1258 1
  return true;
d1263 1
a1263 1
static boolean
d1290 1
a1290 1
	  return false;
d1296 1
a1296 1
  return true;
d1301 1
a1301 1
static boolean
d1328 1
a1328 1
	  return false;
d1334 1
a1334 1
  return true;
d1339 1
a1339 1
static boolean
d1367 1
a1367 1
	  return false;
d1373 1
a1373 1
  return true;
d1414 1
a1414 1
static boolean
d1422 1
a1422 1
    return false;
d1425 1
a1425 1
    return false;
d1428 1
a1428 1
    return false;
d1431 1
a1431 1
    return false;
d1441 1
a1441 1
    return false;
d1452 1
a1452 1
    return false;
d1463 1
a1463 1
    return false;
d1474 1
a1474 1
    return false;
d1477 1
a1477 1
  return true;
d1483 1
a1483 1
static boolean
d1491 1
a1491 1
  boolean dynamic_symbol, shared;
d1500 1
a1500 1
    return true;
d1520 1
a1520 1
	  return false;
d1549 1
a1549 1
  return true;
d1555 1
a1555 1
static boolean
d1572 1
a1572 1
      return true;
d1582 1
a1582 1
  return true;
d1590 1
a1590 1
static boolean
d1609 1
a1609 1
      return true;
d1618 1
a1618 1
static boolean
d1625 3
a1627 3
  boolean plt;
  boolean relocs;
  boolean reltext;
d1708 3
a1710 3
  plt = false;
  relocs = false;
  reltext = false;
d1714 1
a1714 1
      boolean strip;
d1730 1
a1730 1
	      strip = true;
d1735 1
a1735 1
	      plt = true;
d1743 1
a1743 1
	      strip = true;
d1751 1
a1751 1
	      strip = true;
d1774 1
a1774 1
	      strip = true;
d1786 1
a1786 1
		  relocs = true;
d1799 1
a1799 1
		    reltext = true;
d1831 1
a1831 1
	    return false;
d1845 1
a1845 1
	return false;
d1857 1
a1857 1
	    return false;
d1863 1
a1863 1
	return false;
d1870 1
a1870 1
	    return false;
d1878 1
a1878 1
	    return false;
d1884 1
a1884 1
	    return false;
d1890 1
a1890 1
  return true;
d1902 1
a1902 1
static boolean
d1916 1
a1916 1
    return true;
d1921 1
a1921 1
				      name, false, false);
d1937 1
a1937 1
  return true;
d1943 1
a1943 1
static boolean
d1956 1
a1956 1
				      h->root.root.string, false, false);
d2089 1
a2089 1
	  return false;
d2112 1
a2112 1
  return true;
d2118 1
a2118 1
static boolean
d2216 1
a2216 1
				     new_name, false, false, false);
d2230 1
a2230 1
  return true;
d2237 1
a2237 1
static boolean
d2323 1
a2323 1
  return true;
d2329 1
a2329 1
static boolean
d2342 1
a2342 1
    return true;
d2440 1
a2440 1
  return true;
d2466 1
a2466 1
static boolean
d2574 1
a2574 1
  return true;
d2616 1
a2616 1
static boolean
d2634 1
a2634 1
	    return false;
d2665 1
a2665 1
  return true;
d2774 4
a2777 4
#define elf_backend_type_change_ok true
#define elf_backend_get_symbol_type	     elf64_hppa_elf_get_symbol_type
#define elf_backend_reloc_type_class	     elf64_hppa_reloc_type_class
#define elf_backend_rela_normal		     1
@


1.28
log
@Force DT_FLAGS to always be set.  Required by HPUX 11.00 patch PHSS_26559.
@
text
@d187 1
a187 1
  PARAMS ((bfd *, Elf64_Internal_Shdr *, const char *));
d411 1
a411 1
     Elf64_Internal_Shdr *hdr;
d1994 1
d2033 3
a2035 5
      bfd_elf64_swap_reloca_out (splt->output_section->owner, &rel,
				 (((Elf64_External_Rela *)
				   spltrel->contents)
				  + spltrel->reloc_count));
      spltrel->reloc_count++;
d2158 2
a2159 1
      Elf64_Internal_Rela rel;
d2224 3
a2226 5
      bfd_elf64_swap_reloca_out (sopd->output_section->owner, &rel,
				 (((Elf64_External_Rela *)
				   sopdrel->contents)
				  + sopdrel->reloc_count));
      sopdrel->reloc_count++;
d2292 2
a2293 1
      Elf64_Internal_Rela rel;
d2317 3
a2319 5
      bfd_elf64_swap_reloca_out (sdlt->output_section->owner, &rel,
				 (((Elf64_External_Rela *)
				   sdltrel->contents)
				  + sdltrel->reloc_count));
      sdltrel->reloc_count++;
d2362 2
a2363 1
	  Elf64_Internal_Rela rel;
d2430 3
d2434 1
a2434 5
				     &rel,
				     (((Elf64_External_Rela *)
				      hppa_info->other_rel_sec->contents)
				      + hppa_info->other_rel_sec->reloc_count));
	  hppa_info->other_rel_sec->reloc_count++;
d2704 4
a2707 4
  NULL,
  NULL,
  NULL,
  NULL
@


1.27
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d1858 5
@


1.27.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a1857 5
      /* Force DT_FLAGS to always be set.
	 Required by HPUX 11.00 patch PHSS_26559.  */
      if (!add_dynamic_entry (DT_FLAGS, (info)->flags))
	return false;

@


1.27.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d4 1
a4 1
   This file is part of BFD, the Binary File Descriptor library.
d6 13
a18 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d159 1
a159 1
static bfd_boolean elf64_hppa_dyn_hash_table_init
d169 1
a169 1
	   bfd_boolean create, bfd_boolean copy));
d172 1
a172 1
	   bfd_boolean (*func) (struct elf64_hppa_dyn_hash_entry *, PTR),
d183 1
a183 1
static bfd_boolean elf64_hppa_object_p
d186 2
a187 2
static bfd_boolean elf64_hppa_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d192 1
a192 1
static bfd_boolean elf64_hppa_create_dynamic_sections
d195 1
a195 1
static bfd_boolean elf64_hppa_adjust_dynamic_symbol
d198 1
a198 1
static bfd_boolean elf64_hppa_mark_milli_and_exported_functions
d201 1
a201 1
static bfd_boolean elf64_hppa_size_dynamic_sections
d204 3
a206 3
static bfd_boolean elf64_hppa_link_output_symbol_hook
  PARAMS ((struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *, struct elf_link_hash_entry *));
d208 1
a208 1
static bfd_boolean elf64_hppa_finish_dynamic_symbol
d212 1
a212 2
static int elf64_hppa_additional_program_headers
  PARAMS ((bfd *));
d214 1
a214 2
static bfd_boolean elf64_hppa_modify_segment_map
  PARAMS ((bfd *, struct bfd_link_info *));
d219 1
a219 1
static bfd_boolean elf64_hppa_finish_dynamic_sections
d222 1
a222 1
static bfd_boolean elf64_hppa_check_relocs
d226 1
a226 1
static bfd_boolean elf64_hppa_dynamic_symbol_p
d229 1
a229 1
static bfd_boolean elf64_hppa_mark_exported_functions
d232 1
a232 1
static bfd_boolean elf64_hppa_finalize_opd
d235 1
a235 1
static bfd_boolean elf64_hppa_finalize_dlt
d238 1
a238 1
static bfd_boolean allocate_global_data_dlt
d241 1
a241 1
static bfd_boolean allocate_global_data_plt
d244 1
a244 1
static bfd_boolean allocate_global_data_stub
d247 1
a247 1
static bfd_boolean allocate_global_data_opd
d250 1
a250 1
static bfd_boolean get_reloc_section
d253 1
a253 1
static bfd_boolean count_dyn_reloc
d257 1
a257 1
static bfd_boolean allocate_dynrel_entries
d260 1
a260 1
static bfd_boolean elf64_hppa_finalize_dynreloc
d263 1
a263 1
static bfd_boolean get_opd
d266 1
a266 1
static bfd_boolean get_plt
d269 1
a269 1
static bfd_boolean get_dlt
d272 1
a272 1
static bfd_boolean get_stub
d278 1
a278 1
static bfd_boolean
d348 1
a348 1
     bfd_boolean create, copy;
d359 1
a359 1
     bfd_boolean (*func) PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d364 1
a364 1
    (bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) func,
d371 1
a371 1
static bfd_boolean
d381 2
a382 5
      /* GCC on hppa-linux produces binaries with OSABI=Linux,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
	return FALSE;
d387 1
a387 1
	return FALSE;
d403 1
a403 1
  return TRUE;
d408 1
a408 1
static bfd_boolean
d411 1
a411 1
     Elf_Internal_Shdr *hdr;
d420 1
a420 1
	return FALSE;
d424 1
a424 1
	return FALSE;
d429 1
a429 1
      return FALSE;
d433 1
a433 1
    return FALSE;
d436 1
a436 1
  return TRUE;
d500 1
a500 1
static bfd_boolean
d514 1
a514 1
    return FALSE;
d540 1
a540 1
	return FALSE;
d544 1
a544 1
  return TRUE;
d553 1
a553 1
static bfd_boolean
d568 1
a568 1
    return FALSE;
d578 1
a578 1
  return TRUE;
d584 1
a584 1
static bfd_boolean
d600 2
a601 2
  if (info->relocatable)
    return TRUE;
d607 2
a608 2
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
	return FALSE;
d642 1
a642 1
	    return FALSE;
d697 1
a697 1
	return FALSE;
d711 7
a717 8
      enum
	{
	  NEED_DLT = 1,
	  NEED_PLT = 2,
	  NEED_STUB = 4,
	  NEED_OPD = 8,
	  NEED_DYNREL = 16,
	};
d724 1
a724 1
      bfd_boolean maybe_dynamic;
d745 1
a745 1
      maybe_dynamic = FALSE;
d747 1
a747 1
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
d750 1
a750 1
	maybe_dynamic = TRUE;
d859 1
a859 1
					  addr_name, TRUE, TRUE);
d930 1
a930 1
	    return FALSE;
d936 1
a936 1
  return TRUE;
d941 1
a941 1
  return FALSE;
d952 1
a952 1
static bfd_boolean
d957 9
a965 8
  /* ??? What, if anything, needs to happen wrt STV_PROTECTED symbols
     and relocations that retrieve a function descriptor?  Assume the
     worst for now.  */
  if (_bfd_elf_dynamic_symbol_p (h, info, 1))
    {
      /* ??? Why is this here and not elsewhere is_local_label_name.  */
      if (h->root.root.string[0] == '$' && h->root.root.string[1] == '$')
	return FALSE;
d967 14
a980 4
      return TRUE;
    }
  else
    return FALSE;
d983 1
a983 1
/* Mark all functions exported by this file so that we can later allocate
d986 1
a986 1
static bfd_boolean
d1009 1
a1009 1
					  h->root.root.string, TRUE, TRUE);
d1015 1
a1015 1
	return FALSE;
d1023 1
a1023 1
  return TRUE;
d1028 1
a1028 1
static bfd_boolean
d1052 1
a1052 1
		return FALSE;
d1059 1
a1059 1
  return TRUE;
d1064 1
a1064 1
static bfd_boolean
d1085 1
a1085 1
  return TRUE;
d1090 1
a1090 1
static bfd_boolean
d1108 1
a1108 1
  return TRUE;
d1113 1
a1113 1
static bfd_boolean
d1156 1
a1156 1
		return FALSE;
d1174 1
a1174 1
					 new_name, TRUE, TRUE, TRUE);
d1181 1
a1181 1
		return FALSE;
d1192 1
a1192 1
  return TRUE;
d1219 1
a1219 1
   because it contains "official procedure descriptors".  The "official"
d1223 1
a1223 1
static bfd_boolean
d1250 1
a1250 1
	  return FALSE;
d1256 1
a1256 1
  return TRUE;
d1261 1
a1261 1
static bfd_boolean
d1288 1
a1288 1
	  return FALSE;
d1294 1
a1294 1
  return TRUE;
d1299 1
a1299 1
static bfd_boolean
d1326 1
a1326 1
	  return FALSE;
d1332 1
a1332 1
  return TRUE;
d1337 1
a1337 1
static bfd_boolean
d1365 1
a1365 1
	  return FALSE;
d1371 1
a1371 1
  return TRUE;
d1412 1
a1412 1
static bfd_boolean
d1420 1
a1420 1
    return FALSE;
d1423 1
a1423 1
    return FALSE;
d1426 1
a1426 1
    return FALSE;
d1429 1
a1429 1
    return FALSE;
d1439 1
a1439 1
    return FALSE;
d1450 1
a1450 1
    return FALSE;
d1461 1
a1461 1
    return FALSE;
d1472 1
a1472 1
    return FALSE;
d1475 1
a1475 1
  return TRUE;
d1481 1
a1481 1
static bfd_boolean
d1489 1
a1489 1
  bfd_boolean dynamic_symbol, shared;
d1498 1
a1498 1
    return TRUE;
d1518 1
a1518 1
	  return FALSE;
d1547 1
a1547 1
  return TRUE;
d1553 1
a1553 1
static bfd_boolean
d1570 1
a1570 1
      return TRUE;
d1580 1
a1580 1
  return TRUE;
d1588 1
a1588 1
static bfd_boolean
d1607 1
a1607 1
      return TRUE;
d1616 1
a1616 1
static bfd_boolean
d1623 3
a1625 3
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;
d1650 1
a1650 1
      if (info->executable)
d1706 3
a1708 3
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
d1712 1
a1712 1
      bfd_boolean strip;
d1728 1
a1728 1
	      strip = TRUE;
d1733 1
a1733 1
	      plt = TRUE;
d1741 1
a1741 1
	      strip = TRUE;
d1749 1
a1749 1
	      strip = TRUE;
d1772 1
a1772 1
	      strip = TRUE;
d1784 1
a1784 1
		  relocs = TRUE;
d1797 1
a1797 1
		    reltext = TRUE;
d1829 1
a1829 1
	    return FALSE;
d1843 1
a1843 1
	return FALSE;
d1855 1
a1855 1
	    return FALSE;
d1861 1
a1861 1
	return FALSE;
d1868 1
a1868 1
	    return FALSE;
d1876 1
a1876 1
	    return FALSE;
d1882 1
a1882 1
	    return FALSE;
d1888 1
a1888 1
  return TRUE;
d1900 3
a1902 2
static bfd_boolean
elf64_hppa_link_output_symbol_hook (info, name, sym, input_sec, h)
a1906 1
     struct elf_link_hash_entry *h;
d1914 1
a1914 1
    return TRUE;
d1919 1
a1919 3
				      name, FALSE, FALSE);
  if (!dyn_h || dyn_h->h != h)
    return TRUE;
d1928 1
a1928 1
  if (dyn_h->want_opd && dyn_h->st_shndx != -1)
d1935 1
a1935 1
  return TRUE;
d1941 1
a1941 1
static bfd_boolean
d1954 1
a1954 1
				      h->root.root.string, FALSE, FALSE);
a1993 1
      bfd_byte *loc;
d2032 5
a2036 3
      loc = spltrel->contents;
      loc += spltrel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (splt->output_section->owner, &rel, loc);
d2088 1
a2088 1
	  return FALSE;
d2111 1
a2111 1
  return TRUE;
d2117 1
a2117 1
static bfd_boolean
d2159 1
a2159 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d2214 1
a2214 1
				     new_name, FALSE, FALSE, FALSE);
d2224 5
a2228 3
      loc = sopdrel->contents;
      loc += sopdrel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (sopd->output_section->owner, &rel, loc);
d2230 1
a2230 1
  return TRUE;
d2237 1
a2237 1
static bfd_boolean
d2272 1
a2272 3
      else if ((h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	       && h->root.u.def.section)
d2289 1
a2289 1
  /* Create a relocation for the DLT entry associated with this symbol.
d2294 1
a2294 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d2318 5
a2322 3
      loc = sdltrel->contents;
      loc += sdltrel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (sdlt->output_section->owner, &rel, loc);
d2324 1
a2324 1
  return TRUE;
d2330 1
a2330 1
static bfd_boolean
d2343 1
a2343 1
    return TRUE;
d2365 1
a2365 2
	  Elf_Internal_Rela rel;
	  bfd_byte *loc;
a2431 3
	  loc = hppa_info->other_rel_sec->contents;
	  loc += (hppa_info->other_rel_sec->reloc_count++
		  * sizeof (Elf64_External_Rela));
d2433 5
a2437 1
				     &rel, loc);
d2441 1
a2441 1
  return TRUE;
d2467 1
a2467 1
static bfd_boolean
d2575 1
a2575 1
  return TRUE;
d2617 2
a2618 2
static bfd_boolean
elf64_hppa_modify_segment_map (abfd, info)
a2619 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d2635 1
a2635 1
	    return FALSE;
d2666 1
a2666 1
  return TRUE;
a2681 7
static struct bfd_elf_special_section const elf64_hppa_special_sections[]=
{
  { ".fini",    5, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".init",    5, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { NULL,       0, 0, 0,            0 }
};

d2696 1
a2696 1
  64, 3,
d2707 4
a2710 4
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
d2774 5
a2778 5
#define elf_backend_type_change_ok	TRUE
#define elf_backend_get_symbol_type	elf64_hppa_elf_get_symbol_type
#define elf_backend_reloc_type_class	elf64_hppa_reloc_type_class
#define elf_backend_rela_normal		1
#define elf_backend_special_sections	elf64_hppa_special_sections
a2785 2

#undef elf_backend_special_sections
@


1.27.10.1
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@a1857 5
      /* Force DT_FLAGS to always be set.
	 Required by HPUX 11.00 patch PHSS_26559.  */
      if (!add_dynamic_entry (DT_FLAGS, (info)->flags))
	return false;

@


1.27.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d159 1
a159 1
static bfd_boolean elf64_hppa_dyn_hash_table_init
d169 1
a169 1
	   bfd_boolean create, bfd_boolean copy));
d172 1
a172 1
	   bfd_boolean (*func) (struct elf64_hppa_dyn_hash_entry *, PTR),
d183 1
a183 1
static bfd_boolean elf64_hppa_object_p
d186 2
a187 2
static bfd_boolean elf64_hppa_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
d192 1
a192 1
static bfd_boolean elf64_hppa_create_dynamic_sections
d195 1
a195 1
static bfd_boolean elf64_hppa_adjust_dynamic_symbol
d198 1
a198 1
static bfd_boolean elf64_hppa_mark_milli_and_exported_functions
d201 1
a201 1
static bfd_boolean elf64_hppa_size_dynamic_sections
d204 3
a206 3
static bfd_boolean elf64_hppa_link_output_symbol_hook
  PARAMS ((bfd *abfd, struct bfd_link_info *, const char *,
	   Elf_Internal_Sym *, asection *input_sec));
d208 1
a208 1
static bfd_boolean elf64_hppa_finish_dynamic_symbol
d212 1
a212 2
static int elf64_hppa_additional_program_headers
  PARAMS ((bfd *));
d214 1
a214 2
static bfd_boolean elf64_hppa_modify_segment_map
  PARAMS ((bfd *));
d219 1
a219 1
static bfd_boolean elf64_hppa_finish_dynamic_sections
d222 1
a222 1
static bfd_boolean elf64_hppa_check_relocs
d226 1
a226 1
static bfd_boolean elf64_hppa_dynamic_symbol_p
d229 1
a229 1
static bfd_boolean elf64_hppa_mark_exported_functions
d232 1
a232 1
static bfd_boolean elf64_hppa_finalize_opd
d235 1
a235 1
static bfd_boolean elf64_hppa_finalize_dlt
d238 1
a238 1
static bfd_boolean allocate_global_data_dlt
d241 1
a241 1
static bfd_boolean allocate_global_data_plt
d244 1
a244 1
static bfd_boolean allocate_global_data_stub
d247 1
a247 1
static bfd_boolean allocate_global_data_opd
d250 1
a250 1
static bfd_boolean get_reloc_section
d253 1
a253 1
static bfd_boolean count_dyn_reloc
d257 1
a257 1
static bfd_boolean allocate_dynrel_entries
d260 1
a260 1
static bfd_boolean elf64_hppa_finalize_dynreloc
d263 1
a263 1
static bfd_boolean get_opd
d266 1
a266 1
static bfd_boolean get_plt
d269 1
a269 1
static bfd_boolean get_dlt
d272 1
a272 1
static bfd_boolean get_stub
d278 1
a278 1
static bfd_boolean
d348 1
a348 1
     bfd_boolean create, copy;
d359 1
a359 1
     bfd_boolean (*func) PARAMS ((struct elf64_hppa_dyn_hash_entry *, PTR));
d364 1
a364 1
    (bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) func,
d371 1
a371 1
static bfd_boolean
d382 1
a382 1
	return FALSE;
d387 1
a387 1
	return FALSE;
d403 1
a403 1
  return TRUE;
d408 1
a408 1
static bfd_boolean
d411 1
a411 1
     Elf_Internal_Shdr *hdr;
d420 1
a420 1
	return FALSE;
d424 1
a424 1
	return FALSE;
d429 1
a429 1
      return FALSE;
d433 1
a433 1
    return FALSE;
d436 1
a436 1
  return TRUE;
d500 1
a500 1
static bfd_boolean
d514 1
a514 1
    return FALSE;
d540 1
a540 1
	return FALSE;
d544 1
a544 1
  return TRUE;
d553 1
a553 1
static bfd_boolean
d568 1
a568 1
    return FALSE;
d578 1
a578 1
  return TRUE;
d584 1
a584 1
static bfd_boolean
d601 1
a601 1
    return TRUE;
d608 1
a608 1
	return FALSE;
d642 1
a642 1
	    return FALSE;
d697 1
a697 1
	return FALSE;
d724 1
a724 1
      bfd_boolean maybe_dynamic;
d745 1
a745 1
      maybe_dynamic = FALSE;
d750 1
a750 1
	maybe_dynamic = TRUE;
d859 1
a859 1
					  addr_name, TRUE, TRUE);
d930 1
a930 1
	    return FALSE;
d936 1
a936 1
  return TRUE;
d941 1
a941 1
  return FALSE;
d952 1
a952 1
static bfd_boolean
d958 1
a958 1
    return FALSE;
d965 1
a965 1
    return FALSE;
d969 1
a969 1
    return TRUE;
d972 1
a972 1
    return FALSE;
d978 1
a978 1
    return TRUE;
d980 1
a980 1
  return FALSE;
d986 1
a986 1
static bfd_boolean
d1009 1
a1009 1
					  h->root.root.string, TRUE, TRUE);
d1015 1
a1015 1
	return FALSE;
d1023 1
a1023 1
  return TRUE;
d1028 1
a1028 1
static bfd_boolean
d1052 1
a1052 1
		return FALSE;
d1059 1
a1059 1
  return TRUE;
d1064 1
a1064 1
static bfd_boolean
d1085 1
a1085 1
  return TRUE;
d1090 1
a1090 1
static bfd_boolean
d1108 1
a1108 1
  return TRUE;
d1113 1
a1113 1
static bfd_boolean
d1156 1
a1156 1
		return FALSE;
d1174 1
a1174 1
					 new_name, TRUE, TRUE, TRUE);
d1181 1
a1181 1
		return FALSE;
d1192 1
a1192 1
  return TRUE;
d1223 1
a1223 1
static bfd_boolean
d1250 1
a1250 1
	  return FALSE;
d1256 1
a1256 1
  return TRUE;
d1261 1
a1261 1
static bfd_boolean
d1288 1
a1288 1
	  return FALSE;
d1294 1
a1294 1
  return TRUE;
d1299 1
a1299 1
static bfd_boolean
d1326 1
a1326 1
	  return FALSE;
d1332 1
a1332 1
  return TRUE;
d1337 1
a1337 1
static bfd_boolean
d1365 1
a1365 1
	  return FALSE;
d1371 1
a1371 1
  return TRUE;
d1412 1
a1412 1
static bfd_boolean
d1420 1
a1420 1
    return FALSE;
d1423 1
a1423 1
    return FALSE;
d1426 1
a1426 1
    return FALSE;
d1429 1
a1429 1
    return FALSE;
d1439 1
a1439 1
    return FALSE;
d1450 1
a1450 1
    return FALSE;
d1461 1
a1461 1
    return FALSE;
d1472 1
a1472 1
    return FALSE;
d1475 1
a1475 1
  return TRUE;
d1481 1
a1481 1
static bfd_boolean
d1489 1
a1489 1
  bfd_boolean dynamic_symbol, shared;
d1498 1
a1498 1
    return TRUE;
d1518 1
a1518 1
	  return FALSE;
d1547 1
a1547 1
  return TRUE;
d1553 1
a1553 1
static bfd_boolean
d1570 1
a1570 1
      return TRUE;
d1580 1
a1580 1
  return TRUE;
d1588 1
a1588 1
static bfd_boolean
d1607 1
a1607 1
      return TRUE;
d1616 1
a1616 1
static bfd_boolean
d1623 3
a1625 3
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;
d1706 3
a1708 3
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
d1712 1
a1712 1
      bfd_boolean strip;
d1728 1
a1728 1
	      strip = TRUE;
d1733 1
a1733 1
	      plt = TRUE;
d1741 1
a1741 1
	      strip = TRUE;
d1749 1
a1749 1
	      strip = TRUE;
d1772 1
a1772 1
	      strip = TRUE;
d1784 1
a1784 1
		  relocs = TRUE;
d1797 1
a1797 1
		    reltext = TRUE;
d1829 1
a1829 1
	    return FALSE;
d1843 1
a1843 1
	return FALSE;
d1855 1
a1855 1
	    return FALSE;
d1861 1
a1861 1
	return FALSE;
d1868 1
a1868 1
	    return FALSE;
d1876 1
a1876 1
	    return FALSE;
d1882 1
a1882 1
	    return FALSE;
d1888 1
a1888 1
  return TRUE;
d1900 1
a1900 1
static bfd_boolean
d1914 1
a1914 1
    return TRUE;
d1919 1
a1919 1
				      name, FALSE, FALSE);
d1935 1
a1935 1
  return TRUE;
d1941 1
a1941 1
static bfd_boolean
d1954 1
a1954 1
				      h->root.root.string, FALSE, FALSE);
a1993 1
      bfd_byte *loc;
d2032 5
a2036 3
      loc = spltrel->contents;
      loc += spltrel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (splt->output_section->owner, &rel, loc);
d2088 1
a2088 1
	  return FALSE;
d2111 1
a2111 1
  return TRUE;
d2117 1
a2117 1
static bfd_boolean
d2159 1
a2159 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d2214 1
a2214 1
				     new_name, FALSE, FALSE, FALSE);
d2224 5
a2228 3
      loc = sopdrel->contents;
      loc += sopdrel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (sopd->output_section->owner, &rel, loc);
d2230 1
a2230 1
  return TRUE;
d2237 1
a2237 1
static bfd_boolean
d2294 1
a2294 2
      Elf_Internal_Rela rel;
      bfd_byte *loc;
d2318 5
a2322 3
      loc = sdltrel->contents;
      loc += sdltrel->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (sdlt->output_section->owner, &rel, loc);
d2324 1
a2324 1
  return TRUE;
d2330 1
a2330 1
static bfd_boolean
d2343 1
a2343 1
    return TRUE;
d2365 1
a2365 2
	  Elf_Internal_Rela rel;
	  bfd_byte *loc;
a2431 3
	  loc = hppa_info->other_rel_sec->contents;
	  loc += (hppa_info->other_rel_sec->reloc_count++
		  * sizeof (Elf64_External_Rela));
d2433 5
a2437 1
				     &rel, loc);
d2441 1
a2441 1
  return TRUE;
d2467 1
a2467 1
static bfd_boolean
d2575 1
a2575 1
  return TRUE;
d2617 1
a2617 1
static bfd_boolean
d2635 1
a2635 1
	    return FALSE;
d2666 1
a2666 1
  return TRUE;
d2707 4
a2710 4
  bfd_elf64_swap_reloc_in,
  bfd_elf64_swap_reloc_out,
  bfd_elf64_swap_reloca_in,
  bfd_elf64_swap_reloca_out
d2775 4
a2778 4
#define elf_backend_type_change_ok	TRUE
#define elf_backend_get_symbol_type	elf64_hppa_elf_get_symbol_type
#define elf_backend_reloc_type_class	elf64_hppa_reloc_type_class
#define elf_backend_rela_normal		1
@


1.27.10.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d4 1
a4 1
   This file is part of BFD, the Binary File Descriptor library.
d6 4
a9 4
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
d11 4
a14 4
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d16 3
a18 3
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.27.10.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d609 1
a609 1
      if (! _bfd_elf_link_create_dynamic_sections (abfd, info))
d2695 1
a2695 1
  64, 3,
@


1.27.10.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d602 1
a602 1
  if (info->relocatable)
@


1.27.10.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d959 13
a971 8
  /* ??? What, if anything, needs to happen wrt STV_PROTECTED symbols
     and relocations that retrieve a function descriptor?  Assume the
     worst for now.  */
  if (_bfd_elf_dynamic_symbol_p (h, info, 1))
    {
      /* ??? Why is this here and not elsewhere is_local_label_name.  */
      if (h->root.root.string[0] == '$' && h->root.root.string[1] == '$')
	return FALSE;
d973 1
a973 3
      return TRUE;
    }
  else
d975 8
d2272 1
a2272 3
      else if ((h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak)
	       && h->root.u.def.section)
a2680 10
static struct bfd_elf_special_section const elf64_hppa_special_sections[]=
{
  { ".fini",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".init",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { NULL,		0,	NULL,	0,
    0,			0 }
};

a2777 1
#define elf_backend_special_sections	elf64_hppa_special_sections
a2784 2

#undef elf_backend_special_sections
@


1.27.10.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d383 1
a383 4
      /* GCC on hppa-linux produces binaries with OSABI=Linux,
	 but the kernel produces corefiles with OSABI=SysV.  */
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX &&
	  i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_NONE) /* aka SYSV */
d713 7
a719 8
      enum
	{
	  NEED_DLT = 1,
	  NEED_PLT = 2,
	  NEED_STUB = 4,
	  NEED_OPD = 8,
	  NEED_DYNREL = 16,
	};
d749 1
a749 1
		 && (!info->symbolic || info->unresolved_syms_in_shared_libs == RM_IGNORE))
@


1.27.10.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1645 1
a1645 1
      if (info->executable)
d2678 6
a2683 3
  { ".fini",    5, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".init",    5, 0, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { NULL,       0, 0, 0,            0 }
d2778 1
@


1.27.10.9
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d205 2
a206 2
  PARAMS ((struct bfd_link_info *, const char *, Elf_Internal_Sym *,
	   asection *, struct elf_link_hash_entry *));
d216 1
a216 1
  PARAMS ((bfd *, struct bfd_link_info *));
d978 1
a978 1
/* Mark all functions exported by this file so that we can later allocate
d1214 1
a1214 1
   because it contains "official procedure descriptors".  The "official"
d1896 2
a1897 1
elf64_hppa_link_output_symbol_hook (info, name, sym, input_sec, h)
a1901 1
     struct elf_link_hash_entry *h;
a1914 2
  if (!dyn_h || dyn_h->h != h)
    return TRUE;
d1923 1
a1923 1
  if (dyn_h->want_opd && dyn_h->st_shndx != -1)
d2284 1
a2284 1
  /* Create a relocation for the DLT entry associated with this symbol.
d2612 1
a2612 1
elf64_hppa_modify_segment_map (abfd, info)
a2613 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
@


1.26
log
@	* elf-bfd.h (struct elf_reloc_cookie): Remove locsym_shndx,
	change type of locsyms.
	(bfd_elf_get_elf_syms): Declare.
	* elf.c (bfd_elf_get_elf_syms): New function.
	(group_signature): Use bfd_elf_get_elf_syms.
	(bfd_section_from_r_symndx): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Reorganise to increase
	locality of various data structures.  Properly free internal relocs.
	(elf_bfd_final_link): Properly free internal relocs.
	(elf_link_check_versioned_symbol): Use bfd_elf_get_elf_syms.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.  Properly free internal relocs.
	(elf_gc_sweep): Properly free internal relocs.
	(elf_reloc_symbol_deleted_p): No need to swap syms in.
	(elf_bfd_discard_info): Use bfd_elf_get_elf_syms.  Properly free
	internal relocs.
	* elf-m10200.c (mn10200_elf_relax_section): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	(mn10200_elf_relax_delete_bytes): Remove symbol swapping code.
	(mn10200_elf_symbol_address_p): Pass in internal syms.  Remove
	symbol swapping code.
	(mn10200_elf_get_relocated_section_contents): Use bfd_elf_get_elf_syms.
	Properly free possibly cached info.
	* elf-m10300.c (mn10300_elf_relax_section): As above for elf-m10200.c.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As above for elf-m10200.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-m32r.c (m32r_elf_relax_section): As above for elf-m10200.c.
	(m32r_elf_relax_delete_bytes): Likewise.
	(m32r_elf_get_relocated_section_contents): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Free section contents using
	elf_section_data to determine whether cached.
	(sh_elf_relax_section): As above for elf-m10200.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): As above.
	* elf64-alpha.c (elf64_alpha_relax_section): As above.  Also delay
	reading of local syms.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): As above.
	* elfxx-ia64.c (elfNN_ia64_relax_section): As above.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Properly free internal
	relocs.
	* elf32-arm.h (bfd_elf32_arm_process_before_allocation): Properly
	free internal relocs and section contents.  Don't read symbols.
	* elf32-hppa.c (get_local_syms): Use bfd_elf_get_elf_syms.
	(elf32_hppa_size_stubs): Don't free local syms.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Delay
	reading of local syms.  Use bfd_elf_get_elf_syms.  Properly free
	possibly cached info.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Use bfd_elf_get_elf_syms.
	* elf64-ppc.c (struct ppc_link_hash_table): Delete bfd_count and
	all_local_syms.
	(get_local_syms): Delete function.
	(edit_opd): Use bfd_elf_get_elf_syms.  Free on error exit.  Cache
	on exit.
	(ppc64_elf_size_stubs): Use bfd_elf_get_elf_syms.  Free/cache on exit.
@
text
@d2727 1
a2727 1
#define elf_backend_relocate_section	    elf_hppa_relocate_section
d2773 1
@


1.25
log
@        * elf64-hppa.c (elf64_hppa_reloc_type_class): New function.
        (elf64_hppa_finish_dynamic_sections): Check other_rel_sec, dlt_rel_sec
        and opd_rel_sec in order for starting rela section.  Check _raw_size.
        (elf_backend_reloc_type_class): Define.
@
text
@a593 1
  Elf_Internal_Shdr *shndx_hdr;
d615 1
a615 1
     for this BFD.  This is disgusting.  */
d621 2
a622 3
      Elf_Internal_Sym *local_syms, *isym;
      Elf64_External_Sym *ext_syms, *esym;
      Elf_External_Sym_Shndx *shndx_buf, *shndx;
d633 2
a634 19
      /* Allocate memory for the internal and external symbols.  */
      amt = symtab_hdr->sh_info;
      amt *= sizeof (Elf_Internal_Sym);
      local_syms = (Elf_Internal_Sym *) bfd_malloc (amt);
      if (local_syms == NULL)
	return false;

      amt = symtab_hdr->sh_info;
      amt *= sizeof (Elf64_External_Sym);
      ext_syms = (Elf64_External_Sym *) bfd_malloc (amt);
      if (ext_syms == NULL)
	{
	  free (local_syms);
	  return false;
	}

      /* Read in the local symbols.  */
      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (ext_syms, amt, abfd) != amt)
d636 7
a642 27
	  free (ext_syms);
	  free (local_syms);
	  return false;
	}

      shndx_buf = NULL;
      shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;
      if (shndx_hdr->sh_size != 0)
	{
	  amt = symtab_hdr->sh_info;
	  amt *= sizeof (Elf_External_Sym_Shndx);
	  shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	  if (shndx_buf == NULL)
	    {
	      free (ext_syms);
	      free (local_syms);
	      return false;
	    }

	  if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	      || bfd_bread (shndx_buf, amt, abfd) != amt)
	    {
	      free (shndx_buf);
	      free (ext_syms);
	      free (local_syms);
	      return false;
	    }
d645 1
a645 2
      /* Swap in the local symbols, also record the highest section index
	 referenced by the local symbols.  */
d647 2
a648 3
      for (i = 0, isym = local_syms, esym = ext_syms, shndx = shndx_buf;
	   i < symtab_hdr->sh_info;
	   i++, esym++, isym++, shndx = (shndx != NULL ? shndx + 1 : NULL))
a649 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    isym);
a653 4
      /* Now we can free the external symbols.  */
      free (shndx_buf);
      free (ext_syms);

d663 1
a663 1
      for (isym = local_syms, i = 0; i < symtab_hdr->sh_info; i++, isym++)
d669 12
a680 2
      /* We are finished with the local symbols.  Get rid of them.  */
      free (local_syms);
@


1.24
log
@	* elf64-hppa.c (elf64_hppa_mark_milli_and_exported_functions): New
	function.
	(allocate_global_data_dlt):  Don't add millicode symbols to dynamic
	symbol table.
	(allocate_global_data_opd, allocate_dynrel_entries): Likewise.
	(elf64_hppa_size_dynamic_sections): Revise to use
	elf64_hppa_mark_milli_and_exported_functions.
	(elf64_hppa_finish_dynamic_symbol): Remove code to keep millicode
	symbols out of dynamic symbol table.
@
text
@d216 3
d2476 21
d2580 1
a2580 1
	      if (! s)
d2582 2
d2809 1
@


1.23
log
@
	* elf-hppa.h (elf_hppa_final_link): Fix formatting in comment.
	Skip excluded sections in determing __gp value.
	(elf_hppa_final_link_relocate): Use the symbol's address in
	R_PARISC_FPTR64 relocations that don't need an opd entry.
	* elf64-hppa.c (allocate_dynrel_entries): Simplify code.
	(elf64_hppa_finalize_dynreloc): Likewise.
	(elf64_hppa_size_dynamic_sections): Move comments and fix typo.
	(elf64_hppa_finish_dynamic_symbol): Break up assert.
@
text
@d198 3
d650 2
a651 2
          || bfd_bread (ext_syms, amt, abfd) != amt)
        {
d655 1
a655 1
        }
d1079 1
a1079 1
	      || (h && h->dynindx == -1))
d1174 1
a1174 1
	       || h->dynindx == -1
d1548 2
a1549 1
      if (dyn_h->h == 0 || dyn_h->h->dynindx == -1)
d1617 30
d1668 13
a1724 9
  /* Mark each function this program exports so that we will allocate
     space in the .opd section for each function's FPTR.

     We have to traverse the main linker hash table since we have to
     find functions which may not have been mentioned in any relocs.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf64_hppa_mark_exported_functions,
			  info);

a2138 5

  /* Millicode symbols should not be put in the dynamic
     symbol table under any circumstances.  */
  if (ELF_ST_TYPE (sym->st_info) == STT_PARISC_MILLI)
    h->dynindx = -1;
@


1.22
log
@
	* elf64-hppa.c (allocate_global_data_opd): We don't need an opd entry
	for a symbol that has no output section.
	(allocate_dynrel_entries): Correct comment.
	(elf64_hppa_finalize_dynreloc): Likewise.  Don't create an opd entry
	unless we want one.
	(elf64_hppa_finalize_opd): Prevent segfault if dyn_h is NULL.
	(elf64_hppa_finalize_dlt): Likewise.  Prevent segfault for symbols
	with no section.  Remove unnecessary parentheses.
@
text
@d1535 5
a1539 9
      switch (rent->type)
	{
	case R_PARISC_FPTR64:
	  /* Allocate one iff we are building a shared library and don't
	     want an opd entry.  */
	  if (!x->info->shared && dyn_h->want_opd)
	    continue;
	  break;
	}
d1721 1
a1723 2
	      /* Strip this section if we don't need it; see the
		 comment below.  */
d1734 1
a1736 2
	      /* Strip this section if we don't need it; see the
		 comment below.  */
d1742 1
a1744 2
	      /* Strip this section if we don't need it; see the
		 comment below.  */
d1748 1
a1748 1
      else if (strncmp (name, ".rela", 4) == 0)
d1750 7
a1953 3
  BFD_ASSERT (stub != NULL && splt != NULL
	      && sopd != NULL && sdlt != NULL)

d1963 2
d1986 2
d2038 2
d2363 4
a2366 9
	  switch (rent->type)
	    {
	      case R_PARISC_FPTR64:
	      /* Allocate one iff we are building a shared library and don't
		 want an opd entry.  */
	      if (!info->shared && dyn_h->want_opd)
		continue;
	      break;
	    }
@


1.21
log
@elf_swap_symbol_in args should be "const PTR", not "const PTR *".
@
text
@d1162 2
a1163 1
      if (h && h->root.type == bfd_link_hash_undefined)
d1172 2
a1173 3
	       || ((h->root.type == bfd_link_hash_defined
		    || h->root.type == bfd_link_hash_defweak)
		   && h->root.u.def.section->output_section != NULL))
d1538 2
a1539 3
	  /* Allocate one iff we are not building a shared library and
	     !want_opd, which by this point will be true only if we're
	     actually allocating one statically in the main executable.  */
d2117 1
a2117 1
  struct elf_link_hash_entry *h = dyn_h->h;
d2125 1
a2125 1
  if (h && dyn_h && dyn_h->want_opd)
d2238 1
a2238 1
  struct elf_link_hash_entry *h = dyn_h->h;
d2249 1
a2249 1
  if (! info->shared && h && dyn_h && dyn_h->want_dlt)
d2265 1
a2265 1
      else
d2267 1
a2267 3
	  value = (h->root.u.def.value
		   + h->root.u.def.section->output_offset);

d2273 3
d2363 2
a2364 3
	      /* Allocate one iff we are not building a shared library and
		 !want_opd, which by this point will be true only if we're
		 actually allocating one statically in the main executable.  */
d2397 1
a2397 1
	  if (info->shared && rent->type == R_PARISC_FPTR64)
@


1.20
log
@	* elf-bfd.h (struct elf_size_info): Add swap_symbol_in field.
	(bfd_elf32_swap_symbol_in): Update prototype.
	(bfd_elf64_swap_symbol_in): Likewise.
	* elfcode.h (elf_swap_symbol_in): Change input args to const PTR *.
	(elf_slurp_symbol_table): Adjust call to elf_swap_symbol_in.
	* elflink.h (elf_link_is_defined_archive_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_input_bfd): Likewise.
	(elf_gc_mark): Likewise.
	(elf_reloc_symbol_deleted_p): Likewise.
	* elf-m10200.c (mn10200_elf_relax_section): Likewise.
	(mn10200_elf_relax_delete_bytes): Likewise.
	(mn10200_elf_symbol_address_p): Likewise.
	(mn10200_elf_get_relocated_section_contents): Likewise.
	* elf-m10300.c (mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(mn10300_elf_relax_delete_bytes): Likewise.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): Likewise.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (get_local_syms): Likewise.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Likewise.
	* elf32-mips.c (bfd_mips_elf32_create_embedded_relocs): Likewise.
	* elf32-sh.c (sh_elf_relax_section): Likewise.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elf64-ppc.c (get_local_syms): Likewise.
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfcode.h (NAME(_bfd_elf,size_info)): Update initialiser.
	* elf64-alpha.c (alpha_elf_size_info): Likewise.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d685 2
a686 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR *) esym,
				    (const PTR *) shndx, isym);
@


1.19
log
@	* elf.c (bfd_section_from_shdr): Make "name" const.
	* elf-bfd.h (elf_backend_section_from_shdr): Likewise.
	* elf32-i370.c (i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-ppc.c (ppc64_elf_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d685 2
a686 1
	  bfd_elf64_swap_symbol_in (abfd, esym, shndx, isym);
d2677 1
@


1.18
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d187 1
a187 1
  PARAMS ((bfd *, Elf64_Internal_Shdr *, char *));
d406 1
a406 1
     char *name;
@


1.18.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d187 1
a187 1
  PARAMS ((bfd *, Elf64_Internal_Shdr *, const char *));
d406 1
a406 1
     const char *name;
d685 1
a685 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    isym);
d1161 1
a1161 2
      if (h && (h->root.type == bfd_link_hash_undefined
		|| h->root.u.def.section->output_section == NULL))
d1170 3
a1172 2
	       || (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak))
d1534 10
a1543 5
      /* Allocate one iff we are building a shared library, the relocation
	 isn't a R_PARISC_FPTR64, or we don't want an opd entry.  */
      if (!shared && rent->type == R_PARISC_FPTR64 && dyn_h->want_opd)
	continue;

a1724 1
	  /* Strip this section if we don't need it; see the comment below.  */
d1727 2
a1738 1
	  /* Strip this section if we don't need it; see the comment below.  */
d1741 2
a1747 1
	  /* Strip this section if we don't need it; see the comment below.  */
d1750 2
d1755 1
a1755 1
      else if (strncmp (name, ".rela", 5) == 0)
a1756 7
	  /* If we don't need this section, strip it from the output file.
	     This is mostly to handle .rela.bss and .rela.plt.  We must
	     create both sections in create_dynamic_sections, because they
	     must be created before the linker maps input sections to output
	     sections.  The linker does that before adjust_dynamic_symbol
	     is called, and it is that function which decides whether
	     anything needs to go into these sections.  */
d1954 3
a1965 2
      BFD_ASSERT (sopd != NULL)

a1986 2
      BFD_ASSERT (splt != NULL && spltrel != NULL)

a2036 2
      BFD_ASSERT (stub != NULL)

d2117 1
a2117 1
  struct elf_link_hash_entry *h = dyn_h ? dyn_h->h : NULL;
d2125 1
a2125 1
  if (h && dyn_h->want_opd)
d2238 1
a2238 1
  struct elf_link_hash_entry *h = dyn_h ? dyn_h->h : NULL;
d2249 1
a2249 1
  if (! info->shared && h && dyn_h->want_dlt)
d2265 1
a2265 1
      else if (h->root.u.def.section)
d2267 3
a2269 1
	  value = h->root.u.def.value + h->root.u.def.section->output_offset;
a2274 3
      else
	/* We have an undefined function reference.  */
	value = 0;
d2359 10
a2368 4
	  /* Allocate one iff we are building a shared library, the relocation
	     isn't a R_PARISC_FPTR64, or we don't want an opd entry.  */
	  if (!info->shared && rent->type == R_PARISC_FPTR64 && dyn_h->want_opd)
	    continue;
d2397 1
a2397 1
	  if (info->shared && rent->type == R_PARISC_FPTR64 && dyn_h->want_opd)
a2675 1
  bfd_elf64_swap_symbol_in,
@


1.18.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a197 3
static boolean elf64_hppa_mark_milli_and_exported_functions
  PARAMS ((struct elf_link_hash_entry *, PTR));

a212 3
static enum elf_reloc_type_class elf64_hppa_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));

d588 1
d610 1
a610 1
     for this BFD.  */
d616 3
a618 2
      Elf_Internal_Sym *local_syms = NULL;
      Elf_Internal_Sym *isym, *isymend;
d629 11
a639 2
      /* Read this BFD's local symbols.  */
      if (symtab_hdr->sh_info != 0)
d641 35
a675 7
	  local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (local_syms == NULL)
	    local_syms = bfd_elf_get_elf_syms (abfd, symtab_hdr,
					       symtab_hdr->sh_info, 0,
					       NULL, NULL, NULL);
	  if (local_syms == NULL)
	    return false;
d678 2
a679 1
      /* Record the highest section index referenced by the local symbols.  */
d681 3
a683 2
      isymend = local_syms + symtab_hdr->sh_info;
      for (isym = local_syms; isym < isymend; isym++)
d685 2
d691 4
d704 1
a704 1
      for (i = 0, isym = local_syms; isym < isymend; i++, isym++)
d710 2
a711 12
      /* We are finished with the local symbols.  */
      if (local_syms != NULL
	  && symtab_hdr->contents != (unsigned char *) local_syms)
	{
	  if (! info->keep_memory)
	    free (local_syms);
	  else
	    {
	      /* Cache the symbols for elf_link_input_bfd.  */
	      symtab_hdr->contents = (unsigned char *) local_syms;
	    }
	}
d1076 1
a1076 1
	      || (h->dynindx == -1 && h->type != STT_PARISC_MILLI))
d1171 1
a1171 1
	       || (h->dynindx == -1 && h->type != STT_PARISC_MILLI)
d1545 1
a1545 2
      if (dyn_h->h == 0
	  || (dyn_h->h->dynindx == -1 && dyn_h->h->type != STT_PARISC_MILLI))
a1612 30
/* This function is called via elf_link_hash_traverse to mark millicode
   symbols with a dynindx of -1 and to remove the string table reference
   from the dynamic symbol table.  If the symbol is not a millicode symbol,
   elf64_hppa_mark_exported_functions is called.  */

static boolean
elf64_hppa_mark_milli_and_exported_functions (h, data)
     struct elf_link_hash_entry *h;
     PTR data;
{
  struct bfd_link_info *info = (struct bfd_link_info *)data;
  struct elf_link_hash_entry *elf = h;

  if (elf->root.type == bfd_link_hash_warning)
    elf = (struct elf_link_hash_entry *) elf->root.u.i.link;

  if (elf->type == STT_PARISC_MILLI)
    {
      if (elf->dynindx != -1)
	{
	  elf->dynindx = -1;
	  _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				  elf->dynstr_index);
	}
      return true;
    }

  return elf64_hppa_mark_exported_functions (h, data);
}

a1633 13
  /* Mark each function this program exports so that we will allocate
     space in the .opd section for each function's FPTR.  If we are
     creating dynamic sections, change the dynamic index of millicode
     symbols to -1 and remove them from the string table for .dynstr.

     We have to traverse the main linker hash table since we have to
     find functions which may not have been mentioned in any relocs.  */
  elf_link_hash_traverse (elf_hash_table (info),
			  (elf_hash_table (info)->dynamic_sections_created
			   ? elf64_hppa_mark_milli_and_exported_functions
			   : elf64_hppa_mark_exported_functions),
			  info);

d1678 9
d2102 5
a2439 21
/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
elf64_hppa_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  if (ELF64_R_SYM (rela->r_info) == 0)
    return reloc_class_relative;

  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_PARISC_IPLT:
      return reloc_class_plt;
    case R_PARISC_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

d2523 1
a2523 1
	      if (! s || ! s->_raw_size)
a2524 2
	      if (! s || ! s->_raw_size)
		s = hppa_info->opd_rel_sec;
a2749 1
#define elf_backend_reloc_type_class	     elf64_hppa_reloc_type_class
@


1.18.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d2727 1
a2727 1
#define elf_backend_relocate_section	elf_hppa_relocate_section
a2772 1
#define elf_backend_rela_normal		     1
@


1.18.6.4
log
@merge from mainline
@
text
@a1857 5
      /* Force DT_FLAGS to always be set.
	 Required by HPUX 11.00 patch PHSS_26559.  */
      if (!add_dynamic_entry (DT_FLAGS, (info)->flags))
	return false;

@


1.18.4.1
log
@merge from trunk
@
text
@d187 1
a187 1
  PARAMS ((bfd *, Elf64_Internal_Shdr *, const char *));
d406 1
a406 1
     const char *name;
d685 1
a685 2
	  bfd_elf64_swap_symbol_in (abfd, (const PTR) esym, (const PTR) shndx,
				    isym);
d1161 1
a1161 2
      if (h && (h->root.type == bfd_link_hash_undefined
		|| h->root.u.def.section->output_section == NULL))
d1170 3
a1172 2
	       || (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak))
d1537 3
a1539 2
	  /* Allocate one iff we are building a shared library and don't
	     want an opd entry.  */
d2117 1
a2117 1
  struct elf_link_hash_entry *h = dyn_h ? dyn_h->h : NULL;
d2125 1
a2125 1
  if (h && dyn_h->want_opd)
d2238 1
a2238 1
  struct elf_link_hash_entry *h = dyn_h ? dyn_h->h : NULL;
d2249 1
a2249 1
  if (! info->shared && h && dyn_h->want_dlt)
d2265 1
a2265 1
      else if (h->root.u.def.section)
d2267 3
a2269 1
	  value = h->root.u.def.value + h->root.u.def.section->output_offset;
a2274 3
      else
	/* We have an undefined function reference.  */
	value = 0;
d2362 3
a2364 2
	      /* Allocate one iff we are building a shared library and don't
		 want an opd entry.  */
d2397 1
a2397 1
	  if (info->shared && rent->type == R_PARISC_FPTR64 && dyn_h->want_opd)
a2675 1
  bfd_elf64_swap_symbol_in,
@


1.18.4.2
log
@Merge with trunk.
@
text
@d1535 9
a1543 5
      /* Allocate one iff we are building a shared library, the relocation
	 isn't a R_PARISC_FPTR64, or we don't want an opd entry.  */
      if (!shared && rent->type == R_PARISC_FPTR64 && dyn_h->want_opd)
	continue;

a1724 1
	  /* Strip this section if we don't need it; see the comment below.  */
d1727 2
a1738 1
	  /* Strip this section if we don't need it; see the comment below.  */
d1741 2
a1747 1
	  /* Strip this section if we don't need it; see the comment below.  */
d1750 2
d1755 1
a1755 1
      else if (strncmp (name, ".rela", 5) == 0)
a1756 7
	  /* If we don't need this section, strip it from the output file.
	     This is mostly to handle .rela.bss and .rela.plt.  We must
	     create both sections in create_dynamic_sections, because they
	     must be created before the linker maps input sections to output
	     sections.  The linker does that before adjust_dynamic_symbol
	     is called, and it is that function which decides whether
	     anything needs to go into these sections.  */
d1954 3
a1965 2
      BFD_ASSERT (sopd != NULL)

a1986 2
      BFD_ASSERT (splt != NULL && spltrel != NULL)

a2036 2
      BFD_ASSERT (stub != NULL)

d2360 9
a2368 4
	  /* Allocate one iff we are building a shared library, the relocation
	     isn't a R_PARISC_FPTR64, or we don't want an opd entry.  */
	  if (!info->shared && rent->type == R_PARISC_FPTR64 && dyn_h->want_opd)
	    continue;
@


1.17
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d1025 3
@


1.17.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
a1024 3

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
@


1.16
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d588 1
d615 1
a615 1
      int highest_shndx;
d618 1
d649 1
a650 1
	  free (ext_syms);
d654 24
a679 2
      isym = local_syms;
      esym = ext_syms;
d681 3
a683 1
      for (i = 0; i < symtab_hdr->sh_info; i++, esym++, isym++)
d685 1
a685 1
	  bfd_elf64_swap_symbol_in (abfd, esym, isym);
d691 1
@


1.15
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d749 2
a750 1
      if (h && ((info->shared && ! info->symbolic)
d977 1
a977 1
  if ((info->shared && !info->symbolic)
@


1.14
log
@2001-08-10  Andreas Jaeger  <aj@@suse.de>

	* elf64-sparc.c: Add missing prototypes.
	* elf32-cris.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d65 1
a65 1
  unsigned long sym_indx;
d320 1
a320 1
  ret = bfd_zalloc (abfd, sizeof (*ret));
d560 1
a560 1
  bfd_alloc (abfd, sizeof (*rent));
d617 1
d628 3
a630 3
      local_syms
        = (Elf_Internal_Sym *) bfd_malloc (symtab_hdr->sh_info
                                           * sizeof (Elf_Internal_Sym));
d634 3
a636 3
      ext_syms
        = (Elf64_External_Sym *) bfd_malloc (symtab_hdr->sh_info
                                             * sizeof (Elf64_External_Sym));
d645 1
a645 4
          || bfd_read (ext_syms, 1,
                       (symtab_hdr->sh_info
                        * sizeof (Elf64_External_Sym)), abfd)
          != (symtab_hdr->sh_info * sizeof (Elf64_External_Sym)))
d670 3
a672 2
      hppa_info->section_syms = (int *) bfd_malloc (highest_shndx
						    * sizeof (int));
d1049 2
a1050 2
	      if (!_bfd_elf64_link_record_local_dynamic_symbol
		    (x->info, owner, dyn_h->sym_indx))
d1803 5
a1807 2
      if (! bfd_elf64_add_dynamic_entry (info, DT_HP_DLD_FLAGS, 0)
	  || ! bfd_elf64_add_dynamic_entry (info, DT_PLTGOT, 0))
d1817 3
a1819 3
	  if (! bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_HP_DLD_HOOK, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_HP_LOAD_MAP, 0))
d1825 3
a1827 3
	  if (! bfd_elf64_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_JMPREL, 0))
d1833 3
a1835 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_RELA, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_RELASZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_RELAENT,
						sizeof (Elf64_External_Rela)))
d1841 1
a1841 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_TEXTREL, 0))
d1846 1
d2031 1
a2031 1
	  insn |= re_assemble_16 (value);
d2037 1
a2037 1
	  insn |= re_assemble_14 (value);
d2048 1
a2048 1
      bfd_put_32 (stub->owner, insn,
d2057 1
a2057 1
	  insn |= re_assemble_16 (value);
d2062 1
a2062 1
	  insn |= re_assemble_14 (value);
d2064 1
a2064 1
      bfd_put_32 (stub->owner, insn,
d2576 2
a2577 1
	  m = (struct elf_segment_map *) bfd_zalloc (abfd, sizeof *m);
@


1.13
log
@2001-06-02  H.J. Lu  <hjl@@gnu.org>

	* elf32-hppa.c (elf32_hppa_object_p): Check ELFOSABI_LINUX
	and ELFOSABI_HPUX.
	* elf64-hppa.c (elf64_hppa_object_p): Likewise.
@
text
@d201 4
d209 4
d2669 1
a2669 1
#define elf_backend_fake_sections 	elf_hppa_fake_sections
@


1.12
log
@(elf64_hppa_object_p): Set architecture and machine from elf header flags.
@
text
@d361 2
a362 1
  unsigned int flags = elf_elfheader (abfd)->e_flags;
d364 13
@


1.11
log
@Write out millicode functions with the right elf symbol type.
@
text
@d361 15
a375 2
  /* Set the right machine number for an HPPA ELF file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 25);
@


1.10
log
@Linux target variants for elfxx-hppa.
@
text
@d261 3
d2575 13
d2681 1
@


1.10.2.1
log
@Write out millicode functions with the right elf symbol type.
@
text
@a260 3
static int elf64_hppa_elf_get_symbol_type
  PARAMS ((Elf_Internal_Sym *, int));

a2571 13
/* Called when writing out an object file to decide the type of a
   symbol.  */
static int
elf64_hppa_elf_get_symbol_type (elf_sym, type)
     Elf_Internal_Sym *elf_sym;
     int type;
{
  if (ELF_ST_TYPE (elf_sym->st_info) == STT_PARISC_MILLI)
    return STT_PARISC_MILLI;
  else
    return type;
}

a2664 1
#define elf_backend_get_symbol_type	     elf64_hppa_elf_get_symbol_type
@


1.10.2.2
log
@(elf64_hppa_object_p): Set architecture and machine from elf header flags.
@
text
@d361 2
a362 15
  unsigned int flags = elf_elfheader (abfd)->e_flags;

  switch (flags & (EF_PARISC_ARCH | EF_PARISC_WIDE))
    {
    case EFA_PARISC_1_0:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 10);
    case EFA_PARISC_1_1:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 11);
    case EFA_PARISC_2_0:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 20);
    case EFA_PARISC_2_0 | EF_PARISC_WIDE:
      return bfd_default_set_arch_mach (abfd, bfd_arch_hppa, 25);
    }
  /* Don't be fussy.  */
  return true;
@


1.10.2.3
log
@Merge from mainline.
@
text
@d361 1
a361 2
  Elf_Internal_Ehdr * i_ehdrp;
  unsigned int flags;
a362 13
  i_ehdrp = elf_elfheader (abfd);
  if (strcmp (bfd_get_target (abfd), "elf64-hppa-linux") == 0)
    {
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_LINUX)
	return false;
    }
  else
    {
      if (i_ehdrp->e_ident[EI_OSABI] != ELFOSABI_HPUX)
	return false;
    }

  flags = i_ehdrp->e_flags;
@


1.9
log
@Wide mode .plt offsets for elf64-hppa
@
text
@d1169 9
a1177 2
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_HPUX;
  i_ehdrp->e_ident[EI_ABIVERSION] = 1;
d2666 8
@


1.8
log
@2000-12-08  Kazu Hirata  <kazu@@hxi.com>

	* elf64-alpha.c: Fix formatting.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
@
text
@d1 2
a2 2
/* Generic support for 64-bit ELF
   Copyright 1999, 2000 Free Software Foundation, Inc.
d1957 1
d1979 23
a2001 5
      insn &= 0xffffc00e;
      insn |= ((value & 0x2000) >> 13);
      value &= 0x1ff8;
      value <<= 1;
      bfd_put_32 (stub->owner, (insn | value),
d2005 1
a2005 2
      value = dyn_h->plt_offset - hppa_info->gp_offset + 8;

d2007 11
a2017 5
      insn &= 0xffffc00e;
      insn |= ((value & 0x2000) >> 13);
      value &= 0x1ff8;
      value <<= 1;
      bfd_put_32 (stub->owner, (insn | value),
@


1.7
log
@Include alloca-conf.h
@
text
@d33 1
a33 1
 
d172 1
a172 1
	   boolean (*func)(struct elf64_hppa_dyn_hash_entry *, PTR),
a178 1

a182 1

d204 1
a204 1
	
d267 1
a267 1
  memset (ht, 0, sizeof(*ht));
d290 1
a290 1
  memset (ret, 0, sizeof(*ret));
a394 1

d396 1
a396 1
   name describes what was once potentially anonymous memory.  We 
d503 1
a503 1
/* Add a new entry to the list of dynamic relocations against DYN_H. 
d572 1
a572 1
 
d669 1
a669 1
 
d869 1
a869 1
	    
d1085 1
a1085 1
      
d1362 1
a1362 1
	FPTRS 
d1845 1
a1845 1
      sym->st_shndx = dyn_h->st_shndx; 
d1918 1
a1918 1
      /* Fill in the entry in the procedure linkage table. 
d1921 1
a1921 1
	 <funcaddr> <__gp>. 
d1924 1
a1924 1
	 install the PLT entry. 
d1967 1
a1967 1
	 so we do not need to include its output offset in this computation. 
d1976 1
a1976 1
      
d1987 1
a1987 1
      
d2027 1
a2027 1
      /* The first two words of an .opd entry are zero. 
d2080 1
a2080 1
	 function symbol. 
d2152 1
a2152 1
	 to point to the FPTR entry in the .opd section. 
a2196 1

d2268 1
a2268 1
	  /* Create a dynamic relocation for this entry. 
d2291 1
a2291 1
	
d2312 1
a2312 1
		
a2368 1

a2450 1

d2454 1
a2454 1
   dynamic linker requires PT_PHDRs for dynamic libraries too. 
d2481 1
a2481 1
   dynamic linker requires PT_PHDRs for dynamic libraries too. 
d2484 1
a2484 1
   for the HP linker. 
a2626 1

@


1.6
log
@A tiny addition for PCREL12F relocs, and a fix for functions that have
been forced local.
@
text
@d20 1
@


1.5
log
@Zero out the dynamic allocated content space.  Add a comment to remind us that
one day this ought to be fixed.
@
text
@d577 1
a577 1
      unsigned int i;
d751 1
d982 2
d1743 5
a1747 1
	 been allocated already.  */
a1749 5
	  /* FIXME: This should be a call to bfd_alloc not bfd_zalloc.
	     Unused entries should be reclaimed before the section's contents
	     are written out, but at the moment this does not happen.  Thus in
	     order to prevent writing out garbage, we initialise the section's
	     contents to zero.  */
d1836 8
a1843 3
  /* Function symbols for which we created .opd entries were munged
     by finish_dynamic_symbol and have to be un-munged here.  */
  if (dyn_h && dyn_h->want_opd)
@


1.4
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf32-arm.h (elf32_arm_size_dynamic_sections): Also set
	DF_TEXTREL if DT_TEXTREL is set.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Likewise.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.
	* elf32-mips.c (_bfd_mips_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Likewise.
	* elf64-ia64.c (elf64_ia64_size_dynamic_sections): Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.

	* bfd/elflink.h (NAME(bfd_elf,size_dynamic_sections)): Also
	set DF_SYMBOLIC for symbolic link. Also set DT_RUNPATH if
	DT_RPATH is set.
	Set the DT_FLAGS and DT_FLAGS_1 entries if necessary.
@
text
@d1743 6
a1748 1
	  s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
@


1.3
log
@Use section id in get_dyn_name.
@
text
@d1792 1
@


1.2
log
@Restore hppa-elf32 to working order.
@
text
@d175 2
a176 2
  PARAMS ((bfd *abfd, struct elf_link_hash_entry *h,
	   const Elf_Internal_Rela *rel, char **pbuf, size_t *plen));
d402 2
a403 2
get_dyn_name (abfd, h, rel, pbuf, plen)
     bfd *abfd;
d419 2
a420 5
    {
      nlen = sizeof(void*)*2 + 1 + sizeof(bfd_vma)*4 + 1 + 1;
      nlen += 10;	/* %p slop */
    }
  tlen = nlen + 1 + 16 + 1;
d437 1
d442 3
a444 1
      nlen = sprintf (buf, "%p:%lx", abfd, ELF64_R_SYM (rel->r_info));
d577 2
a578 1
      int i, highest_shndx;
d821 1
a821 1
      addr_name = get_dyn_name (abfd, h, rel, &buf, &buf_len);
d2515 1
a2515 1
        int i;
@


1.1
log
@        * elf64-hppa.c, elf64-hppa.h: New files with PA64 support.
@
text
@d58 1
a58 1
  /* The symbol table entry, if any, that this was derrived from.  */
d265 1
a265 1
     bfd *abfd;
a577 1
      asection *section;
d1179 1
a1179 1
     struct bfd_link_info *info;
d1217 1
a1217 1
     struct bfd_link_info *info;
d1255 1
a1255 1
     struct bfd_link_info *info;
d1293 1
a1293 1
     struct bfd_link_info *info;
d1512 1
a1512 1
     struct bfd_link_info *info;
a1552 1
  boolean stubs;
d1808 1
a1808 1
     bfd *abfd;
d1812 1
a1812 1
     asection *input_sec;
a2038 1
      bfd_vma value;
a2286 2
	      asymbol *sym;
	      int elf_index;
a2363 1
      struct elf_link_hash_entry *h;
d2485 1
a2485 1
  struct elf_segment_map *m, **pm;
@

