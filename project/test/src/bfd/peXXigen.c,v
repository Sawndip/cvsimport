head	1.73;
access;
symbols
	sid-snapshot-20180601:1.73
	sid-snapshot-20180501:1.73
	sid-snapshot-20180401:1.73
	sid-snapshot-20180301:1.73
	sid-snapshot-20180201:1.73
	sid-snapshot-20180101:1.73
	sid-snapshot-20171201:1.73
	sid-snapshot-20171101:1.73
	sid-snapshot-20171001:1.73
	sid-snapshot-20170901:1.73
	sid-snapshot-20170801:1.73
	sid-snapshot-20170701:1.73
	sid-snapshot-20170601:1.73
	sid-snapshot-20170501:1.73
	sid-snapshot-20170401:1.73
	sid-snapshot-20170301:1.73
	sid-snapshot-20170201:1.73
	sid-snapshot-20170101:1.73
	sid-snapshot-20161201:1.73
	sid-snapshot-20161101:1.73
	sid-snapshot-20160901:1.73
	sid-snapshot-20160801:1.73
	sid-snapshot-20160701:1.73
	sid-snapshot-20160601:1.73
	sid-snapshot-20160501:1.73
	sid-snapshot-20160401:1.73
	sid-snapshot-20160301:1.73
	sid-snapshot-20160201:1.73
	sid-snapshot-20160101:1.73
	sid-snapshot-20151201:1.73
	sid-snapshot-20151101:1.73
	sid-snapshot-20151001:1.73
	sid-snapshot-20150901:1.73
	sid-snapshot-20150801:1.73
	sid-snapshot-20150701:1.73
	sid-snapshot-20150601:1.73
	sid-snapshot-20150501:1.73
	sid-snapshot-20150401:1.73
	sid-snapshot-20150301:1.73
	sid-snapshot-20150201:1.73
	sid-snapshot-20150101:1.73
	sid-snapshot-20141201:1.73
	sid-snapshot-20141101:1.73
	sid-snapshot-20141001:1.73
	sid-snapshot-20140901:1.73
	sid-snapshot-20140801:1.73
	sid-snapshot-20140701:1.73
	sid-snapshot-20140601:1.73
	sid-snapshot-20140501:1.73
	sid-snapshot-20140401:1.73
	sid-snapshot-20140301:1.73
	sid-snapshot-20140201:1.73
	sid-snapshot-20140101:1.73
	sid-snapshot-20131201:1.73
	sid-snapshot-20131101:1.73
	sid-snapshot-20131001:1.73
	binutils-2_24-branch:1.73.0.2
	binutils-2_24-branchpoint:1.73
	binutils-2_21_1:1.67.2.1
	sid-snapshot-20130901:1.73
	gdb_7_6_1-2013-08-30-release:1.72
	sid-snapshot-20130801:1.73
	sid-snapshot-20130701:1.73
	sid-snapshot-20130601:1.73
	sid-snapshot-20130501:1.73
	gdb_7_6-2013-04-26-release:1.72
	sid-snapshot-20130401:1.73
	binutils-2_23_2:1.70
	gdb_7_6-branch:1.72.0.2
	gdb_7_6-2013-03-12-branchpoint:1.72
	sid-snapshot-20130301:1.72
	sid-snapshot-20130201:1.72
	sid-snapshot-20130101:1.71
	sid-snapshot-20121201:1.71
	gdb_7_5_1-2012-11-29-release:1.70
	binutils-2_23_1:1.70
	sid-snapshot-20121101:1.71
	binutils-2_23:1.70
	sid-snapshot-20121001:1.70
	sid-snapshot-20120901:1.70
	gdb_7_5-2012-08-17-release:1.70
	sid-snapshot-20120801:1.70
	binutils-2_23-branch:1.70.0.10
	binutils-2_23-branchpoint:1.70
	gdb_7_5-branch:1.70.0.8
	gdb_7_5-2012-07-18-branchpoint:1.70
	sid-snapshot-20120701:1.70
	sid-snapshot-20120601:1.70
	sid-snapshot-20120501:1.70
	binutils-2_22_branch:1.70.0.6
	gdb_7_4_1-2012-04-26-release:1.70
	sid-snapshot-20120401:1.70
	sid-snapshot-20120301:1.70
	sid-snapshot-20120201:1.70
	gdb_7_4-2012-01-24-release:1.70
	sid-snapshot-20120101:1.70
	gdb_7_4-branch:1.70.0.4
	gdb_7_4-2011-12-13-branchpoint:1.70
	sid-snapshot-20111201:1.70
	binutils-2_22:1.70
	sid-snapshot-20111101:1.70
	sid-snapshot-20111001:1.70
	binutils-2_22-branch:1.70.0.2
	binutils-2_22-branchpoint:1.70
	gdb_7_3_1-2011-09-04-release:1.69
	sid-snapshot-20110901:1.70
	sid-snapshot-20110801:1.70
	gdb_7_3-2011-07-26-release:1.69
	sid-snapshot-20110701:1.70
	sid-snapshot-20110601:1.70
	sid-snapshot-20110501:1.70
	gdb_7_3-branch:1.69.0.2
	gdb_7_3-2011-04-01-branchpoint:1.69
	sid-snapshot-20110401:1.69
	sid-snapshot-20110301:1.69
	sid-snapshot-20110201:1.69
	sid-snapshot-20110101:1.69
	binutils-2_21:1.67
	sid-snapshot-20101201:1.67
	binutils-2_21-branch:1.67.0.2
	binutils-2_21-branchpoint:1.67
	sid-snapshot-20101101:1.67
	sid-snapshot-20101001:1.67
	binutils-2_20_1:1.57.6.2
	gdb_7_2-2010-09-02-release:1.64
	sid-snapshot-20100901:1.64
	sid-snapshot-20100801:1.64
	gdb_7_2-branch:1.64.0.2
	gdb_7_2-2010-07-07-branchpoint:1.64
	sid-snapshot-20100701:1.64
	sid-snapshot-20100601:1.63
	sid-snapshot-20100501:1.63
	sid-snapshot-20100401:1.62
	gdb_7_1-2010-03-18-release:1.61
	sid-snapshot-20100301:1.61
	gdb_7_1-branch:1.61.0.2
	gdb_7_1-2010-02-18-branchpoint:1.61
	sid-snapshot-20100201:1.61
	sid-snapshot-20100101:1.61
	gdb_7_0_1-2009-12-22-release:1.59
	sid-snapshot-20091201:1.60
	sid-snapshot-20091101:1.60
	binutils-2_20:1.57.6.2
	gdb_7_0-2009-10-06-release:1.59
	sid-snapshot-20091001:1.59
	gdb_7_0-branch:1.59.0.2
	gdb_7_0-2009-09-16-branchpoint:1.59
	arc-sim-20090309:1.43
	binutils-arc-20081103-branch:1.46.0.12
	binutils-arc-20081103-branchpoint:1.46
	binutils-2_20-branch:1.57.0.6
	binutils-2_20-branchpoint:1.57
	sid-snapshot-20090901:1.57
	sid-snapshot-20090801:1.57
	msnyder-checkpoint-072509-branch:1.57.0.4
	msnyder-checkpoint-072509-branchpoint:1.57
	sid-snapshot-20090701:1.57
	dje-cgen-play1-branch:1.57.0.2
	dje-cgen-play1-branchpoint:1.57
	sid-snapshot-20090601:1.57
	sid-snapshot-20090501:1.56
	sid-snapshot-20090401:1.47
	arc-20081103-branch:1.46.0.10
	arc-20081103-branchpoint:1.46
	arc-insight_6_8-branch:1.43.0.10
	arc-insight_6_8-branchpoint:1.43
	insight_6_8-branch:1.43.0.8
	insight_6_8-branchpoint:1.43
	sid-snapshot-20090301:1.46
	binutils-2_19_1:1.46
	sid-snapshot-20090201:1.46
	sid-snapshot-20090101:1.46
	reverse-20081226-branch:1.46.0.8
	reverse-20081226-branchpoint:1.46
	sid-snapshot-20081201:1.46
	multiprocess-20081120-branch:1.46.0.6
	multiprocess-20081120-branchpoint:1.46
	sid-snapshot-20081101:1.46
	binutils-2_19:1.46
	sid-snapshot-20081001:1.46
	reverse-20080930-branch:1.46.0.4
	reverse-20080930-branchpoint:1.46
	binutils-2_19-branch:1.46.0.2
	binutils-2_19-branchpoint:1.46
	sid-snapshot-20080901:1.46
	sid-snapshot-20080801:1.46
	reverse-20080717-branch:1.43.0.6
	reverse-20080717-branchpoint:1.43
	sid-snapshot-20080701:1.43
	msnyder-reverse-20080609-branch:1.43.0.4
	msnyder-reverse-20080609-branchpoint:1.43
	drow-reverse-20070409-branch:1.40.0.2
	drow-reverse-20070409-branchpoint:1.40
	sid-snapshot-20080601:1.43
	sid-snapshot-20080501:1.43
	sid-snapshot-20080403:1.43
	sid-snapshot-20080401:1.43
	gdb_6_8-2008-03-27-release:1.43
	sid-snapshot-20080301:1.43
	gdb_6_8-branch:1.43.0.2
	gdb_6_8-2008-02-26-branchpoint:1.43
	sid-snapshot-20080201:1.43
	sid-snapshot-20080101:1.43
	sid-snapshot-20071201:1.43
	sid-snapshot-20071101:1.42
	gdb_6_7_1-2007-10-29-release:1.42
	gdb_6_7-2007-10-10-release:1.42
	sid-snapshot-20071001:1.42
	gdb_6_7-branch:1.42.0.4
	gdb_6_7-2007-09-07-branchpoint:1.42
	binutils-2_18:1.42
	binutils-2_18-branch:1.42.0.2
	binutils-2_18-branchpoint:1.42
	insight_6_6-20070208-release:1.38
	binutils-csl-coldfire-4_1-32:1.34
	binutils-csl-sourcerygxx-4_1-32:1.34
	gdb_6_6-2006-12-18-release:1.38
	binutils-csl-innovasic-fido-3_4_4-33:1.34
	binutils-csl-sourcerygxx-3_4_4-32:1.27
	binutils-csl-coldfire-4_1-30:1.34
	binutils-csl-sourcerygxx-4_1-30:1.34
	binutils-csl-coldfire-4_1-28:1.34
	binutils-csl-sourcerygxx-4_1-29:1.34
	binutils-csl-sourcerygxx-4_1-28:1.34
	gdb_6_6-branch:1.38.0.2
	gdb_6_6-2006-11-15-branchpoint:1.38
	binutils-csl-arm-2006q3-27:1.34
	binutils-csl-sourcerygxx-4_1-27:1.34
	binutils-csl-arm-2006q3-26:1.34
	binutils-csl-sourcerygxx-4_1-26:1.34
	binutils-csl-sourcerygxx-4_1-25:1.34
	binutils-csl-sourcerygxx-4_1-24:1.34
	binutils-csl-sourcerygxx-4_1-23:1.34
	insight_6_5-20061003-release:1.34
	gdb-csl-symbian-6_4_50_20060226-12:1.34
	binutils-csl-sourcerygxx-4_1-21:1.34
	binutils-csl-arm-2006q3-21:1.34
	binutils-csl-sourcerygxx-4_1-22:1.34
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.34
	binutils-csl-sourcerygxx-4_1-20:1.34
	binutils-csl-arm-2006q3-19:1.34
	binutils-csl-sourcerygxx-4_1-19:1.34
	binutils-csl-sourcerygxx-4_1-18:1.34
	binutils-csl-renesas-4_1-9:1.34
	gdb-csl-sourcerygxx-3_4_4-25:1.32
	binutils-csl-sourcerygxx-3_4_4-25:1.27
	nickrob-async-20060828-mergepoint:1.36
	gdb-csl-symbian-6_4_50_20060226-11:1.34
	binutils-csl-renesas-4_1-8:1.34
	binutils-csl-renesas-4_1-7:1.34
	binutils-csl-renesas-4_1-6:1.34
	gdb-csl-sourcerygxx-4_1-17:1.34
	binutils-csl-sourcerygxx-4_1-17:1.34
	gdb-csl-20060226-branch-local-2:1.34
	gdb-csl-sourcerygxx-4_1-14:1.34
	binutils-csl-sourcerygxx-4_1-14:1.34
	binutils-csl-sourcerygxx-4_1-15:1.34
	gdb-csl-sourcerygxx-4_1-13:1.34
	binutils-csl-sourcerygxx-4_1-13:1.34
	binutils-2_17:1.34
	gdb-csl-sourcerygxx-4_1-12:1.34
	binutils-csl-sourcerygxx-4_1-12:1.34
	gdb-csl-sourcerygxx-3_4_4-21:1.34
	binutils-csl-sourcerygxx-3_4_4-21:1.34
	gdb_6_5-20060621-release:1.34
	binutils-csl-wrs-linux-3_4_4-24:1.27
	binutils-csl-wrs-linux-3_4_4-23:1.27
	gdb-csl-sourcerygxx-4_1-9:1.34
	binutils-csl-sourcerygxx-4_1-9:1.34
	gdb-csl-sourcerygxx-4_1-8:1.34
	binutils-csl-sourcerygxx-4_1-8:1.34
	gdb-csl-sourcerygxx-4_1-7:1.34
	binutils-csl-sourcerygxx-4_1-7:1.34
	gdb-csl-arm-2006q1-6:1.34
	binutils-csl-arm-2006q1-6:1.34
	gdb-csl-sourcerygxx-4_1-6:1.34
	binutils-csl-sourcerygxx-4_1-6:1.34
	binutils-csl-wrs-linux-3_4_4-22:1.27
	gdb-csl-symbian-6_4_50_20060226-10:1.34
	gdb-csl-symbian-6_4_50_20060226-9:1.34
	gdb-csl-symbian-6_4_50_20060226-8:1.34
	gdb-csl-coldfire-4_1-11:1.34
	binutils-csl-coldfire-4_1-11:1.34
	gdb-csl-sourcerygxx-3_4_4-19:1.34
	binutils-csl-sourcerygxx-3_4_4-19:1.34
	gdb-csl-coldfire-4_1-10:1.34
	gdb_6_5-branch:1.34.0.20
	gdb_6_5-2006-05-14-branchpoint:1.34
	binutils-csl-coldfire-4_1-10:1.34
	gdb-csl-sourcerygxx-4_1-5:1.34
	binutils-csl-sourcerygxx-4_1-5:1.34
	nickrob-async-20060513-branch:1.34.0.18
	nickrob-async-20060513-branchpoint:1.34
	gdb-csl-sourcerygxx-4_1-4:1.34
	binutils-csl-sourcerygxx-4_1-4:1.34
	msnyder-reverse-20060502-branch:1.34.0.16
	msnyder-reverse-20060502-branchpoint:1.34
	binutils-csl-wrs-linux-3_4_4-21:1.27
	gdb-csl-morpho-4_1-4:1.34
	binutils-csl-morpho-4_1-4:1.34
	gdb-csl-sourcerygxx-3_4_4-17:1.34
	binutils-csl-sourcerygxx-3_4_4-17:1.34
	binutils-csl-wrs-linux-3_4_4-20:1.27
	readline_5_1-import-branch:1.34.0.14
	readline_5_1-import-branchpoint:1.34
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.34
	binutils-2_17-branch:1.34.0.12
	binutils-2_17-branchpoint:1.34
	gdb-csl-symbian-20060226-branch:1.34.0.10
	gdb-csl-symbian-20060226-branchpoint:1.34
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.34
	msnyder-reverse-20060331-branch:1.34.0.8
	msnyder-reverse-20060331-branchpoint:1.34
	binutils-csl-2_17-branch:1.34.0.6
	binutils-csl-2_17-branchpoint:1.34
	gdb-csl-available-20060303-branch:1.34.0.4
	gdb-csl-available-20060303-branchpoint:1.34
	gdb-csl-20060226-branch:1.34.0.2
	gdb-csl-20060226-branchpoint:1.34
	gdb_6_4-20051202-release:1.32
	msnyder-fork-checkpoint-branch:1.32.0.8
	msnyder-fork-checkpoint-branchpoint:1.32
	gdb-csl-gxxpro-6_3-branch:1.32.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.32
	gdb_6_4-branch:1.32.0.4
	gdb_6_4-2005-11-01-branchpoint:1.32
	gdb-csl-arm-20051020-branch:1.32.0.2
	gdb-csl-arm-20051020-branchpoint:1.32
	binutils-csl-gxxpro-3_4-branch:1.27.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.27
	binutils-2_16_1:1.27
	msnyder-tracepoint-checkpoint-branch:1.30.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.30
	gdb-csl-arm-20050325-2005-q1b:1.27
	binutils-csl-arm-2005q1b:1.27
	binutils-2_16:1.27
	gdb-csl-arm-20050325-2005-q1a:1.27
	binutils-csl-arm-2005q1a:1.27
	csl-arm-20050325-branch:1.27.0.6
	csl-arm-20050325-branchpoint:1.27
	binutils-csl-arm-2005q1-branch:1.27.0.4
	binutils-csl-arm-2005q1-branchpoint:1.27
	binutils-2_16-branch:1.27.0.2
	binutils-2_16-branchpoint:1.27
	csl-arm-2004-q3d:1.25
	gdb_6_3-20041109-release:1.25
	gdb_6_3-branch:1.25.0.4
	gdb_6_3-20041019-branchpoint:1.25
	csl-arm-2004-q3:1.25
	drow_intercu-merge-20040921:1.25
	drow_intercu-merge-20040915:1.25
	jimb-gdb_6_2-e500-branch:1.25.0.6
	jimb-gdb_6_2-e500-branchpoint:1.25
	gdb_6_2-20040730-release:1.25
	gdb_6_2-branch:1.25.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.25
	gdb_6_1_1-20040616-release:1.22
	binutils-2_15:1.21.6.1
	binutils-2_15-branchpoint:1.21
	csl-arm-2004-q1a:1.23
	csl-arm-2004-q1:1.22
	gdb_6_1-2004-04-05-release:1.22
	drow_intercu-merge-20040402:1.22
	drow_intercu-merge-20040327:1.22
	ezannoni_pie-20040323-branch:1.22.0.8
	ezannoni_pie-20040323-branchpoint:1.22
	cagney_tramp-20040321-mergepoint:1.22
	cagney_tramp-20040309-branch:1.22.0.6
	cagney_tramp-20040309-branchpoint:1.22
	gdb_6_1-branch:1.22.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.22
	drow_intercu-20040221-branch:1.22.0.2
	drow_intercu-20040221-branchpoint:1.22
	binutils-2_15-branch:1.21.0.6
	cagney_bfdfile-20040213-branch:1.21.0.4
	cagney_bfdfile-20040213-branchpoint:1.21
	drow-cplus-merge-20040208:1.21
	carlton_dictionary-20040126-merge:1.21
	cagney_bigcore-20040122-branch:1.21.0.2
	cagney_bigcore-20040122-branchpoint:1.21
	drow-cplus-merge-20040113:1.20
	csl-arm-2003-q4:1.20
	drow-cplus-merge-20031224:1.20
	drow-cplus-merge-20031220:1.20
	carlton_dictionary-20031215-merge:1.20
	drow-cplus-merge-20031214:1.19
	carlton-dictionary-20031111-merge:1.18
	gdb_6_0-2003-10-04-release:1.14
	kettenis_sparc-20030918-branch:1.15.0.6
	kettenis_sparc-20030918-branchpoint:1.15
	carlton_dictionary-20030917-merge:1.15
	ezannoni_pie-20030916-branchpoint:1.15
	ezannoni_pie-20030916-branch:1.15.0.4
	cagney_x86i386-20030821-branch:1.15.0.2
	cagney_x86i386-20030821-branchpoint:1.15
	carlton_dictionary-20030805-merge:1.15
	carlton_dictionary-20030627-merge:1.15
	gdb_6_0-branch:1.14.0.22
	gdb_6_0-2003-06-23-branchpoint:1.14
	jimb-ppc64-linux-20030613-branch:1.14.0.20
	jimb-ppc64-linux-20030613-branchpoint:1.14
	binutils-2_14:1.14
	cagney_convert-20030606-branch:1.14.0.18
	cagney_convert-20030606-branchpoint:1.14
	cagney_writestrings-20030508-branch:1.14.0.16
	cagney_writestrings-20030508-branchpoint:1.14
	jimb-ppc64-linux-20030528-branch:1.14.0.14
	jimb-ppc64-linux-20030528-branchpoint:1.14
	carlton_dictionary-20030523-merge:1.14
	cagney_fileio-20030521-branch:1.14.0.12
	cagney_fileio-20030521-branchpoint:1.14
	kettenis_i386newframe-20030517-mergepoint:1.14
	jimb-ppc64-linux-20030509-branch:1.14.0.10
	jimb-ppc64-linux-20030509-branchpoint:1.14
	kettenis_i386newframe-20030504-mergepoint:1.14
	carlton_dictionary-20030430-merge:1.14
	binutils-2_14-branch:1.14.0.8
	binutils-2_14-branchpoint:1.14
	kettenis_i386newframe-20030419-branch:1.14.0.6
	kettenis_i386newframe-20030419-branchpoint:1.14
	carlton_dictionary-20030416-merge:1.14
	cagney_frameaddr-20030409-mergepoint:1.14
	kettenis_i386newframe-20030406-branch:1.14.0.4
	kettenis_i386newframe-20030406-branchpoint:1.14
	cagney_frameaddr-20030403-branchpoint:1.14
	cagney_frameaddr-20030403-branch:1.14.0.2
	cagney_framebase-20030330-mergepoint:1.13
	cagney_framebase-20030326-branch:1.13.0.2
	cagney_framebase-20030326-branchpoint:1.13
	cagney_lazyid-20030317-branch:1.12.0.12
	cagney_lazyid-20030317-branchpoint:1.12
	kettenis-i386newframe-20030316-mergepoint:1.12
	offbyone-20030313-branch:1.12.0.10
	offbyone-20030313-branchpoint:1.12
	kettenis-i386newframe-20030308-branch:1.12.0.8
	kettenis-i386newframe-20030308-branchpoint:1.12
	carlton_dictionary-20030305-merge:1.12
	cagney_offbyone-20030303-branch:1.12.0.6
	cagney_offbyone-20030303-branchpoint:1.12
	carlton_dictionary-20030207-merge:1.12
	interps-20030202-branch:1.12.0.4
	interps-20030202-branchpoint:1.12
	cagney-unwind-20030108-branch:1.12.0.2
	cagney-unwind-20030108-branchpoint:1.12
	binutils-2_13_2_1:1.10.2.1
	binutils-2_13_2:1.10.2.1
	carlton_dictionary-20021223-merge:1.12
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.11
	binutils-2_13_1:1.10.2.1
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.12
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.10
	carlton_dictionary-20020920-branchpoint:1.11
	sid-20020905-branchpoint:1.11
	sid-20020905-branch:1.11.0.8
	gdb_5_3-branch:1.11.0.6
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.4
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.2
	readline_4_3-import-branchpoint:1.11
	binutils-2_13:1.10.2.1
	gdb_5_2_1-2002-07-23-release:1.6
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	kseitz_interps-20020528-branch:1.7.0.2
	kseitz_interps-20020528-branchpoint:1.7
	cagney_regbuf-20020515-branch:1.6.0.8
	cagney_regbuf-20020515-branchpoint:1.6
	binutils-2_12_1:1.6
	jimb-macro-020506-branch:1.6.0.6
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	binutils-2_12:1.6
	gdb_5_2-branch:1.6.0.4
	gdb_5_2-2002-03-03-branchpoint:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.6
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.4
	gdb_5_1-2001-07-29-branchpoint:1.2
	binutils-2_11_2:1.2.2.1
	binutils-2_11_1:1.2.2.1
	binutils-2_11-branch:1.2.0.2
	x86_64versiong3:1.1
	binutils_latest_snapshot:1.73;
locks; strict;
comment	@ * @;


1.73
date	2013.03.21.14.07.08;	author ktietz;	state Exp;
branches;
next	1.72;

1.72
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.71;

1.71
date	2012.10.18.17.42.29;	author ktietz;	state Exp;
branches;
next	1.70;

1.70
date	2011.04.09.16.06.00;	author ktietz;	state Exp;
branches;
next	1.69;

1.69
date	2010.12.21.15.24.38;	author ktietz;	state Exp;
branches;
next	1.68;

1.68
date	2010.12.21.08.41.16;	author muller;	state Exp;
branches;
next	1.67;

1.67
date	2010.09.22.08.01.56;	author ktietz;	state Exp;
branches
	1.67.2.1;
next	1.66;

1.66
date	2010.09.14.20.25.34;	author ktietz;	state Exp;
branches;
next	1.65;

1.65
date	2010.09.06.23.55.10;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2010.04.09.14.40.16;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2010.03.18.12.27.15;	author hjl;	state Exp;
branches;
next	1.61;

1.61
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.27.10.53.28;	author ktietz;	state Exp;
branches;
next	1.59;

1.59
date	2009.09.09.21.38.58;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2009.09.05.07.56.22;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2009.05.21.12.52.37;	author davek;	state Exp;
branches
	1.57.6.1;
next	1.56;

1.56
date	2009.04.27.13.59.40;	author hjl;	state Exp;
branches;
next	1.55;

1.55
date	2009.04.23.13.36.42;	author davek;	state Exp;
branches;
next	1.54;

1.54
date	2009.04.21.17.08.20;	author hjl;	state Exp;
branches;
next	1.53;

1.53
date	2009.04.21.02.13.47;	author davek;	state Exp;
branches;
next	1.52;

1.52
date	2009.04.20.01.09.43;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2009.04.17.15.03.48;	author hjl;	state Exp;
branches;
next	1.50;

1.50
date	2009.04.17.13.46.16;	author hjl;	state Exp;
branches;
next	1.49;

1.49
date	2009.04.06.16.48.36;	author hjl;	state Exp;
branches;
next	1.48;

1.48
date	2009.04.05.18.12.21;	author ktietz;	state Exp;
branches;
next	1.47;

1.47
date	2009.03.05.01.04.56;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2008.07.21.14.09.57;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.18.11.30.22;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2007.11.13.20.17.43;	author hjl;	state Exp;
branches;
next	1.42;

1.42
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.22.15.52.29;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.19.23.06.06;	author hjl;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.14.19.03.32;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2006.09.20.11.35.07;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2006.07.24.16.51.26;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.09.15.58.42;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.09.12.55.01;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2005.07.29.14.07.01;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.17.13.39.56;	author jakub;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.04.15.53.37;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.04.07.19.34;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.21.07.45.38;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.03.11.41.00;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.31.23.13.29;	author bje;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.24.04.46.25;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2004.05.07.15.08.49;	author ford;	state Exp;
branches;
next	1.23;

1.23
date	2004.04.17.11.18.47;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2004.02.21.06.16.02;	author dannysmith;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2004.01.20.21.04.19;	author dannysmith;	state Exp;
branches
	1.21.6.1;
next	1.20;

1.20
date	2003.12.15.11.50.11;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.10.17.04.54;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.17.03.30.27;	author cgf;	state Exp;
branches;
next	1.16;

1.16
date	2003.10.07.08.49.11;	author nathan;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.25.06.40.23;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.03.11.13.26;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.20.09.02.09;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.16.13.35.58;	author amodra;	state Exp;
branches
	1.11.10.1
	1.11.12.1;
next	1.10;

1.10
date	2002.06.06.10.45.14;	author amodra;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2002.05.30.11.06.10;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.29.20.06.28;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.15.15.28.12;	author nickc;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2002.01.30.16.07.28;	author nickc;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2001.10.25.06.33.56;	author rth;	state Exp;
branches;
next	1.4;

1.4
date	2001.09.18.09.57.25;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.14.10.01.29;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2001.02.13.19.23.08;	author dj;	state Exp;
branches;
next	;

1.67.2.1
date	2011.05.29.04.51.18;	author amodra;	state Exp;
branches;
next	;

1.57.6.1
date	2009.09.05.08.00.19;	author nickc;	state Exp;
branches;
next	1.57.6.2;

1.57.6.2
date	2009.09.09.21.40.20;	author nickc;	state Exp;
branches;
next	;

1.22.2.1
date	2004.09.16.17.00.36;	author drow;	state Exp;
branches;
next	;

1.21.6.1
date	2004.04.09.18.28.03;	author drow;	state Exp;
branches;
next	;

1.11.10.1
date	2002.12.23.19.37.57;	author carlton;	state Exp;
branches;
next	1.11.10.2;

1.11.10.2
date	2003.04.16.19.56.46;	author carlton;	state Exp;
branches;
next	1.11.10.3;

1.11.10.3
date	2003.06.27.21.49.29;	author carlton;	state Exp;
branches;
next	1.11.10.4;

1.11.10.4
date	2003.11.11.23.50.28;	author carlton;	state Exp;
branches;
next	1.11.10.5;

1.11.10.5
date	2003.12.15.23.59.51;	author carlton;	state Exp;
branches;
next	1.11.10.6;

1.11.10.6
date	2004.01.26.19.11.10;	author carlton;	state Exp;
branches;
next	;

1.11.12.1
date	2003.12.14.20.26.50;	author drow;	state Exp;
branches;
next	1.11.12.2;

1.11.12.2
date	2003.12.20.18.16.47;	author drow;	state Exp;
branches;
next	1.11.12.3;

1.11.12.3
date	2004.02.09.19.43.25;	author drow;	state Exp;
branches;
next	;

1.10.2.1
date	2002.07.16.13.38.36;	author amodra;	state Exp;
branches;
next	;

1.7.2.1
date	2002.06.20.01.31.08;	author kseitz;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2002.07.22.21.46.49;	author kseitz;	state Exp;
branches;
next	;

1.6.8.1
date	2002.06.15.16.42.40;	author cagney;	state Exp;
branches;
next	;

1.2.2.1
date	2001.06.11.10.04.19;	author amodra;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.10.25.06.33.31;	author rth;	state Exp;
branches;
next	;


desc
@@


1.73
log
@	* coffgen.c (coff_real_object_p): Make global.
	* peicode.h (coff_real_object_p): Add prototype.
	(FILHDR): Defined for COFF_IMAGE_WITH_PE as
	external_PEI_IMAGE_hdr structure.
	(coff_swap_filehdr_in): Handle variable header-size.
	* peXXigen.c (_bfd_XXi_swap_aouthdr_in): Just handle amount
	of directory-entiries as specified in pe-header.
@
text
@/* Support for the generic parts of PE/PEI; the common executable parts.
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010  Free Software Foundation, Inc.
   Written by Cygnus Solutions.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* Most of this hacked by Steve Chamberlain <sac@@cygnus.com>.

   PE/PEI rearrangement (and code added): Donn Terry
					  Softway Systems, Inc.  */

/* Hey look, some documentation [and in a place you expect to find it]!

   The main reference for the pei format is "Microsoft Portable Executable
   and Common Object File Format Specification 4.1".  Get it if you need to
   do some serious hacking on this code.

   Another reference:
   "Peering Inside the PE: A Tour of the Win32 Portable Executable
   File Format", MSJ 1994, Volume 9.

   The *sole* difference between the pe format and the pei format is that the
   latter has an MSDOS 2.0 .exe header on the front that prints the message
   "This app must be run under Windows." (or some such).
   (FIXME: Whether that statement is *really* true or not is unknown.
   Are there more subtle differences between pe and pei formats?
   For now assume there aren't.  If you find one, then for God sakes
   document it here!)

   The Microsoft docs use the word "image" instead of "executable" because
   the former can also refer to a DLL (shared library).  Confusion can arise
   because the `i' in `pei' also refers to "image".  The `pe' format can
   also create images (i.e. executables), it's just that to run on a win32
   system you need to use the pei format.

   FIXME: Please add more docs here so the next poor fool that has to hack
   on this code has a chance of getting something accomplished without
   wasting too much time.  */

/* This expands into COFF_WITH_pe, COFF_WITH_pep, or COFF_WITH_pex64
   depending on whether we're compiling for straight PE or PE+.  */
#define COFF_WITH_XX

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "bfdver.h"

/* NOTE: it's strange to be including an architecture specific header
   in what's supposed to be general (to PE/PEI) code.  However, that's
   where the definitions are, and they don't vary per architecture
   within PE/PEI, so we get them from there.  FIXME: The lack of
   variance is an assumption which may prove to be incorrect if new
   PE/PEI targets are created.  */
#if defined COFF_WITH_pex64
# include "coff/x86_64.h"
#elif defined COFF_WITH_pep
# include "coff/ia64.h"
#else
# include "coff/i386.h"
#endif

#include "coff/pe.h"
#include "libcoff.h"
#include "libpei.h"

#if defined COFF_WITH_pep || defined COFF_WITH_pex64
# undef AOUTSZ
# define AOUTSZ		PEPAOUTSZ
# define PEAOUTHDR	PEPAOUTHDR
#endif

/* FIXME: This file has various tests of POWERPC_LE_PE.  Those tests
   worked when the code was in peicode.h, but no longer work now that
   the code is in peigen.c.  PowerPC NT is said to be dead.  If
   anybody wants to revive the code, you will have to figure out how
   to handle those issues.  */

void
_bfd_XXi_swap_sym_in (bfd * abfd, void * ext1, void * in1)
{
  SYMENT *ext = (SYMENT *) ext1;
  struct internal_syment *in = (struct internal_syment *) in1;

  if (ext->e.e_name[0] == 0)
    {
      in->_n._n_n._n_zeroes = 0;
      in->_n._n_n._n_offset = H_GET_32 (abfd, ext->e.e.e_offset);
    }
  else
    memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN);

  in->n_value = H_GET_32 (abfd, ext->e_value);
  in->n_scnum = H_GET_16 (abfd, ext->e_scnum);

  if (sizeof (ext->e_type) == 2)
    in->n_type = H_GET_16 (abfd, ext->e_type);
  else
    in->n_type = H_GET_32 (abfd, ext->e_type);

  in->n_sclass = H_GET_8 (abfd, ext->e_sclass);
  in->n_numaux = H_GET_8 (abfd, ext->e_numaux);

#ifndef STRICT_PE_FORMAT
  /* This is for Gnu-created DLLs.  */

  /* The section symbols for the .idata$ sections have class 0x68
     (C_SECTION), which MS documentation indicates is a section
     symbol.  Unfortunately, the value field in the symbol is simply a
     copy of the .idata section's flags rather than something useful.
     When these symbols are encountered, change the value to 0 so that
     they will be handled somewhat correctly in the bfd code.  */
  if (in->n_sclass == C_SECTION)
    {
      char namebuf[SYMNMLEN + 1];
      const char *name = NULL;

      in->n_value = 0x0;

      /* Create synthetic empty sections as needed.  DJ */
      if (in->n_scnum == 0)
	{
	  asection *sec;

	  name = _bfd_coff_internal_syment_name (abfd, in, namebuf);
	  if (name == NULL)
	    /* FIXME: Return error.  */
	    abort ();
	  sec = bfd_get_section_by_name (abfd, name);
	  if (sec != NULL)
	    in->n_scnum = sec->target_index;
	}

      if (in->n_scnum == 0)
	{
	  int unused_section_number = 0;
	  asection *sec;
	  flagword flags;

	  for (sec = abfd->sections; sec; sec = sec->next)
	    if (unused_section_number <= sec->target_index)
	      unused_section_number = sec->target_index + 1;

	  if (name == namebuf)
	    {
	      name = (const char *) bfd_alloc (abfd, strlen (namebuf) + 1);
	      if (name == NULL)
		/* FIXME: Return error.  */
		abort ();
	      strcpy ((char *) name, namebuf);
	    }
	  flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_DATA | SEC_LOAD;
	  sec = bfd_make_section_anyway_with_flags (abfd, name, flags);
	  if (sec == NULL)
	    /* FIXME: Return error.  */
	    abort ();

	  sec->vma = 0;
	  sec->lma = 0;
	  sec->size = 0;
	  sec->filepos = 0;
	  sec->rel_filepos = 0;
	  sec->reloc_count = 0;
	  sec->line_filepos = 0;
	  sec->lineno_count = 0;
	  sec->userdata = NULL;
	  sec->next = NULL;
	  sec->alignment_power = 2;

	  sec->target_index = unused_section_number;

	  in->n_scnum = unused_section_number;
	}
      in->n_sclass = C_STAT;
    }
#endif

#ifdef coff_swap_sym_in_hook
  /* This won't work in peigen.c, but since it's for PPC PE, it's not
     worth fixing.  */
  coff_swap_sym_in_hook (abfd, ext1, in1);
#endif
}

unsigned int
_bfd_XXi_swap_sym_out (bfd * abfd, void * inp, void * extp)
{
  struct internal_syment *in = (struct internal_syment *) inp;
  SYMENT *ext = (SYMENT *) extp;

  if (in->_n._n_name[0] == 0)
    {
      H_PUT_32 (abfd, 0, ext->e.e.e_zeroes);
      H_PUT_32 (abfd, in->_n._n_n._n_offset, ext->e.e.e_offset);
    }
  else
    memcpy (ext->e.e_name, in->_n._n_name, SYMNMLEN);

  H_PUT_32 (abfd, in->n_value, ext->e_value);
  H_PUT_16 (abfd, in->n_scnum, ext->e_scnum);

  if (sizeof (ext->e_type) == 2)
    H_PUT_16 (abfd, in->n_type, ext->e_type);
  else
    H_PUT_32 (abfd, in->n_type, ext->e_type);

  H_PUT_8 (abfd, in->n_sclass, ext->e_sclass);
  H_PUT_8 (abfd, in->n_numaux, ext->e_numaux);

  return SYMESZ;
}

void
_bfd_XXi_swap_aux_in (bfd *	abfd,
		      void *	ext1,
		      int       type,
		      int       in_class,
		      int	indx ATTRIBUTE_UNUSED,
		      int	numaux ATTRIBUTE_UNUSED,
		      void * 	in1)
{
  AUXENT *ext = (AUXENT *) ext1;
  union internal_auxent *in = (union internal_auxent *) in1;

  switch (in_class)
    {
    case C_FILE:
      if (ext->x_file.x_fname[0] == 0)
	{
	  in->x_file.x_n.x_zeroes = 0;
	  in->x_file.x_n.x_offset = H_GET_32 (abfd, ext->x_file.x_n.x_offset);
	}
      else
	memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
      return;

    case C_STAT:
    case C_LEAFSTAT:
    case C_HIDDEN:
      if (type == T_NULL)
	{
	  in->x_scn.x_scnlen = GET_SCN_SCNLEN (abfd, ext);
	  in->x_scn.x_nreloc = GET_SCN_NRELOC (abfd, ext);
	  in->x_scn.x_nlinno = GET_SCN_NLINNO (abfd, ext);
	  in->x_scn.x_checksum = H_GET_32 (abfd, ext->x_scn.x_checksum);
	  in->x_scn.x_associated = H_GET_16 (abfd, ext->x_scn.x_associated);
	  in->x_scn.x_comdat = H_GET_8 (abfd, ext->x_scn.x_comdat);
	  return;
	}
      break;
    }

  in->x_sym.x_tagndx.l = H_GET_32 (abfd, ext->x_sym.x_tagndx);
  in->x_sym.x_tvndx = H_GET_16 (abfd, ext->x_sym.x_tvndx);

  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
      || ISTAG (in_class))
    {
      in->x_sym.x_fcnary.x_fcn.x_lnnoptr = GET_FCN_LNNOPTR (abfd, ext);
      in->x_sym.x_fcnary.x_fcn.x_endndx.l = GET_FCN_ENDNDX (abfd, ext);
    }
  else
    {
      in->x_sym.x_fcnary.x_ary.x_dimen[0] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      in->x_sym.x_fcnary.x_ary.x_dimen[1] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      in->x_sym.x_fcnary.x_ary.x_dimen[2] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      in->x_sym.x_fcnary.x_ary.x_dimen[3] =
	H_GET_16 (abfd, ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }

  if (ISFCN (type))
    {
      in->x_sym.x_misc.x_fsize = H_GET_32 (abfd, ext->x_sym.x_misc.x_fsize);
    }
  else
    {
      in->x_sym.x_misc.x_lnsz.x_lnno = GET_LNSZ_LNNO (abfd, ext);
      in->x_sym.x_misc.x_lnsz.x_size = GET_LNSZ_SIZE (abfd, ext);
    }
}

unsigned int
_bfd_XXi_swap_aux_out (bfd *  abfd,
		       void * inp,
		       int    type,
		       int    in_class,
		       int    indx ATTRIBUTE_UNUSED,
		       int    numaux ATTRIBUTE_UNUSED,
		       void * extp)
{
  union internal_auxent *in = (union internal_auxent *) inp;
  AUXENT *ext = (AUXENT *) extp;

  memset (ext, 0, AUXESZ);

  switch (in_class)
    {
    case C_FILE:
      if (in->x_file.x_fname[0] == 0)
	{
	  H_PUT_32 (abfd, 0, ext->x_file.x_n.x_zeroes);
	  H_PUT_32 (abfd, in->x_file.x_n.x_offset, ext->x_file.x_n.x_offset);
	}
      else
	memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);

      return AUXESZ;

    case C_STAT:
    case C_LEAFSTAT:
    case C_HIDDEN:
      if (type == T_NULL)
	{
	  PUT_SCN_SCNLEN (abfd, in->x_scn.x_scnlen, ext);
	  PUT_SCN_NRELOC (abfd, in->x_scn.x_nreloc, ext);
	  PUT_SCN_NLINNO (abfd, in->x_scn.x_nlinno, ext);
	  H_PUT_32 (abfd, in->x_scn.x_checksum, ext->x_scn.x_checksum);
	  H_PUT_16 (abfd, in->x_scn.x_associated, ext->x_scn.x_associated);
	  H_PUT_8 (abfd, in->x_scn.x_comdat, ext->x_scn.x_comdat);
	  return AUXESZ;
	}
      break;
    }

  H_PUT_32 (abfd, in->x_sym.x_tagndx.l, ext->x_sym.x_tagndx);
  H_PUT_16 (abfd, in->x_sym.x_tvndx, ext->x_sym.x_tvndx);

  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
      || ISTAG (in_class))
    {
      PUT_FCN_LNNOPTR (abfd, in->x_sym.x_fcnary.x_fcn.x_lnnoptr,  ext);
      PUT_FCN_ENDNDX  (abfd, in->x_sym.x_fcnary.x_fcn.x_endndx.l, ext);
    }
  else
    {
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      H_PUT_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
    }

  if (ISFCN (type))
    H_PUT_32 (abfd, in->x_sym.x_misc.x_fsize, ext->x_sym.x_misc.x_fsize);
  else
    {
      PUT_LNSZ_LNNO (abfd, in->x_sym.x_misc.x_lnsz.x_lnno, ext);
      PUT_LNSZ_SIZE (abfd, in->x_sym.x_misc.x_lnsz.x_size, ext);
    }

  return AUXESZ;
}

void
_bfd_XXi_swap_lineno_in (bfd * abfd, void * ext1, void * in1)
{
  LINENO *ext = (LINENO *) ext1;
  struct internal_lineno *in = (struct internal_lineno *) in1;

  in->l_addr.l_symndx = H_GET_32 (abfd, ext->l_addr.l_symndx);
  in->l_lnno = GET_LINENO_LNNO (abfd, ext);
}

unsigned int
_bfd_XXi_swap_lineno_out (bfd * abfd, void * inp, void * outp)
{
  struct internal_lineno *in = (struct internal_lineno *) inp;
  struct external_lineno *ext = (struct external_lineno *) outp;
  H_PUT_32 (abfd, in->l_addr.l_symndx, ext->l_addr.l_symndx);

  PUT_LINENO_LNNO (abfd, in->l_lnno, ext);
  return LINESZ;
}

void
_bfd_XXi_swap_aouthdr_in (bfd * abfd,
			  void * aouthdr_ext1,
			  void * aouthdr_int1)
{
  PEAOUTHDR * src = (PEAOUTHDR *) aouthdr_ext1;
  AOUTHDR * aouthdr_ext = (AOUTHDR *) aouthdr_ext1;
  struct internal_aouthdr *aouthdr_int
    = (struct internal_aouthdr *) aouthdr_int1;
  struct internal_extra_pe_aouthdr *a = &aouthdr_int->pe;

  aouthdr_int->magic = H_GET_16 (abfd, aouthdr_ext->magic);
  aouthdr_int->vstamp = H_GET_16 (abfd, aouthdr_ext->vstamp);
  aouthdr_int->tsize = GET_AOUTHDR_TSIZE (abfd, aouthdr_ext->tsize);
  aouthdr_int->dsize = GET_AOUTHDR_DSIZE (abfd, aouthdr_ext->dsize);
  aouthdr_int->bsize = GET_AOUTHDR_BSIZE (abfd, aouthdr_ext->bsize);
  aouthdr_int->entry = GET_AOUTHDR_ENTRY (abfd, aouthdr_ext->entry);
  aouthdr_int->text_start =
    GET_AOUTHDR_TEXT_START (abfd, aouthdr_ext->text_start);
#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
  /* PE32+ does not have data_start member!  */
  aouthdr_int->data_start =
    GET_AOUTHDR_DATA_START (abfd, aouthdr_ext->data_start);
  a->BaseOfData = aouthdr_int->data_start;
#endif

  a->Magic = aouthdr_int->magic;
  a->MajorLinkerVersion = H_GET_8 (abfd, aouthdr_ext->vstamp);
  a->MinorLinkerVersion = H_GET_8 (abfd, aouthdr_ext->vstamp + 1);
  a->SizeOfCode = aouthdr_int->tsize ;
  a->SizeOfInitializedData = aouthdr_int->dsize ;
  a->SizeOfUninitializedData = aouthdr_int->bsize ;
  a->AddressOfEntryPoint = aouthdr_int->entry;
  a->BaseOfCode = aouthdr_int->text_start;
  a->ImageBase = GET_OPTHDR_IMAGE_BASE (abfd, src->ImageBase);
  a->SectionAlignment = H_GET_32 (abfd, src->SectionAlignment);
  a->FileAlignment = H_GET_32 (abfd, src->FileAlignment);
  a->MajorOperatingSystemVersion =
    H_GET_16 (abfd, src->MajorOperatingSystemVersion);
  a->MinorOperatingSystemVersion =
    H_GET_16 (abfd, src->MinorOperatingSystemVersion);
  a->MajorImageVersion = H_GET_16 (abfd, src->MajorImageVersion);
  a->MinorImageVersion = H_GET_16 (abfd, src->MinorImageVersion);
  a->MajorSubsystemVersion = H_GET_16 (abfd, src->MajorSubsystemVersion);
  a->MinorSubsystemVersion = H_GET_16 (abfd, src->MinorSubsystemVersion);
  a->Reserved1 = H_GET_32 (abfd, src->Reserved1);
  a->SizeOfImage = H_GET_32 (abfd, src->SizeOfImage);
  a->SizeOfHeaders = H_GET_32 (abfd, src->SizeOfHeaders);
  a->CheckSum = H_GET_32 (abfd, src->CheckSum);
  a->Subsystem = H_GET_16 (abfd, src->Subsystem);
  a->DllCharacteristics = H_GET_16 (abfd, src->DllCharacteristics);
  a->SizeOfStackReserve =
    GET_OPTHDR_SIZE_OF_STACK_RESERVE (abfd, src->SizeOfStackReserve);
  a->SizeOfStackCommit =
    GET_OPTHDR_SIZE_OF_STACK_COMMIT (abfd, src->SizeOfStackCommit);
  a->SizeOfHeapReserve =
    GET_OPTHDR_SIZE_OF_HEAP_RESERVE (abfd, src->SizeOfHeapReserve);
  a->SizeOfHeapCommit =
    GET_OPTHDR_SIZE_OF_HEAP_COMMIT (abfd, src->SizeOfHeapCommit);
  a->LoaderFlags = H_GET_32 (abfd, src->LoaderFlags);
  a->NumberOfRvaAndSizes = H_GET_32 (abfd, src->NumberOfRvaAndSizes);

  {
    int idx;

    for (idx = 0; idx < a->NumberOfRvaAndSizes; idx++)
      {
        /* If data directory is empty, rva also should be 0.  */
	int size =
	  H_GET_32 (abfd, src->DataDirectory[idx][1]);

	a->DataDirectory[idx].Size = size;

	if (size)
	  a->DataDirectory[idx].VirtualAddress =
	    H_GET_32 (abfd, src->DataDirectory[idx][0]);
	else
	  a->DataDirectory[idx].VirtualAddress = 0;
      }
  }

  if (aouthdr_int->entry)
    {
      aouthdr_int->entry += a->ImageBase;
#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
      aouthdr_int->entry &= 0xffffffff;
#endif
    }

  if (aouthdr_int->tsize)
    {
      aouthdr_int->text_start += a->ImageBase;
#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
      aouthdr_int->text_start &= 0xffffffff;
#endif
    }

#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
  /* PE32+ does not have data_start member!  */
  if (aouthdr_int->dsize)
    {
      aouthdr_int->data_start += a->ImageBase;
      aouthdr_int->data_start &= 0xffffffff;
    }
#endif

#ifdef POWERPC_LE_PE
  /* These three fields are normally set up by ppc_relocate_section.
     In the case of reading a file in, we can pick them up from the
     DataDirectory.  */
  first_thunk_address = a->DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress;
  thunk_size = a->DataDirectory[PE_IMPORT_ADDRESS_TABLE].Size;
  import_table_size = a->DataDirectory[PE_IMPORT_TABLE].Size;
#endif
}

/* A support function for below.  */

static void
add_data_entry (bfd * abfd,
		struct internal_extra_pe_aouthdr *aout,
		int idx,
		char *name,
		bfd_vma base)
{
  asection *sec = bfd_get_section_by_name (abfd, name);

  /* Add import directory information if it exists.  */
  if ((sec != NULL)
      && (coff_section_data (abfd, sec) != NULL)
      && (pei_section_data (abfd, sec) != NULL))
    {
      /* If data directory is empty, rva also should be 0.  */
      int size = pei_section_data (abfd, sec)->virt_size;
      aout->DataDirectory[idx].Size = size;

      if (size)
	{
	  aout->DataDirectory[idx].VirtualAddress =
	    (sec->vma - base) & 0xffffffff;
	  sec->flags |= SEC_DATA;
	}
    }
}

unsigned int
_bfd_XXi_swap_aouthdr_out (bfd * abfd, void * in, void * out)
{
  struct internal_aouthdr *aouthdr_in = (struct internal_aouthdr *) in;
  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;
  PEAOUTHDR *aouthdr_out = (PEAOUTHDR *) out;
  bfd_vma sa, fa, ib;
  IMAGE_DATA_DIRECTORY idata2, idata5, tls;

  sa = extra->SectionAlignment;
  fa = extra->FileAlignment;
  ib = extra->ImageBase;

  idata2 = pe->pe_opthdr.DataDirectory[PE_IMPORT_TABLE];
  idata5 = pe->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE];
  tls = pe->pe_opthdr.DataDirectory[PE_TLS_TABLE];

  if (aouthdr_in->tsize)
    {
      aouthdr_in->text_start -= ib;
#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
      aouthdr_in->text_start &= 0xffffffff;
#endif
    }

  if (aouthdr_in->dsize)
    {
      aouthdr_in->data_start -= ib;
#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
      aouthdr_in->data_start &= 0xffffffff;
#endif
    }

  if (aouthdr_in->entry)
    {
      aouthdr_in->entry -= ib;
#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
      aouthdr_in->entry &= 0xffffffff;
#endif
    }

#define FA(x) (((x) + fa -1 ) & (- fa))
#define SA(x) (((x) + sa -1 ) & (- sa))

  /* We like to have the sizes aligned.  */
  aouthdr_in->bsize = FA (aouthdr_in->bsize);

  extra->NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;

  add_data_entry (abfd, extra, 0, ".edata", ib);
  add_data_entry (abfd, extra, 2, ".rsrc", ib);
  add_data_entry (abfd, extra, 3, ".pdata", ib);

  /* In theory we do not need to call add_data_entry for .idata$2 or
     .idata$5.  It will be done in bfd_coff_final_link where all the
     required information is available.  If however, we are not going
     to perform a final link, eg because we have been invoked by objcopy
     or strip, then we need to make sure that these Data Directory
     entries are initialised properly.

     So - we copy the input values into the output values, and then, if
     a final link is going to be performed, it can overwrite them.  */
  extra->DataDirectory[PE_IMPORT_TABLE]  = idata2;
  extra->DataDirectory[PE_IMPORT_ADDRESS_TABLE] = idata5;
  extra->DataDirectory[PE_TLS_TABLE] = tls;

  if (extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress == 0)
    /* Until other .idata fixes are made (pending patch), the entry for
       .idata is needed for backwards compatibility.  FIXME.  */
    add_data_entry (abfd, extra, 1, ".idata", ib);

  /* For some reason, the virtual size (which is what's set by
     add_data_entry) for .reloc is not the same as the size recorded
     in this slot by MSVC; it doesn't seem to cause problems (so far),
     but since it's the best we've got, use it.  It does do the right
     thing for .pdata.  */
  if (pe->has_reloc_section)
    add_data_entry (abfd, extra, 5, ".reloc", ib);

  {
    asection *sec;
    bfd_vma hsize = 0;
    bfd_vma dsize = 0;
    bfd_vma isize = 0;
    bfd_vma tsize = 0;

    for (sec = abfd->sections; sec; sec = sec->next)
      {
	int rounded = FA (sec->size);

	/* The first non-zero section filepos is the header size.
	   Sections without contents will have a filepos of 0.  */
	if (hsize == 0)
	  hsize = sec->filepos;
	if (sec->flags & SEC_DATA)
	  dsize += rounded;
	if (sec->flags & SEC_CODE)
	  tsize += rounded;
	/* The image size is the total VIRTUAL size (which is what is
	   in the virt_size field).  Files have been seen (from MSVC
	   5.0 link.exe) where the file size of the .data segment is
	   quite small compared to the virtual size.  Without this
	   fix, strip munges the file.

	   FIXME: We need to handle holes between sections, which may
	   happpen when we covert from another format.  We just use
	   the virtual address and virtual size of the last section
	   for the image size.  */
	if (coff_section_data (abfd, sec) != NULL
	    && pei_section_data (abfd, sec) != NULL)
	  isize = (sec->vma - extra->ImageBase
		   + SA (FA (pei_section_data (abfd, sec)->virt_size)));
      }

    aouthdr_in->dsize = dsize;
    aouthdr_in->tsize = tsize;
    extra->SizeOfHeaders = hsize;
    extra->SizeOfImage = isize;
  }

  H_PUT_16 (abfd, aouthdr_in->magic, aouthdr_out->standard.magic);

/* e.g. 219510000 is linker version 2.19  */
#define LINKER_VERSION ((short) (BFD_VERSION / 1000000))

  /* This piece of magic sets the "linker version" field to
     LINKER_VERSION.  */
  H_PUT_16 (abfd, (LINKER_VERSION / 100 + (LINKER_VERSION % 100) * 256),
	    aouthdr_out->standard.vstamp);

  PUT_AOUTHDR_TSIZE (abfd, aouthdr_in->tsize, aouthdr_out->standard.tsize);
  PUT_AOUTHDR_DSIZE (abfd, aouthdr_in->dsize, aouthdr_out->standard.dsize);
  PUT_AOUTHDR_BSIZE (abfd, aouthdr_in->bsize, aouthdr_out->standard.bsize);
  PUT_AOUTHDR_ENTRY (abfd, aouthdr_in->entry, aouthdr_out->standard.entry);
  PUT_AOUTHDR_TEXT_START (abfd, aouthdr_in->text_start,
			  aouthdr_out->standard.text_start);

#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
  /* PE32+ does not have data_start member!  */
  PUT_AOUTHDR_DATA_START (abfd, aouthdr_in->data_start,
			  aouthdr_out->standard.data_start);
#endif

  PUT_OPTHDR_IMAGE_BASE (abfd, extra->ImageBase, aouthdr_out->ImageBase);
  H_PUT_32 (abfd, extra->SectionAlignment, aouthdr_out->SectionAlignment);
  H_PUT_32 (abfd, extra->FileAlignment, aouthdr_out->FileAlignment);
  H_PUT_16 (abfd, extra->MajorOperatingSystemVersion,
	    aouthdr_out->MajorOperatingSystemVersion);
  H_PUT_16 (abfd, extra->MinorOperatingSystemVersion,
	    aouthdr_out->MinorOperatingSystemVersion);
  H_PUT_16 (abfd, extra->MajorImageVersion, aouthdr_out->MajorImageVersion);
  H_PUT_16 (abfd, extra->MinorImageVersion, aouthdr_out->MinorImageVersion);
  H_PUT_16 (abfd, extra->MajorSubsystemVersion,
	    aouthdr_out->MajorSubsystemVersion);
  H_PUT_16 (abfd, extra->MinorSubsystemVersion,
	    aouthdr_out->MinorSubsystemVersion);
  H_PUT_32 (abfd, extra->Reserved1, aouthdr_out->Reserved1);
  H_PUT_32 (abfd, extra->SizeOfImage, aouthdr_out->SizeOfImage);
  H_PUT_32 (abfd, extra->SizeOfHeaders, aouthdr_out->SizeOfHeaders);
  H_PUT_32 (abfd, extra->CheckSum, aouthdr_out->CheckSum);
  H_PUT_16 (abfd, extra->Subsystem, aouthdr_out->Subsystem);
  H_PUT_16 (abfd, extra->DllCharacteristics, aouthdr_out->DllCharacteristics);
  PUT_OPTHDR_SIZE_OF_STACK_RESERVE (abfd, extra->SizeOfStackReserve,
				    aouthdr_out->SizeOfStackReserve);
  PUT_OPTHDR_SIZE_OF_STACK_COMMIT (abfd, extra->SizeOfStackCommit,
				   aouthdr_out->SizeOfStackCommit);
  PUT_OPTHDR_SIZE_OF_HEAP_RESERVE (abfd, extra->SizeOfHeapReserve,
				   aouthdr_out->SizeOfHeapReserve);
  PUT_OPTHDR_SIZE_OF_HEAP_COMMIT (abfd, extra->SizeOfHeapCommit,
				  aouthdr_out->SizeOfHeapCommit);
  H_PUT_32 (abfd, extra->LoaderFlags, aouthdr_out->LoaderFlags);
  H_PUT_32 (abfd, extra->NumberOfRvaAndSizes,
	    aouthdr_out->NumberOfRvaAndSizes);
  {
    int idx;

    for (idx = 0; idx < 16; idx++)
      {
	H_PUT_32 (abfd, extra->DataDirectory[idx].VirtualAddress,
		  aouthdr_out->DataDirectory[idx][0]);
	H_PUT_32 (abfd, extra->DataDirectory[idx].Size,
		  aouthdr_out->DataDirectory[idx][1]);
      }
  }

  return AOUTSZ;
}

unsigned int
_bfd_XXi_only_swap_filehdr_out (bfd * abfd, void * in, void * out)
{
  int idx;
  struct internal_filehdr *filehdr_in = (struct internal_filehdr *) in;
  struct external_PEI_filehdr *filehdr_out = (struct external_PEI_filehdr *) out;

  if (pe_data (abfd)->has_reloc_section
      || pe_data (abfd)->dont_strip_reloc)
    filehdr_in->f_flags &= ~F_RELFLG;

  if (pe_data (abfd)->dll)
    filehdr_in->f_flags |= F_DLL;

  filehdr_in->pe.e_magic    = DOSMAGIC;
  filehdr_in->pe.e_cblp     = 0x90;
  filehdr_in->pe.e_cp       = 0x3;
  filehdr_in->pe.e_crlc     = 0x0;
  filehdr_in->pe.e_cparhdr  = 0x4;
  filehdr_in->pe.e_minalloc = 0x0;
  filehdr_in->pe.e_maxalloc = 0xffff;
  filehdr_in->pe.e_ss       = 0x0;
  filehdr_in->pe.e_sp       = 0xb8;
  filehdr_in->pe.e_csum     = 0x0;
  filehdr_in->pe.e_ip       = 0x0;
  filehdr_in->pe.e_cs       = 0x0;
  filehdr_in->pe.e_lfarlc   = 0x40;
  filehdr_in->pe.e_ovno     = 0x0;

  for (idx = 0; idx < 4; idx++)
    filehdr_in->pe.e_res[idx] = 0x0;

  filehdr_in->pe.e_oemid   = 0x0;
  filehdr_in->pe.e_oeminfo = 0x0;

  for (idx = 0; idx < 10; idx++)
    filehdr_in->pe.e_res2[idx] = 0x0;

  filehdr_in->pe.e_lfanew = 0x80;

  /* This next collection of data are mostly just characters.  It
     appears to be constant within the headers put on NT exes.  */
  filehdr_in->pe.dos_message[0]  = 0x0eba1f0e;
  filehdr_in->pe.dos_message[1]  = 0xcd09b400;
  filehdr_in->pe.dos_message[2]  = 0x4c01b821;
  filehdr_in->pe.dos_message[3]  = 0x685421cd;
  filehdr_in->pe.dos_message[4]  = 0x70207369;
  filehdr_in->pe.dos_message[5]  = 0x72676f72;
  filehdr_in->pe.dos_message[6]  = 0x63206d61;
  filehdr_in->pe.dos_message[7]  = 0x6f6e6e61;
  filehdr_in->pe.dos_message[8]  = 0x65622074;
  filehdr_in->pe.dos_message[9]  = 0x6e757220;
  filehdr_in->pe.dos_message[10] = 0x206e6920;
  filehdr_in->pe.dos_message[11] = 0x20534f44;
  filehdr_in->pe.dos_message[12] = 0x65646f6d;
  filehdr_in->pe.dos_message[13] = 0x0a0d0d2e;
  filehdr_in->pe.dos_message[14] = 0x24;
  filehdr_in->pe.dos_message[15] = 0x0;
  filehdr_in->pe.nt_signature = NT_SIGNATURE;

  H_PUT_16 (abfd, filehdr_in->f_magic, filehdr_out->f_magic);
  H_PUT_16 (abfd, filehdr_in->f_nscns, filehdr_out->f_nscns);

  H_PUT_32 (abfd, time (0), filehdr_out->f_timdat);
  PUT_FILEHDR_SYMPTR (abfd, filehdr_in->f_symptr,
		      filehdr_out->f_symptr);
  H_PUT_32 (abfd, filehdr_in->f_nsyms, filehdr_out->f_nsyms);
  H_PUT_16 (abfd, filehdr_in->f_opthdr, filehdr_out->f_opthdr);
  H_PUT_16 (abfd, filehdr_in->f_flags, filehdr_out->f_flags);

  /* Put in extra dos header stuff.  This data remains essentially
     constant, it just has to be tacked on to the beginning of all exes
     for NT.  */
  H_PUT_16 (abfd, filehdr_in->pe.e_magic, filehdr_out->e_magic);
  H_PUT_16 (abfd, filehdr_in->pe.e_cblp, filehdr_out->e_cblp);
  H_PUT_16 (abfd, filehdr_in->pe.e_cp, filehdr_out->e_cp);
  H_PUT_16 (abfd, filehdr_in->pe.e_crlc, filehdr_out->e_crlc);
  H_PUT_16 (abfd, filehdr_in->pe.e_cparhdr, filehdr_out->e_cparhdr);
  H_PUT_16 (abfd, filehdr_in->pe.e_minalloc, filehdr_out->e_minalloc);
  H_PUT_16 (abfd, filehdr_in->pe.e_maxalloc, filehdr_out->e_maxalloc);
  H_PUT_16 (abfd, filehdr_in->pe.e_ss, filehdr_out->e_ss);
  H_PUT_16 (abfd, filehdr_in->pe.e_sp, filehdr_out->e_sp);
  H_PUT_16 (abfd, filehdr_in->pe.e_csum, filehdr_out->e_csum);
  H_PUT_16 (abfd, filehdr_in->pe.e_ip, filehdr_out->e_ip);
  H_PUT_16 (abfd, filehdr_in->pe.e_cs, filehdr_out->e_cs);
  H_PUT_16 (abfd, filehdr_in->pe.e_lfarlc, filehdr_out->e_lfarlc);
  H_PUT_16 (abfd, filehdr_in->pe.e_ovno, filehdr_out->e_ovno);

  for (idx = 0; idx < 4; idx++)
    H_PUT_16 (abfd, filehdr_in->pe.e_res[idx], filehdr_out->e_res[idx]);

  H_PUT_16 (abfd, filehdr_in->pe.e_oemid, filehdr_out->e_oemid);
  H_PUT_16 (abfd, filehdr_in->pe.e_oeminfo, filehdr_out->e_oeminfo);

  for (idx = 0; idx < 10; idx++)
    H_PUT_16 (abfd, filehdr_in->pe.e_res2[idx], filehdr_out->e_res2[idx]);

  H_PUT_32 (abfd, filehdr_in->pe.e_lfanew, filehdr_out->e_lfanew);

  for (idx = 0; idx < 16; idx++)
    H_PUT_32 (abfd, filehdr_in->pe.dos_message[idx],
	      filehdr_out->dos_message[idx]);

  /* Also put in the NT signature.  */
  H_PUT_32 (abfd, filehdr_in->pe.nt_signature, filehdr_out->nt_signature);

  return FILHSZ;
}

unsigned int
_bfd_XX_only_swap_filehdr_out (bfd * abfd, void * in, void * out)
{
  struct internal_filehdr *filehdr_in = (struct internal_filehdr *) in;
  FILHDR *filehdr_out = (FILHDR *) out;

  H_PUT_16 (abfd, filehdr_in->f_magic, filehdr_out->f_magic);
  H_PUT_16 (abfd, filehdr_in->f_nscns, filehdr_out->f_nscns);
  H_PUT_32 (abfd, filehdr_in->f_timdat, filehdr_out->f_timdat);
  PUT_FILEHDR_SYMPTR (abfd, filehdr_in->f_symptr, filehdr_out->f_symptr);
  H_PUT_32 (abfd, filehdr_in->f_nsyms, filehdr_out->f_nsyms);
  H_PUT_16 (abfd, filehdr_in->f_opthdr, filehdr_out->f_opthdr);
  H_PUT_16 (abfd, filehdr_in->f_flags, filehdr_out->f_flags);

  return FILHSZ;
}

unsigned int
_bfd_XXi_swap_scnhdr_out (bfd * abfd, void * in, void * out)
{
  struct internal_scnhdr *scnhdr_int = (struct internal_scnhdr *) in;
  SCNHDR *scnhdr_ext = (SCNHDR *) out;
  unsigned int ret = SCNHSZ;
  bfd_vma ps;
  bfd_vma ss;

  memcpy (scnhdr_ext->s_name, scnhdr_int->s_name, sizeof (scnhdr_int->s_name));

  PUT_SCNHDR_VADDR (abfd,
		    ((scnhdr_int->s_vaddr
		      - pe_data (abfd)->pe_opthdr.ImageBase)
		     & 0xffffffff),
		    scnhdr_ext->s_vaddr);

  /* NT wants the size data to be rounded up to the next
     NT_FILE_ALIGNMENT, but zero if it has no content (as in .bss,
     sometimes).  */
  if ((scnhdr_int->s_flags & IMAGE_SCN_CNT_UNINITIALIZED_DATA) != 0)
    {
      if (bfd_pei_p (abfd))
	{
	  ps = scnhdr_int->s_size;
	  ss = 0;
	}
      else
       {
         ps = 0;
         ss = scnhdr_int->s_size;
       }
    }
  else
    {
      if (bfd_pei_p (abfd))
	ps = scnhdr_int->s_paddr;
      else
	ps = 0;

      ss = scnhdr_int->s_size;
    }

  PUT_SCNHDR_SIZE (abfd, ss,
		   scnhdr_ext->s_size);

  /* s_paddr in PE is really the virtual size.  */
  PUT_SCNHDR_PADDR (abfd, ps, scnhdr_ext->s_paddr);

  PUT_SCNHDR_SCNPTR (abfd, scnhdr_int->s_scnptr,
		     scnhdr_ext->s_scnptr);
  PUT_SCNHDR_RELPTR (abfd, scnhdr_int->s_relptr,
		     scnhdr_ext->s_relptr);
  PUT_SCNHDR_LNNOPTR (abfd, scnhdr_int->s_lnnoptr,
		      scnhdr_ext->s_lnnoptr);

  {
    /* Extra flags must be set when dealing with PE.  All sections should also
       have the IMAGE_SCN_MEM_READ (0x40000000) flag set.  In addition, the
       .text section must have IMAGE_SCN_MEM_EXECUTE (0x20000000) and the data
       sections (.idata, .data, .bss, .CRT) must have IMAGE_SCN_MEM_WRITE set
       (this is especially important when dealing with the .idata section since
       the addresses for routines from .dlls must be overwritten).  If .reloc
       section data is ever generated, we must add IMAGE_SCN_MEM_DISCARDABLE
       (0x02000000).  Also, the resource data should also be read and
       writable.  */

    /* FIXME: Alignment is also encoded in this field, at least on PPC and
       ARM-WINCE.  Although - how do we get the original alignment field
       back ?  */

    typedef struct
    {
      const char * 	section_name;
      unsigned long	must_have;
    }
    pe_required_section_flags;

    pe_required_section_flags known_sections [] =
      {
	{ ".arch",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_ALIGN_8BYTES },
	{ ".bss",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".data",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".edata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".idata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".pdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".rdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".reloc", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE },
	{ ".rsrc",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".text" , IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE },
	{ ".tls",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".xdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ NULL, 0}
      };

    pe_required_section_flags * p;

    /* We have defaulted to adding the IMAGE_SCN_MEM_WRITE flag, but now
       we know exactly what this specific section wants so we remove it
       and then allow the must_have field to add it back in if necessary.
       However, we don't remove IMAGE_SCN_MEM_WRITE flag from .text if the
       default WP_TEXT file flag has been cleared.  WP_TEXT may be cleared
       by ld --enable-auto-import (if auto-import is actually needed),
       by ld --omagic, or by obcopy --writable-text.  */

    for (p = known_sections; p->section_name; p++)
      if (strcmp (scnhdr_int->s_name, p->section_name) == 0)
	{
	  if (strcmp (scnhdr_int->s_name, ".text")
	      || (bfd_get_file_flags (abfd) & WP_TEXT))
	    scnhdr_int->s_flags &= ~IMAGE_SCN_MEM_WRITE;
	  scnhdr_int->s_flags |= p->must_have;
	  break;
	}

    H_PUT_32 (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);
  }

  if (coff_data (abfd)->link_info
      && ! coff_data (abfd)->link_info->relocatable
      && ! coff_data (abfd)->link_info->shared
      && strcmp (scnhdr_int->s_name, ".text") == 0)
    {
      /* By inference from looking at MS output, the 32 bit field
	 which is the combination of the number_of_relocs and
	 number_of_linenos is used for the line number count in
	 executables.  A 16-bit field won't do for cc1.  The MS
	 document says that the number of relocs is zero for
	 executables, but the 17-th bit has been observed to be there.
	 Overflow is not an issue: a 4G-line program will overflow a
	 bunch of other fields long before this!  */
      H_PUT_16 (abfd, (scnhdr_int->s_nlnno & 0xffff), scnhdr_ext->s_nlnno);
      H_PUT_16 (abfd, (scnhdr_int->s_nlnno >> 16), scnhdr_ext->s_nreloc);
    }
  else
    {
      if (scnhdr_int->s_nlnno <= 0xffff)
	H_PUT_16 (abfd, scnhdr_int->s_nlnno, scnhdr_ext->s_nlnno);
      else
	{
	  (*_bfd_error_handler) (_("%s: line number overflow: 0x%lx > 0xffff"),
				 bfd_get_filename (abfd),
				 scnhdr_int->s_nlnno);
	  bfd_set_error (bfd_error_file_truncated);
	  H_PUT_16 (abfd, 0xffff, scnhdr_ext->s_nlnno);
	  ret = 0;
	}

      /* Although we could encode 0xffff relocs here, we do not, to be
         consistent with other parts of bfd. Also it lets us warn, as
         we should never see 0xffff here w/o having the overflow flag
         set.  */
      if (scnhdr_int->s_nreloc < 0xffff)
	H_PUT_16 (abfd, scnhdr_int->s_nreloc, scnhdr_ext->s_nreloc);
      else
	{
	  /* PE can deal with large #s of relocs, but not here.  */
	  H_PUT_16 (abfd, 0xffff, scnhdr_ext->s_nreloc);
	  scnhdr_int->s_flags |= IMAGE_SCN_LNK_NRELOC_OVFL;
	  H_PUT_32 (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);
	}
    }
  return ret;
}

static char * dir_names[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] =
{
  N_("Export Directory [.edata (or where ever we found it)]"),
  N_("Import Directory [parts of .idata]"),
  N_("Resource Directory [.rsrc]"),
  N_("Exception Directory [.pdata]"),
  N_("Security Directory"),
  N_("Base Relocation Directory [.reloc]"),
  N_("Debug Directory"),
  N_("Description Directory"),
  N_("Special Directory"),
  N_("Thread Storage Directory [.tls]"),
  N_("Load Configuration Directory"),
  N_("Bound Import Directory"),
  N_("Import Address Table Directory"),
  N_("Delay Import Directory"),
  N_("CLR Runtime Header"),
  N_("Reserved")
};

#ifdef POWERPC_LE_PE
/* The code for the PPC really falls in the "architecture dependent"
   category.  However, it's not clear that anyone will ever care, so
   we're ignoring the issue for now; if/when PPC matters, some of this
   may need to go into peicode.h, or arguments passed to enable the
   PPC- specific code.  */
#endif

static bfd_boolean
pe_print_idata (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data;
  asection *section;
  bfd_signed_vma adj;

#ifdef POWERPC_LE_PE
  asection *rel_section = bfd_get_section_by_name (abfd, ".reldata");
#endif

  bfd_size_type datasize = 0;
  bfd_size_type dataoff;
  bfd_size_type i;
  int onaline = 20;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  bfd_vma addr;

  addr = extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress;

  if (addr == 0 && extra->DataDirectory[PE_IMPORT_TABLE].Size == 0)
    {
      /* Maybe the extra header isn't there.  Look for the section.  */
      section = bfd_get_section_by_name (abfd, ".idata");
      if (section == NULL)
	return TRUE;

      addr = section->vma;
      datasize = section->size;
      if (datasize == 0)
	return TRUE;
    }
  else
    {
      addr += extra->ImageBase;
      for (section = abfd->sections; section != NULL; section = section->next)
	{
	  datasize = section->size;
	  if (addr >= section->vma && addr < section->vma + datasize)
	    break;
	}

      if (section == NULL)
	{
	  fprintf (file,
		   _("\nThere is an import table, but the section containing it could not be found\n"));
	  return TRUE;
	}
    }

  fprintf (file, _("\nThere is an import table in %s at 0x%lx\n"),
	   section->name, (unsigned long) addr);

  dataoff = addr - section->vma;

#ifdef POWERPC_LE_PE
  if (rel_section != 0 && rel_section->size != 0)
    {
      /* The toc address can be found by taking the starting address,
	 which on the PPC locates a function descriptor. The
	 descriptor consists of the function code starting address
	 followed by the address of the toc. The starting address we
	 get from the bfd, and the descriptor is supposed to be in the
	 .reldata section.  */

      bfd_vma loadable_toc_address;
      bfd_vma toc_address;
      bfd_vma start_address;
      bfd_byte *data;
      bfd_vma offset;

      if (!bfd_malloc_and_get_section (abfd, rel_section, &data))
	{
	  if (data != NULL)
	    free (data);
	  return FALSE;
	}

      offset = abfd->start_address - rel_section->vma;

      if (offset >= rel_section->size || offset + 8 > rel_section->size)
        {
          if (data != NULL)
            free (data);
          return FALSE;
        }

      start_address = bfd_get_32 (abfd, data + offset);
      loadable_toc_address = bfd_get_32 (abfd, data + offset + 4);
      toc_address = loadable_toc_address - 32768;

      fprintf (file,
	       _("\nFunction descriptor located at the start address: %04lx\n"),
	       (unsigned long int) (abfd->start_address));
      fprintf (file,
	       _("\tcode-base %08lx toc (loadable/actual) %08lx/%08lx\n"),
	       start_address, loadable_toc_address, toc_address);
      if (data != NULL)
	free (data);
    }
  else
    {
      fprintf (file,
	       _("\nNo reldata section! Function descriptor not decoded.\n"));
    }
#endif

  fprintf (file,
	   _("\nThe Import Tables (interpreted %s section contents)\n"),
	   section->name);
  fprintf (file,
	   _("\
 vma:            Hint    Time      Forward  DLL       First\n\
                 Table   Stamp     Chain    Name      Thunk\n"));

  /* Read the whole section.  Some of the fields might be before dataoff.  */
  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }

  adj = section->vma - extra->ImageBase;

  /* Print all image import descriptors.  */
  for (i = dataoff; i + onaline <= datasize; i += onaline)
    {
      bfd_vma hint_addr;
      bfd_vma time_stamp;
      bfd_vma forward_chain;
      bfd_vma dll_name;
      bfd_vma first_thunk;
      int idx = 0;
      bfd_size_type j;
      char *dll;

      /* Print (i + extra->DataDirectory[PE_IMPORT_TABLE].VirtualAddress).  */
      fprintf (file, " %08lx\t", (unsigned long) (i + adj));
      hint_addr = bfd_get_32 (abfd, data + i);
      time_stamp = bfd_get_32 (abfd, data + i + 4);
      forward_chain = bfd_get_32 (abfd, data + i + 8);
      dll_name = bfd_get_32 (abfd, data + i + 12);
      first_thunk = bfd_get_32 (abfd, data + i + 16);

      fprintf (file, "%08lx %08lx %08lx %08lx %08lx\n",
	       (unsigned long) hint_addr,
	       (unsigned long) time_stamp,
	       (unsigned long) forward_chain,
	       (unsigned long) dll_name,
	       (unsigned long) first_thunk);

      if (hint_addr == 0 && first_thunk == 0)
	break;

      if (dll_name - adj >= section->size)
        break;

      dll = (char *) data + dll_name - adj;
      fprintf (file, _("\n\tDLL Name: %s\n"), dll);

      if (hint_addr != 0)
	{
	  bfd_byte *ft_data;
	  asection *ft_section;
	  bfd_vma ft_addr;
	  bfd_size_type ft_datasize;
	  int ft_idx;
	  int ft_allocated;

	  fprintf (file, _("\tvma:  Hint/Ord Member-Name Bound-To\n"));

	  idx = hint_addr - adj;

	  ft_addr = first_thunk + extra->ImageBase;
	  ft_idx = first_thunk - adj;
	  ft_data = data + ft_idx;
	  ft_datasize = datasize - ft_idx;
	  ft_allocated = 0;

	  if (first_thunk != hint_addr)
	    {
	      /* Find the section which contains the first thunk.  */
	      for (ft_section = abfd->sections;
		   ft_section != NULL;
		   ft_section = ft_section->next)
		{
		  if (ft_addr >= ft_section->vma
		      && ft_addr < ft_section->vma + ft_section->size)
		    break;
		}

	      if (ft_section == NULL)
		{
		  fprintf (file,
		       _("\nThere is a first thunk, but the section containing it could not be found\n"));
		  continue;
		}

	      /* Now check to see if this section is the same as our current
		 section.  If it is not then we will have to load its data in.  */
	      if (ft_section != section)
		{
		  ft_idx = first_thunk - (ft_section->vma - extra->ImageBase);
		  ft_datasize = ft_section->size - ft_idx;
		  ft_data = (bfd_byte *) bfd_malloc (ft_datasize);
		  if (ft_data == NULL)
		    continue;

		  /* Read ft_datasize bytes starting at offset ft_idx.  */
		  if (!bfd_get_section_contents (abfd, ft_section, ft_data,
						 (bfd_vma) ft_idx, ft_datasize))
		    {
		      free (ft_data);
		      continue;
		    }
		  ft_allocated = 1;
		}
	    }

	  /* Print HintName vector entries.  */
#ifdef COFF_WITH_pex64
	  for (j = 0; idx + j + 8 <= datasize; j += 8)
	    {
	      unsigned long member = bfd_get_32 (abfd, data + idx + j);
	      unsigned long member_high = bfd_get_32 (abfd, data + idx + j + 4);

	      if (!member && !member_high)
		break;

	      if (member_high & 0x80000000)
		fprintf (file, "\t%lx%08lx\t %4lx%08lx  <none>",
			 member_high,member, member_high & 0x7fffffff, member);
	      else
		{
		  int ordinal;
		  char *member_name;

		  ordinal = bfd_get_16 (abfd, data + member - adj);
		  member_name = (char *) data + member - adj + 2;
		  fprintf (file, "\t%04lx\t %4d  %s",member, ordinal, member_name);
		}

	      /* If the time stamp is not zero, the import address
		 table holds actual addresses.  */
	      if (time_stamp != 0
		  && first_thunk != 0
		  && first_thunk != hint_addr
		  && j + 4 <= ft_datasize)
		fprintf (file, "\t%04lx",
			 (unsigned long) bfd_get_32 (abfd, ft_data + j));
	      fprintf (file, "\n");
	    }
#else
	  for (j = 0; idx + j + 4 <= datasize; j += 4)
	    {
	      unsigned long member = bfd_get_32 (abfd, data + idx + j);

	      /* Print single IMAGE_IMPORT_BY_NAME vector.  */
	      if (member == 0)
		break;

	      if (member & 0x80000000)
		fprintf (file, "\t%04lx\t %4lu  <none>",
			 member, member & 0x7fffffff);
	      else
		{
		  int ordinal;
		  char *member_name;

		  ordinal = bfd_get_16 (abfd, data + member - adj);
		  member_name = (char *) data + member - adj + 2;
		  fprintf (file, "\t%04lx\t %4d  %s",
			   member, ordinal, member_name);
		}

	      /* If the time stamp is not zero, the import address
		 table holds actual addresses.  */
	      if (time_stamp != 0
		  && first_thunk != 0
		  && first_thunk != hint_addr
		  && j + 4 <= ft_datasize)
		fprintf (file, "\t%04lx",
			 (unsigned long) bfd_get_32 (abfd, ft_data + j));

	      fprintf (file, "\n");
	    }
#endif
	  if (ft_allocated)
	    free (ft_data);
	}

      fprintf (file, "\n");
    }

  free (data);

  return TRUE;
}

static bfd_boolean
pe_print_edata (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data;
  asection *section;
  bfd_size_type datasize = 0;
  bfd_size_type dataoff;
  bfd_size_type i;
  bfd_signed_vma adj;
  struct EDT_type
  {
    long export_flags;          /* Reserved - should be zero.  */
    long time_stamp;
    short major_ver;
    short minor_ver;
    bfd_vma name;               /* RVA - relative to image base.  */
    long base;                  /* Ordinal base.  */
    unsigned long num_functions;/* Number in the export address table.  */
    unsigned long num_names;    /* Number in the name pointer table.  */
    bfd_vma eat_addr;		/* RVA to the export address table.  */
    bfd_vma npt_addr;		/* RVA to the Export Name Pointer Table.  */
    bfd_vma ot_addr;		/* RVA to the Ordinal Table.  */
  } edt;

  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *extra = &pe->pe_opthdr;

  bfd_vma addr;

  addr = extra->DataDirectory[PE_EXPORT_TABLE].VirtualAddress;

  if (addr == 0 && extra->DataDirectory[PE_EXPORT_TABLE].Size == 0)
    {
      /* Maybe the extra header isn't there.  Look for the section.  */
      section = bfd_get_section_by_name (abfd, ".edata");
      if (section == NULL)
	return TRUE;

      addr = section->vma;
      dataoff = 0;
      datasize = section->size;
      if (datasize == 0)
	return TRUE;
    }
  else
    {
      addr += extra->ImageBase;

      for (section = abfd->sections; section != NULL; section = section->next)
	if (addr >= section->vma && addr < section->vma + section->size)
	  break;

      if (section == NULL)
	{
	  fprintf (file,
		   _("\nThere is an export table, but the section containing it could not be found\n"));
	  return TRUE;
	}

      dataoff = addr - section->vma;
      datasize = extra->DataDirectory[PE_EXPORT_TABLE].Size;
      if (datasize > section->size - dataoff)
	{
	  fprintf (file,
		   _("\nThere is an export table in %s, but it does not fit into that section\n"),
		   section->name);
	  return TRUE;
	}
    }

  fprintf (file, _("\nThere is an export table in %s at 0x%lx\n"),
	   section->name, (unsigned long) addr);

  data = (bfd_byte *) bfd_malloc (datasize);
  if (data == NULL)
    return FALSE;

  if (! bfd_get_section_contents (abfd, section, data,
				  (file_ptr) dataoff, datasize))
    return FALSE;

  /* Go get Export Directory Table.  */
  edt.export_flags   = bfd_get_32 (abfd, data +  0);
  edt.time_stamp     = bfd_get_32 (abfd, data +  4);
  edt.major_ver      = bfd_get_16 (abfd, data +  8);
  edt.minor_ver      = bfd_get_16 (abfd, data + 10);
  edt.name           = bfd_get_32 (abfd, data + 12);
  edt.base           = bfd_get_32 (abfd, data + 16);
  edt.num_functions  = bfd_get_32 (abfd, data + 20);
  edt.num_names      = bfd_get_32 (abfd, data + 24);
  edt.eat_addr       = bfd_get_32 (abfd, data + 28);
  edt.npt_addr       = bfd_get_32 (abfd, data + 32);
  edt.ot_addr        = bfd_get_32 (abfd, data + 36);

  adj = section->vma - extra->ImageBase + dataoff;

  /* Dump the EDT first.  */
  fprintf (file,
	   _("\nThe Export Tables (interpreted %s section contents)\n\n"),
	   section->name);

  fprintf (file,
	   _("Export Flags \t\t\t%lx\n"), (unsigned long) edt.export_flags);

  fprintf (file,
	   _("Time/Date stamp \t\t%lx\n"), (unsigned long) edt.time_stamp);

  fprintf (file,
	   _("Major/Minor \t\t\t%d/%d\n"), edt.major_ver, edt.minor_ver);

  fprintf (file,
	   _("Name \t\t\t\t"));
  bfd_fprintf_vma (abfd, file, edt.name);
  fprintf (file,
	   " %s\n", data + edt.name - adj);

  fprintf (file,
	   _("Ordinal Base \t\t\t%ld\n"), edt.base);

  fprintf (file,
	   _("Number in:\n"));

  fprintf (file,
	   _("\tExport Address Table \t\t%08lx\n"),
	   edt.num_functions);

  fprintf (file,
	   _("\t[Name Pointer/Ordinal] Table\t%08lx\n"), edt.num_names);

  fprintf (file,
	   _("Table Addresses\n"));

  fprintf (file,
	   _("\tExport Address Table \t\t"));
  bfd_fprintf_vma (abfd, file, edt.eat_addr);
  fprintf (file, "\n");

  fprintf (file,
	   _("\tName Pointer Table \t\t"));
  bfd_fprintf_vma (abfd, file, edt.npt_addr);
  fprintf (file, "\n");

  fprintf (file,
	   _("\tOrdinal Table \t\t\t"));
  bfd_fprintf_vma (abfd, file, edt.ot_addr);
  fprintf (file, "\n");

  /* The next table to find is the Export Address Table. It's basically
     a list of pointers that either locate a function in this dll, or
     forward the call to another dll. Something like:
      typedef union
      {
        long export_rva;
        long forwarder_rva;
      } export_address_table_entry;  */

  fprintf (file,
	  _("\nExport Address Table -- Ordinal Base %ld\n"),
	  edt.base);

  for (i = 0; i < edt.num_functions; ++i)
    {
      bfd_vma eat_member = bfd_get_32 (abfd,
				       data + edt.eat_addr + (i * 4) - adj);
      if (eat_member == 0)
	continue;

      if (eat_member - adj <= datasize)
	{
	  /* This rva is to a name (forwarding function) in our section.  */
	  /* Should locate a function descriptor.  */
	  fprintf (file,
		   "\t[%4ld] +base[%4ld] %04lx %s -- %s\n",
		   (long) i,
		   (long) (i + edt.base),
		   (unsigned long) eat_member,
		   _("Forwarder RVA"),
		   data + eat_member - adj);
	}
      else
	{
	  /* Should locate a function descriptor in the reldata section.  */
	  fprintf (file,
		   "\t[%4ld] +base[%4ld] %04lx %s\n",
		   (long) i,
		   (long) (i + edt.base),
		   (unsigned long) eat_member,
		   _("Export RVA"));
	}
    }

  /* The Export Name Pointer Table is paired with the Export Ordinal Table.  */
  /* Dump them in parallel for clarity.  */
  fprintf (file,
	   _("\n[Ordinal/Name Pointer] Table\n"));

  for (i = 0; i < edt.num_names; ++i)
    {
      bfd_vma name_ptr = bfd_get_32 (abfd,
				    data +
				    edt.npt_addr
				    + (i*4) - adj);

      char *name = (char *) data + name_ptr - adj;

      bfd_vma ord = bfd_get_16 (abfd,
				    data +
				    edt.ot_addr
				    + (i*2) - adj);
      fprintf (file,
	      "\t[%4ld] %s\n", (long) ord, name);
    }

  free (data);

  return TRUE;
}

/* This really is architecture dependent.  On IA-64, a .pdata entry
   consists of three dwords containing relative virtual addresses that
   specify the start and end address of the code range the entry
   covers and the address of the corresponding unwind info data.

   On ARM and SH-4, a compressed PDATA structure is used :
   _IMAGE_CE_RUNTIME_FUNCTION_ENTRY, whereas MIPS is documented to use
   _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY.
   See http://msdn2.microsoft.com/en-us/library/ms253988(VS.80).aspx .

   This is the version for uncompressed data.  */

static bfd_boolean
pe_print_pdata (bfd * abfd, void * vfile)
{
#if defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
# define PDATA_ROW_SIZE	(3 * 8)
#else
# define PDATA_ROW_SIZE	(5 * 4)
#endif
  FILE *file = (FILE *) vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".pdata");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = PDATA_ROW_SIZE;

  if (section == NULL
      || coff_section_data (abfd, section) == NULL
      || pei_section_data (abfd, section) == NULL)
    return TRUE;

  stop = pei_section_data (abfd, section)->virt_size;
  if ((stop % onaline) != 0)
    fprintf (file,
	     _("Warning, .pdata section size (%ld) is not a multiple of %d\n"),
	     (long) stop, onaline);

  fprintf (file,
	   _("\nThe Function Table (interpreted .pdata section contents)\n"));
#if defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
  fprintf (file,
	   _(" vma:\t\t\tBegin Address    End Address      Unwind Info\n"));
#else
  fprintf (file, _("\
 vma:\t\tBegin    End      EH       EH       PrologEnd  Exception\n\
     \t\tAddress  Address  Handler  Data     Address    Mask\n"));
#endif

  datasize = section->size;
  if (datasize == 0)
    return TRUE;

  if (! bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }

  start = 0;

  for (i = start; i < stop; i += onaline)
    {
      bfd_vma begin_addr;
      bfd_vma end_addr;
      bfd_vma eh_handler;
      bfd_vma eh_data;
      bfd_vma prolog_end_addr;
#if !defined(COFF_WITH_pep) || defined(COFF_WITH_pex64)
      int em_data;
#endif

      if (i + PDATA_ROW_SIZE > stop)
	break;

      begin_addr      = GET_PDATA_ENTRY (abfd, data + i     );
      end_addr        = GET_PDATA_ENTRY (abfd, data + i +  4);
      eh_handler      = GET_PDATA_ENTRY (abfd, data + i +  8);
      eh_data         = GET_PDATA_ENTRY (abfd, data + i + 12);
      prolog_end_addr = GET_PDATA_ENTRY (abfd, data + i + 16);

      if (begin_addr == 0 && end_addr == 0 && eh_handler == 0
	  && eh_data == 0 && prolog_end_addr == 0)
	/* We are probably into the padding of the section now.  */
	break;

#if !defined(COFF_WITH_pep) || defined(COFF_WITH_pex64)
      em_data = ((eh_handler & 0x1) << 2) | (prolog_end_addr & 0x3);
#endif
      eh_handler &= ~(bfd_vma) 0x3;
      prolog_end_addr &= ~(bfd_vma) 0x3;

      fputc (' ', file);
      bfd_fprintf_vma (abfd, file, i + section->vma); fputc ('\t', file);
      bfd_fprintf_vma (abfd, file, begin_addr); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, end_addr); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, eh_handler);
#if !defined(COFF_WITH_pep) || defined(COFF_WITH_pex64)
      fputc (' ', file);
      bfd_fprintf_vma (abfd, file, eh_data); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, prolog_end_addr);
      fprintf (file, "   %x", em_data);
#endif

#ifdef POWERPC_LE_PE
      if (eh_handler == 0 && eh_data != 0)
	{
	  /* Special bits here, although the meaning may be a little
	     mysterious. The only one I know for sure is 0x03
	     Code Significance
	     0x00 None
	     0x01 Register Save Millicode
	     0x02 Register Restore Millicode
	     0x03 Glue Code Sequence.  */
	  switch (eh_data)
	    {
	    case 0x01:
	      fprintf (file, _(" Register save millicode"));
	      break;
	    case 0x02:
	      fprintf (file, _(" Register restore millicode"));
	      break;
	    case 0x03:
	      fprintf (file, _(" Glue code sequence"));
	      break;
	    default:
	      break;
	    }
	}
#endif
      fprintf (file, "\n");
    }

  free (data);

  return TRUE;
#undef PDATA_ROW_SIZE
}

typedef struct sym_cache
{
  int        symcount;
  asymbol ** syms;
} sym_cache;

static asymbol **
slurp_symtab (bfd *abfd, sym_cache *psc)
{
  asymbol ** sy = NULL;
  long storage;

  if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
    {
      psc->symcount = 0;
      return NULL;
    }

  storage = bfd_get_symtab_upper_bound (abfd);
  if (storage < 0)
    return NULL;
  if (storage)
    sy = (asymbol **) bfd_malloc (storage);

  psc->symcount = bfd_canonicalize_symtab (abfd, sy);
  if (psc->symcount < 0)
    return NULL;
  return sy;
}

static const char *
my_symbol_for_address (bfd *abfd, bfd_vma func, sym_cache *psc)
{
  int i;

  if (psc->syms == 0)
    psc->syms = slurp_symtab (abfd, psc);

  for (i = 0; i < psc->symcount; i++)
    {
      if (psc->syms[i]->section->vma + psc->syms[i]->value == func)
	return psc->syms[i]->name;
    }

  return NULL;
}

static void
cleanup_syms (sym_cache *psc)
{
  psc->symcount = 0;
  free (psc->syms);
  psc->syms = NULL;
}

/* This is the version for "compressed" pdata.  */

bfd_boolean
_bfd_XX_print_ce_compressed_pdata (bfd * abfd, void * vfile)
{
# define PDATA_ROW_SIZE	(2 * 4)
  FILE *file = (FILE *) vfile;
  bfd_byte *data = NULL;
  asection *section = bfd_get_section_by_name (abfd, ".pdata");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = PDATA_ROW_SIZE;
  struct sym_cache cache = {0, 0} ;

  if (section == NULL
      || coff_section_data (abfd, section) == NULL
      || pei_section_data (abfd, section) == NULL)
    return TRUE;

  stop = pei_section_data (abfd, section)->virt_size;
  if ((stop % onaline) != 0)
    fprintf (file,
	     _("Warning, .pdata section size (%ld) is not a multiple of %d\n"),
	     (long) stop, onaline);

  fprintf (file,
	   _("\nThe Function Table (interpreted .pdata section contents)\n"));

  fprintf (file, _("\
 vma:\t\tBegin    Prolog   Function Flags    Exception EH\n\
     \t\tAddress  Length   Length   32b exc  Handler   Data\n"));

  datasize = section->size;
  if (datasize == 0)
    return TRUE;

  if (! bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }

  start = 0;

  for (i = start; i < stop; i += onaline)
    {
      bfd_vma begin_addr;
      bfd_vma other_data;
      bfd_vma prolog_length, function_length;
      int flag32bit, exception_flag;
      asection *tsection;

      if (i + PDATA_ROW_SIZE > stop)
	break;

      begin_addr = GET_PDATA_ENTRY (abfd, data + i     );
      other_data = GET_PDATA_ENTRY (abfd, data + i +  4);

      if (begin_addr == 0 && other_data == 0)
	/* We are probably into the padding of the section now.  */
	break;

      prolog_length = (other_data & 0x000000FF);
      function_length = (other_data & 0x3FFFFF00) >> 8;
      flag32bit = (int)((other_data & 0x40000000) >> 30);
      exception_flag = (int)((other_data & 0x80000000) >> 31);

      fputc (' ', file);
      bfd_fprintf_vma (abfd, file, i + section->vma); fputc ('\t', file);
      bfd_fprintf_vma (abfd, file, begin_addr); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, prolog_length); fputc (' ', file);
      bfd_fprintf_vma (abfd, file, function_length); fputc (' ', file);
      fprintf (file, "%2d  %2d   ", flag32bit, exception_flag);

      /* Get the exception handler's address and the data passed from the
         .text section. This is really the data that belongs with the .pdata
         but got "compressed" out for the ARM and SH4 architectures.  */
      tsection = bfd_get_section_by_name (abfd, ".text");
      if (tsection && coff_section_data (abfd, tsection)
	  && pei_section_data (abfd, tsection))
	{
	  bfd_vma eh_off = (begin_addr - 8) - tsection->vma;
	  bfd_byte *tdata;

	  tdata = (bfd_byte *) bfd_malloc (8);
	  if (tdata)
	    {
	      if (bfd_get_section_contents (abfd, tsection, tdata, eh_off, 8))
		{
		  bfd_vma eh, eh_data;

		  eh = bfd_get_32 (abfd, tdata);
		  eh_data = bfd_get_32 (abfd, tdata + 4);
		  fprintf (file, "%08x  ", (unsigned int) eh);
		  fprintf (file, "%08x", (unsigned int) eh_data);
		  if (eh != 0)
		    {
		      const char *s = my_symbol_for_address (abfd, eh, &cache);

		      if (s)
			fprintf (file, " (%s) ", s);
		    }
		}
	      free (tdata);
	    }
	}

      fprintf (file, "\n");
    }

  free (data);

  cleanup_syms (& cache);

  return TRUE;
#undef PDATA_ROW_SIZE
}


#define IMAGE_REL_BASED_HIGHADJ 4
static const char * const tbl[] =
{
  "ABSOLUTE",
  "HIGH",
  "LOW",
  "HIGHLOW",
  "HIGHADJ",
  "MIPS_JMPADDR",
  "SECTION",
  "REL32",
  "RESERVED1",
  "MIPS_JMPADDR16",
  "DIR64",
  "HIGH3ADJ",
  "UNKNOWN",   /* MUST be last.  */
};

static bfd_boolean
pe_print_reloc (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  bfd_byte *data = 0;
  asection *section = bfd_get_section_by_name (abfd, ".reloc");
  bfd_size_type i;
  bfd_size_type start, stop;

  if (section == NULL)
    return TRUE;

  if (section->size == 0)
    return TRUE;

  fprintf (file,
	   _("\n\nPE File Base Relocations (interpreted .reloc section contents)\n"));

  if (! bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }

  start = 0;

  stop = section->size;

  for (i = start; i < stop;)
    {
      int j;
      bfd_vma virtual_address;
      long number, size;

      /* The .reloc section is a sequence of blocks, with a header consisting
	 of two 32 bit quantities, followed by a number of 16 bit entries.  */
      virtual_address = bfd_get_32 (abfd, data+i);
      size = bfd_get_32 (abfd, data+i+4);
      number = (size - 8) / 2;

      if (size == 0)
	break;

      fprintf (file,
	       _("\nVirtual Address: %08lx Chunk size %ld (0x%lx) Number of fixups %ld\n"),
	       (unsigned long) virtual_address, size, (unsigned long) size, number);

      for (j = 0; j < number; ++j)
	{
	  unsigned short e = bfd_get_16 (abfd, data + i + 8 + j * 2);
	  unsigned int t = (e & 0xF000) >> 12;
	  int off = e & 0x0FFF;

	  if (t >= sizeof (tbl) / sizeof (tbl[0]))
	    t = (sizeof (tbl) / sizeof (tbl[0])) - 1;

	  fprintf (file,
		   _("\treloc %4d offset %4x [%4lx] %s"),
		   j, off, (unsigned long) (off + virtual_address), tbl[t]);

	  /* HIGHADJ takes an argument, - the next record *is* the
	     low 16 bits of addend.  */
	  if (t == IMAGE_REL_BASED_HIGHADJ)
	    {
	      fprintf (file, " (%4x)",
		       ((unsigned int)
			bfd_get_16 (abfd, data + i + 8 + j * 2 + 2)));
	      j++;
	    }

	  fprintf (file, "\n");
	}

      i += size;
    }

  free (data);

  return TRUE;
}

/* Print out the program headers.  */

bfd_boolean
_bfd_XX_print_private_bfd_data_common (bfd * abfd, void * vfile)
{
  FILE *file = (FILE *) vfile;
  int j;
  pe_data_type *pe = pe_data (abfd);
  struct internal_extra_pe_aouthdr *i = &pe->pe_opthdr;
  const char *subsystem_name = NULL;
  const char *name;

  /* The MS dumpbin program reportedly ands with 0xff0f before
     printing the characteristics field.  Not sure why.  No reason to
     emulate it here.  */
  fprintf (file, _("\nCharacteristics 0x%x\n"), pe->real_flags);
#undef PF
#define PF(x, y) if (pe->real_flags & x) { fprintf (file, "\t%s\n", y); }
  PF (IMAGE_FILE_RELOCS_STRIPPED, "relocations stripped");
  PF (IMAGE_FILE_EXECUTABLE_IMAGE, "executable");
  PF (IMAGE_FILE_LINE_NUMS_STRIPPED, "line numbers stripped");
  PF (IMAGE_FILE_LOCAL_SYMS_STRIPPED, "symbols stripped");
  PF (IMAGE_FILE_LARGE_ADDRESS_AWARE, "large address aware");
  PF (IMAGE_FILE_BYTES_REVERSED_LO, "little endian");
  PF (IMAGE_FILE_32BIT_MACHINE, "32 bit words");
  PF (IMAGE_FILE_DEBUG_STRIPPED, "debugging information removed");
  PF (IMAGE_FILE_SYSTEM, "system file");
  PF (IMAGE_FILE_DLL, "DLL");
  PF (IMAGE_FILE_BYTES_REVERSED_HI, "big endian");
#undef PF

  /* ctime implies '\n'.  */
  {
    time_t t = pe->coff.timestamp;
    fprintf (file, "\nTime/Date\t\t%s", ctime (&t));
  }

#ifndef IMAGE_NT_OPTIONAL_HDR_MAGIC
# define IMAGE_NT_OPTIONAL_HDR_MAGIC 0x10b
#endif
#ifndef IMAGE_NT_OPTIONAL_HDR64_MAGIC
# define IMAGE_NT_OPTIONAL_HDR64_MAGIC 0x20b
#endif
#ifndef IMAGE_NT_OPTIONAL_HDRROM_MAGIC
# define IMAGE_NT_OPTIONAL_HDRROM_MAGIC 0x107
#endif

  switch (i->Magic)
    {
    case IMAGE_NT_OPTIONAL_HDR_MAGIC:
      name = "PE32";
      break;
    case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
      name = "PE32+";
      break;
    case IMAGE_NT_OPTIONAL_HDRROM_MAGIC:
      name = "ROM";
      break;
    default:
      name = NULL;
      break;
    }
  fprintf (file, "Magic\t\t\t%04x", i->Magic);
  if (name)
    fprintf (file, "\t(%s)",name);
  fprintf (file, "\nMajorLinkerVersion\t%d\n", i->MajorLinkerVersion);
  fprintf (file, "MinorLinkerVersion\t%d\n", i->MinorLinkerVersion);
  fprintf (file, "SizeOfCode\t\t%08lx\n", (unsigned long) i->SizeOfCode);
  fprintf (file, "SizeOfInitializedData\t%08lx\n",
	   (unsigned long) i->SizeOfInitializedData);
  fprintf (file, "SizeOfUninitializedData\t%08lx\n",
	   (unsigned long) i->SizeOfUninitializedData);
  fprintf (file, "AddressOfEntryPoint\t");
  bfd_fprintf_vma (abfd, file, i->AddressOfEntryPoint);
  fprintf (file, "\nBaseOfCode\t\t");
  bfd_fprintf_vma (abfd, file, i->BaseOfCode);
#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
  /* PE32+ does not have BaseOfData member!  */
  fprintf (file, "\nBaseOfData\t\t");
  bfd_fprintf_vma (abfd, file, i->BaseOfData);
#endif

  fprintf (file, "\nImageBase\t\t");
  bfd_fprintf_vma (abfd, file, i->ImageBase);
  fprintf (file, "\nSectionAlignment\t");
  bfd_fprintf_vma (abfd, file, i->SectionAlignment);
  fprintf (file, "\nFileAlignment\t\t");
  bfd_fprintf_vma (abfd, file, i->FileAlignment);
  fprintf (file, "\nMajorOSystemVersion\t%d\n", i->MajorOperatingSystemVersion);
  fprintf (file, "MinorOSystemVersion\t%d\n", i->MinorOperatingSystemVersion);
  fprintf (file, "MajorImageVersion\t%d\n", i->MajorImageVersion);
  fprintf (file, "MinorImageVersion\t%d\n", i->MinorImageVersion);
  fprintf (file, "MajorSubsystemVersion\t%d\n", i->MajorSubsystemVersion);
  fprintf (file, "MinorSubsystemVersion\t%d\n", i->MinorSubsystemVersion);
  fprintf (file, "Win32Version\t\t%08lx\n", (unsigned long) i->Reserved1);
  fprintf (file, "SizeOfImage\t\t%08lx\n", (unsigned long) i->SizeOfImage);
  fprintf (file, "SizeOfHeaders\t\t%08lx\n", (unsigned long) i->SizeOfHeaders);
  fprintf (file, "CheckSum\t\t%08lx\n", (unsigned long) i->CheckSum);

  switch (i->Subsystem)
    {
    case IMAGE_SUBSYSTEM_UNKNOWN:
      subsystem_name = "unspecified";
      break;
    case IMAGE_SUBSYSTEM_NATIVE:
      subsystem_name = "NT native";
      break;
    case IMAGE_SUBSYSTEM_WINDOWS_GUI:
      subsystem_name = "Windows GUI";
      break;
    case IMAGE_SUBSYSTEM_WINDOWS_CUI:
      subsystem_name = "Windows CUI";
      break;
    case IMAGE_SUBSYSTEM_POSIX_CUI:
      subsystem_name = "POSIX CUI";
      break;
    case IMAGE_SUBSYSTEM_WINDOWS_CE_GUI:
      subsystem_name = "Wince CUI";
      break;
    // These are from UEFI Platform Initialization Specification 1.1.
    case IMAGE_SUBSYSTEM_EFI_APPLICATION:
      subsystem_name = "EFI application";
      break;
    case IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER:
      subsystem_name = "EFI boot service driver";
      break;
    case IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:
      subsystem_name = "EFI runtime driver";
      break;
    case IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER:
      subsystem_name = "SAL runtime driver";
      break;
    // This is from revision 8.0 of the MS PE/COFF spec
    case IMAGE_SUBSYSTEM_XBOX:
      subsystem_name = "XBOX";
      break;
    // Added default case for clarity - subsystem_name is NULL anyway.
    default:
      subsystem_name = NULL;
    }

  fprintf (file, "Subsystem\t\t%08x", i->Subsystem);
  if (subsystem_name)
    fprintf (file, "\t(%s)", subsystem_name);
  fprintf (file, "\nDllCharacteristics\t%08x\n", i->DllCharacteristics);
  fprintf (file, "SizeOfStackReserve\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfStackReserve);
  fprintf (file, "\nSizeOfStackCommit\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfStackCommit);
  fprintf (file, "\nSizeOfHeapReserve\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfHeapReserve);
  fprintf (file, "\nSizeOfHeapCommit\t");
  bfd_fprintf_vma (abfd, file, i->SizeOfHeapCommit);
  fprintf (file, "\nLoaderFlags\t\t%08lx\n", (unsigned long) i->LoaderFlags);
  fprintf (file, "NumberOfRvaAndSizes\t%08lx\n",
	   (unsigned long) i->NumberOfRvaAndSizes);

  fprintf (file, "\nThe Data Directory\n");
  for (j = 0; j < IMAGE_NUMBEROF_DIRECTORY_ENTRIES; j++)
    {
      fprintf (file, "Entry %1x ", j);
      bfd_fprintf_vma (abfd, file, i->DataDirectory[j].VirtualAddress);
      fprintf (file, " %08lx ", (unsigned long) i->DataDirectory[j].Size);
      fprintf (file, "%s\n", dir_names[j]);
    }

  pe_print_idata (abfd, vfile);
  pe_print_edata (abfd, vfile);
  if (bfd_coff_have_print_pdata (abfd))
    bfd_coff_print_pdata (abfd, vfile);
  else
    pe_print_pdata (abfd, vfile);
  pe_print_reloc (abfd, vfile);

  return TRUE;
}

/* Copy any private info we understand from the input bfd
   to the output bfd.  */

bfd_boolean
_bfd_XX_bfd_copy_private_bfd_data_common (bfd * ibfd, bfd * obfd)
{
  pe_data_type *ipe, *ope;

  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_coff_flavour
      || obfd->xvec->flavour != bfd_target_coff_flavour)
    return TRUE;

  ipe = pe_data (ibfd);
  ope = pe_data (obfd);

  /* pe_opthdr is copied in copy_object.  */
  ope->dll = ipe->dll;

  /* Don't copy input subsystem if output is different from input.  */
  if (obfd->xvec != ibfd->xvec)
    ope->pe_opthdr.Subsystem = IMAGE_SUBSYSTEM_UNKNOWN;

  /* For strip: if we removed .reloc, we'll make a real mess of things
     if we don't remove this entry as well.  */
  if (! pe_data (obfd)->has_reloc_section)
    {
      pe_data (obfd)->pe_opthdr.DataDirectory[PE_BASE_RELOCATION_TABLE].VirtualAddress = 0;
      pe_data (obfd)->pe_opthdr.DataDirectory[PE_BASE_RELOCATION_TABLE].Size = 0;
    }

  /* For PIE, if there is .reloc, we won't add IMAGE_FILE_RELOCS_STRIPPED.
     But there is no .reloc, we make sure that IMAGE_FILE_RELOCS_STRIPPED
     won't be added.  */
  if (! pe_data (ibfd)->has_reloc_section
      && ! (pe_data (ibfd)->real_flags & IMAGE_FILE_RELOCS_STRIPPED))
    pe_data (obfd)->dont_strip_reloc = 1;

  return TRUE;
}

/* Copy private section data.  */

bfd_boolean
_bfd_XX_bfd_copy_private_section_data (bfd *ibfd,
				       asection *isec,
				       bfd *obfd,
				       asection *osec)
{
  if (bfd_get_flavour (ibfd) != bfd_target_coff_flavour
      || bfd_get_flavour (obfd) != bfd_target_coff_flavour)
    return TRUE;

  if (coff_section_data (ibfd, isec) != NULL
      && pei_section_data (ibfd, isec) != NULL)
    {
      if (coff_section_data (obfd, osec) == NULL)
	{
	  bfd_size_type amt = sizeof (struct coff_section_tdata);
	  osec->used_by_bfd = bfd_zalloc (obfd, amt);
	  if (osec->used_by_bfd == NULL)
	    return FALSE;
	}

      if (pei_section_data (obfd, osec) == NULL)
	{
	  bfd_size_type amt = sizeof (struct pei_section_tdata);
	  coff_section_data (obfd, osec)->tdata = bfd_zalloc (obfd, amt);
	  if (coff_section_data (obfd, osec)->tdata == NULL)
	    return FALSE;
	}

      pei_section_data (obfd, osec)->virt_size =
	pei_section_data (ibfd, isec)->virt_size;
      pei_section_data (obfd, osec)->pe_flags =
	pei_section_data (ibfd, isec)->pe_flags;
    }

  return TRUE;
}

void
_bfd_XX_get_symbol_info (bfd * abfd, asymbol *symbol, symbol_info *ret)
{
  coff_get_symbol_info (abfd, symbol, ret);
}

#if !defined(COFF_WITH_pep) && defined(COFF_WITH_pex64)
static int
sort_x64_pdata (const void *l, const void *r)
{
  const char *lp = (const char *) l;
  const char *rp = (const char *) r;
  bfd_vma vl, vr;
  vl = bfd_getl32 (lp); vr = bfd_getl32 (rp);
  if (vl != vr)
    return (vl < vr ? -1 : 1);
  /* We compare just begin address.  */
  return 0;
}
#endif

/* Handle the .idata section and other things that need symbol table
   access.  */

bfd_boolean
_bfd_XXi_final_link_postscript (bfd * abfd, struct coff_final_link_info *pfinfo)
{
  struct coff_link_hash_entry *h1;
  struct bfd_link_info *info = pfinfo->info;
  bfd_boolean result = TRUE;

  /* There are a few fields that need to be filled in now while we
     have symbol table access.

     The .idata subsections aren't directly available as sections, but
     they are in the symbol table, so get them from there.  */

  /* The import directory.  This is the address of .idata$2, with size
     of .idata$2 + .idata$3.  */
  h1 = coff_link_hash_lookup (coff_hash_table (info),
			      ".idata$2", FALSE, FALSE, TRUE);
  if (h1 != NULL)
    {
      /* PR ld/2729: We cannot rely upon all the output sections having been
	 created properly, so check before referencing them.  Issue a warning
	 message for any sections tht could not be found.  */
      if ((h1->root.type == bfd_link_hash_defined
	   || h1->root.type == bfd_link_hash_defweak)
	  && h1->root.u.def.section != NULL
	  && h1->root.u.def.section->output_section != NULL)
	pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_TABLE].VirtualAddress =
	  (h1->root.u.def.value
	   + h1->root.u.def.section->output_section->vma
	   + h1->root.u.def.section->output_offset);
      else
	{
	  _bfd_error_handler
	    (_("%B: unable to fill in DataDictionary[1] because .idata$2 is missing"),
	     abfd);
	  result = FALSE;
	}

      h1 = coff_link_hash_lookup (coff_hash_table (info),
				  ".idata$4", FALSE, FALSE, TRUE);
      if (h1 != NULL
	  && (h1->root.type == bfd_link_hash_defined
	   || h1->root.type == bfd_link_hash_defweak)
	  && h1->root.u.def.section != NULL
	  && h1->root.u.def.section->output_section != NULL)
	pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_TABLE].Size =
	  ((h1->root.u.def.value
	    + h1->root.u.def.section->output_section->vma
	    + h1->root.u.def.section->output_offset)
	   - pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_TABLE].VirtualAddress);
      else
	{
	  _bfd_error_handler
	    (_("%B: unable to fill in DataDictionary[1] because .idata$4 is missing"),
	     abfd);
	  result = FALSE;
	}

      /* The import address table.  This is the size/address of
         .idata$5.  */
      h1 = coff_link_hash_lookup (coff_hash_table (info),
				  ".idata$5", FALSE, FALSE, TRUE);
      if (h1 != NULL
	  && (h1->root.type == bfd_link_hash_defined
	   || h1->root.type == bfd_link_hash_defweak)
	  && h1->root.u.def.section != NULL
	  && h1->root.u.def.section->output_section != NULL)
	pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress =
	  (h1->root.u.def.value
	   + h1->root.u.def.section->output_section->vma
	   + h1->root.u.def.section->output_offset);
      else
	{
	  _bfd_error_handler
	    (_("%B: unable to fill in DataDictionary[12] because .idata$5 is missing"),
	     abfd);
	  result = FALSE;
	}

      h1 = coff_link_hash_lookup (coff_hash_table (info),
				  ".idata$6", FALSE, FALSE, TRUE);
      if (h1 != NULL
	  && (h1->root.type == bfd_link_hash_defined
	   || h1->root.type == bfd_link_hash_defweak)
	  && h1->root.u.def.section != NULL
	  && h1->root.u.def.section->output_section != NULL)
	pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].Size =
	  ((h1->root.u.def.value
	    + h1->root.u.def.section->output_section->vma
	    + h1->root.u.def.section->output_offset)
	   - pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress);
      else
	{
	  _bfd_error_handler
	    (_("%B: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE (12)] because .idata$6 is missing"),
	     abfd);
	  result = FALSE;
	}
    }
  else
    {
      h1 = coff_link_hash_lookup (coff_hash_table (info),
				  "__IAT_start__", FALSE, FALSE, TRUE);
      if (h1 != NULL
	  && (h1->root.type == bfd_link_hash_defined
	   || h1->root.type == bfd_link_hash_defweak)
	  && h1->root.u.def.section != NULL
	  && h1->root.u.def.section->output_section != NULL)
	{
	  bfd_vma iat_va;

	  iat_va =
	    (h1->root.u.def.value
	     + h1->root.u.def.section->output_section->vma
	     + h1->root.u.def.section->output_offset);

	  h1 = coff_link_hash_lookup (coff_hash_table (info),
				      "__IAT_end__", FALSE, FALSE, TRUE);
	  if (h1 != NULL
	      && (h1->root.type == bfd_link_hash_defined
	       || h1->root.type == bfd_link_hash_defweak)
	      && h1->root.u.def.section != NULL
	      && h1->root.u.def.section->output_section != NULL)
	    {
	      pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].Size =
		((h1->root.u.def.value
		  + h1->root.u.def.section->output_section->vma
		  + h1->root.u.def.section->output_offset)
		 - iat_va);
	      if (pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].Size != 0)
		pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress =
		  iat_va - pe_data (abfd)->pe_opthdr.ImageBase;
	    }
	  else
	    {
	      _bfd_error_handler
		(_("%B: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE(12)]"
		   " because .idata$6 is missing"), abfd);
	      result = FALSE;
	    }
        }
    }

  h1 = coff_link_hash_lookup (coff_hash_table (info),
			      (bfd_get_symbol_leading_char(abfd) != 0
			       ? "__tls_used" : "_tls_used"),
			      FALSE, FALSE, TRUE);
  if (h1 != NULL)
    {
      if ((h1->root.type == bfd_link_hash_defined
	   || h1->root.type == bfd_link_hash_defweak)
	  && h1->root.u.def.section != NULL
	  && h1->root.u.def.section->output_section != NULL)
	pe_data (abfd)->pe_opthdr.DataDirectory[PE_TLS_TABLE].VirtualAddress =
	  (h1->root.u.def.value
	   + h1->root.u.def.section->output_section->vma
	   + h1->root.u.def.section->output_offset
	   - pe_data (abfd)->pe_opthdr.ImageBase);
      else
	{
	  _bfd_error_handler
	    (_("%B: unable to fill in DataDictionary[9] because __tls_used is missing"),
	     abfd);
	  result = FALSE;
	}
     /* According to PECOFF sepcifications by Microsoft version 8.2
	the TLS data directory consists of 4 pointers, followed
	by two 4-byte integer. This implies that the total size
	is different for 32-bit and 64-bit executables.  */
#if !defined(COFF_WITH_pep) && !defined(COFF_WITH_pex64)
      pe_data (abfd)->pe_opthdr.DataDirectory[PE_TLS_TABLE].Size = 0x18;
#else
      pe_data (abfd)->pe_opthdr.DataDirectory[PE_TLS_TABLE].Size = 0x28;
#endif
    }

/* If there is a .pdata section and we have linked pdata finally, we
     need to sort the entries ascending.  */
#if !defined(COFF_WITH_pep) && defined(COFF_WITH_pex64)
  {
    asection *sec = bfd_get_section_by_name (abfd, ".pdata");

    if (sec)
      {
	bfd_size_type x = sec->rawsize;
	bfd_byte *tmp_data = NULL;

	if (x)
	  tmp_data = bfd_malloc (x);

	if (tmp_data != NULL)
	  {
	    if (bfd_get_section_contents (abfd, sec, tmp_data, 0, x))
	      {
		qsort (tmp_data,
		       (size_t) (x / 12),
		       12, sort_x64_pdata);
		bfd_set_section_contents (pfinfo->output_bfd, sec,
					  tmp_data, 0, x);
	      }
	    free (tmp_data);
	  }
      }
  }
#endif

  /* If we couldn't find idata$2, we either have an excessively
     trivial program or are in DEEP trouble; we have to assume trivial
     program....  */
  return result;
}
@


1.72
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d464 1
a464 1
    for (idx = 0; idx < 16; idx++)
@


1.71
log
@ChangeLog bfd

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* coff-i386.c (bfd_target): Add section flag SEC_EXCLUDE.
	Allow BFD_COMPRESS and BFD_DECOMPRESS flags.
	* coff-x86_64.c: Likewise.
	* coffcode.h (DOT_ZDEBUG): New define.
	(sec_to_styp_flags): Check for .zdebug.
	(styp_to_sec_flags): Likewise.
	* coffgen.c (make_a_section): Handle .debug_* section
	compression/decompression flags.
	* cofflink.c (mark_relocs): Ignore relocations
	for a section, which isn't marked as used.
	(_bfd_coff_link_input_bfd): Add support of compressed
	debug sections.
	* compress.c (decompress_contents): Loop as long
	as there is input available and there is room for
	output.
	* bfd/pe-arm.c: Add .zdebug_ partial match entry.
	* pe-i386.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't clear all
	data-directories as this might destroy content.

        * coff-i386.c (_bfd_generic_find_nearest_line_discriminator):
        define as coff_find_nearest_line_discriminator.
        * libcoff-in.h (coff_find_nearest_line_discriminator): New
        * libcoff.h: Regenerated.
        * coff-x86_64.c: Likewise.
        * coffgen.c (coff_find_nearest_line_discriminator): New function.
        prototype.

ChangeLog binutils

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	* objdump.c (dump_bfd): Call dump headers after
	call of slurp_symtab.

ChangeLog ld

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* NEWS: Menition new feature.
	* scripttempl/pep.sc: Add zdebug sections.
	* scripttempl/pe.sc: L
@
text
@d2442 1
a2442 1
	is different for 32-bit and 64-bit executables.  */ 
@


1.70
log
@2011-04-09  Kai Tietz  <ktietz@@redhat.com>

        * peXXigen.c (_bfd_XXi_final_link_postscripte): Sort pdata in temporary
        buffer and use rawsize for sorting.
        * coffcode.h (coff_compute_section_file_positions): Set rawsize
        before doing alignment.
@
text
@a593 3
  /* First null out all data directory entries.  */
  memset (extra->DataDirectory, 0, sizeof (extra->DataDirectory));

@


1.69
log
@2010-12-21  Kai Tietz  <kai.tietz@@onevision.com>

        * peXXigen.c (_bfd_XXi_final_link_postscript): Use
        bfd_get_symbol_leading_char to determine "_tls_used" name.

2010-12-21  Kai Tietz  <kai.tietz@@onevision.com>

	* ld-pe/pe.exp: Add TLS directory test.
	* ld-pe/tlssec.s: New.
	* ld-pe/tlssec64.d: New.
	* ld-pe/tlssec32.d: New.
@
text
@d2461 2
a2462 1
	bfd_size_type x = sec->rawsize ? sec->rawsize : sec->size;
d2464 4
a2467 1
	if (x && bfd_get_section_contents (abfd, sec, pfinfo->contents, 0, x))
d2469 9
a2477 5
	    qsort (pfinfo->contents,
	    	   (size_t) ((sec->size <x ? sec->size : x) / 12),
	    	   12, sort_x64_pdata);
	    bfd_set_section_contents (pfinfo->output_bfd, sec,
	    			      pfinfo->contents, 0, x);
@


1.68
log
@	* peXXigen.c (_bfd_XXi_final_link_postscript): Use correct size
	for windows 64-bit TLS table size.
@
text
@d2421 3
a2423 1
			      "__tls_used", FALSE, FALSE, TRUE);
@


1.67
log
@2010-09-22  Kai Tietz  <kai.tietz@@onevision.com>

        * peXXigen.c (_bfd_XXi_final_link_postscript):
        Add handling for setting IAT directory entry.
@
text
@d2440 5
a2444 1

d2446 3
@


1.67.2.1
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d2452 1
a2452 2
	bfd_size_type x = sec->rawsize;
	bfd_byte *tmp_data = NULL;
d2454 1
a2454 4
	if (x)
	  tmp_data = bfd_malloc (x);

	if (tmp_data != NULL)
d2456 5
a2460 9
	    if (bfd_get_section_contents (abfd, sec, tmp_data, 0, x))
	      {
		qsort (tmp_data,
		       (size_t) (x / 12),
		       12, sort_x64_pdata);
		bfd_set_section_contents (pfinfo->output_bfd, sec,
					  tmp_data, 0, x);
	      }
	    free (tmp_data);
@


1.66
log
@2010-09-14  Kai Tietz  <kai.tietz@@onevision.com>

        * peXXigen.c (sort_x64_pdata): New helper.
        (_bfd_XXi_final_link_postscript): Do pdata sorting.
@
text
@d2376 43
@


1.65
log
@	* peXXigen.c: Whitespace.
	(pe_print_idata): Correct section limit calculations.  Tidy array
	indexing.
	(_bfd_XX_print_ce_compressed_pdata): Don't leak memory.
@
text
@d2259 15
d2401 22
@


1.64
log
@fix set but unused variable warnings
@
text
@d553 1
a553 1
  
d561 1
a561 1
  
d618 1
a618 1
    
d929 1
a929 1
    /* FIXME: Alignment is also encoded in this field, at least on PPC and 
d939 1
a939 1
    
a1112 1
  datasize -= dataoff;
d1185 1
a1185 1
  for (i = 0; i < datasize; i += onaline)
d1197 6
a1202 6
      fprintf (file, " %08lx\t", (unsigned long) (i + adj + dataoff));
      hint_addr = bfd_get_32 (abfd, data + i + dataoff);
      time_stamp = bfd_get_32 (abfd, data + i + 4 + dataoff);
      forward_chain = bfd_get_32 (abfd, data + i + 8 + dataoff);
      dll_name = bfd_get_32 (abfd, data + i + 12 + dataoff);
      first_thunk = bfd_get_32 (abfd, data + i + 16 + dataoff);
d1227 1
a1227 1
	  int ft_allocated = 0;
d1232 1
a1232 1
	  
a1233 1
	  ft_data = data;
d1235 3
a1237 1
	  ft_allocated = 0; 
a1245 1
		  ft_datasize = ft_section->size;
d1247 1
a1247 1
		      && ft_addr < ft_section->vma + ft_datasize)
d1260 1
a1260 6
	      if (ft_section == section)
		{
		  ft_data = data;
		  ft_idx = first_thunk - adj;
		}
	      else
d1263 2
a1264 1
		  ft_data = (bfd_byte *) bfd_malloc (datasize);
d1268 3
a1270 3
		  /* Read datasize bfd_bytes starting at offset ft_idx.  */
		  if (! bfd_get_section_contents
		      (abfd, ft_section, ft_data, (bfd_vma) ft_idx, datasize))
a1274 2

		  ft_idx = 0;
d1281 1
a1281 1
	  for (j = 0; j < datasize; j += 8)
d1306 2
a1307 1
		  && first_thunk != hint_addr)
d1309 1
a1309 1
			 (unsigned long) bfd_get_32 (abfd, ft_data + ft_idx + j));
d1313 1
a1313 1
	  for (j = 0; j < datasize; j += 4)
d1317 1
a1317 1
	      /* Print single IMAGE_IMPORT_BY_NAME vector.  */ 
d1339 2
a1340 1
		  && first_thunk != hint_addr)
d1342 1
a1342 1
			 (unsigned long) bfd_get_32 (abfd, ft_data + ft_idx + j));
d1581 1
a1581 1
   covers and the address of the corresponding unwind info data. 
a1825 1
      bfd_byte *tdata = 0;
d1857 5
a1861 1
	  if (bfd_malloc_and_get_section (abfd, tsection, & tdata))
d1863 1
a1863 4
	      int xx = (begin_addr - 8) - tsection->vma;

	      tdata = (bfd_byte *) bfd_malloc (8);
	      if (bfd_get_section_contents (abfd, tsection, tdata, (bfd_vma) xx, 8))
a1880 5
	  else
	    {
	      if (tdata)
		free (tdata);
	    }
d2187 1
a2187 1
 
d2281 1
a2281 1
      /* PR ld/2729: We cannot rely upon all the output sections having been 
d2295 1
a2295 1
	    (_("%B: unable to fill in DataDictionary[1] because .idata$2 is missing"), 
d2315 1
a2315 1
	    (_("%B: unable to fill in DataDictionary[1] because .idata$4 is missing"), 
d2336 1
a2336 1
	    (_("%B: unable to fill in DataDictionary[12] because .idata$5 is missing"), 
d2352 1
a2352 1
	   - pe_data (abfd)->pe_opthdr.DataDirectory[PE_IMPORT_ADDRESS_TABLE].VirtualAddress);      
d2356 1
a2356 1
	    (_("%B: unable to fill in DataDictionary[PE_IMPORT_ADDRESS_TABLE (12)] because .idata$6 is missing"), 
d2378 1
a2378 1
	    (_("%B: unable to fill in DataDictionary[9] because __tls_used is missing"), 
@


1.63
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d1653 1
d1655 1
d1671 1
d1673 1
@


1.62
log
@Don't add IMAGE_FILE_RELOCS_STRIPPED for PIE.

2010-03-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/11396
	* libcoff-in.h (pe_tdata): Add dont_strip_reloc.
	* libcoff.h: Regenerated.

	* peXXigen.c (_bfd_XXi_only_swap_filehdr_out): Clear F_RELFLG
	if dont_strip_reloc is set.
	(_bfd_XX_bfd_copy_private_bfd_data_common): Set
	dont_strip_reloc on output if there is no .reloc and
	IMAGE_FILE_RELOCS_STRIPPED isn't set in input.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
a1924 1
  bfd_size_type datasize;
a1936 1
  datasize = section->size;
@


1.61
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d743 2
a744 1
  if (pe_data (abfd)->has_reloc_section)
d2210 8
@


1.60
log
@2009-10-27  Kai Tietz  <kai.tietz@@onevision.com>

        * peXXigen.c (bfdver.h): Add include.
        (LINKER_VERSION): Do calculation based on BFD_VERSION.
@
text
@d1787 1
a1787 1
  struct sym_cache sym_cache = {0, 0} ;
d1873 1
a1873 1
		      const char *s = my_symbol_for_address (abfd, eh, &sym_cache);
d1893 1
a1893 1
  cleanup_syms (& sym_cache);
@


1.59
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d65 1
d670 2
a671 1
#define LINKER_VERSION 256 /* That is, 2.56 */
@


1.58
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d163 1
a163 1
	      name = bfd_alloc (abfd, strlen (namebuf) + 1);
d1266 1
a1266 1
		  ft_data = bfd_malloc (datasize);
d1435 1
a1435 1
  data = bfd_malloc (datasize);
d1739 1
a1739 1
    sy = bfd_malloc (storage);
d1860 1
a1860 1
	      tdata = bfd_malloc (8);
@


1.57
log
@	* coffgen.c (coff_print_symbol):  Use bfd_fprintf_vma, not
	fprintf_vma directly.
	* peXXigen.c (pe_print_edata):  Likewise.
	(pe_print_pdata):  Likewise.
	(_bfd_XX_print_ce_compressed_pdata):  Likewise.
	(_bfd_XX_print_private_bfd_data_common):  Likewise.
@
text
@d234 1
a234 1
		      int       class,
d242 1
a242 1
  switch (class)
d273 2
a274 1
  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
d306 1
a306 1
		       int    class,
d316 1
a316 1
  switch (class)
d348 2
a349 1
  if (class == C_BLOCK || class == C_FCN || ISFCN (type) || ISTAG (class))
@


1.57.6.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d234 1
a234 1
		      int       in_class,
d242 1
a242 1
  switch (in_class)
d273 1
a273 2
  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
      || ISTAG (in_class))
d305 1
a305 1
		       int    in_class,
d315 1
a315 1
  switch (in_class)
d347 1
a347 2
  if (in_class == C_BLOCK || in_class == C_FCN || ISFCN (type)
      || ISTAG (in_class))
@


1.57.6.2
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d163 1
a163 1
	      name = (const char *) bfd_alloc (abfd, strlen (namebuf) + 1);
d1266 1
a1266 1
		  ft_data = (bfd_byte *) bfd_malloc (datasize);
d1435 1
a1435 1
  data = (bfd_byte *) bfd_malloc (datasize);
d1739 1
a1739 1
    sy = (asymbol **) bfd_malloc (storage);
d1860 1
a1860 1
	      tdata = (bfd_byte *) bfd_malloc (8);
@


1.56
log
@bfd/

2009-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* peXXigen.c (_bfd_XX_bfd_copy_private_bfd_data_common): Don't
	copy pe_opthdr.

binutils/

2009-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (copy_object): Copy pe_opthdr before changing PE
	parameters.
@
text
@d1472 1
a1472 1
  fprintf_vma (file, edt.name);
d1494 1
a1494 1
  fprintf_vma (file, edt.eat_addr);
d1499 1
a1499 1
  fprintf_vma (file, edt.npt_addr);
d1504 1
a1504 1
  fprintf_vma (file, edt.ot_addr);
d1669 4
a1672 4
      fprintf_vma (file, i + section->vma); fputc ('\t', file);
      fprintf_vma (file, begin_addr); fputc (' ', file);
      fprintf_vma (file, end_addr); fputc (' ', file);
      fprintf_vma (file, eh_handler);
d1675 2
a1676 2
      fprintf_vma (file, eh_data); fputc (' ', file);
      fprintf_vma (file, prolog_end_addr);
d1841 4
a1844 4
      fprintf_vma (file, i + section->vma); fputc ('\t', file);
      fprintf_vma (file, begin_addr); fputc (' ', file);
      fprintf_vma (file, prolog_length); fputc (' ', file);
      fprintf_vma (file, function_length); fputc (' ', file);
d2071 1
a2071 1
  fprintf_vma (file, i->AddressOfEntryPoint);
d2073 1
a2073 1
  fprintf_vma (file, i->BaseOfCode);
d2077 1
a2077 1
  fprintf_vma (file, i->BaseOfData);
d2081 1
a2081 1
  fprintf_vma (file, i->ImageBase);
d2083 1
a2083 1
  fprintf_vma (file, i->SectionAlignment);
d2085 1
a2085 1
  fprintf_vma (file, i->FileAlignment);
d2144 1
a2144 1
  fprintf_vma (file, i->SizeOfStackReserve);
d2146 1
a2146 1
  fprintf_vma (file, i->SizeOfStackCommit);
d2148 1
a2148 1
  fprintf_vma (file, i->SizeOfHeapReserve);
d2150 1
a2150 1
  fprintf_vma (file, i->SizeOfHeapCommit);
d2159 1
a2159 1
      fprintf_vma (file, i->DataDirectory[j].VirtualAddress);
@


1.55
log
@2009-04-23  Matthias Klose  <doko@@ubuntu.com>

	* bfd/peXXigen.c (_bfd_XXi_swap_sym_in): Initialize `name'.
@
text
@d2191 1
a2191 1
  ope->pe_opthdr = ipe->pe_opthdr;
@


1.54
log
@2009-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* coff-ia64.c (COFF_PAGE_SIZE): Changed to 8K.

	* coffcode.h (coff_compute_section_file_positions): Clear
	D_PAGED if PE section alignment is smaller than COFF_PAGE_SIZE.

	* libcoff-in.h (pe_tdata): Remove force_minimum_alignment and
	force_minimum_alignment.

	* libcoff.h: Regenerated.

	* pei-ia64.c (PEI_TARGET_SUBSYSTEM): Removed.
	(PEI_FORCE_MINIMUM_ALIGNMENT): Likewise.

	* peicode.h (pe_mkobject): Don't set force_minimum_alignment
	nor target_subsystem.

	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't check
	force_minimum_alignment nor target_subsystem.
@
text
@d133 1
a133 1
      const char *name;
@


1.53
log
@bfd/ChangeLog

2009-04-21  Kai Tietz  <kai.tietz@@onevision.com>

	* coff-x86_64.c (PEI_HEADERS): Protect includes.
	(bfd_pe_print_pdata): Remove #ifdef PE variation.
	* pei-x86_64.c (PEI_HEADERS): Define to prevent double
	include in coff-x86_64.c of headers.
	(PDATA_ROW_SIZE): New define.
	(pex_regs[]): New static array.
	(pex64_get_runtime_function): New static function.
	(pex64_get_unwind_info): Likewise.
	(pex64_get_scope_entry): Likewise.
	(pex64_xdata_print_uwd_codes): Likewise.
	(pep_get_section_by_rva): Likewise.
	(pex64_dump_xdata): Likewise.
	(pex64_bfd_print_pdata): Likewise.
	(bfd_pe_print_pdata): Define as pex64_bfd_print_pdata.
	* peXXigen.c (_bfd_pex64_print_pdata): Removed implementation.
	* libpei.h (_bfd_pex64_print_pdata): Removed declaration.

include/ChangeLog

2009-04-21  Kai Tietz  <kai.tietz@@onevision.com>

	* coff/pe.h (pex64_runtime_function): New structure.
	(external_pex64_runtime_function): Likewise.
	(pex64_unwind_code): Likewise.
	(external_pex64_unwind_code): Likewise.
	(pex64_unwind_info): Likewise.
	(external_pex64_unwind_info): Likewise.
	(external_pex64_scope): Likewise.
	(pex64_scope): Likewise.
	(pex64_scope_entry):  Likewise.
	(external_pex64_scope_entry): Likewise.
	(PEX64_IS_RUNTIME_FUNCTION_CHAINED): New macro.
	(PEX64_GET_UNWINDDATA_UNIFIED_RVA): Likewise.
	(PEX64_UNWCODE_CODE): Likewise.
	(PEX64_UNWCODE_INFO): Likewise.
	(UWOP_...): Add defines for unwind code.
	(UNW_FLAG_...): Add defined for unwind info flags.
	(PEX64_SCOPE_ENTRY_SIZE): New macro.
	(PEX64_UWI_VERSION): Likewise.
	(PEX64_UWI_FLAGS): Likewise.
	(PEX64_UWI_FRAMEREG): Likewise.
	(PEX64_UWI_FRAMEOFF): Likewise.
	(PEX64_UWI_SIZEOF_UWCODE_ARRAY): Likewise.
	(PEX64_OFFSET_TO_UNWIND_CODE): Likewise.
	(PEX64_OFFSET_TO_HANDLER_RVA): Likewise.
	(PEX64_OFFSET_TO_SCOPE_COUNT): Likewise.
	(PEX64_SCOPE_ENTRY): Likewise.
@
text
@a550 11
  if (pe->force_minimum_alignment)
    {
      if (!extra->FileAlignment)
	extra->FileAlignment = PE_DEF_FILE_ALIGNMENT;
      if (!extra->SectionAlignment)
	extra->SectionAlignment = PE_DEF_SECTION_ALIGNMENT;
    }

  if (extra->Subsystem == IMAGE_SUBSYSTEM_UNKNOWN)
    extra->Subsystem = pe->target_subsystem;

@


1.52
log
@2009-04-19  Peter O'Gorman  <binutils@@mlists.thewrittenword.com>
            Alan Modra  <amodra@@bigpond.net.au>
            Dave Korn  <dave.korn.cygwin@@gmail.com>

	* peXXigen.c (_bfd_XXi_swap_sym_in): Fix name handling w.r.t
	long names and non-NUL-terminated strings.
@
text
@a1905 81
#ifdef COFF_WITH_pex64
/* The PE+ x64 variant.  */
bfd_boolean
_bfd_pex64_print_pdata (bfd *abfd, void *vfile)
{
# define PDATA_ROW_SIZE	(3 * 4)
  FILE *file = (FILE *) vfile;
  bfd_byte *data = NULL;
  asection *section = bfd_get_section_by_name (abfd, ".pdata");
  bfd_size_type datasize = 0;
  bfd_size_type i;
  bfd_size_type start, stop;
  int onaline = PDATA_ROW_SIZE;
  struct sym_cache sym_cache = {0, 0};

  if (section == NULL
      || coff_section_data (abfd, section) == NULL
      || pei_section_data (abfd, section) == NULL)
    return TRUE;

  stop = pei_section_data (abfd, section)->virt_size;
  if ((stop % onaline) != 0)
    fprintf (file,
             _("warning: .pdata section size (%ld) is not a multiple of %d\n"),
	     (long) stop, onaline);

  fprintf (file,
	   _("\nThe Function Table (interpreted .pdata section contents)\n"));

  fprintf (file, _("vma:\t\t\tBeginAddress\t EndAddress\t  UnwindData\n"));

  datasize = section->size;
  if (datasize == 0)
    return TRUE;

  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }

  start = 0;

  for (i = start; i < stop; i += onaline)
    {
      bfd_vma begin_addr;
      bfd_vma end_addr;
      bfd_vma unwind_data_addr;

      if (i + PDATA_ROW_SIZE > stop)
	break;

      begin_addr = bfd_get_32 (abfd, data + i);
      end_addr = bfd_get_32 (abfd, data + i + 4);
      unwind_data_addr = bfd_get_32 (abfd, data + i +  8);

      if (begin_addr == 0 && end_addr == 0 && unwind_data_addr == 0)
	/* We are probably into the padding of the section now.  */
	break;

      fputc (' ', file);
      fprintf_vma (file, i + section->vma);
      fprintf (file, ":\t");
      fprintf_vma (file, begin_addr);
      fputc (' ', file);
      fprintf_vma (file, end_addr);
      fputc (' ', file);
      fprintf_vma (file, unwind_data_addr);

      fprintf (file, "\n");
    }

  free (data);

  cleanup_syms (&sym_cache);

  return TRUE;
#undef PDATA_ROW_SIZE
}
#endif
@


1.51
log
@bfd/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* peXXigen.c (_bfd_XX_print_private_bfd_data_common): Replace
	IMAGE_SUBSYSTEM_EFI_ROM with IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER.

binutils/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (set_pe_subsystem): Replace efi-rom with sal-rtd.
	* doc/binutils.texi: Likewise.

include/coff/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* pe.h (IMAGE_SUBSYSTEM_EFI_ROM): Renamed to ...
	(IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER): This.
@
text
@d132 3
d142 7
a148 8
	  for (sec = abfd->sections; sec; sec = sec->next)
	    {
	      if (strcmp (sec->name, in->n_name) == 0)
		{
		  in->n_scnum = sec->target_index;
		  break;
		}
	    }
a154 1
	  char *name;
d161 8
a168 4
	  name = bfd_alloc (abfd, (bfd_size_type) strlen (in->n_name) + 10);
	  if (name == NULL)
	    return;
	  strcpy (name, in->n_name);
d171 3
@


1.50
log
@bfd/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10074
	* coffcode.h (bfd_pei_p): New.

	* config.bfd: Remove bfd_efi_bsdrv_ia32_vec,
	bfd_efi_rtdrv_ia32_vec, bfd_efi_bsdrv_x86_64_vec,
	bfd_efi_rtdrv_x86_64_vec, bfd_efi_bsdrv_ia64_vec and
	bfd_efi_rtdrv_ia64_vec.  Replace bfd_efi_app_ia32_vec,
	bfd_efi_app_x86_64_vec and bfd_efi_app_ia64_vec with
	i386pei_vec, x86_64pei_vec and bfd_pei_ia64_vec, respectively.

	* configure.in: Remove bfd_efi_bsdrv_ia32_vec,
	bfd_efi_rtdrv_ia32_vec, bfd_efi_bsdrv_x86_64_vec,
	bfd_efi_rtdrv_x86_64_vec,
	bfd_efi_bsdrv_ia64_vec and bfd_efi_rtdrv_ia64_vec.  Replace
	bfd_efi_ia64_vec with bfd_pei_ia64_vec.
	* targets.c: Likewise.

	* configure: Regenerated.
	* libcoff.h: Likewise.
	* Makefile.in: Likewise.

	* efi-app-ia32.c: Removed.
	* efi-app-x86_64.c: Likewise.
	* efi-bsdrv-ia32.c: Likewise.
	* efi-bsdrv-ia64.c: Likewise.
	* efi-bsdrv-x86_64.c: Likewise.
	* efi-rtdrv-ia32.c: Likewise.
	* efi-rtdrv-ia64.c: Likewise.
	* efi-rtdrv-x86_64.c: Likewise.
	* efi-rtdrv-ia32.c: Likewise.

	* efi-app-ia64.c: Moved to ...
	* pei-ia64.c: This.
	(TARGET_SYM): Set to bfd_pei_ia64_vec.
	(TARGET_NAME): Set to pei-ia64.

	* libpei.h (bfd_target_pei_p): Removed.
	(bfd_target_pei_arch): Likewise.
	(bfd_target_efi_app_p): Likewise.
	(bfd_target_efi_app_arch): Likewise.
	(bfd_target_efi_bsdrv_p): Likewise.
	(bfd_target_efi_bsdrv_arch): Likewise.
	(bfd_target_efi_rtdrv_p): Likewise.
	(bfd_target_efi_rtdrv_arch): Likewise.
	(bfd_pe_executable_p): Likewise.

	* Makefile.am (BFD32_BACKENDS): Remove efi-app-ia32.lo,
	efi-bsdrv-ia32.lo and efi-rtdrv-ia32.lo.
	(BFD32_BACKENDS_CFILES): Remove efi-app-ia32.c, efi-bsdrv-ia32.c
	and efi-rtdrv-ia32.c.
	(BFD64_BACKENDS): Remove efi-app-ia64.lo, efi-bsdrv-ia64.lo,
	efi-rtdrv-ia64.lo, efi-app-x86_64.lo, efi-bsdrv-x86_64.lo and
	efi-rtdrv-x86_64.lo. Add pei-ia64.lo.
	(BFD64_BACKENDS_CFILES): Remove efi-app-ia64.c, efi-bsdrv-ia64.c,
	efi-rtdrv-ia64.c, efi-app-x86_64.c, efi-bsdrv-x86_64.c and
	efi-rtdrv-x86_64.c. Add pei-ia64.c.
	(efi-app-ia64.lo): Removed.
	(efi-bsdrv-ia32.lo): Likewise.
	(efi-rtdrv-ia32.lo): Likewise.
	(efi-app-ia64.lo): Likewise.
	(efi-bsdrv-ia64.lo): Likewise.
	(efi-rtdrv-ia64.lo): Likewise.
	(efi-app-x86_64.lo): Likewise.
	(efi-bsdrv-x86_64.lo): Likewise.
	(efi-rtdrv-x86_64.lo): Likewise.
	(pei-ia64.lo): New.

	* peicode.h (coff_swap_scnhdr_in): Replace bfd_pe_executable_p
	with bfd_pei_p.
	(arch_type): Removed.
	(pe_arch): Likewise.
	(pe_bfd_object_p): Just return coff_object_p.

	* peXXigen.c (_bfd_XXi_swap_scnhdr_out): Replace
	bfd_pe_executable_p with bfd_pei_p.

binutils/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10074
	* objcopy.c: Include coff/i386.h and coff/pe.h.
	(pe_file_alignment): New.
	(pe_heap_commit): Likewise.
	(pe_heap_reserve): Likewise.
	(pe_image_base): Likewise.
	(pe_section_alignment): Likewise.
	(pe_stack_commit): Likewise.
	(pe_stack_reserve): Likewise.
	(pe_subsystem): Likewise.
	(pe_major_subsystem_version): Likewise.
	(pe_minor_subsystem_version): Likewise.
	(set_pe_subsystem): Likewise.
	(convert_efi_target): Likewise.
	(command_line_switch): Add OPTION_FILE_ALIGNMENT,
	OPTION_HEAP, OPTION_IMAGE_BASE, OPTION_SECTION_ALIGNMENT,
	OPTION_STACK and OPTION_SUBSYSTEM.
	(copy_options): Likewise.
	(copy_usage): Add --file-alignment, --heap, --image-base,
	--section-alignment, --stack and --subsystem.
	(copy_object): Set up PE parameters.
	(copy_main): Process Add OPTION_FILE_ALIGNMENT,
	OPTION_HEAP, OPTION_IMAGE_BASE, OPTION_SECTION_ALIGNMENT,
	OPTION_STACK and OPTION_SUBSYSTEM.   Convert EFI target to
	PEI target.

	* NEWS: Mention --file-alignment, --heap, --image-base,
	--section-alignment, --stack and --subsystem command line
	options for objcopy.

	* doc/binutils.texi: Document --file-alignment, --heap,
	--image-base, --section-alignment, --stack and --subsystem
	command line options for objcopy.
@
text
@d2201 1
d2211 2
a2212 3
    // These are from revision 8.0 of the MS PE/COFF spec
    case IMAGE_SUBSYSTEM_EFI_ROM:
      subsystem_name = "EFI ROM";
d2214 1
@


1.49
log
@2009-04-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* coff-x86_64.c (bfd_pe_print_pdata): Defined to
	_bfd_pex64_print_pdata only if PE is defined.

	* libpei.h (_bfd_pep_print_x64_pdata): Renamed to ...
	(_bfd_pex64_print_pdata): This.

	* peXXigen.c (_bfd_pep_print_x64_pdata): Renamed to ...
	(_bfd_pex64_print_pdata): This.  Defined only if COFF_WITH_pex64
	is defined.
@
text
@d882 1
a882 1
      if (bfd_pe_executable_p (abfd))
d895 1
a895 1
      if (bfd_pe_executable_p (abfd))
@


1.48
log
@2009-04-05  Kai Tietz  <kai.tietz@@onevision.com>

        * coff-x86_64.c (bfd_pe_print_pdata): Define as
        _bfd_pep_print_x64_pdata.
        * libpei.h (_bfd_pep_print_x64_pdata): Add prototype.
        * peXXigen.c (_bfd_pep_print_x64_pdata): New.
@
text
@d1898 1
d1901 1
a1901 1
_bfd_pep_print_x64_pdata (bfd *abfd, void *vfile)
d1978 1
@


1.47
log
@	PR 9923
	* peXXigen.c (_bfd_XXi_final_link_postscript): Check h->root.type.
@
text
@d1897 80
@


1.46
log
@Silence gcc printf warnings
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008  Free Software Foundation, Inc.
d2280 3
a2282 1
      if (h1->root.u.def.section != NULL
d2299 2
d2321 2
d2340 2
d2362 3
a2364 1
      if (h1->root.u.def.section != NULL
@


1.45
log
@        * coff-sh.c (bfd_pe_print_pdata): Define to NULL for non
        COFF_WITH_PE based SH ports.
        * libpei.h (_bfd_XX_print_ce_compressed_pdata): Prototype.
        * arm-wince-pe.c (bfd_pe_print_pdata): Use
        _bfd_pe_print_ce_compressed_pdata.
        (slurp_symcache, cleanup_syms, pe_print_ce_compressed_pdata): Move
        to...
        * peXXigen.c: ... here and rename pe_print_ce_compressed_pdata to
        _bfd_XX_print_ce_compressed_pdata.
@
text
@d1313 1
a1313 1
			 (long) bfd_get_32 (abfd, ft_data + ft_idx + j));
d1345 1
a1345 1
			 (long) bfd_get_32 (abfd, ft_data + ft_idx + j));
d1964 1
a1964 1
	       (unsigned long) virtual_address, size, size, number);
d1977 1
a1977 1
		   j, off, (long) (off + virtual_address), tbl[t]);
d2067 1
a2067 1
  fprintf (file, "SizeOfCode\t\t%08lx\n", i->SizeOfCode);
d2069 1
a2069 1
	   i->SizeOfInitializedData);
d2071 1
a2071 1
	   i->SizeOfUninitializedData);
d2094 4
a2097 4
  fprintf (file, "Win32Version\t\t%08lx\n", i->Reserved1);
  fprintf (file, "SizeOfImage\t\t%08lx\n", i->SizeOfImage);
  fprintf (file, "SizeOfHeaders\t\t%08lx\n", i->SizeOfHeaders);
  fprintf (file, "CheckSum\t\t%08lx\n", i->CheckSum);
d2152 3
a2154 2
  fprintf (file, "\nLoaderFlags\t\t%08lx\n", i->LoaderFlags);
  fprintf (file, "NumberOfRvaAndSizes\t%08lx\n", i->NumberOfRvaAndSizes);
d2161 1
a2161 1
      fprintf (file, " %08lx ", i->DataDirectory[j].Size);
@


1.44
log
@        * pe-arm-wince.c (pe_print_compressed_pdata): Define new function to
        print compressed pdata structure as described on MSDN. This only
        applies to a limited set of architectures (ARM, SH4).
        (slurp_symtab, my_symbol_for_address): Define static helper
        functions for pe_print_compressed_pdata.
        * coffcode.h (bfd_coff_backend_data): Add _bfd_coff_print_pdata field.
        (bfd_coff_have_print_pdata, bfd_coff_print_pdata): Define.
        * bfd/peXXigen.c (_bfd_XX_print_private_bfd_data_common): Add check on
        bfd_coff_backend_data, call the function if non-null.
        * pei-mcore.c: Add target dependent initialisation for
        bfd_coff_backend_data.
        * coff-sh.c: Likewise.
        * coff64-rs6000.c: Likewise.
        * coff-rs6000.c: Likewise.
        * libcoff-in.h: Likewise.
        * cf-i386lynx.c: Likewise.
        * coff-alpha.c: Likewise.
        * coff-apollo.c: Likewise.
        * coff-arm.c: Likewise.
        * coff-aux.c: Likewise.
        * coff-h8300.c: Likewise.
        * coff-h8500.c: Likewise.
        * coff-i386.c: Likewise.
        * coff-i860.c: Likewise.
        * coff-i960.c: Likewise.
        * coff-ia64.c: Likewise.
        * coff-m68k.c: Likewise.
        * coff-m88k.c: Likewise.
        * coff-maxq.c: Likewise.
        * coff-mips.c: Likewise.
        * coff-or32.c: Likewise.
        * coff-sparc.c: Likewise.
        * coff-tic30.c: Likewise.
        * coff-tic4x.c: Likewise.
        * coff-tic54x.c: Likewise.
        * coff-tic80.c: Likewise.
        * coff-w65.c: Likewise.
        * coff-we32k.c: Likewise.
        * coff-x86_64.c: Likewise.
        * coff-z80.c: Likewise.
        * coff-z8k.c: Likewise.
        * pe-mcore.c: Likewise.
        * pe-mips.c: Likewise.
        * pe-ppc.c: Likewise.
        * peXXigen.c: Likewise.
        * pei-ppc.c: Likewise.
        * libcoff.h: Regenerate.
@
text
@d1591 1
a1591 2
   The version of this function to deal with compressed pdata has been
   moved to pe-arm-wince.c.  */
d1718 180
@


1.43
log
@2007-11-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/5307
	* peXXigen.c (_bfd_XX_bfd_copy_private_bfd_data_common): Don't
	copy input subsystem if output is different from input.
@
text
@d3 1
a3 1
   2005, 2006, 2007 Free Software Foundation, Inc.
d1584 9
a1592 1
   covers and the address of the corresponding unwind info data.  */
d1716 1
d1987 4
a1990 1
  pe_print_pdata (abfd, vfile);
@


1.42
log
@Switch sources over to use the GPL version 3
@
text
@d1990 2
d1997 9
a2005 2
  pe_data (obfd)->pe_opthdr = pe_data (ibfd)->pe_opthdr;
  pe_data (obfd)->dll = pe_data (ibfd)->dll;
@


1.41
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 3
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.40
log
@bfd/

2003-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4210
	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Use the virtual
	address and virtual size of the last section for the image
	size.

ld/testsuite/

2003-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4210
	* ld-pe/image_size.d: New file.
	* ld-pe/image_size.s: Likewise.
	* ld-pe/image_size.t: Likewise.

	* ld-pe/pe.exp: Run image_size.
@
text
@d3 1
a3 1
   2005, 2006 Free Software Foundation, Inc.
d59 1
a60 1
#include "sysdep.h"
@


1.39
log
@*** empty log message ***
@
text
@d648 6
a653 1
	   fix, strip munges the file.  */
d656 2
a657 1
	  isize += SA (FA (pei_section_data (abfd, sec)->virt_size));
d663 1
a663 1
    extra->SizeOfImage = SA (hsize) + isize;
@


1.38
log
@* peXXigen.c: Updates for PE/COFF V8.0, and clarification
  (dir_names): Added CLR Runtime Header to dir_names[].
  (_bfd_XX_print_private_bfd_data_common): Added EFI_ROM and XBOX subsystem names
  (_bfd_XXi_swap_aouthdr_in, _bfd_XXi_swap_aouthdr_out)
  (pe_print_idata, pe_print_edata)
  (_bfd_XX_bfd_copy_private_bfd_data_common)
  (_bfd_XXi_final_link_postscript): Use #DEFINEs for index into DataDirectory.
* pe.h: Added defines for IMAGE_SUBSYSTEM_EFI_ROM and IMAGE_SUBSYSTEM_XBOX.
* internal.h: Added defines for PE directory entry types.
  NB: in internal.h because IMAGE_NUMBEROF_DIRECTORY_ENTRYIES is in pe.h
@
text
@d391 1
a391 2
  struct internal_extra_pe_aouthdr *a;
  PEAOUTHDR * src = (PEAOUTHDR *) (aouthdr_ext1);
d393 3
a395 1
  struct internal_aouthdr *aouthdr_int = (struct internal_aouthdr *)aouthdr_int1;
d409 1
d412 8
a419 1
  a = &aouthdr_int->pe;
d1814 1
d1840 46
@


1.37
log
@Add x86_64-mingw64 target
@
text
@d487 3
a489 3
  first_thunk_address = a->DataDirectory[12].VirtualAddress;
  thunk_size = a->DataDirectory[12].Size;
  import_table_size = a->DataDirectory[1].Size;
d547 3
a549 3
  idata2 = pe->pe_opthdr.DataDirectory[1];
  idata5 = pe->pe_opthdr.DataDirectory[12];
  tls = pe->pe_opthdr.DataDirectory[9];
d599 3
a601 3
  extra->DataDirectory[1]  = idata2;
  extra->DataDirectory[12] = idata5;
  extra->DataDirectory[9] = tls;
d603 1
a603 1
  if (extra->DataDirectory[1].VirtualAddress == 0)
d1024 1
a1024 1
  N_("Reserved"),
d1058 1
a1058 1
  addr = extra->DataDirectory[1].VirtualAddress;
d1060 1
a1060 1
  if (addr == 0 && extra->DataDirectory[1].Size == 0)
d1178 1
a1178 1
      /* Print (i + extra->DataDirectory[1].VirtualAddress).  */
d1219 2
a1220 2
      
	  if (first_thunk != hint_addr) 
d1375 1
a1375 1
  addr = extra->DataDirectory[0].VirtualAddress;
d1377 1
a1377 1
  if (addr == 0 && extra->DataDirectory[0].Size == 0)
d1406 1
a1406 1
      datasize = extra->DataDirectory[0].Size;
d1876 10
d1938 2
a1939 2
      pe_data (obfd)->pe_opthdr.DataDirectory[5].VirtualAddress = 0;
      pe_data (obfd)->pe_opthdr.DataDirectory[5].Size = 0;
d2017 1
a2017 1
	pe_data (abfd)->pe_opthdr.DataDirectory[1].VirtualAddress =
d2034 1
a2034 1
	pe_data (abfd)->pe_opthdr.DataDirectory[1].Size =
d2038 1
a2038 1
	   - pe_data (abfd)->pe_opthdr.DataDirectory[1].VirtualAddress);
d2054 1
a2054 1
	pe_data (abfd)->pe_opthdr.DataDirectory[12].VirtualAddress =
d2071 1
a2071 1
	pe_data (abfd)->pe_opthdr.DataDirectory[12].Size =
d2075 1
a2075 1
	   - pe_data (abfd)->pe_opthdr.DataDirectory[12].VirtualAddress);      
d2079 1
a2079 1
	    (_("%B: unable to fill in DataDictionary[12] because .idata$6 is missing"), 
d2091 1
a2091 1
	pe_data (abfd)->pe_opthdr.DataDirectory[9].VirtualAddress =
d2104 1
a2104 1
      pe_data (abfd)->pe_opthdr.DataDirectory[9].Size = 0x18;
@


1.36
log
@PR ld/2729
* peXXigen.c (_bfd_XXi_final_link_postscript): Check for the existance of
  output sections before putting their entries into the DataDictionary.
@
text
@d55 2
a56 2
/* This expands into COFF_WITH_pe or COFF_WITH_pep depending on whether
   we're compiling for straight PE or PE+.  */
d70 3
a72 1
#ifdef COFF_WITH_pep
d82 1
a82 1
#ifdef COFF_WITH_pep
d404 1
a404 1
#ifndef COFF_WITH_pep
d447 1
d461 1
a461 1
#ifndef COFF_WITH_pep
d469 1
a469 1
#ifndef COFF_WITH_pep
d474 1
a474 1
#ifndef COFF_WITH_pep
d554 1
a554 1
#ifndef COFF_WITH_pep
d562 1
a562 1
#ifndef COFF_WITH_pep
d570 1
a570 1
#ifndef COFF_WITH_pep
d667 1
a667 1
#ifndef COFF_WITH_pep
d1268 32
d1332 1
a1332 1

d1572 2
a1573 2
#ifdef COFF_WITH_pep
# define PDATA_ROW_SIZE	(3*8)
d1575 1
a1575 1
# define PDATA_ROW_SIZE	(5*4)
d1598 1
a1598 1
#ifdef COFF_WITH_pep
d1652 1
a1652 1
#ifndef COFF_WITH_pep
@


1.35
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d1953 1
d1967 17
a1983 4
      pe_data (abfd)->pe_opthdr.DataDirectory[1].VirtualAddress =
	(h1->root.u.def.value
	 + h1->root.u.def.section->output_section->vma
	 + h1->root.u.def.section->output_offset);
d1986 15
a2000 5
      pe_data (abfd)->pe_opthdr.DataDirectory[1].Size =
	((h1->root.u.def.value
	  + h1->root.u.def.section->output_section->vma
	  + h1->root.u.def.section->output_offset)
	 - pe_data (abfd)->pe_opthdr.DataDirectory[1].VirtualAddress);
d2006 15
a2020 4
      pe_data (abfd)->pe_opthdr.DataDirectory[12].VirtualAddress =
	(h1->root.u.def.value
	 + h1->root.u.def.section->output_section->vma
	 + h1->root.u.def.section->output_offset);
d2023 15
a2037 5
      pe_data (abfd)->pe_opthdr.DataDirectory[12].Size =
	((h1->root.u.def.value
	  + h1->root.u.def.section->output_section->vma
	  + h1->root.u.def.section->output_offset)
	 - pe_data (abfd)->pe_opthdr.DataDirectory[12].VirtualAddress);      
d2044 15
a2058 5
      pe_data (abfd)->pe_opthdr.DataDirectory[9].VirtualAddress =
	(h1->root.u.def.value
	 + h1->root.u.def.section->output_section->vma
	 + h1->root.u.def.section->output_offset
	 - pe_data (abfd)->pe_opthdr.ImageBase);
d2065 1
a2065 1
  return TRUE;
@


1.34
log
@Update date in copyright notice
@
text
@d150 1
d160 2
a161 1
	  sec = bfd_make_section_anyway (abfd, name);
a173 1
	  sec->flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_DATA | SEC_LOAD;
@


1.33
log
@Add comma after HIGH3ADJ
@
text
@d3 1
a3 1
   2005 Free Software Foundation, Inc.
@


1.32
log
@* peXXigen.c (pe_print_edata): Compute the size of the export table from the
  size field in the DataDictionary and not the size of the section.  Some
  linkers embed the export table inside a larger section.
@
text
@d1671 1
a1671 1
  "HIGH3ADJ"
@


1.31
log
@	* elf.c (bfd_section_from_shdr): Fail if sh_entsize is bogus for
	symbol, relocation, group or versym sections.

	* coffcode.h (coff_slurp_reloc_table): Don't crash if native_relocs
	is NULL.
	* peXXigen.c (pe_print_idata): Don't crash if dll_name or start_address
	doesn't point into the section.
@
text
@d1349 1
d1359 4
d1364 3
a1366 4
	  datasize = section->size;

	  if (addr >= section->vma && addr < section->vma + datasize)
	    break;
d1369 3
a1371 1
      if (section == NULL)
d1374 2
a1375 1
		   _("\nThere is an export table, but the section containing it could not be found\n"));
a1382 3
  dataoff = addr - section->vma;
  datasize -= dataoff;

@


1.30
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1106 1
a1106 1
      int offset;
d1117 7
d1192 3
@


1.29
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.28
log
@Update to ISO-C90 and fix formatting
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.27
log
@update copyright dates
@
text
@a90 7

static void add_data_entry
  PARAMS ((bfd *, struct internal_extra_pe_aouthdr *, int, char *, bfd_vma));
static bfd_boolean pe_print_pdata PARAMS ((bfd *, PTR));
static bfd_boolean pe_print_reloc PARAMS ((bfd *, PTR));
static bfd_boolean pe_print_idata PARAMS ((bfd *, PTR));
static bfd_boolean pe_print_edata PARAMS ((bfd *, PTR));
a91 1

d93 1
a93 4
_bfd_XXi_swap_sym_in (abfd, ext1, in1)
     bfd *abfd;
     PTR ext1;
     PTR in1;
d170 1
a170 1
	  sec->next = (asection *) NULL;
d190 1
a190 4
_bfd_XXi_swap_sym_out (abfd, inp, extp)
     bfd       *abfd;
     PTR	inp;
     PTR	extp;
d218 7
a224 8
_bfd_XXi_swap_aux_in (abfd, ext1, type, class, indx, numaux, in1)
     bfd            *abfd;
     PTR	     ext1;
     int             type;
     int             class;
     int	     indx ATTRIBUTE_UNUSED;
     int	     numaux ATTRIBUTE_UNUSED;
     PTR 	     in1;
d289 7
a295 8
_bfd_XXi_swap_aux_out (abfd, inp, type, class, indx, numaux, extp)
     bfd  *abfd;
     PTR   inp;
     int   type;
     int   class;
     int   indx ATTRIBUTE_UNUSED;
     int   numaux ATTRIBUTE_UNUSED;
     PTR   extp;
d300 2
a301 1
  memset ((PTR) ext, 0, AUXESZ);
d363 1
a363 4
_bfd_XXi_swap_lineno_in (abfd, ext1, in1)
     bfd *abfd;
     PTR ext1;
     PTR in1;
d373 1
a373 4
_bfd_XXi_swap_lineno_out (abfd, inp, outp)
     bfd       *abfd;
     PTR	inp;
     PTR	outp;
d384 3
a386 4
_bfd_XXi_swap_aouthdr_in (abfd, aouthdr_ext1, aouthdr_int1)
     bfd *abfd;
     PTR aouthdr_ext1;
     PTR aouthdr_int1;
d389 2
a390 2
  PEAOUTHDR *src = (PEAOUTHDR *) (aouthdr_ext1);
  AOUTHDR        *aouthdr_ext = (AOUTHDR *) aouthdr_ext1;
d402 1
a402 1
  /* PE32+ does not have data_start member! */
d471 1
a471 1
  /* PE32+ does not have data_start member! */
d492 5
a496 6
add_data_entry (abfd, aout, idx, name, base)
     bfd *abfd;
     struct internal_extra_pe_aouthdr *aout;
     int idx;
     char *name;
     bfd_vma base;
d519 1
a519 4
_bfd_XXi_swap_aouthdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
d621 1
a621 1
	int rounded = FA(sec->size);
d644 1
a644 1
    extra->SizeOfImage = SA(hsize) + isize;
d715 1
a715 4
_bfd_XXi_only_swap_filehdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
d823 1
a823 4
_bfd_XX_only_swap_filehdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
d840 1
a840 4
_bfd_XXi_swap_scnhdr_out (abfd, in, out)
     bfd       *abfd;
     PTR	in;
     PTR	out;
d1005 18
a1022 18
  {
    N_("Export Directory [.edata (or where ever we found it)]"),
    N_("Import Directory [parts of .idata]"),
    N_("Resource Directory [.rsrc]"),
    N_("Exception Directory [.pdata]"),
    N_("Security Directory"),
    N_("Base Relocation Directory [.reloc]"),
    N_("Debug Directory"),
    N_("Description Directory"),
    N_("Special Directory"),
    N_("Thread Storage Directory [.tls]"),
    N_("Load Configuration Directory"),
    N_("Bound Import Directory"),
    N_("Import Address Table Directory"),
    N_("Delay Import Directory"),
    N_("Reserved"),
    N_("Reserved")
  };
d1033 1
a1033 3
pe_print_idata (abfd, vfile)
     bfd *abfd;
     PTR vfile;
d1236 1
a1236 1
		  ft_data = (bfd_byte *) bfd_malloc (datasize);
d1241 2
a1242 4
		  if (! bfd_get_section_contents (abfd, ft_section,
						  (PTR) ft_data,
						  (bfd_vma) ft_idx,
						  datasize))
d1300 1
a1300 3
pe_print_edata (abfd, vfile)
     bfd *abfd;
     PTR vfile;
d1311 1
a1311 1
    long export_flags;          /* reserved - should be zero */
d1315 7
a1321 7
    bfd_vma name;               /* rva - relative to image base */
    long base;                  /* ordinal base */
    unsigned long num_functions;/* Number in the export address table */
    unsigned long num_names;    /* Number in the name pointer table */
    bfd_vma eat_addr;		/* rva to the export address table */
    bfd_vma npt_addr;		/* rva to the Export Name Pointer Table */
    bfd_vma ot_addr;		/* rva to the Ordinal Table */
d1369 1
a1369 1
  data = (bfd_byte *) bfd_malloc (datasize);
d1373 1
a1373 1
  if (! bfd_get_section_contents (abfd, section, (PTR) data,
d1450 1
a1450 2
      } export_address_table_entry;
  */
d1520 1
a1520 3
pe_print_pdata (abfd, vfile)
     bfd *abfd;
     PTR vfile;
d1561 1
a1561 1
  if (!bfd_malloc_and_get_section (abfd, section, &data))
d1613 6
a1618 6
	     mysterious. The only one I know for sure is 0x03.  */
	  /* Code Significance                           */
	  /* 0x00 None                                   */
	  /* 0x01 Register Save Millicode                */
	  /* 0x02 Register Restore Millicode             */
	  /* 0x03 Glue Code Sequence                     */
d1645 15
a1659 15
  {
    "ABSOLUTE",
    "HIGH",
    "LOW",
    "HIGHLOW",
    "HIGHADJ",
    "MIPS_JMPADDR",
    "SECTION",
    "REL32",
    "RESERVED1",
    "MIPS_JMPADDR16",
    "DIR64",
    "HIGH3ADJ"
    "UNKNOWN",   /* MUST be last */
  };
d1662 1
a1662 3
pe_print_reloc (abfd, vfile)
     bfd *abfd;
     PTR vfile;
d1681 1
a1681 1
  if (!bfd_malloc_and_get_section (abfd, section, &data))
d1748 1
a1748 3
_bfd_XX_print_private_bfd_data_common (abfd, vfile)
     bfd *abfd;
     PTR vfile;
d1864 1
a1864 2
_bfd_XX_bfd_copy_private_bfd_data_common (ibfd, obfd)
     bfd *ibfd, *obfd;
d1887 4
a1890 5
_bfd_XX_bfd_copy_private_section_data (ibfd, isec, obfd, osec)
     bfd *ibfd;
     asection *isec;
     bfd *obfd;
     asection *osec;
d1902 1
a1902 1
	  osec->used_by_bfd = (PTR) bfd_zalloc (obfd, amt);
d1910 1
a1910 1
	  coff_section_data (obfd, osec)->tdata = (PTR) bfd_zalloc (obfd, amt);
d1925 1
a1925 4
_bfd_XX_get_symbol_info (abfd, symbol, ret)
     bfd *abfd;
     asymbol *symbol;
     symbol_info *ret;
d1934 1
a1934 3
_bfd_XXi_final_link_postscript (abfd, pfinfo)
     bfd *abfd;
     struct coff_final_link_info *pfinfo;
@


1.26
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
@


1.25
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a140 18
#if 0
      /* FIXME: This is clearly wrong.  The problem seems to be that
         undefined C_SECTION symbols appear in the first object of a
         MS generated .lib file, and the symbols are not defined
         anywhere.  */
      in->n_scnum = 1;

      /* I have tried setting the class to 3 and using the following
	 to set the section number.  This will put the address of the
	 pointer to the string kernel32.dll at addresses 0 and 0x10
	 off start of idata section which is not correct.  */
#if 0
      if (strcmp (in->_n._n_name, ".idata$4") == 0)
	in->n_scnum = 3;
      else
	in->n_scnum = 2;
#endif
#else
a189 1
#endif
a1033 8
#if 0
	  (*_bfd_error_handler) (_("%s: reloc overflow 1: 0x%lx > 0xffff"),
				 bfd_get_filename (abfd),
				 scnhdr_int->s_nreloc);
	  bfd_set_error (bfd_error_file_truncated);
	  H_PUT_16 (abfd, 0xffff, scnhdr_ext->s_nreloc);
	  ret = 0;
#endif
a1205 5
#if 0
      if (i + 20 > datasize)
	/* Check stuff.  */
	;
#endif
a1980 8
#if 0 /* This code no longer appears to be necessary.
	 ImageBase has already been added in by coff_swap_scnhdr_in.  */
  if (pe_data (abfd) != NULL
      && ((symbol->flags & BSF_DEBUGGING) == 0
	  || (symbol->flags & BSF_DEBUGGING_RELOC) != 0)
      && ! bfd_is_abs_section (symbol->section))
    ret->value += pe_data (abfd)->pe_opthdr.ImageBase;
#endif
@


1.24
log
@* coffcode.h (coff_write_object_contents) [COFF_IMAGE_WITH_PE]:
Propagate IMAGE_FILE_LARGE_ADDRESS_AWARE.
* peXXigen.c (_bfd_XX_print_private_bfd_data_common): Recognize
IMAGE_FILE_LARGE_ADDRESS_AWARE.  Use PE defines.
@
text
@d192 1
a192 2
	  sec->_cooked_size = 0;
	  sec->_raw_size = 0;
d666 1
a666 1
	int rounded = FA(sec->_raw_size);
a1110 1
  bfd_size_type amt;
d1128 1
a1128 1
      datasize = bfd_section_size (abfd, section);
d1137 1
a1137 1
	  datasize = bfd_section_size (abfd, section);
d1157 1
a1157 1
  if (rel_section != 0 && bfd_section_size (abfd, rel_section) != 0)
d1169 1
a1169 1
      bfd_byte *data = 0;
d1172 6
a1177 7
      amt = bfd_section_size (abfd, rel_section);
      data = (bfd_byte *) bfd_malloc (amt);
      if (data == NULL && amt != 0)
	return FALSE;

      bfd_get_section_contents (abfd, rel_section, (PTR) data, (bfd_vma) 0,
				amt);
d1191 2
a1208 5
  amt = dataoff + datasize;
  data = (bfd_byte *) bfd_malloc (amt);
  if (data == NULL)
    return FALSE;

d1210 6
a1215 2
  if (! bfd_get_section_contents (abfd, section, (PTR) data, (bfd_vma) 0, amt))
    return FALSE;
d1282 1
a1282 1
		  ft_datasize = bfd_section_size (abfd, ft_section);
d1412 1
a1412 1
      datasize = bfd_section_size (abfd, section);
d1422 1
a1422 1
	  datasize = bfd_section_size (abfd, section);
d1633 1
a1633 1
  datasize = bfd_section_size (abfd, section);
d1637 6
a1642 6
  data = (bfd_byte *) bfd_malloc (datasize);
  if (data == NULL && datasize != 0)
    return FALSE;

  bfd_get_section_contents (abfd, section, (PTR) data, (bfd_vma) 0,
			    datasize);
d1752 1
a1752 1
  if (bfd_section_size (abfd, section) == 0)
d1758 7
a1764 7
  datasize = bfd_section_size (abfd, section);
  data = (bfd_byte *) bfd_malloc (datasize);
  if (data == NULL && datasize != 0)
    return FALSE;

  bfd_get_section_contents (abfd, section, (PTR) data, (bfd_vma) 0,
			    datasize);
d1768 1
a1768 1
  stop = bfd_section_size (abfd, section);
@


1.23
log
@	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Use the first non-zero
	filepos for the SizeOfHeaders field.
	(_bfd_XXi_swap_scnhdr_out): Correct section flags lossage on reloc
	overflow.
	(_bfd_XXi_swap_sym_in): Remove redundant section flags assignment.
@
text
@d1844 11
a1854 10
  PF (F_RELFLG, "relocations stripped");
  PF (F_EXEC, "executable");
  PF (F_LNNO, "line numbers stripped");
  PF (F_LSYMS, "symbols stripped");
  PF (0x80, "little endian");
  PF (F_AR32WR, "32 bit words");
  PF (0x200, "debugging information removed");
  PF (0x1000, "system file");
  PF (F_DLL, "DLL");
  PF (0x8000, "big endian");
@


1.22
log
@	* peXXigen.c (_bfd_XXi_swap_scnhdr_out): Clear
	IMAGE_SCN_MEM_WRITE on known sections only.
@
text
@a200 1
	  sec->flags = 0;
d660 1
d662 1
a662 1
    bfd_vma isize = SA(abfd->sections->filepos);
d669 4
d689 2
a690 1
    extra->SizeOfImage = isize;
a692 1
  extra->SizeOfHeaders = abfd->sections->filepos;
a989 1
    int flags = scnhdr_int->s_flags;
d1004 2
a1005 2
	    flags &= ~IMAGE_SCN_MEM_WRITE;
	  flags |= p->must_have;
d1009 1
a1009 1
    H_PUT_32 (abfd, flags, scnhdr_ext->s_flags);
@


1.22.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d192 2
a193 1
	  sec->size = 0;
d201 1
a660 1
    bfd_vma hsize = 0;
d662 1
a662 1
    bfd_vma isize = 0;
d667 1
a667 1
	int rounded = FA(sec->size);
a668 4
	/* The first non-zero section filepos is the header size.
	   Sections without contents will have a filepos of 0.  */
	if (hsize == 0)
	  hsize = sec->filepos;
d685 1
a685 2
    extra->SizeOfHeaders = hsize;
    extra->SizeOfImage = SA(hsize) + isize;
d688 1
d986 1
d1001 2
a1002 2
	    scnhdr_int->s_flags &= ~IMAGE_SCN_MEM_WRITE;
	  scnhdr_int->s_flags |= p->must_have;
d1006 1
a1006 1
    H_PUT_32 (abfd, scnhdr_int->s_flags, scnhdr_ext->s_flags);
d1109 1
d1127 1
a1127 1
      datasize = section->size;
d1136 1
a1136 1
	  datasize = section->size;
d1156 1
a1156 1
  if (rel_section != 0 && rel_section->size != 0)
d1168 1
a1168 1
      bfd_byte *data;
d1171 7
a1177 6
      if (!bfd_malloc_and_get_section (abfd, rel_section, &data))
	{
	  if (data != NULL)
	    free (data);
	  return FALSE;
	}
a1190 2
      if (data != NULL)
	free (data);
d1207 5
d1213 2
a1214 6
  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }
d1281 1
a1281 1
		  ft_datasize = ft_section->size;
d1411 1
a1411 1
      datasize = section->size;
d1421 1
a1421 1
	  datasize = section->size;
d1632 1
a1632 1
  datasize = section->size;
d1636 6
a1641 6
  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }
d1751 1
a1751 1
  if (section->size == 0)
d1757 7
a1763 7
  datasize = section->size;
  if (!bfd_malloc_and_get_section (abfd, section, &data))
    {
      if (data != NULL)
	free (data);
      return FALSE;
    }
d1767 1
a1767 1
  stop = section->size;
d1841 10
a1850 11
  PF (IMAGE_FILE_RELOCS_STRIPPED, "relocations stripped");
  PF (IMAGE_FILE_EXECUTABLE_IMAGE, "executable");
  PF (IMAGE_FILE_LINE_NUMS_STRIPPED, "line numbers stripped");
  PF (IMAGE_FILE_LOCAL_SYMS_STRIPPED, "symbols stripped");
  PF (IMAGE_FILE_LARGE_ADDRESS_AWARE, "large address aware");
  PF (IMAGE_FILE_BYTES_REVERSED_LO, "little endian");
  PF (IMAGE_FILE_32BIT_MACHINE, "32 bit words");
  PF (IMAGE_FILE_DEBUG_STRIPPED, "debugging information removed");
  PF (IMAGE_FILE_SYSTEM, "system file");
  PF (IMAGE_FILE_DLL, "DLL");
  PF (IMAGE_FILE_BYTES_REVERSED_HI, "big endian");
@


1.21
log
@	* peXXigen.c (_bfd_XXi_swap_scnhdr_out): Don't remove
	IMAGE_SCN_MEM_WRITE flag from .text section if WP_TEXT
	flag has been cleared.
@
text
@a994 4
  
    if (strcmp (scnhdr_int->s_name, ".text") 
	|| (bfd_get_file_flags (abfd) & WP_TEXT))
      flags &= ~IMAGE_SCN_MEM_WRITE;
d999 3
@


1.21.6.1
log
@Merge to 2.15 branch.
@
text
@d995 4
a1002 3
	  if (strcmp (scnhdr_int->s_name, ".text")
	      || (bfd_get_file_flags (abfd) & WP_TEXT))
	    flags &= ~IMAGE_SCN_MEM_WRITE;
@


1.20
log
@Ensure that correct flags are set on known PE section types.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d988 12
a1002 4
	  /* We have defaulted to adding the IMAGE_SCN_MEM_WRITE flag, but now
	     we know exactly what this specific section wants so we remove it
	     and then allow the must_have field to add it back in if necessary.  */
	  flags &= ~IMAGE_SCN_MEM_WRITE;
@


1.19
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d946 14
a959 9
  /* Extra flags must be set when dealing with NT.  All sections should also
     have the IMAGE_SCN_MEM_READ (0x40000000) flag set.  In addition, the
     .text section must have IMAGE_SCN_MEM_EXECUTE (0x20000000) and the data
     sections (.idata, .data, .bss, .CRT) must have IMAGE_SCN_MEM_WRITE set
     (this is especially important when dealing with the .idata section since
     the addresses for routines from .dlls must be overwritten).  If .reloc
     section data is ever generated, we must add IMAGE_SCN_MEM_DISCARDABLE
     (0x02000000).  Also, the resource data should also be read and
     writable.  */
d961 23
a983 3
  /* FIXME: alignment is also encoded in this field, at least on ppc (krk) */
  /* FIXME: even worse, I don't see how to get the original alignment field*/
  /*        back...                                                        */
d985 1
a985 1
  {
d987 11
@


1.18
log
@Add initial support for TLS sections in PE format files.
@
text
@d648 1
a648 1
       .idata is needed for backwards compatability.  FIXME.  */
d972 1
a972 1
	 which is the combintion of the number_of_relocs and
@


1.17
log
@* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't calculate image size for
sections which lack size info.
@
text
@d573 1
a573 2
  IMAGE_DATA_DIRECTORY idata2, idata5;

d592 1
d644 1
d2029 13
a2041 1
  
@


1.16
log
@	* coffcode.h (coff_set_alignment_hook): With PE_COFF reloc
	overflow, set reloc start position to after the count
	reloc. Subtract one from num relocs. Give error on 0xffff relocs
	and no overflow.
	* cofflink.c (_bfd_coff_final_link): Deal with PE_COFF reloc
	overflow.
	* peXXigen.c (_bfd_XXi_swap_scnhdr_out): Do overflow if >=
	0xffff.
@
text
@d677 3
a679 1
	isize += SA (FA (pei_section_data (abfd, sec)->virt_size));
@


1.15
log
@Correct spelling of "relocatable".
@
text
@d993 5
a997 1
      if (scnhdr_int->s_nreloc <= 0xffff)
@


1.14
log
@(_bfd_XXi_swap_scnhdr_out): Compute ps and ss differently for object files and
  executables.
(coff_swap_scnhdr_in): Only set the s_size field for object files or for
  executables who have not already initialised the field.
(bfd_pe_executable_p): New macro.  Return true if the PE format bfd is an
  executable.
@
text
@d964 1
a964 1
      && ! coff_data (abfd)->link_info->relocateable
@


1.13
log
@Initialise $idata2 and $idata5 in case bfd_coff_final_link is not called.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d909 10
a918 2
      ps = scnhdr_int->s_size;
      ss = 0;
d922 5
a926 1
      ps = scnhdr_int->s_paddr;
@


1.12
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d573 1
d575 1
d591 3
a621 1

d626 1
a626 1
  /* first null out all data directory entries ..  */
a629 9

  /* Don't call add_data_entry for .idata$2 or .idata$5.  It's done in
     bfd_coff_final_link where all the required information is
     available.  */

  /* However, until other .idata fixes are made (pending patch), the
     entry for .idata is needed for backwards compatability.  FIXME.  */
  add_data_entry (abfd, extra, 1, ".idata", ib);

a630 1

d633 17
d703 1
a703 1
  /* PE32+ does not have data_start member! */
d2008 1
a2008 1
	 - pe_data (abfd)->pe_opthdr.DataDirectory[12].VirtualAddress);
d2010 1
a2010 1

@


1.11
log
@	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Correct order of memset args.
@
text
@d94 4
a97 4
static boolean pe_print_pdata PARAMS ((bfd *, PTR));
static boolean pe_print_reloc PARAMS ((bfd *, PTR));
static boolean pe_print_idata PARAMS ((bfd *, PTR));
static boolean pe_print_edata PARAMS ((bfd *, PTR));
d1019 1
a1019 1
static boolean
d1051 1
a1051 1
	return true;
d1056 1
a1056 1
	return true;
d1072 1
a1072 1
	  return true;
d1101 1
a1101 1
	return false;
d1137 1
a1137 1
    return false;
d1141 1
a1141 1
    return false;
d1293 1
a1293 1
  return true;
d1296 1
a1296 1
static boolean
d1335 1
a1335 1
	return true;
d1340 1
a1340 1
	return true;
d1358 1
a1358 1
	  return true;
d1370 1
a1370 1
    return false;
d1374 1
a1374 1
    return false;
d1511 1
a1511 1
  return true;
d1519 1
a1519 1
static boolean
d1540 1
a1540 1
    return true;
d1561 1
a1561 1
    return true;
d1565 1
a1565 1
    return false;
d1642 1
a1642 1
  return true;
d1663 1
a1663 1
static boolean
d1676 1
a1676 1
    return true;
d1679 1
a1679 1
    return true;
d1687 1
a1687 1
    return false;
d1746 1
a1746 1
  return true;
d1751 1
a1751 1
boolean
d1862 1
a1862 1
  return true;
d1868 1
a1868 1
boolean
d1875 1
a1875 1
    return true;
d1887 1
a1887 1
  return true;
d1892 1
a1892 1
boolean
d1901 1
a1901 1
    return true;
d1911 1
a1911 1
	    return false;
d1919 1
a1919 1
	    return false;
d1928 1
a1928 1
  return true;
d1951 1
a1951 1
boolean
d1968 1
a1968 1
			      ".idata$2", false, false, true);
d1976 1
a1976 1
				  ".idata$4", false, false, true);
d1986 1
a1986 1
				  ".idata$5", false, false, true);
d1992 1
a1992 1
				  ".idata$6", false, false, true);
d2003 1
a2003 1
  return true;
@


1.11.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d94 4
a97 4
static bfd_boolean pe_print_pdata PARAMS ((bfd *, PTR));
static bfd_boolean pe_print_reloc PARAMS ((bfd *, PTR));
static bfd_boolean pe_print_idata PARAMS ((bfd *, PTR));
static bfd_boolean pe_print_edata PARAMS ((bfd *, PTR));
d573 1
a573 2
  IMAGE_DATA_DIRECTORY idata2, idata5, tls;
  
a588 4
  idata2 = pe->pe_opthdr.DataDirectory[1];
  idata5 = pe->pe_opthdr.DataDirectory[12];
  tls = pe->pe_opthdr.DataDirectory[9];
  
d617 1
d622 1
a622 1
  /* First null out all data directory entries.  */
d626 9
d636 1
a638 18
  /* In theory we do not need to call add_data_entry for .idata$2 or
     .idata$5.  It will be done in bfd_coff_final_link where all the
     required information is available.  If however, we are not going
     to perform a final link, eg because we have been invoked by objcopy
     or strip, then we need to make sure that these Data Directory
     entries are initialised properly.

     So - we copy the input values into the output values, and then, if
     a final link is going to be performed, it can overwrite them.  */
  extra->DataDirectory[1]  = idata2;
  extra->DataDirectory[12] = idata5;
  extra->DataDirectory[9] = tls;

  if (extra->DataDirectory[1].VirtualAddress == 0)
    /* Until other .idata fixes are made (pending patch), the entry for
       .idata is needed for backwards compatibility.  FIXME.  */
    add_data_entry (abfd, extra, 1, ".idata", ib);
    
d666 1
a666 3
	if (coff_section_data (abfd, sec) != NULL
	    && pei_section_data (abfd, sec) != NULL)
	  isize += SA (FA (pei_section_data (abfd, sec)->virt_size));
d692 1
a692 1
  /* PE32+ does not have data_start member!  */
d898 2
a899 10
      if (bfd_pe_executable_p (abfd))
	{
	  ps = scnhdr_int->s_size;
	  ss = 0;
	}
      else
       {
         ps = 0;
         ss = scnhdr_int->s_size;
       }
d903 1
a903 5
      if (bfd_pe_executable_p (abfd))
	ps = scnhdr_int->s_paddr;
      else
	ps = 0;

d941 1
a941 1
      && ! coff_data (abfd)->link_info->relocatable
d946 1
a946 1
	 which is the combination of the number_of_relocs and
d970 1
a970 5
      /* Although we could encode 0xffff relocs here, we do not, to be
         consistent with other parts of bfd. Also it lets us warn, as
         we should never see 0xffff here w/o having the overflow flag
         set.  */
      if (scnhdr_int->s_nreloc < 0xffff)
d1019 1
a1019 1
static bfd_boolean
d1051 1
a1051 1
	return TRUE;
d1056 1
a1056 1
	return TRUE;
d1072 1
a1072 1
	  return TRUE;
d1101 1
a1101 1
	return FALSE;
d1137 1
a1137 1
    return FALSE;
d1141 1
a1141 1
    return FALSE;
d1293 1
a1293 1
  return TRUE;
d1296 1
a1296 1
static bfd_boolean
d1335 1
a1335 1
	return TRUE;
d1340 1
a1340 1
	return TRUE;
d1358 1
a1358 1
	  return TRUE;
d1370 1
a1370 1
    return FALSE;
d1374 1
a1374 1
    return FALSE;
d1511 1
a1511 1
  return TRUE;
d1519 1
a1519 1
static bfd_boolean
d1540 1
a1540 1
    return TRUE;
d1561 1
a1561 1
    return TRUE;
d1565 1
a1565 1
    return FALSE;
d1642 1
a1642 1
  return TRUE;
d1663 1
a1663 1
static bfd_boolean
d1676 1
a1676 1
    return TRUE;
d1679 1
a1679 1
    return TRUE;
d1687 1
a1687 1
    return FALSE;
d1746 1
a1746 1
  return TRUE;
d1751 1
a1751 1
bfd_boolean
d1862 1
a1862 1
  return TRUE;
d1868 1
a1868 1
bfd_boolean
d1875 1
a1875 1
    return TRUE;
d1887 1
a1887 1
  return TRUE;
d1892 1
a1892 1
bfd_boolean
d1901 1
a1901 1
    return TRUE;
d1911 1
a1911 1
	    return FALSE;
d1919 1
a1919 1
	    return FALSE;
d1928 1
a1928 1
  return TRUE;
d1951 1
a1951 1
bfd_boolean
d1968 1
a1968 1
			      ".idata$2", FALSE, FALSE, TRUE);
d1976 1
a1976 1
				  ".idata$4", FALSE, FALSE, TRUE);
d1986 1
a1986 1
				  ".idata$5", FALSE, FALSE, TRUE);
d1992 1
a1992 1
				  ".idata$6", FALSE, FALSE, TRUE);
d1997 1
a1997 13
	 - pe_data (abfd)->pe_opthdr.DataDirectory[12].VirtualAddress);      
    }

  h1 = coff_link_hash_lookup (coff_hash_table (info),
			      "__tls_used", FALSE, FALSE, TRUE);
  if (h1 != NULL)
    {
      pe_data (abfd)->pe_opthdr.DataDirectory[9].VirtualAddress =
	(h1->root.u.def.value
	 + h1->root.u.def.section->output_section->vma
	 + h1->root.u.def.section->output_offset
	 - pe_data (abfd)->pe_opthdr.ImageBase);
      pe_data (abfd)->pe_opthdr.DataDirectory[9].Size = 0x18;
d2003 1
a2003 1
  return TRUE;
@


1.11.12.2
log
@Merge from mainline.
@
text
@d946 9
a954 10
  {
    /* Extra flags must be set when dealing with PE.  All sections should also
       have the IMAGE_SCN_MEM_READ (0x40000000) flag set.  In addition, the
       .text section must have IMAGE_SCN_MEM_EXECUTE (0x20000000) and the data
       sections (.idata, .data, .bss, .CRT) must have IMAGE_SCN_MEM_WRITE set
       (this is especially important when dealing with the .idata section since
       the addresses for routines from .dlls must be overwritten).  If .reloc
       section data is ever generated, we must add IMAGE_SCN_MEM_DISCARDABLE
       (0x02000000).  Also, the resource data should also be read and
       writable.  */
d956 3
a958 3
    /* FIXME: Alignment is also encoded in this field, at least on PPC and 
       ARM-WINCE.  Although - how do we get the original alignment field
       back ?  */
d960 1
a960 25
    typedef struct
    {
      const char * 	section_name;
      unsigned long	must_have;
    }
    pe_required_section_flags;
    
    pe_required_section_flags known_sections [] =
      {
	{ ".arch",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_ALIGN_8BYTES },
	{ ".bss",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".data",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".edata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".idata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".pdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".rdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".reloc", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE },
	{ ".rsrc",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".text" , IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE },
	{ ".tls",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".xdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ NULL, 0}
      };

    pe_required_section_flags * p;
a961 11

    for (p = known_sections; p->section_name; p++)
      if (strcmp (scnhdr_int->s_name, p->section_name) == 0)
	{
	  /* We have defaulted to adding the IMAGE_SCN_MEM_WRITE flag, but now
	     we know exactly what this specific section wants so we remove it
	     and then allow the must_have field to add it back in if necessary.  */
	  flags &= ~IMAGE_SCN_MEM_WRITE;
	  flags |= p->must_have;
	  break;
	}
@


1.11.12.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a987 12
    /* We have defaulted to adding the IMAGE_SCN_MEM_WRITE flag, but now
       we know exactly what this specific section wants so we remove it
       and then allow the must_have field to add it back in if necessary.
       However, we don't remove IMAGE_SCN_MEM_WRITE flag from .text if the
       default WP_TEXT file flag has been cleared.  WP_TEXT may be cleared
       by ld --enable-auto-import (if auto-import is actually needed),
       by ld --omagic, or by obcopy --writable-text.  */
  
    if (strcmp (scnhdr_int->s_name, ".text") 
	|| (bfd_get_file_flags (abfd) & WP_TEXT))
      flags &= ~IMAGE_SCN_MEM_WRITE;

d991 4
@


1.11.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d94 4
a97 4
static bfd_boolean pe_print_pdata PARAMS ((bfd *, PTR));
static bfd_boolean pe_print_reloc PARAMS ((bfd *, PTR));
static bfd_boolean pe_print_idata PARAMS ((bfd *, PTR));
static bfd_boolean pe_print_edata PARAMS ((bfd *, PTR));
d1019 1
a1019 1
static bfd_boolean
d1051 1
a1051 1
	return TRUE;
d1056 1
a1056 1
	return TRUE;
d1072 1
a1072 1
	  return TRUE;
d1101 1
a1101 1
	return FALSE;
d1137 1
a1137 1
    return FALSE;
d1141 1
a1141 1
    return FALSE;
d1293 1
a1293 1
  return TRUE;
d1296 1
a1296 1
static bfd_boolean
d1335 1
a1335 1
	return TRUE;
d1340 1
a1340 1
	return TRUE;
d1358 1
a1358 1
	  return TRUE;
d1370 1
a1370 1
    return FALSE;
d1374 1
a1374 1
    return FALSE;
d1511 1
a1511 1
  return TRUE;
d1519 1
a1519 1
static bfd_boolean
d1540 1
a1540 1
    return TRUE;
d1561 1
a1561 1
    return TRUE;
d1565 1
a1565 1
    return FALSE;
d1642 1
a1642 1
  return TRUE;
d1663 1
a1663 1
static bfd_boolean
d1676 1
a1676 1
    return TRUE;
d1679 1
a1679 1
    return TRUE;
d1687 1
a1687 1
    return FALSE;
d1746 1
a1746 1
  return TRUE;
d1751 1
a1751 1
bfd_boolean
d1862 1
a1862 1
  return TRUE;
d1868 1
a1868 1
bfd_boolean
d1875 1
a1875 1
    return TRUE;
d1887 1
a1887 1
  return TRUE;
d1892 1
a1892 1
bfd_boolean
d1901 1
a1901 1
    return TRUE;
d1911 1
a1911 1
	    return FALSE;
d1919 1
a1919 1
	    return FALSE;
d1928 1
a1928 1
  return TRUE;
d1951 1
a1951 1
bfd_boolean
d1968 1
a1968 1
			      ".idata$2", FALSE, FALSE, TRUE);
d1976 1
a1976 1
				  ".idata$4", FALSE, FALSE, TRUE);
d1986 1
a1986 1
				  ".idata$5", FALSE, FALSE, TRUE);
d1992 1
a1992 1
				  ".idata$6", FALSE, FALSE, TRUE);
d2003 1
a2003 1
  return TRUE;
@


1.11.10.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a572 1
  IMAGE_DATA_DIRECTORY idata2, idata5;
a573 1
  
a588 3
  idata2 = pe->pe_opthdr.DataDirectory[1];
  idata5 = pe->pe_opthdr.DataDirectory[12];
  
d617 1
d622 1
a622 1
  /* First null out all data directory entries.  */
d626 9
d636 1
a638 17
  /* In theory we do not need to call add_data_entry for .idata$2 or
     .idata$5.  It will be done in bfd_coff_final_link where all the
     required information is available.  If however, we are not going
     to perform a final link, eg because we have been invoked by objcopy
     or strip, then we need to make sure that these Data Directory
     entries are initialised properly.

     So - we copy the input values into the output values, and then, if
     a final link is going to be performed, it can overwrite them.  */
  extra->DataDirectory[1]  = idata2;
  extra->DataDirectory[12] = idata5;

  if (extra->DataDirectory[1].VirtualAddress == 0)
    /* Until other .idata fixes are made (pending patch), the entry for
       .idata is needed for backwards compatability.  FIXME.  */
    add_data_entry (abfd, extra, 1, ".idata", ib);
    
d692 1
a692 1
  /* PE32+ does not have data_start member!  */
d898 2
a899 10
      if (bfd_pe_executable_p (abfd))
	{
	  ps = scnhdr_int->s_size;
	  ss = 0;
	}
      else
       {
         ps = 0;
         ss = scnhdr_int->s_size;
       }
d903 1
a903 5
      if (bfd_pe_executable_p (abfd))
	ps = scnhdr_int->s_paddr;
      else
	ps = 0;

d1997 1
a1997 1
	 - pe_data (abfd)->pe_opthdr.DataDirectory[12].VirtualAddress);      
d1999 1
a1999 1
  
@


1.11.10.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d964 1
a964 1
      && ! coff_data (abfd)->link_info->relocatable
@


1.11.10.4
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d573 2
a574 1
  IMAGE_DATA_DIRECTORY idata2, idata5, tls;
a592 1
  tls = pe->pe_opthdr.DataDirectory[9];
a643 1
  extra->DataDirectory[9] = tls;
d677 1
a677 3
	if (coff_section_data (abfd, sec) != NULL
	    && pei_section_data (abfd, sec) != NULL)
	  isize += SA (FA (pei_section_data (abfd, sec)->virt_size));
d993 1
a993 5
      /* Although we could encode 0xffff relocs here, we do not, to be
         consistent with other parts of bfd. Also it lets us warn, as
         we should never see 0xffff here w/o having the overflow flag
         set.  */
      if (scnhdr_int->s_nreloc < 0xffff)
d2022 1
a2022 13

  h1 = coff_link_hash_lookup (coff_hash_table (info),
			      "__tls_used", FALSE, FALSE, TRUE);
  if (h1 != NULL)
    {
      pe_data (abfd)->pe_opthdr.DataDirectory[9].VirtualAddress =
	(h1->root.u.def.value
	 + h1->root.u.def.section->output_section->vma
	 + h1->root.u.def.section->output_offset
	 - pe_data (abfd)->pe_opthdr.ImageBase);
      pe_data (abfd)->pe_opthdr.DataDirectory[9].Size = 0x18;
    }

@


1.11.10.5
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d648 1
a648 1
       .idata is needed for backwards compatibility.  FIXME.  */
d946 14
a960 39
    /* Extra flags must be set when dealing with PE.  All sections should also
       have the IMAGE_SCN_MEM_READ (0x40000000) flag set.  In addition, the
       .text section must have IMAGE_SCN_MEM_EXECUTE (0x20000000) and the data
       sections (.idata, .data, .bss, .CRT) must have IMAGE_SCN_MEM_WRITE set
       (this is especially important when dealing with the .idata section since
       the addresses for routines from .dlls must be overwritten).  If .reloc
       section data is ever generated, we must add IMAGE_SCN_MEM_DISCARDABLE
       (0x02000000).  Also, the resource data should also be read and
       writable.  */

    /* FIXME: Alignment is also encoded in this field, at least on PPC and 
       ARM-WINCE.  Although - how do we get the original alignment field
       back ?  */

    typedef struct
    {
      const char * 	section_name;
      unsigned long	must_have;
    }
    pe_required_section_flags;
    
    pe_required_section_flags known_sections [] =
      {
	{ ".arch",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE | IMAGE_SCN_ALIGN_8BYTES },
	{ ".bss",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_UNINITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".data",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".edata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".idata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".pdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".rdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ ".reloc", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_DISCARDABLE },
	{ ".rsrc",  IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".text" , IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE },
	{ ".tls",   IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_WRITE },
	{ ".xdata", IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA },
	{ NULL, 0}
      };

    pe_required_section_flags * p;
a962 11
    for (p = known_sections; p->section_name; p++)
      if (strcmp (scnhdr_int->s_name, p->section_name) == 0)
	{
	  /* We have defaulted to adding the IMAGE_SCN_MEM_WRITE flag, but now
	     we know exactly what this specific section wants so we remove it
	     and then allow the must_have field to add it back in if necessary.  */
	  flags &= ~IMAGE_SCN_MEM_WRITE;
	  flags |= p->must_have;
	  break;
	}

d972 1
a972 1
	 which is the combination of the number_of_relocs and
@


1.11.10.6
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
a987 12
    /* We have defaulted to adding the IMAGE_SCN_MEM_WRITE flag, but now
       we know exactly what this specific section wants so we remove it
       and then allow the must_have field to add it back in if necessary.
       However, we don't remove IMAGE_SCN_MEM_WRITE flag from .text if the
       default WP_TEXT file flag has been cleared.  WP_TEXT may be cleared
       by ld --enable-auto-import (if auto-import is actually needed),
       by ld --omagic, or by obcopy --writable-text.  */
  
    if (strcmp (scnhdr_int->s_name, ".text") 
	|| (bfd_get_file_flags (abfd) & WP_TEXT))
      flags &= ~IMAGE_SCN_MEM_WRITE;

d991 4
@


1.10
log
@	* peXXigen.c (pe_print_idata): Remove unused variable.
@
text
@d623 1
a623 1
  memset (extra->DataDirectory, sizeof (extra->DataDirectory), 0);
@


1.10.2.1
log
@	* config/tc-z8k.c (build_bytes): Correct order of memset args.
@
text
@d623 1
a623 1
  memset (extra->DataDirectory, 0, sizeof (extra->DataDirectory));
@


1.9
log
@Remove double printed import table lines; add Bound-To comment.
@
text
@a1189 1
	  int differ = 0;
@


1.8
log
@* peXXigen.c (pe_print_idata): Fix seg faults on printing import tables with
auto-imported symbols.
@
text
@d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d1145 1
a1145 1
  /* print all image import descriptors */ 
d1157 1
a1157 1
      /* print (i + extra->DataDirectory[1].VirtualAddress)  */
d1193 1
a1193 1
	  fprintf (file, _("\tvma:  Hint/Ord Member-Name\n"));
d1196 2
a1197 2

		ft_addr = first_thunk + extra->ImageBase;
d1237 4
a1240 1
		  if (! bfd_get_section_contents (abfd, ft_section, (PTR) ft_data, (bfd_vma) ft_idx, datasize))
d1250 2
a1251 1
	  /* print HintName vector entries */ 
d1256 1
a1256 1
	      /* print single IMAGE_IMPORT_BY_NAME vector */ 
d1259 1
d1261 2
a1262 2
		fprintf (file, "\t%04lx\t %4lu", member,
	       member & 0x7fffffff);
d1273 1
a1273 1
	
d1275 4
a1278 2
		       table holds actual addresses. */
	      if (time_stamp != 0 && first_thunk != 0 && first_thunk != hint_addr)
a1283 44

	  for (j = 0; j < datasize; j += 4)
	    {
	      int ordinal;
	      char *member_name;
	      bfd_vma hint_member = 0;
	      bfd_vma iat_member;

	      if (hint_addr != 0)
		hint_member = bfd_get_32 (abfd, data + idx + j);
	      iat_member = bfd_get_32 (abfd, ft_data + ft_idx + j);

	      if (hint_addr == 0 && iat_member == 0)
		break;

	      if (hint_addr == 0 || hint_member != iat_member)
		{
		  if (differ == 0)
		    {
		      fprintf (file,
			       _("\tThe Import Address Table (difference found)\n"));
		      fprintf (file, _("\tvma:  Hint/Ord Member-Name\n"));
		      differ = 1;
		    }

		  if (iat_member == 0)
		    fprintf (file,
			     _("\t>>> Ran out of IAT members!\n"));

		  else if (hint_member != 0)
		    {
		      ordinal = bfd_get_16 (abfd, data + hint_member - adj);
		      member_name = (char *) data + hint_member - adj + 2;
		      fprintf (file, "\t%04lx\t %4d  %s\n",
			       (unsigned long) iat_member, ordinal, member_name);
		    }
		}

	      if (hint_addr != 0 && hint_member == 0)
		break;
	    }

	  if (differ == 0)
	    fprintf (file, _("\tThe Import Address Table is identical\n"));
@


1.7
log
@Do not assume that the first thunk is located in the same section as the
import table.  Instead check, and if necessary load the section containing
the thunk.
@
text
@d1145 1
d1185 8
d1197 51
d1252 1
d1257 1
a1257 1
			 member & 0x7fffffff);
d1268 1
a1268 1

d1270 2
a1271 4
                 table holds actual addresses.  */
	      if (time_stamp != 0
		  && first_thunk != 0
		  && first_thunk != hint_addr)
d1273 1
a1273 1
			 (long) bfd_get_32 (abfd, data + first_thunk - adj + j));
a1276 56
	}

      if (hint_addr != first_thunk && time_stamp == 0)
	{
          bfd_byte *ft_data;
	  asection *ft_section;
	  bfd_vma ft_addr;
	  bfd_size_type ft_datasize;
	  int ft_idx;
	  int differ = 0;
	  int ft_allocated = 0;

          ft_addr = first_thunk + extra->ImageBase;

	  /* Find the section which contains the first thunk.  */
	  for (ft_section = abfd->sections;
	       ft_section != NULL;
	       ft_section = ft_section->next)
	    {
	      ft_datasize = bfd_section_size (abfd, ft_section);
	      if (ft_addr >= ft_section->vma
		  && ft_addr < ft_section->vma + ft_datasize)
		break;
	    }

	  if (ft_section == NULL)
	    {
	      fprintf (file,
		   _("\nThere is a first thunk, but the section containing it could not be found\n"));
	      continue;
	    }

	  /* Now check to see if this section is the same as our current
	     section.  If it is not then we will have to load its data in.  */
	  if (ft_section == section)
	    {
	      ft_data = data;
              ft_idx = first_thunk - adj;
	    }
	  else
	    {
              ft_idx = first_thunk - (ft_section->vma - extra->ImageBase);
	      ft_data = (bfd_byte *) bfd_malloc (datasize);
	      if (ft_data == NULL)
		continue;

	      /* Read datasize bfd_bytes starting at offset ft_idx.  */
	      if (! bfd_get_section_contents (abfd, ft_section, (PTR) ft_data, (bfd_vma) ft_idx, datasize))
		{
		  free (ft_data);
		  continue;
		}

	      ft_idx = 0;
	      ft_allocated = 1;
	    }
d1305 2
a1306 1
		  else
d1308 2
a1309 2
		      ordinal = bfd_get_16 (abfd, data + iat_member - adj);
		      member_name = (char *) data + iat_member - adj + 2;
d1311 1
a1311 3
			      (unsigned long) iat_member,
			      ordinal,
			      member_name);
d1320 1
a1320 2
	    fprintf (file,
		     _("\tThe Import Address Table is identical\n"));
@


1.7.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a1144 1
  /* Print all image import descriptors.  */
d1156 1
a1156 1
      /* Print (i + extra->DataDirectory[1].VirtualAddress).  */
d1184 1
a1184 8
	  bfd_byte *ft_data;
	  asection *ft_section;
	  bfd_vma ft_addr;
	  bfd_size_type ft_datasize;
	  int ft_idx;
	  int ft_allocated = 0;

	  fprintf (file, _("\tvma:  Hint/Ord Member-Name Bound-To\n"));
a1186 49
	  
	  ft_addr = first_thunk + extra->ImageBase;
	  ft_data = data;
	  ft_idx = first_thunk - adj;
	  ft_allocated = 0; 
      
	  if (first_thunk != hint_addr) 
	    {
	      /* Find the section which contains the first thunk.  */
	      for (ft_section = abfd->sections;
		   ft_section != NULL;
		   ft_section = ft_section->next)
		{
		  ft_datasize = bfd_section_size (abfd, ft_section);
		  if (ft_addr >= ft_section->vma
		      && ft_addr < ft_section->vma + ft_datasize)
		    break;
		}

	      if (ft_section == NULL)
		{
		  fprintf (file,
		       _("\nThere is a first thunk, but the section containing it could not be found\n"));
		  continue;
		}

	      /* Now check to see if this section is the same as our current
		 section.  If it is not then we will have to load its data in.  */
	      if (ft_section == section)
		{
		  ft_data = data;
		  ft_idx = first_thunk - adj;
		}
	      else
		{
		  ft_idx = first_thunk - (ft_section->vma - extra->ImageBase);
		  ft_data = (bfd_byte *) bfd_malloc (datasize);
		  if (ft_data == NULL)
		    continue;

		  /* Read datasize bfd_bytes starting at offset ft_idx.  */
		  if (! bfd_get_section_contents (abfd, ft_section,
						  (PTR) ft_data,
						  (bfd_vma) ft_idx,
						  datasize))
		    {
		      free (ft_data);
		      continue;
		    }
a1187 6
		  ft_idx = 0;
		  ft_allocated = 1;
		}
	    }

	  /* Print HintName vector entries.  */
a1191 1
	      /* Print single IMAGE_IMPORT_BY_NAME vector.  */ 
a1193 1

d1195 2
a1196 2
		fprintf (file, "\t%04lx\t %4lu  <none>",
			 member, member & 0x7fffffff);
d1209 1
a1209 1
		 table holds actual addresses.  */
d1214 1
a1214 1
			 (long) bfd_get_32 (abfd, ft_data + ft_idx + j));
d1218 102
@


1.7.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d623 1
a623 1
  memset (extra->DataDirectory, 0, sizeof (extra->DataDirectory));
@


1.6
log
@Fixes for better translation into other languages
@
text
@d1222 5
d1228 1
a1228 1
	  int idx2;
d1230 44
a1273 1
	  idx2 = first_thunk - adj;
d1284 1
a1284 1
	      iat_member = bfd_get_32 (abfd, data + idx2 + j);
d1320 3
@


1.6.8.1
log
@merge from trunk
@
text
@d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a1144 1
  /* Print all image import descriptors.  */
d1156 1
a1156 1
      /* Print (i + extra->DataDirectory[1].VirtualAddress).  */
d1184 1
a1184 8
	  bfd_byte *ft_data;
	  asection *ft_section;
	  bfd_vma ft_addr;
	  bfd_size_type ft_datasize;
	  int ft_idx;
	  int ft_allocated = 0;

	  fprintf (file, _("\tvma:  Hint/Ord Member-Name Bound-To\n"));
a1186 25
	  
	  ft_addr = first_thunk + extra->ImageBase;
	  ft_data = data;
	  ft_idx = first_thunk - adj;
	  ft_allocated = 0; 
      
	  if (first_thunk != hint_addr) 
	    {
	      /* Find the section which contains the first thunk.  */
	      for (ft_section = abfd->sections;
		   ft_section != NULL;
		   ft_section = ft_section->next)
		{
		  ft_datasize = bfd_section_size (abfd, ft_section);
		  if (ft_addr >= ft_section->vma
		      && ft_addr < ft_section->vma + ft_datasize)
		    break;
		}

	      if (ft_section == NULL)
		{
		  fprintf (file,
		       _("\nThere is a first thunk, but the section containing it could not be found\n"));
		  continue;
		}
a1187 30
	      /* Now check to see if this section is the same as our current
		 section.  If it is not then we will have to load its data in.  */
	      if (ft_section == section)
		{
		  ft_data = data;
		  ft_idx = first_thunk - adj;
		}
	      else
		{
		  ft_idx = first_thunk - (ft_section->vma - extra->ImageBase);
		  ft_data = (bfd_byte *) bfd_malloc (datasize);
		  if (ft_data == NULL)
		    continue;

		  /* Read datasize bfd_bytes starting at offset ft_idx.  */
		  if (! bfd_get_section_contents (abfd, ft_section,
						  (PTR) ft_data,
						  (bfd_vma) ft_idx,
						  datasize))
		    {
		      free (ft_data);
		      continue;
		    }

		  ft_idx = 0;
		  ft_allocated = 1;
		}
	    }

	  /* Print HintName vector entries.  */
a1191 1
	      /* Print single IMAGE_IMPORT_BY_NAME vector.  */ 
a1193 1

d1195 2
a1196 2
		fprintf (file, "\t%04lx\t %4lu  <none>",
			 member, member & 0x7fffffff);
d1209 1
a1209 1
		 table holds actual addresses.  */
d1214 1
a1214 1
			 (long) bfd_get_32 (abfd, ft_data + ft_idx + j));
d1218 50
d1269 3
a1271 2
	  if (ft_allocated)
	    free (ft_data);
@


1.5
log
@        * peXXigen.c (_bfd_XX_print_private_bfd_data_common): Copy
        timestamp to time_t for ctime.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
d25 1
a25 2
					  Softway Systems, Inc.
*/
d53 1
a53 2
   wasting too much time.
*/
d1130 3
a1132 3
	   _(" vma:            Hint    Time      Forward  DLL       First\n"));
  fprintf (file,
	   _("                 Table   Stamp     Chain    Name      Thunk\n"));
d1540 3
a1542 4
  fprintf (file,
	   _(" vma:\t\tBegin    End      EH       EH       PrologEnd  Exception\n"));
  fprintf (file,
	   _("     \t\tAddress  Address  Handler  Data     Address    Mask\n"));
@


1.4
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1770 4
a1773 1
  fprintf (file, "\nTime/Date\t\t%s", ctime (&pe->coff.timestamp));
@


1.3
log
@Add missing protypes
@
text
@d114 1
a114 2
      in->_n._n_n._n_offset =
	bfd_h_get_32 (abfd, (bfd_byte *) ext->e.e.e_offset);
d119 2
a120 2
  in->n_value = bfd_h_get_32 (abfd, (bfd_byte *) ext->e_value);
  in->n_scnum = bfd_h_get_16 (abfd, (bfd_byte *) ext->e_scnum);
d123 1
a123 1
    in->n_type = bfd_h_get_16 (abfd, (bfd_byte *) ext->e_type);
d125 1
a125 1
    in->n_type = bfd_h_get_32 (abfd, (bfd_byte *) ext->e_type);
d127 2
a128 2
  in->n_sclass = bfd_h_get_8 (abfd, ext->e_sclass);
  in->n_numaux = bfd_h_get_8 (abfd, ext->e_numaux);
d186 1
a186 1
	  name = bfd_alloc (abfd, strlen (in->n_name) + 10);
d234 2
a235 2
      bfd_h_put_32 (abfd, 0, (bfd_byte *) ext->e.e.e_zeroes);
      bfd_h_put_32 (abfd, in->_n._n_n._n_offset, (bfd_byte *) ext->e.e.e_offset);
d240 2
a241 2
  bfd_h_put_32 (abfd, in->n_value, (bfd_byte *) ext->e_value);
  bfd_h_put_16 (abfd, in->n_scnum, (bfd_byte *) ext->e_scnum);
d244 1
a244 1
    bfd_h_put_16 (abfd, in->n_type, (bfd_byte *) ext->e_type);
d246 1
a246 1
    bfd_h_put_32 (abfd, in->n_type, (bfd_byte *) ext->e_type);
d248 2
a249 2
  bfd_h_put_8 (abfd, in->n_sclass, ext->e_sclass);
  bfd_h_put_8 (abfd, in->n_numaux, ext->e_numaux);
d273 1
a273 2
	  in->x_file.x_n.x_offset =
	    bfd_h_get_32 (abfd, (bfd_byte *) ext->x_file.x_n.x_offset);
d287 3
a289 6
	  in->x_scn.x_checksum =
	    bfd_h_get_32 (abfd, (bfd_byte *) ext->x_scn.x_checksum);
	  in->x_scn.x_associated =
	    bfd_h_get_16 (abfd, (bfd_byte *) ext->x_scn.x_associated);
	  in->x_scn.x_comdat =
	    bfd_h_get_8 (abfd, (bfd_byte *) ext->x_scn.x_comdat);
d295 2
a296 2
  in->x_sym.x_tagndx.l = bfd_h_get_32 (abfd, (bfd_byte *) ext->x_sym.x_tagndx);
  in->x_sym.x_tvndx = bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_tvndx);
d306 1
a306 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
d308 1
a308 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
d310 1
a310 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
d312 1
a312 1
	bfd_h_get_16 (abfd, (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
d317 1
a317 2
      in->x_sym.x_misc.x_fsize =
	bfd_h_get_32 (abfd, (bfd_byte *) ext->x_sym.x_misc.x_fsize);
d345 2
a346 4
	  bfd_h_put_32 (abfd, 0, (bfd_byte *) ext->x_file.x_n.x_zeroes);
	  bfd_h_put_32 (abfd,
			in->x_file.x_n.x_offset,
			(bfd_byte *) ext->x_file.x_n.x_offset);
d361 3
a363 6
	  bfd_h_put_32 (abfd, in->x_scn.x_checksum,
			(bfd_byte *) ext->x_scn.x_checksum);
	  bfd_h_put_16 (abfd, in->x_scn.x_associated,
			(bfd_byte *) ext->x_scn.x_associated);
	  bfd_h_put_8 (abfd, in->x_scn.x_comdat,
		       (bfd_byte *) ext->x_scn.x_comdat);
d369 2
a370 2
  bfd_h_put_32 (abfd, in->x_sym.x_tagndx.l, (bfd_byte *) ext->x_sym.x_tagndx);
  bfd_h_put_16 (abfd, in->x_sym.x_tvndx, (bfd_byte *) ext->x_sym.x_tvndx);
d379 8
a386 8
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[0],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[0]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[1],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[1]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[2],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[2]);
      bfd_h_put_16 (abfd, in->x_sym.x_fcnary.x_ary.x_dimen[3],
		    (bfd_byte *) ext->x_sym.x_fcnary.x_ary.x_dimen[3]);
d390 1
a390 2
    bfd_h_put_32 (abfd, in->x_sym.x_misc.x_fsize,
		  (bfd_byte *) ext->x_sym.x_misc.x_fsize);
d409 1
a409 1
  in->l_addr.l_symndx = bfd_h_get_32 (abfd, (bfd_byte *) ext->l_addr.l_symndx);
d421 1
a421 2
  bfd_h_put_32 (abfd, in->l_addr.l_symndx, (bfd_byte *)
	  ext->l_addr.l_symndx);
d438 6
a443 10
  aouthdr_int->magic = bfd_h_get_16 (abfd, (bfd_byte *) aouthdr_ext->magic);
  aouthdr_int->vstamp = bfd_h_get_16 (abfd, (bfd_byte *) aouthdr_ext->vstamp);
  aouthdr_int->tsize =
    GET_AOUTHDR_TSIZE (abfd, (bfd_byte *) aouthdr_ext->tsize);
  aouthdr_int->dsize =
    GET_AOUTHDR_DSIZE (abfd, (bfd_byte *) aouthdr_ext->dsize);
  aouthdr_int->bsize =
    GET_AOUTHDR_BSIZE (abfd, (bfd_byte *) aouthdr_ext->bsize);
  aouthdr_int->entry =
    GET_AOUTHDR_ENTRY (abfd, (bfd_byte *) aouthdr_ext->entry);
d445 1
a445 1
    GET_AOUTHDR_TEXT_START (abfd, (bfd_byte *) aouthdr_ext->text_start);
d449 1
a449 1
    GET_AOUTHDR_DATA_START (abfd, (bfd_byte *) aouthdr_ext->data_start);
d453 3
a455 3
  a->ImageBase = GET_OPTHDR_IMAGE_BASE (abfd, (bfd_byte *) src->ImageBase);
  a->SectionAlignment = bfd_h_get_32 (abfd, (bfd_byte *) src->SectionAlignment);
  a->FileAlignment = bfd_h_get_32 (abfd, (bfd_byte *) src->FileAlignment);
d457 1
a457 1
    bfd_h_get_16 (abfd, (bfd_byte *) src->MajorOperatingSystemVersion);
d459 21
a479 17
    bfd_h_get_16 (abfd, (bfd_byte *) src->MinorOperatingSystemVersion);
  a->MajorImageVersion = bfd_h_get_16 (abfd, (bfd_byte *) src->MajorImageVersion);
  a->MinorImageVersion = bfd_h_get_16 (abfd, (bfd_byte *) src->MinorImageVersion);
  a->MajorSubsystemVersion = bfd_h_get_16 (abfd, (bfd_byte *) src->MajorSubsystemVersion);
  a->MinorSubsystemVersion = bfd_h_get_16 (abfd, (bfd_byte *) src->MinorSubsystemVersion);
  a->Reserved1 = bfd_h_get_32 (abfd, (bfd_byte *) src->Reserved1);
  a->SizeOfImage = bfd_h_get_32 (abfd, (bfd_byte *) src->SizeOfImage);
  a->SizeOfHeaders = bfd_h_get_32 (abfd, (bfd_byte *) src->SizeOfHeaders);
  a->CheckSum = bfd_h_get_32 (abfd, (bfd_byte *) src->CheckSum);
  a->Subsystem = bfd_h_get_16 (abfd, (bfd_byte *) src->Subsystem);
  a->DllCharacteristics = bfd_h_get_16 (abfd, (bfd_byte *) src->DllCharacteristics);
  a->SizeOfStackReserve = GET_OPTHDR_SIZE_OF_STACK_RESERVE (abfd, (bfd_byte *) src->SizeOfStackReserve);
  a->SizeOfStackCommit = GET_OPTHDR_SIZE_OF_STACK_COMMIT (abfd, (bfd_byte *) src->SizeOfStackCommit);
  a->SizeOfHeapReserve = GET_OPTHDR_SIZE_OF_HEAP_RESERVE (abfd, (bfd_byte *) src->SizeOfHeapReserve);
  a->SizeOfHeapCommit = GET_OPTHDR_SIZE_OF_HEAP_COMMIT (abfd, (bfd_byte *) src->SizeOfHeapCommit);
  a->LoaderFlags = bfd_h_get_32 (abfd, (bfd_byte *) src->LoaderFlags);
  a->NumberOfRvaAndSizes = bfd_h_get_32 (abfd, (bfd_byte *) src->NumberOfRvaAndSizes);
d488 1
a488 1
	  bfd_h_get_32 (abfd, (bfd_byte *) src->DataDirectory[idx][1]);
d493 1
a493 1
	    bfd_h_get_32 (abfd, (bfd_byte *) src->DataDirectory[idx][0]);
d677 1
a677 1
  bfd_h_put_16 (abfd, aouthdr_in->magic, (bfd_byte *) aouthdr_out->standard.magic);
d683 7
a689 8
  bfd_h_put_16 (abfd,
		LINKER_VERSION / 100 + (LINKER_VERSION % 100) * 256,
		(bfd_byte *) aouthdr_out->standard.vstamp);

  PUT_AOUTHDR_TSIZE (abfd, aouthdr_in->tsize, (bfd_byte *) aouthdr_out->standard.tsize);
  PUT_AOUTHDR_DSIZE (abfd, aouthdr_in->dsize, (bfd_byte *) aouthdr_out->standard.dsize);
  PUT_AOUTHDR_BSIZE (abfd, aouthdr_in->bsize, (bfd_byte *) aouthdr_out->standard.bsize);
  PUT_AOUTHDR_ENTRY (abfd, aouthdr_in->entry, (bfd_byte *) aouthdr_out->standard.entry);
d691 1
a691 1
			  (bfd_byte *) aouthdr_out->standard.text_start);
d696 1
a696 1
			  (bfd_byte *) aouthdr_out->standard.data_start);
d699 19
a717 30
  PUT_OPTHDR_IMAGE_BASE (abfd, extra->ImageBase,
			 (bfd_byte *) aouthdr_out->ImageBase);
  bfd_h_put_32 (abfd, extra->SectionAlignment,
		(bfd_byte *) aouthdr_out->SectionAlignment);
  bfd_h_put_32 (abfd, extra->FileAlignment,
		(bfd_byte *) aouthdr_out->FileAlignment);
  bfd_h_put_16 (abfd, extra->MajorOperatingSystemVersion,
		(bfd_byte *) aouthdr_out->MajorOperatingSystemVersion);
  bfd_h_put_16 (abfd, extra->MinorOperatingSystemVersion,
		(bfd_byte *) aouthdr_out->MinorOperatingSystemVersion);
  bfd_h_put_16 (abfd, extra->MajorImageVersion,
		(bfd_byte *) aouthdr_out->MajorImageVersion);
  bfd_h_put_16 (abfd, extra->MinorImageVersion,
		(bfd_byte *) aouthdr_out->MinorImageVersion);
  bfd_h_put_16 (abfd, extra->MajorSubsystemVersion,
		(bfd_byte *) aouthdr_out->MajorSubsystemVersion);
  bfd_h_put_16 (abfd, extra->MinorSubsystemVersion,
		(bfd_byte *) aouthdr_out->MinorSubsystemVersion);
  bfd_h_put_32 (abfd, extra->Reserved1,
		(bfd_byte *) aouthdr_out->Reserved1);
  bfd_h_put_32 (abfd, extra->SizeOfImage,
		(bfd_byte *) aouthdr_out->SizeOfImage);
  bfd_h_put_32 (abfd, extra->SizeOfHeaders,
		(bfd_byte *) aouthdr_out->SizeOfHeaders);
  bfd_h_put_32 (abfd, extra->CheckSum,
		(bfd_byte *) aouthdr_out->CheckSum);
  bfd_h_put_16 (abfd, extra->Subsystem,
		(bfd_byte *) aouthdr_out->Subsystem);
  bfd_h_put_16 (abfd, extra->DllCharacteristics,
		(bfd_byte *) aouthdr_out->DllCharacteristics);
d719 1
a719 1
				    (bfd_byte *) aouthdr_out->SizeOfStackReserve);
d721 1
a721 1
				   (bfd_byte *) aouthdr_out->SizeOfStackCommit);
d723 1
a723 1
				   (bfd_byte *) aouthdr_out->SizeOfHeapReserve);
d725 4
a728 5
				  (bfd_byte *) aouthdr_out->SizeOfHeapCommit);
  bfd_h_put_32 (abfd, extra->LoaderFlags,
		(bfd_byte *) aouthdr_out->LoaderFlags);
  bfd_h_put_32 (abfd, extra->NumberOfRvaAndSizes,
		(bfd_byte *) aouthdr_out->NumberOfRvaAndSizes);
d734 4
a737 4
	bfd_h_put_32 (abfd, extra->DataDirectory[idx].VirtualAddress,
		      (bfd_byte *) aouthdr_out->DataDirectory[idx][0]);
	bfd_h_put_32 (abfd, extra->DataDirectory[idx].Size,
		      (bfd_byte *) aouthdr_out->DataDirectory[idx][1]);
d806 2
a807 2
  bfd_h_put_16 (abfd, filehdr_in->f_magic, (bfd_byte *) filehdr_out->f_magic);
  bfd_h_put_16 (abfd, filehdr_in->f_nscns, (bfd_byte *) filehdr_out->f_nscns);
d809 6
a814 6
  bfd_h_put_32 (abfd, time (0), (bfd_byte *) filehdr_out->f_timdat);
  PUT_FILEHDR_SYMPTR (abfd, (bfd_vma) filehdr_in->f_symptr,
		      (bfd_byte *) filehdr_out->f_symptr);
  bfd_h_put_32 (abfd, filehdr_in->f_nsyms, (bfd_byte *) filehdr_out->f_nsyms);
  bfd_h_put_16 (abfd, filehdr_in->f_opthdr, (bfd_byte *) filehdr_out->f_opthdr);
  bfd_h_put_16 (abfd, filehdr_in->f_flags, (bfd_byte *) filehdr_out->f_flags);
d819 14
a832 17
  bfd_h_put_16 (abfd, filehdr_in->pe.e_magic, (bfd_byte *) filehdr_out->e_magic);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_cblp, (bfd_byte *) filehdr_out->e_cblp);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_cp, (bfd_byte *) filehdr_out->e_cp);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_crlc, (bfd_byte *) filehdr_out->e_crlc);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_cparhdr,
	       (bfd_byte *) filehdr_out->e_cparhdr);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_minalloc,
	       (bfd_byte *) filehdr_out->e_minalloc);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_maxalloc,
	       (bfd_byte *) filehdr_out->e_maxalloc);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_ss, (bfd_byte *) filehdr_out->e_ss);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_sp, (bfd_byte *) filehdr_out->e_sp);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_csum, (bfd_byte *) filehdr_out->e_csum);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_ip, (bfd_byte *) filehdr_out->e_ip);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_cs, (bfd_byte *) filehdr_out->e_cs);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_lfarlc, (bfd_byte *) filehdr_out->e_lfarlc);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_ovno, (bfd_byte *) filehdr_out->e_ovno);
d835 1
a835 2
    bfd_h_put_16 (abfd, filehdr_in->pe.e_res[idx],
		  (bfd_byte *) filehdr_out->e_res[idx]);
d837 2
a838 3
  bfd_h_put_16 (abfd, filehdr_in->pe.e_oemid, (bfd_byte *) filehdr_out->e_oemid);
  bfd_h_put_16 (abfd, filehdr_in->pe.e_oeminfo,
		(bfd_byte *) filehdr_out->e_oeminfo);
d841 1
a841 2
    bfd_h_put_16 (abfd, filehdr_in->pe.e_res2[idx],
		  (bfd_byte *) filehdr_out->e_res2[idx]);
d843 1
a843 1
  bfd_h_put_32 (abfd, filehdr_in->pe.e_lfanew, (bfd_byte *) filehdr_out->e_lfanew);
d846 2
a847 2
    bfd_h_put_32 (abfd, filehdr_in->pe.dos_message[idx],
		  (bfd_byte *) filehdr_out->dos_message[idx]);
d850 1
a850 2
  bfd_h_put_32 (abfd, filehdr_in->pe.nt_signature,
		(bfd_byte *) filehdr_out->nt_signature);
d864 7
a870 8
  bfd_h_put_16 (abfd, filehdr_in->f_magic, (bfd_byte *) filehdr_out->f_magic);
  bfd_h_put_16 (abfd, filehdr_in->f_nscns, (bfd_byte *) filehdr_out->f_nscns);
  bfd_h_put_32 (abfd, filehdr_in->f_timdat, (bfd_byte *) filehdr_out->f_timdat);
  PUT_FILEHDR_SYMPTR (abfd, (bfd_vma) filehdr_in->f_symptr,
		      (bfd_byte *) filehdr_out->f_symptr);
  bfd_h_put_32 (abfd, filehdr_in->f_nsyms, (bfd_byte *) filehdr_out->f_nsyms);
  bfd_h_put_16 (abfd, filehdr_in->f_opthdr, (bfd_byte *) filehdr_out->f_opthdr);
  bfd_h_put_16 (abfd, filehdr_in->f_flags, (bfd_byte *) filehdr_out->f_flags);
d893 1
a893 1
		    (bfd_byte *) scnhdr_ext->s_vaddr);
d910 1
a910 1
		   (bfd_byte *) scnhdr_ext->s_size);
d913 1
a913 1
  PUT_SCNHDR_PADDR (abfd, ps, (bfd_byte *) scnhdr_ext->s_paddr);
d916 1
a916 1
		     (bfd_byte *) scnhdr_ext->s_scnptr);
d918 1
a918 1
		     (bfd_byte *) scnhdr_ext->s_relptr);
d920 1
a920 1
		      (bfd_byte *) scnhdr_ext->s_lnnoptr);
d939 1
a939 1
    bfd_h_put_32 (abfd, flags, (bfd_byte *) scnhdr_ext->s_flags);
d955 2
a956 4
      bfd_h_put_16 (abfd, scnhdr_int->s_nlnno & 0xffff,
		    (bfd_byte *) scnhdr_ext->s_nlnno);
      bfd_h_put_16 (abfd, scnhdr_int->s_nlnno >> 16,
		    (bfd_byte *) scnhdr_ext->s_nreloc);
d961 1
a961 2
	bfd_h_put_16 (abfd, scnhdr_int->s_nlnno,
		      (bfd_byte *) scnhdr_ext->s_nlnno);
d968 1
a968 1
	  bfd_h_put_16 (abfd, 0xffff, (bfd_byte *) scnhdr_ext->s_nlnno);
d973 1
a973 2
	bfd_h_put_16 (abfd, scnhdr_int->s_nreloc,
		      (bfd_byte *) scnhdr_ext->s_nreloc);
d977 1
a977 1
	  bfd_h_put_16 (abfd, 0xffff, (bfd_byte *) scnhdr_ext->s_nreloc);
d979 1
a979 2
	  bfd_h_put_32 (abfd, scnhdr_int->s_flags,
			(bfd_byte *) scnhdr_ext->s_flags);
d985 1
a985 1
	  bfd_h_put_16 (abfd, 0xffff, (bfd_byte *) scnhdr_ext->s_nreloc);
d1038 1
d1100 3
a1102 3
      data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd,
								 rel_section));
      if (data == NULL && bfd_section_size (abfd, rel_section) != 0)
d1105 2
a1106 4
      bfd_get_section_contents (abfd,
				rel_section,
				(PTR) data, 0,
				bfd_section_size (abfd, rel_section));
d1136 2
a1137 1
  data = (bfd_byte *) bfd_malloc (dataoff + datasize);
d1142 1
a1142 2
  if (! bfd_get_section_contents (abfd, section, (PTR) data,
				  0, dataoff + datasize))
d1360 2
a1361 2
  if (! bfd_get_section_contents (abfd, section, (PTR) data, dataoff,
				  datasize))
d1548 2
a1549 1
  if (bfd_section_size (abfd, section) == 0)
d1552 1
a1552 2
  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
  datasize = bfd_section_size (abfd, section);
d1556 2
a1557 4
  bfd_get_section_contents (abfd,
			    section,
			    (PTR) data, 0,
			    bfd_section_size (abfd, section));
d1660 1
a1660 1
  bfd_size_type datasize = 0;
a1672 1
  data = (bfd_byte *) bfd_malloc ((size_t) bfd_section_size (abfd, section));
d1674 1
d1678 2
a1679 4
  bfd_get_section_contents (abfd,
			    section,
			    (PTR) data, 0,
			    bfd_section_size (abfd, section));
d1894 2
a1895 2
	  osec->used_by_bfd =
	    (PTR) bfd_zalloc (obfd, sizeof (struct coff_section_tdata));
d1902 2
a1903 2
	  coff_section_data (obfd, osec)->tdata =
	    (PTR) bfd_zalloc (obfd, sizeof (struct pei_section_tdata));
@


1.2
log
@Update copyright notices
@
text
@d98 3
a100 2

/**********************************************************************/
d118 1
a118 3
    {
      memcpy (in->_n._n_name, ext->e.e_name, SYMNMLEN);
    }
d122 1
d124 1
a124 3
    {
      in->n_type = bfd_h_get_16 (abfd, (bfd_byte *) ext->e_type);
    }
d126 2
a127 3
    {
      in->n_type = bfd_h_get_32 (abfd, (bfd_byte *) ext->e_type);
    }
d166 1
d176 1
d182 1
d232 1
d239 1
a239 3
    {
      memcpy (ext->e.e_name, in->_n._n_name, SYMNMLEN);
    }
d243 1
d245 1
a245 3
    {
      bfd_h_put_16 (abfd, in->n_type, (bfd_byte *) ext->e_type);
    }
d247 2
a248 3
    {
      bfd_h_put_32 (abfd, in->n_type, (bfd_byte *) ext->e_type);
    }
d278 1
a278 3
	{
	  memcpy (in->x_file.x_fname, ext->x_file.x_fname, FILNMLEN);
	}
d357 2
a358 3
	{
	  memcpy (ext->x_file.x_fname, in->x_file.x_fname, FILNMLEN);
	}
d496 1
d505 2
a506 4
	  {
	    a->DataDirectory[idx].VirtualAddress =
	      bfd_h_get_32 (abfd, (bfd_byte *) src->DataDirectory[idx][0]);
	  }
d519 1
d527 1
a544 1

d559 1
a559 1
  /* add import directory information if it exists */
d564 1
a564 1
      /* If data directory is empty, rva also should be 0 */
d611 1
d619 1
d757 1
d842 1
a842 1
  /* put in extra dos header stuff.  This data remains essentially
d844 1
a844 1
     for NT */
d862 5
a866 6
  {
    int idx;
    for (idx = 0; idx < 4; idx++)
      bfd_h_put_16 (abfd, filehdr_in->pe.e_res[idx],
		    (bfd_byte *) filehdr_out->e_res[idx]);
  }
d870 5
a874 6
  {
    int idx;
    for (idx = 0; idx < 10; idx++)
      bfd_h_put_16 (abfd, filehdr_in->pe.e_res2[idx],
		    (bfd_byte *) filehdr_out->e_res2[idx]);
  }
d877 3
a879 6
  {
    int idx;
    for (idx = 0; idx < 16; idx++)
      bfd_h_put_32 (abfd, filehdr_in->pe.dos_message[idx],
		    (bfd_byte *) filehdr_out->dos_message[idx]);
  }
a931 1

d972 1
d1008 1
d1014 1
a1014 1
	  /* PE can deal with large #s of relocs, but not here */
d1032 19
a1050 18
static char * dir_names[IMAGE_NUMBEROF_DIRECTORY_ENTRIES] = {
  N_("Export Directory [.edata (or where ever we found it)]"),
  N_("Import Directory [parts of .idata]"),
  N_("Resource Directory [.rsrc]"),
  N_("Exception Directory [.pdata]"),
  N_("Security Directory"),
  N_("Base Relocation Directory [.reloc]"),
  N_("Debug Directory"),
  N_("Description Directory"),
  N_("Special Directory"),
  N_("Thread Storage Directory [.tls]"),
  N_("Load Configuration Directory"),
  N_("Bound Import Directory"),
  N_("Import Address Table Directory"),
  N_("Delay Import Directory"),
  N_("Reserved"),
  N_("Reserved")
};
a1051 1
/**********************************************************************/
a1059 1
/**********************************************************************/
d1200 1
a1200 1

d1202 3
a1204 5
	{
	  /* Check stuff.  */
	  ;
	}

d1292 1
d1294 2
a1295 4
		    {
		      fprintf (file,
			      _("\t>>> Ran out of IAT members!\n"));
		    }
d1310 1
d1312 2
a1313 4
	    {
	      fprintf (file,
		      _("\tThe Import Address Table is identical\n"));
	    }
a1316 1

a1331 1

a1334 1

d1336 3
a1338 2
  struct EDT_type {
    long export_flags;             /* reserved - should be zero */
d1342 7
a1348 7
    bfd_vma name;                  /* rva - relative to image base */
    long base;                     /* ordinal base */
    unsigned long num_functions;   /* Number in the export address table */
    unsigned long num_names;       /* Number in the name pointer table */
    bfd_vma eat_addr;    /* rva to the export address table */
    bfd_vma npt_addr;        /* rva to the Export Name Pointer Table */
    bfd_vma ot_addr; /* rva to the Ordinal Table */
d1373 1
d1377 1
d1419 1
a1419 1
  /* Dump the EDT first first */
d1473 2
a1474 1
      typedef union {
d1623 2
a1624 4
	{
	  /* We are probably into the padding of the section now.  */
	  break;
	}
d1677 16
a1692 15
static const char * const tbl[] = {
  "ABSOLUTE",
  "HIGH",
  "LOW",
  "HIGHLOW",
  "HIGHADJ",
  "MIPS_JMPADDR",
  "SECTION",
  "REL32",
  "RESERVED1",
  "MIPS_JMPADDR16",
  "DIR64",
  "HIGH3ADJ"
  "UNKNOWN",   /* MUST be last */
};
d1736 1
a1736 2
	 of two 32 bit quantities, followed by a number of 16 bit entries */

d1742 1
a1742 3
	{
	  break;
	}
d1773 1
d1831 1
d1862 1
d1910 1
a1910 1
  /* for strip: if we removed .reloc, we'll make a real mess of things
d1921 1
d1943 1
d1951 1
@


1.2.2.1
log
@Merge from mainline.
@
text
@@


1.2.2.2
log
@        * peXXigen.c (_bfd_XX_print_private_bfd_data_common): Copy
        timestamp to time_t for ctime.
@
text
@d1828 1
a1828 4
  {
    time_t t = pe->coff.timestamp;
    fprintf (file, "\nTime/Date\t\t%s", ctime (&t));
  }
@


1.1
log
@* peicode.h (coff_swap_filehdr_out) [COFF_IMAGE_WITH_PE]: Define
as _bfd_XXi_only_swap_filehdr_out.
(pe_mkobject) [PEI_FORCE_MINIMUM_ALIGNMENT]: Set
pe->force_minimum_alignment to TRUE.
(pe_mkobject) [PEI_TARGET_SUBSYSTEM]: Set pe->target_subsystem to
PEI_TARGET_SUBSYSTEM.
(pe_print_private_bfd_data): Call
_bfd_XX_print_private_bfd_data_common() instead of
_bfd_pe_print_private_bfd_data_common().
(pe_bfd_copy_private_bfd_data): Call
_bfd_XX_bfd_copy_private_bfd_data_common() instead of
_bfd_pe_bfd_copy_private_bfd_data_common().
(coff_bfd_copy_private_section_data): Define as
_bfd_XX_bfd_copy_private_section_data instead of
_bfd_pe_bfd_copy_private_section_data.
(coff_get_symbol_info): Define as _bfd_XX_get_symbol_info instead
of a _bfd_pe_get_symbol_info.

* peigen.c: Delete.

* peXXigen.c: Renamed from peigen.c.
(COFF_WITH_XX): Define this macro (will get expanded into
COFF_WITH_pep or COFF_WITH_pe, depending on whether this is being
compiled as peigen.c or pepigen.c.
[COFF_WITH_pep]: Include "coff/ia64.h" instead of "coff/i386.h" to
define the canonical PEP structures and definitions.
(_bfd_XXi_swap_aouthdr_out): If pe->force_minimum_alignment is in
effect, enforce minimum file and section alignments.  If
extra->Subsystem is IMAGE_SUBSYSTEM_UNKNOWN, set it to
pe->target_subsystem (this defaults to IMAGE_SUBSYSTEM_UNKNOWN,
so, by default, this is a no-op).

* libpei.h: Rename COFF_WITH_PEP to COFF_WITH_pep.
(_bfd_XX_bfd_copy_private_bfd_data_common): Add macros to map
_bfd_XXfoo to _bfd_pepfoo if COFF_WIT_PEP is defined and to
_bfd_pefoo if it's not defined.  Use these macros to define
coff swap macros.

* libcoff.h (pe_tdata): Add members target_subsystem and
force_minimum_alignment.

* efi-app-ia64.c (COFF_WITH_pep): Rename COFF_WITH_PEP to
COFF_WITH_pep.
(PEI_TARGET_SUBSYSTEM): Rename from PEI_DEFAULT_TARGET_SUBSYSTEM.

* configure.in (bfd_efi_app_ia64_vec): Use pepigen.lo instead of
peigen.lo.

* coff-ia64.c: Rename COFF_WITH_PEP to COFF_WITH_pep.
(AOUTSZ): Rename PEP64AOUTSZ and PEP64AOUTHDR to PEPAOUTSZ and
PEPAOUTHDR.

* Makefile.in (BFD64_BACKENDS): Mention pepigen.lo.
(BFD64_BACKENDS_CFILES): Mention pepigen.c
(peigen.c): Add rule to generate from peXXigen.c.
(pepigen.c): Ditto.
(pepigen.lo): List dependencies for pepigen.lo.

* unwind-ia64.c (unw_decode_x1): Declare code arg with
ATTRIBUTE_UNUSED.
(unw_decode_x2): Ditto.
(unw_decode_x3): Ditto.
(unw_decode_x4): Ditto.

* pe.h (PEPAOUTSZ): Rename from PEP64AOUTSZ.
Rename from PEPAOUTHDR.
@
text
@d2 2
a3 1
   Copyright 1995, 96, 97, 98, 99, 2000, 2001 Free Software Foundation, Inc.
@

