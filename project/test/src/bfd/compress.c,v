head	1.20;
access;
symbols
	sid-snapshot-20180601:1.20
	sid-snapshot-20180501:1.20
	sid-snapshot-20180401:1.20
	sid-snapshot-20180301:1.20
	sid-snapshot-20180201:1.20
	sid-snapshot-20180101:1.20
	sid-snapshot-20171201:1.20
	sid-snapshot-20171101:1.20
	sid-snapshot-20171001:1.20
	sid-snapshot-20170901:1.20
	sid-snapshot-20170801:1.20
	sid-snapshot-20170701:1.20
	sid-snapshot-20170601:1.20
	sid-snapshot-20170501:1.20
	sid-snapshot-20170401:1.20
	sid-snapshot-20170301:1.20
	sid-snapshot-20170201:1.20
	sid-snapshot-20170101:1.20
	sid-snapshot-20161201:1.20
	sid-snapshot-20161101:1.20
	sid-snapshot-20160901:1.20
	sid-snapshot-20160801:1.20
	sid-snapshot-20160701:1.20
	sid-snapshot-20160601:1.20
	sid-snapshot-20160501:1.20
	sid-snapshot-20160401:1.20
	sid-snapshot-20160301:1.20
	sid-snapshot-20160201:1.20
	sid-snapshot-20160101:1.20
	sid-snapshot-20151201:1.20
	sid-snapshot-20151101:1.20
	sid-snapshot-20151001:1.20
	sid-snapshot-20150901:1.20
	sid-snapshot-20150801:1.20
	sid-snapshot-20150701:1.20
	sid-snapshot-20150601:1.20
	sid-snapshot-20150501:1.20
	sid-snapshot-20150401:1.20
	sid-snapshot-20150301:1.20
	sid-snapshot-20150201:1.20
	sid-snapshot-20150101:1.20
	sid-snapshot-20141201:1.20
	sid-snapshot-20141101:1.20
	sid-snapshot-20141001:1.20
	sid-snapshot-20140901:1.20
	sid-snapshot-20140801:1.20
	sid-snapshot-20140701:1.20
	sid-snapshot-20140601:1.20
	sid-snapshot-20140501:1.20
	sid-snapshot-20140401:1.20
	sid-snapshot-20140301:1.20
	sid-snapshot-20140201:1.20
	sid-snapshot-20140101:1.20
	sid-snapshot-20131201:1.20
	sid-snapshot-20131101:1.20
	sid-snapshot-20131001:1.20
	binutils-2_24-branch:1.20.0.2
	binutils-2_24-branchpoint:1.20
	binutils-2_21_1:1.6.2.1
	sid-snapshot-20130901:1.20
	gdb_7_6_1-2013-08-30-release:1.19
	sid-snapshot-20130801:1.20
	sid-snapshot-20130701:1.20
	sid-snapshot-20130601:1.20
	sid-snapshot-20130501:1.20
	gdb_7_6-2013-04-26-release:1.19
	sid-snapshot-20130401:1.19
	binutils-2_23_2:1.12
	gdb_7_6-branch:1.19.0.2
	gdb_7_6-2013-03-12-branchpoint:1.19
	sid-snapshot-20130301:1.19
	sid-snapshot-20130201:1.19
	sid-snapshot-20130101:1.18
	sid-snapshot-20121201:1.18
	gdb_7_5_1-2012-11-29-release:1.12
	binutils-2_23_1:1.12
	sid-snapshot-20121101:1.18
	binutils-2_23:1.12
	sid-snapshot-20121001:1.12
	sid-snapshot-20120901:1.12
	gdb_7_5-2012-08-17-release:1.12
	sid-snapshot-20120801:1.12
	binutils-2_23-branch:1.12.0.4
	binutils-2_23-branchpoint:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	sid-snapshot-20120701:1.12
	sid-snapshot-20120601:1.12
	sid-snapshot-20120501:1.11
	binutils-2_22_branch:1.9.0.6
	gdb_7_4_1-2012-04-26-release:1.9
	sid-snapshot-20120401:1.11
	sid-snapshot-20120301:1.11
	sid-snapshot-20120201:1.11
	gdb_7_4-2012-01-24-release:1.9
	sid-snapshot-20120101:1.11
	gdb_7_4-branch:1.9.0.4
	gdb_7_4-2011-12-13-branchpoint:1.9
	sid-snapshot-20111201:1.9
	binutils-2_22:1.9
	sid-snapshot-20111101:1.9
	sid-snapshot-20111001:1.9
	binutils-2_22-branch:1.9.0.2
	binutils-2_22-branchpoint:1.9
	gdb_7_3_1-2011-09-04-release:1.8
	sid-snapshot-20110901:1.9
	sid-snapshot-20110801:1.9
	gdb_7_3-2011-07-26-release:1.8
	sid-snapshot-20110701:1.9
	sid-snapshot-20110601:1.9
	sid-snapshot-20110501:1.9
	gdb_7_3-branch:1.8.0.2
	gdb_7_3-2011-04-01-branchpoint:1.8
	sid-snapshot-20110401:1.8
	sid-snapshot-20110301:1.7
	sid-snapshot-20110201:1.7
	sid-snapshot-20110101:1.7
	binutils-2_21:1.6
	sid-snapshot-20101201:1.6
	binutils-2_21-branch:1.6.0.2
	binutils-2_21-branchpoint:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.4
	binutils-2_20_1:1.1.18.1
	gdb_7_2-2010-09-02-release:1.4
	sid-snapshot-20100901:1.4
	sid-snapshot-20100801:1.4
	gdb_7_2-branch:1.4.0.2
	gdb_7_2-2010-07-07-branchpoint:1.4
	sid-snapshot-20100701:1.3
	sid-snapshot-20100601:1.2
	sid-snapshot-20100501:1.2
	sid-snapshot-20100401:1.2
	gdb_7_1-2010-03-18-release:1.2
	sid-snapshot-20100301:1.2
	gdb_7_1-branch:1.2.0.4
	gdb_7_1-2010-02-18-branchpoint:1.2
	sid-snapshot-20100201:1.2
	sid-snapshot-20100101:1.2
	gdb_7_0_1-2009-12-22-release:1.2
	sid-snapshot-20091201:1.2
	sid-snapshot-20091101:1.2
	binutils-2_20:1.1.18.1
	gdb_7_0-2009-10-06-release:1.2
	sid-snapshot-20091001:1.2
	gdb_7_0-branch:1.2.0.2
	gdb_7_0-2009-09-16-branchpoint:1.2
	binutils-arc-20081103-branch:1.1.0.20
	binutils-arc-20081103-branchpoint:1.1
	binutils-2_20-branch:1.1.0.18
	binutils-2_20-branchpoint:1.1
	sid-snapshot-20090901:1.1
	sid-snapshot-20090801:1.1
	msnyder-checkpoint-072509-branch:1.1.0.16
	msnyder-checkpoint-072509-branchpoint:1.1
	sid-snapshot-20090701:1.1
	dje-cgen-play1-branch:1.1.0.14
	dje-cgen-play1-branchpoint:1.1
	sid-snapshot-20090601:1.1
	sid-snapshot-20090501:1.1
	sid-snapshot-20090401:1.1
	arc-20081103-branch:1.1.0.12
	arc-20081103-branchpoint:1.1
	sid-snapshot-20090301:1.1
	binutils-2_19_1:1.1
	sid-snapshot-20090201:1.1
	sid-snapshot-20090101:1.1
	reverse-20081226-branch:1.1.0.10
	reverse-20081226-branchpoint:1.1
	sid-snapshot-20081201:1.1
	multiprocess-20081120-branch:1.1.0.8
	multiprocess-20081120-branchpoint:1.1
	sid-snapshot-20081101:1.1
	binutils-2_19:1.1
	sid-snapshot-20081001:1.1
	reverse-20080930-branch:1.1.0.6
	reverse-20080930-branchpoint:1.1
	binutils-2_19-branch:1.1.0.4
	binutils-2_19-branchpoint:1.1
	sid-snapshot-20080901:1.1
	sid-snapshot-20080801:1.1
	reverse-20080717-branch:1.1.0.2
	reverse-20080717-branchpoint:1.1
	binutils_latest_snapshot:1.20;
locks; strict;
comment	@ * @;


1.20
date	2013.04.17.14.16.01;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.18;

1.18
date	2012.10.24.21.36.50;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.21.09.06.06;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.20.08.27.13;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2012.10.19.16.59.57;	author tromey;	state Exp;
branches;
next	1.14;

1.14
date	2012.10.19.15.51.53;	author tromey;	state Exp;
branches;
next	1.13;

1.13
date	2012.10.18.17.42.29;	author ktietz;	state Exp;
branches;
next	1.12;

1.12
date	2012.05.17.15.13.19;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2011.12.14.16.12.13;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2011.12.14.11.50.13;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2011.04.11.04.08.12;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2011.03.06.18.37.07;	author msnyder;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.24.10.40.19;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.29.19.56.00;	author hjl;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2010.10.29.12.10.23;	author hjl;	state Exp;
branches;
next	1.4;

1.4
date	2010.07.03.20.52.22;	author ccoutant;	state Exp;
branches;
next	1.3;

1.3
date	2010.06.28.14.41.11;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2008.07.10.01.32.21;	author csilvers;	state Exp;
branches
	1.1.18.1;
next	;

1.6.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	;

1.1.18.1
date	2009.09.09.21.40.18;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.20
log
@	* coffcode.h: Added a cast to void when a bfd_set_section_*()
	macro's return value is ignored.
	* elf32-hppa.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* mach-o.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* peicode.h: Likewise.
	* elf32-m32r.c: Check return value of bfd_set_section_*().
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* vms-alpha.c: Likewise.
@
text
@/* Compressed section support (intended for debug sections).
   Copyright 2008, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#ifdef HAVE_ZLIB_H
#include <zlib.h>
#endif

#ifdef HAVE_ZLIB_H
static bfd_boolean
decompress_contents (bfd_byte *compressed_buffer,
		     bfd_size_type compressed_size,
		     bfd_byte *uncompressed_buffer,
		     bfd_size_type uncompressed_size)
{
  z_stream strm;
  int rc;

  /* It is possible the section consists of several compressed
     buffers concatenated together, so we uncompress in a loop.  */
  strm.zalloc = NULL;
  strm.zfree = NULL;
  strm.opaque = NULL;
  strm.avail_in = compressed_size - 12;
  strm.next_in = (Bytef*) compressed_buffer + 12;
  strm.avail_out = uncompressed_size;

  BFD_ASSERT (Z_OK == 0);
  rc = inflateInit (&strm);
  while (strm.avail_in > 0 && strm.avail_out > 0)
    {
      if (rc != Z_OK)
	break;
      strm.next_out = ((Bytef*) uncompressed_buffer
                       + (uncompressed_size - strm.avail_out));
      rc = inflate (&strm, Z_FINISH);
      if (rc != Z_STREAM_END)
	break;
      rc = inflateReset (&strm);
    }
  rc |= inflateEnd (&strm);
  return rc == Z_OK && strm.avail_out == 0;
}
#endif

/*
FUNCTION
	bfd_compress_section_contents

SYNOPSIS
	bfd_boolean bfd_compress_section_contents
	  (bfd *abfd, asection *section, bfd_byte *uncompressed_buffer,
	   bfd_size_type uncompressed_size);

DESCRIPTION

	Compress data of the size specified in @@var{uncompressed_size}
	and pointed to by @@var{uncompressed_buffer} using zlib and store
	as the contents field.  This function assumes the contents
	field was allocated using bfd_malloc() or equivalent.  If zlib
	is not installed on this machine, the input is unmodified.

	Return @@code{TRUE} if the full section contents is compressed
	successfully.
*/

bfd_boolean
bfd_compress_section_contents (bfd *abfd ATTRIBUTE_UNUSED,
			       sec_ptr sec ATTRIBUTE_UNUSED,
			       bfd_byte *uncompressed_buffer ATTRIBUTE_UNUSED,
			       bfd_size_type uncompressed_size ATTRIBUTE_UNUSED)
{
#ifndef HAVE_ZLIB_H
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;
#else
  uLong compressed_size;
  bfd_byte *compressed_buffer;

  compressed_size = compressBound (uncompressed_size) + 12;
  compressed_buffer = (bfd_byte *) bfd_malloc (compressed_size);

  if (compressed_buffer == NULL)
    return FALSE;

  if (compress ((Bytef*) compressed_buffer + 12,
		&compressed_size,
		(const Bytef*) uncompressed_buffer,
		uncompressed_size) != Z_OK)
    {
      free (compressed_buffer);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  /* Write the zlib header.  In this case, it should be "ZLIB" followed
     by the uncompressed section size, 8 bytes in big-endian order.  */
  memcpy (compressed_buffer, "ZLIB", 4);
  compressed_buffer[11] = uncompressed_size; uncompressed_size >>= 8;
  compressed_buffer[10] = uncompressed_size; uncompressed_size >>= 8;
  compressed_buffer[9] = uncompressed_size; uncompressed_size >>= 8;
  compressed_buffer[8] = uncompressed_size; uncompressed_size >>= 8;
  compressed_buffer[7] = uncompressed_size; uncompressed_size >>= 8;
  compressed_buffer[6] = uncompressed_size; uncompressed_size >>= 8;
  compressed_buffer[5] = uncompressed_size; uncompressed_size >>= 8;
  compressed_buffer[4] = uncompressed_size;
  compressed_size += 12;

  /* Free the uncompressed contents if we compress in place.  */
  if (uncompressed_buffer == sec->contents)
    free (uncompressed_buffer);

  sec->contents = compressed_buffer;
  sec->size = compressed_size;
  sec->compress_status = COMPRESS_SECTION_DONE;

  return TRUE;
#endif  /* HAVE_ZLIB_H */
}

/*
FUNCTION
	bfd_get_full_section_contents

SYNOPSIS
	bfd_boolean bfd_get_full_section_contents
	  (bfd *abfd, asection *section, bfd_byte **ptr);

DESCRIPTION
	Read all data from @@var{section} in BFD @@var{abfd}, decompress
	if needed, and store in @@var{*ptr}.  If @@var{*ptr} is NULL,
	return @@var{*ptr} with memory malloc'd by this function.

	Return @@code{TRUE} if the full section contents is retrieved
	successfully.
*/

bfd_boolean
bfd_get_full_section_contents (bfd *abfd, sec_ptr sec, bfd_byte **ptr)
{
  bfd_size_type sz;
  bfd_byte *p = *ptr;
#ifdef HAVE_ZLIB_H
  bfd_boolean ret;
  bfd_size_type save_size;
  bfd_size_type save_rawsize;
  bfd_byte *compressed_buffer;
#endif

  if (abfd->direction != write_direction && sec->rawsize != 0)
    sz = sec->rawsize;
  else
    sz = sec->size;
  if (sz == 0)
    return TRUE;

  switch (sec->compress_status)
    {
    case COMPRESS_SECTION_NONE:
      if (p == NULL)
	{
	  p = (bfd_byte *) bfd_malloc (sz);
	  if (p == NULL)
	    return FALSE;
	}
      if (!bfd_get_section_contents (abfd, sec, p, 0, sz))
	{
	  if (*ptr != p)
	    free (p);
	  return FALSE;
	}
      *ptr = p;
      return TRUE;

    case DECOMPRESS_SECTION_SIZED:
#ifndef HAVE_ZLIB_H
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
#else
      /* Read in the full compressed section contents.  */
      compressed_buffer = (bfd_byte *) bfd_malloc (sec->compressed_size);
      if (compressed_buffer == NULL)
	return FALSE;
      save_rawsize = sec->rawsize;
      save_size = sec->size;
      /* Clear rawsize, set size to compressed size and set compress_status
	 to COMPRESS_SECTION_NONE.  If the compressed size is bigger than
	 the uncompressed size, bfd_get_section_contents will fail.  */
      sec->rawsize = 0;
      sec->size = sec->compressed_size;
      sec->compress_status = COMPRESS_SECTION_NONE;
      ret = bfd_get_section_contents (abfd, sec, compressed_buffer,
				      0, sec->compressed_size);
      /* Restore rawsize and size.  */
      sec->rawsize = save_rawsize;
      sec->size = save_size;
      sec->compress_status = DECOMPRESS_SECTION_SIZED;
      if (!ret)
	goto fail_compressed;

      if (p == NULL)
	p = (bfd_byte *) bfd_malloc (sz);
      if (p == NULL)
	goto fail_compressed;

      if (!decompress_contents (compressed_buffer, sec->compressed_size, p, sz))
	{
	  bfd_set_error (bfd_error_bad_value);
	  if (p != *ptr)
	    free (p);
	fail_compressed:
	  free (compressed_buffer);
	  return FALSE;
	}

      free (compressed_buffer);
      *ptr = p;
      return TRUE;
#endif

    case COMPRESS_SECTION_DONE:
      if (p == NULL)
	{
	  p = (bfd_byte *) bfd_malloc (sz);
	  if (p == NULL)
	    return FALSE;
	  *ptr = p;
	}
      memcpy (p, sec->contents, sz);
      return TRUE;

    default:
      abort ();
    }
}

/*
FUNCTION
	bfd_cache_section_contents

SYNOPSIS
	void bfd_cache_section_contents
	  (asection *sec, void *contents);

DESCRIPTION
	Stash @@var(contents) so any following reads of @@var(sec) do
	not need to decompress again.
*/

void
bfd_cache_section_contents (asection *sec, void *contents)
{
  if (sec->compress_status == DECOMPRESS_SECTION_SIZED)
    sec->compress_status = COMPRESS_SECTION_DONE;
  sec->contents = contents;
  sec->flags |= SEC_IN_MEMORY;
}


/*
FUNCTION
	bfd_is_section_compressed

SYNOPSIS
	bfd_boolean bfd_is_section_compressed
	  (bfd *abfd, asection *section);

DESCRIPTION
	Return @@code{TRUE} if @@var{section} is compressed.
*/

bfd_boolean
bfd_is_section_compressed (bfd *abfd, sec_ptr sec)
{
  bfd_byte compressed_buffer [12];
  unsigned int saved = sec->compress_status;
  bfd_boolean compressed;

  /* Don't decompress the section.  */
  sec->compress_status = COMPRESS_SECTION_NONE;

  /* Read the zlib header.  In this case, it should be "ZLIB" followed
     by the uncompressed section size, 8 bytes in big-endian order.  */
  compressed = (bfd_get_section_contents (abfd, sec, compressed_buffer, 0, 12)
		&& CONST_STRNEQ ((char*) compressed_buffer, "ZLIB"));

  /* Restore compress_status.  */
  sec->compress_status = saved;
  return compressed;
}

/*
FUNCTION
	bfd_init_section_decompress_status

SYNOPSIS
	bfd_boolean bfd_init_section_decompress_status
	  (bfd *abfd, asection *section);

DESCRIPTION
	Record compressed section size, update section size with
	decompressed size and set compress_status to
	DECOMPRESS_SECTION_SIZED.

	Return @@code{FALSE} if the section is not a valid compressed
	section or zlib is not installed on this machine.  Otherwise,
	return @@code{TRUE}.
*/

bfd_boolean
bfd_init_section_decompress_status (bfd *abfd ATTRIBUTE_UNUSED,
				    sec_ptr sec ATTRIBUTE_UNUSED)
{
#ifndef HAVE_ZLIB_H
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;
#else
  bfd_byte compressed_buffer [12];
  bfd_size_type uncompressed_size;

  if (sec->rawsize != 0
      || sec->contents != NULL
      || sec->compress_status != COMPRESS_SECTION_NONE
      || !bfd_get_section_contents (abfd, sec, compressed_buffer, 0, 12))
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Read the zlib header.  In this case, it should be "ZLIB" followed
     by the uncompressed section size, 8 bytes in big-endian order.  */
  if (! CONST_STRNEQ ((char*) compressed_buffer, "ZLIB"))
    {
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }

  uncompressed_size = compressed_buffer[4]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[5]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[6]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[7]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[8]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[9]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[10]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[11];

  sec->compressed_size = sec->size;
  sec->size = uncompressed_size;
  sec->compress_status = DECOMPRESS_SECTION_SIZED;

  return TRUE;
#endif
}

/*
FUNCTION
	bfd_init_section_compress_status

SYNOPSIS
	bfd_boolean bfd_init_section_compress_status
	  (bfd *abfd, asection *section);

DESCRIPTION
	If open for read, compress section, update section size with
	compressed size and set compress_status to COMPRESS_SECTION_DONE.

	Return @@code{FALSE} if the section is not a valid compressed
	section or zlib is not installed on this machine.  Otherwise,
	return @@code{TRUE}.
*/

bfd_boolean
bfd_init_section_compress_status (bfd *abfd ATTRIBUTE_UNUSED,
				  sec_ptr sec ATTRIBUTE_UNUSED)
{
#ifndef HAVE_ZLIB_H
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;
#else
  bfd_size_type uncompressed_size;
  bfd_byte *uncompressed_buffer;
  bfd_boolean ret;

  /* Error if not opened for read.  */
  if (abfd->direction != read_direction
      || sec->size == 0
      || sec->rawsize != 0
      || sec->contents != NULL
      || sec->compress_status != COMPRESS_SECTION_NONE)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* Read in the full section contents and compress it.  */
  uncompressed_size = sec->size;
  uncompressed_buffer = (bfd_byte *) bfd_malloc (uncompressed_size);
  if (!bfd_get_section_contents (abfd, sec, uncompressed_buffer,
				 0, uncompressed_size))
    ret = FALSE;
  else
    ret = bfd_compress_section_contents (abfd, sec,
					 uncompressed_buffer,
					 uncompressed_size);

  free (uncompressed_buffer);
  return ret;
#endif
}
@


1.19
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d48 1
d53 1
a53 1
	return FALSE;
d58 1
a58 1
	return FALSE;
d61 1
a61 1
  rc = inflateEnd (&strm);
@


1.18
log
@Don't decompress the section in bfd_is_section_compressed

	* compress.c (bfd_is_section_compressed): Don't decompress the
	section.
@
text
@d82 1
a82 1
	Return @@code{TRUE} if the full section contents is compressed 
d151 1
a151 1
	return @@var{*ptr} with memory malloc'd by this function.  
@


1.17
log
@bfd/
	* compress.c (bfd_cache_section_contents): New function.
	* bfd-in2.h: Regenerate.
binutils/
	* objdump.c (load_specific_debug_section): Use
	bfd_cache_section_contents.
@
text
@d295 5
d303 6
a308 2
  return (bfd_get_section_contents (abfd, sec, compressed_buffer, 0, 12)
	  && CONST_STRNEQ ((char*) compressed_buffer, "ZLIB"));
@


1.16
log
@	* compress.c: Reinstate 2012-10-19 change.
	(bfd_get_full_section_contents): Don't free unless we alloc.
	Use proper decompress size.  Delete some vars, rename others.
@
text
@d258 23
@


1.15
log
@	* compress.c: Revert previous patch.
@
text
@d164 2
a165 3
  bfd_size_type compressed_size;
  bfd_size_type uncompressed_size;
  bfd_size_type rawsize;
a166 1
  bfd_byte *uncompressed_buffer;
d200 1
a200 3
      uncompressed_size = sec->size;
      compressed_size = sec->compressed_size;
      compressed_buffer = (bfd_byte *) bfd_malloc (compressed_size);
d203 2
a204 1
      rawsize = sec->rawsize;
d209 1
a209 1
      sec->size = compressed_size;
d212 1
a212 1
				      0, compressed_size);
d214 2
a215 2
      sec->rawsize = rawsize;
      sec->size = uncompressed_size;
d220 3
a222 2
      uncompressed_buffer = (bfd_byte *) bfd_malloc (uncompressed_size);
      if (uncompressed_buffer == NULL)
d225 1
a225 2
      if (!decompress_contents (compressed_buffer, compressed_size,
				uncompressed_buffer, uncompressed_size))
d228 2
a229 1
	  free (uncompressed_buffer);
d236 2
a237 3
      sec->contents = uncompressed_buffer;
      sec->compress_status = COMPRESS_SECTION_DONE;
      /* Fall thru */
@


1.14
log
@	* compress.c (bfd_get_full_section_contents): Don't cache
	decompressed contents.
@
text
@d168 1
d223 2
a224 3
      if (p == NULL)
	p = (bfd_byte *) bfd_malloc (uncompressed_size);
      if (p == NULL)
d228 1
a228 1
				p, uncompressed_size))
d231 1
a231 1
	  free (p);
d238 3
a240 2
      *ptr = p;
      return TRUE;
@


1.13
log
@ChangeLog bfd

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* coff-i386.c (bfd_target): Add section flag SEC_EXCLUDE.
	Allow BFD_COMPRESS and BFD_DECOMPRESS flags.
	* coff-x86_64.c: Likewise.
	* coffcode.h (DOT_ZDEBUG): New define.
	(sec_to_styp_flags): Check for .zdebug.
	(styp_to_sec_flags): Likewise.
	* coffgen.c (make_a_section): Handle .debug_* section
	compression/decompression flags.
	* cofflink.c (mark_relocs): Ignore relocations
	for a section, which isn't marked as used.
	(_bfd_coff_link_input_bfd): Add support of compressed
	debug sections.
	* compress.c (decompress_contents): Loop as long
	as there is input available and there is room for
	output.
	* bfd/pe-arm.c: Add .zdebug_ partial match entry.
	* pe-i386.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't clear all
	data-directories as this might destroy content.

        * coff-i386.c (_bfd_generic_find_nearest_line_discriminator):
        define as coff_find_nearest_line_discriminator.
        * libcoff-in.h (coff_find_nearest_line_discriminator): New
        * libcoff.h: Regenerated.
        * coff-x86_64.c: Likewise.
        * coffgen.c (coff_find_nearest_line_discriminator): New function.
        prototype.

ChangeLog binutils

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	* objdump.c (dump_bfd): Call dump headers after
	call of slurp_symtab.

ChangeLog ld

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* NEWS: Menition new feature.
	* scripttempl/pep.sc: Add zdebug sections.
	* scripttempl/pe.sc: L
@
text
@a167 1
  bfd_byte *uncompressed_buffer;
d222 3
a224 2
      uncompressed_buffer = (bfd_byte *) bfd_malloc (uncompressed_size);
      if (uncompressed_buffer == NULL)
d228 1
a228 1
				uncompressed_buffer, uncompressed_size))
d231 1
a231 1
	  free (uncompressed_buffer);
d238 2
a239 3
      sec->contents = uncompressed_buffer;
      sec->compress_status = COMPRESS_SECTION_DONE;
      /* Fall thru */
@


1.12
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d49 1
a49 1
  while (strm.avail_in > 0)
@


1.11
log
@When computing checksums, skip the contents of sections with the SHT_NOBITS type.
Revert change to compress.c
@
text
@d2 1
a2 1
   Copyright 2008, 2010, 2011
a21 1
#include "config.h"
@


1.10
log
@	PR ld/12451
	* elfcode.h (elf_checksum_contents): Read in the section's
	contents if they are not already available.
	* compress.c (bfd_get_full_section_contents): Use zmalloc to
	allocate the buffers so that excess bytes are guaranteed to be
	zero.
@
text
@d184 1
a184 1
	  p = (bfd_byte *) bfd_zmalloc (sz);
d224 1
a224 1
      uncompressed_buffer = (bfd_byte *) bfd_zmalloc (uncompressed_size);
@


1.9
log
@	* bfd-in.h (bfd_get_section_limit): Don't use rawsize with output
	sections.
	* libbfd.c (_bfd_generic_get_section_contents): Likewise.
	(_bfd_generic_get_section_contents_in_window): Likewise.
	* section.c (bfd_get_section_contents): Likewise.
	* compress.c (bfd_get_full_section_contents): Likewise.
	* elf32-rx.c (rx_final_link): Ignore rawsize.
	* elf32-microblaze.c (microblaze_elf_relocate_section): Use correct
	bfd with bfd_get_section_limit.
	* elfxx-ia64.c (elfNN_ia64_choose_gp): Add "final" parameter.  Use
	os->size during final link.  Update callers.
	* bfd-in2.h: Regenerate.
@
text
@d184 1
a184 1
	  p = (bfd_byte *) bfd_malloc (sz);
d224 1
a224 1
      uncompressed_buffer = (bfd_byte *) bfd_malloc (uncompressed_size);
@


1.8
log
@2011-03-05  Michael Snyder  <msnyder@@vmware.com>

	* compress.c (bfd_compress_section_contents): Check for out of mem.
@
text
@d2 1
a2 1
   Copyright 2008, 2010
d161 1
a161 1
  bfd_size_type sz = sec->rawsize ? sec->rawsize : sec->size;
d172 4
@


1.7
log
@	* compress.c (decompress_contents): Style.
	(bfd_get_full_section_contents): Do not decompress directly into
	caller buffer or directly return cached section contents.
	Check malloc return for compressed_buffer.
@
text
@d103 3
@


1.6
log
@Use uLong on compressed_size when using zlib.

2010-10-29  Pawel Sikora  <pluto@@pld-linux.org>

	PR binutils/12075
	* compress.c (bfd_compress_section_contents): Use uLong on
	compressed_size.
@
text
@d62 1
a62 1
  return rc != Z_OK || strm.avail_out != 0 ? FALSE: TRUE;
a159 1
  bfd_boolean need_free, ret;
d161 1
a179 2
	  need_free = TRUE;
	  *ptr = p;
d181 7
a187 12
      else
	need_free = FALSE;
      ret = bfd_get_section_contents (abfd, sec, p, 0, sz);
      if (!ret && need_free)
	free (p);
      return ret;

    case COMPRESS_SECTION_DONE:
      if (p)
	memcpy (p, sec->contents, sz);
      else
	*ptr = sec->contents;
a190 6
      break;

    default:
      abort ();
    }

d192 2
a193 2
  bfd_set_error (bfd_error_invalid_operation);
  return FALSE;
d195 18
a212 19
  /* Read in the full compressed section contents.  */
  uncompressed_size = sec->size;
  compressed_size = sec->compressed_size;
  compressed_buffer = (bfd_byte *) bfd_malloc (compressed_size);
  rawsize = sec->rawsize;
  /* Clear rawsize, set size to compressed size and set compress_status
     to COMPRESS_SECTION_NONE.  If the compressed size is bigger than
     the uncompressed size, bfd_get_section_contents will fail.  */
  sec->rawsize = 0;
  sec->size = compressed_size;
  sec->compress_status = COMPRESS_SECTION_NONE;
  ret = bfd_get_section_contents (abfd, sec, compressed_buffer,
				  0, compressed_size);
  /* Restore rawsize and size.  */
  sec->rawsize = rawsize;
  sec->size = uncompressed_size;
  if (!ret)
    {
fail_compressed:
d214 2
a215 3
      free (compressed_buffer);
      return ret;
    }
a216 5
  /* Decompress to caller buffer directly if it is provided. */
  if (p)
    uncompressed_buffer = p;
  else
    {
a219 1
    }
d221 10
a230 4
  if (!decompress_contents (compressed_buffer, compressed_size,
			    uncompressed_buffer, uncompressed_size))
    {
      sec->compress_status = DECOMPRESS_SECTION_SIZED;
d232 6
d239 11
a249 3
	free (uncompressed_buffer);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
a250 10

  free (compressed_buffer);
  if (p == NULL)
    *ptr = uncompressed_buffer;

  sec->contents = uncompressed_buffer;
  sec->compress_status = COMPRESS_SECTION_DONE;

  return TRUE;
#endif
@


1.6.2.1
log
@backport from mainline
@
text
@d62 1
a62 1
  return rc == Z_OK && strm.avail_out == 0;
d160 1
a161 1
  bfd_boolean ret;
d180 2
d183 12
a194 7
      if (!bfd_get_section_contents (abfd, sec, p, 0, sz))
	{
	  if (*ptr != p)
	    free (p);
	  return FALSE;
	}
      *ptr = p;
d198 6
d205 2
a206 2
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
d208 19
a226 18
      /* Read in the full compressed section contents.  */
      uncompressed_size = sec->size;
      compressed_size = sec->compressed_size;
      compressed_buffer = (bfd_byte *) bfd_malloc (compressed_size);
      if (compressed_buffer == NULL)
	return FALSE;
      rawsize = sec->rawsize;
      /* Clear rawsize, set size to compressed size and set compress_status
	 to COMPRESS_SECTION_NONE.  If the compressed size is bigger than
	 the uncompressed size, bfd_get_section_contents will fail.  */
      sec->rawsize = 0;
      sec->size = compressed_size;
      sec->compress_status = COMPRESS_SECTION_NONE;
      ret = bfd_get_section_contents (abfd, sec, compressed_buffer,
				      0, compressed_size);
      /* Restore rawsize and size.  */
      sec->rawsize = rawsize;
      sec->size = uncompressed_size;
d228 3
a230 2
      if (!ret)
	goto fail_compressed;
d232 5
d240 1
d242 10
a251 9
      if (!decompress_contents (compressed_buffer, compressed_size,
				uncompressed_buffer, uncompressed_size))
	{
	  bfd_set_error (bfd_error_bad_value);
	  free (uncompressed_buffer);
	fail_compressed:
	  free (compressed_buffer);
	  return FALSE;
	}
d253 3
a255 5
      free (compressed_buffer);
      sec->contents = uncompressed_buffer;
      sec->compress_status = COMPRESS_SECTION_DONE;
      /* Fall thru */
#endif
d257 2
a258 10
    case COMPRESS_SECTION_DONE:
      if (p == NULL)
	{
	  p = (bfd_byte *) bfd_malloc (sz);
	  if (p == NULL)
	    return FALSE;
	  *ptr = p;
	}
      memcpy (p, sec->contents, sz);
      return TRUE;
d260 2
a261 3
    default:
      abort ();
    }
@


1.5
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d97 1
a97 1
  bfd_size_type compressed_size;
@


1.4
log
@bfd/ChangeLog:

	* compress.c (bfd_uncompress_section_contents): Add ATTRIBUTE_UNUSED.
	* dwarf2.c (read_and_uncompress_section): New function.
	(read_section): Call it.
	(find_line): Likewise.

binutils/ChangeLog:

	* objdump.c (load_specific_debug_section): Decompress section contents
	before applying relocations.
	* readelf.c (load_specific_debug_section): Update section size after
	decompression.

gas/ChangeLog:

	* Makefile.am: Add compress-debug.c and compress-debug.h.
	* Makefile.in: Regenerate.
	* config.in: Add HAVE_ZLIB_H.
	* configure.in: Check for zlib.h.
	* configure: Regenerate.

	* as.c (parse_args): Add --compress-debug-sections and
	--nocompress-debug-sections.
	* as.h (flag_compress_debug): New variable.
	* compress-debug.c: New file.
	* compress-debug.h: New file.
	* write.c: Include compress-debug.h.
	(compress_frag): New function.
	(compress_debug): New function.
	(write_object_file): Compress debug sections if requested.
@
text
@d30 36
d68 1
a68 1
	bfd_uncompress_section_contents
d71 3
a73 2
	bfd_boolean bfd_uncompress_section_contents
	  (bfd_byte **buffer, bfd_size_type *size);
d77 5
a81 8
	Uncompresses a section that was compressed using zlib, in place.  At
	the call to this function, *@@var{buffer} and *@@var{size} should point
	to the section contents to be uncompressed.  At the end of the
	function, *@@var{buffer} and *@@var{size} will point to the uncompressed
	contents.  This function assumes *BUFFER was allocated using
	bfd_malloc() or equivalent.  If the section is not a valid compressed
	section, or zlib is not installed on this machine, the input is
	unmodified.
d83 2
a84 2
        Returns @@code{FALSE} if unable to uncompress successfully; in that case
        the input is unmodified.  Otherwise, returns @@code{TRUE}.
d88 4
a91 2
bfd_uncompress_section_contents (bfd_byte **buffer ATTRIBUTE_UNUSED,
				 bfd_size_type *size ATTRIBUTE_UNUSED)
d94 1
d97 66
a162 2
  bfd_size_type compressed_size = *size;
  bfd_byte *compressed_buffer = *buffer;
d164 2
d167 157
a323 3
  z_stream strm;
  int rc;
  bfd_size_type header_size = 12;
d327 6
a332 3
  if (compressed_size < header_size
      || ! CONST_STRNEQ ((char*) compressed_buffer, "ZLIB"))
    return FALSE;
d342 36
a377 11
  /* It is possible the section consists of several compressed
     buffers concatenated together, so we uncompress in a loop.  */
  strm.zalloc = NULL;
  strm.zfree = NULL;
  strm.opaque = NULL;
  strm.avail_in = compressed_size - header_size;
  strm.next_in = (Bytef*) compressed_buffer + header_size;
  strm.avail_out = uncompressed_size;
  uncompressed_buffer = (bfd_byte *) bfd_malloc (uncompressed_size);
  if (! uncompressed_buffer)
    return FALSE;
d379 6
a384 2
  rc = inflateInit (&strm);
  while (strm.avail_in > 0)
d386 2
a387 8
      if (rc != Z_OK)
        goto fail;
      strm.next_out = ((Bytef*) uncompressed_buffer
                       + (uncompressed_size - strm.avail_out));
      rc = inflate (&strm, Z_FINISH);
      if (rc != Z_STREAM_END)
        goto fail;
      rc = inflateReset (&strm);
a388 4
  rc = inflateEnd (&strm);
  if (rc != Z_OK
      || strm.avail_out != 0)
    goto fail;
d390 10
a399 4
  free (compressed_buffer);
  *buffer = uncompressed_buffer;
  *size = uncompressed_size;
  return TRUE;
a400 1
 fail:
d402 2
a403 2
  return FALSE;
#endif  /* HAVE_ZLIB_H */
@


1.3
log
@	* compress.c (bfd_uncompress_section_contents): Use ATTRIBUTE_UNUSED
	to silence gcc warning.
@
text
@d1 1
a1 1
/* ELF attributes support (based on ARM EABI attributes).
@


1.2
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d2 1
a2 1
   Copyright 2008
d54 2
a55 1
bfd_uncompress_section_contents (bfd_byte **buffer, bfd_size_type *size)
a57 3
  /* These are just to quiet gcc.  */
  buffer = 0;
  size = 0;
@


1.1
log
@bfd/
	* Makefile.am (BFD32_LIBS): Add compress.lo.
	(BFD32_LIBS_CFILES): Add compress.c.
	(BFD_H_FILES): Likewise.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf2.c (read_section): New function.
	(read_indirect_string): Call new function read_section.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Call new function read_section when just one
	.zdebug_info section is found, otherwise read and compress
	multiple sections.
	(_bfd_dwarf2_cleanup_debug_info): Free sec_info_ptr.
	* elf.c (_bfd_elf_make_section_from_shdr): Add zdebug prefix.
	(special_sections_z): New struct.
	(special_sections): Refer to special_sections_z.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Recognize
	sections named .zdebug_*.
	(_bfd_mips_elf_fake_sections): Likewise.
	* compress.c: New file.
	(bfd_uncompress_section_contents): New function.
bfd/doc/
	* Makefile.am (BFD_H_DEP): Add ../compress.c.
	* Makefile.in: Regenerate.
binutils/
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf.c (debug_displays): Add .zdebug_* strings.
	* dwarf.h (struct dwarf_section): Add fields uncompressed_namd
	and compressed_name.
	* objdump.c (load_debug_section): Call
	bfd_uncompress_section_contents when loading a compressed
	section.
	(dump_dwarf_section): Recognize compressed section name.
	(mach_o_dwarf_sections): Rename as
	mach_o_uncompressed_dwarf_sections.
	(mach_o_compressed_dwarf_sections): New variable.
	(generic_dwarf_section): Rename as
	generic_uncompressed_dwarf_sections.
	(generic_compressed_dwarf_sections): New variable.
	(check_mach_o_dwarf): Save and restore
	mach_o_compressed_dwarf_sections.
	* readelf.c: Add #include for config.h and zlib.h
	(process_section_headers): Recognize compressed section name.
	(uncompress_section_contents): New function.
	(load_debug_section): Call uncompress_section_contents when
	loading a compressed section.
	(display_debug_section): Recognize compressed section name.
binutils/testsuite:
	* binutils-all/objdump.exp: Add test for objdump -s on a file
	with a compressed debug section.  Add test for objdump -W on a
	file that contains a compressed debug section.
	* binutils-all/readelf.exp: Call readelf_compressed_wa_test.
	(readelf_compressed_wa_test): New function.
	* binutils-all/dw2-compressed.S: New file.
	* binutils-all/objdump.W: New file.
	* binutils-all/objdump.s: New file.
	* binutils-all/readelf.wa: New file.
@
text
@d92 1
a92 1
  uncompressed_buffer = bfd_malloc (uncompressed_size);
@


1.1.18.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d92 1
a92 1
  uncompressed_buffer = (bfd_byte *) bfd_malloc (uncompressed_size);
@


