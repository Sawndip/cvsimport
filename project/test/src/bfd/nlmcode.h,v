head	1.23;
access;
symbols
	sid-snapshot-20180601:1.23
	sid-snapshot-20180501:1.23
	sid-snapshot-20180401:1.23
	sid-snapshot-20180301:1.23
	sid-snapshot-20180201:1.23
	sid-snapshot-20180101:1.23
	sid-snapshot-20171201:1.23
	sid-snapshot-20171101:1.23
	sid-snapshot-20171001:1.23
	sid-snapshot-20170901:1.23
	sid-snapshot-20170801:1.23
	sid-snapshot-20170701:1.23
	sid-snapshot-20170601:1.23
	sid-snapshot-20170501:1.23
	sid-snapshot-20170401:1.23
	sid-snapshot-20170301:1.23
	sid-snapshot-20170201:1.23
	sid-snapshot-20170101:1.23
	sid-snapshot-20161201:1.23
	sid-snapshot-20161101:1.23
	sid-snapshot-20160901:1.23
	sid-snapshot-20160801:1.23
	sid-snapshot-20160701:1.23
	sid-snapshot-20160601:1.23
	sid-snapshot-20160501:1.23
	sid-snapshot-20160401:1.23
	sid-snapshot-20160301:1.23
	sid-snapshot-20160201:1.23
	sid-snapshot-20160101:1.23
	sid-snapshot-20151201:1.23
	sid-snapshot-20151101:1.23
	sid-snapshot-20151001:1.23
	sid-snapshot-20150901:1.23
	sid-snapshot-20150801:1.23
	sid-snapshot-20150701:1.23
	sid-snapshot-20150601:1.23
	sid-snapshot-20150501:1.23
	sid-snapshot-20150401:1.23
	sid-snapshot-20150301:1.23
	sid-snapshot-20150201:1.23
	sid-snapshot-20150101:1.23
	sid-snapshot-20141201:1.23
	sid-snapshot-20141101:1.23
	sid-snapshot-20141001:1.23
	sid-snapshot-20140901:1.23
	sid-snapshot-20140801:1.23
	sid-snapshot-20140701:1.23
	sid-snapshot-20140601:1.23
	sid-snapshot-20140501:1.23
	sid-snapshot-20140401:1.23
	sid-snapshot-20140301:1.23
	sid-snapshot-20140201:1.23
	sid-snapshot-20140101:1.23
	sid-snapshot-20131201:1.23
	sid-snapshot-20131101:1.23
	sid-snapshot-20131001:1.23
	binutils-2_24-branch:1.23.0.14
	binutils-2_24-branchpoint:1.23
	binutils-2_21_1:1.22
	sid-snapshot-20130901:1.23
	gdb_7_6_1-2013-08-30-release:1.23
	sid-snapshot-20130801:1.23
	sid-snapshot-20130701:1.23
	sid-snapshot-20130601:1.23
	sid-snapshot-20130501:1.23
	gdb_7_6-2013-04-26-release:1.23
	sid-snapshot-20130401:1.23
	binutils-2_23_2:1.23
	gdb_7_6-branch:1.23.0.12
	gdb_7_6-2013-03-12-branchpoint:1.23
	sid-snapshot-20130301:1.23
	sid-snapshot-20130201:1.23
	sid-snapshot-20130101:1.23
	sid-snapshot-20121201:1.23
	gdb_7_5_1-2012-11-29-release:1.23
	binutils-2_23_1:1.23
	sid-snapshot-20121101:1.23
	binutils-2_23:1.23
	sid-snapshot-20121001:1.23
	sid-snapshot-20120901:1.23
	gdb_7_5-2012-08-17-release:1.23
	sid-snapshot-20120801:1.23
	binutils-2_23-branch:1.23.0.10
	binutils-2_23-branchpoint:1.23
	gdb_7_5-branch:1.23.0.8
	gdb_7_5-2012-07-18-branchpoint:1.23
	sid-snapshot-20120701:1.23
	sid-snapshot-20120601:1.23
	sid-snapshot-20120501:1.23
	binutils-2_22_branch:1.23.0.6
	gdb_7_4_1-2012-04-26-release:1.23
	sid-snapshot-20120401:1.23
	sid-snapshot-20120301:1.23
	sid-snapshot-20120201:1.23
	gdb_7_4-2012-01-24-release:1.23
	sid-snapshot-20120101:1.23
	gdb_7_4-branch:1.23.0.4
	gdb_7_4-2011-12-13-branchpoint:1.23
	sid-snapshot-20111201:1.23
	binutils-2_22:1.23
	sid-snapshot-20111101:1.23
	sid-snapshot-20111001:1.23
	binutils-2_22-branch:1.23.0.2
	binutils-2_22-branchpoint:1.23
	gdb_7_3_1-2011-09-04-release:1.22
	sid-snapshot-20110901:1.23
	sid-snapshot-20110801:1.23
	gdb_7_3-2011-07-26-release:1.22
	sid-snapshot-20110701:1.23
	sid-snapshot-20110601:1.22
	sid-snapshot-20110501:1.22
	gdb_7_3-branch:1.22.0.42
	gdb_7_3-2011-04-01-branchpoint:1.22
	sid-snapshot-20110401:1.22
	sid-snapshot-20110301:1.22
	sid-snapshot-20110201:1.22
	sid-snapshot-20110101:1.22
	binutils-2_21:1.22
	sid-snapshot-20101201:1.22
	binutils-2_21-branch:1.22.0.40
	binutils-2_21-branchpoint:1.22
	sid-snapshot-20101101:1.22
	sid-snapshot-20101001:1.22
	binutils-2_20_1:1.22
	gdb_7_2-2010-09-02-release:1.22
	sid-snapshot-20100901:1.22
	sid-snapshot-20100801:1.22
	gdb_7_2-branch:1.22.0.38
	gdb_7_2-2010-07-07-branchpoint:1.22
	sid-snapshot-20100701:1.22
	sid-snapshot-20100601:1.22
	sid-snapshot-20100501:1.22
	sid-snapshot-20100401:1.22
	gdb_7_1-2010-03-18-release:1.22
	sid-snapshot-20100301:1.22
	gdb_7_1-branch:1.22.0.36
	gdb_7_1-2010-02-18-branchpoint:1.22
	sid-snapshot-20100201:1.22
	sid-snapshot-20100101:1.22
	gdb_7_0_1-2009-12-22-release:1.22
	sid-snapshot-20091201:1.22
	sid-snapshot-20091101:1.22
	binutils-2_20:1.22
	gdb_7_0-2009-10-06-release:1.22
	sid-snapshot-20091001:1.22
	gdb_7_0-branch:1.22.0.34
	gdb_7_0-2009-09-16-branchpoint:1.22
	arc-sim-20090309:1.22
	binutils-arc-20081103-branch:1.22.0.32
	binutils-arc-20081103-branchpoint:1.22
	binutils-2_20-branch:1.22.0.30
	binutils-2_20-branchpoint:1.22
	sid-snapshot-20090901:1.22
	sid-snapshot-20090801:1.22
	msnyder-checkpoint-072509-branch:1.22.0.28
	msnyder-checkpoint-072509-branchpoint:1.22
	sid-snapshot-20090701:1.22
	dje-cgen-play1-branch:1.22.0.26
	dje-cgen-play1-branchpoint:1.22
	sid-snapshot-20090601:1.22
	sid-snapshot-20090501:1.22
	sid-snapshot-20090401:1.22
	arc-20081103-branch:1.22.0.24
	arc-20081103-branchpoint:1.22
	arc-insight_6_8-branch:1.22.0.22
	arc-insight_6_8-branchpoint:1.22
	insight_6_8-branch:1.22.0.20
	insight_6_8-branchpoint:1.22
	sid-snapshot-20090301:1.22
	binutils-2_19_1:1.22
	sid-snapshot-20090201:1.22
	sid-snapshot-20090101:1.22
	reverse-20081226-branch:1.22.0.18
	reverse-20081226-branchpoint:1.22
	sid-snapshot-20081201:1.22
	multiprocess-20081120-branch:1.22.0.16
	multiprocess-20081120-branchpoint:1.22
	sid-snapshot-20081101:1.22
	binutils-2_19:1.22
	sid-snapshot-20081001:1.22
	reverse-20080930-branch:1.22.0.14
	reverse-20080930-branchpoint:1.22
	binutils-2_19-branch:1.22.0.12
	binutils-2_19-branchpoint:1.22
	sid-snapshot-20080901:1.22
	sid-snapshot-20080801:1.22
	reverse-20080717-branch:1.22.0.10
	reverse-20080717-branchpoint:1.22
	sid-snapshot-20080701:1.22
	msnyder-reverse-20080609-branch:1.22.0.8
	msnyder-reverse-20080609-branchpoint:1.22
	drow-reverse-20070409-branch:1.20.0.4
	drow-reverse-20070409-branchpoint:1.20
	sid-snapshot-20080601:1.22
	sid-snapshot-20080501:1.22
	sid-snapshot-20080403:1.22
	sid-snapshot-20080401:1.22
	gdb_6_8-2008-03-27-release:1.22
	sid-snapshot-20080301:1.22
	gdb_6_8-branch:1.22.0.6
	gdb_6_8-2008-02-26-branchpoint:1.22
	sid-snapshot-20080201:1.22
	sid-snapshot-20080101:1.22
	sid-snapshot-20071201:1.22
	sid-snapshot-20071101:1.22
	gdb_6_7_1-2007-10-29-release:1.22
	gdb_6_7-2007-10-10-release:1.22
	sid-snapshot-20071001:1.22
	gdb_6_7-branch:1.22.0.4
	gdb_6_7-2007-09-07-branchpoint:1.22
	binutils-2_18:1.22
	binutils-2_18-branch:1.22.0.2
	binutils-2_18-branchpoint:1.22
	insight_6_6-20070208-release:1.20
	binutils-csl-coldfire-4_1-32:1.17
	binutils-csl-sourcerygxx-4_1-32:1.17
	gdb_6_6-2006-12-18-release:1.20
	binutils-csl-innovasic-fido-3_4_4-33:1.17
	binutils-csl-sourcerygxx-3_4_4-32:1.14
	binutils-csl-coldfire-4_1-30:1.17
	binutils-csl-sourcerygxx-4_1-30:1.17
	binutils-csl-coldfire-4_1-28:1.17
	binutils-csl-sourcerygxx-4_1-29:1.17
	binutils-csl-sourcerygxx-4_1-28:1.17
	gdb_6_6-branch:1.20.0.2
	gdb_6_6-2006-11-15-branchpoint:1.20
	binutils-csl-arm-2006q3-27:1.17
	binutils-csl-sourcerygxx-4_1-27:1.17
	binutils-csl-arm-2006q3-26:1.17
	binutils-csl-sourcerygxx-4_1-26:1.17
	binutils-csl-sourcerygxx-4_1-25:1.17
	binutils-csl-sourcerygxx-4_1-24:1.17
	binutils-csl-sourcerygxx-4_1-23:1.17
	insight_6_5-20061003-release:1.17
	gdb-csl-symbian-6_4_50_20060226-12:1.17
	binutils-csl-sourcerygxx-4_1-21:1.17
	binutils-csl-arm-2006q3-21:1.17
	binutils-csl-sourcerygxx-4_1-22:1.17
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.17
	binutils-csl-sourcerygxx-4_1-20:1.17
	binutils-csl-arm-2006q3-19:1.17
	binutils-csl-sourcerygxx-4_1-19:1.17
	binutils-csl-sourcerygxx-4_1-18:1.17
	binutils-csl-renesas-4_1-9:1.17
	gdb-csl-sourcerygxx-3_4_4-25:1.17
	binutils-csl-sourcerygxx-3_4_4-25:1.14
	nickrob-async-20060828-mergepoint:1.18
	gdb-csl-symbian-6_4_50_20060226-11:1.17
	binutils-csl-renesas-4_1-8:1.17
	binutils-csl-renesas-4_1-7:1.17
	binutils-csl-renesas-4_1-6:1.17
	gdb-csl-sourcerygxx-4_1-17:1.17
	binutils-csl-sourcerygxx-4_1-17:1.17
	gdb-csl-20060226-branch-local-2:1.17
	gdb-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-15:1.17
	gdb-csl-sourcerygxx-4_1-13:1.17
	binutils-csl-sourcerygxx-4_1-13:1.17
	binutils-2_17:1.17
	gdb-csl-sourcerygxx-4_1-12:1.17
	binutils-csl-sourcerygxx-4_1-12:1.17
	gdb-csl-sourcerygxx-3_4_4-21:1.17
	binutils-csl-sourcerygxx-3_4_4-21:1.17
	gdb_6_5-20060621-release:1.17
	binutils-csl-wrs-linux-3_4_4-24:1.14
	binutils-csl-wrs-linux-3_4_4-23:1.14
	gdb-csl-sourcerygxx-4_1-9:1.17
	binutils-csl-sourcerygxx-4_1-9:1.17
	gdb-csl-sourcerygxx-4_1-8:1.17
	binutils-csl-sourcerygxx-4_1-8:1.17
	gdb-csl-sourcerygxx-4_1-7:1.17
	binutils-csl-sourcerygxx-4_1-7:1.17
	gdb-csl-arm-2006q1-6:1.17
	binutils-csl-arm-2006q1-6:1.17
	gdb-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-wrs-linux-3_4_4-22:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.17
	gdb-csl-symbian-6_4_50_20060226-9:1.17
	gdb-csl-symbian-6_4_50_20060226-8:1.17
	gdb-csl-coldfire-4_1-11:1.17
	binutils-csl-coldfire-4_1-11:1.17
	gdb-csl-sourcerygxx-3_4_4-19:1.17
	binutils-csl-sourcerygxx-3_4_4-19:1.17
	gdb-csl-coldfire-4_1-10:1.17
	gdb_6_5-branch:1.17.0.30
	gdb_6_5-2006-05-14-branchpoint:1.17
	binutils-csl-coldfire-4_1-10:1.17
	gdb-csl-sourcerygxx-4_1-5:1.17
	binutils-csl-sourcerygxx-4_1-5:1.17
	nickrob-async-20060513-branch:1.17.0.28
	nickrob-async-20060513-branchpoint:1.17
	gdb-csl-sourcerygxx-4_1-4:1.17
	binutils-csl-sourcerygxx-4_1-4:1.17
	msnyder-reverse-20060502-branch:1.17.0.26
	msnyder-reverse-20060502-branchpoint:1.17
	binutils-csl-wrs-linux-3_4_4-21:1.14
	gdb-csl-morpho-4_1-4:1.17
	binutils-csl-morpho-4_1-4:1.17
	gdb-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-wrs-linux-3_4_4-20:1.14
	readline_5_1-import-branch:1.17.0.24
	readline_5_1-import-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.17
	binutils-2_17-branch:1.17.0.22
	binutils-2_17-branchpoint:1.17
	gdb-csl-symbian-20060226-branch:1.17.0.20
	gdb-csl-symbian-20060226-branchpoint:1.17
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.17
	msnyder-reverse-20060331-branch:1.17.0.18
	msnyder-reverse-20060331-branchpoint:1.17
	binutils-csl-2_17-branch:1.17.0.16
	binutils-csl-2_17-branchpoint:1.17
	gdb-csl-available-20060303-branch:1.17.0.14
	gdb-csl-available-20060303-branchpoint:1.17
	gdb-csl-20060226-branch:1.17.0.12
	gdb-csl-20060226-branchpoint:1.17
	gdb_6_4-20051202-release:1.17
	msnyder-fork-checkpoint-branch:1.17.0.10
	msnyder-fork-checkpoint-branchpoint:1.17
	gdb-csl-gxxpro-6_3-branch:1.17.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.17
	gdb_6_4-branch:1.17.0.6
	gdb_6_4-2005-11-01-branchpoint:1.17
	gdb-csl-arm-20051020-branch:1.17.0.4
	gdb-csl-arm-20051020-branchpoint:1.17
	binutils-csl-gxxpro-3_4-branch:1.14.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.14
	binutils-2_16_1:1.14
	msnyder-tracepoint-checkpoint-branch:1.17.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.17
	gdb-csl-arm-20050325-2005-q1b:1.14
	binutils-csl-arm-2005q1b:1.14
	binutils-2_16:1.14
	gdb-csl-arm-20050325-2005-q1a:1.14
	binutils-csl-arm-2005q1a:1.14
	csl-arm-20050325-branch:1.14.0.6
	csl-arm-20050325-branchpoint:1.14
	binutils-csl-arm-2005q1-branch:1.14.0.4
	binutils-csl-arm-2005q1-branchpoint:1.14
	binutils-2_16-branch:1.14.0.2
	binutils-2_16-branchpoint:1.14
	csl-arm-2004-q3d:1.12
	gdb_6_3-20041109-release:1.12
	gdb_6_3-branch:1.12.0.4
	gdb_6_3-20041019-branchpoint:1.12
	csl-arm-2004-q3:1.12
	drow_intercu-merge-20040921:1.12
	drow_intercu-merge-20040915:1.12
	jimb-gdb_6_2-e500-branch:1.12.0.6
	jimb-gdb_6_2-e500-branchpoint:1.12
	gdb_6_2-20040730-release:1.12
	gdb_6_2-branch:1.12.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.12
	gdb_6_1_1-20040616-release:1.11
	binutils-2_15:1.11
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.11
	csl-arm-2004-q1:1.11
	gdb_6_1-2004-04-05-release:1.11
	drow_intercu-merge-20040402:1.11
	drow_intercu-merge-20040327:1.11
	ezannoni_pie-20040323-branch:1.11.0.14
	ezannoni_pie-20040323-branchpoint:1.11
	cagney_tramp-20040321-mergepoint:1.11
	cagney_tramp-20040309-branch:1.11.0.12
	cagney_tramp-20040309-branchpoint:1.11
	gdb_6_1-branch:1.11.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.11
	drow_intercu-20040221-branch:1.11.0.8
	drow_intercu-20040221-branchpoint:1.11
	binutils-2_15-branch:1.11.0.6
	cagney_bfdfile-20040213-branch:1.11.0.4
	cagney_bfdfile-20040213-branchpoint:1.11
	drow-cplus-merge-20040208:1.11
	carlton_dictionary-20040126-merge:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	drow-cplus-merge-20040113:1.11
	csl-arm-2003-q4:1.11
	drow-cplus-merge-20031224:1.11
	drow-cplus-merge-20031220:1.11
	carlton_dictionary-20031215-merge:1.11
	drow-cplus-merge-20031214:1.11
	carlton-dictionary-20031111-merge:1.11
	gdb_6_0-2003-10-04-release:1.9
	kettenis_sparc-20030918-branch:1.9.0.42
	kettenis_sparc-20030918-branchpoint:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.40
	cagney_x86i386-20030821-branch:1.9.0.38
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.36
	gdb_6_0-2003-06-23-branchpoint:1.9
	jimb-ppc64-linux-20030613-branch:1.9.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.9
	binutils-2_14:1.9
	cagney_convert-20030606-branch:1.9.0.32
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.9.0.30
	cagney_writestrings-20030508-branchpoint:1.9
	jimb-ppc64-linux-20030528-branch:1.9.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.26
	cagney_fileio-20030521-branchpoint:1.9
	kettenis_i386newframe-20030517-mergepoint:1.9
	jimb-ppc64-linux-20030509-branch:1.9.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.9
	kettenis_i386newframe-20030504-mergepoint:1.9
	carlton_dictionary-20030430-merge:1.9
	binutils-2_14-branch:1.9.0.22
	binutils-2_14-branchpoint:1.9
	kettenis_i386newframe-20030419-branch:1.9.0.20
	kettenis_i386newframe-20030419-branchpoint:1.9
	carlton_dictionary-20030416-merge:1.9
	cagney_frameaddr-20030409-mergepoint:1.9
	kettenis_i386newframe-20030406-branch:1.9.0.18
	kettenis_i386newframe-20030406-branchpoint:1.9
	cagney_frameaddr-20030403-branchpoint:1.9
	cagney_frameaddr-20030403-branch:1.9.0.16
	cagney_framebase-20030330-mergepoint:1.9
	cagney_framebase-20030326-branch:1.9.0.14
	cagney_framebase-20030326-branchpoint:1.9
	cagney_lazyid-20030317-branch:1.9.0.12
	cagney_lazyid-20030317-branchpoint:1.9
	kettenis-i386newframe-20030316-mergepoint:1.9
	offbyone-20030313-branch:1.9.0.10
	offbyone-20030313-branchpoint:1.9
	kettenis-i386newframe-20030308-branch:1.9.0.8
	kettenis-i386newframe-20030308-branchpoint:1.9
	carlton_dictionary-20030305-merge:1.9
	cagney_offbyone-20030303-branch:1.9.0.6
	cagney_offbyone-20030303-branchpoint:1.9
	carlton_dictionary-20030207-merge:1.9
	interps-20030202-branch:1.9.0.4
	interps-20030202-branchpoint:1.9
	cagney-unwind-20030108-branch:1.9.0.2
	cagney-unwind-20030108-branchpoint:1.9
	binutils-2_13_2_1:1.7.2.1
	binutils-2_13_2:1.7.2.1
	carlton_dictionary-20021223-merge:1.9
	gdb_5_3-2002-12-12-release:1.8
	carlton_dictionary-20021115-merge:1.8
	binutils-2_13_1:1.7.2.1
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.12
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.8
	carlton_dictionary-branch:1.8.0.10
	carlton_dictionary-20020920-branchpoint:1.8
	sid-20020905-branchpoint:1.8
	sid-20020905-branch:1.8.0.8
	gdb_5_3-branch:1.8.0.6
	gdb_5_3-2002-09-04-branchpoint:1.8
	kseitz_interps-20020829-merge:1.8
	cagney_sysregs-20020825-branch:1.8.0.4
	cagney_sysregs-20020825-branchpoint:1.8
	readline_4_3-import-branch:1.8.0.2
	readline_4_3-import-branchpoint:1.8
	binutils-2_13:1.7.2.1
	gdb_5_2_1-2002-07-23-release:1.6
	binutils-2_13-branchpoint:1.7
	binutils-2_13-branch:1.7.0.2
	kseitz_interps-20020528-branch:1.6.0.10
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.8
	cagney_regbuf-20020515-branchpoint:1.6
	binutils-2_12_1:1.6
	jimb-macro-020506-branch:1.6.0.6
	jimb-macro-020506-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	binutils-2_12:1.6
	gdb_5_2-branch:1.6.0.4
	gdb_5_2-2002-03-03-branchpoint:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	insight-precleanup-2001-01-01:1.3
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	gdb-premipsmulti-2000-06-06-branch:1.2.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.2
	gdb_5_0-2000-05-19-release:1.2
	gdb_4_18_2-2000-05-18-release:1.2
	gdb_4_95_1-2000-05-11-snapshot:1.2
	gdb_4_95_0-2000-04-27-snapshot:1.2
	gdb_5_0-2000-04-10-branch:1.2.0.4
	gdb_5_0-2000-04-10-branchpoint:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.23
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2011.06.02.13.43.14;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2006.09.28.12.59.25;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.04.15.53.36;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.04.07.19.33;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.21.07.45.38;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.03.11.41.00;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.19.11.58.02;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.24.04.46.25;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.04.10.41.52;	author amodra;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	2003.10.16.04.11.07;	author cagney;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.23.10.25.34;	author nickc;	state Exp;
branches
	1.8.10.1
	1.8.12.1;
next	1.7;

1.7
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.09.18.09.57.25;	author amodra;	state Exp;
branches
	1.6.10.1;
next	1.5;

1.5
date	2001.08.23.15.45.19;	author hjl;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.21.04.01;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.12.12.21.25.54;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.07.12.10.29.54;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.11.8.1
date	2004.09.16.17.00.36;	author drow;	state Exp;
branches;
next	;

1.8.10.1
date	2002.12.23.19.37.56;	author carlton;	state Exp;
branches;
next	1.8.10.2;

1.8.10.2
date	2003.11.11.23.50.28;	author carlton;	state Exp;
branches;
next	;

1.8.12.1
date	2003.12.14.20.26.50;	author drow;	state Exp;
branches;
next	;

1.7.2.1
date	2002.07.23.10.26.05;	author nickc;	state Exp;
branches;
next	;

1.6.10.1
date	2002.07.22.21.46.48;	author kseitz;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2002.08.09.18.34.17;	author kseitz;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Fix spelling mistakes.
@
text
@/* NLM (NetWare Loadable Module) executable support for BFD.
   Copyright 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2011  Free Software Foundation, Inc.

   Written by Fred Fish @@ Cygnus Support, using ELF support as the
   template.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "libnlm.h"

/* The functions in this file do not use the names they appear to use.
   This file is actually compiled multiple times, once for each size
   of NLM target we are using.  At each size we use a different name,
   constructed by the macro nlmNAME.  For example, the function which
   is named nlm_symbol_type below is actually named nlm32_symbol_type
   in the final executable.  */

#define Nlm_External_Fixed_Header	NlmNAME (External_Fixed_Header)
#define Nlm_External_Version_Header	NlmNAME (External_Version_Header)
#define Nlm_External_Copyright_Header	NlmNAME (External_Copyright_Header)
#define Nlm_External_Extended_Header	NlmNAME (External_Extended_Header)
#define Nlm_External_Custom_Header	NlmNAME (External_Custom_Header)
#define Nlm_External_Cygnus_Ext_Header	NlmNAME (External_Cygnus_Ext_Header)

#define nlm_symbol_type			nlmNAME (symbol_type)
#define nlm_get_symtab_upper_bound	nlmNAME (get_symtab_upper_bound)
#define nlm_canonicalize_symtab		nlmNAME (canonicalize_symtab)
#define nlm_make_empty_symbol		nlmNAME (make_empty_symbol)
#define nlm_print_symbol		nlmNAME (print_symbol)
#define nlm_get_symbol_info		nlmNAME (get_symbol_info)
#define nlm_get_reloc_upper_bound	nlmNAME (get_reloc_upper_bound)
#define nlm_canonicalize_reloc		nlmNAME (canonicalize_reloc)
#define nlm_object_p			nlmNAME (object_p)
#define nlm_set_section_contents	nlmNAME (set_section_contents)
#define nlm_write_object_contents	nlmNAME (write_object_contents)

#define nlm_swap_fixed_header_in(abfd,src,dst) \
  (nlm_swap_fixed_header_in_func (abfd)) (abfd, src, dst)
#define nlm_swap_fixed_header_out(abfd,src,dst) \
  (nlm_swap_fixed_header_out_func (abfd)) (abfd, src, dst)

/* Should perhaps use put_offset, put_word, etc.  For now, the two versions
   can be handled by explicitly specifying 32 bits or "the long type".  */
#if ARCH_SIZE == 64
#define put_word	H_PUT_64
#define get_word	H_GET_64
#endif
#if ARCH_SIZE == 32
#define put_word	H_PUT_32
#define get_word	H_GET_32
#endif

/* Read and swap in the variable length header.  All the fields must
   exist in the NLM, and must exist in the order they are read here.  */

static bfd_boolean
nlm_swap_variable_header_in (bfd *abfd)
{
  unsigned char temp[NLM_TARGET_LONG_SIZE];
  bfd_size_type amt;

  /* Read the description length and text members.  */
  amt = sizeof (nlm_variable_header (abfd)->descriptionLength);
  if (bfd_bread ((void *) &nlm_variable_header (abfd)->descriptionLength,
		amt, abfd) != amt)
    return FALSE;
  amt = nlm_variable_header (abfd)->descriptionLength + 1;
  if (bfd_bread ((void *) nlm_variable_header (abfd)->descriptionText,
		amt, abfd) != amt)
    return FALSE;

  /* Read and convert the stackSize field.  */
  amt = sizeof (temp);
  if (bfd_bread ((void *) temp, amt, abfd) != amt)
    return FALSE;
  nlm_variable_header (abfd)->stackSize = get_word (abfd, (bfd_byte *) temp);

  /* Read and convert the reserved field.  */
  amt = sizeof (temp);
  if (bfd_bread ((void *) temp, amt, abfd) != amt)
    return FALSE;
  nlm_variable_header (abfd)->reserved = get_word (abfd, (bfd_byte *) temp);

  /* Read the oldThreadName field.  This field is a fixed length string.  */
  amt = sizeof (nlm_variable_header (abfd)->oldThreadName);
  if (bfd_bread ((void *) nlm_variable_header (abfd)->oldThreadName,
		amt, abfd) != amt)
    return FALSE;

  /* Read the screen name length and text members.  */
  amt = sizeof (nlm_variable_header (abfd)->screenNameLength);
  if (bfd_bread ((void *) & nlm_variable_header (abfd)->screenNameLength,
		amt, abfd) != amt)
    return FALSE;
  amt = nlm_variable_header (abfd)->screenNameLength + 1;
  if (bfd_bread ((void *) nlm_variable_header (abfd)->screenName,
		amt, abfd) != amt)
    return FALSE;

  /* Read the thread name length and text members.  */
  amt = sizeof (nlm_variable_header (abfd)->threadNameLength);
  if (bfd_bread ((void *) & nlm_variable_header (abfd)->threadNameLength,
		amt, abfd) != amt)
    return FALSE;
  amt = nlm_variable_header (abfd)->threadNameLength + 1;
  if (bfd_bread ((void *) nlm_variable_header (abfd)->threadName,
		amt, abfd) != amt)
    return FALSE;
  return TRUE;
}

/* Add a section to the bfd.  */

static bfd_boolean
add_bfd_section (bfd *abfd,
		 char *name,
		 file_ptr offset,
		 bfd_size_type size,
		 flagword flags)
{
  asection *newsect;

  newsect = bfd_make_section_with_flags (abfd, name, flags);
  if (newsect == NULL)
    return FALSE;

  newsect->vma = 0;		/* NLM's are relocatable.  */
  newsect->size = size;
  newsect->filepos = offset;
  newsect->alignment_power = bfd_log2 ((bfd_vma) 0);	/* FIXME */

  return TRUE;
}

/* Read and swap in the contents of all the auxiliary headers.  Because of
   the braindead design, we have to do strcmps on strings of indeterminate
   length to figure out what each auxiliary header is.  Even worse, we have
   no way of knowing how many auxiliary headers there are or where the end
   of the auxiliary headers are, except by finding something that doesn't
   look like a known auxiliary header.  This means that the first new type
   of auxiliary header added will break all existing tools that don't
   recognize it.  */

static bfd_boolean
nlm_swap_auxiliary_headers_in (bfd *abfd)
{
  char tempstr[16];
  file_ptr position;
  bfd_size_type amt;

  for (;;)
    {
      position = bfd_tell (abfd);
      amt = sizeof (tempstr);
      if (bfd_bread ((void *) tempstr, amt, abfd) != amt)
	return FALSE;
      if (bfd_seek (abfd, position, SEEK_SET) != 0)
	return FALSE;
      if (CONST_STRNEQ (tempstr, "VeRsIoN#"))
	{
	  Nlm_External_Version_Header thdr;

	  amt = sizeof (thdr);
	  if (bfd_bread ((void *) &thdr, amt, abfd) != amt)
	    return FALSE;
	  memcpy (nlm_version_header (abfd)->stamp, thdr.stamp,
		  sizeof (thdr.stamp));
	  nlm_version_header (abfd)->majorVersion =
	    get_word (abfd, (bfd_byte *) thdr.majorVersion);
	  nlm_version_header (abfd)->minorVersion =
	    get_word (abfd, (bfd_byte *) thdr.minorVersion);
	  nlm_version_header (abfd)->revision =
	    get_word (abfd, (bfd_byte *) thdr.revision);
	  nlm_version_header (abfd)->year =
	    get_word (abfd, (bfd_byte *) thdr.year);
	  nlm_version_header (abfd)->month =
	    get_word (abfd, (bfd_byte *) thdr.month);
	  nlm_version_header (abfd)->day =
	    get_word (abfd, (bfd_byte *) thdr.day);
	}
      else if (CONST_STRNEQ (tempstr, "MeSsAgEs"))
	{
	  Nlm_External_Extended_Header thdr;

	  amt = sizeof (thdr);
	  if (bfd_bread ((void *) &thdr, amt, abfd) != amt)
	    return FALSE;
	  memcpy (nlm_extended_header (abfd)->stamp, thdr.stamp,
		  sizeof (thdr.stamp));
	  nlm_extended_header (abfd)->languageID =
	    get_word (abfd, (bfd_byte *) thdr.languageID);
	  nlm_extended_header (abfd)->messageFileOffset =
	    get_word (abfd, (bfd_byte *) thdr.messageFileOffset);
	  nlm_extended_header (abfd)->messageFileLength =
	    get_word (abfd, (bfd_byte *) thdr.messageFileLength);
	  nlm_extended_header (abfd)->messageCount =
	    get_word (abfd, (bfd_byte *) thdr.messageCount);
	  nlm_extended_header (abfd)->helpFileOffset =
	    get_word (abfd, (bfd_byte *) thdr.helpFileOffset);
	  nlm_extended_header (abfd)->helpFileLength =
	    get_word (abfd, (bfd_byte *) thdr.helpFileLength);
	  nlm_extended_header (abfd)->RPCDataOffset =
	    get_word (abfd, (bfd_byte *) thdr.RPCDataOffset);
	  nlm_extended_header (abfd)->RPCDataLength =
	    get_word (abfd, (bfd_byte *) thdr.RPCDataLength);
	  nlm_extended_header (abfd)->sharedCodeOffset =
	    get_word (abfd, (bfd_byte *) thdr.sharedCodeOffset);
	  nlm_extended_header (abfd)->sharedCodeLength =
	    get_word (abfd, (bfd_byte *) thdr.sharedCodeLength);
	  nlm_extended_header (abfd)->sharedDataOffset =
	    get_word (abfd, (bfd_byte *) thdr.sharedDataOffset);
	  nlm_extended_header (abfd)->sharedDataLength =
	    get_word (abfd, (bfd_byte *) thdr.sharedDataLength);
	  nlm_extended_header (abfd)->sharedRelocationFixupOffset =
	    get_word (abfd, (bfd_byte *) thdr.sharedRelocationFixupOffset);
	  nlm_extended_header (abfd)->sharedRelocationFixupCount =
	    get_word (abfd, (bfd_byte *) thdr.sharedRelocationFixupCount);
	  nlm_extended_header (abfd)->sharedExternalReferenceOffset =
	    get_word (abfd, (bfd_byte *) thdr.sharedExternalReferenceOffset);
	  nlm_extended_header (abfd)->sharedExternalReferenceCount =
	    get_word (abfd, (bfd_byte *) thdr.sharedExternalReferenceCount);
	  nlm_extended_header (abfd)->sharedPublicsOffset =
	    get_word (abfd, (bfd_byte *) thdr.sharedPublicsOffset);
	  nlm_extended_header (abfd)->sharedPublicsCount =
	    get_word (abfd, (bfd_byte *) thdr.sharedPublicsCount);
	  nlm_extended_header (abfd)->sharedDebugRecordOffset =
	    get_word (abfd, (bfd_byte *) thdr.sharedDebugRecordOffset);
	  nlm_extended_header (abfd)->sharedDebugRecordCount =
	    get_word (abfd, (bfd_byte *) thdr.sharedDebugRecordCount);
	  nlm_extended_header (abfd)->SharedInitializationOffset =
	    get_word (abfd, (bfd_byte *) thdr.sharedInitializationOffset);
	  nlm_extended_header (abfd)->SharedExitProcedureOffset =
	    get_word (abfd, (bfd_byte *) thdr.SharedExitProcedureOffset);
	  nlm_extended_header (abfd)->productID =
	    get_word (abfd, (bfd_byte *) thdr.productID);
	  nlm_extended_header (abfd)->reserved0 =
	    get_word (abfd, (bfd_byte *) thdr.reserved0);
	  nlm_extended_header (abfd)->reserved1 =
	    get_word (abfd, (bfd_byte *) thdr.reserved1);
	  nlm_extended_header (abfd)->reserved2 =
	    get_word (abfd, (bfd_byte *) thdr.reserved2);
	  nlm_extended_header (abfd)->reserved3 =
	    get_word (abfd, (bfd_byte *) thdr.reserved3);
	  nlm_extended_header (abfd)->reserved4 =
	    get_word (abfd, (bfd_byte *) thdr.reserved4);
	  nlm_extended_header (abfd)->reserved5 =
	    get_word (abfd, (bfd_byte *) thdr.reserved5);
	}
      else if (CONST_STRNEQ (tempstr, "CoPyRiGhT="))
	{
	  amt = sizeof (nlm_copyright_header (abfd)->stamp);
	  if (bfd_bread ((void *) nlm_copyright_header (abfd)->stamp,
			amt, abfd) != amt)
	    return FALSE;
	  if (bfd_bread ((void *) &(nlm_copyright_header (abfd)
				->copyrightMessageLength),
			(bfd_size_type) 1, abfd) != 1)
	    return FALSE;
	  /* The copyright message is a variable length string.  */
	  amt = nlm_copyright_header (abfd)->copyrightMessageLength + 1;
	  if (bfd_bread ((void *) nlm_copyright_header (abfd)->copyrightMessage,
			amt, abfd) != amt)
	    return FALSE;
	}
      else if (CONST_STRNEQ (tempstr, "CuStHeAd"))
	{
	  Nlm_External_Custom_Header thdr;
	  bfd_size_type hdrLength;
	  file_ptr dataOffset;
	  bfd_size_type dataLength;
	  char dataStamp[8];
	  void * hdr;

	  /* Read the stamp ("CuStHeAd").  */
	  amt = sizeof (thdr.stamp);
	  if (bfd_bread ((void *) thdr.stamp, amt, abfd) != amt)
	    return FALSE;
	  /* Read the length of this custom header.  */
	  amt = sizeof (thdr.length);
	  if (bfd_bread ((void *) thdr.length, amt, abfd) != amt)
	    return FALSE;
	  hdrLength = get_word (abfd, (bfd_byte *) thdr.length);
	  /* Read further fields if we have them.  */
	  if (hdrLength < NLM_TARGET_LONG_SIZE)
	    dataOffset = 0;
	  else
	    {
	      amt = sizeof (thdr.dataOffset);
	      if (bfd_bread ((void *) thdr.dataOffset, amt, abfd) != amt)
		return FALSE;
	      dataOffset = get_word (abfd, (bfd_byte *) thdr.dataOffset);
	    }
	  if (hdrLength < 2 * NLM_TARGET_LONG_SIZE)
	    dataLength = 0;
	  else
	    {
	      amt = sizeof (thdr.dataLength);
	      if (bfd_bread ((void *) thdr.dataLength, amt, abfd) != amt)
		return FALSE;
	      dataLength = get_word (abfd, (bfd_byte *) thdr.dataLength);
	    }
	  if (hdrLength < 2 * NLM_TARGET_LONG_SIZE + 8)
	    memset (dataStamp, 0, sizeof (dataStamp));
	  else
	    {
	      amt = sizeof (dataStamp);
	      if (bfd_bread ((void *) dataStamp, amt, abfd) != amt)
		return FALSE;
	    }

	  /* Read the rest of the header, if any.  */
	  if (hdrLength <= 2 * NLM_TARGET_LONG_SIZE + 8)
	    {
	      hdr = NULL;
	      hdrLength = 0;
	    }
	  else
	    {
	      hdrLength -= 2 * NLM_TARGET_LONG_SIZE + 8;
	      hdr = bfd_alloc (abfd, hdrLength);
	      if (hdr == NULL)
		return FALSE;
	      if (bfd_bread (hdr, hdrLength, abfd) != hdrLength)
		return FALSE;
	    }

	  /* If we have found a Cygnus header, process it.  Otherwise,
	     just save the associated data without trying to interpret
	     it.  */
	  if (CONST_STRNEQ (dataStamp, "CyGnUsEx"))
	    {
	      file_ptr pos;
	      bfd_byte *contents;
	      bfd_byte *p, *pend;

	      BFD_ASSERT (hdrLength == 0 && hdr == NULL);

	      pos = bfd_tell (abfd);
	      if (bfd_seek (abfd, dataOffset, SEEK_SET) != 0)
		return FALSE;
	      contents = bfd_alloc (abfd, dataLength);
	      if (contents == NULL)
		return FALSE;
	      if (bfd_bread (contents, dataLength, abfd) != dataLength)
		return FALSE;
	      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
		return FALSE;

	      LITMEMCPY (nlm_cygnus_ext_header (abfd), "CyGnUsEx");
	      nlm_cygnus_ext_header (abfd)->offset = dataOffset;
	      nlm_cygnus_ext_header (abfd)->length = dataLength;

	      /* This data this header points to provides a list of
		 the sections which were in the original object file
		 which was converted to become an NLM.  We locate
		 those sections and add them to the BFD.  Note that
		 this is likely to create a second .text, .data and
		 .bss section; retrieving the sections by name will
		 get the actual NLM sections, which is what we want to
		 happen.  The sections from the original file, which
		 may be subsets of the NLM section, can only be found
		 using bfd_map_over_sections.  */
	      p = contents;
	      pend = p + dataLength;
	      while (p < pend)
		{
		  char *name;
		  size_t l;
		  file_ptr filepos;
		  bfd_size_type size;
		  asection *newsec;

		  /* The format of this information is
		     null terminated section name
		     zeroes to adjust to 4 byte boundary
		     4 byte section data file pointer
		     4 byte section size.  */

		  name = (char *) p;
		  l = strlen (name) + 1;
		  l = (l + 3) &~ (size_t) 3;
		  p += l;
		  filepos = H_GET_32 (abfd, p);
		  p += 4;
		  size = H_GET_32 (abfd, p);
		  p += 4;

		  newsec = bfd_make_section_anyway (abfd, name);
		  if (newsec == NULL)
		    return FALSE;
		  newsec->size = size;
		  if (filepos != 0)
		    {
		      newsec->filepos = filepos;
		      newsec->flags |= SEC_HAS_CONTENTS;
		    }
		}
	    }
	  else
	    {
	      memcpy (nlm_custom_header (abfd)->stamp, thdr.stamp,
		      sizeof (thdr.stamp));
	      nlm_custom_header (abfd)->hdrLength = hdrLength;
	      nlm_custom_header (abfd)->dataOffset = dataOffset;
	      nlm_custom_header (abfd)->dataLength = dataLength;
	      memcpy (nlm_custom_header (abfd)->dataStamp, dataStamp,
		      sizeof (dataStamp));
	      nlm_custom_header (abfd)->hdr = hdr;
	    }
	}
      else
	break;
    }
  return TRUE;
}

const bfd_target *
nlm_object_p (bfd *abfd)
{
  struct nlm_obj_tdata *preserved_tdata = nlm_tdata (abfd);
  bfd_boolean (*backend_object_p) (bfd *);
  void * x_fxdhdr = NULL;
  Nlm_Internal_Fixed_Header *i_fxdhdrp;
  struct nlm_obj_tdata *new_tdata = NULL;
  const char *signature;
  enum bfd_architecture arch;
  bfd_size_type amt;

  /* Some NLM formats have a prefix before the standard NLM fixed
     header.  */
  backend_object_p = nlm_backend_object_p_func (abfd);
  if (backend_object_p)
    {
      if (!(*backend_object_p) (abfd))
	goto got_wrong_format_error;
    }

  /* Read in the fixed length portion of the NLM header in external format.  */
  amt = nlm_fixed_header_size (abfd);
  x_fxdhdr = bfd_malloc (amt);
  if (x_fxdhdr == NULL)
    goto got_no_match;

  if (bfd_bread ((void *) x_fxdhdr, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	goto got_wrong_format_error;
      else
	goto got_no_match;
    }

  /* Allocate an instance of the nlm_obj_tdata structure and hook it up to
     the tdata pointer in the bfd.  */
  amt = sizeof (struct nlm_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    goto got_no_match;

  nlm_tdata (abfd) = new_tdata;

  i_fxdhdrp = nlm_fixed_header (abfd);
  nlm_swap_fixed_header_in (abfd, x_fxdhdr, i_fxdhdrp);
  free (x_fxdhdr);
  x_fxdhdr = NULL;

  /* Check to see if we have an NLM file for this backend by matching
     the NLM signature.  */
  signature = nlm_signature (abfd);
  if (signature != NULL
      && *signature != '\0'
      && strncmp ((char *) i_fxdhdrp->signature, signature,
		  NLM_SIGNATURE_SIZE) != 0)
    goto got_wrong_format_error;

  /* There's no supported way to discover the endianness of an NLM, so test for
     a sane version number after doing byte swapping appropriate for this
     XVEC.  (Hack alert!)  */
  if (i_fxdhdrp->version > 0xFFFF)
    goto got_wrong_format_error;

  /* There's no supported way to check for 32 bit versus 64 bit addresses,
     so ignore this distinction for now.  (FIXME) */
  /* Swap in the rest of the required header.  */
  if (!nlm_swap_variable_header_in (abfd))
    {
      if (bfd_get_error () != bfd_error_system_call)
	goto got_wrong_format_error;
      else
	goto got_no_match;
    }

  /* Add the sections supplied by all NLM's, and then read in the
     auxiliary headers.  Reading the auxiliary headers may create
     additional sections described in the cygnus_ext header.
     From this point on we assume that we have an NLM, and do not
     treat errors as indicating the wrong format.  */
  if (!add_bfd_section (abfd, NLM_CODE_NAME,
			i_fxdhdrp->codeImageOffset,
			i_fxdhdrp->codeImageSize,
			(SEC_CODE | SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			 | SEC_RELOC))
      || !add_bfd_section (abfd, NLM_INITIALIZED_DATA_NAME,
			   i_fxdhdrp->dataImageOffset,
			   i_fxdhdrp->dataImageSize,
			   (SEC_DATA | SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_RELOC))
      || !add_bfd_section (abfd, NLM_UNINITIALIZED_DATA_NAME,
			   (file_ptr) 0,
			   i_fxdhdrp->uninitializedDataSize,
			   SEC_ALLOC))
    goto got_no_match;

  if (!nlm_swap_auxiliary_headers_in (abfd))
    goto got_no_match;

  if (nlm_fixed_header (abfd)->numberOfRelocationFixups != 0
      || nlm_fixed_header (abfd)->numberOfExternalReferences != 0)
    abfd->flags |= HAS_RELOC;
  if (nlm_fixed_header (abfd)->numberOfPublics != 0
      || nlm_fixed_header (abfd)->numberOfDebugRecords != 0
      || nlm_fixed_header (abfd)->numberOfExternalReferences != 0)
    abfd->flags |= HAS_SYMS;

  arch = nlm_architecture (abfd);
  if (arch != bfd_arch_unknown)
    bfd_default_set_arch_mach (abfd, arch, (unsigned long) 0);

  abfd->flags |= EXEC_P;
  bfd_get_start_address (abfd) = nlm_fixed_header (abfd)->codeStartOffset;

  return abfd->xvec;

got_wrong_format_error:
  bfd_set_error (bfd_error_wrong_format);
got_no_match:
  nlm_tdata (abfd) = preserved_tdata;
  if (new_tdata != NULL)
    bfd_release (abfd, new_tdata);
  if (x_fxdhdr != NULL)
    free (x_fxdhdr);

  return NULL;
}

/* Swap and write out the variable length header.  All the fields must
   exist in the NLM, and must exist in this order.  */

static bfd_boolean
nlm_swap_variable_header_out (bfd *abfd)
{
  bfd_byte temp[NLM_TARGET_LONG_SIZE];
  bfd_size_type amt;

  /* Write the description length and text members.  */
  amt = sizeof (nlm_variable_header (abfd)->descriptionLength);
  if (bfd_bwrite (& nlm_variable_header (abfd)->descriptionLength, amt,
		  abfd) != amt)
    return FALSE;
  amt = nlm_variable_header (abfd)->descriptionLength + 1;
  if (bfd_bwrite ((void *) nlm_variable_header (abfd)->descriptionText, amt,
		  abfd) != amt)
    return FALSE;

  /* Convert and write the stackSize field.  */
  put_word (abfd, (bfd_vma) nlm_variable_header (abfd)->stackSize, temp);
  amt = sizeof (temp);
  if (bfd_bwrite (temp, amt, abfd) != amt)
    return FALSE;

  /* Convert and write the reserved field.  */
  put_word (abfd, (bfd_vma) nlm_variable_header (abfd)->reserved, temp);
  amt = sizeof (temp);
  if (bfd_bwrite (temp, amt, abfd) != amt)
    return FALSE;

  /* Write the oldThreadName field.  This field is a fixed length string.  */
  amt = sizeof (nlm_variable_header (abfd)->oldThreadName);
  if (bfd_bwrite (nlm_variable_header (abfd)->oldThreadName, amt,
		  abfd) != amt)
    return FALSE;

  /* Write the screen name length and text members.  */
  amt = sizeof (nlm_variable_header (abfd)->screenNameLength);
  if (bfd_bwrite (& nlm_variable_header (abfd)->screenNameLength, amt,
		 abfd) != amt)
    return FALSE;
  amt = nlm_variable_header (abfd)->screenNameLength + 1;
  if (bfd_bwrite (nlm_variable_header (abfd)->screenName, amt, abfd) != amt)
    return FALSE;

  /* Write the thread name length and text members.  */
  amt = sizeof (nlm_variable_header (abfd)->threadNameLength);
  if (bfd_bwrite (& nlm_variable_header (abfd)->threadNameLength, amt,
		 abfd) != amt)
    return FALSE;
  amt = nlm_variable_header (abfd)->threadNameLength + 1;
  if (bfd_bwrite (nlm_variable_header (abfd)->threadName, amt, abfd) != amt)
    return FALSE;
  return TRUE;
}

/* Return whether there is a non-zero byte in a memory block.  */

static bfd_boolean
find_nonzero (void * buf, size_t size)
{
  char *p = (char *) buf;

  while (size-- != 0)
    if (*p++ != 0)
      return TRUE;
  return FALSE;
}

/* Swap out the contents of the auxiliary headers.  We create those
   auxiliary headers which have been set non-zero.  We do not require
   the caller to set up the stamp fields.  */

static bfd_boolean
nlm_swap_auxiliary_headers_out (bfd *abfd)
{
  bfd_size_type amt;

  /* Write out the version header if there is one.  */
  if (find_nonzero (nlm_version_header (abfd),
		    sizeof (Nlm_Internal_Version_Header)))
    {
      Nlm_External_Version_Header thdr;

      LITMEMCPY (thdr.stamp, "VeRsIoN#");
      put_word (abfd, (bfd_vma) nlm_version_header (abfd)->majorVersion,
		(bfd_byte *) thdr.majorVersion);
      put_word (abfd, (bfd_vma) nlm_version_header (abfd)->minorVersion,
		(bfd_byte *) thdr.minorVersion);
      put_word (abfd, (bfd_vma) nlm_version_header (abfd)->revision,
		(bfd_byte *) thdr.revision);
      put_word (abfd, (bfd_vma) nlm_version_header (abfd)->year,
		(bfd_byte *) thdr.year);
      put_word (abfd, (bfd_vma) nlm_version_header (abfd)->month,
		(bfd_byte *) thdr.month);
      put_word (abfd, (bfd_vma) nlm_version_header (abfd)->day,
		(bfd_byte *) thdr.day);
      if (bfd_bwrite ((void *) &thdr, (bfd_size_type) sizeof (thdr), abfd)
	  != sizeof (thdr))
	return FALSE;
    }

  /* Note - the CoPyRiGhT tag is emitted before the MeSsAgEs
     tag in order to make the NW4.x and NW5.x loaders happy.  */

  /* Write out the copyright header if there is one.  */
  if (find_nonzero (nlm_copyright_header (abfd),
		    sizeof (Nlm_Internal_Copyright_Header)))
    {
      Nlm_External_Copyright_Header thdr;

      LITMEMCPY (thdr.stamp, "CoPyRiGhT=");
      amt = sizeof (thdr.stamp);
      if (bfd_bwrite ((void *) thdr.stamp, amt, abfd) != amt)
	return FALSE;
      thdr.copyrightMessageLength[0] =
	nlm_copyright_header (abfd)->copyrightMessageLength;
      amt = 1;
      if (bfd_bwrite ((void *) thdr.copyrightMessageLength, amt, abfd) != amt)
	return FALSE;
      /* The copyright message is a variable length string.  */
      amt = nlm_copyright_header (abfd)->copyrightMessageLength + 1;
      if (bfd_bwrite ((void *) nlm_copyright_header (abfd)->copyrightMessage,
		     amt, abfd) != amt)
	return FALSE;
    }

  /* Write out the extended header if there is one.  */
  if (find_nonzero (nlm_extended_header (abfd),
		    sizeof (Nlm_Internal_Extended_Header)))
    {
      Nlm_External_Extended_Header thdr;

      LITMEMCPY (thdr.stamp, "MeSsAgEs");
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->languageID,
		(bfd_byte *) thdr.languageID);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->messageFileOffset,
		(bfd_byte *) thdr.messageFileOffset);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->messageFileLength,
		(bfd_byte *) thdr.messageFileLength);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->messageCount,
		(bfd_byte *) thdr.messageCount);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->helpFileOffset,
		(bfd_byte *) thdr.helpFileOffset);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->helpFileLength,
		(bfd_byte *) thdr.helpFileLength);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->RPCDataOffset,
		(bfd_byte *) thdr.RPCDataOffset);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->RPCDataLength,
		(bfd_byte *) thdr.RPCDataLength);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->sharedCodeOffset,
		(bfd_byte *) thdr.sharedCodeOffset);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->sharedCodeLength,
		(bfd_byte *) thdr.sharedCodeLength);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->sharedDataOffset,
		(bfd_byte *) thdr.sharedDataOffset);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->sharedDataLength,
		(bfd_byte *) thdr.sharedDataLength);
      put_word (abfd,
	  (bfd_vma) nlm_extended_header (abfd)->sharedRelocationFixupOffset,
		(bfd_byte *) thdr.sharedRelocationFixupOffset);
      put_word (abfd,
	   (bfd_vma) nlm_extended_header (abfd)->sharedRelocationFixupCount,
		(bfd_byte *) thdr.sharedRelocationFixupCount);
      put_word (abfd,
	(bfd_vma) nlm_extended_header (abfd)->sharedExternalReferenceOffset,
		(bfd_byte *) thdr.sharedExternalReferenceOffset);
      put_word (abfd,
	 (bfd_vma) nlm_extended_header (abfd)->sharedExternalReferenceCount,
		(bfd_byte *) thdr.sharedExternalReferenceCount);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->sharedPublicsOffset,
		(bfd_byte *) thdr.sharedPublicsOffset);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->sharedPublicsCount,
		(bfd_byte *) thdr.sharedPublicsCount);
      put_word (abfd,
	      (bfd_vma) nlm_extended_header (abfd)->sharedDebugRecordOffset,
		(bfd_byte *) thdr.sharedDebugRecordOffset);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->sharedDebugRecordCount,
		(bfd_byte *) thdr.sharedDebugRecordCount);
      put_word (abfd,
	   (bfd_vma) nlm_extended_header (abfd)->SharedInitializationOffset,
		(bfd_byte *) thdr.sharedInitializationOffset);
      put_word (abfd,
	    (bfd_vma) nlm_extended_header (abfd)->SharedExitProcedureOffset,
		(bfd_byte *) thdr.SharedExitProcedureOffset);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->productID,
		(bfd_byte *) thdr.productID);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->reserved0,
		(bfd_byte *) thdr.reserved0);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->reserved1,
		(bfd_byte *) thdr.reserved1);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->reserved2,
		(bfd_byte *) thdr.reserved2);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->reserved3,
		(bfd_byte *) thdr.reserved3);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->reserved4,
		(bfd_byte *) thdr.reserved4);
      put_word (abfd,
		(bfd_vma) nlm_extended_header (abfd)->reserved5,
		(bfd_byte *) thdr.reserved5);
      if (bfd_bwrite ((void *) &thdr, (bfd_size_type) sizeof (thdr), abfd)
	  != sizeof (thdr))
	return FALSE;
    }

  /* Write out the custom header if there is one.   */
  if (find_nonzero (nlm_custom_header (abfd),
		    sizeof (Nlm_Internal_Custom_Header)))
    {
      Nlm_External_Custom_Header thdr;
      bfd_boolean ds;
      bfd_size_type hdrLength;

      ds = find_nonzero (nlm_custom_header (abfd)->dataStamp,
			 sizeof (nlm_custom_header (abfd)->dataStamp));
      LITMEMCPY (thdr.stamp, "CuStHeAd");
      hdrLength = (2 * NLM_TARGET_LONG_SIZE + (ds ? 8 : 0)
		   + nlm_custom_header (abfd)->hdrLength);
      put_word (abfd, hdrLength, thdr.length);
      put_word (abfd, (bfd_vma) nlm_custom_header (abfd)->dataOffset,
		thdr.dataOffset);
      put_word (abfd, (bfd_vma) nlm_custom_header (abfd)->dataLength,
		thdr.dataLength);
      if (! ds)
	{
	  BFD_ASSERT (nlm_custom_header (abfd)->hdrLength == 0);
	  amt = sizeof (thdr) - sizeof (thdr.dataStamp);
	  if (bfd_bwrite ((void *) &thdr, amt, abfd) != amt)
	    return FALSE;
	}
      else
	{
	  memcpy (thdr.dataStamp, nlm_custom_header (abfd)->dataStamp,
		  sizeof (thdr.dataStamp));
	  amt = sizeof (thdr);
	  if (bfd_bwrite ((void *) &thdr, amt, abfd) != amt)
	    return FALSE;
	  amt = nlm_custom_header (abfd)->hdrLength;
	  if (bfd_bwrite (nlm_custom_header (abfd)->hdr, amt, abfd) != amt)
	    return FALSE;
	}
    }

  /* Write out the Cygnus debugging header if there is one.  */
  if (find_nonzero (nlm_cygnus_ext_header (abfd),
		    sizeof (Nlm_Internal_Cygnus_Ext_Header)))
    {
      Nlm_External_Custom_Header thdr;

      LITMEMCPY (thdr.stamp, "CuStHeAd");
      put_word (abfd, (bfd_vma) 2 * NLM_TARGET_LONG_SIZE + 8,
		(bfd_byte *) thdr.length);
      put_word (abfd, (bfd_vma) nlm_cygnus_ext_header (abfd)->offset,
		(bfd_byte *) thdr.dataOffset);
      put_word (abfd, (bfd_vma) nlm_cygnus_ext_header (abfd)->length,
		(bfd_byte *) thdr.dataLength);
      LITMEMCPY (thdr.dataStamp, "CyGnUsEx");
      amt = sizeof (thdr);
      if (bfd_bwrite ((void *) &thdr, amt, abfd) != amt)
	return FALSE;
    }

  return TRUE;
}

/* We read the NLM's public symbols and use it to generate a bfd symbol
   table (hey, it's better than nothing) on a one-for-one basis.  Thus
   use the number of public symbols as the number of bfd symbols we will
   have once we actually get around to reading them in.

   Return the number of bytes required to hold the symtab vector, based on
   the count plus 1, since we will NULL terminate the vector allocated based
   on this size.  */

long
nlm_get_symtab_upper_bound (bfd *abfd)
{
  Nlm_Internal_Fixed_Header *i_fxdhdrp;	/* Nlm file header, internal form.  */
  long symcount;
  long symtab_size = 0;

  i_fxdhdrp = nlm_fixed_header (abfd);
  symcount = (i_fxdhdrp->numberOfPublics
	      + i_fxdhdrp->numberOfDebugRecords
	      + i_fxdhdrp->numberOfExternalReferences);
  symtab_size = (symcount + 1) * (sizeof (asymbol));
  return symtab_size;
}

/* Slurp in nlm symbol table.

   In the external (in-file) form, NLM export records are variable length,
   with the following form:

	1 byte		length of the symbol name (N)
	N bytes		the symbol name
	4 bytes		the symbol offset from start of it's section

   We also read in the debugging symbols and import records.  Import
   records are treated as undefined symbols.  As we read the import
   records we also read in the associated reloc information, which is
   attached to the symbol.

   The bfd symbols are copied to SYMvoid *S.

   When we return, the bfd symcount is either zero or contains the correct
   number of symbols.  */

static bfd_boolean
nlm_slurp_symbol_table (bfd *abfd)
{
  Nlm_Internal_Fixed_Header *i_fxdhdrp;	/* Nlm file header, internal form.  */
  bfd_size_type totsymcount;	/* Number of NLM symbols.  */
  bfd_size_type symcount;	/* Counter of NLM symbols.  */
  nlm_symbol_type *sym;		/* Pointer to current bfd symbol.  */
  unsigned char symlength;	/* Symbol length read into here.  */
  unsigned char symtype;	/* Type of debugging symbol.  */
  bfd_byte temp[NLM_TARGET_LONG_SIZE];	/* Symbol offsets read into here.  */
  bfd_boolean (*read_import_func) (bfd *, nlm_symbol_type *);
  bfd_boolean (*set_public_section_func) (bfd *, nlm_symbol_type *);
  bfd_size_type amt;

  if (nlm_get_symbols (abfd) != NULL)
    return TRUE;

  /* Read each raw NLM symbol, using the information to create a canonical bfd
     symbol table entry.

     Note that we allocate the initial bfd canonical symbol buffer based on a
     one-to-one mapping of the NLM symbols to canonical symbols.  We actually
     use all the NLM symbols, so there will be no space left over at the end.
     When we have all the symbols, we build the caller's pointer vector.  */

  abfd->symcount = 0;
  i_fxdhdrp = nlm_fixed_header (abfd);
  totsymcount = (i_fxdhdrp->numberOfPublics
		 + i_fxdhdrp->numberOfDebugRecords
		 + i_fxdhdrp->numberOfExternalReferences);
  if (totsymcount == 0)
    return TRUE;

  if (bfd_seek (abfd, i_fxdhdrp->publicsOffset, SEEK_SET) != 0)
    return FALSE;

  amt = totsymcount * sizeof (nlm_symbol_type);
  sym = bfd_zalloc (abfd, amt);
  if (!sym)
    return FALSE;
  nlm_set_symbols (abfd, sym);

  /* We use the bfd's symcount directly as the control count, so that early
     termination of the loop leaves the symcount correct for the symbols that
     were read.  */

  set_public_section_func = nlm_set_public_section_func (abfd);
  symcount = i_fxdhdrp->numberOfPublics;
  while (abfd->symcount < symcount)
    {
      amt = sizeof (symlength);
      if (bfd_bread ((void *) &symlength, amt, abfd) != amt)
	return FALSE;
      amt = symlength;
      sym->symbol.the_bfd = abfd;
      sym->symbol.name = bfd_alloc (abfd, amt + 1);
      if (!sym->symbol.name)
	return FALSE;
      if (bfd_bread ((void *) sym->symbol.name, amt, abfd) != amt)
	return FALSE;
      /* Cast away const.  */
      ((char *) (sym->symbol.name))[symlength] = '\0';
      amt = sizeof (temp);
      if (bfd_bread ((void *) temp, amt, abfd) != amt)
	return FALSE;
      sym->symbol.flags = BSF_GLOBAL | BSF_EXPORT;
      sym->symbol.value = get_word (abfd, temp);
      if (set_public_section_func)
	{
	  /* Most backends can use the code below, but unfortunately
	     some use a different scheme.  */
	  if (! (*set_public_section_func) (abfd, sym))
	    return FALSE;
	}
      else
	{
	  if (sym->symbol.value & NLM_HIBIT)
	    {
	      sym->symbol.value &= ~NLM_HIBIT;
	      sym->symbol.flags |= BSF_FUNCTION;
	      sym->symbol.section =
		bfd_get_section_by_name (abfd, NLM_CODE_NAME);
	    }
	  else
	    sym->symbol.section =
	      bfd_get_section_by_name (abfd, NLM_INITIALIZED_DATA_NAME);
	}
      sym->rcnt = 0;
      abfd->symcount++;
      sym++;
    }

  /* Read the debugging records.  */

  if (i_fxdhdrp->numberOfDebugRecords > 0)
    {
      if (bfd_seek (abfd, i_fxdhdrp->debugInfoOffset, SEEK_SET) != 0)
	return FALSE;

      symcount += i_fxdhdrp->numberOfDebugRecords;
      while (abfd->symcount < symcount)
	{
	  amt = sizeof (symtype);
	  if (bfd_bread ((void *) &symtype, amt, abfd) != amt)
	    return FALSE;
	  amt = sizeof (temp);
	  if (bfd_bread ((void *) temp, amt, abfd) != amt)
	    return FALSE;
	  amt = sizeof (symlength);
	  if (bfd_bread ((void *) &symlength, amt, abfd) != amt)
	    return FALSE;
	  amt = symlength;
	  sym->symbol.the_bfd = abfd;
	  sym->symbol.name = bfd_alloc (abfd, amt + 1);
	  if (!sym->symbol.name)
	    return FALSE;
	  if (bfd_bread ((void *) sym->symbol.name, amt, abfd) != amt)
	    return FALSE;
	  /* Cast away const.  */
	  ((char *) (sym->symbol.name))[symlength] = '\0';
	  sym->symbol.flags = BSF_LOCAL;
	  sym->symbol.value = get_word (abfd, temp);

	  if (symtype == 0)
	    sym->symbol.section =
	      bfd_get_section_by_name (abfd, NLM_INITIALIZED_DATA_NAME);
	  else if (symtype == 1)
	    {
	      sym->symbol.flags |= BSF_FUNCTION;
	      sym->symbol.section =
		bfd_get_section_by_name (abfd, NLM_CODE_NAME);
	    }
	  else
	    sym->symbol.section = bfd_abs_section_ptr;

	  sym->rcnt = 0;
	  abfd->symcount++;
	  sym++;
	}
    }

  /* Read in the import records.  We can only do this if we know how
     to read relocs for this target.  */
  read_import_func = nlm_read_import_func (abfd);
  if (read_import_func != NULL)
    {
      if (bfd_seek (abfd, i_fxdhdrp->externalReferencesOffset, SEEK_SET) != 0)
	return FALSE;

      symcount += i_fxdhdrp->numberOfExternalReferences;
      while (abfd->symcount < symcount)
	{
	  if (! (*read_import_func) (abfd, sym))
	    return FALSE;
	  sym++;
	  abfd->symcount++;
	}
    }

  return TRUE;
}

/* Note that bfd_get_symcount is guaranteed to be zero if slurping the
   symbol table fails.  */

long
nlm_canonicalize_symtab (bfd *abfd, asymbol **alocation)
{
  nlm_symbol_type *symbase;
  bfd_size_type counter = 0;

  if (! nlm_slurp_symbol_table (abfd))
    return -1;
  symbase = nlm_get_symbols (abfd);
  while (counter < bfd_get_symcount (abfd))
    {
      *alocation++ = &symbase->symbol;
      symbase++;
      counter++;
    }
  *alocation = NULL;
  return bfd_get_symcount (abfd);
}

/* Make an NLM symbol.  There is nothing special to do here.  */

asymbol *
nlm_make_empty_symbol (bfd *abfd)
{
  bfd_size_type amt = sizeof (nlm_symbol_type);
  nlm_symbol_type *new = bfd_zalloc (abfd, amt);

  if (new == NULL)
    return NULL;
  new->symbol.the_bfd = abfd;
  return & new->symbol;
}

/* Get symbol information.  */

void
nlm_get_symbol_info (bfd *ignore_abfd ATTRIBUTE_UNUSED,
		     asymbol *symbol,
		     symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);
}

/* Print symbol information.  */

void
nlm_print_symbol (bfd *abfd,
		  void * afile,
		  asymbol *symbol,
		  bfd_print_symbol_type how)
{
  FILE *file = (FILE *) afile;

  switch (how)
    {
    case bfd_print_symbol_name:
    case bfd_print_symbol_more:
      if (symbol->name)
	fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_all:
      bfd_print_symbol_vandf (abfd, (void *) file, symbol);
      fprintf (file, " %-5s", symbol->section->name);
      if (symbol->name)
	fprintf (file, " %s", symbol->name);
      break;
    }
}

/* Get the relocs for an NLM file.  There are two types of relocs.
   Imports are relocs against symbols defined in other NLM files.  We
   treat these as relocs against global symbols.  Relocation fixups
   are internal relocs.

   The actual format used to store the relocs is machine specific.  */

/* Read in the relocation fixup information.  This is stored in
   nlm_relocation_fixups, an array of arelent structures, and
   nlm_relocation_fixup_secs, an array of section pointers.  The
   section pointers are needed because the relocs are not sorted by
   section.  */

static bfd_boolean
nlm_slurp_reloc_fixups (bfd *abfd)
{
  bfd_boolean (*read_func) (bfd *, nlm_symbol_type *, asection **, arelent *);
  bfd_size_type count, amt;
  arelent *rels;
  asection **secs;

  if (nlm_relocation_fixups (abfd) != NULL)
    return TRUE;
  read_func = nlm_read_reloc_func (abfd);
  if (read_func == NULL)
    return TRUE;

  if (bfd_seek (abfd, nlm_fixed_header (abfd)->relocationFixupOffset,
		SEEK_SET) != 0)
    return FALSE;

  count = nlm_fixed_header (abfd)->numberOfRelocationFixups;
  amt = count * sizeof (arelent);
  rels = bfd_alloc (abfd, amt);
  amt = count * sizeof (asection *);
  secs = bfd_alloc (abfd, amt);
  if ((rels == NULL || secs == NULL) && count != 0)
    return FALSE;
  nlm_relocation_fixups (abfd) = rels;
  nlm_relocation_fixup_secs (abfd) = secs;

  /* We have to read piece by piece, because we don't know how large
     the machine specific reloc information is.  */
  while (count-- != 0)
    {
      if (! (*read_func) (abfd, NULL, secs, rels))
	{
	  nlm_relocation_fixups (abfd) = NULL;
	  nlm_relocation_fixup_secs (abfd) = NULL;
	  return FALSE;
	}
      ++secs;
      ++rels;
    }

  return TRUE;
}

/* Get the number of relocs.  This really just returns an upper bound,
   since it does not attempt to distinguish them based on the section.
   That will be handled when they are actually read.  */

long
nlm_get_reloc_upper_bound (bfd *abfd, asection *sec)
{
  nlm_symbol_type *syms;
  bfd_size_type count;
  unsigned int ret;

  /* If we don't know how to read relocs, just return 0.  */
  if (nlm_read_reloc_func (abfd) == NULL)
    return -1;
  /* Make sure we have either the code or the data section.  */
  if ((bfd_get_section_flags (abfd, sec) & (SEC_CODE | SEC_DATA)) == 0)
    return 0;

  syms = nlm_get_symbols (abfd);
  if (syms == NULL)
    {
      if (! nlm_slurp_symbol_table (abfd))
	return -1;
      syms = nlm_get_symbols (abfd);
    }

  ret = nlm_fixed_header (abfd)->numberOfRelocationFixups;

  count = bfd_get_symcount (abfd);
  while (count-- != 0)
    {
      ret += syms->rcnt;
      ++syms;
    }

  return (ret + 1) * sizeof (arelent *);
}

/* Get the relocs themselves.  */

long
nlm_canonicalize_reloc (bfd *abfd,
			asection *sec,
			arelent **relptr,
			asymbol **symbols)
{
  arelent *rels;
  asection **secs;
  bfd_size_type count, i;
  long ret;

  /* Get the relocation fixups.  */
  rels = nlm_relocation_fixups (abfd);
  if (rels == NULL)
    {
      if (! nlm_slurp_reloc_fixups (abfd))
	return -1;
      rels = nlm_relocation_fixups (abfd);
    }
  secs = nlm_relocation_fixup_secs (abfd);

  ret = 0;
  count = nlm_fixed_header (abfd)->numberOfRelocationFixups;
  for (i = 0; i < count; i++, rels++, secs++)
    {
      if (*secs == sec)
	{
	  *relptr++ = rels;
	  ++ret;
	}
    }

  /* Get the import symbols.  */
  count = bfd_get_symcount (abfd);
  for (i = 0; i < count; i++, symbols++)
    {
      asymbol *sym;

      sym = *symbols;
      if (bfd_asymbol_flavour (sym) == bfd_target_nlm_flavour)
	{
	  nlm_symbol_type *nlm_sym;
	  bfd_size_type j;

	  nlm_sym = (nlm_symbol_type *) sym;
	  for (j = 0; j < nlm_sym->rcnt; j++)
	    {
	      if (nlm_sym->relocs[j].section == sec)
		{
		  *relptr = &nlm_sym->relocs[j].reloc;
		  (*relptr)->sym_ptr_ptr = symbols;
		  ++relptr;
		  ++ret;
		}
	    }
	}
    }

  *relptr = NULL;

  return ret;
}

/* Compute the section file positions for an NLM file.  All variable
   length data in the file headers must be set before this function is
   called.  If the variable length data is changed later, the
   resulting object file will be incorrect.  Unfortunately, there is
   no way to check this.

   This routine also sets the Size and Offset fields in the fixed
   header.

   It also looks over the symbols and moves any common symbols into
   the .bss section; NLM has no way to represent a common symbol.
   This approach means that either the symbols must already have been
   set at this point, or there must be no common symbols.  We need to
   move the symbols at this point so that mangle_relocs can see the
   final values.  */

static bfd_boolean
nlm_compute_section_file_positions (bfd *abfd)
{
  file_ptr sofar;
  asection *sec;
  bfd_vma text, data, bss;
  bfd_vma text_low, data_low;
  unsigned int text_align, data_align, other_align;
  file_ptr text_ptr, data_ptr, other_ptr;
  asection *bss_sec;
  asymbol **sym_ptr_ptr;

  if (abfd->output_has_begun)
    return TRUE;

  /* Make sure we have a section to hold uninitialized data.  */
  bss_sec = bfd_get_section_by_name (abfd, NLM_UNINITIALIZED_DATA_NAME);
  if (bss_sec == NULL)
    {
      if (!add_bfd_section (abfd, NLM_UNINITIALIZED_DATA_NAME,
			    (file_ptr) 0, (bfd_size_type) 0,
			    SEC_ALLOC))
	return FALSE;
      bss_sec = bfd_get_section_by_name (abfd, NLM_UNINITIALIZED_DATA_NAME);
    }

  abfd->output_has_begun = TRUE;

  /* The fixed header.  */
  sofar = nlm_optional_prefix_size (abfd) + nlm_fixed_header_size (abfd);

  /* The variable header.  */
  sofar += (sizeof (nlm_variable_header (abfd)->descriptionLength)
	    + nlm_variable_header (abfd)->descriptionLength + 1
	    + NLM_TARGET_LONG_SIZE	/* stackSize */
	    + NLM_TARGET_LONG_SIZE	/* reserved */
	    + sizeof (nlm_variable_header (abfd)->oldThreadName)
	    + sizeof (nlm_variable_header (abfd)->screenNameLength)
	    + nlm_variable_header (abfd)->screenNameLength + 1
	    + sizeof (nlm_variable_header (abfd)->threadNameLength)
	    + nlm_variable_header (abfd)->threadNameLength + 1);

  /* The auxiliary headers.  */
  if (find_nonzero (nlm_version_header (abfd),
		    sizeof (Nlm_Internal_Version_Header)))
    sofar += sizeof (Nlm_External_Version_Header);
  if (find_nonzero (nlm_extended_header (abfd),
		    sizeof (Nlm_Internal_Extended_Header)))
    sofar += sizeof (Nlm_External_Extended_Header);
  if (find_nonzero (nlm_copyright_header (abfd),
		    sizeof (Nlm_Internal_Copyright_Header)))
    sofar += (sizeof (Nlm_External_Copyright_Header)
	      + nlm_copyright_header (abfd)->copyrightMessageLength + 1);
  if (find_nonzero (nlm_custom_header (abfd),
		    sizeof (Nlm_Internal_Custom_Header)))
    sofar += (sizeof (Nlm_External_Custom_Header)
	      + nlm_custom_header (abfd)->hdrLength);
  if (find_nonzero (nlm_cygnus_ext_header (abfd),
		    sizeof (Nlm_Internal_Cygnus_Ext_Header)))
    sofar += sizeof (Nlm_External_Custom_Header);

  /* Compute the section file positions in two passes.  First get the
     sizes of the text and data sections, and then set the file
     positions.  This code aligns the sections in the file using the
     same alignment restrictions that apply to the sections in memory;
     this may not be necessary.  */
  text = 0;
  text_low = (bfd_vma) - 1;
  text_align = 0;
  data = 0;
  data_low = (bfd_vma) - 1;
  data_align = 0;
  bss = 0;
  other_align = 0;
  for (sec = abfd->sections; sec != NULL; sec = sec->next)
    {
      flagword f;

      sec->size = BFD_ALIGN (sec->size, 1 << sec->alignment_power);

      f = bfd_get_section_flags (abfd, sec);
      if (f & SEC_CODE)
	{
	  text += sec->size;
	  if (bfd_get_section_vma (abfd, sec) < text_low)
	    text_low = bfd_get_section_vma (abfd, sec);
	  if (sec->alignment_power > text_align)
	    text_align = sec->alignment_power;
	}
      else if (f & SEC_DATA)
	{
	  data += sec->size;
	  if (bfd_get_section_vma (abfd, sec) < data_low)
	    data_low = bfd_get_section_vma (abfd, sec);
	  if (sec->alignment_power > data_align)
	    data_align = sec->alignment_power;
	}
      else if (f & SEC_HAS_CONTENTS)
	{
	  if (sec->alignment_power > other_align)
	    other_align = sec->alignment_power;
	}
      else if (f & SEC_ALLOC)
	bss += sec->size;
    }

  nlm_set_text_low (abfd, text_low);
  nlm_set_data_low (abfd, data_low);

  if (nlm_no_uninitialized_data (abfd))
    {
      /* This NetWare format does not use uninitialized data.  We must
	 increase the size of the data section.  We will never wind up
	 writing those file locations, so they will remain zero.  */
      data += bss;
      bss = 0;
    }

  text_ptr = BFD_ALIGN (sofar, 1 << text_align);
  data_ptr = BFD_ALIGN (text_ptr + text, 1 << data_align);
  other_ptr = BFD_ALIGN (data_ptr + data, 1 << other_align);

  /* Fill in some fields in the header for which we now have the
     information.  */
  nlm_fixed_header (abfd)->codeImageOffset = text_ptr;
  nlm_fixed_header (abfd)->codeImageSize = text;
  nlm_fixed_header (abfd)->dataImageOffset = data_ptr;
  nlm_fixed_header (abfd)->dataImageSize = data;
  nlm_fixed_header (abfd)->uninitializedDataSize = bss;

  for (sec = abfd->sections; sec != NULL; sec = sec->next)
    {
      flagword f;

      f = bfd_get_section_flags (abfd, sec);

      if (f & SEC_CODE)
	{
	  sec->filepos = text_ptr;
	  text_ptr += sec->size;
	}
      else if (f & SEC_DATA)
	{
	  sec->filepos = data_ptr;
	  data_ptr += sec->size;
	}
      else if (f & SEC_HAS_CONTENTS)
	{
	  sec->filepos = other_ptr;
	  other_ptr += sec->size;
	}
    }

  nlm_fixed_header (abfd)->relocationFixupOffset = other_ptr;

  /* Move all common symbols into the .bss section.  */

  sym_ptr_ptr = bfd_get_outsymbols (abfd);
  if (sym_ptr_ptr != NULL)
    {
      asymbol **sym_end;
      bfd_vma add;

      sym_end = sym_ptr_ptr + bfd_get_symcount (abfd);
      add = 0;
      for (; sym_ptr_ptr < sym_end; sym_ptr_ptr++)
	{
	  asymbol *sym;
	  bfd_vma size;

	  sym = *sym_ptr_ptr;

	  if (!bfd_is_com_section (bfd_get_section (sym)))
	    continue;

	  /* Put the common symbol in the .bss section, and increase
	     the size of the .bss section by the size of the common
	     symbol (which is the old value of the symbol).  */
	  sym->section = bss_sec;
	  size = sym->value;
	  sym->value = bss_sec->size + add;
	  add += size;
	  add = BFD_ALIGN (add, 1 << bss_sec->alignment_power);
	}
      if (add != 0)
	{
	  if (nlm_no_uninitialized_data (abfd))
	    {
	      /* We could handle this case, but so far it hasn't been
		 necessary.  */
	      abort ();
	    }
	  nlm_fixed_header (abfd)->uninitializedDataSize += add;
	  bss_sec->size += add;
	}
    }

  return TRUE;
}

/* Set the contents of a section.  To do this we need to know where
   the section is going to be located in the output file.  That means
   that the sizes of all the sections must be set, and all the
   variable size header information must be known.  */

bfd_boolean
nlm_set_section_contents (bfd *abfd,
			  asection *section,
			  const void * location,
			  file_ptr offset,
			  bfd_size_type count)
{
  if (! abfd->output_has_begun
      && ! nlm_compute_section_file_positions (abfd))
    return FALSE;

  if (count == 0)
    return TRUE;

  /* i386 NetWare has a very restricted set of relocs.  In order for
     objcopy to work, the NLM i386 backend needs a chance to rework
     the section contents so that its set of relocs will work.  If all
     the relocs are already acceptable, this will not do anything.  */
  if (section->reloc_count != 0)
    {
      bfd_boolean (*mangle_relocs_func)
	(bfd *, asection *, const void *, bfd_vma, bfd_size_type);

      mangle_relocs_func = nlm_mangle_relocs_func (abfd);
      if (mangle_relocs_func != NULL)
	{
	  if (!(*mangle_relocs_func) (abfd, section, location,
				      (bfd_vma) offset, count))
	    return FALSE;
	}
    }

  if (bfd_seek (abfd, section->filepos + offset, SEEK_SET) != 0
      || bfd_bwrite (location, count, abfd) != count)
    return FALSE;

  return TRUE;
}

/* We need to sort a list of relocs associated with sections when we
   write out the external relocs.  */

static int
nlm_external_reloc_compare (const void *p1, const void *p2)
{
  const struct reloc_and_sec *r1 = (const struct reloc_and_sec *) p1;
  const struct reloc_and_sec *r2 = (const struct reloc_and_sec *) p2;
  int cmp;

  cmp = strcmp ((*r1->rel->sym_ptr_ptr)->name,
		(*r2->rel->sym_ptr_ptr)->name);
  if (cmp != 0)
    return cmp;

  /* We sort by address within symbol to make the sort more stable and
     increase the chances that different hosts will generate bit for
     bit equivalent results.  */
  return (int) (r1->rel->address - r2->rel->address);
}

/* Write out an NLM file.  We write out the information in this order:
     fixed header
     variable header
     auxiliary headers
     code sections
     data sections
     other sections (custom data, messages, help, shared NLM, RPC,
     		     module dependencies)
     relocation fixups
     external references (imports)
     public symbols (exports)
     debugging records
   This is similar to the order used by the NetWare tools; the
   difference is that NetWare puts the sections other than code, data
   and custom data at the end of the NLM.  It is convenient for us to
   know where the sections are going to be before worrying about the
   size of the other information.

   By the time this function is called, all the section data should
   have been output using set_section_contents.  Note that custom
   data, the message file, the help file, the shared NLM file, the RPC
   data, and the module dependencies are all considered to be
   sections; the caller is responsible for filling in the offset and
   length fields in the NLM headers.  The relocation fixups and
   imports are both obtained from the list of relocs attached to each
   section.  The exports and debugging records are obtained from the
   list of outsymbols.  */

bfd_boolean
nlm_write_object_contents (bfd *abfd)
{
  asection *sec;
  bfd_boolean (*write_import_func) (bfd *, asection *, arelent *);
  bfd_size_type external_reloc_count, internal_reloc_count, i, c;
  struct reloc_and_sec *external_relocs;
  asymbol **sym_ptr_ptr;
  file_ptr last;
  bfd_boolean (*write_prefix_func) (bfd *);
  unsigned char *fixed_header = NULL;
  file_ptr pos;
  bfd_size_type amt;

  fixed_header = bfd_malloc (nlm_fixed_header_size (abfd));
  if (fixed_header == NULL)
    goto error_return;

  if (! abfd->output_has_begun
      && ! nlm_compute_section_file_positions (abfd))
    goto error_return;

  /* Write out the variable length headers.  */
  pos = nlm_optional_prefix_size (abfd) + nlm_fixed_header_size (abfd);
  if (bfd_seek (abfd, pos, SEEK_SET) != 0)
    goto error_return;
  if (! nlm_swap_variable_header_out (abfd)
      || ! nlm_swap_auxiliary_headers_out (abfd))
    {
      bfd_set_error (bfd_error_system_call);
      goto error_return;
    }

  /* A weak check on whether the section file positions were
     reasonable.  */
  if (bfd_tell (abfd) > nlm_fixed_header (abfd)->codeImageOffset)
    {
      bfd_set_error (bfd_error_invalid_operation);
      goto error_return;
    }

  /* Advance to the relocs.  */
  if (bfd_seek (abfd, nlm_fixed_header (abfd)->relocationFixupOffset,
		SEEK_SET) != 0)
    goto error_return;

  /* The format of the relocation entries is dependent upon the
     particular target.  We use an external routine to write the reloc
     out.  */
  write_import_func = nlm_write_import_func (abfd);

  /* Write out the internal relocation fixups.  While we're looping
     over the relocs, we also count the external relocs, which is
     needed when they are written out below.  */
  internal_reloc_count = 0;
  external_reloc_count = 0;
  for (sec = abfd->sections; sec != NULL; sec = sec->next)
    {
      arelent **rel_ptr_ptr, **rel_end;

      if (sec->reloc_count == 0)
	continue;

      /* We can only represent relocs within a code or data
	 section.  We ignore them for a debugging section.  */
      if ((bfd_get_section_flags (abfd, sec) & (SEC_CODE | SEC_DATA)) == 0)
	continue;

      /* We need to know how to write out imports */
      if (write_import_func == NULL)
	{
	  bfd_set_error (bfd_error_invalid_operation);
	  goto error_return;
	}

      rel_ptr_ptr = sec->orelocation;
      rel_end = rel_ptr_ptr + sec->reloc_count;
      for (; rel_ptr_ptr < rel_end; rel_ptr_ptr++)
	{
	  arelent *rel;
	  asymbol *sym;

	  rel = *rel_ptr_ptr;
	  sym = *rel->sym_ptr_ptr;

	  if (! bfd_is_und_section (bfd_get_section (sym)))
	    {
	      ++internal_reloc_count;
	      if (! (*write_import_func) (abfd, sec, rel))
		goto error_return;
	    }
	  else
	    ++external_reloc_count;
	}
    }
  nlm_fixed_header (abfd)->numberOfRelocationFixups = internal_reloc_count;

  /* Write out the imports (relocs against external symbols).  These
     are output as a symbol name followed by all the relocs for that
     symbol, so we must first gather together all the relocs against
     external symbols and sort them.  */
  amt = external_reloc_count * sizeof (struct reloc_and_sec);
  external_relocs = bfd_alloc (abfd, amt);
  if (external_relocs == NULL)
    goto error_return;
  i = 0;
  for (sec = abfd->sections; sec != NULL; sec = sec->next)
    {
      arelent **rel_ptr_ptr, **rel_end;

      if (sec->reloc_count == 0)
	continue;

      rel_ptr_ptr = sec->orelocation;
      rel_end = rel_ptr_ptr + sec->reloc_count;
      for (; rel_ptr_ptr < rel_end; rel_ptr_ptr++)
	{
	  arelent *rel;
	  asymbol *sym;

	  rel = *rel_ptr_ptr;
	  sym = *rel->sym_ptr_ptr;

	  if (! bfd_is_und_section (bfd_get_section (sym)))
	    continue;

	  external_relocs[i].rel = rel;
	  external_relocs[i].sec = sec;
	  ++i;
	}
    }

  BFD_ASSERT (i == external_reloc_count);

  /* Sort the external relocs by name.  */
  qsort (external_relocs, (size_t) external_reloc_count,
	 sizeof (struct reloc_and_sec), nlm_external_reloc_compare);

  /* Write out the external relocs.  */
  nlm_fixed_header (abfd)->externalReferencesOffset = bfd_tell (abfd);
  c = 0;
  i = 0;
  while (i < external_reloc_count)
    {
      arelent *rel;
      asymbol *sym;
      bfd_size_type j, cnt;

      ++c;

      rel = external_relocs[i].rel;
      sym = *rel->sym_ptr_ptr;

      cnt = 0;
      for (j = i;
	   (j < external_reloc_count
	    && *external_relocs[j].rel->sym_ptr_ptr == sym);
	   j++)
	++cnt;

      if (! (*nlm_write_external_func (abfd)) (abfd, cnt, sym,
					       &external_relocs[i]))
	goto error_return;

      i += cnt;
    }

  nlm_fixed_header (abfd)->numberOfExternalReferences = c;

  /* Write out the public symbols (exports).  */
  sym_ptr_ptr = bfd_get_outsymbols (abfd);
  if (sym_ptr_ptr != NULL)
    {
      bfd_vma (*get_public_offset_func) (bfd *, asymbol *);
      bfd_boolean (*write_export_func) (bfd *, asymbol *, bfd_vma);

      asymbol **sym_end;

      nlm_fixed_header (abfd)->publicsOffset = bfd_tell (abfd);
      get_public_offset_func = nlm_get_public_offset_func (abfd);
      write_export_func = nlm_write_export_func (abfd);
      c = 0;
      sym_end = sym_ptr_ptr + bfd_get_symcount (abfd);
      for (; sym_ptr_ptr < sym_end; sym_ptr_ptr++)
	{
	  asymbol *sym;
	  bfd_byte len;
	  bfd_vma offset;
	  bfd_byte temp[NLM_TARGET_LONG_SIZE];

	  sym = *sym_ptr_ptr;

	  if ((sym->flags & (BSF_EXPORT | BSF_GLOBAL)) == 0
	      || bfd_is_und_section (bfd_get_section (sym)))
	    continue;

	  ++c;

	  if (get_public_offset_func)
	    {
	      /* Most backends can use the code below, but
		 unfortunately some use a different scheme.  */
	      offset = (*get_public_offset_func) (abfd, sym);
	    }
	  else
	    {
	      offset = bfd_asymbol_value (sym);
	      sec = sym->section;
	      if (sec->flags & SEC_CODE)
		{
		  offset -= nlm_get_text_low (abfd);
		  offset |= NLM_HIBIT;
		}
	      else if (sec->flags & (SEC_DATA | SEC_ALLOC))
		{
		  /* SEC_ALLOC is for the .bss section.  */
		  offset -= nlm_get_data_low (abfd);
		}
	      else
		{
		  /* We can't handle an exported symbol that is not in
		     the code or data segment.  */
		  bfd_set_error (bfd_error_invalid_operation);
		  goto error_return;
		}
	    }

	  if (write_export_func)
	    {
	      if (! (*write_export_func) (abfd, sym, offset))
		goto error_return;
	    }
	  else
	    {
	      len = strlen (sym->name);
	      if ((bfd_bwrite (&len, (bfd_size_type) sizeof (bfd_byte), abfd)
		   != sizeof (bfd_byte))
		  || bfd_bwrite (sym->name, (bfd_size_type) len, abfd) != len)
		goto error_return;

	      put_word (abfd, offset, temp);
	      if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), abfd)
		  != sizeof (temp))
		goto error_return;
	    }
	}
      nlm_fixed_header (abfd)->numberOfPublics = c;

      /* Write out the debugging records.  The NLM conversion program
	 wants to be able to inhibit this, so as a special hack if
	 debugInfoOffset is set to -1 we don't write any debugging
	 information.  This can not be handled by fiddling with the
	 symbol table, because exported symbols appear in both the
	 exported symbol list and the debugging information.  */
      if (nlm_fixed_header (abfd)->debugInfoOffset == (file_ptr) - 1)
	{
	  nlm_fixed_header (abfd)->debugInfoOffset = 0;
	  nlm_fixed_header (abfd)->numberOfDebugRecords = 0;
	}
      else
	{
	  nlm_fixed_header (abfd)->debugInfoOffset = bfd_tell (abfd);
	  c = 0;
	  sym_ptr_ptr = bfd_get_outsymbols (abfd);
	  sym_end = sym_ptr_ptr + bfd_get_symcount (abfd);
	  for (; sym_ptr_ptr < sym_end; sym_ptr_ptr++)
	    {
	      asymbol *sym;
	      bfd_byte type, len;
	      bfd_vma offset;
	      bfd_byte temp[NLM_TARGET_LONG_SIZE];

	      sym = *sym_ptr_ptr;

	      /* The NLM notion of a debugging symbol is actually what
		 BFD calls a local or global symbol.  What BFD calls a
		 debugging symbol NLM does not understand at all.  */
	      if ((sym->flags & (BSF_LOCAL | BSF_GLOBAL | BSF_EXPORT)) == 0
		  || (sym->flags & BSF_DEBUGGING) != 0
		  || bfd_is_und_section (bfd_get_section (sym)))
		continue;

	      ++c;

	      offset = bfd_asymbol_value (sym);
	      sec = sym->section;
	      if (sec->flags & SEC_CODE)
		{
		  offset -= nlm_get_text_low (abfd);
		  type = 1;
		}
	      else if (sec->flags & (SEC_DATA | SEC_ALLOC))
		{
		  /* SEC_ALLOC is for the .bss section.  */
		  offset -= nlm_get_data_low (abfd);
		  type = 0;
		}
	      else
		type = 2;

	      /* The type is 0 for data, 1 for code, 2 for absolute.  */
	      if (bfd_bwrite (&type, (bfd_size_type) sizeof (bfd_byte), abfd)
		  != sizeof (bfd_byte))
		goto error_return;

	      put_word (abfd, offset, temp);
	      if (bfd_bwrite (temp, (bfd_size_type) sizeof (temp), abfd)
		  != sizeof (temp))
		goto error_return;

	      len = strlen (sym->name);
	      if ((bfd_bwrite (&len, (bfd_size_type) sizeof (bfd_byte), abfd)
		   != sizeof (bfd_byte))
		  || bfd_bwrite (sym->name, (bfd_size_type) len, abfd) != len)
		goto error_return;
	    }
	  nlm_fixed_header (abfd)->numberOfDebugRecords = c;
	}
    }

  /* NLMLINK fills in offset values even if there is no data, so we do
     the same.  */
  last = bfd_tell (abfd);
  if (nlm_fixed_header (abfd)->codeImageOffset == 0)
    nlm_fixed_header (abfd)->codeImageOffset = last;
  if (nlm_fixed_header (abfd)->dataImageOffset == 0)
    nlm_fixed_header (abfd)->dataImageOffset = last;
  if (nlm_fixed_header (abfd)->customDataOffset == 0)
    nlm_fixed_header (abfd)->customDataOffset = last;
  if (nlm_fixed_header (abfd)->moduleDependencyOffset == 0)
    nlm_fixed_header (abfd)->moduleDependencyOffset = last;
  if (nlm_fixed_header (abfd)->relocationFixupOffset == 0)
    nlm_fixed_header (abfd)->relocationFixupOffset = last;
  if (nlm_fixed_header (abfd)->externalReferencesOffset == 0)
    nlm_fixed_header (abfd)->externalReferencesOffset = last;
  if (nlm_fixed_header (abfd)->publicsOffset == 0)
    nlm_fixed_header (abfd)->publicsOffset = last;
  if (nlm_fixed_header (abfd)->debugInfoOffset == 0)
    nlm_fixed_header (abfd)->debugInfoOffset = last;

  /* At this point everything has been written out except the fixed
     header.  */
  memcpy (nlm_fixed_header (abfd)->signature, nlm_signature (abfd),
	  NLM_SIGNATURE_SIZE);
  nlm_fixed_header (abfd)->version = NLM_HEADER_VERSION;
  nlm_fixed_header (abfd)->codeStartOffset =
    (bfd_get_start_address (abfd)
     - nlm_get_text_low (abfd));

  /* We have no convenient way for the caller to pass in the exit
     procedure or the check unload procedure, so the caller must set
     the values in the header to the values of the symbols.  */
  nlm_fixed_header (abfd)->exitProcedureOffset -= nlm_get_text_low (abfd);
  if (nlm_fixed_header (abfd)->checkUnloadProcedureOffset != 0)
    nlm_fixed_header (abfd)->checkUnloadProcedureOffset -=
      nlm_get_text_low (abfd);

  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    goto error_return;

  write_prefix_func = nlm_write_prefix_func (abfd);
  if (write_prefix_func)
    {
      if (! (*write_prefix_func) (abfd))
	goto error_return;
    }

  BFD_ASSERT ((bfd_size_type) bfd_tell (abfd)
	      == nlm_optional_prefix_size (abfd));

  nlm_swap_fixed_header_out (abfd, nlm_fixed_header (abfd), fixed_header);
  if (bfd_bwrite (fixed_header, nlm_fixed_header_size (abfd), abfd)
      != nlm_fixed_header_size (abfd))
    goto error_return;

  if (fixed_header != NULL)
    free (fixed_header);
  return TRUE;

error_return:
  if (fixed_header != NULL)
    free (fixed_header);
  return FALSE;
}
@


1.22
log
@Switch sources over to use the GPL version 3
@
text
@d3 1
a3 1
   2005, 2006, 2007 Free Software Foundation, Inc.
d494 1
a494 1
  /* There's no supported way to discover the endianess of an NLM, so test for
@


1.21
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
d22 2
a23 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.20
log
@* bfd-in.h (CONST_STRNCPY) : Delete.
  (LITSTRCPY) : New.
  (LITMEMCPY) : New.
* bfd-in2.h : Regenerate.
* elflink.c  (bfd_elf_gc_sections) : Use LITMEMCPY. Don't manually calculate string lengths.
* nlmcode.h (nlm_swap_auxiliary_headers_in) : Use LITMEMCPY.
* nlmconv.c (main) : Use LITMEMCPY.
* prdbg.c (tg_class_static_member) : Use LITSTRCPY.
@
text
@d3 1
a3 1
   2005, 2006 Free Software Foundation, Inc.
d24 1
a25 1
#include "sysdep.h"
@


1.19
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d367 1
a367 1
	      memcpy (nlm_cygnus_ext_header (abfd), STRING_COMMA_LEN ("CyGnUsEx"));
d648 1
a648 1
      memcpy (thdr.stamp, STRING_COMMA_LEN ("VeRsIoN#"));
d675 1
a675 1
      memcpy (thdr.stamp, STRING_COMMA_LEN ("CoPyRiGhT="));
d697 1
a697 1
      memcpy (thdr.stamp, STRING_COMMA_LEN ("MeSsAgEs"));
d800 1
a800 1
      memcpy (thdr.stamp, STRING_COMMA_LEN ("CuStHeAd"));
d834 1
a834 1
      memcpy (thdr.stamp, STRING_COMMA_LEN ("CuStHeAd"));
d841 1
a841 1
      memcpy (thdr.dataStamp, STRING_COMMA_LEN ("CyGnUsEx"));
@


1.18
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d177 1
a177 1
      if (strncmp (tempstr, "VeRsIoN#", 8) == 0)
d199 1
a199 1
      else if (strncmp (tempstr, "MeSsAgEs", 8) == 0)
d267 1
a267 1
      else if (strncmp (tempstr, "CoPyRiGhT=", 10) == 0)
d283 1
a283 1
      else if (strncmp (tempstr, "CuStHeAd", 8) == 0)
d348 1
a348 1
	  if (strncmp (dataStamp, "CyGnUsEx", 8) == 0)
d367 1
a367 1
	      memcpy (nlm_cygnus_ext_header (abfd), "CyGnUsEx", 8);
d648 1
a648 1
      memcpy (thdr.stamp, "VeRsIoN#", 8);
d675 1
a675 1
      memcpy (thdr.stamp, "CoPyRiGhT=", 10);
d697 1
a697 1
      memcpy (thdr.stamp, "MeSsAgEs", 8);
d800 1
a800 1
      memcpy (thdr.stamp, "CuStHeAd", 8);
d834 1
a834 1
      memcpy (thdr.stamp, "CuStHeAd", 8);
d841 1
a841 1
      memcpy (thdr.dataStamp, "CyGnUsEx", 8);
@


1.17
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   2005 Free Software Foundation, Inc.
d141 1
a141 1
  newsect = bfd_make_section (abfd, name);
a147 1
  newsect->flags = flags;
@


1.16
log
@Update the FSF address in the copyright/GPL notice
@
text
@d22 1
a22 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.15
log
@Update to ISO-C90 and fix formatting
@
text
@d22 1
a22 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.14
log
@update copyright dates
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d36 18
a53 18
#define Nlm_External_Fixed_Header	NlmNAME(External_Fixed_Header)
#define Nlm_External_Version_Header	NlmNAME(External_Version_Header)
#define Nlm_External_Copyright_Header	NlmNAME(External_Copyright_Header)
#define Nlm_External_Extended_Header	NlmNAME(External_Extended_Header)
#define Nlm_External_Custom_Header	NlmNAME(External_Custom_Header)
#define Nlm_External_Cygnus_Ext_Header	NlmNAME(External_Cygnus_Ext_Header)

#define nlm_symbol_type			nlmNAME(symbol_type)
#define nlm_get_symtab_upper_bound	nlmNAME(get_symtab_upper_bound)
#define nlm_canonicalize_symtab		nlmNAME(canonicalize_symtab)
#define nlm_make_empty_symbol		nlmNAME(make_empty_symbol)
#define nlm_print_symbol		nlmNAME(print_symbol)
#define nlm_get_symbol_info		nlmNAME(get_symbol_info)
#define nlm_get_reloc_upper_bound	nlmNAME(get_reloc_upper_bound)
#define nlm_canonicalize_reloc		nlmNAME(canonicalize_reloc)
#define nlm_object_p			nlmNAME(object_p)
#define nlm_set_section_contents	nlmNAME(set_section_contents)
#define nlm_write_object_contents	nlmNAME(write_object_contents)
d56 1
a56 1
  (nlm_swap_fixed_header_in_func(abfd)) (abfd,src,dst)
d58 1
a58 24
  (nlm_swap_fixed_header_out_func(abfd)) (abfd,src,dst)

/* Forward declarations of static functions.  */

static bfd_boolean add_bfd_section
  PARAMS ((bfd *, char *, file_ptr, bfd_size_type, flagword));
static bfd_boolean nlm_swap_variable_header_in
  PARAMS ((bfd *));
static bfd_boolean nlm_swap_variable_header_out
  PARAMS ((bfd *));
static bfd_boolean find_nonzero
  PARAMS ((PTR, size_t));
static bfd_boolean nlm_swap_auxiliary_headers_in
  PARAMS ((bfd *));
static bfd_boolean nlm_swap_auxiliary_headers_out
  PARAMS ((bfd *));
static bfd_boolean nlm_slurp_symbol_table
  PARAMS ((bfd *));
static bfd_boolean nlm_slurp_reloc_fixups
  PARAMS ((bfd *));
static bfd_boolean nlm_compute_section_file_positions
  PARAMS ((bfd *));
static int nlm_external_reloc_compare
  PARAMS ((const void *, const void *));
a70 153
const bfd_target *
nlm_object_p (abfd)
     bfd *abfd;
{
  struct nlm_obj_tdata *preserved_tdata = nlm_tdata (abfd);
  bfd_boolean (*backend_object_p) PARAMS ((bfd *));
  PTR x_fxdhdr = NULL;
  Nlm_Internal_Fixed_Header *i_fxdhdrp;
  struct nlm_obj_tdata *new_tdata = NULL;
  const char *signature;
  enum bfd_architecture arch;
  bfd_size_type amt;

  /* Some NLM formats have a prefix before the standard NLM fixed
     header.  */
  backend_object_p = nlm_backend_object_p_func (abfd);
  if (backend_object_p)
    {
      if (!(*backend_object_p) (abfd))
	goto got_wrong_format_error;
    }

  /* Read in the fixed length portion of the NLM header in external format.  */
  amt = nlm_fixed_header_size (abfd);
  x_fxdhdr = (PTR) bfd_malloc (amt);
  if (x_fxdhdr == NULL)
    goto got_no_match;

  if (bfd_bread ((PTR) x_fxdhdr, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	goto got_wrong_format_error;
      else
	goto got_no_match;
    }

  /* Allocate an instance of the nlm_obj_tdata structure and hook it up to
     the tdata pointer in the bfd.  */
  amt = sizeof (struct nlm_obj_tdata);
  new_tdata = (struct nlm_obj_tdata *) bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    goto got_no_match;

  nlm_tdata (abfd) = new_tdata;

  i_fxdhdrp = nlm_fixed_header (abfd);
  nlm_swap_fixed_header_in (abfd, x_fxdhdr, i_fxdhdrp);
  free (x_fxdhdr);
  x_fxdhdr = NULL;

  /* Check to see if we have an NLM file for this backend by matching
     the NLM signature.  */
  signature = nlm_signature (abfd);
  if (signature != NULL
      && *signature != '\0'
      && strncmp ((char *) i_fxdhdrp->signature, signature,
		  NLM_SIGNATURE_SIZE) != 0)
    goto got_wrong_format_error;

  /* There's no supported way to discover the endianess of an NLM, so test for
     a sane version number after doing byte swapping appropriate for this
     XVEC.  (Hack alert!)  */
  if (i_fxdhdrp->version > 0xFFFF)
    goto got_wrong_format_error;

  /* There's no supported way to check for 32 bit versus 64 bit addresses,
     so ignore this distinction for now.  (FIXME) */
  /* Swap in the rest of the required header.  */
  if (!nlm_swap_variable_header_in (abfd))
    {
      if (bfd_get_error () != bfd_error_system_call)
	goto got_wrong_format_error;
      else
	goto got_no_match;
    }

  /* Add the sections supplied by all NLM's, and then read in the
     auxiliary headers.  Reading the auxiliary headers may create
     additional sections described in the cygnus_ext header.
     From this point on we assume that we have an NLM, and do not
     treat errors as indicating the wrong format.  */
  if (!add_bfd_section (abfd, NLM_CODE_NAME,
			i_fxdhdrp->codeImageOffset,
			i_fxdhdrp->codeImageSize,
			(SEC_CODE | SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			 | SEC_RELOC))
      || !add_bfd_section (abfd, NLM_INITIALIZED_DATA_NAME,
			   i_fxdhdrp->dataImageOffset,
			   i_fxdhdrp->dataImageSize,
			   (SEC_DATA | SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_RELOC))
      || !add_bfd_section (abfd, NLM_UNINITIALIZED_DATA_NAME,
			   (file_ptr) 0,
			   i_fxdhdrp->uninitializedDataSize,
			   SEC_ALLOC))
    goto got_no_match;

  if (!nlm_swap_auxiliary_headers_in (abfd))
    goto got_no_match;

  if (nlm_fixed_header (abfd)->numberOfRelocationFixups != 0
      || nlm_fixed_header (abfd)->numberOfExternalReferences != 0)
    abfd->flags |= HAS_RELOC;
  if (nlm_fixed_header (abfd)->numberOfPublics != 0
      || nlm_fixed_header (abfd)->numberOfDebugRecords != 0
      || nlm_fixed_header (abfd)->numberOfExternalReferences != 0)
    abfd->flags |= HAS_SYMS;

  arch = nlm_architecture (abfd);
  if (arch != bfd_arch_unknown)
    bfd_default_set_arch_mach (abfd, arch, (unsigned long) 0);

  abfd->flags |= EXEC_P;
  bfd_get_start_address (abfd) = nlm_fixed_header (abfd)->codeStartOffset;

  return (abfd->xvec);

got_wrong_format_error:
  bfd_set_error (bfd_error_wrong_format);
got_no_match:
  nlm_tdata (abfd) = preserved_tdata;
  if (new_tdata != NULL)
    bfd_release (abfd, new_tdata);
  if (x_fxdhdr != NULL)
    free (x_fxdhdr);
  return (NULL);
}

/* Add a section to the bfd.  */

static bfd_boolean
add_bfd_section (abfd, name, offset, size, flags)
     bfd *abfd;
     char *name;
     file_ptr offset;
     bfd_size_type size;
     flagword flags;
{
  asection *newsect;

  newsect = bfd_make_section (abfd, name);
  if (newsect == NULL)
    return FALSE;

  newsect->vma = 0;		/* NLM's are relocatable.  */
  newsect->size = size;
  newsect->filepos = offset;
  newsect->flags = flags;
  newsect->alignment_power = bfd_log2 ((bfd_vma) 0);	/* FIXME */

  return TRUE;
}

d75 1
a75 2
nlm_swap_variable_header_in (abfd)
     bfd *abfd;
a80 1

d82 1
a82 1
  if (bfd_bread ((PTR) &nlm_variable_header (abfd)->descriptionLength,
d86 1
a86 1
  if (bfd_bread ((PTR) nlm_variable_header (abfd)->descriptionText,
a90 1

d92 1
a92 1
  if (bfd_bread ((PTR) temp, amt, abfd) != amt)
a96 1

d98 1
a98 1
  if (bfd_bread ((PTR) temp, amt, abfd) != amt)
a102 1

d104 1
a104 1
  if (bfd_bread ((PTR) nlm_variable_header (abfd)->oldThreadName,
a108 1

d110 1
a110 1
  if (bfd_bread ((PTR) & nlm_variable_header (abfd)->screenNameLength,
d114 1
a114 1
  if (bfd_bread ((PTR) nlm_variable_header (abfd)->screenName,
a118 1

d120 1
a120 1
  if (bfd_bread ((PTR) & nlm_variable_header (abfd)->threadNameLength,
d124 1
a124 1
  if (bfd_bread ((PTR) nlm_variable_header (abfd)->threadName,
d130 1
a130 2
/* Swap and write out the variable length header.  All the fields must
   exist in the NLM, and must exist in this order.  */
d133 5
a137 2
nlm_swap_variable_header_out (abfd)
     bfd *abfd;
d139 1
a139 2
  unsigned char temp[NLM_TARGET_LONG_SIZE];
  bfd_size_type amt;
d141 2
a142 8
  /* Write the description length and text members.  */
  amt = sizeof (nlm_variable_header (abfd)->descriptionLength);
  if (bfd_bwrite ((PTR) & nlm_variable_header (abfd)->descriptionLength, amt,
		 abfd) != amt)
    return FALSE;
  amt = nlm_variable_header (abfd)->descriptionLength + 1;
  if (bfd_bwrite ((PTR) nlm_variable_header (abfd)->descriptionText, amt,
		 abfd) != amt)
d145 5
a149 13
  /* Convert and write the stackSize field.  */
  put_word (abfd, (bfd_vma) nlm_variable_header (abfd)->stackSize,
	    (bfd_byte *) temp);
  amt = sizeof (temp);
  if (bfd_bwrite ((PTR) temp, amt, abfd) != amt)
    return FALSE;

  /* Convert and write the reserved field.  */
  put_word (abfd, (bfd_vma) nlm_variable_header (abfd)->reserved,
	    (bfd_byte *) temp);
  amt = sizeof (temp);
  if (bfd_bwrite ((PTR) temp, amt, abfd) != amt)
    return FALSE;
a150 25
  /* Write the oldThreadName field.  This field is a fixed length string.  */
  amt = sizeof (nlm_variable_header (abfd)->oldThreadName);
  if (bfd_bwrite ((PTR) nlm_variable_header (abfd)->oldThreadName, amt,
		 abfd) != amt)
    return FALSE;

  /* Write the screen name length and text members.  */
  amt = sizeof (nlm_variable_header (abfd)->screenNameLength);
  if (bfd_bwrite ((PTR) & nlm_variable_header (abfd)->screenNameLength, amt,
		 abfd) != amt)
    return FALSE;
  amt = nlm_variable_header (abfd)->screenNameLength + 1;
  if (bfd_bwrite ((PTR) nlm_variable_header (abfd)->screenName, amt,
		 abfd) != amt)
    return FALSE;

  /* Write the thread name length and text members.  */
  amt = sizeof (nlm_variable_header (abfd)->threadNameLength);
  if (bfd_bwrite ((PTR) & nlm_variable_header (abfd)->threadNameLength, amt,
		 abfd) != amt)
    return FALSE;
  amt = nlm_variable_header (abfd)->threadNameLength + 1;
  if (bfd_bwrite ((PTR) nlm_variable_header (abfd)->threadName, amt,
		 abfd) != amt)
    return FALSE;
d164 1
a164 2
nlm_swap_auxiliary_headers_in (abfd)
     bfd *abfd;
d174 1
a174 1
      if (bfd_bread ((PTR) tempstr, amt, abfd) != amt)
d183 1
a183 1
	  if (bfd_bread ((PTR) &thdr, amt, abfd) != amt)
d205 1
a205 1
	  if (bfd_bread ((PTR) &thdr, amt, abfd) != amt)
d271 1
a271 1
	  if (bfd_bread ((PTR) nlm_copyright_header (abfd)->stamp,
d274 1
a274 1
	  if (bfd_bread ((PTR) &(nlm_copyright_header (abfd)
d280 1
a280 1
	  if (bfd_bread ((PTR) nlm_copyright_header (abfd)->copyrightMessage,
d291 1
a291 1
	  PTR hdr;
d295 1
a295 1
	  if (bfd_bread ((PTR) thdr.stamp, amt, abfd) != amt)
d299 1
a299 1
	  if (bfd_bread ((PTR) thdr.length, amt, abfd) != amt)
d308 1
a308 1
	      if (bfd_bread ((PTR) thdr.dataOffset, amt, abfd) != amt)
d317 1
a317 1
	      if (bfd_bread ((PTR) thdr.dataLength, amt, abfd) != amt)
d326 1
a326 1
	      if (bfd_bread ((PTR) dataStamp, amt, abfd) != amt)
d360 1
a360 1
	      contents = (bfd_byte *) bfd_alloc (abfd, dataLength);
d396 1
a396 2
		     4 byte section size
		     */
d408 1
a408 1
		  if (newsec == (asection *) NULL)
d436 185
d624 1
a624 3
find_nonzero (buf, size)
     PTR buf;
     size_t size;
d639 1
a639 2
nlm_swap_auxiliary_headers_out (abfd)
     bfd *abfd;
d644 1
a644 1
  if (find_nonzero ((PTR) nlm_version_header (abfd),
d662 1
a662 1
      if (bfd_bwrite ((PTR) &thdr, (bfd_size_type) sizeof (thdr), abfd)
d671 1
a671 1
  if (find_nonzero ((PTR) nlm_copyright_header (abfd),
d678 1
a678 1
      if (bfd_bwrite ((PTR) thdr.stamp, amt, abfd) != amt)
d683 1
a683 1
      if (bfd_bwrite ((PTR) thdr.copyrightMessageLength, amt, abfd) != amt)
d687 1
a687 1
      if (bfd_bwrite ((PTR) nlm_copyright_header (abfd)->copyrightMessage,
d693 1
a693 1
  if (find_nonzero ((PTR) nlm_extended_header (abfd),
d786 1
a786 1
      if (bfd_bwrite ((PTR) &thdr, (bfd_size_type) sizeof (thdr), abfd)
d792 1
a792 1
  if (find_nonzero ((PTR) nlm_custom_header (abfd),
d799 1
a799 1
      ds = find_nonzero ((PTR) nlm_custom_header (abfd)->dataStamp,
d813 1
a813 1
	  if (bfd_bwrite ((PTR) &thdr, amt, abfd) != amt)
d821 1
a821 1
	  if (bfd_bwrite ((PTR) &thdr, amt, abfd) != amt)
d830 1
a830 1
  if (find_nonzero ((PTR) nlm_cygnus_ext_header (abfd),
d844 1
a844 1
      if (bfd_bwrite ((PTR) &thdr, amt, abfd) != amt)
d861 1
a861 2
nlm_get_symtab_upper_bound (abfd)
     bfd *abfd;
d872 1
a872 77
  return (symtab_size);
}

/* Note that bfd_get_symcount is guaranteed to be zero if slurping the
   symbol table fails.  */

long
nlm_canonicalize_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
{
  nlm_symbol_type *symbase;
  bfd_size_type counter = 0;

  if (! nlm_slurp_symbol_table (abfd))
    return -1;
  symbase = nlm_get_symbols (abfd);
  while (counter < bfd_get_symcount (abfd))
    {
      *alocation++ = &symbase->symbol;
      symbase++;
      counter++;
    }
  *alocation = (asymbol *) NULL;
  return bfd_get_symcount (abfd);
}

/* Make an NLM symbol.  There is nothing special to do here.  */

asymbol *
nlm_make_empty_symbol (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (nlm_symbol_type);
  nlm_symbol_type *new = (nlm_symbol_type *) bfd_zalloc (abfd, amt);

  if (new)
    new->symbol.the_bfd = abfd;
  return &new->symbol;
}

/* Get symbol information.  */

void
nlm_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
{
  bfd_symbol_info (symbol, ret);
}

/* Print symbol information.  */

void
nlm_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
{
  FILE *file = (FILE *) afile;

  switch (how)
    {
    case bfd_print_symbol_name:
    case bfd_print_symbol_more:
      if (symbol->name)
	fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_all:
      bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
      fprintf (file, " %-5s", symbol->section->name);
      if (symbol->name)
	fprintf (file, " %s", symbol->name);
      break;
    }
d889 1
a889 1
   The bfd symbols are copied to SYMPTRS.
d895 1
a895 2
nlm_slurp_symbol_table (abfd)
     bfd *abfd;
d904 2
a905 2
  bfd_boolean (*read_import_func) PARAMS ((bfd *, nlm_symbol_type *));
  bfd_boolean (*set_public_section_func) PARAMS ((bfd *, nlm_symbol_type *));
d931 1
a931 1
  sym = ((nlm_symbol_type *) bfd_zalloc (abfd, amt));
d945 1
a945 1
      if (bfd_bread ((PTR) &symlength, amt, abfd) != amt)
d952 1
a952 1
      if (bfd_bread ((PTR) sym->symbol.name, amt, abfd) != amt)
d957 1
a957 1
      if (bfd_bread ((PTR) temp, amt, abfd) != amt)
d978 2
a979 4
	    {
	      sym->symbol.section =
		bfd_get_section_by_name (abfd, NLM_INITIALIZED_DATA_NAME);
	    }
d997 1
a997 1
	  if (bfd_bread ((PTR) &symtype, amt, abfd) != amt)
d1000 1
a1000 1
	  if (bfd_bread ((PTR) temp, amt, abfd) != amt)
d1003 1
a1003 1
	  if (bfd_bread ((PTR) &symlength, amt, abfd) != amt)
d1010 1
a1010 1
	  if (bfd_bread ((PTR) sym->symbol.name, amt, abfd) != amt)
d1016 1
d1018 2
a1019 4
	    {
	      sym->symbol.section =
		bfd_get_section_by_name (abfd, NLM_INITIALIZED_DATA_NAME);
	    }
d1027 2
a1028 3
	    {
	      sym->symbol.section = bfd_abs_section_ptr;
	    }
d1055 72
d1142 1
a1142 2
nlm_slurp_reloc_fixups (abfd)
     bfd *abfd;
d1144 1
a1144 2
  bfd_boolean (*read_func)
    PARAMS ((bfd *, nlm_symbol_type *, asection **, arelent *));
d1161 1
a1161 1
  rels = (arelent *) bfd_alloc (abfd, amt);
d1163 1
a1163 1
  secs = (asection **) bfd_alloc (abfd, amt);
d1173 1
a1173 1
      if (! (*read_func) (abfd, (nlm_symbol_type *) NULL, secs, rels))
d1191 1
a1191 3
nlm_get_reloc_upper_bound (abfd, sec)
     bfd *abfd;
     asection *sec;
d1227 4
a1230 5
nlm_canonicalize_reloc (abfd, sec, relptr, symbols)
     bfd *abfd;
     asection *sec;
     arelent **relptr;
     asymbol **symbols;
d1235 1
a1235 1
  unsigned int ret;
d1306 1
a1306 2
nlm_compute_section_file_positions (abfd)
     bfd *abfd;
d1348 1
a1348 1
  if (find_nonzero ((PTR) nlm_version_header (abfd),
d1351 1
a1351 1
  if (find_nonzero ((PTR) nlm_extended_header (abfd),
d1354 1
a1354 1
  if (find_nonzero ((PTR) nlm_copyright_header (abfd),
d1358 1
a1358 1
  if (find_nonzero ((PTR) nlm_custom_header (abfd),
d1362 1
a1362 1
  if (find_nonzero ((PTR) nlm_cygnus_ext_header (abfd),
d1379 1
a1379 1
  for (sec = abfd->sections; sec != (asection *) NULL; sec = sec->next)
d1435 1
a1435 1
  for (sec = abfd->sections; sec != (asection *) NULL; sec = sec->next)
d1511 5
a1515 6
nlm_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     asection *section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
d1531 1
a1531 1
	PARAMS ((bfd *, asection *, const PTR, bfd_vma, bfd_size_type));
d1553 1
a1553 3
nlm_external_reloc_compare (p1, p2)
     const void *p1;
     const void *p2;
d1599 1
a1599 2
nlm_write_object_contents (abfd)
     bfd *abfd;
d1602 1
a1602 1
  bfd_boolean (*write_import_func) PARAMS ((bfd *, asection *, arelent *));
d1607 1
a1607 1
  bfd_boolean (*write_prefix_func) PARAMS ((bfd *));
d1612 1
a1612 2
  fixed_header = ((unsigned char *)
		  bfd_malloc (nlm_fixed_header_size (abfd)));
d1654 1
a1654 1
  for (sec = abfd->sections; sec != (asection *) NULL; sec = sec->next)
d1700 2
a1701 2
  external_relocs = (struct reloc_and_sec *) bfd_alloc (abfd, amt);
  if (external_relocs == (struct reloc_and_sec *) NULL)
d1704 1
a1704 1
  for (sec = abfd->sections; sec != (asection *) NULL; sec = sec->next)
d1733 1
a1733 1
  qsort ((PTR) external_relocs, (size_t) external_reloc_count,
d1769 1
a1769 1
  if (sym_ptr_ptr != (asymbol **) NULL)
d1771 2
a1772 2
      bfd_vma (*get_public_offset_func) PARAMS ((bfd *, asymbol *));
      bfd_boolean (*write_export_func) PARAMS ((bfd *, asymbol *, bfd_vma));
@


1.13
log
@	* elf32-arm.c (elf32_arm_finish_dynamic_sections): Warning fix.
	* elf32-iq2000.c (iq2000_reloc_type_lookup): C90 function decl.
	* nlmcode.h (nlm_write_object_contents): Warning fix.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003, 2004
@


1.12
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1695 1
a1695 1
  if (bfd_tell (abfd) > (ufile_ptr) nlm_fixed_header (abfd)->codeImageOffset)
@


1.11
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003
d239 1
a239 1
  newsect->_raw_size = size;
d633 1
a633 1
		  newsec->_raw_size = size;
d1440 1
a1440 1
      sec->_raw_size = BFD_ALIGN (sec->_raw_size, 1 << sec->alignment_power);
d1445 1
a1445 1
	  text += sec->_raw_size;
d1453 1
a1453 1
	  data += sec->_raw_size;
d1465 1
a1465 1
	bss += sec->_raw_size;
d1501 1
a1501 1
	  text_ptr += sec->_raw_size;
d1506 1
a1506 1
	  data_ptr += sec->_raw_size;
d1511 1
a1511 1
	  other_ptr += sec->_raw_size;
d1542 1
a1542 1
	  sym->value = bss_sec->_raw_size + add;
d1555 1
a1555 1
	  bss_sec->_raw_size += add;
@


1.11.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003, 2004
d239 1
a239 1
  newsect->size = size;
d633 1
a633 1
		  newsec->size = size;
d1440 1
a1440 1
      sec->size = BFD_ALIGN (sec->size, 1 << sec->alignment_power);
d1445 1
a1445 1
	  text += sec->size;
d1453 1
a1453 1
	  data += sec->size;
d1465 1
a1465 1
	bss += sec->size;
d1501 1
a1501 1
	  text_ptr += sec->size;
d1506 1
a1506 1
	  data_ptr += sec->size;
d1511 1
a1511 1
	  other_ptr += sec->size;
d1542 1
a1542 1
	  sym->value = bss_sec->size + add;
d1555 1
a1555 1
	  bss_sec->size += add;
@


1.10
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002
d1571 1
a1571 1
     PTR location;
d1589 1
a1589 1
	PARAMS ((bfd *, asection *, PTR, bfd_vma, bfd_size_type));
@


1.9
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d45 1
a45 1
#define nlm_get_symtab			nlmNAME(get_symtab)
d921 1
a921 1
nlm_get_symtab (abfd, alocation)
@


1.8
log
@Swapped the order of the MeSsAgEs and CoPyRiGhT tags to make >=NW4.x NLM
loaders to show the Copyright string.
@
text
@d62 1
a62 1
static boolean add_bfd_section
d64 1
a64 1
static boolean nlm_swap_variable_header_in
d66 1
a66 1
static boolean nlm_swap_variable_header_out
d68 1
a68 1
static boolean find_nonzero
d70 1
a70 1
static boolean nlm_swap_auxiliary_headers_in
d72 1
a72 1
static boolean nlm_swap_auxiliary_headers_out
d74 1
a74 1
static boolean nlm_slurp_symbol_table
d76 1
a76 1
static boolean nlm_slurp_reloc_fixups
d78 1
a78 1
static boolean nlm_compute_section_file_positions
d99 1
a99 1
  boolean (*backend_object_p) PARAMS ((bfd *));
d224 1
a224 1
static boolean
d236 1
a236 1
    return false;
d244 1
a244 1
  return true;
d250 1
a250 1
static boolean
d262 1
a262 1
    return false;
d266 1
a266 1
    return false;
d272 1
a272 1
    return false;
d279 1
a279 1
    return false;
d287 1
a287 1
    return false;
d294 1
a294 1
    return false;
d298 1
a298 1
    return false;
d305 1
a305 1
    return false;
d309 2
a310 2
    return false;
  return true;
d316 1
a316 1
static boolean
d327 1
a327 1
    return false;
d331 1
a331 1
    return false;
d338 1
a338 1
    return false;
d345 1
a345 1
    return false;
d351 1
a351 1
    return false;
d357 1
a357 1
    return false;
d361 1
a361 1
    return false;
d367 1
a367 1
    return false;
d371 2
a372 2
    return false;
  return true;
d384 1
a384 1
static boolean
d397 1
a397 1
	return false;
d399 1
a399 1
	return false;
d406 1
a406 1
	    return false;
d428 1
a428 1
	    return false;
d495 1
a495 1
	    return false;
d499 1
a499 1
	    return false;
d504 1
a504 1
	    return false;
d518 1
a518 1
	    return false;
d522 1
a522 1
	    return false;
d531 1
a531 1
		return false;
d540 1
a540 1
		return false;
d549 1
a549 1
		return false;
d563 1
a563 1
		return false;
d565 1
a565 1
		return false;
d581 1
a581 1
		return false;
d584 1
a584 1
		return false;
d586 1
a586 1
		return false;
d588 1
a588 1
		return false;
d632 1
a632 1
		    return false;
d656 1
a656 1
  return true;
d661 1
a661 1
static boolean
d670 2
a671 2
      return true;
  return false;
d678 1
a678 1
static boolean
d705 1
a705 1
	return false;
d720 1
a720 1
	return false;
d725 1
a725 1
	return false;
d730 1
a730 1
	return false;
d829 1
a829 1
	return false;
d837 1
a837 1
      boolean ds;
d855 1
a855 1
	    return false;
d863 1
a863 1
	    return false;
d866 1
a866 1
	    return false;
d886 1
a886 1
	return false;
d889 1
a889 1
  return true;
d1012 1
a1012 1
static boolean
d1023 2
a1024 2
  boolean (*read_import_func) PARAMS ((bfd *, nlm_symbol_type *));
  boolean (*set_public_section_func) PARAMS ((bfd *, nlm_symbol_type *));
d1028 1
a1028 1
    return true;
d1044 1
a1044 1
    return true;
d1047 1
a1047 1
    return false;
d1052 1
a1052 1
    return false;
d1065 1
a1065 1
	return false;
d1070 1
a1070 1
	return false;
d1072 1
a1072 1
	return false;
d1077 1
a1077 1
	return false;
d1085 1
a1085 1
	    return false;
d1112 1
a1112 1
	return false;
d1119 1
a1119 1
	    return false;
d1122 1
a1122 1
	    return false;
d1125 1
a1125 1
	    return false;
d1130 1
a1130 1
	    return false;
d1132 1
a1132 1
	    return false;
d1164 1
a1164 1
	return false;
d1170 1
a1170 1
	    return false;
d1176 1
a1176 1
  return true;
d1192 1
a1192 1
static boolean
d1196 2
a1197 2
  boolean (*read_func) PARAMS ((bfd *, nlm_symbol_type *, asection **,
				arelent *));
d1203 1
a1203 1
    return true;
d1206 1
a1206 1
    return true;
d1210 1
a1210 1
    return false;
d1218 1
a1218 1
    return false;
d1230 1
a1230 1
	  return false;
d1236 1
a1236 1
  return true;
d1361 1
a1361 1
static boolean
d1375 1
a1375 1
    return true;
d1384 1
a1384 1
	return false;
d1388 1
a1388 1
  abfd->output_has_begun = true;
d1559 1
a1559 1
  return true;
d1567 1
a1567 1
boolean
d1577 1
a1577 1
    return false;
d1580 1
a1580 1
    return true;
d1588 2
a1589 2
      boolean (*mangle_relocs_func) PARAMS ((bfd *, asection *, PTR,
					     bfd_vma, bfd_size_type));
d1596 1
a1596 1
	    return false;
d1602 1
a1602 1
    return false;
d1604 1
a1604 1
  return true;
d1658 1
a1658 1
boolean
d1663 1
a1663 1
  boolean (*write_import_func) PARAMS ((bfd *, asection *, arelent *));
d1668 1
a1668 1
  boolean (*write_prefix_func) PARAMS ((bfd *));
d1834 1
a1834 1
      boolean (*write_export_func) PARAMS ((bfd *, asymbol *, bfd_vma));
d2037 1
a2037 1
  return true;
d2042 1
a2042 1
  return false;
@


1.8.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003
d45 1
a45 1
#define nlm_canonicalize_symtab		nlmNAME(canonicalize_symtab)
d62 1
a62 1
static bfd_boolean add_bfd_section
d64 1
a64 1
static bfd_boolean nlm_swap_variable_header_in
d66 1
a66 1
static bfd_boolean nlm_swap_variable_header_out
d68 1
a68 1
static bfd_boolean find_nonzero
d70 1
a70 1
static bfd_boolean nlm_swap_auxiliary_headers_in
d72 1
a72 1
static bfd_boolean nlm_swap_auxiliary_headers_out
d74 1
a74 1
static bfd_boolean nlm_slurp_symbol_table
d76 1
a76 1
static bfd_boolean nlm_slurp_reloc_fixups
d78 1
a78 1
static bfd_boolean nlm_compute_section_file_positions
d99 1
a99 1
  bfd_boolean (*backend_object_p) PARAMS ((bfd *));
d224 1
a224 1
static bfd_boolean
d236 1
a236 1
    return FALSE;
d244 1
a244 1
  return TRUE;
d250 1
a250 1
static bfd_boolean
d262 1
a262 1
    return FALSE;
d266 1
a266 1
    return FALSE;
d272 1
a272 1
    return FALSE;
d279 1
a279 1
    return FALSE;
d287 1
a287 1
    return FALSE;
d294 1
a294 1
    return FALSE;
d298 1
a298 1
    return FALSE;
d305 1
a305 1
    return FALSE;
d309 2
a310 2
    return FALSE;
  return TRUE;
d316 1
a316 1
static bfd_boolean
d327 1
a327 1
    return FALSE;
d331 1
a331 1
    return FALSE;
d338 1
a338 1
    return FALSE;
d345 1
a345 1
    return FALSE;
d351 1
a351 1
    return FALSE;
d357 1
a357 1
    return FALSE;
d361 1
a361 1
    return FALSE;
d367 1
a367 1
    return FALSE;
d371 2
a372 2
    return FALSE;
  return TRUE;
d384 1
a384 1
static bfd_boolean
d397 1
a397 1
	return FALSE;
d399 1
a399 1
	return FALSE;
d406 1
a406 1
	    return FALSE;
d428 1
a428 1
	    return FALSE;
d495 1
a495 1
	    return FALSE;
d499 1
a499 1
	    return FALSE;
d504 1
a504 1
	    return FALSE;
d518 1
a518 1
	    return FALSE;
d522 1
a522 1
	    return FALSE;
d531 1
a531 1
		return FALSE;
d540 1
a540 1
		return FALSE;
d549 1
a549 1
		return FALSE;
d563 1
a563 1
		return FALSE;
d565 1
a565 1
		return FALSE;
d581 1
a581 1
		return FALSE;
d584 1
a584 1
		return FALSE;
d586 1
a586 1
		return FALSE;
d588 1
a588 1
		return FALSE;
d632 1
a632 1
		    return FALSE;
d656 1
a656 1
  return TRUE;
d661 1
a661 1
static bfd_boolean
d670 2
a671 2
      return TRUE;
  return FALSE;
d678 1
a678 1
static bfd_boolean
d705 1
a705 1
	return FALSE;
d720 1
a720 1
	return FALSE;
d725 1
a725 1
	return FALSE;
d730 1
a730 1
	return FALSE;
d829 1
a829 1
	return FALSE;
d837 1
a837 1
      bfd_boolean ds;
d855 1
a855 1
	    return FALSE;
d863 1
a863 1
	    return FALSE;
d866 1
a866 1
	    return FALSE;
d886 1
a886 1
	return FALSE;
d889 1
a889 1
  return TRUE;
d921 1
a921 1
nlm_canonicalize_symtab (abfd, alocation)
d1012 1
a1012 1
static bfd_boolean
d1023 2
a1024 2
  bfd_boolean (*read_import_func) PARAMS ((bfd *, nlm_symbol_type *));
  bfd_boolean (*set_public_section_func) PARAMS ((bfd *, nlm_symbol_type *));
d1028 1
a1028 1
    return TRUE;
d1044 1
a1044 1
    return TRUE;
d1047 1
a1047 1
    return FALSE;
d1052 1
a1052 1
    return FALSE;
d1065 1
a1065 1
	return FALSE;
d1070 1
a1070 1
	return FALSE;
d1072 1
a1072 1
	return FALSE;
d1077 1
a1077 1
	return FALSE;
d1085 1
a1085 1
	    return FALSE;
d1112 1
a1112 1
	return FALSE;
d1119 1
a1119 1
	    return FALSE;
d1122 1
a1122 1
	    return FALSE;
d1125 1
a1125 1
	    return FALSE;
d1130 1
a1130 1
	    return FALSE;
d1132 1
a1132 1
	    return FALSE;
d1164 1
a1164 1
	return FALSE;
d1170 1
a1170 1
	    return FALSE;
d1176 1
a1176 1
  return TRUE;
d1192 1
a1192 1
static bfd_boolean
d1196 2
a1197 2
  bfd_boolean (*read_func)
    PARAMS ((bfd *, nlm_symbol_type *, asection **, arelent *));
d1203 1
a1203 1
    return TRUE;
d1206 1
a1206 1
    return TRUE;
d1210 1
a1210 1
    return FALSE;
d1218 1
a1218 1
    return FALSE;
d1230 1
a1230 1
	  return FALSE;
d1236 1
a1236 1
  return TRUE;
d1361 1
a1361 1
static bfd_boolean
d1375 1
a1375 1
    return TRUE;
d1384 1
a1384 1
	return FALSE;
d1388 1
a1388 1
  abfd->output_has_begun = TRUE;
d1559 1
a1559 1
  return TRUE;
d1567 1
a1567 1
bfd_boolean
d1571 1
a1571 1
     const PTR location;
d1577 1
a1577 1
    return FALSE;
d1580 1
a1580 1
    return TRUE;
d1588 2
a1589 2
      bfd_boolean (*mangle_relocs_func)
	PARAMS ((bfd *, asection *, const PTR, bfd_vma, bfd_size_type));
d1596 1
a1596 1
	    return FALSE;
d1602 1
a1602 1
    return FALSE;
d1604 1
a1604 1
  return TRUE;
d1658 1
a1658 1
bfd_boolean
d1663 1
a1663 1
  bfd_boolean (*write_import_func) PARAMS ((bfd *, asection *, arelent *));
d1668 1
a1668 1
  bfd_boolean (*write_prefix_func) PARAMS ((bfd *));
d1834 1
a1834 1
      bfd_boolean (*write_export_func) PARAMS ((bfd *, asymbol *, bfd_vma));
d2037 1
a2037 1
  return TRUE;
d2042 1
a2042 1
  return FALSE;
@


1.8.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d62 1
a62 1
static bfd_boolean add_bfd_section
d64 1
a64 1
static bfd_boolean nlm_swap_variable_header_in
d66 1
a66 1
static bfd_boolean nlm_swap_variable_header_out
d68 1
a68 1
static bfd_boolean find_nonzero
d70 1
a70 1
static bfd_boolean nlm_swap_auxiliary_headers_in
d72 1
a72 1
static bfd_boolean nlm_swap_auxiliary_headers_out
d74 1
a74 1
static bfd_boolean nlm_slurp_symbol_table
d76 1
a76 1
static bfd_boolean nlm_slurp_reloc_fixups
d78 1
a78 1
static bfd_boolean nlm_compute_section_file_positions
d99 1
a99 1
  bfd_boolean (*backend_object_p) PARAMS ((bfd *));
d224 1
a224 1
static bfd_boolean
d236 1
a236 1
    return FALSE;
d244 1
a244 1
  return TRUE;
d250 1
a250 1
static bfd_boolean
d262 1
a262 1
    return FALSE;
d266 1
a266 1
    return FALSE;
d272 1
a272 1
    return FALSE;
d279 1
a279 1
    return FALSE;
d287 1
a287 1
    return FALSE;
d294 1
a294 1
    return FALSE;
d298 1
a298 1
    return FALSE;
d305 1
a305 1
    return FALSE;
d309 2
a310 2
    return FALSE;
  return TRUE;
d316 1
a316 1
static bfd_boolean
d327 1
a327 1
    return FALSE;
d331 1
a331 1
    return FALSE;
d338 1
a338 1
    return FALSE;
d345 1
a345 1
    return FALSE;
d351 1
a351 1
    return FALSE;
d357 1
a357 1
    return FALSE;
d361 1
a361 1
    return FALSE;
d367 1
a367 1
    return FALSE;
d371 2
a372 2
    return FALSE;
  return TRUE;
d384 1
a384 1
static bfd_boolean
d397 1
a397 1
	return FALSE;
d399 1
a399 1
	return FALSE;
d406 1
a406 1
	    return FALSE;
d428 1
a428 1
	    return FALSE;
d495 1
a495 1
	    return FALSE;
d499 1
a499 1
	    return FALSE;
d504 1
a504 1
	    return FALSE;
d518 1
a518 1
	    return FALSE;
d522 1
a522 1
	    return FALSE;
d531 1
a531 1
		return FALSE;
d540 1
a540 1
		return FALSE;
d549 1
a549 1
		return FALSE;
d563 1
a563 1
		return FALSE;
d565 1
a565 1
		return FALSE;
d581 1
a581 1
		return FALSE;
d584 1
a584 1
		return FALSE;
d586 1
a586 1
		return FALSE;
d588 1
a588 1
		return FALSE;
d632 1
a632 1
		    return FALSE;
d656 1
a656 1
  return TRUE;
d661 1
a661 1
static bfd_boolean
d670 2
a671 2
      return TRUE;
  return FALSE;
d678 1
a678 1
static bfd_boolean
d705 1
a705 1
	return FALSE;
d720 1
a720 1
	return FALSE;
d725 1
a725 1
	return FALSE;
d730 1
a730 1
	return FALSE;
d829 1
a829 1
	return FALSE;
d837 1
a837 1
      bfd_boolean ds;
d855 1
a855 1
	    return FALSE;
d863 1
a863 1
	    return FALSE;
d866 1
a866 1
	    return FALSE;
d886 1
a886 1
	return FALSE;
d889 1
a889 1
  return TRUE;
d1012 1
a1012 1
static bfd_boolean
d1023 2
a1024 2
  bfd_boolean (*read_import_func) PARAMS ((bfd *, nlm_symbol_type *));
  bfd_boolean (*set_public_section_func) PARAMS ((bfd *, nlm_symbol_type *));
d1028 1
a1028 1
    return TRUE;
d1044 1
a1044 1
    return TRUE;
d1047 1
a1047 1
    return FALSE;
d1052 1
a1052 1
    return FALSE;
d1065 1
a1065 1
	return FALSE;
d1070 1
a1070 1
	return FALSE;
d1072 1
a1072 1
	return FALSE;
d1077 1
a1077 1
	return FALSE;
d1085 1
a1085 1
	    return FALSE;
d1112 1
a1112 1
	return FALSE;
d1119 1
a1119 1
	    return FALSE;
d1122 1
a1122 1
	    return FALSE;
d1125 1
a1125 1
	    return FALSE;
d1130 1
a1130 1
	    return FALSE;
d1132 1
a1132 1
	    return FALSE;
d1164 1
a1164 1
	return FALSE;
d1170 1
a1170 1
	    return FALSE;
d1176 1
a1176 1
  return TRUE;
d1192 1
a1192 1
static bfd_boolean
d1196 2
a1197 2
  bfd_boolean (*read_func)
    PARAMS ((bfd *, nlm_symbol_type *, asection **, arelent *));
d1203 1
a1203 1
    return TRUE;
d1206 1
a1206 1
    return TRUE;
d1210 1
a1210 1
    return FALSE;
d1218 1
a1218 1
    return FALSE;
d1230 1
a1230 1
	  return FALSE;
d1236 1
a1236 1
  return TRUE;
d1361 1
a1361 1
static bfd_boolean
d1375 1
a1375 1
    return TRUE;
d1384 1
a1384 1
	return FALSE;
d1388 1
a1388 1
  abfd->output_has_begun = TRUE;
d1559 1
a1559 1
  return TRUE;
d1567 1
a1567 1
bfd_boolean
d1577 1
a1577 1
    return FALSE;
d1580 1
a1580 1
    return TRUE;
d1588 2
a1589 2
      bfd_boolean (*mangle_relocs_func)
	PARAMS ((bfd *, asection *, PTR, bfd_vma, bfd_size_type));
d1596 1
a1596 1
	    return FALSE;
d1602 1
a1602 1
    return FALSE;
d1604 1
a1604 1
  return TRUE;
d1658 1
a1658 1
bfd_boolean
d1663 1
a1663 1
  bfd_boolean (*write_import_func) PARAMS ((bfd *, asection *, arelent *));
d1668 1
a1668 1
  bfd_boolean (*write_prefix_func) PARAMS ((bfd *));
d1834 1
a1834 1
      bfd_boolean (*write_export_func) PARAMS ((bfd *, asymbol *, bfd_vma));
d2037 1
a2037 1
  return TRUE;
d2042 1
a2042 1
  return FALSE;
@


1.8.10.2
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002, 2003
d45 1
a45 1
#define nlm_canonicalize_symtab		nlmNAME(canonicalize_symtab)
d921 1
a921 1
nlm_canonicalize_symtab (abfd, alocation)
d1571 1
a1571 1
     const PTR location;
d1589 1
a1589 1
	PARAMS ((bfd *, asection *, const PTR, bfd_vma, bfd_size_type));
@


1.7
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d8 1
a8 1
This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d60 1
a60 1
/* Forward declarations of static functions */
a116 1

a131 1

a145 1

d155 1
a155 2
     XVEC.  (Hack alert!) */

a160 1

a174 1

d236 2
a237 3
    {
      return false;
    }
d243 1
a323 1

a333 1

a340 1

a347 1

a353 1

a363 1

d654 1
a654 3
	{
	  break;
	}
d708 25
a831 22
  /* Write out the copyright header if there is one.  */
  if (find_nonzero ((PTR) nlm_copyright_header (abfd),
		    sizeof (Nlm_Internal_Copyright_Header)))
    {
      Nlm_External_Copyright_Header thdr;

      memcpy (thdr.stamp, "CoPyRiGhT=", 10);
      amt = sizeof (thdr.stamp);
      if (bfd_bwrite ((PTR) thdr.stamp, amt, abfd) != amt)
	return false;
      thdr.copyrightMessageLength[0] =
	nlm_copyright_header (abfd)->copyrightMessageLength;
      amt = 1;
      if (bfd_bwrite ((PTR) thdr.copyrightMessageLength, amt, abfd) != amt)
	return false;
      /* The copyright message is a variable length string.  */
      amt = nlm_copyright_header (abfd)->copyrightMessageLength + 1;
      if (bfd_bwrite ((PTR) nlm_copyright_header (abfd)->copyrightMessage,
		     amt, abfd) != amt)
	return false;
    }

d905 1
a905 1
  Nlm_Internal_Fixed_Header *i_fxdhdrp;	/* Nlm file header, internal form */
d1010 1
a1010 2
   number of symbols.
*/
d1016 7
a1022 7
  Nlm_Internal_Fixed_Header *i_fxdhdrp;	/* Nlm file header, internal form */
  bfd_size_type totsymcount;	/* Number of NLM symbols */
  bfd_size_type symcount;	/* Counter of NLM symbols */
  nlm_symbol_type *sym;		/* Pointer to current bfd symbol */
  unsigned char symlength;	/* Symbol length read into here */
  unsigned char symtype;	/* Type of debugging symbol */
  bfd_byte temp[NLM_TARGET_LONG_SIZE];	/* Symbol offsets read into here */
d1044 1
a1044 3
    {
      return true;
    }
a1159 1

@


1.7.2.1
log
@Swapped the order of the MeSsAgEs and CoPyRiGhT tags to make >=NW4.x NLM
loaders to show the Copyright string.
@
text
@a721 25
  /* Note - the CoPyRiGhT tag is emitted before the MeSsAgEs
     tag in order to make the NW4.x and NW5.x loaders happy.  */

  /* Write out the copyright header if there is one.  */
  if (find_nonzero ((PTR) nlm_copyright_header (abfd),
		    sizeof (Nlm_Internal_Copyright_Header)))
    {
      Nlm_External_Copyright_Header thdr;

      memcpy (thdr.stamp, "CoPyRiGhT=", 10);
      amt = sizeof (thdr.stamp);
      if (bfd_bwrite ((PTR) thdr.stamp, amt, abfd) != amt)
	return false;
      thdr.copyrightMessageLength[0] =
	nlm_copyright_header (abfd)->copyrightMessageLength;
      amt = 1;
      if (bfd_bwrite ((PTR) thdr.copyrightMessageLength, amt, abfd) != amt)
	return false;
      /* The copyright message is a variable length string.  */
      amt = nlm_copyright_header (abfd)->copyrightMessageLength + 1;
      if (bfd_bwrite ((PTR) nlm_copyright_header (abfd)->copyrightMessage,
		     amt, abfd) != amt)
	return false;
    }

d818 22
@


1.6
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001
d939 1
a939 1
  if (nlm_slurp_symbol_table (abfd) == false)
d1098 1
a1098 1
	  if ((*set_public_section_func) (abfd, sym) == false)
d1184 1
a1184 1
	  if ((*read_import_func) (abfd, sym) == false)
d1241 1
a1241 1
      if ((*read_func) (abfd, (nlm_symbol_type *) NULL, secs, rels) == false)
d1277 1
a1277 1
      if (nlm_slurp_symbol_table (abfd) == false)
d1312 1
a1312 1
      if (nlm_slurp_reloc_fixups (abfd) == false)
d1389 1
a1389 1
  if (abfd->output_has_begun == true)
d1590 2
a1591 2
  if (abfd->output_has_begun == false
      && nlm_compute_section_file_positions (abfd) == false)
d1693 2
a1694 2
  if (abfd->output_has_begun == false
      && nlm_compute_section_file_positions (abfd) == false)
d1701 2
a1702 2
  if (nlm_swap_variable_header_out (abfd) == false
      || nlm_swap_auxiliary_headers_out (abfd) == false)
d1763 1
a1763 1
	      if ((*write_import_func) (abfd, sec, rel) == false)
d1835 2
a1836 3
      if ((*nlm_write_external_func (abfd)) (abfd, cnt, sym,
					     &external_relocs[i])
	  == false)
d1904 1
a1904 1
	      if ((*write_export_func) (abfd, sym, offset) == false)
d2038 1
a2038 1
      if ((*write_prefix_func) (abfd) == false)
@


1.6.10.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000, 2001, 2002
d939 1
a939 1
  if (! nlm_slurp_symbol_table (abfd))
d1098 1
a1098 1
	  if (! (*set_public_section_func) (abfd, sym))
d1184 1
a1184 1
	  if (! (*read_import_func) (abfd, sym))
d1241 1
a1241 1
      if (! (*read_func) (abfd, (nlm_symbol_type *) NULL, secs, rels))
d1277 1
a1277 1
      if (! nlm_slurp_symbol_table (abfd))
d1312 1
a1312 1
      if (! nlm_slurp_reloc_fixups (abfd))
d1389 1
a1389 1
  if (abfd->output_has_begun)
d1590 2
a1591 2
  if (! abfd->output_has_begun
      && ! nlm_compute_section_file_positions (abfd))
d1693 2
a1694 2
  if (! abfd->output_has_begun
      && ! nlm_compute_section_file_positions (abfd))
d1701 2
a1702 2
  if (! nlm_swap_variable_header_out (abfd)
      || ! nlm_swap_auxiliary_headers_out (abfd))
d1763 1
a1763 1
	      if (! (*write_import_func) (abfd, sec, rel))
d1835 3
a1837 2
      if (! (*nlm_write_external_func (abfd)) (abfd, cnt, sym,
					       &external_relocs[i]))
d1905 1
a1905 1
	      if (! (*write_export_func) (abfd, sym, offset))
d2039 1
a2039 1
      if (! (*write_prefix_func) (abfd))
@


1.6.10.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d8 1
a8 1
   This file is part of BFD, the Binary File Descriptor library.
d10 13
a22 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d60 1
a60 1
/* Forward declarations of static functions.  */
d117 1
d133 1
d148 1
d158 2
a159 1
     XVEC.  (Hack alert!)  */
d165 1
d180 1
d242 3
a244 2
    return false;

a249 1

d330 1
d341 1
d349 1
d357 1
d364 1
d375 1
d666 3
a668 1
	break;
a721 25
  /* Note - the CoPyRiGhT tag is emitted before the MeSsAgEs
     tag in order to make the NW4.x and NW5.x loaders happy.  */

  /* Write out the copyright header if there is one.  */
  if (find_nonzero ((PTR) nlm_copyright_header (abfd),
		    sizeof (Nlm_Internal_Copyright_Header)))
    {
      Nlm_External_Copyright_Header thdr;

      memcpy (thdr.stamp, "CoPyRiGhT=", 10);
      amt = sizeof (thdr.stamp);
      if (bfd_bwrite ((PTR) thdr.stamp, amt, abfd) != amt)
	return false;
      thdr.copyrightMessageLength[0] =
	nlm_copyright_header (abfd)->copyrightMessageLength;
      amt = 1;
      if (bfd_bwrite ((PTR) thdr.copyrightMessageLength, amt, abfd) != amt)
	return false;
      /* The copyright message is a variable length string.  */
      amt = nlm_copyright_header (abfd)->copyrightMessageLength + 1;
      if (bfd_bwrite ((PTR) nlm_copyright_header (abfd)->copyrightMessage,
		     amt, abfd) != amt)
	return false;
    }

d821 22
d916 1
a916 1
  Nlm_Internal_Fixed_Header *i_fxdhdrp;	/* Nlm file header, internal form.  */
d1021 2
a1022 1
   number of symbols.  */
d1028 7
a1034 7
  Nlm_Internal_Fixed_Header *i_fxdhdrp;	/* Nlm file header, internal form.  */
  bfd_size_type totsymcount;	/* Number of NLM symbols.  */
  bfd_size_type symcount;	/* Counter of NLM symbols.  */
  nlm_symbol_type *sym;		/* Pointer to current bfd symbol.  */
  unsigned char symlength;	/* Symbol length read into here.  */
  unsigned char symtype;	/* Type of debugging symbol.  */
  bfd_byte temp[NLM_TARGET_LONG_SIZE];	/* Symbol offsets read into here.  */
d1056 3
a1058 1
    return true;
d1174 1
@


1.5
log
@2001-08-23  H.J. Lu  <hjl@@gnu.org>

	* syms.c (bfd_print_symbol_vandf): Add abfd to arg.
	* bfd-in2.h (bfd_print_symbol_vandf): Regenerated.

	* aoutx.h (NAME(aout,print_symbol)): Pass abfd to
	bfd_print_symbol_vandf.
	* coffgen.c (coff_print_symbol): Likewise.
	* elf.c (bfd_elf_print_symbol): Likewise.
	* ieee.c (ieee_print_symbol): Likewise.
	* nlmcode.h (nlm_print_symbol): Likewise.
	* oasys.c (oasys_print_symbol): Likewise.
	* pdp11.c (NAME(aout,print_symbol)): Likewise.
	* som.c (som_print_symbol): Likewise.
	* srec.c (srec_print_symbol): Likewise.
	* tekhex.c (tekhex_print_symbol): Likewise.
	* versados.c (versados_print_symbol): Likewise.
	* vms.c (vms_print_symbol): Likewise.

	* elf.c (_bfd_elf_print_private_bfd_data): Replace fprintf_vma
	with bfd_fprintf_vma.
	(bfd_elf_print_symbol): Likewise.
	* syms.c (bfd_print_symbol_vandf): Likewise.
@
text
@d2 2
a3 1
   Copyright 1993, 1994, 1995, 1998, 2000 Free Software Foundation, Inc.
d86 2
a87 2
#define put_word	bfd_h_put_64
#define get_word	bfd_h_get_64
d90 2
a91 2
#define put_word	bfd_h_put_32
#define get_word	bfd_h_get_32
d105 1
d118 2
a119 1
  x_fxdhdr = (PTR) bfd_malloc ((size_t) nlm_fixed_header_size (abfd));
d123 1
a123 2
  if (bfd_read ((PTR) x_fxdhdr, nlm_fixed_header_size (abfd), 1, abfd) !=
      nlm_fixed_header_size (abfd))
d134 2
a135 2
  new_tdata = ((struct nlm_obj_tdata *)
	       bfd_zalloc (abfd, sizeof (struct nlm_obj_tdata)));
d243 1
a243 1
      return (false);
d249 2
a250 2
  newsect->alignment_power = bfd_log2 (0);	/* FIXME */
  return (true);
d261 1
d265 8
a272 10
  if (bfd_read ((PTR) & nlm_variable_header (abfd)->descriptionLength,
		sizeof (nlm_variable_header (abfd)->descriptionLength),
		1, abfd) !=
      sizeof (nlm_variable_header (abfd)->descriptionLength))
    return (false);
  if (bfd_read ((PTR) nlm_variable_header (abfd)->descriptionText,
		nlm_variable_header (abfd)->descriptionLength + 1,
		1, abfd) !=
      (bfd_size_type) nlm_variable_header (abfd)->descriptionLength + 1)
    return (false);
d276 3
a278 2
  if (bfd_read ((PTR) temp, sizeof (temp), 1, abfd) != sizeof (temp))
    return (false);
d283 3
a285 2
  if (bfd_read ((PTR) temp, sizeof (temp), 1, abfd) != sizeof (temp))
    return (false);
d290 4
a293 5
  if (bfd_read ((PTR) nlm_variable_header (abfd)->oldThreadName,
		sizeof (nlm_variable_header (abfd)->oldThreadName),
		1, abfd) !=
      sizeof (nlm_variable_header (abfd)->oldThreadName))
    return (false);
d297 8
a304 10
  if (bfd_read ((PTR) & nlm_variable_header (abfd)->screenNameLength,
		sizeof (nlm_variable_header (abfd)->screenNameLength),
		1, abfd) !=
      sizeof (nlm_variable_header (abfd)->screenNameLength))
    return (false);
  if (bfd_read ((PTR) nlm_variable_header (abfd)->screenName,
		nlm_variable_header (abfd)->screenNameLength + 1,
		1, abfd) !=
      (bfd_size_type) nlm_variable_header (abfd)->screenNameLength + 1)
    return (false);
d308 9
a316 11
  if (bfd_read ((PTR) & nlm_variable_header (abfd)->threadNameLength,
		sizeof (nlm_variable_header (abfd)->threadNameLength),
		1, abfd) !=
      sizeof (nlm_variable_header (abfd)->threadNameLength))
    return (false);
  if (bfd_read ((PTR) nlm_variable_header (abfd)->threadName,
		nlm_variable_header (abfd)->threadNameLength + 1,
		1, abfd) !=
      (bfd_size_type) nlm_variable_header (abfd)->threadNameLength + 1)
    return (false);
  return (true);
d327 1
d331 8
a338 10
  if (bfd_write ((PTR) & nlm_variable_header (abfd)->descriptionLength,
		 sizeof (nlm_variable_header (abfd)->descriptionLength),
		 1, abfd) !=
      sizeof (nlm_variable_header (abfd)->descriptionLength))
    return (false);
  if (bfd_write ((PTR) nlm_variable_header (abfd)->descriptionText,
		 nlm_variable_header (abfd)->descriptionLength + 1,
		 1, abfd) !=
      (bfd_size_type) nlm_variable_header (abfd)->descriptionLength + 1)
    return (false);
d344 3
a346 2
  if (bfd_write ((PTR) temp, sizeof (temp), 1, abfd) != sizeof (temp))
    return (false);
d352 3
a354 2
  if (bfd_write ((PTR) temp, sizeof (temp), 1, abfd) != sizeof (temp))
    return (false);
d358 4
a361 5
  if (bfd_write ((PTR) nlm_variable_header (abfd)->oldThreadName,
		 sizeof (nlm_variable_header (abfd)->oldThreadName),
		 1, abfd) !=
      sizeof (nlm_variable_header (abfd)->oldThreadName))
    return (false);
d365 8
a372 10
  if (bfd_write ((PTR) & nlm_variable_header (abfd)->screenNameLength,
		 sizeof (nlm_variable_header (abfd)->screenNameLength),
		 1, abfd) !=
      sizeof (nlm_variable_header (abfd)->screenNameLength))
    return (false);
  if (bfd_write ((PTR) nlm_variable_header (abfd)->screenName,
		 nlm_variable_header (abfd)->screenNameLength + 1,
		 1, abfd) !=
      (bfd_size_type) nlm_variable_header (abfd)->screenNameLength + 1)
    return (false);
d376 9
a384 11
  if (bfd_write ((PTR) & nlm_variable_header (abfd)->threadNameLength,
		 sizeof (nlm_variable_header (abfd)->threadNameLength),
		 1, abfd) !=
      sizeof (nlm_variable_header (abfd)->threadNameLength))
    return (false);
  if (bfd_write ((PTR) nlm_variable_header (abfd)->threadName,
		 nlm_variable_header (abfd)->threadNameLength + 1,
		 1, abfd) !=
      (bfd_size_type) nlm_variable_header (abfd)->threadNameLength + 1)
    return (false);
  return (true);
d401 2
a402 1
  long position;
d407 5
a411 5
      if (bfd_read ((PTR) tempstr, sizeof (tempstr), 1, abfd) !=
	  sizeof (tempstr))
	return (false);
      if (bfd_seek (abfd, position, SEEK_SET) == -1)
	return (false);
d415 4
a418 2
	  if (bfd_read ((PTR) & thdr, sizeof (thdr), 1, abfd) != sizeof (thdr))
	    return (false);
d437 4
a440 2
	  if (bfd_read ((PTR) & thdr, sizeof (thdr), 1, abfd) != sizeof (thdr))
	    return (false);
d504 8
a511 9
	  if (bfd_read ((PTR) nlm_copyright_header (abfd)->stamp,
			sizeof (nlm_copyright_header (abfd)->stamp),
			1, abfd)
	      != sizeof (nlm_copyright_header (abfd)->stamp))
	    return (false);
	  if (bfd_read ((PTR) & (nlm_copyright_header (abfd)
				 ->copyrightMessageLength),
			1, 1, abfd) != 1)
	    return (false);
d513 4
a516 6
	  if (bfd_read ((PTR) nlm_copyright_header (abfd)->copyrightMessage,
		    nlm_copyright_header (abfd)->copyrightMessageLength + 1,
			1, abfd) !=
	      ((bfd_size_type)
	       nlm_copyright_header (abfd)->copyrightMessageLength + 1))
	    return (false);
d528 2
a529 2
	  if (bfd_read ((PTR) thdr.stamp, 1, sizeof (thdr.stamp), abfd)
	      != sizeof (thdr.stamp))
d532 2
a533 2
	  if (bfd_read ((PTR) thdr.length, 1, sizeof (thdr.length), abfd)
	      != sizeof (thdr.length))
d541 2
a542 3
	      if (bfd_read ((PTR) thdr.dataOffset, 1,
			    sizeof (thdr.dataOffset), abfd)
		  != sizeof (thdr.dataOffset))
d550 2
a551 3
	      if (bfd_read ((PTR) thdr.dataLength, 1,
			    sizeof (thdr.dataLength), abfd)
		  != sizeof (thdr.dataLength))
d559 2
a560 2
	      if (bfd_read ((PTR) dataStamp, 1, sizeof (dataStamp), abfd)
		  != sizeof (dataStamp))
d576 1
a576 1
	      if (bfd_read (hdr, 1, hdrLength, abfd) != hdrLength)
d597 1
a597 1
	      if (bfd_read (contents, 1, dataLength, abfd) != dataLength)
d635 1
a635 1
		  l = (l + 3) &~ 3;
d637 1
a637 1
		  filepos = bfd_h_get_32 (abfd, p);
d639 1
a639 1
		  size = bfd_h_get_32 (abfd, p);
d670 1
a670 1
  return (true);
d696 2
d717 2
a718 1
      if (bfd_write ((PTR) & thdr, sizeof (thdr), 1, abfd) != sizeof (thdr))
d816 2
a817 1
      if (bfd_write ((PTR) & thdr, sizeof (thdr), 1, abfd) != sizeof (thdr))
d828 2
a829 2
      if (bfd_write ((PTR) thdr.stamp, sizeof (thdr.stamp), 1, abfd)
	  != sizeof (thdr.stamp))
d833 2
a834 1
      if (bfd_write ((PTR) thdr.copyrightMessageLength, 1, 1, abfd) != 1)
d837 3
a839 5
      if (bfd_write ((PTR) nlm_copyright_header (abfd)->copyrightMessage,
		     nlm_copyright_header (abfd)->copyrightMessageLength + 1,
		     1, abfd) !=
	  ((bfd_size_type)
	   nlm_copyright_header (abfd)->copyrightMessageLength + 1))
d864 2
a865 3
	  if (bfd_write ((PTR) &thdr, 1,
			 sizeof (thdr) - sizeof (thdr.dataStamp), abfd)
	      != sizeof (thdr) - sizeof (thdr.dataStamp))
d872 2
a873 1
	  if (bfd_write ((PTR) &thdr, sizeof (thdr), 1, abfd) != sizeof (thdr))
d875 2
a876 3
	  if (bfd_write (nlm_custom_header (abfd)->hdr, 1,
			 nlm_custom_header (abfd)->hdrLength, abfd)
	      != nlm_custom_header (abfd)->hdrLength)
d895 2
a896 1
      if (bfd_write ((PTR) &thdr, sizeof (thdr), 1, abfd) != sizeof (thdr))
d958 2
a959 1
  nlm_symbol_type *new;
a960 1
  new = (nlm_symbol_type *) bfd_zalloc (abfd, sizeof (nlm_symbol_type));
d1037 1
d1040 1
a1040 1
    return (true);
d1057 1
a1057 1
      return (true);
d1060 2
a1061 2
  if (bfd_seek (abfd, i_fxdhdrp->publicsOffset, SEEK_SET) == -1)
    return (false);
d1063 2
a1064 2
  sym = ((nlm_symbol_type *)
	 bfd_zalloc (abfd, totsymcount * sizeof (nlm_symbol_type)));
d1077 4
a1080 3
      if (bfd_read ((PTR) & symlength, sizeof (symlength), 1, abfd)
	  != sizeof (symlength))
	return (false);
d1082 1
a1082 1
      sym->symbol.name = bfd_alloc (abfd, symlength + 1);
d1085 2
a1086 3
      if (bfd_read ((PTR) sym->symbol.name, symlength, 1, abfd)
	  != symlength)
	return (false);
d1089 3
a1091 2
      if (bfd_read ((PTR) temp, sizeof (temp), 1, abfd) != sizeof (temp))
	return (false);
d1125 2
a1126 2
      if (bfd_seek (abfd, i_fxdhdrp->debugInfoOffset, SEEK_SET) == -1)
	return (false);
d1131 8
a1138 5
	  if ((bfd_read ((PTR) & symtype, sizeof (symtype), 1, abfd)
	       != sizeof (symtype))
	   || bfd_read ((PTR) temp, sizeof (temp), 1, abfd) != sizeof (temp)
	      || (bfd_read ((PTR) & symlength, sizeof (symlength), 1, abfd)
		  != sizeof (symlength)))
d1140 1
d1142 1
a1142 1
	  sym->symbol.name = bfd_alloc (abfd, symlength + 1);
d1145 2
a1146 3
	  if (bfd_read ((PTR) sym->symbol.name, symlength, 1, abfd)
	      != symlength)
	    return (false);
d1178 2
a1179 3
      if (bfd_seek (abfd, i_fxdhdrp->externalReferencesOffset, SEEK_SET)
	  == -1)
	return (false);
d1191 1
a1191 1
  return (true);
d1213 1
a1213 1
  bfd_size_type count;
d1228 4
a1231 2
  rels = (arelent *) bfd_alloc (abfd, count * sizeof (arelent));
  secs = (asection **) bfd_alloc (abfd, count * sizeof (asection *));
d1615 2
a1616 2
  if (bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) != 0
      || bfd_write (location, 1, count, abfd) != count)
d1685 2
d1689 1
a1689 1
		  bfd_malloc ((size_t) nlm_fixed_header_size (abfd)));
d1698 2
a1699 3
  if (bfd_seek (abfd,
	     nlm_optional_prefix_size (abfd) + nlm_fixed_header_size (abfd),
		SEEK_SET) != 0)
d1710 1
a1710 1
  if (bfd_tell (abfd) > nlm_fixed_header (abfd)->codeImageOffset)
d1776 2
a1777 4
  external_relocs =
    (struct reloc_and_sec *) bfd_alloc (abfd,
					(external_reloc_count
					 * sizeof (struct reloc_and_sec)));
d1911 1
a1911 1
	      if ((bfd_write (&len, sizeof (bfd_byte), 1, abfd)
d1913 1
a1913 1
		  || bfd_write (sym->name, len, 1, abfd) != len)
d1917 2
a1918 1
	      if (bfd_write (temp, sizeof (temp), 1, abfd) != sizeof (temp))
d1977 1
a1977 1
	      if (bfd_write (&type, sizeof (bfd_byte), 1, abfd)
d1982 2
a1983 1
	      if (bfd_write (temp, sizeof (temp), 1, abfd) != sizeof (temp))
d1987 1
a1987 1
	      if ((bfd_write (&len, sizeof (bfd_byte), 1, abfd)
d1989 1
a1989 1
		  || bfd_write (sym->name, len, 1, abfd) != len)
d2033 1
a2033 1
  if (bfd_seek (abfd, 0, SEEK_SET) != 0)
d2047 1
a2047 1
  if (bfd_write (fixed_header, nlm_fixed_header_size (abfd), 1, abfd)
@


1.4
log
@Update copyright notices
@
text
@d984 1
a984 1
     bfd *abfd ATTRIBUTE_UNUSED;
d999 1
a999 1
      bfd_print_symbol_vandf ((PTR) file, symbol);
@


1.3
log
@2000-12-12  Kazu Hirata  <kazu@@hxi.com>

	* m68klinux.c: Fix formatting.
	* m68knetbsd.c: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* netbsd.h: Likewise.
	* newsos3.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* nlmswap.h: Likewise.
	* nlm-target.h: Likewise.
	* ns32knetbsd.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 98, 1999 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1998, 2000 Free Software Foundation, Inc.
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d55 1
a55 1
  (nlm_swap_fixed_header_in_func(abfd))(abfd,src,dst)
d57 1
a57 1
  (nlm_swap_fixed_header_out_func(abfd))(abfd,src,dst)
d145 1
a145 1
     the NLM signature. */
d226 1
a226 1
/* Add a section to the bfd. */
d243 1
a243 1
  newsect->vma = 0;		/* NLM's are relocatable. */
d252 1
a252 1
   exist in the NLM, and must exist in the order they are read here. */
d260 1
a260 1
  /* Read the description length and text members. */
d273 1
a273 1
  /* Read and convert the stackSize field. */
d279 1
a279 1
  /* Read and convert the reserved field. */
d285 1
a285 1
  /* Read the oldThreadName field.  This field is a fixed length string. */
d293 1
a293 1
  /* Read the screen name length and text members. */
d306 1
a306 1
  /* Read the thread name length and text members. */
d330 1
a330 1
  /* Write the description length and text members. */
d343 1
a343 1
  /* Convert and write the stackSize field. */
d350 1
a350 1
  /* Convert and write the reserved field. */
d357 1
a357 1
  /* Write the oldThreadName field.  This field is a fixed length string. */
d365 1
a365 1
  /* Write the screen name length and text members. */
d378 1
a378 1
  /* Write the thread name length and text members. */
d400 1
a400 1
   recognize it. */
d514 1
a514 1
	  /* The copyright message is a variable length string. */
a822 1

d837 1
a837 1
      /* The copyright message is a variable length string. */
d913 1
a913 1
   on this size. */
d932 1
a932 1
   symbol table fails. */
d1050 1
a1050 1
     When we have all the symbols, we build the caller's pointer vector. */
d1073 1
a1073 1
     were read. */
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 1998 Free Software Foundation, Inc.
d974 1
a974 1
     bfd *ignore_abfd;
d985 1
a985 1
     bfd *abfd;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

