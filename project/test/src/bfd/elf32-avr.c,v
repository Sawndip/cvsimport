head	1.62;
access;
symbols
	sid-snapshot-20180601:1.62
	sid-snapshot-20180501:1.62
	sid-snapshot-20180401:1.62
	sid-snapshot-20180301:1.62
	sid-snapshot-20180201:1.62
	sid-snapshot-20180101:1.62
	sid-snapshot-20171201:1.62
	sid-snapshot-20171101:1.62
	sid-snapshot-20171001:1.62
	sid-snapshot-20170901:1.62
	sid-snapshot-20170801:1.62
	sid-snapshot-20170701:1.62
	sid-snapshot-20170601:1.62
	sid-snapshot-20170501:1.62
	sid-snapshot-20170401:1.62
	sid-snapshot-20170301:1.62
	sid-snapshot-20170201:1.62
	sid-snapshot-20170101:1.62
	sid-snapshot-20161201:1.62
	sid-snapshot-20161101:1.62
	sid-snapshot-20160901:1.62
	sid-snapshot-20160801:1.62
	sid-snapshot-20160701:1.62
	sid-snapshot-20160601:1.62
	sid-snapshot-20160501:1.62
	sid-snapshot-20160401:1.62
	sid-snapshot-20160301:1.62
	sid-snapshot-20160201:1.62
	sid-snapshot-20160101:1.62
	sid-snapshot-20151201:1.62
	sid-snapshot-20151101:1.62
	sid-snapshot-20151001:1.62
	sid-snapshot-20150901:1.62
	sid-snapshot-20150801:1.62
	sid-snapshot-20150701:1.62
	sid-snapshot-20150601:1.62
	sid-snapshot-20150501:1.62
	sid-snapshot-20150401:1.62
	sid-snapshot-20150301:1.62
	sid-snapshot-20150201:1.62
	sid-snapshot-20150101:1.62
	sid-snapshot-20141201:1.62
	sid-snapshot-20141101:1.62
	sid-snapshot-20141001:1.62
	sid-snapshot-20140901:1.62
	sid-snapshot-20140801:1.62
	sid-snapshot-20140701:1.62
	sid-snapshot-20140601:1.62
	sid-snapshot-20140501:1.62
	sid-snapshot-20140401:1.62
	sid-snapshot-20140301:1.62
	sid-snapshot-20140201:1.62
	sid-snapshot-20140101:1.62
	sid-snapshot-20131201:1.62
	sid-snapshot-20131101:1.62
	sid-snapshot-20131001:1.62
	binutils-2_24-branch:1.62.0.2
	binutils-2_24-branchpoint:1.62
	binutils-2_21_1:1.48
	sid-snapshot-20130901:1.62
	gdb_7_6_1-2013-08-30-release:1.61
	sid-snapshot-20130801:1.62
	sid-snapshot-20130701:1.62
	sid-snapshot-20130601:1.62
	sid-snapshot-20130501:1.62
	gdb_7_6-2013-04-26-release:1.61
	sid-snapshot-20130401:1.61
	binutils-2_23_2:1.58
	gdb_7_6-branch:1.61.0.2
	gdb_7_6-2013-03-12-branchpoint:1.61
	sid-snapshot-20130301:1.61
	sid-snapshot-20130201:1.59
	sid-snapshot-20130101:1.58
	sid-snapshot-20121201:1.58
	gdb_7_5_1-2012-11-29-release:1.57
	binutils-2_23_1:1.58
	sid-snapshot-20121101:1.58
	binutils-2_23:1.58
	sid-snapshot-20121001:1.58
	sid-snapshot-20120901:1.58
	gdb_7_5-2012-08-17-release:1.57
	sid-snapshot-20120801:1.58
	binutils-2_23-branch:1.58.0.2
	binutils-2_23-branchpoint:1.58
	gdb_7_5-branch:1.57.0.2
	gdb_7_5-2012-07-18-branchpoint:1.57
	sid-snapshot-20120701:1.57
	sid-snapshot-20120601:1.57
	sid-snapshot-20120501:1.54
	binutils-2_22_branch:1.51.0.6
	gdb_7_4_1-2012-04-26-release:1.51
	sid-snapshot-20120401:1.53
	sid-snapshot-20120301:1.53
	sid-snapshot-20120201:1.52
	gdb_7_4-2012-01-24-release:1.51
	sid-snapshot-20120101:1.51
	gdb_7_4-branch:1.51.0.4
	gdb_7_4-2011-12-13-branchpoint:1.51
	sid-snapshot-20111201:1.51
	binutils-2_22:1.51
	sid-snapshot-20111101:1.51
	sid-snapshot-20111001:1.51
	binutils-2_22-branch:1.51.0.2
	binutils-2_22-branchpoint:1.51
	gdb_7_3_1-2011-09-04-release:1.50
	sid-snapshot-20110901:1.51
	sid-snapshot-20110801:1.51
	gdb_7_3-2011-07-26-release:1.50
	sid-snapshot-20110701:1.51
	sid-snapshot-20110601:1.50
	sid-snapshot-20110501:1.50
	gdb_7_3-branch:1.50.0.2
	gdb_7_3-2011-04-01-branchpoint:1.50
	sid-snapshot-20110401:1.50
	sid-snapshot-20110301:1.49
	sid-snapshot-20110201:1.49
	sid-snapshot-20110101:1.49
	binutils-2_21:1.48
	sid-snapshot-20101201:1.49
	binutils-2_21-branch:1.48.0.2
	binutils-2_21-branchpoint:1.48
	sid-snapshot-20101101:1.48
	sid-snapshot-20101001:1.47
	binutils-2_20_1:1.42
	gdb_7_2-2010-09-02-release:1.46
	sid-snapshot-20100901:1.47
	sid-snapshot-20100801:1.46
	gdb_7_2-branch:1.46.0.2
	gdb_7_2-2010-07-07-branchpoint:1.46
	sid-snapshot-20100701:1.46
	sid-snapshot-20100601:1.45
	sid-snapshot-20100501:1.45
	sid-snapshot-20100401:1.45
	gdb_7_1-2010-03-18-release:1.44
	sid-snapshot-20100301:1.45
	gdb_7_1-branch:1.44.0.2
	gdb_7_1-2010-02-18-branchpoint:1.44
	sid-snapshot-20100201:1.43
	sid-snapshot-20100101:1.43
	gdb_7_0_1-2009-12-22-release:1.42
	sid-snapshot-20091201:1.42
	sid-snapshot-20091101:1.42
	binutils-2_20:1.42
	gdb_7_0-2009-10-06-release:1.42
	sid-snapshot-20091001:1.42
	gdb_7_0-branch:1.42.0.4
	gdb_7_0-2009-09-16-branchpoint:1.42
	arc-sim-20090309:1.33
	binutils-arc-20081103-branch:1.37.0.8
	binutils-arc-20081103-branchpoint:1.37
	binutils-2_20-branch:1.42.0.2
	binutils-2_20-branchpoint:1.42
	sid-snapshot-20090901:1.41
	sid-snapshot-20090801:1.41
	msnyder-checkpoint-072509-branch:1.41.0.4
	msnyder-checkpoint-072509-branchpoint:1.41
	sid-snapshot-20090701:1.41
	dje-cgen-play1-branch:1.41.0.2
	dje-cgen-play1-branchpoint:1.41
	sid-snapshot-20090601:1.41
	sid-snapshot-20090501:1.40
	sid-snapshot-20090401:1.40
	arc-20081103-branch:1.37.0.6
	arc-20081103-branchpoint:1.37
	arc-insight_6_8-branch:1.33.0.6
	arc-insight_6_8-branchpoint:1.33
	insight_6_8-branch:1.33.0.4
	insight_6_8-branchpoint:1.33
	sid-snapshot-20090301:1.40
	binutils-2_19_1:1.37.2.1
	sid-snapshot-20090201:1.38
	sid-snapshot-20090101:1.38
	reverse-20081226-branch:1.38.0.4
	reverse-20081226-branchpoint:1.38
	sid-snapshot-20081201:1.38
	multiprocess-20081120-branch:1.38.0.2
	multiprocess-20081120-branchpoint:1.38
	sid-snapshot-20081101:1.37
	binutils-2_19:1.37
	sid-snapshot-20081001:1.37
	reverse-20080930-branch:1.37.0.4
	reverse-20080930-branchpoint:1.37
	binutils-2_19-branch:1.37.0.2
	binutils-2_19-branchpoint:1.37
	sid-snapshot-20080901:1.37
	sid-snapshot-20080801:1.36
	reverse-20080717-branch:1.35.0.4
	reverse-20080717-branchpoint:1.35
	sid-snapshot-20080701:1.35
	msnyder-reverse-20080609-branch:1.35.0.2
	msnyder-reverse-20080609-branchpoint:1.35
	drow-reverse-20070409-branch:1.30.0.2
	drow-reverse-20070409-branchpoint:1.30
	sid-snapshot-20080601:1.34
	sid-snapshot-20080501:1.34
	sid-snapshot-20080403:1.34
	sid-snapshot-20080401:1.34
	gdb_6_8-2008-03-27-release:1.33
	sid-snapshot-20080301:1.33
	gdb_6_8-branch:1.33.0.2
	gdb_6_8-2008-02-26-branchpoint:1.33
	sid-snapshot-20080201:1.33
	sid-snapshot-20080101:1.33
	sid-snapshot-20071201:1.33
	sid-snapshot-20071101:1.33
	gdb_6_7_1-2007-10-29-release:1.32
	gdb_6_7-2007-10-10-release:1.32
	sid-snapshot-20071001:1.33
	gdb_6_7-branch:1.32.0.4
	gdb_6_7-2007-09-07-branchpoint:1.32
	binutils-2_18:1.32
	binutils-2_18-branch:1.32.0.2
	binutils-2_18-branchpoint:1.32
	insight_6_6-20070208-release:1.27
	binutils-csl-coldfire-4_1-32:1.24
	binutils-csl-sourcerygxx-4_1-32:1.24
	gdb_6_6-2006-12-18-release:1.27
	binutils-csl-innovasic-fido-3_4_4-33:1.24
	binutils-csl-sourcerygxx-3_4_4-32:1.19
	binutils-csl-coldfire-4_1-30:1.24
	binutils-csl-sourcerygxx-4_1-30:1.24
	binutils-csl-coldfire-4_1-28:1.24
	binutils-csl-sourcerygxx-4_1-29:1.24
	binutils-csl-sourcerygxx-4_1-28:1.24
	gdb_6_6-branch:1.27.0.2
	gdb_6_6-2006-11-15-branchpoint:1.27
	binutils-csl-arm-2006q3-27:1.24
	binutils-csl-sourcerygxx-4_1-27:1.24
	binutils-csl-arm-2006q3-26:1.24
	binutils-csl-sourcerygxx-4_1-26:1.24
	binutils-csl-sourcerygxx-4_1-25:1.24
	binutils-csl-sourcerygxx-4_1-24:1.24
	binutils-csl-sourcerygxx-4_1-23:1.24
	insight_6_5-20061003-release:1.25
	gdb-csl-symbian-6_4_50_20060226-12:1.22
	binutils-csl-sourcerygxx-4_1-21:1.24
	binutils-csl-arm-2006q3-21:1.24
	binutils-csl-sourcerygxx-4_1-22:1.24
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.24
	binutils-csl-sourcerygxx-4_1-20:1.24
	binutils-csl-arm-2006q3-19:1.24
	binutils-csl-sourcerygxx-4_1-19:1.24
	binutils-csl-sourcerygxx-4_1-18:1.24
	binutils-csl-renesas-4_1-9:1.24
	gdb-csl-sourcerygxx-3_4_4-25:1.22
	binutils-csl-sourcerygxx-3_4_4-25:1.19
	nickrob-async-20060828-mergepoint:1.26
	gdb-csl-symbian-6_4_50_20060226-11:1.22
	binutils-csl-renesas-4_1-8:1.24
	binutils-csl-renesas-4_1-7:1.24
	binutils-csl-renesas-4_1-6:1.24
	gdb-csl-sourcerygxx-4_1-17:1.22
	binutils-csl-sourcerygxx-4_1-17:1.24
	gdb-csl-20060226-branch-local-2:1.22
	gdb-csl-sourcerygxx-4_1-14:1.22
	binutils-csl-sourcerygxx-4_1-14:1.24
	binutils-csl-sourcerygxx-4_1-15:1.24
	gdb-csl-sourcerygxx-4_1-13:1.22
	binutils-csl-sourcerygxx-4_1-13:1.24
	binutils-2_17:1.24
	gdb-csl-sourcerygxx-4_1-12:1.22
	binutils-csl-sourcerygxx-4_1-12:1.24
	gdb-csl-sourcerygxx-3_4_4-21:1.22
	binutils-csl-sourcerygxx-3_4_4-21:1.24
	gdb_6_5-20060621-release:1.25
	binutils-csl-wrs-linux-3_4_4-24:1.19
	binutils-csl-wrs-linux-3_4_4-23:1.19
	gdb-csl-sourcerygxx-4_1-9:1.22
	binutils-csl-sourcerygxx-4_1-9:1.24
	gdb-csl-sourcerygxx-4_1-8:1.22
	binutils-csl-sourcerygxx-4_1-8:1.24
	gdb-csl-sourcerygxx-4_1-7:1.22
	binutils-csl-sourcerygxx-4_1-7:1.24
	gdb-csl-arm-2006q1-6:1.22
	binutils-csl-arm-2006q1-6:1.24
	gdb-csl-sourcerygxx-4_1-6:1.22
	binutils-csl-sourcerygxx-4_1-6:1.24
	binutils-csl-wrs-linux-3_4_4-22:1.19
	gdb-csl-symbian-6_4_50_20060226-10:1.22
	gdb-csl-symbian-6_4_50_20060226-9:1.22
	gdb-csl-symbian-6_4_50_20060226-8:1.22
	gdb-csl-coldfire-4_1-11:1.22
	binutils-csl-coldfire-4_1-11:1.24
	gdb-csl-sourcerygxx-3_4_4-19:1.22
	binutils-csl-sourcerygxx-3_4_4-19:1.24
	gdb-csl-coldfire-4_1-10:1.22
	gdb_6_5-branch:1.25.0.4
	gdb_6_5-2006-05-14-branchpoint:1.25
	binutils-csl-coldfire-4_1-10:1.24
	gdb-csl-sourcerygxx-4_1-5:1.22
	binutils-csl-sourcerygxx-4_1-5:1.24
	nickrob-async-20060513-branch:1.25.0.2
	nickrob-async-20060513-branchpoint:1.25
	gdb-csl-sourcerygxx-4_1-4:1.22
	binutils-csl-sourcerygxx-4_1-4:1.24
	msnyder-reverse-20060502-branch:1.24.0.12
	msnyder-reverse-20060502-branchpoint:1.24
	binutils-csl-wrs-linux-3_4_4-21:1.19
	gdb-csl-morpho-4_1-4:1.22
	binutils-csl-morpho-4_1-4:1.24
	gdb-csl-sourcerygxx-3_4_4-17:1.22
	binutils-csl-sourcerygxx-3_4_4-17:1.24
	binutils-csl-wrs-linux-3_4_4-20:1.19
	readline_5_1-import-branch:1.24.0.10
	readline_5_1-import-branchpoint:1.24
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.22
	binutils-2_17-branch:1.24.0.8
	binutils-2_17-branchpoint:1.24
	gdb-csl-symbian-20060226-branch:1.22.0.12
	gdb-csl-symbian-20060226-branchpoint:1.22
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.22
	msnyder-reverse-20060331-branch:1.24.0.6
	msnyder-reverse-20060331-branchpoint:1.24
	binutils-csl-2_17-branch:1.24.0.4
	binutils-csl-2_17-branchpoint:1.24
	gdb-csl-available-20060303-branch:1.24.0.2
	gdb-csl-available-20060303-branchpoint:1.24
	gdb-csl-20060226-branch:1.22.0.10
	gdb-csl-20060226-branchpoint:1.22
	gdb_6_4-20051202-release:1.22
	msnyder-fork-checkpoint-branch:1.22.0.8
	msnyder-fork-checkpoint-branchpoint:1.22
	gdb-csl-gxxpro-6_3-branch:1.22.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.22
	gdb_6_4-branch:1.22.0.4
	gdb_6_4-2005-11-01-branchpoint:1.22
	gdb-csl-arm-20051020-branch:1.22.0.2
	gdb-csl-arm-20051020-branchpoint:1.22
	binutils-csl-gxxpro-3_4-branch:1.19.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.19
	binutils-2_16_1:1.19
	msnyder-tracepoint-checkpoint-branch:1.21.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.21
	gdb-csl-arm-20050325-2005-q1b:1.19
	binutils-csl-arm-2005q1b:1.19
	binutils-2_16:1.19
	gdb-csl-arm-20050325-2005-q1a:1.19
	binutils-csl-arm-2005q1a:1.19
	csl-arm-20050325-branch:1.19.0.6
	csl-arm-20050325-branchpoint:1.19
	binutils-csl-arm-2005q1-branch:1.19.0.4
	binutils-csl-arm-2005q1-branchpoint:1.19
	binutils-2_16-branch:1.19.0.2
	binutils-2_16-branchpoint:1.19
	csl-arm-2004-q3d:1.18
	gdb_6_3-20041109-release:1.17
	gdb_6_3-branch:1.17.0.6
	gdb_6_3-20041019-branchpoint:1.17
	csl-arm-2004-q3:1.17
	drow_intercu-merge-20040921:1.17
	drow_intercu-merge-20040915:1.17
	jimb-gdb_6_2-e500-branch:1.17.0.8
	jimb-gdb_6_2-e500-branchpoint:1.17
	gdb_6_2-20040730-release:1.17
	gdb_6_2-branch:1.17.0.4
	gdb_6_2-2004-07-10-gmt-branchpoint:1.17
	gdb_6_1_1-20040616-release:1.15
	binutils-2_15:1.15.6.1
	binutils-2_15-branchpoint:1.15
	csl-arm-2004-q1a:1.17
	csl-arm-2004-q1:1.17
	gdb_6_1-2004-04-05-release:1.15
	drow_intercu-merge-20040402:1.17
	drow_intercu-merge-20040327:1.17
	ezannoni_pie-20040323-branch:1.17.0.2
	ezannoni_pie-20040323-branchpoint:1.17
	cagney_tramp-20040321-mergepoint:1.16
	cagney_tramp-20040309-branch:1.15.0.12
	cagney_tramp-20040309-branchpoint:1.15
	gdb_6_1-branch:1.15.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.15
	drow_intercu-20040221-branch:1.15.0.8
	drow_intercu-20040221-branchpoint:1.15
	binutils-2_15-branch:1.15.0.6
	cagney_bfdfile-20040213-branch:1.15.0.4
	cagney_bfdfile-20040213-branchpoint:1.15
	drow-cplus-merge-20040208:1.15
	carlton_dictionary-20040126-merge:1.15
	cagney_bigcore-20040122-branch:1.15.0.2
	cagney_bigcore-20040122-branchpoint:1.15
	drow-cplus-merge-20040113:1.15
	csl-arm-2003-q4:1.15
	drow-cplus-merge-20031224:1.15
	drow-cplus-merge-20031220:1.15
	carlton_dictionary-20031215-merge:1.15
	drow-cplus-merge-20031214:1.15
	carlton-dictionary-20031111-merge:1.15
	gdb_6_0-2003-10-04-release:1.13
	kettenis_sparc-20030918-branch:1.14.0.6
	kettenis_sparc-20030918-branchpoint:1.14
	carlton_dictionary-20030917-merge:1.14
	ezannoni_pie-20030916-branchpoint:1.14
	ezannoni_pie-20030916-branch:1.14.0.4
	cagney_x86i386-20030821-branch:1.14.0.2
	cagney_x86i386-20030821-branchpoint:1.14
	carlton_dictionary-20030805-merge:1.14
	carlton_dictionary-20030627-merge:1.14
	gdb_6_0-branch:1.13.0.36
	gdb_6_0-2003-06-23-branchpoint:1.13
	jimb-ppc64-linux-20030613-branch:1.13.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.13
	binutils-2_14:1.13
	cagney_convert-20030606-branch:1.13.0.32
	cagney_convert-20030606-branchpoint:1.13
	cagney_writestrings-20030508-branch:1.13.0.30
	cagney_writestrings-20030508-branchpoint:1.13
	jimb-ppc64-linux-20030528-branch:1.13.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.13
	carlton_dictionary-20030523-merge:1.13
	cagney_fileio-20030521-branch:1.13.0.26
	cagney_fileio-20030521-branchpoint:1.13
	kettenis_i386newframe-20030517-mergepoint:1.13
	jimb-ppc64-linux-20030509-branch:1.13.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.13
	kettenis_i386newframe-20030504-mergepoint:1.13
	carlton_dictionary-20030430-merge:1.13
	binutils-2_14-branch:1.13.0.22
	binutils-2_14-branchpoint:1.13
	kettenis_i386newframe-20030419-branch:1.13.0.20
	kettenis_i386newframe-20030419-branchpoint:1.13
	carlton_dictionary-20030416-merge:1.13
	cagney_frameaddr-20030409-mergepoint:1.13
	kettenis_i386newframe-20030406-branch:1.13.0.18
	kettenis_i386newframe-20030406-branchpoint:1.13
	cagney_frameaddr-20030403-branchpoint:1.13
	cagney_frameaddr-20030403-branch:1.13.0.16
	cagney_framebase-20030330-mergepoint:1.13
	cagney_framebase-20030326-branch:1.13.0.14
	cagney_framebase-20030326-branchpoint:1.13
	cagney_lazyid-20030317-branch:1.13.0.12
	cagney_lazyid-20030317-branchpoint:1.13
	kettenis-i386newframe-20030316-mergepoint:1.13
	offbyone-20030313-branch:1.13.0.10
	offbyone-20030313-branchpoint:1.13
	kettenis-i386newframe-20030308-branch:1.13.0.8
	kettenis-i386newframe-20030308-branchpoint:1.13
	carlton_dictionary-20030305-merge:1.13
	cagney_offbyone-20030303-branch:1.13.0.6
	cagney_offbyone-20030303-branchpoint:1.13
	carlton_dictionary-20030207-merge:1.13
	interps-20030202-branch:1.13.0.4
	interps-20030202-branchpoint:1.13
	cagney-unwind-20030108-branch:1.13.0.2
	cagney-unwind-20030108-branchpoint:1.13
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	carlton_dictionary-20021223-merge:1.13
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.11
	binutils-2_13_1:1.10
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.12
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.10
	carlton_dictionary-20020920-branchpoint:1.11
	sid-20020905-branchpoint:1.11
	sid-20020905-branch:1.11.0.8
	gdb_5_3-branch:1.11.0.6
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.11.0.4
	cagney_sysregs-20020825-branchpoint:1.11
	readline_4_3-import-branch:1.11.0.2
	readline_4_3-import-branchpoint:1.11
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.9
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	kseitz_interps-20020528-branch:1.9.0.10
	kseitz_interps-20020528-branchpoint:1.9
	cagney_regbuf-20020515-branch:1.9.0.8
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.9
	jimb-macro-020506-branch:1.9.0.6
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	binutils-2_12:1.9
	gdb_5_2-branch:1.9.0.4
	gdb_5_2-2002-03-03-branchpoint:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.9
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	insight-precleanup-2001-01-01:1.4
	binutils-2_10_1:1.1
	binutils-2_10:1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1
	gdb_5_0-2000-05-19-release:1.1
	gdb_4_18_2-2000-05-18-release:1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1
	gdb_5_0-2000-04-10-branch:1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1
	binutils-2_10-branch:1.1.0.2
	binutils-2_10-branchpoint:1.1
	binutils_latest_snapshot:1.62;
locks; strict;
comment	@ * @;


1.62
date	2013.04.09.15.50.38;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2013.02.11.05.30.54;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2013.02.10.04.36.31;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.58;

1.58
date	2012.07.24.21.44.44;	author eweddington;	state Exp;
branches;
next	1.57;

1.57
date	2012.05.16.14.52.16;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2012.05.11.12.59.23;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2012.05.07.03.27.49;	author macro;	state Exp;
branches;
next	1.54;

1.54
date	2012.04.24.05.12.31;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2012.02.02.18.02.10;	author eweddington;	state Exp;
branches;
next	1.52;

1.52
date	2012.01.05.09.57.18;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.02.13.43.14;	author nickc;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2011.03.22.18.10.42;	author eweddington;	state Exp;
branches;
next	1.49;

1.49
date	2010.11.17.10.56.42;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2010.10.25.15.54.13;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2010.08.25.14.53.40;	author hjl;	state Exp;
branches;
next	1.46;

1.46
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2010.02.23.11.38.35;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2010.02.04.09.16.38;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.11.13.42.02;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2009.05.27.13.31.23;	author nathan;	state Exp;
branches;
next	1.40;

1.40
date	2009.02.18.15.28.56;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2009.02.03.17.21.02;	author eweddington;	state Exp;
branches;
next	1.38;

1.38
date	2008.11.14.21.37.52;	author eweddington;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.09.05.35.12;	author eweddington;	state Exp;
branches
	1.37.2.1;
next	1.36;

1.36
date	2008.07.28.06.46.31;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2008.06.04.09.59.08;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2008.03.12.08.36.58;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.25.09.32.41;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2006.05.24.07.36.09;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.05.17.46.47;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.03.15.54.23;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.03.15.25.29;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2005.06.20.18.12.06;	author hjl;	state Exp;
branches;
next	1.21;

1.21
date	2005.05.04.15.53.12;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2005.05.04.07.19.22;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.22.14.25.42;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2004.10.21.15.28.20;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2004.03.22.02.28.15;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.20.23.16.39;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.05.13.17.08;	author amodra;	state Exp;
branches
	1.15.6.1
	1.15.8.1
	1.15.12.1;
next	1.14;

1.14
date	2003.06.25.06.40.22;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.30.08.39.37;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.28.11.55.38;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches
	1.11.10.1
	1.11.12.1;
next	1.10;

1.10
date	2002.07.01.08.06.42;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	2001.11.23.12.17.15;	author jakub;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.18.09.57.23;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.12.23.53.31;	author aoliva;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.21.03.58;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.12.03.20.44.04;	author kazu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.07.03.22.25.33;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.27.01.45.30;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.27.08.39.12;	author amodra;	state Exp;
branches;
next	;

1.51.2.1
date	2012.02.01.17.07.37;	author nickc;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2012.05.11.12.24.22;	author nickc;	state Exp;
branches;
next	;

1.37.2.1
date	2008.11.17.15.26.01;	author eweddington;	state Exp;
branches;
next	1.37.2.2;

1.37.2.2
date	2009.02.04.16.48.33;	author eweddington;	state Exp;
branches;
next	1.37.2.3;

1.37.2.3
date	2009.02.19.17.53.10;	author eweddington;	state Exp;
branches;
next	;

1.15.6.1
date	2004.04.08.12.41.38;	author amodra;	state Exp;
branches;
next	;

1.15.8.1
date	2004.03.27.17.37.32;	author drow;	state Exp;
branches;
next	;

1.15.12.1
date	2004.03.21.23.57.26;	author cagney;	state Exp;
branches;
next	;

1.11.10.1
date	2002.12.23.19.37.38;	author carlton;	state Exp;
branches;
next	1.11.10.2;

1.11.10.2
date	2003.06.27.21.49.12;	author carlton;	state Exp;
branches;
next	1.11.10.3;

1.11.10.3
date	2003.11.11.23.50.14;	author carlton;	state Exp;
branches;
next	;

1.11.12.1
date	2003.12.14.20.26.38;	author drow;	state Exp;
branches;
next	;

1.9.10.1
date	2002.07.22.21.46.42;	author kseitz;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2002.08.09.18.34.13;	author kseitz;	state Exp;
branches;
next	;

1.4.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.62
log
@	PR ld/12494
	* bfd/elf32-avr.c: Consider all sections to determine if linker
	relaxation can safely delete a ret after a call/jmp
@
text
@/* AVR-specific support for 32-bit ELF
   Copyright 1999-2013 Free Software Foundation, Inc.
   Contributed by Denis Chertykov <denisc@@overta.ru>

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/avr.h"
#include "elf32-avr.h"

/* Enable debugging printout at stdout with this variable.  */
static bfd_boolean debug_relax = FALSE;

/* Enable debugging printout at stdout with this variable.  */
static bfd_boolean debug_stubs = FALSE;

/* Hash table initialization and handling.  Code is taken from the hppa port
   and adapted to the needs of AVR.  */

/* We use two hash tables to hold information for linking avr objects.

   The first is the elf32_avr_link_hash_table which is derived from the
   stanard ELF linker hash table.  We use this as a place to attach the other
   hash table and some static information.

   The second is the stub hash table which is derived from the base BFD
   hash table.  The stub hash table holds the information on the linker
   stubs.  */

struct elf32_avr_stub_hash_entry
{
  /* Base hash table entry structure.  */
  struct bfd_hash_entry bh_root;

  /* Offset within stub_sec of the beginning of this stub.  */
  bfd_vma stub_offset;

  /* Given the symbol's value and its section we can determine its final
     value when building the stubs (so the stub knows where to jump).  */
  bfd_vma target_value;

  /* This way we could mark stubs to be no longer necessary.  */
  bfd_boolean is_actually_needed;
};

struct elf32_avr_link_hash_table
{
  /* The main hash table.  */
  struct elf_link_hash_table etab;

  /* The stub hash table.  */
  struct bfd_hash_table bstab;

  bfd_boolean no_stubs;

  /* Linker stub bfd.  */
  bfd *stub_bfd;

  /* The stub section.  */
  asection *stub_sec;

  /* Usually 0, unless we are generating code for a bootloader.  Will
     be initialized by elf32_avr_size_stubs to the vma offset of the
     output section associated with the stub section.  */
  bfd_vma vector_base;

  /* Assorted information used by elf32_avr_size_stubs.  */
  unsigned int        bfd_count;
  int                 top_index;
  asection **         input_list;
  Elf_Internal_Sym ** all_local_syms;

  /* Tables for mapping vma beyond the 128k boundary to the address of the
     corresponding stub.  (AMT)
     "amt_max_entry_cnt" reflects the number of entries that memory is allocated
     for in the "amt_stub_offsets" and "amt_destination_addr" arrays.
     "amt_entry_cnt" informs how many of these entries actually contain
     useful data.  */
  unsigned int amt_entry_cnt;
  unsigned int amt_max_entry_cnt;
  bfd_vma *    amt_stub_offsets;
  bfd_vma *    amt_destination_addr;
};

/* Various hash macros and functions.  */
#define avr_link_hash_table(p) \
  /* PR 3874: Check that we have an AVR style hash table before using it.  */\
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == AVR_ELF_DATA ? ((struct elf32_avr_link_hash_table *) ((p)->hash)) : NULL)

#define avr_stub_hash_entry(ent) \
  ((struct elf32_avr_stub_hash_entry *)(ent))

#define avr_stub_hash_lookup(table, string, create, copy) \
  ((struct elf32_avr_stub_hash_entry *) \
   bfd_hash_lookup ((table), (string), (create), (copy)))

static reloc_howto_type elf_avr_howto_table[] =
{
  HOWTO (R_AVR_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_AVR_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 7 bit PC relative relocation.  */
  HOWTO (R_AVR_7_PCREL,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 7,			/* bitsize */
	 TRUE,			/* pc_relative */
	 3,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_AVR_7_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 13 bit PC relative relocation.  */
  HOWTO (R_AVR_13_PCREL,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 13,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_AVR_13_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0xfff,			/* src_mask */
	 0xfff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit absolute relocation.  */
  HOWTO (R_AVR_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit absolute relocation for command address
     Will be changed when linker stubs are needed.  */
  HOWTO (R_AVR_16_PM,		/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_16_PM",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 16 bit address.
     For LDI command.  */
  HOWTO (R_AVR_LO8_LDI,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_LO8_LDI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A high 8 bit absolute relocation of 16 bit address.
     For LDI command.  */
  HOWTO (R_AVR_HI8_LDI,		/* type */
	 8,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HI8_LDI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A high 6 bit absolute relocation of 22 bit address.
     For LDI command.  As well second most significant 8 bit value of
     a 32 bit link-time constant.  */
  HOWTO (R_AVR_HH8_LDI,		/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HH8_LDI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A negative low 8 bit absolute relocation of 16 bit address.
     For LDI command.  */
  HOWTO (R_AVR_LO8_LDI_NEG,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_LO8_LDI_NEG",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A negative high 8 bit absolute relocation of 16 bit address.
     For LDI command.  */
  HOWTO (R_AVR_HI8_LDI_NEG,	/* type */
	 8,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HI8_LDI_NEG",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A negative high 6 bit absolute relocation of 22 bit address.
     For LDI command.  */
  HOWTO (R_AVR_HH8_LDI_NEG,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HH8_LDI_NEG",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  Will not be changed when linker stubs are needed. */
  HOWTO (R_AVR_LO8_LDI_PM,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_LO8_LDI_PM",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  Will not be changed when linker stubs are needed. */
  HOWTO (R_AVR_HI8_LDI_PM,	/* type */
	 9,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HI8_LDI_PM",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  Will not be changed when linker stubs are needed. */
  HOWTO (R_AVR_HH8_LDI_PM,	/* type */
	 17,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HH8_LDI_PM",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  Will not be changed when linker stubs are needed. */
  HOWTO (R_AVR_LO8_LDI_PM_NEG,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_LO8_LDI_PM_NEG", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  Will not be changed when linker stubs are needed. */
  HOWTO (R_AVR_HI8_LDI_PM_NEG,	/* type */
	 9,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HI8_LDI_PM_NEG", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  Will not be changed when linker stubs are needed. */
  HOWTO (R_AVR_HH8_LDI_PM_NEG,	/* type */
	 17,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_HH8_LDI_PM_NEG", /* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* Relocation for CALL command in ATmega.  */
  HOWTO (R_AVR_CALL,		/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 23,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_CALL",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),			/* pcrel_offset */
  /* A 16 bit absolute relocation of 16 bit address.
     For LDI command.  */
  HOWTO (R_AVR_LDI,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_LDI",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A 6 bit absolute relocation of 6 bit offset.
     For ldd/sdd command.  */
  HOWTO (R_AVR_6,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_6",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* A 6 bit absolute relocation of 6 bit offset.
     For sbiw/adiw command.  */
  HOWTO (R_AVR_6_ADIW,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 6,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_6_ADIW",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* Most significant 8 bit value of a 32 bit link-time constant.  */
  HOWTO (R_AVR_MS8_LDI,		/* type */
	 24,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_MS8_LDI",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* Negative most significant 8 bit value of a 32 bit link-time constant.  */
  HOWTO (R_AVR_MS8_LDI_NEG,	/* type */
	 24,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_MS8_LDI_NEG",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffff,		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE), 		/* pcrel_offset */
  /* A low 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  Will be changed when linker stubs are needed.  */
  HOWTO (R_AVR_LO8_LDI_GS,      /* type */
         1,                     /* rightshift */
         1,                     /* size (0 = byte, 1 = short, 2 = long) */
         8,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_AVR_LO8_LDI_GS",    /* name */
         FALSE,                 /* partial_inplace */
         0xffff,                /* src_mask */
         0xffff,                /* dst_mask */
         FALSE),                /* pcrel_offset */
  /* A low 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  Will be changed when linker stubs are needed.  */
  HOWTO (R_AVR_HI8_LDI_GS,      /* type */
         9,                     /* rightshift */
         1,                     /* size (0 = byte, 1 = short, 2 = long) */
         8,                     /* bitsize */
         FALSE,                 /* pc_relative */
         0,                     /* bitpos */
         complain_overflow_dont, /* complain_on_overflow */
         bfd_elf_generic_reloc, /* special_function */
         "R_AVR_HI8_LDI_GS",    /* name */
         FALSE,                 /* partial_inplace */
         0xffff,                /* src_mask */
         0xffff,                /* dst_mask */
         FALSE),                /* pcrel_offset */
  /* 8 bit offset.  */
  HOWTO (R_AVR_8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_8",		/* name */
	 FALSE,			/* partial_inplace */
	 0x000000ff,		/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* lo8-part to use in  .byte lo8(sym).  */
  HOWTO (R_AVR_8_LO8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_8_LO8",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* hi8-part to use in  .byte hi8(sym).  */
  HOWTO (R_AVR_8_HI8,		/* type */
	 8,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_8_HI8",		/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
  /* hlo8-part to use in  .byte hlo8(sym).  */
  HOWTO (R_AVR_8_HLO8,		/* type */
	 16,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_AVR_8_HLO8",	/* name */
	 FALSE,			/* partial_inplace */
	 0xffffff,		/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* Map BFD reloc types to AVR ELF reloc types.  */

struct avr_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned int elf_reloc_val;
};

static const struct avr_reloc_map avr_reloc_map[] =
{
  { BFD_RELOC_NONE,                 R_AVR_NONE },
  { BFD_RELOC_32,                   R_AVR_32 },
  { BFD_RELOC_AVR_7_PCREL,          R_AVR_7_PCREL },
  { BFD_RELOC_AVR_13_PCREL,         R_AVR_13_PCREL },
  { BFD_RELOC_16,                   R_AVR_16 },
  { BFD_RELOC_AVR_16_PM,            R_AVR_16_PM },
  { BFD_RELOC_AVR_LO8_LDI,          R_AVR_LO8_LDI},
  { BFD_RELOC_AVR_HI8_LDI,          R_AVR_HI8_LDI },
  { BFD_RELOC_AVR_HH8_LDI,          R_AVR_HH8_LDI },
  { BFD_RELOC_AVR_MS8_LDI,          R_AVR_MS8_LDI },
  { BFD_RELOC_AVR_LO8_LDI_NEG,      R_AVR_LO8_LDI_NEG },
  { BFD_RELOC_AVR_HI8_LDI_NEG,      R_AVR_HI8_LDI_NEG },
  { BFD_RELOC_AVR_HH8_LDI_NEG,      R_AVR_HH8_LDI_NEG },
  { BFD_RELOC_AVR_MS8_LDI_NEG,      R_AVR_MS8_LDI_NEG },
  { BFD_RELOC_AVR_LO8_LDI_PM,       R_AVR_LO8_LDI_PM },
  { BFD_RELOC_AVR_LO8_LDI_GS,       R_AVR_LO8_LDI_GS },
  { BFD_RELOC_AVR_HI8_LDI_PM,       R_AVR_HI8_LDI_PM },
  { BFD_RELOC_AVR_HI8_LDI_GS,       R_AVR_HI8_LDI_GS },
  { BFD_RELOC_AVR_HH8_LDI_PM,       R_AVR_HH8_LDI_PM },
  { BFD_RELOC_AVR_LO8_LDI_PM_NEG,   R_AVR_LO8_LDI_PM_NEG },
  { BFD_RELOC_AVR_HI8_LDI_PM_NEG,   R_AVR_HI8_LDI_PM_NEG },
  { BFD_RELOC_AVR_HH8_LDI_PM_NEG,   R_AVR_HH8_LDI_PM_NEG },
  { BFD_RELOC_AVR_CALL,             R_AVR_CALL },
  { BFD_RELOC_AVR_LDI,              R_AVR_LDI  },
  { BFD_RELOC_AVR_6,                R_AVR_6    },
  { BFD_RELOC_AVR_6_ADIW,           R_AVR_6_ADIW },
  { BFD_RELOC_8,                    R_AVR_8 },
  { BFD_RELOC_AVR_8_LO,             R_AVR_8_LO8 },
  { BFD_RELOC_AVR_8_HI,             R_AVR_8_HI8 },
  { BFD_RELOC_AVR_8_HLO,            R_AVR_8_HLO8 }
};

/* Meant to be filled one day with the wrap around address for the
   specific device.  I.e. should get the value 0x4000 for 16k devices,
   0x8000 for 32k devices and so on.

   We initialize it here with a value of 0x1000000 resulting in
   that we will never suggest a wrap-around jump during relaxation.
   The logic of the source code later on assumes that in
   avr_pc_wrap_around one single bit is set.  */
static bfd_vma avr_pc_wrap_around = 0x10000000;

/* If this variable holds a value different from zero, the linker relaxation
   machine will try to optimize call/ret sequences by a single jump
   instruction. This option could be switched off by a linker switch.  */
static int avr_replace_call_ret_sequences = 1;

/* Initialize an entry in the stub hash table.  */

static struct bfd_hash_entry *
stub_hash_newfunc (struct bfd_hash_entry *entry,
                   struct bfd_hash_table *table,
                   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
                                 sizeof (struct elf32_avr_stub_hash_entry));
      if (entry == NULL)
        return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = bfd_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf32_avr_stub_hash_entry *hsh;

      /* Initialize the local fields.  */
      hsh = avr_stub_hash_entry (entry);
      hsh->stub_offset = 0;
      hsh->target_value = 0;
    }

  return entry;
}

/* This function is just a straight passthrough to the real
   function in linker.c.  Its prupose is so that its address
   can be compared inside the avr_link_hash_table macro.  */

static struct bfd_hash_entry *
elf32_avr_link_hash_newfunc (struct bfd_hash_entry * entry,
			     struct bfd_hash_table * table,
			     const char * string)
{
  return _bfd_elf_link_hash_newfunc (entry, table, string);
}

/* Create the derived linker hash table.  The AVR ELF port uses the derived
   hash table to keep information specific to the AVR ELF linker (without
   using static variables).  */

static struct bfd_link_hash_table *
elf32_avr_link_hash_table_create (bfd *abfd)
{
  struct elf32_avr_link_hash_table *htab;
  bfd_size_type amt = sizeof (*htab);

  htab = bfd_zmalloc (amt);
  if (htab == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&htab->etab, abfd,
                                      elf32_avr_link_hash_newfunc,
                                      sizeof (struct elf_link_hash_entry),
				      AVR_ELF_DATA))
    {
      free (htab);
      return NULL;
    }

  /* Init the stub hash table too.  */
  if (!bfd_hash_table_init (&htab->bstab, stub_hash_newfunc,
                            sizeof (struct elf32_avr_stub_hash_entry)))
    return NULL;

  return &htab->etab.root;
}

/* Free the derived linker hash table.  */

static void
elf32_avr_link_hash_table_free (struct bfd_link_hash_table *btab)
{
  struct elf32_avr_link_hash_table *htab
    = (struct elf32_avr_link_hash_table *) btab;

  /* Free the address mapping table.  */
  if (htab->amt_stub_offsets != NULL)
    free (htab->amt_stub_offsets);
  if (htab->amt_destination_addr != NULL)
    free (htab->amt_destination_addr);

  bfd_hash_table_free (&htab->bstab);
  _bfd_elf_link_hash_table_free (btab);
}

/* Calculates the effective distance of a pc relative jump/call.  */

static int
avr_relative_distance_considering_wrap_around (unsigned int distance)
{
  unsigned int wrap_around_mask = avr_pc_wrap_around - 1;
  int dist_with_wrap_around = distance & wrap_around_mask;

  if (dist_with_wrap_around > ((int) (avr_pc_wrap_around >> 1)))
    dist_with_wrap_around -= avr_pc_wrap_around;

  return dist_with_wrap_around;
}


static reloc_howto_type *
bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (avr_reloc_map) / sizeof (struct avr_reloc_map);
       i++)
    if (avr_reloc_map[i].bfd_reloc_val == code)
      return &elf_avr_howto_table[avr_reloc_map[i].elf_reloc_val];

  return NULL;
}

static reloc_howto_type *
bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				 const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (elf_avr_howto_table) / sizeof (elf_avr_howto_table[0]);
       i++)
    if (elf_avr_howto_table[i].name != NULL
	&& strcasecmp (elf_avr_howto_table[i].name, r_name) == 0)
      return &elf_avr_howto_table[i];

  return NULL;
}

/* Set the howto pointer for an AVR ELF reloc.  */

static void
avr_info_to_howto_rela (bfd *abfd ATTRIBUTE_UNUSED,
			arelent *cache_ptr,
			Elf_Internal_Rela *dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_AVR_max);
  cache_ptr->howto = &elf_avr_howto_table[r_type];
}

static bfd_boolean
avr_stub_is_required_for_16_bit_reloc (bfd_vma relocation)
{
  return (relocation >= 0x020000);
}

/* Returns the address of the corresponding stub if there is one.
   Returns otherwise an address above 0x020000.  This function
   could also be used, if there is no knowledge on the section where
   the destination is found.  */

static bfd_vma
avr_get_stub_addr (bfd_vma srel,
                   struct elf32_avr_link_hash_table *htab)
{
  unsigned int sindex;
  bfd_vma stub_sec_addr =
              (htab->stub_sec->output_section->vma +
	       htab->stub_sec->output_offset);

  for (sindex = 0; sindex < htab->amt_max_entry_cnt; sindex ++)
    if (htab->amt_destination_addr[sindex] == srel)
      return htab->amt_stub_offsets[sindex] + stub_sec_addr;

  /* Return an address that could not be reached by 16 bit relocs.  */
  return 0x020000;
}

/* Perform a single relocation.  By default we use the standard BFD
   routines, but a few relocs, we have to do them ourselves.  */

static bfd_reloc_status_type
avr_final_link_relocate (reloc_howto_type *                 howto,
			 bfd *                              input_bfd,
			 asection *                         input_section,
			 bfd_byte *                         contents,
			 Elf_Internal_Rela *                rel,
                         bfd_vma                            relocation,
                         struct elf32_avr_link_hash_table * htab)
{
  bfd_reloc_status_type r = bfd_reloc_ok;
  bfd_vma               x;
  bfd_signed_vma	srel;
  bfd_signed_vma	reloc_addr;
  bfd_boolean           use_stubs = FALSE;
  /* Usually is 0, unless we are generating code for a bootloader.  */
  bfd_signed_vma        base_addr = htab->vector_base;

  /* Absolute addr of the reloc in the final excecutable.  */
  reloc_addr = rel->r_offset + input_section->output_section->vma
	       + input_section->output_offset;

  switch (howto->type)
    {
    case R_AVR_7_PCREL:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      srel -= 2;	/* Branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
	       input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;
      if (srel > ((1 << 7) - 1) || (srel < - (1 << 7)))
	return bfd_reloc_overflow;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xfc07) | (((srel >> 1) << 3) & 0x3f8);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_13_PCREL:
      contents   += rel->r_offset;
      srel = (bfd_signed_vma) relocation;
      srel += rel->r_addend;
      srel -= rel->r_offset;
      srel -= 2;	/* Branch instructions add 2 to the PC...  */
      srel -= (input_section->output_section->vma +
	       input_section->output_offset);

      if (srel & 1)
	return bfd_reloc_outofrange;

      srel = avr_relative_distance_considering_wrap_around (srel);

      /* AVR addresses commands as words.  */
      srel >>= 1;

      /* Check for overflow.  */
      if (srel < -2048 || srel > 2047)
	{
          /* Relative distance is too large.  */

	  /* Always apply WRAPAROUND for avr2, avr25, and avr4.  */
	  switch (bfd_get_mach (input_bfd))
	    {
	    case bfd_mach_avr2:
	    case bfd_mach_avr25:
	    case bfd_mach_avr4:
	      break;

	    default:
	      return bfd_reloc_overflow;
	    }
	}

      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf000) | (srel & 0xfff);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_LO8_LDI:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_LDI:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      if (((srel > 0) && (srel & 0xffff) > 255)
	  || ((srel < 0) && ((-srel) & 0xffff) > 128))
        /* Remove offset for data/eeprom section.  */
        return bfd_reloc_overflow;

      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_6:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      if (((srel & 0xffff) > 63) || (srel < 0))
	/* Remove offset for data/eeprom section.  */
	return bfd_reloc_overflow;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xd3f8) | ((srel & 7) | ((srel & (3 << 3)) << 7)
                       | ((srel & (1 << 5)) << 8));
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_6_ADIW:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      if (((srel & 0xffff) > 63) || (srel < 0))
	/* Remove offset for data/eeprom section.  */
	return bfd_reloc_overflow;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xff30) | (srel & 0xf) | ((srel & 0x30) << 2);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HI8_LDI:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = (srel >> 8) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HH8_LDI:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = (srel >> 16) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_MS8_LDI:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = (srel >> 24) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_LO8_LDI_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HI8_LDI_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      srel = (srel >> 8) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HH8_LDI_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      srel = (srel >> 16) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_MS8_LDI_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      srel = (srel >> 24) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_LO8_LDI_GS:
      use_stubs = (!htab->no_stubs);
      /* Fall through.  */
    case R_AVR_LO8_LDI_PM:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;

      if (use_stubs
          && avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
        {
          bfd_vma old_srel = srel;

          /* We need to use the address of the stub instead.  */
          srel = avr_get_stub_addr (srel, htab);
          if (debug_stubs)
            printf ("LD: Using jump stub (at 0x%x) with destination 0x%x for "
                    "reloc at address 0x%x.\n",
                    (unsigned int) srel,
                    (unsigned int) old_srel,
                    (unsigned int) reloc_addr);

	  if (avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
	    return bfd_reloc_outofrange;
        }

      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HI8_LDI_GS:
      use_stubs = (!htab->no_stubs);
      /* Fall through.  */
    case R_AVR_HI8_LDI_PM:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;

      if (use_stubs
          && avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
        {
          bfd_vma old_srel = srel;

          /* We need to use the address of the stub instead.  */
          srel = avr_get_stub_addr (srel, htab);
          if (debug_stubs)
            printf ("LD: Using jump stub (at 0x%x) with destination 0x%x for "
                    "reloc at address 0x%x.\n",
                    (unsigned int) srel,
                    (unsigned int) old_srel,
                    (unsigned int) reloc_addr);

	  if (avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
	    return bfd_reloc_outofrange;
        }

      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      srel = (srel >> 8) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HH8_LDI_PM:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      srel = (srel >> 16) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_LO8_LDI_PM_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HI8_LDI_PM_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      srel = (srel >> 8) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_HH8_LDI_PM_NEG:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      srel = -srel;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      srel = (srel >> 16) & 0xff;
      x = bfd_get_16 (input_bfd, contents);
      x = (x & 0xf0f0) | (srel & 0xf) | ((srel << 4) & 0xf00);
      bfd_put_16 (input_bfd, x, contents);
      break;

    case R_AVR_CALL:
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;
      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      x = bfd_get_16 (input_bfd, contents);
      x |= ((srel & 0x10000) | ((srel << 3) & 0x1f00000)) >> 16;
      bfd_put_16 (input_bfd, x, contents);
      bfd_put_16 (input_bfd, (bfd_vma) srel & 0xffff, contents+2);
      break;

    case R_AVR_16_PM:
      use_stubs = (!htab->no_stubs);
      contents += rel->r_offset;
      srel = (bfd_signed_vma) relocation + rel->r_addend;

      if (use_stubs
          && avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
        {
          bfd_vma old_srel = srel;

          /* We need to use the address of the stub instead.  */
          srel = avr_get_stub_addr (srel,htab);
          if (debug_stubs)
            printf ("LD: Using jump stub (at 0x%x) with destination 0x%x for "
                    "reloc at address 0x%x.\n",
                    (unsigned int) srel,
                    (unsigned int) old_srel,
                    (unsigned int) reloc_addr);

	  if (avr_stub_is_required_for_16_bit_reloc (srel - base_addr))
	    return bfd_reloc_outofrange;
        }

      if (srel & 1)
	return bfd_reloc_outofrange;
      srel = srel >> 1;
      bfd_put_16 (input_bfd, (bfd_vma) srel &0x00ffff, contents);
      break;

    default:
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);
    }

  return r;
}

/* Relocate an AVR ELF section.  */

static bfd_boolean
elf32_avr_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info,
			    bfd *input_bfd,
			    asection *input_section,
			    bfd_byte *contents,
			    Elf_Internal_Rela *relocs,
			    Elf_Internal_Sym *local_syms,
			    asection **local_sections)
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;
  struct elf32_avr_link_hash_table * htab = avr_link_hash_table (info);

  if (htab == NULL)
    return FALSE;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      const char *                 name;
      int                          r_type;

      r_type = ELF32_R_TYPE (rel->r_info);
      r_symndx = ELF32_R_SYM (rel->r_info);
      howto  = elf_avr_howto_table + r_type;
      h      = NULL;
      sym    = NULL;
      sec    = NULL;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  bfd_boolean unresolved_reloc, warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);

	  name = h->root.root.string;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      r = avr_final_link_relocate (howto, input_bfd, input_section,
				   contents, rel, relocation, htab);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, (h ? &h->root : NULL),
		 name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

/* The final processing done just before writing out a AVR ELF object
   file.  This gets the AVR architecture right based on the machine
   number.  */

static void
bfd_elf_avr_final_write_processing (bfd *abfd,
				    bfd_boolean linker ATTRIBUTE_UNUSED)
{
  unsigned long val;

  switch (bfd_get_mach (abfd))
    {
    default:
    case bfd_mach_avr2:
      val = E_AVR_MACH_AVR2;
      break;

    case bfd_mach_avr1:
      val = E_AVR_MACH_AVR1;
      break;

    case bfd_mach_avr25:
      val = E_AVR_MACH_AVR25;
      break;

    case bfd_mach_avr3:
      val = E_AVR_MACH_AVR3;
      break;

    case bfd_mach_avr31:
      val = E_AVR_MACH_AVR31;
      break;

    case bfd_mach_avr35:
      val = E_AVR_MACH_AVR35;
      break;

    case bfd_mach_avr4:
      val = E_AVR_MACH_AVR4;
      break;

    case bfd_mach_avr5:
      val = E_AVR_MACH_AVR5;
      break;

    case bfd_mach_avr51:
      val = E_AVR_MACH_AVR51;
      break;

    case bfd_mach_avr6:
      val = E_AVR_MACH_AVR6;
      break;

    case bfd_mach_avrxmega1:
      val = E_AVR_MACH_XMEGA1;
      break;

    case bfd_mach_avrxmega2:
      val = E_AVR_MACH_XMEGA2;
      break;

    case bfd_mach_avrxmega3:
      val = E_AVR_MACH_XMEGA3;
      break;

    case bfd_mach_avrxmega4:
      val = E_AVR_MACH_XMEGA4;
      break;

    case bfd_mach_avrxmega5:
      val = E_AVR_MACH_XMEGA5;
      break;

    case bfd_mach_avrxmega6:
      val = E_AVR_MACH_XMEGA6;
      break;

    case bfd_mach_avrxmega7:
      val = E_AVR_MACH_XMEGA7;
      break;
    }

  elf_elfheader (abfd)->e_machine = EM_AVR;
  elf_elfheader (abfd)->e_flags &= ~ EF_AVR_MACH;
  elf_elfheader (abfd)->e_flags |= val;
  elf_elfheader (abfd)->e_flags |= EF_AVR_LINKRELAX_PREPARED;
}

/* Set the right machine number.  */

static bfd_boolean
elf32_avr_object_p (bfd *abfd)
{
  unsigned int e_set = bfd_mach_avr2;

  if (elf_elfheader (abfd)->e_machine == EM_AVR
      || elf_elfheader (abfd)->e_machine == EM_AVR_OLD)
    {
      int e_mach = elf_elfheader (abfd)->e_flags & EF_AVR_MACH;

      switch (e_mach)
	{
	default:
	case E_AVR_MACH_AVR2:
	  e_set = bfd_mach_avr2;
	  break;

	case E_AVR_MACH_AVR1:
	  e_set = bfd_mach_avr1;
	  break;

	case E_AVR_MACH_AVR25:
	  e_set = bfd_mach_avr25;
	  break;

	case E_AVR_MACH_AVR3:
	  e_set = bfd_mach_avr3;
	  break;

	case E_AVR_MACH_AVR31:
	  e_set = bfd_mach_avr31;
	  break;

	case E_AVR_MACH_AVR35:
	  e_set = bfd_mach_avr35;
	  break;

	case E_AVR_MACH_AVR4:
	  e_set = bfd_mach_avr4;
	  break;

	case E_AVR_MACH_AVR5:
	  e_set = bfd_mach_avr5;
	  break;

	case E_AVR_MACH_AVR51:
	  e_set = bfd_mach_avr51;
	  break;

	case E_AVR_MACH_AVR6:
	  e_set = bfd_mach_avr6;
	  break;

	case E_AVR_MACH_XMEGA1:
	  e_set = bfd_mach_avrxmega1;
	  break;

	case E_AVR_MACH_XMEGA2:
	  e_set = bfd_mach_avrxmega2;
	  break;

	case E_AVR_MACH_XMEGA3:
	  e_set = bfd_mach_avrxmega3;
	  break;

	case E_AVR_MACH_XMEGA4:
	  e_set = bfd_mach_avrxmega4;
	  break;

	case E_AVR_MACH_XMEGA5:
	  e_set = bfd_mach_avrxmega5;
	  break;

	case E_AVR_MACH_XMEGA6:
	  e_set = bfd_mach_avrxmega6;
	  break;

	case E_AVR_MACH_XMEGA7:
	  e_set = bfd_mach_avrxmega7;
	  break;
	}
    }
  return bfd_default_set_arch_mach (abfd, bfd_arch_avr,
				    e_set);
}


/* Delete some bytes from a section while changing the size of an instruction.
   The parameter "addr" denotes the section-relative offset pointing just
   behind the shrinked instruction. "addr+count" point at the first
   byte just behind the original unshrinked instruction.  */

static bfd_boolean
elf32_avr_relax_delete_bytes (bfd *abfd,
                              asection *sec,
                              bfd_vma addr,
                              int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymbuf = NULL;
  bfd_vma toaddr;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
  contents = elf_section_data (sec)->this_hdr.contents;

  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  if (toaddr - addr - count > 0)
    memmove (contents + addr, contents + addr + count,
             (size_t) (toaddr - addr - count));
  sec->size -= count;

  /* Adjust all the reloc addresses.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      bfd_vma old_reloc_address;

      old_reloc_address = (sec->output_section->vma
                           + sec->output_offset + irel->r_offset);

      /* Get the new reloc address.  */
      if ((irel->r_offset > addr
           && irel->r_offset < toaddr))
        {
          if (debug_relax)
            printf ("Relocation at address 0x%x needs to be moved.\n"
                    "Old section offset: 0x%x, New section offset: 0x%x \n",
                    (unsigned int) old_reloc_address,
                    (unsigned int) irel->r_offset,
                    (unsigned int) ((irel->r_offset) - count));

          irel->r_offset -= count;
        }

    }

   /* The reloc's own addresses are now ok. However, we need to readjust
      the reloc's addend, i.e. the reloc's value if two conditions are met:
      1.) the reloc is relative to a symbol in this section that
          is located in front of the shrinked instruction
      2.) symbol plus addend end up behind the shrinked instruction.

      The most common case where this happens are relocs relative to
      the section-start symbol.

      This step needs to be done for all of the sections of the bfd.  */

  {
    struct bfd_section *isec;

    for (isec = abfd->sections; isec; isec = isec->next)
     {
       bfd_vma symval;
       bfd_vma shrinked_insn_address;

       if (isec->reloc_count == 0)
	 continue;

       shrinked_insn_address = (sec->output_section->vma
                                + sec->output_offset + addr - count);

       irel = elf_section_data (isec)->relocs;
       /* PR 12161: Read in the relocs for this section if necessary.  */
       if (irel == NULL)
         irel = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL, TRUE);

       for (irelend = irel + isec->reloc_count;
            irel < irelend;
            irel++)
         {
           /* Read this BFD's local symbols if we haven't done
              so already.  */
           if (isymbuf == NULL && symtab_hdr->sh_info != 0)
             {
               isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
               if (isymbuf == NULL)
                 isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
                                                 symtab_hdr->sh_info, 0,
                                                 NULL, NULL, NULL);
               if (isymbuf == NULL)
                 return FALSE;
             }

           /* Get the value of the symbol referred to by the reloc.  */
           if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
             {
               /* A local symbol.  */
               asection *sym_sec;

               isym = isymbuf + ELF32_R_SYM (irel->r_info);
               sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
               symval = isym->st_value;
               /* If the reloc is absolute, it will not have
                  a symbol or section associated with it.  */
               if (sym_sec == sec)
                 {
                   symval += sym_sec->output_section->vma
                             + sym_sec->output_offset;

                   if (debug_relax)
                     printf ("Checking if the relocation's "
                             "addend needs corrections.\n"
                             "Address of anchor symbol: 0x%x \n"
                             "Address of relocation target: 0x%x \n"
                             "Address of relaxed insn: 0x%x \n",
                             (unsigned int) symval,
                             (unsigned int) (symval + irel->r_addend),
                             (unsigned int) shrinked_insn_address);

                   if (symval <= shrinked_insn_address
                       && (symval + irel->r_addend) > shrinked_insn_address)
                     {
                       irel->r_addend -= count;

                       if (debug_relax)
                         printf ("Relocation's addend needed to be fixed \n");
                     }
                 }
	       /* else...Reference symbol is absolute.  No adjustment needed.  */
	     }
	   /* else...Reference symbol is extern.  No need for adjusting
	      the addend.  */
	 }
     }
  }

  /* Adjust the local symbols defined in this section.  */
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  /* Fix PR 9841, there may be no local symbols.  */
  if (isym != NULL)
    {
      Elf_Internal_Sym *isymend;

      isymend = isym + symtab_hdr->sh_info;
      for (; isym < isymend; isym++)
	{
	  if (isym->st_shndx == sec_shndx
	      && isym->st_value > addr
	      && isym->st_value < toaddr)
	    isym->st_value -= count;
	}
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
              - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;
      if ((sym_hash->root.type == bfd_link_hash_defined
           || sym_hash->root.type == bfd_link_hash_defweak)
          && sym_hash->root.u.def.section == sec
          && sym_hash->root.u.def.value > addr
          && sym_hash->root.u.def.value < toaddr)
        {
          sym_hash->root.u.def.value -= count;
        }
    }

  return TRUE;
}

/* This function handles relaxing for the avr.
   Many important relaxing opportunities within functions are already
   realized by the compiler itself.
   Here we try to replace  call (4 bytes) ->  rcall (2 bytes)
   and jump -> rjmp (safes also 2 bytes).
   As well we now optimize seqences of
     - call/rcall function
     - ret
   to yield
     - jmp/rjmp function
     - ret
   . In case that within a sequence
     - jmp/rjmp label
     - ret
   the ret could no longer be reached it is optimized away. In order
   to check if the ret is no longer needed, it is checked that the ret's address
   is not the target of a branch or jump within the same section, it is checked
   that there is no skip instruction before the jmp/rjmp and that there
   is no local or global label place at the address of the ret.

   We refrain from relaxing within sections ".vectors" and
   ".jumptables" in order to maintain the position of the instructions.
   There, however, we substitute jmp/call by a sequence rjmp,nop/rcall,nop
   if possible. (In future one could possibly use the space of the nop
   for the first instruction of the irq service function.

   The .jumptables sections is meant to be used for a future tablejump variant
   for the devices with 3-byte program counter where the table itself
   contains 4-byte jump instructions whose relative offset must not
   be changed.  */

static bfd_boolean
elf32_avr_relax_section (bfd *abfd,
			 asection *sec,
                         struct bfd_link_info *link_info,
                         bfd_boolean *again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  struct elf32_avr_link_hash_table *htab;

  /* If 'shrinkable' is FALSE, do not shrink by deleting bytes while
     relaxing. Such shrinking can cause issues for the sections such
     as .vectors and .jumptables. Instead the unused bytes should be
     filled with nop instructions. */
  bfd_boolean shrinkable = TRUE;

  if (!strcmp (sec->name,".vectors")
      || !strcmp (sec->name,".jumptables"))
    shrinkable = FALSE;

  if (link_info->relocatable)
    (*link_info->callbacks->einfo)
      (_("%P%F: --relax and -r may not be used together\n"));

  htab = avr_link_hash_table (link_info);
  if (htab == NULL)
    return FALSE;

  /* Assume nothing changes.  */
  *again = FALSE;

  if ((!htab->no_stubs) && (sec == htab->stub_sec))
    {
      /* We are just relaxing the stub section.
	 Let's calculate the size needed again.  */
      bfd_size_type last_estimated_stub_section_size = htab->stub_sec->size;

      if (debug_relax)
        printf ("Relaxing the stub section. Size prior to this pass: %i\n",
                (int) last_estimated_stub_section_size);

      elf32_avr_size_stubs (htab->stub_sec->output_section->owner,
                            link_info, FALSE);

      /* Check if the number of trampolines changed.  */
      if (last_estimated_stub_section_size != htab->stub_sec->size)
        *again = TRUE;

      if (debug_relax)
        printf ("Size of stub section after this pass: %i\n",
                (int) htab->stub_sec->size);

      return TRUE;
    }

  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return TRUE;

  /* Check if the object file to relax uses internal symbols so that we
     could fix up the relocations.  */
  if (!(elf_elfheader (abfd)->e_flags & EF_AVR_LINKRELAX_PREPARED))
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf_link_read_relocs
                     (abfd, sec, NULL, NULL, link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;

  /* Walk through the relocs looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;

      if (   ELF32_R_TYPE (irel->r_info) != R_AVR_13_PCREL
	     && ELF32_R_TYPE (irel->r_info) != R_AVR_7_PCREL
	     && ELF32_R_TYPE (irel->r_info) != R_AVR_CALL)
        continue;

      /* Get the section contents if we haven't done so already.  */
      if (contents == NULL)
        {
          /* Get cached copy if it exists.  */
          if (elf_section_data (sec)->this_hdr.contents != NULL)
            contents = elf_section_data (sec)->this_hdr.contents;
          else
            {
              /* Go get them off disk.  */
              if (! bfd_malloc_and_get_section (abfd, sec, &contents))
                goto error_return;
            }
        }

      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
        {
          isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
          if (isymbuf == NULL)
            isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
                                            symtab_hdr->sh_info, 0,
                                            NULL, NULL, NULL);
          if (isymbuf == NULL)
            goto error_return;
        }


      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
        {
          /* A local symbol.  */
          Elf_Internal_Sym *isym;
          asection *sym_sec;

          isym = isymbuf + ELF32_R_SYM (irel->r_info);
          sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
          symval = isym->st_value;
          /* If the reloc is absolute, it will not have
             a symbol or section associated with it.  */
          if (sym_sec)
            symval += sym_sec->output_section->vma
              + sym_sec->output_offset;
        }
      else
        {
          unsigned long indx;
          struct elf_link_hash_entry *h;

          /* An external symbol.  */
          indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
          h = elf_sym_hashes (abfd)[indx];
          BFD_ASSERT (h != NULL);
          if (h->root.type != bfd_link_hash_defined
              && h->root.type != bfd_link_hash_defweak)
	    /* This appears to be a reference to an undefined
	       symbol.  Just ignore it--it will be caught by the
	       regular reloc processing.  */
	    continue;

          symval = (h->root.u.def.value
                    + h->root.u.def.section->output_section->vma
                    + h->root.u.def.section->output_offset);
        }

      /* For simplicity of coding, we are going to modify the section
         contents, the section relocs, and the BFD symbol table.  We
         must tell the rest of the code not to free up this
         information.  It would be possible to instead create a table
         of changes which have to be made, as is done in coff-mips.c;
         that would be more work, but would require less memory when
         the linker is run.  */
      switch (ELF32_R_TYPE (irel->r_info))
        {
	  /* Try to turn a 22-bit absolute call/jump into an 13-bit
	     pc-relative rcall/rjmp.  */
	case R_AVR_CALL:
          {
            bfd_vma value = symval + irel->r_addend;
            bfd_vma dot, gap;
            int distance_short_enough = 0;

            /* Get the address of this instruction.  */
            dot = (sec->output_section->vma
                   + sec->output_offset + irel->r_offset);

            /* Compute the distance from this insn to the branch target.  */
            gap = value - dot;

            /* Check if the gap falls in the range that can be accommodated
               in 13bits signed (It is 12bits when encoded, as we deal with
               word addressing). */
            if (!shrinkable && ((int) gap >= -4096 && (int) gap <= 4095))
              distance_short_enough = 1;
            /* If shrinkable, then we can check for a range of distance which
               is two bytes farther on both the directions because the call
               or jump target will be closer by two bytes after the
               relaxation. */
            else if (shrinkable && ((int) gap >= -4094 && (int) gap <= 4097))
              distance_short_enough = 1;

            /* Here we handle the wrap-around case.  E.g. for a 16k device
               we could use a rjmp to jump from address 0x100 to 0x3d00!
               In order to make this work properly, we need to fill the
               vaiable avr_pc_wrap_around with the appropriate value.
               I.e. 0x4000 for a 16k device.  */
            {
	      /* Shrinking the code size makes the gaps larger in the
		 case of wrap-arounds.  So we use a heuristical safety
		 margin to avoid that during relax the distance gets
		 again too large for the short jumps.  Let's assume
		 a typical code-size reduction due to relax for a
		 16k device of 600 bytes.  So let's use twice the
		 typical value as safety margin.  */
	      int rgap;
	      int safety_margin;

	      int assumed_shrink = 600;
	      if (avr_pc_wrap_around > 0x4000)
		assumed_shrink = 900;

	      safety_margin = 2 * assumed_shrink;

	      rgap = avr_relative_distance_considering_wrap_around (gap);

	      if (rgap >= (-4092 + safety_margin)
		  && rgap <= (4094 - safety_margin))
		distance_short_enough = 1;
            }

            if (distance_short_enough)
              {
                unsigned char code_msb;
                unsigned char code_lsb;

                if (debug_relax)
                  printf ("shrinking jump/call instruction at address 0x%x"
                          " in section %s\n\n",
                          (int) dot, sec->name);

                /* Note that we've changed the relocs, section contents,
                   etc.  */
                elf_section_data (sec)->relocs = internal_relocs;
                elf_section_data (sec)->this_hdr.contents = contents;
                symtab_hdr->contents = (unsigned char *) isymbuf;

                /* Get the instruction code for relaxing.  */
                code_lsb = bfd_get_8 (abfd, contents + irel->r_offset);
                code_msb = bfd_get_8 (abfd, contents + irel->r_offset + 1);

                /* Mask out the relocation bits.  */
                code_msb &= 0x94;
                code_lsb &= 0x0E;
                if (code_msb == 0x94 && code_lsb == 0x0E)
                  {
                    /* we are changing call -> rcall .  */
                    bfd_put_8 (abfd, 0x00, contents + irel->r_offset);
                    bfd_put_8 (abfd, 0xD0, contents + irel->r_offset + 1);
                  }
                else if (code_msb == 0x94 && code_lsb == 0x0C)
                  {
                    /* we are changeing jump -> rjmp.  */
                    bfd_put_8 (abfd, 0x00, contents + irel->r_offset);
                    bfd_put_8 (abfd, 0xC0, contents + irel->r_offset + 1);
                  }
                else
                  abort ();

                /* Fix the relocation's type.  */
                irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
                                             R_AVR_13_PCREL);

                /* We should not modify the ordering if 'shrinkable' is
                   FALSE. */
                if (!shrinkable)
                  {
                    /* Let's insert a nop.  */
                    bfd_put_8 (abfd, 0x00, contents + irel->r_offset + 2);
                    bfd_put_8 (abfd, 0x00, contents + irel->r_offset + 3);
                  }
                else
                  {
                    /* Delete two bytes of data.  */
                    if (!elf32_avr_relax_delete_bytes (abfd, sec,
                                                       irel->r_offset + 2, 2))
                      goto error_return;

                    /* That will change things, so, we should relax again.
                       Note that this is not required, and it may be slow.  */
                    *again = TRUE;
                  }
              }
          }

        default:
          {
            unsigned char code_msb;
            unsigned char code_lsb;
            bfd_vma dot;

            code_msb = bfd_get_8 (abfd, contents + irel->r_offset + 1);
            code_lsb = bfd_get_8 (abfd, contents + irel->r_offset + 0);

            /* Get the address of this instruction.  */
            dot = (sec->output_section->vma
                   + sec->output_offset + irel->r_offset);

            /* Here we look for rcall/ret or call/ret sequences that could be
               safely replaced by rjmp/ret or jmp/ret.  */
            if (((code_msb & 0xf0) == 0xd0)
                && avr_replace_call_ret_sequences)
              {
                /* This insn is a rcall.  */
                unsigned char next_insn_msb = 0;
                unsigned char next_insn_lsb = 0;

                if (irel->r_offset + 3 < sec->size)
                  {
                    next_insn_msb =
		      bfd_get_8 (abfd, contents + irel->r_offset + 3);
                    next_insn_lsb =
		      bfd_get_8 (abfd, contents + irel->r_offset + 2);
                  }

		if ((0x95 == next_insn_msb) && (0x08 == next_insn_lsb))
                  {
                    /* The next insn is a ret. We now convert the rcall insn
                       into a rjmp instruction.  */
                    code_msb &= 0xef;
                    bfd_put_8 (abfd, code_msb, contents + irel->r_offset + 1);
                    if (debug_relax)
                      printf ("converted rcall/ret sequence at address 0x%x"
                              " into rjmp/ret sequence. Section is %s\n\n",
                              (int) dot, sec->name);
                    *again = TRUE;
                    break;
                  }
              }
            else if ((0x94 == (code_msb & 0xfe))
		     && (0x0e == (code_lsb & 0x0e))
		     && avr_replace_call_ret_sequences)
              {
                /* This insn is a call.  */
                unsigned char next_insn_msb = 0;
                unsigned char next_insn_lsb = 0;

                if (irel->r_offset + 5 < sec->size)
                  {
                    next_insn_msb =
		      bfd_get_8 (abfd, contents + irel->r_offset + 5);
                    next_insn_lsb =
		      bfd_get_8 (abfd, contents + irel->r_offset + 4);
                  }

                if ((0x95 == next_insn_msb) && (0x08 == next_insn_lsb))
                  {
                    /* The next insn is a ret. We now convert the call insn
                       into a jmp instruction.  */

                    code_lsb &= 0xfd;
                    bfd_put_8 (abfd, code_lsb, contents + irel->r_offset);
                    if (debug_relax)
                      printf ("converted call/ret sequence at address 0x%x"
                              " into jmp/ret sequence. Section is %s\n\n",
                              (int) dot, sec->name);
                    *again = TRUE;
                    break;
                  }
              }
            else if ((0xc0 == (code_msb & 0xf0))
                     || ((0x94 == (code_msb & 0xfe))
                         && (0x0c == (code_lsb & 0x0e))))
              {
                /* This insn is a rjmp or a jmp.  */
                unsigned char next_insn_msb = 0;
                unsigned char next_insn_lsb = 0;
                int insn_size;

                if (0xc0 == (code_msb & 0xf0))
                  insn_size = 2; /* rjmp insn */
                else
                  insn_size = 4; /* jmp insn */

                if (irel->r_offset + insn_size + 1 < sec->size)
                  {
                    next_insn_msb =
		      bfd_get_8 (abfd, contents + irel->r_offset
				 + insn_size + 1);
                    next_insn_lsb =
		      bfd_get_8 (abfd, contents + irel->r_offset
				 + insn_size);
                  }

                if ((0x95 == next_insn_msb) && (0x08 == next_insn_lsb))
                  {
                    /* The next insn is a ret. We possibly could delete
                       this ret. First we need to check for preceding
                       sbis/sbic/sbrs or cpse "skip" instructions.  */

                    int there_is_preceding_non_skip_insn = 1;
                    bfd_vma address_of_ret;

                    address_of_ret = dot + insn_size;

                    if (debug_relax && (insn_size == 2))
                      printf ("found rjmp / ret sequence at address 0x%x\n",
                              (int) dot);
                    if (debug_relax && (insn_size == 4))
                      printf ("found jmp / ret sequence at address 0x%x\n",
                              (int) dot);

                    /* We have to make sure that there is a preceding insn.  */
                    if (irel->r_offset >= 2)
                      {
                        unsigned char preceding_msb;
                        unsigned char preceding_lsb;

                        preceding_msb =
			  bfd_get_8 (abfd, contents + irel->r_offset - 1);
                        preceding_lsb =
			  bfd_get_8 (abfd, contents + irel->r_offset - 2);

                        /* sbic.  */
                        if (0x99 == preceding_msb)
                          there_is_preceding_non_skip_insn = 0;

                        /* sbis.  */
                        if (0x9b == preceding_msb)
                          there_is_preceding_non_skip_insn = 0;

                        /* sbrc */
                        if ((0xfc == (preceding_msb & 0xfe)
			     && (0x00 == (preceding_lsb & 0x08))))
                          there_is_preceding_non_skip_insn = 0;

                        /* sbrs */
                        if ((0xfe == (preceding_msb & 0xfe)
			     && (0x00 == (preceding_lsb & 0x08))))
                          there_is_preceding_non_skip_insn = 0;

                        /* cpse */
                        if (0x10 == (preceding_msb & 0xfc))
                          there_is_preceding_non_skip_insn = 0;

                        if (there_is_preceding_non_skip_insn == 0)
                          if (debug_relax)
                            printf ("preceding skip insn prevents deletion of"
                                    " ret insn at Addy 0x%x in section %s\n",
                                    (int) dot + 2, sec->name);
                      }
                    else
                      {
                        /* There is no previous instruction.  */
                        there_is_preceding_non_skip_insn = 0;
                      }

                    if (there_is_preceding_non_skip_insn)
                      {
                        /* We now only have to make sure that there is no
                           local label defined at the address of the ret
                           instruction and that there is no local relocation
                           in this section pointing to the ret.  */

                        int deleting_ret_is_safe = 1;
                        unsigned int section_offset_of_ret_insn =
			  irel->r_offset + insn_size;
                        Elf_Internal_Sym *isym, *isymend;
                        unsigned int sec_shndx;
			struct bfd_section *isec;

                        sec_shndx =
			  _bfd_elf_section_from_bfd_section (abfd, sec);

                        /* Check for local symbols.  */
                        isym = (Elf_Internal_Sym *) symtab_hdr->contents;
                        isymend = isym + symtab_hdr->sh_info;
			/* PR 6019: There may not be any local symbols.  */
                        for (; isym != NULL && isym < isymend; isym++)
			  {
			    if (isym->st_value == section_offset_of_ret_insn
				&& isym->st_shndx == sec_shndx)
			      {
				deleting_ret_is_safe = 0;
				if (debug_relax)
				  printf ("local label prevents deletion of ret "
					  "insn at address 0x%x\n",
					  (int) dot + insn_size);
			      }
			  }

			/* Now check for global symbols.  */
			{
			  int symcount;
			  struct elf_link_hash_entry **sym_hashes;
			  struct elf_link_hash_entry **end_hashes;

			  symcount = (symtab_hdr->sh_size
				      / sizeof (Elf32_External_Sym)
				      - symtab_hdr->sh_info);
			  sym_hashes = elf_sym_hashes (abfd);
			  end_hashes = sym_hashes + symcount;
			  for (; sym_hashes < end_hashes; sym_hashes++)
			    {
			      struct elf_link_hash_entry *sym_hash =
				*sym_hashes;
			      if ((sym_hash->root.type == bfd_link_hash_defined
				   || sym_hash->root.type ==
				   bfd_link_hash_defweak)
				  && sym_hash->root.u.def.section == sec
				  && sym_hash->root.u.def.value == section_offset_of_ret_insn)
				{
				  deleting_ret_is_safe = 0;
				  if (debug_relax)
				    printf ("global label prevents deletion of "
					    "ret insn at address 0x%x\n",
					    (int) dot + insn_size);
				}
			    }
			}

			/* Now we check for relocations pointing to ret.  */
			for (isec = abfd->sections; isec && deleting_ret_is_safe; isec = isec->next)
			  {
			    Elf_Internal_Rela *rel;
			    Elf_Internal_Rela *relend;
              
			    rel = elf_section_data (isec)->relocs;
			    if (rel == NULL)
			      rel = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL, TRUE);

			    relend = rel + isec->reloc_count;

			    for (; rel && rel < relend; rel++)
			      {
				bfd_vma reloc_target = 0;

				/* Read this BFD's local symbols if we haven't
				   done so already.  */
				if (isymbuf == NULL && symtab_hdr->sh_info != 0)
				  {
				    isymbuf = (Elf_Internal_Sym *)
				      symtab_hdr->contents;
				    if (isymbuf == NULL)
				      isymbuf = bfd_elf_get_elf_syms
					(abfd,
					 symtab_hdr,
					 symtab_hdr->sh_info, 0,
					 NULL, NULL, NULL);
				    if (isymbuf == NULL)
				      break;
				  }

				/* Get the value of the symbol referred to
				   by the reloc.  */
				if (ELF32_R_SYM (rel->r_info)
				    < symtab_hdr->sh_info)
				  {
				    /* A local symbol.  */
				    asection *sym_sec;

				    isym = isymbuf
				      + ELF32_R_SYM (rel->r_info);
				    sym_sec = bfd_section_from_elf_index
				      (abfd, isym->st_shndx);
				    symval = isym->st_value;

				    /* If the reloc is absolute, it will not
				       have a symbol or section associated
				       with it.  */

				    if (sym_sec)
				      {
					symval +=
					  sym_sec->output_section->vma
					  + sym_sec->output_offset;
					reloc_target = symval + rel->r_addend;
				      }
				    else
				      {
					reloc_target = symval + rel->r_addend;
					/* Reference symbol is absolute.  */
				      }
				  }
				/* else ... reference symbol is extern.  */

				if (address_of_ret == reloc_target)
				  {
				    deleting_ret_is_safe = 0;
				    if (debug_relax)
				      printf ("ret from "
					      "rjmp/jmp ret sequence at address"
					      " 0x%x could not be deleted. ret"
					      " is target of a relocation.\n",
					      (int) address_of_ret);
				    break;
				  }
			      }
			  }

			if (deleting_ret_is_safe)
			  {
			    if (debug_relax)
			      printf ("unreachable ret instruction "
				      "at address 0x%x deleted.\n",
				      (int) dot + insn_size);

			    /* Delete two bytes of data.  */
			    if (!elf32_avr_relax_delete_bytes (abfd, sec,
							       irel->r_offset + insn_size, 2))
			      goto error_return;

			    /* That will change things, so, we should relax
			       again. Note that this is not required, and it
			       may be slow.  */
			    *again = TRUE;
			    break;
			  }
                      }
                  }
              }
            break;
          }
        }
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (! link_info->keep_memory)
        free (contents);
      else
        {
          /* Cache the section contents for elf_link_input_bfd.  */
          elf_section_data (sec)->this_hdr.contents = contents;
        }
    }

  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return TRUE;

 error_return:
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);

  return FALSE;
}

/* This is a version of bfd_generic_get_relocated_section_contents
   which uses elf32_avr_relocate_section.

   For avr it's essentially a cut and paste taken from the H8300 port.
   The author of the relaxation support patch for avr had absolutely no
   clue what is happening here but found out that this part of the code
   seems to be important.  */

static bfd_byte *
elf32_avr_get_relocated_section_contents (bfd *output_bfd,
                                          struct bfd_link_info *link_info,
                                          struct bfd_link_order *link_order,
                                          bfd_byte *data,
                                          bfd_boolean relocatable,
                                          asymbol **symbols)
{
  Elf_Internal_Shdr *symtab_hdr;
  asection *input_section = link_order->u.indirect.section;
  bfd *input_bfd = input_section->owner;
  asection **sections = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Sym *isymbuf = NULL;

  /* We only need to handle the case of relaxing, or of having a
     particular set of section contents, specially.  */
  if (relocatable
      || elf_section_data (input_section)->this_hdr.contents == NULL)
    return bfd_generic_get_relocated_section_contents (output_bfd, link_info,
                                                       link_order, data,
                                                       relocatable,
                                                       symbols);
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;

  memcpy (data, elf_section_data (input_section)->this_hdr.contents,
          (size_t) input_section->size);

  if ((input_section->flags & SEC_RELOC) != 0
      && input_section->reloc_count > 0)
    {
      asection **secpp;
      Elf_Internal_Sym *isym, *isymend;
      bfd_size_type amt;

      internal_relocs = (_bfd_elf_link_read_relocs
                         (input_bfd, input_section, NULL, NULL, FALSE));
      if (internal_relocs == NULL)
        goto error_return;

      if (symtab_hdr->sh_info != 0)
        {
          isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
          if (isymbuf == NULL)
            isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
                                            symtab_hdr->sh_info, 0,
                                            NULL, NULL, NULL);
          if (isymbuf == NULL)
            goto error_return;
        }

      amt = symtab_hdr->sh_info;
      amt *= sizeof (asection *);
      sections = bfd_malloc (amt);
      if (sections == NULL && amt != 0)
        goto error_return;

      isymend = isymbuf + symtab_hdr->sh_info;
      for (isym = isymbuf, secpp = sections; isym < isymend; ++isym, ++secpp)
        {
          asection *isec;

          if (isym->st_shndx == SHN_UNDEF)
            isec = bfd_und_section_ptr;
          else if (isym->st_shndx == SHN_ABS)
            isec = bfd_abs_section_ptr;
          else if (isym->st_shndx == SHN_COMMON)
            isec = bfd_com_section_ptr;
          else
            isec = bfd_section_from_elf_index (input_bfd, isym->st_shndx);

          *secpp = isec;
        }

      if (! elf32_avr_relocate_section (output_bfd, link_info, input_bfd,
                                        input_section, data, internal_relocs,
                                        isymbuf, sections))
        goto error_return;

      if (sections != NULL)
        free (sections);
      if (isymbuf != NULL
          && symtab_hdr->contents != (unsigned char *) isymbuf)
        free (isymbuf);
      if (elf_section_data (input_section)->relocs != internal_relocs)
        free (internal_relocs);
    }

  return data;

 error_return:
  if (sections != NULL)
    free (sections);
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    free (isymbuf);
  if (internal_relocs != NULL
      && elf_section_data (input_section)->relocs != internal_relocs)
    free (internal_relocs);
  return NULL;
}


/* Determines the hash entry name for a particular reloc. It consists of
   the identifier of the symbol section and the added reloc addend and
   symbol offset relative to the section the symbol is attached to.  */

static char *
avr_stub_name (const asection *symbol_section,
               const bfd_vma symbol_offset,
               const Elf_Internal_Rela *rela)
{
  char *stub_name;
  bfd_size_type len;

  len = 8 + 1 + 8 + 1 + 1;
  stub_name = bfd_malloc (len);

  sprintf (stub_name, "%08x+%08x",
           symbol_section->id & 0xffffffff,
           (unsigned int) ((rela->r_addend & 0xffffffff) + symbol_offset));

  return stub_name;
}


/* Add a new stub entry to the stub hash.  Not all fields of the new
   stub entry are initialised.  */

static struct elf32_avr_stub_hash_entry *
avr_add_stub (const char *stub_name,
              struct elf32_avr_link_hash_table *htab)
{
  struct elf32_avr_stub_hash_entry *hsh;

  /* Enter this entry into the linker stub hash table.  */
  hsh = avr_stub_hash_lookup (&htab->bstab, stub_name, TRUE, FALSE);

  if (hsh == NULL)
    {
      (*_bfd_error_handler) (_("%B: cannot create stub entry %s"),
                             NULL, stub_name);
      return NULL;
    }

  hsh->stub_offset = 0;
  return hsh;
}

/* We assume that there is already space allocated for the stub section
   contents and that before building the stubs the section size is
   initialized to 0.  We assume that within the stub hash table entry,
   the absolute position of the jmp target has been written in the
   target_value field.  We write here the offset of the generated jmp insn
   relative to the trampoline section start to the stub_offset entry in
   the stub hash table entry.  */

static  bfd_boolean
avr_build_one_stub (struct bfd_hash_entry *bh, void *in_arg)
{
  struct elf32_avr_stub_hash_entry *hsh;
  struct bfd_link_info *info;
  struct elf32_avr_link_hash_table *htab;
  bfd *stub_bfd;
  bfd_byte *loc;
  bfd_vma target;
  bfd_vma starget;

  /* Basic opcode */
  bfd_vma jmp_insn = 0x0000940c;

  /* Massage our args to the form they really have.  */
  hsh = avr_stub_hash_entry (bh);

  if (!hsh->is_actually_needed)
    return TRUE;

  info = (struct bfd_link_info *) in_arg;

  htab = avr_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  target = hsh->target_value;

  /* Make a note of the offset within the stubs for this entry.  */
  hsh->stub_offset = htab->stub_sec->size;
  loc = htab->stub_sec->contents + hsh->stub_offset;

  stub_bfd = htab->stub_sec->owner;

  if (debug_stubs)
    printf ("Building one Stub. Address: 0x%x, Offset: 0x%x\n",
             (unsigned int) target,
             (unsigned int) hsh->stub_offset);

  /* We now have to add the information on the jump target to the bare
     opcode bits already set in jmp_insn.  */

  /* Check for the alignment of the address.  */
  if (target & 1)
     return FALSE;

  starget = target >> 1;
  jmp_insn |= ((starget & 0x10000) | ((starget << 3) & 0x1f00000)) >> 16;
  bfd_put_16 (stub_bfd, jmp_insn, loc);
  bfd_put_16 (stub_bfd, (bfd_vma) starget & 0xffff, loc + 2);

  htab->stub_sec->size += 4;

  /* Now add the entries in the address mapping table if there is still
     space left.  */
  {
    unsigned int nr;

    nr = htab->amt_entry_cnt + 1;
    if (nr <= htab->amt_max_entry_cnt)
      {
        htab->amt_entry_cnt = nr;

        htab->amt_stub_offsets[nr - 1] = hsh->stub_offset;
        htab->amt_destination_addr[nr - 1] = target;
      }
  }

  return TRUE;
}

static bfd_boolean
avr_mark_stub_not_to_be_necessary (struct bfd_hash_entry *bh,
                                   void *in_arg ATTRIBUTE_UNUSED)
{
  struct elf32_avr_stub_hash_entry *hsh;

  hsh = avr_stub_hash_entry (bh);
  hsh->is_actually_needed = FALSE;

  return TRUE;
}

static bfd_boolean
avr_size_one_stub (struct bfd_hash_entry *bh, void *in_arg)
{
  struct elf32_avr_stub_hash_entry *hsh;
  struct elf32_avr_link_hash_table *htab;
  int size;

  /* Massage our args to the form they really have.  */
  hsh = avr_stub_hash_entry (bh);
  htab = in_arg;

  if (hsh->is_actually_needed)
    size = 4;
  else
    size = 0;

  htab->stub_sec->size += size;
  return TRUE;
}

void
elf32_avr_setup_params (struct bfd_link_info *info,
                        bfd *avr_stub_bfd,
                        asection *avr_stub_section,
                        bfd_boolean no_stubs,
                        bfd_boolean deb_stubs,
                        bfd_boolean deb_relax,
                        bfd_vma pc_wrap_around,
                        bfd_boolean call_ret_replacement)
{
  struct elf32_avr_link_hash_table *htab = avr_link_hash_table (info);

  if (htab == NULL)
    return;
  htab->stub_sec = avr_stub_section;
  htab->stub_bfd = avr_stub_bfd;
  htab->no_stubs = no_stubs;

  debug_relax = deb_relax;
  debug_stubs = deb_stubs;
  avr_pc_wrap_around = pc_wrap_around;
  avr_replace_call_ret_sequences = call_ret_replacement;
}


/* Set up various things so that we can make a list of input sections
   for each output section included in the link.  Returns -1 on error,
   0 when no stubs will be needed, and 1 on success.  It also sets
   information on the stubs bfd and the stub section in the info
   struct.  */

int
elf32_avr_setup_section_lists (bfd *output_bfd,
                               struct bfd_link_info *info)
{
  bfd *input_bfd;
  unsigned int bfd_count;
  int top_id, top_index;
  asection *section;
  asection **input_list, **list;
  bfd_size_type amt;
  struct elf32_avr_link_hash_table *htab = avr_link_hash_table (info);

  if (htab == NULL || htab->no_stubs)
    return 0;

  /* Count the number of input BFDs and find the top input section id.  */
  for (input_bfd = info->input_bfds, bfd_count = 0, top_id = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    {
      bfd_count += 1;
      for (section = input_bfd->sections;
           section != NULL;
           section = section->next)
	if (top_id < section->id)
	  top_id = section->id;
    }

  htab->bfd_count = bfd_count;

  /* We can't use output_bfd->section_count here to find the top output
     section index as some sections may have been removed, and
     strip_excluded_output_sections doesn't renumber the indices.  */
  for (section = output_bfd->sections, top_index = 0;
       section != NULL;
       section = section->next)
    if (top_index < section->index)
      top_index = section->index;

  htab->top_index = top_index;
  amt = sizeof (asection *) * (top_index + 1);
  input_list = bfd_malloc (amt);
  htab->input_list = input_list;
  if (input_list == NULL)
    return -1;

  /* For sections we aren't interested in, mark their entries with a
     value we can check later.  */
  list = input_list + top_index;
  do
    *list = bfd_abs_section_ptr;
  while (list-- != input_list);

  for (section = output_bfd->sections;
       section != NULL;
       section = section->next)
    if ((section->flags & SEC_CODE) != 0)
      input_list[section->index] = NULL;

  return 1;
}


/* Read in all local syms for all input bfds, and create hash entries
   for export stubs if we are building a multi-subspace shared lib.
   Returns -1 on error, 0 otherwise.  */

static int
get_local_syms (bfd *input_bfd, struct bfd_link_info *info)
{
  unsigned int bfd_indx;
  Elf_Internal_Sym *local_syms, **all_local_syms;
  struct elf32_avr_link_hash_table *htab = avr_link_hash_table (info);
  bfd_size_type amt;

  if (htab == NULL)
    return -1;

  /* We want to read in symbol extension records only once.  To do this
     we need to read in the local symbols in parallel and save them for
     later use; so hold pointers to the local symbols in an array.  */
  amt = sizeof (Elf_Internal_Sym *) * htab->bfd_count;
  all_local_syms = bfd_zmalloc (amt);
  htab->all_local_syms = all_local_syms;
  if (all_local_syms == NULL)
    return -1;

  /* Walk over all the input BFDs, swapping in local symbols.
     If we are creating a shared library, create hash entries for the
     export stubs.  */
  for (bfd_indx = 0;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next, bfd_indx++)
    {
      Elf_Internal_Shdr *symtab_hdr;

      /* We'll need the symbol table in a second.  */
      symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
      if (symtab_hdr->sh_info == 0)
	continue;

      /* We need an array of the local symbols attached to the input bfd.  */
      local_syms = (Elf_Internal_Sym *) symtab_hdr->contents;
      if (local_syms == NULL)
	{
	  local_syms = bfd_elf_get_elf_syms (input_bfd, symtab_hdr,
					     symtab_hdr->sh_info, 0,
					     NULL, NULL, NULL);
	  /* Cache them for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) local_syms;
	}
      if (local_syms == NULL)
	return -1;

      all_local_syms[bfd_indx] = local_syms;
    }

  return 0;
}

#define ADD_DUMMY_STUBS_FOR_DEBUGGING 0

bfd_boolean
elf32_avr_size_stubs (bfd *output_bfd,
                      struct bfd_link_info *info,
                      bfd_boolean is_prealloc_run)
{
  struct elf32_avr_link_hash_table *htab;
  int stub_changed = 0;

  htab = avr_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* At this point we initialize htab->vector_base
     To the start of the text output section.  */
  htab->vector_base = htab->stub_sec->output_section->vma;

  if (get_local_syms (info->input_bfds, info))
    {
      if (htab->all_local_syms)
	goto error_ret_free_local;
      return FALSE;
    }

  if (ADD_DUMMY_STUBS_FOR_DEBUGGING)
    {
      struct elf32_avr_stub_hash_entry *test;

      test = avr_add_stub ("Hugo",htab);
      test->target_value = 0x123456;
      test->stub_offset = 13;

      test = avr_add_stub ("Hugo2",htab);
      test->target_value = 0x84210;
      test->stub_offset = 14;
    }

  while (1)
    {
      bfd *input_bfd;
      unsigned int bfd_indx;

      /* We will have to re-generate the stub hash table each time anything
         in memory has changed.  */

      bfd_hash_traverse (&htab->bstab, avr_mark_stub_not_to_be_necessary, htab);
      for (input_bfd = info->input_bfds, bfd_indx = 0;
           input_bfd != NULL;
           input_bfd = input_bfd->link_next, bfd_indx++)
        {
          Elf_Internal_Shdr *symtab_hdr;
          asection *section;
          Elf_Internal_Sym *local_syms;

          /* We'll need the symbol table in a second.  */
          symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
          if (symtab_hdr->sh_info == 0)
            continue;

          local_syms = htab->all_local_syms[bfd_indx];

          /* Walk over each section attached to the input bfd.  */
          for (section = input_bfd->sections;
               section != NULL;
               section = section->next)
            {
              Elf_Internal_Rela *internal_relocs, *irelaend, *irela;

              /* If there aren't any relocs, then there's nothing more
                 to do.  */
              if ((section->flags & SEC_RELOC) == 0
                  || section->reloc_count == 0)
                continue;

              /* If this section is a link-once section that will be
                 discarded, then don't create any stubs.  */
              if (section->output_section == NULL
                  || section->output_section->owner != output_bfd)
                continue;

              /* Get the relocs.  */
              internal_relocs
                = _bfd_elf_link_read_relocs (input_bfd, section, NULL, NULL,
                                             info->keep_memory);
              if (internal_relocs == NULL)
                goto error_ret_free_local;

              /* Now examine each relocation.  */
              irela = internal_relocs;
              irelaend = irela + section->reloc_count;
              for (; irela < irelaend; irela++)
                {
                  unsigned int r_type, r_indx;
                  struct elf32_avr_stub_hash_entry *hsh;
                  asection *sym_sec;
                  bfd_vma sym_value;
                  bfd_vma destination;
                  struct elf_link_hash_entry *hh;
                  char *stub_name;

                  r_type = ELF32_R_TYPE (irela->r_info);
                  r_indx = ELF32_R_SYM (irela->r_info);

                  /* Only look for 16 bit GS relocs. No other reloc will need a
                     stub.  */
                  if (!((r_type == R_AVR_16_PM)
                        || (r_type == R_AVR_LO8_LDI_GS)
                        || (r_type == R_AVR_HI8_LDI_GS)))
                    continue;

                  /* Now determine the call target, its name, value,
                     section.  */
                  sym_sec = NULL;
                  sym_value = 0;
                  destination = 0;
                  hh = NULL;
                  if (r_indx < symtab_hdr->sh_info)
                    {
                      /* It's a local symbol.  */
                      Elf_Internal_Sym *sym;
                      Elf_Internal_Shdr *hdr;
		      unsigned int shndx;

                      sym = local_syms + r_indx;
                      if (ELF_ST_TYPE (sym->st_info) != STT_SECTION)
                        sym_value = sym->st_value;
		      shndx = sym->st_shndx;
		      if (shndx < elf_numsections (input_bfd))
			{
			  hdr = elf_elfsections (input_bfd)[shndx];
			  sym_sec = hdr->bfd_section;
			  destination = (sym_value + irela->r_addend
					 + sym_sec->output_offset
					 + sym_sec->output_section->vma);
			}
                    }
                  else
                    {
                      /* It's an external symbol.  */
                      int e_indx;

                      e_indx = r_indx - symtab_hdr->sh_info;
                      hh = elf_sym_hashes (input_bfd)[e_indx];

                      while (hh->root.type == bfd_link_hash_indirect
                             || hh->root.type == bfd_link_hash_warning)
                        hh = (struct elf_link_hash_entry *)
                              (hh->root.u.i.link);

                      if (hh->root.type == bfd_link_hash_defined
                          || hh->root.type == bfd_link_hash_defweak)
                        {
                          sym_sec = hh->root.u.def.section;
                          sym_value = hh->root.u.def.value;
                          if (sym_sec->output_section != NULL)
                          destination = (sym_value + irela->r_addend
                                         + sym_sec->output_offset
                                         + sym_sec->output_section->vma);
                        }
                      else if (hh->root.type == bfd_link_hash_undefweak)
                        {
                          if (! info->shared)
                            continue;
                        }
                      else if (hh->root.type == bfd_link_hash_undefined)
                        {
                          if (! (info->unresolved_syms_in_objects == RM_IGNORE
                                 && (ELF_ST_VISIBILITY (hh->other)
                                     == STV_DEFAULT)))
                             continue;
                        }
                      else
                        {
                          bfd_set_error (bfd_error_bad_value);

                          error_ret_free_internal:
                          if (elf_section_data (section)->relocs == NULL)
                            free (internal_relocs);
                          goto error_ret_free_local;
                        }
                    }

                  if (! avr_stub_is_required_for_16_bit_reloc
		      (destination - htab->vector_base))
                    {
                      if (!is_prealloc_run)
			/* We are having a reloc that does't need a stub.  */
			continue;

		      /* We don't right now know if a stub will be needed.
			 Let's rather be on the safe side.  */
                    }

                  /* Get the name of this stub.  */
                  stub_name = avr_stub_name (sym_sec, sym_value, irela);

                  if (!stub_name)
                    goto error_ret_free_internal;


                  hsh = avr_stub_hash_lookup (&htab->bstab,
                                              stub_name,
                                              FALSE, FALSE);
                  if (hsh != NULL)
                    {
                      /* The proper stub has already been created.  Mark it
                         to be used and write the possibly changed destination
                         value.  */
                      hsh->is_actually_needed = TRUE;
                      hsh->target_value = destination;
                      free (stub_name);
                      continue;
                    }

                  hsh = avr_add_stub (stub_name, htab);
                  if (hsh == NULL)
                    {
                      free (stub_name);
                      goto error_ret_free_internal;
                    }

                  hsh->is_actually_needed = TRUE;
                  hsh->target_value = destination;

                  if (debug_stubs)
                    printf ("Adding stub with destination 0x%x to the"
                            " hash table.\n", (unsigned int) destination);
                  if (debug_stubs)
                    printf ("(Pre-Alloc run: %i)\n", is_prealloc_run);

                  stub_changed = TRUE;
                }

              /* We're done with the internal relocs, free them.  */
              if (elf_section_data (section)->relocs == NULL)
                free (internal_relocs);
            }
        }

      /* Re-Calculate the number of needed stubs.  */
      htab->stub_sec->size = 0;
      bfd_hash_traverse (&htab->bstab, avr_size_one_stub, htab);

      if (!stub_changed)
        break;

      stub_changed = FALSE;
    }

  free (htab->all_local_syms);
  return TRUE;

 error_ret_free_local:
  free (htab->all_local_syms);
  return FALSE;
}


/* Build all the stubs associated with the current output file.  The
   stubs are kept in a hash table attached to the main linker hash
   table.  We also set up the .plt entries for statically linked PIC
   functions here.  This function is called via hppaelf_finish in the
   linker.  */

bfd_boolean
elf32_avr_build_stubs (struct bfd_link_info *info)
{
  asection *stub_sec;
  struct bfd_hash_table *table;
  struct elf32_avr_link_hash_table *htab;
  bfd_size_type total_size = 0;

  htab = avr_link_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* In case that there were several stub sections:  */
  for (stub_sec = htab->stub_bfd->sections;
       stub_sec != NULL;
       stub_sec = stub_sec->next)
    {
      bfd_size_type size;

      /* Allocate memory to hold the linker stubs.  */
      size = stub_sec->size;
      total_size += size;

      stub_sec->contents = bfd_zalloc (htab->stub_bfd, size);
      if (stub_sec->contents == NULL && size != 0)
	return FALSE;
      stub_sec->size = 0;
    }

  /* Allocate memory for the adress mapping table.  */
  htab->amt_entry_cnt = 0;
  htab->amt_max_entry_cnt = total_size / 4;
  htab->amt_stub_offsets = bfd_malloc (sizeof (bfd_vma)
                                       * htab->amt_max_entry_cnt);
  htab->amt_destination_addr = bfd_malloc (sizeof (bfd_vma)
					   * htab->amt_max_entry_cnt );

  if (debug_stubs)
    printf ("Allocating %i entries in the AMT\n", htab->amt_max_entry_cnt);

  /* Build the stubs as directed by the stub hash table.  */
  table = &htab->bstab;
  bfd_hash_traverse (table, avr_build_one_stub, info);

  if (debug_stubs)
    printf ("Final Stub section Size: %i\n", (int) htab->stub_sec->size);

  return TRUE;
}

#define ELF_ARCH		bfd_arch_avr
#define ELF_TARGET_ID		AVR_ELF_DATA
#define ELF_MACHINE_CODE	EM_AVR
#define ELF_MACHINE_ALT1	EM_AVR_OLD
#define ELF_MAXPAGESIZE		1

#define TARGET_LITTLE_SYM       bfd_elf32_avr_vec
#define TARGET_LITTLE_NAME	"elf32-avr"

#define bfd_elf32_bfd_link_hash_table_create elf32_avr_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free   elf32_avr_link_hash_table_free

#define elf_info_to_howto	             avr_info_to_howto_rela
#define elf_info_to_howto_rel	             NULL
#define elf_backend_relocate_section         elf32_avr_relocate_section
#define elf_backend_can_gc_sections          1
#define elf_backend_rela_normal		     1
#define elf_backend_final_write_processing \
					bfd_elf_avr_final_write_processing
#define elf_backend_object_p		elf32_avr_object_p

#define bfd_elf32_bfd_relax_section elf32_avr_relax_section
#define bfd_elf32_bfd_get_relocated_section_contents \
                                        elf32_avr_get_relocated_section_contents

#include "elf32-target.h"
@


1.61
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@d2 1
a2 3
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012
   Free Software Foundation, Inc.
d2139 1
d2190 1
d2192 8
a2199 3
			{
			  Elf_Internal_Rela *rel;
			  Elf_Internal_Rela *relend;
d2201 1
a2201 2
			  relend = elf_section_data (sec)->relocs
			    + sec->reloc_count;
d2203 3
a2205 4
			  for (rel = elf_section_data (sec)->relocs;
			       rel < relend; rel++)
			    {
			      bfd_vma reloc_target = 0;
d2207 58
a2264 13
			      /* Read this BFD's local symbols if we haven't
				 done so already.  */
			      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
				{
				  isymbuf = (Elf_Internal_Sym *)
				    symtab_hdr->contents;
				  if (isymbuf == NULL)
				    isymbuf = bfd_elf_get_elf_syms
				      (abfd,
				       symtab_hdr,
				       symtab_hdr->sh_info, 0,
				       NULL, NULL, NULL);
				  if (isymbuf == NULL)
d2266 3
a2268 47
				}

			      /* Get the value of the symbol referred to
				 by the reloc.  */
			      if (ELF32_R_SYM (rel->r_info)
				  < symtab_hdr->sh_info)
				{
				  /* A local symbol.  */
				  asection *sym_sec;

				  isym = isymbuf
				    + ELF32_R_SYM (rel->r_info);
				  sym_sec = bfd_section_from_elf_index
				    (abfd, isym->st_shndx);
				  symval = isym->st_value;

				  /* If the reloc is absolute, it will not
				     have a symbol or section associated
				     with it.  */

				  if (sym_sec)
				    {
				      symval +=
					sym_sec->output_section->vma
					+ sym_sec->output_offset;
				      reloc_target = symval + rel->r_addend;
				    }
				  else
				    {
				      reloc_target = symval + rel->r_addend;
				      /* Reference symbol is absolute.  */
				    }
				}
			      /* else ... reference symbol is extern.  */

			      if (address_of_ret == reloc_target)
				{
				  deleting_ret_is_safe = 0;
				  if (debug_relax)
				    printf ("ret from "
					    "rjmp/jmp ret sequence at address"
					    " 0x%x could not be deleted. ret"
					    " is target of a relocation.\n",
					    (int) address_of_ret);
				}
			    }
			}
a2288 1

@


1.60
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d711 1
a711 1
  _bfd_generic_link_hash_table_free (btab);
@


1.59
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d675 1
a675 1
  htab = bfd_malloc (amt);
a692 9
  htab->stub_bfd = NULL;
  htab->stub_sec = NULL;

  /* Initialize the address mapping table.  */
  htab->amt_stub_offsets = NULL;
  htab->amt_destination_addr = NULL;
  htab->amt_entry_cnt = 0;
  htab->amt_max_entry_cnt = 0;

@


1.58
log
@2012-07-24  Jan Waclawek <konfera@@efton.sk>
	PR 13899
	* elf32-avr.c (elf32_avr_relax_delete_bytes): Call
	_bfd_elf_link_read_relocs with keep_memory as TRUE.
@
text
@d1706 2
a1707 2
     relaxing. Such shrinking can cause issues for the sections such 
     as .vectors and .jumptables. Instead the unused bytes should be 
d1878 1
a1878 1
               or jump target will be closer by two bytes after the 
d1955 1
a1955 1
                   FALSE. */ 
@


1.57
log
@	PR 13503
	* reloc.c: Rename BFD_RELOC_AVR_8_HHI to BFD_RELOC_AVR_8_HLO.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenrate.
	* elf32-avr.c (elf_avr_howto_table): Rename R_AVR_8_HHI8 to
	R_AVR_8_HLO8.
	(avr_reloc_map): Ditto.

	* config/tc-avr.c (avr_cons_fix_new): Rename R_AVR_8_HHI8 to
	R_AVR_8_HLO8.
	(exp_mod_data) Ditto. And replace "hhi8" with "hlo8".
	(md_apply_fix): Rename BFD_RELOC_AVR_8_HHI to BFD_RELOC_AVR_8_HLO.

	* avr.h (RELOC_NUMBERS): Rename R_AVR_8_HHI8 to R_AVR_8_HLO8.
@
text
@d1561 1
a1561 1
	 irel = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL, FALSE);
a1619 3

       if (elf_section_data (isec)->relocs == NULL)
	 free (irelend - isec->reloc_count);
@


1.56
log
@	PR 13503
	* reloc.c: Add new ENUM for BFD_RELOC_AVR_8_LO,
	BFD_RELOC_AVR_8_HI, BFD_RELOC_AVR_8_HHI.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenrate.
	* elf32-avr.c (elf_avr_howto_table): Add entries for
	R_AVR_8_LO8, R_AVR_8_HI8, R_AVR_8_HHI8.
	(avr_reloc_map): Add RELOC mappings for R_AVR_8_LO8, R_AVR_8_HI8,
	R_AVR_8_HHI8.

	* config/tc-avr.c (exp_mod_pm): Remove variable.
	(exp_mod_data_t): New typedef.
	(pexp_mod_data, exp_mod_data): New variables.
	(avr_parse_cons_expression): Scan through exp_mod_data[] to find
	data expression modifiers "pm", "gs", "lo8", hi8", "hhi8", "hh8"
	and set pexp_mod_data accordingly to be used in avr_cons_fix_new.
	(avr_cons_fix_new): Handle new data expression modifiers shipped
	in pexp_mod_data.
	(md_apply_fix): Handle BFD_RELOC_AVR_8_LO, BFD_RELOC_AVR_8_HI,
	BFD_RELOC_AVR_8_HHI.

	* elf/avr.h (RELOC_NUMBERS): Add values for R_AVR_8_LO8,
	R_AVR_8_HI8, R_AVR_8_HHI8.
@
text
@d548 2
a549 2
  /* hhi8-part to use in  .byte hhi8(sym).  */
  HOWTO (R_AVR_8_HHI8,		/* type */
d557 1
a557 1
	 "R_AVR_8_HHI8",	/* name */
d603 1
a603 1
  { BFD_RELOC_AVR_8_HHI,            R_AVR_8_HHI8 }
@


1.55
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d520 42
d600 4
a603 1
  { BFD_RELOC_8,                    R_AVR_8 }
@


1.54
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1195 1
a1195 1
					 rel, relend, howto, contents);
@


1.53
log
@2012-02-02  Vidya Praveen (vidya.praveen@@atmel.com)

	PR bfd/13410
	* bfd/elf32-avr.c (elf32_avr_relax_section): Correct the
	condition that qualifies the candidates for relaxation.
@
text
@d3 2
a4 1
   2010, 2011  Free Software Foundation, Inc.
d1193 1
a1193 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.52
log
@	PR ld/12161
	* elf32-avr.c (elf32_avr_relax_delete_bytes): Read in relocs if
	necessary.
@
text
@d1662 10
d1828 10
a1837 4
            /* If the distance is within -4094..+4098 inclusive, then we can
               relax this jump/call.  +4098 because the call/jump target
               will be closer after the relaxation.  */
            if ((int) gap >= -4094 && (int) gap <= 4098)
d1911 3
a1913 5
                /* Check for the vector section. There we don't want to
                   modify the ordering!  */

                if (!strcmp (sec->name,".vectors")
                    || !strcmp (sec->name,".jumptables"))
@


1.51
log
@Fix spelling mistakes.
@
text
@d1506 3
d1512 6
a1517 2
       irelend = elf_section_data (isec)->relocs + isec->reloc_count;
       for (irel = elf_section_data (isec)->relocs;
d1574 3
@


1.51.2.1
log
@	* Import this patch from the mainline:
	2012-01-05  Nick Clifton  <nickc@@redhat.com>

	PR ld/12161
	* elf32-avr.c (elf32_avr_relax_delete_bytes): Read in relocs if
	necessary.
@
text
@a1505 3
       if (isec->reloc_count == 0)
	 continue;

d1509 2
a1510 6
       irel = elf_section_data (isec)->relocs;
       /* PR 12161: Read in the relocs for this section if necessary.  */
       if (irel == NULL)
	 irel = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL, FALSE);

       for (irelend = irel + isec->reloc_count;
a1566 3

       if (elf_section_data (isec)->relocs == NULL)
	 free (irelend - isec->reloc_count);
@


1.51.2.2
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1192 1
a1192 1
      if (sec != NULL && discarded_section (sec))
@


1.50
log
@/bfd:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* archures.c: Add AVR XMEGA architecture information.
	* cpu-avr.c (arch_info_struct): Likewise.
	* elf32-avr.c (bfd_elf_avr_final_write_processing): Likewise.
	(elf32_avr_object_p): Likewise.

/gas:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* config/tc-avr.c (struct avr_opcodes_s): Add opcode field.
	(AVR_INSN): Change definition to match.
	(avr_opcodes): Likewise, change to match.
	(mcu_types): Add XMEGA architecture names and new XMEGA device names.
	(md_show_usage): Add XMEGA architecture names.
	(avr_operand): Add 'E' constraint for DES instruction of XMEGA devices.
	Add support for SPM Z+ instruction.
	* doc/c-avr.texi: Add documentation for XMEGA architectures and
	devices.

/include/opcode:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* avr.h (AVR_ISA_SPMX,AVR_ISA_DES,AVR_ISA_M256,AVR_ISA_XMEGA):
	New instruction set flags.
	(AVR_INSN): Add new instructions for SPM Z+, DES for XMEGA.

/ld:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* Makefile.am (ALL_EMULATION_SOURCES): Add AVR XMEGA architectures.
	(eavrxmega?.c): Likewise.
	* configure.tgt (targ_extra_emuls): Likewise.
	* emulparams/avrxmega1.sh: New file.
	* emulparams/avrxmega2.sh: Likewise.
	* emulparams/avrxmega3.sh: Likewise.
	* emulparams/avrxmega4.sh: Likewise.
	* emulparams/avrxmega5.sh: Likewise.
	* emulparams/avrxmega6.sh: Likewise.
	* emulparams/avrxmega7.sh: Likewise.
	* emultempl/avrelf.em (avr_elf_${EMULATION_NAME}_before_allocation):
	Add avrxmega6, avrxmega7 to list of architectures for no stubs.

/opcodes:
2011-03-22  Eric B. Weddington  <eric.weddington@@atmel.com>

	* avr-dis.c (avr_operand): Add opcode_str parameter. Check for
	post-increment to support LPM Z+ instruction. Add support for 'E'
	constraint for DES instruction.
	(print_insn_avr): Adjust calls to avr_operand. Rename variable.
@
text
@d3 1
a3 1
   2010  Free Software Foundation, Inc.
d2011 1
a2011 1
                       this ret. First we need to check for preceeding
d2014 1
a2014 1
                    int there_is_preceeding_non_skip_insn = 1;
d2026 1
a2026 1
                    /* We have to make sure that there is a preceeding insn.  */
d2029 4
a2032 3
                        unsigned char preceeding_msb;
                        unsigned char preceeding_lsb;
                        preceeding_msb =
d2034 1
a2034 1
                        preceeding_lsb =
d2038 2
a2039 2
                        if (0x99 == preceeding_msb)
                          there_is_preceeding_non_skip_insn = 0;
d2042 2
a2043 2
                        if (0x9b == preceeding_msb)
                          there_is_preceeding_non_skip_insn = 0;
d2046 3
a2048 3
                        if ((0xfc == (preceeding_msb & 0xfe)
			     && (0x00 == (preceeding_lsb & 0x08))))
                          there_is_preceeding_non_skip_insn = 0;
d2051 3
a2053 3
                        if ((0xfe == (preceeding_msb & 0xfe)
			     && (0x00 == (preceeding_lsb & 0x08))))
                          there_is_preceeding_non_skip_insn = 0;
d2056 2
a2057 2
                        if (0x10 == (preceeding_msb & 0xfc))
                          there_is_preceeding_non_skip_insn = 0;
d2059 1
a2059 1
                        if (there_is_preceeding_non_skip_insn == 0)
d2061 2
a2062 2
                            printf ("preceeding skip insn prevents deletion of"
                                    " ret insn at addr 0x%x in section %s\n",
d2068 1
a2068 1
                        there_is_preceeding_non_skip_insn = 0;
d2071 1
a2071 1
                    if (there_is_preceeding_non_skip_insn)
@


1.49
log
@	PR ld/12161
	* elf32-avr.c (elf32_avr_check_relocs): Delete.
	(elf_backend_check_relocs): Delete.
@
text
@d1301 28
d1391 28
@


1.48
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@a736 42
/* Look through the relocs for a section during the first phase.
   Since we don't do .gots or .plts, we just need to consider the
   virtual table relocs for gc.  */

static bfd_boolean
elf32_avr_check_relocs (bfd *abfd,
			struct bfd_link_info *info,
			asection *sec,
			const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}
    }

  return TRUE;
}

a2958 1
#define elf_backend_check_relocs             elf32_avr_check_relocs
@


1.47
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d1235 2
a1236 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.46
log
@fix set but unused variable warnings
@
text
@d2994 1
@


1.45
log
@PR 11297: Add support for 8-bit relocations to the AVR toolchain.
@
text
@d1207 1
a1207 1
      howto  = elf_avr_howto_table + ELF32_R_TYPE (rel->r_info);
a1433 1
  Elf_Internal_Rela *irelalign;
a1444 4
  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
a1459 1
      bfd_vma shrinked_insn_address;
a1462 2
      shrinked_insn_address = (sec->output_section->vma
                              + sec->output_offset + addr - count);
a1642 2
  static asection *last_input_section = NULL;
  static Elf_Internal_Rela *last_reloc = NULL;
a1701 5
  if (sec != last_input_section)
    last_reloc = NULL;

  last_input_section = sec;

d2497 1
a2497 1
                                   void *in_arg)
a2499 1
  struct elf32_avr_link_hash_table *htab;
a2500 1
  htab = in_arg;
@


1.44
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d476 1
a476 1
     For LDI command.  Will be changed when linker stubs are needed. */
d491 1
a491 1
     For LDI command.  Will be changed when linker stubs are needed. */
d504 15
a518 1
         FALSE)                 /* pcrel_offset */
d556 2
a557 1
  { BFD_RELOC_AVR_6_ADIW,           R_AVR_6_ADIW }
@


1.43
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
d41 1
a41 1
   The first is the elf32_avr_link_hash_tablse which is derived from the
d107 2
a108 2
  ((p)->hash->table.newfunc != elf32_avr_link_hash_newfunc ? NULL : \
   ((struct elf32_avr_link_hash_table *) ((p)->hash)))
d620 2
a621 1
                                      sizeof (struct elf_link_hash_entry)))
d1171 3
d2570 1
a2570 1
  struct elf32_avr_link_hash_table *htab = avr_link_hash_table(info);
@


1.42
log
@update copyright dates
@
text
@d778 1
a778 1
  unsigned int index;
d783 3
a785 3
  for (index = 0; index < htab->amt_max_entry_cnt; index ++)
    if (htab->amt_destination_addr[index] == srel)
      return htab->amt_stub_offsets[index] + stub_sec_addr;
a1512 1
               Elf_Internal_Sym *isym;
d1705 2
a1706 2
          && ELF32_R_TYPE (irel->r_info) != R_AVR_7_PCREL
          && ELF32_R_TYPE (irel->r_info) != R_AVR_CALL)
d1723 1
a1723 1
     /* Read this BFD's local symbols if we haven't done so already.  */
d1782 3
a1784 3
         /* Try to turn a 22-bit absolute call/jump into an 13-bit
            pc-relative rcall/rjmp.  */
         case R_AVR_CALL:
d1809 21
a1829 21
               /* Shrinking the code size makes the gaps larger in the
                  case of wrap-arounds.  So we use a heuristical safety
                  margin to avoid that during relax the distance gets
                  again too large for the short jumps.  Let's assume
                  a typical code-size reduction due to relax for a
                  16k device of 600 bytes.  So let's use twice the
                  typical value as safety margin.  */
               int rgap;
               int safety_margin;

               int assumed_shrink = 600;
               if (avr_pc_wrap_around > 0x4000)
                 assumed_shrink = 900;

               safety_margin = 2 * assumed_shrink;

               rgap = avr_relative_distance_considering_wrap_around (gap);

               if (rgap >= (-4092 + safety_margin)
                   && rgap <= (4094 - safety_margin))
		 distance_short_enough = 1;
d1923 1
a1923 1
                        bfd_get_8 (abfd, contents + irel->r_offset + 3);
d1925 1
a1925 1
                        bfd_get_8 (abfd, contents + irel->r_offset + 2);
d1953 1
a1953 1
                        bfd_get_8 (abfd, contents + irel->r_offset + 5);
d1955 1
a1955 1
                        bfd_get_8 (abfd, contents + irel->r_offset + 4);
d1990 2
a1991 2
                        bfd_get_8 (abfd, contents + irel->r_offset
                                         + insn_size + 1);
d1993 2
a1994 2
                        bfd_get_8 (abfd, contents + irel->r_offset
                                         + insn_size);
d2021 1
a2021 1
                            bfd_get_8 (abfd, contents + irel->r_offset - 1);
d2023 1
a2023 1
                            bfd_get_8 (abfd, contents + irel->r_offset - 2);
d2035 1
a2035 1
                            && (0x00 == (preceeding_lsb & 0x08))))
d2040 1
a2040 1
                            && (0x00 == (preceeding_lsb & 0x08))))
d2068 1
a2068 1
                                          irel->r_offset + insn_size;
d2080 29
a2108 29
                         {
                           if (isym->st_value == section_offset_of_ret_insn
                               && isym->st_shndx == sec_shndx)
                             {
                               deleting_ret_is_safe = 0;
                               if (debug_relax)
                                 printf ("local label prevents deletion of ret "
                                         "insn at address 0x%x\n",
                                         (int) dot + insn_size);
                             }
                         }

                         /* Now check for global symbols.  */
                         {
                           int symcount;
                           struct elf_link_hash_entry **sym_hashes;
                           struct elf_link_hash_entry **end_hashes;

                           symcount = (symtab_hdr->sh_size
                                       / sizeof (Elf32_External_Sym)
                                       - symtab_hdr->sh_info);
                           sym_hashes = elf_sym_hashes (abfd);
                           end_hashes = sym_hashes + symcount;
                           for (; sym_hashes < end_hashes; sym_hashes++)
                            {
                              struct elf_link_hash_entry *sym_hash =
                                                                 *sym_hashes;
                              if ((sym_hash->root.type == bfd_link_hash_defined
                                  || sym_hash->root.type ==
d2110 104
a2213 109
                                  && sym_hash->root.u.def.section == sec
                                  && sym_hash->root.u.def.value == section_offset_of_ret_insn)
                                {
                                  deleting_ret_is_safe = 0;
                                  if (debug_relax)
                                    printf ("global label prevents deletion of "
                                            "ret insn at address 0x%x\n",
                                            (int) dot + insn_size);
                                }
                            }
                         }
                         /* Now we check for relocations pointing to ret.  */
                         {
                           Elf_Internal_Rela *irel;
                           Elf_Internal_Rela *relend;
                           Elf_Internal_Shdr *symtab_hdr;

                           symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
                           relend = elf_section_data (sec)->relocs
                                    + sec->reloc_count;

                           for (irel = elf_section_data (sec)->relocs;
                                irel < relend; irel++)
                             {
                               bfd_vma reloc_target = 0;
                               bfd_vma symval;
                               Elf_Internal_Sym *isymbuf = NULL;

                               /* Read this BFD's local symbols if we haven't
                                  done so already.  */
                               if (isymbuf == NULL && symtab_hdr->sh_info != 0)
                                 {
                                   isymbuf = (Elf_Internal_Sym *)
                                             symtab_hdr->contents;
                                   if (isymbuf == NULL)
                                     isymbuf = bfd_elf_get_elf_syms
				       (abfd,
					symtab_hdr,
					symtab_hdr->sh_info, 0,
					NULL, NULL, NULL);
                                   if (isymbuf == NULL)
                                     break;
                                  }

                               /* Get the value of the symbol referred to
                                  by the reloc.  */
                               if (ELF32_R_SYM (irel->r_info)
                                   < symtab_hdr->sh_info)
                                 {
                                   /* A local symbol.  */
                                   Elf_Internal_Sym *isym;
                                   asection *sym_sec;

                                   isym = isymbuf
                                          + ELF32_R_SYM (irel->r_info);
                                   sym_sec = bfd_section_from_elf_index
				     (abfd, isym->st_shndx);
                                   symval = isym->st_value;

                                   /* If the reloc is absolute, it will not
                                      have a symbol or section associated
                                      with it.  */

                                   if (sym_sec)
                                     {
                                       symval +=
                                           sym_sec->output_section->vma
                                           + sym_sec->output_offset;
                                       reloc_target = symval + irel->r_addend;
                                     }
                                   else
                                     {
                                       reloc_target = symval + irel->r_addend;
                                       /* Reference symbol is absolute.  */
                                     }
                                 }
			       /* else ... reference symbol is extern.  */

                               if (address_of_ret == reloc_target)
                                 {
                                   deleting_ret_is_safe = 0;
                                   if (debug_relax)
                                     printf ("ret from "
                                             "rjmp/jmp ret sequence at address"
                                             " 0x%x could not be deleted. ret"
                                             " is target of a relocation.\n",
                                             (int) address_of_ret);
                                 }
                             }
                         }

                         if (deleting_ret_is_safe)
                           {
                             if (debug_relax)
                               printf ("unreachable ret instruction "
                                       "at address 0x%x deleted.\n",
                                       (int) dot + insn_size);

                             /* Delete two bytes of data.  */
                             if (!elf32_avr_relax_delete_bytes (abfd, sec,
                                        irel->r_offset + insn_size, 2))
                               goto error_return;

                             /* That will change things, so, we should relax
                                again. Note that this is not required, and it
                                may be slow.  */
                             *again = TRUE;
                             break;
                           }
@


1.41
log
@	bfd/
	* elf32-ppc.c (ppc_elf_relax_section): Work with a partial
	link.
	* bout.c (b_out_bfd_relax_section): Reject relocatable links.
	* elf32-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-avr.c (elf32_avr_relax_section): Likewise.
	* elf32-frv.c (elf32_avr_relax_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relax_section): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relax_section): Likewise.
	* reloc.c (bfd_generic_relax_section): Likewise.
	* reloc16.c (bfd_coff_reloc16_relax_section): Likewise.
	* vms.c (vms_bfd_relax_section): Likewise.

	ld/
	* ldmain.c (main): Don't reject --relax -r.
	* ld.texinfo (PowerPC ELF32): Document behaviour of relaxing
	partial links.

	ld/testsuite/
	* ld-powerpc/vxworks-relax-2.s: New.
	* ld-powerpc/vxworks-relax-2.rd: New.
	* ld-powerpc/powerpc.exp: Add it.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007, 2008
@


1.40
log
@        PR 9841
        * elf32-avr.c: Handle case where no local symbos exist correctly.
@
text
@d1637 4
@


1.39
log
@/bfd:
2009-02-03  Eric B. Weddington  <eric.weddington@@atmel.com>

	* elf32-avr.c (avr_final_link_relocate): Allow avr25 to wraparound.
@
text
@a1417 1
  Elf_Internal_Sym *isymend;
d1555 2
a1556 2
  isymend = isym + symtab_hdr->sh_info;
  for (; isym < isymend; isym++)
d1558 10
a1567 4
      if (isym->st_shndx == sec_shndx
          && isym->st_value > addr
          && isym->st_value < toaddr)
        isym->st_value -= count;
@


1.38
log
@/bfd:
2008-11-14  Eric B. Weddington  <eric.weddington@@atmel.com>

	PR 7022
	* elf32-avr.c (bfd_elf_avr_final_write_processing):
	Add missing break statements.
@
text
@d857 1
a857 1
	  /* Always apply WRAPAROUND for avr2 and avr4.  */
d861 1
@


1.37
log
@Add AVR architectures avr25, avr31, avr35, and avr51 to match GCC.
bfd/
	* archures.c (bfd_mach_avr25, bfd_mach_avr31, bfd_mach_avr35,
	bfd_mach_avr51): New.
	* bfd-in2.h: Regenerate.
	* cpu-avr.c (arch_info_struct): Add avr25, avr31, avr35, and avr51
	architectures. Change comments to match architecture comments in GCC.
	(compatible): Add test for new AVR architectures.
	* elf32-avr.c (bfd_elf_avr_final_write_processing): Recognize
	bfd_mach_avr25, bfd_mach_avr31, bfd_mach_avr35 and bfd_mach_avr51.
	(elf32_avr_object_p): Recognize E_AVR_MACH_AVR25, E_AVR_MACH_AVR31,
	E_AVR_MACH_AVR35 and E_AVR_MACH_AVR51.

gas/
	* config/tc-avr.c (mcu_types): Add avr25, avr31, avr35, and avr51
	architectures. Reorganize list to put mcu types in correct architectures
	and to order list same as in GCC. Use new ISA definitions in
	include/opcode/avr.h.
	* doc/c-avr.texi: Add avr25, avr31, avr35, and avr51 architecture
	descriptions. Reorganize descriptions to put mcu types in correct
	architectures and to order lists same as in GCC.

include/
	* elf/avr.h (E_AVR_MACH_AVR25, E_AVR_MACH_AVR31,
	E_AVR_MACH_AVR35, E_AVR_MACH_AVR51): Define.
	(EF_AVR_MACH): Redefine to 0x7F.
	* opcode/avr.h (AVR_ISA_TINY3, AVR_ISA_ALL, AVR_ISA_USB162): Remove.
	(AVR_ISA_AVR3): Redefine.
	(AVR_ISA_AVR1, AVR_ISA_AVR2, AVR_ISA_AVR31, AVR_ISA_AVR35,
	AVR_ISA_AVR3_ALL, AVR_ISA_AVR4, AVR_ISA_AVR5, AVR_ISA_AVR51,
	AVR_ISA_AVR6): Define.

ld/
	* Makefile.am (ALL_EMULATIONS): Add eavr25.o, eavr31.o, eavr35.o,
	and eavr51.o.
	Add rules for eavr25.c, eavr31.c, eavr35.c, eavr51.c.
	* Makefile.in: Regenerate.
	* configure.tgt (avr-*-*, targ_extra_emuls): Add avr25, avr31, avr35
	and avr51.
	* emulparams/avr25.sh: New file.
	* emulparams/avr31.sh: New file.
	* emulparams/avr35.sh: New file.
	* emulparams/avr51.sh: New file.
@
text
@d1301 1
d1309 1
d1313 1
@


1.37.2.1
log
@/bfd:
2008-11-17  Eric B. Weddington  <eric.weddington@@atmel.com>

	PR 7022
	* elf32-avr.c (bfd_elf_avr_final_write_processing):
	Add missing break statements.
@
text
@a1300 1
      break;
a1307 1
      break;
a1310 1
      break;
@


1.37.2.2
log
@/bfd:
2009-02-04  Eric B. Weddington  <eric.weddington@@atmel.com>

	* elf32-avr.c (avr_final_link_relocate): Allow avr25 to wraparound.
@
text
@d857 1
a857 1
	  /* Always apply WRAPAROUND for avr2, avr25, and avr4.  */
a860 1
	    case bfd_mach_avr25:
@


1.37.2.3
log
@/bfd:
2009-02-15  Bjoern Haase  <bjoern.m.haase@@web.de>

	PR 9841
	* elf32-avr.c: Handle case where no local symbos exist correctly.
@
text
@d1557 1
a1557 2
  /* Fix PR 9841, there may be no local symbols.  */ 
  for (; isym != NULL && isym < isymend; isym++)
@


1.36
log
@	* elf32-arm.c (arm_map_one_stub): Declare variables at beginning
	of block.
	* elf32-avr.c (get_local_syms): Likewise.
@
text
@d1299 3
d1306 6
d1320 4
d1358 4
d1366 8
d1382 4
@


1.35
log
@        PR ld/6019
        * elf32-avr.c (elf32_avr_relax_section): Handle the case where
        there are no local symbols.
@
text
@d2593 1
d2601 1
a2601 1
  bfd_size_type amt = sizeof (Elf_Internal_Sym *) * htab->bfd_count;
@


1.34
log
@include/elf/
	PR 5900
	* common.h (SHN_BAD): Delete.
	(SHN_LORESERVE .. SHN_HIRESERVE): Move to..
	* external.h: ..here.
	* internal.h (SHN_LORESERVE, SHN_HIRESERVE): Define.
	(SHN_LOPROC, SHN_HIPROC, SHN_LOOS, SHN_HIOS): Define.
	(SHN_ABS, SHN_COMMON, SHN_XINDEX, SHN_BAD): Define.
bfd/
	PR 5900
	* elf-bfd.h: Include elf/internal.h after elf/external.h.
	* elfcode.h (elf_swap_symbol_in): Map reserved shndx range.
	(elf_swap_symbol_out): Adjust SHN_XINDEX test.
	(elf_swap_ehdr_out): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.
	(valid_section_index_p): Delete.
	(elf_object_p): Don't increment section numbers over reserved range.
	Simplify test for valid sh_link, sh_info and e_shstrndx fields.
	(elf_write_shdrs_and_ehdr): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.  Don't increment section numbers over
	reserved range.
	* elf.c (bfd_elf_sym_name): Remove redundant tests on st_shndx.
	(bfd_section_from_shdr): Likewise.
	(group_signature): Range check before accessing elf_elfsections.
	(_bfd_elf_setup_sections): Likewise.
	(bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): Don't increment section number over
	reserved sections.
	(assign_file_positions_for_non_load_sections): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(_bfd_elf_write_object_contents): Likewise.
	(assign_section_numbers): Likewise.  Adjust for changed SHN_*.
	(prep_headers): Delete unused variable.
	* elflink.c (bfd_elf_link_record_local_dynamic_symbol): Adjust
	for changed SHN_* values.
	(check_dynsym, elf_link_input_bfd): Likewise.
	(bfd_elf_final_link): Likewise.  Don't skip over reserved section
	range.
	(elf_fixup_link_order): Check that sh_link field is valid.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Make "index" unsigned.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Range check before
	accesssing elf_elfsections.
	* elf32-avr.c (elf32_avr_size_stubs): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Adjust for changed
	SHN_* defines.  Test for SHN_BAD return from
	_bfd_elf_section_from_bfd_section
binutils/
	PR 5900
	* readelf.c (SECTION_HEADER_INDEX, SECTION_HEADER_NUM): Delete.
	Remove use throughout file.
	(SECTION_HEADER): Likewise.
	(dump_relocations): Don't adjust st_shndx for reserved range.
	(process_file_header): Mask SHN_XINDEX to values seen in external
	elf structs.  Simplify valid section index tests.
	(get_32bit_elf_symbols, get_64bit_elf_symbols): Mask SHN_XINDEX.
	Map reserved st_shndx to internal form.
	(process_section_groups): Test that group symbol st_shndx is in
	range, not just non-zero.  Delete reserved range check.
	(get_symbol_index_type): Mask "type" to 16 bits when printing PRC,
	OS or RSV.
gdb/
	PR 5900
	* elfread.c (elf_symtab_read): Make shndx an unsigned int.
	* mipsread.c: Include elf/internal.h.
	(read_alphacoff_dynamic_symtab): Map external reserved sym_shndx
	to internal range.
ld/testsuite/
	PR 5900
	* ld-elf/sec64k.exp: Update.
@
text
@d2037 2
a2038 1
                        for (; isym < isymend; isym++)
@


1.33
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2006, 2007
d2760 1
a2762 2
                      hdr = elf_elfsections (input_bfd)[sym->st_shndx];
                      sym_sec = hdr->bfd_section;
d2765 9
a2773 3
                      destination = (sym_value + irela->r_addend
                                     + sym_sec->output_offset
                                     + sym_sec->output_section->vma);
@


1.32
log
@Switch sources over to use the GPL version 3
@
text
@d732 1
a732 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a740 3
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
@


1.31
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.30
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.29
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d691 16
@


1.28
log
@PR binutils/3874
* elf32-avr.c (avr_link_hash_table): Check to make sure that the hash table was created by elf32_avr_link_hash_table_create before using it.
  (elf32_avr_link_hash_newfunc): New function.  Just pass the call through to _bfd_elf_link_hash_newfunc.
  (elf32_avr_link_hash_table_create): Use elf32_avr_link_hash_newfunc instead of _bfd_elf_link_hash_newfunc.
  (elf32_avr_relocate_section): Check for the hash table pointer being NULL.
  (elf32_avr_relax_section, avr_build_one_stub, elf32_avr_setup_params, get_local_syms, elf32_avr_size_stubs, elf32_avr_build_stubs): Likewise.
@
text
@a1155 3
  if (info == NULL || info->relocatable)
    return TRUE;

a1171 1
      /* This is a final link.  */
d1201 14
@


1.27
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2006
d106 3
a108 1
  ((struct elf32_avr_link_hash_table *) ((p)->hash))
d592 12
d619 1
a619 1
                                      _bfd_elf_link_hash_newfunc,
d1156 1
a1156 1
  if (info->relocatable)
d1577 2
d2383 2
d2475 1
a2475 1
  struct elf32_avr_link_hash_table *htab = avr_link_hash_table(info);
d2477 2
d2508 1
a2508 1
  if (htab->no_stubs)
d2570 3
d2622 2
a2623 2
 struct elf32_avr_link_hash_table *htab;
 int stub_changed = 0;
d2625 3
a2627 1
 htab = avr_link_hash_table (info);
d2629 10
a2638 10
 /* At this point we initialize htab->vector_base
    To the start of the text output section.  */
 htab->vector_base = htab->stub_sec->output_section->vma;

 if (get_local_syms (info->input_bfds, info))
   {
     if (htab->all_local_syms)
       goto error_ret_free_local;
     return FALSE;
   }
d2884 2
@


1.26
log
@Add support for AVR6 family
@
text
@a690 42
static asection *
elf32_avr_gc_mark_hook (asection *sec,
			struct bfd_link_info *info ATTRIBUTE_UNUSED,
			Elf_Internal_Rela *rel,
			struct elf_link_hash_entry *h,
			Elf_Internal_Sym *sym)
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
}

static bfd_boolean
elf32_avr_gc_sweep_hook (bfd *abfd ATTRIBUTE_UNUSED,
			 struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 asection *sec ATTRIBUTE_UNUSED,
			 const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED)
{
  /* We don't use got and plt entries for avr.  */
  return TRUE;
}

a2911 2
#define elf_backend_gc_mark_hook             elf32_avr_gc_mark_hook
#define elf_backend_gc_sweep_hook            elf32_avr_gc_sweep_hook
@


1.25
log
@* gas/config/tc-avr.h (TC_VALIDATE_FIX): Define.  Disable fixups for PMEM
    related expressions.
* bfd/elf32-avr.c (elf32_avr_relax_delete_bytes): Iterate over all of the
    bfd's sections for the reloc-addend adjustments.
@
text
@d28 86
d190 2
a191 1
  /* A 16 bit absolute relocation for command address.  */
d297 1
a297 1
     For LDI command.  */
d311 2
a312 2
  /* A high 8 bit absolute relocation of 16 bit program memory address.
     For LDI command.  */
d326 2
a327 2
  /* A high 8 bit absolute relocation of 24 bit program memory address.
     For LDI command.  */
d341 2
a342 2
  /* A low 8 bit absolute relocation of a negative 24 bit
     program memory address.  For LDI command.  */
d356 2
a357 2
  /* A high 8 bit absolute relocation of a negative 16 bit
     program memory address.  For LDI command.  */
d371 2
a372 2
  /* A high 8 bit absolute relocation of a negative 24 bit
     program memory address.  For LDI command.  */
d472 31
a502 1
	 FALSE) 		/* pcrel_offset */
d513 1
a513 1
 static const struct avr_reloc_map avr_reloc_map[] =
d530 1
d532 1
d551 1
d553 93
a645 1
unsigned int avr_pc_wrap_around = 0x10000000;
d778 28
d810 7
a816 6
avr_final_link_relocate (reloc_howto_type *  howto,
			 bfd *               input_bfd,
			 asection *          input_section,
			 bfd_byte *          contents,
			 Elf_Internal_Rela * rel,
			 bfd_vma             relocation)
d821 8
d999 3
d1005 19
d1032 3
d1038 19
d1128 29
d1182 1
d1234 1
a1234 1
				   contents, rel, relocation);
d1315 4
d1361 4
a1371 3
/* Enable debugging printout at stdout with a value of 1.  */
#define DEBUG_RELAX 0

d1430 1
a1430 1
          if (DEBUG_RELAX)
d1446 2
a1447 2
      2.) symbol plus addend end up behind the shrinked instruction.  
      
d1450 1
a1450 1
         
d1465 1
a1465 1
       for (irel = elf_section_data (isec)->relocs; 
d1469 1
a1469 1
           /* Read this BFD's local symbols if we haven't done 
d1495 1
a1495 1
                 { 
d1499 1
a1499 1
                   if (DEBUG_RELAX)
d1514 1
a1514 1
                       if (DEBUG_RELAX)
d1519 2
a1520 2
              }
	   /* else...Reference symbol is extern. No need for adjusting 
d1522 1
a1522 1
          }
d1589 1
a1589 1
static  bfd_boolean
d1602 3
d1609 24
d1799 1
a1799 1
                if (DEBUG_RELAX)
d1874 3
a1876 2
               safely replaced by rjmp/ret or jmp/ret */
            if (0xd0 == (code_msb & 0xf0))
d1896 1
a1896 1
                    if (DEBUG_RELAX)
d1905 2
a1906 1
                      && (0x0e == (code_lsb & 0x0e)))
d1927 1
a1927 1
                    if (DEBUG_RELAX)
d1970 1
a1970 1
                    if (DEBUG_RELAX && (insn_size == 2))
d1973 1
a1973 1
                    if (DEBUG_RELAX && (insn_size == 4))
d2010 1
a2010 1
                          if (DEBUG_RELAX)
d2046 1
a2046 1
                               if (DEBUG_RELAX)
d2075 1
a2075 1
                                  if (DEBUG_RELAX)
d2152 1
a2152 1
                                   if (DEBUG_RELAX)
d2164 1
a2164 1
                             if (DEBUG_RELAX)
d2332 608
d2948 3
@


1.24
log
@Update formatting to ISO-C90
@
text
@d436 1
d459 2
a460 4
    {
      if (avr_reloc_map[i].bfd_reloc_val == code)
	return &elf_avr_howto_table[avr_reloc_map[i].elf_reloc_val];
    }
d1051 1
a1051 1
			      asection *sec,
d1053 1
a1053 1
			      int count)
d1087 1
a1087 1
  /* Adjust all the relocs.  */
a1089 1
      bfd_vma symval;
d1112 1
a1112 5
      /* The reloc's own addresses are now ok. However, we need to readjust
         the reloc's addend if two conditions are met:
         1.) the reloc is relative to a symbol in this section that
             is located in front of the shrinked instruction
         2.) symbol plus addend end up behind the shrinked instruction.
d1114 56
a1169 45
         This should happen only for local symbols that are progmem related.  */

      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
        {
          isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
          if (isymbuf == NULL)
            isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
                                            symtab_hdr->sh_info, 0,
                                            NULL, NULL, NULL);
          if (isymbuf == NULL)
             return FALSE;
         }

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
        {
          /* A local symbol.  */
          Elf_Internal_Sym *isym;
          asection *sym_sec;

          isym = isymbuf + ELF32_R_SYM (irel->r_info);
          sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
          symval = isym->st_value;
          /* If the reloc is absolute, it will not have
             a symbol or section associated with it.  */
          if (sym_sec)
            {
               symval += sym_sec->output_section->vma
                         + sym_sec->output_offset;

               if (DEBUG_RELAX)
                printf ("Checking if the relocation's "
                        "addend needs corrections.\n"
                        "Address of anchor symbol: 0x%x \n"
                        "Address of relocation target: 0x%x \n"
                        "Address of relaxed insn: 0x%x \n",
                        (unsigned int) symval,
                        (unsigned int) (symval + irel->r_addend),
                        (unsigned int) shrinked_insn_address);

               if (symval <= shrinked_insn_address
                   && (symval + irel->r_addend) > shrinked_insn_address)
                 {
                   irel->r_addend -= count;
d1172 17
a1188 4
                     printf ("Anchor symbol and relocation target bracket "
                             "shrinked insn address.\n"
                             "Need for new addend : 0x%x\n",
                             (unsigned int) irel->r_addend);
d1190 7
a1196 5
            }
	  /* else ... Reference symbol is absolute.  No adjustment needed.  */
        }
      /* else ... Reference symbol is extern. No need for adjusting the addend.  */
    }
@


1.23
log
@Add linker relaxation support for the AVR
@
text
@d20 1
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, 
a28 31
static reloc_howto_type *bfd_elf32_bfd_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static void avr_info_to_howto_rela
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static asection *elf32_avr_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf32_avr_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf32_avr_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_reloc_status_type avr_final_link_relocate
  PARAMS ((reloc_howto_type *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, bfd_vma));
static bfd_boolean elf32_avr_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static void bfd_elf_avr_final_write_processing PARAMS ((bfd *, bfd_boolean));
static bfd_boolean elf32_avr_object_p PARAMS ((bfd *));

/* Relaxing stuff */
static bfd_boolean elf32_avr_relax_section
  PARAMS((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean elf32_avr_relax_delete_bytes
  PARAMS((bfd *, asection *, bfd_vma, int));
static bfd_byte *elf32_avr_get_relocated_section_contents
  PARAMS((bfd *, struct bfd_link_info *, struct bfd_link_order *,
          bfd_byte *, bfd_boolean, asymbol **));

d149 1
a149 1
     For LDI command.  As well second most significant 8 bit value of 
d425 1
a425 1
   specific device.  I.e. should get the value 0x4000 for 16k devices, 
d427 1
a427 1
   
d429 2
a430 2
   that we will never suggest a wrap-around jump during relaxation.  
   The logic of the source code later on assumes that in 
d432 1
a432 1
   
d438 1
a438 1
{ 
a439 1
               
d442 1
a442 1
  if (dist_with_wrap_around > ((int) (avr_pc_wrap_around >> 1)) )
d450 2
a451 3
bfd_elf32_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d469 3
a471 4
avr_info_to_howto_rela (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d481 5
a485 6
elf32_avr_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d513 4
a516 5
elf32_avr_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
d527 4
a530 5
elf32_avr_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d542 1
a542 1
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof (Elf32_External_Sym);
d571 6
a576 8
avr_final_link_relocate (howto, input_bfd, input_section,
			 contents, rel, relocation)
     reloc_howto_type *  howto;
     bfd *               input_bfd;
     asection *          input_section;
     bfd_byte *          contents;
     Elf_Internal_Rela * rel;
     bfd_vma             relocation;
d652 2
a653 2
      if ( ((srel > 0) && (srel & 0xffff) > 255)
           || ((srel < 0) && ( (-srel) & 0xffff) > 128))
d669 1
a669 1
      x = (x & 0xd3f8) | ((srel & 7) | ((srel & (3 << 3)) << 7) 
d681 1
a681 1
      x = (x & 0xff30) | (srel & 0xf) | ((srel & 0x30) << 2); 
d846 1
d848 8
a855 10
elf32_avr_relocate_section (output_bfd, info, input_bfd, input_section,
			    contents, relocs, local_syms, local_sections)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d966 2
a967 3
bfd_elf_avr_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
d1004 1
a1004 2
elf32_avr_object_p (abfd)
     bfd *abfd;
d1007 1
d1012 1
d1045 165
d1214 2
a1215 2
   and jump -> rjmp (safes also 2 bytes).  
   As well we now optimize seqences of 
d1229 1
a1229 1
   
d1231 1
a1231 1
   ".jumptables" in order to maintain the position of the instructions.  
d1233 1
a1233 1
   if possible. (In future one could possibly use the space of the nop 
d1238 1
a1238 1
   contains 4-byte jump instructions whose relative offset must not 
d1240 1
a1240 1
 
d1242 2
a1243 1
elf32_avr_relax_section (bfd *abfd, asection *sec,
d1266 1
a1266 1
 
a1268 1
 
a1270 1
  
d1276 1
a1276 2
                     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
                      link_info->keep_memory));
d1291 1
a1291 1
      if (ELF32_R_TYPE (irel->r_info) != R_AVR_13_PCREL
d1295 1
a1295 1
           
d1305 1
a1305 1
              if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d1350 5
a1354 6
            {
              /* This appears to be a reference to an undefined
                 symbol.  Just ignore it--it will be caught by the
                 regular reloc processing.  */
              continue;
            }
d1386 1
a1386 1
               will be closer after the relaxation.  */ 
d1391 1
a1391 1
               we could use a rjmp to jump from address 0x100 to 0x3d00!  
d1402 1
a1402 2
                  typical value as safety margin.  */ 

d1409 1
a1409 1
  
d1413 2
a1414 2
 
               if (rgap >= (-4092 + safety_margin) 
d1416 2
a1417 2
                   distance_short_enough = 1;
            } 
d1454 1
a1454 1
                else 
d1484 1
d1497 2
a1498 2
           
            /* Here we look for rcall/ret or call/ret sequences that could be 
d1508 1
a1508 1
                    next_insn_msb = 
d1510 1
a1510 1
                    next_insn_lsb = 
d1513 2
a1514 1
                if ((0x95 == next_insn_msb) && (0x08 == next_insn_lsb))
a1517 1
                    
d1542 1
d1558 2
a1559 2
            else if ((0xc0 == (code_msb & 0xf0))        
                     || ((0x94 == (code_msb & 0xfe))      
d1562 1
a1562 1
                /* this insn is a rjmp or a jmp.  */
d1574 2
a1575 2
                    next_insn_msb = 
                        bfd_get_8 (abfd, contents + irel->r_offset 
d1577 2
a1578 2
                    next_insn_lsb = 
                        bfd_get_8 (abfd, contents + irel->r_offset 
d1594 1
a1594 2
                      printf ("found rjmp / ret sequence at "
                              "address 0x%x\n",
d1597 1
a1597 2
                      printf ("found jmp / ret sequence at "
                              "address 0x%x\n",
d1605 1
a1605 1
                        preceeding_msb = 
d1607 1
a1607 1
                        preceeding_lsb = 
d1611 1
a1611 1
                        if (0x99 == preceeding_msb)    
d1615 1
a1615 1
                        if (0x9b == preceeding_msb)    
d1623 1
a1623 1
                        /* sbrs */ 
d1627 1
a1627 1
                       
d1631 1
a1631 1
                       
d1642 1
a1642 1
                      } 
d1652 1
a1652 1
                        unsigned int section_offset_of_ret_insn = 
d1656 3
a1658 3
                       
                        sec_shndx = 
                             _bfd_elf_section_from_bfd_section (abfd, sec);
d1682 1
a1682 1
                           symcount = (symtab_hdr->sh_size 
d1689 1
a1689 1
                              struct elf_link_hash_entry *sym_hash = 
d1692 2
a1693 2
                                  || sym_hash->root.type == 
                                                          bfd_link_hash_defweak)
d1695 1
a1695 2
                                  && sym_hash->root.u.def.value == 
                                                   section_offset_of_ret_insn) 
d1711 2
a1712 2
                           symtab_hdr = &elf_tdata (abfd)->symtab_hdr; 
                           relend = elf_section_data (sec)->relocs 
d1715 1
a1715 1
                           for (irel = elf_section_data (sec)->relocs; 
d1721 2
a1722 2
                               
                               /* Read this BFD's local symbols if we haven't 
d1726 1
a1726 1
                                   isymbuf = (Elf_Internal_Sym *) 
d1729 5
a1733 5
                                     isymbuf = bfd_elf_get_elf_syms (
                                            abfd, 
                                            symtab_hdr,
                                            symtab_hdr->sh_info, 0,
                                            NULL, NULL, NULL);
d1737 2
a1738 2
                             
                               /* Get the value of the symbol referred to 
d1740 1
a1740 1
                               if (ELF32_R_SYM (irel->r_info) 
d1747 1
a1747 1
                                   isym = isymbuf 
d1749 5
a1753 5
                                   sym_sec = bfd_section_from_elf_index (
                                                 abfd, isym->st_shndx);
                                   symval = isym->st_value; 
                            
                                   /* If the reloc is absolute, it will not 
d1756 1
a1756 1
             
d1758 2
a1759 2
                                     { 
                                       symval += 
d1767 1
a1767 1
                                       /* reference symbol is absolute.  */
d1770 3
a1772 1
                               else
a1773 5
                                   /* reference symbol is extern.  */
                                 }
                                 
                               if (address_of_ret == reloc_target)
                                 {   
d1791 1
a1791 1
                    
d1797 2
a1798 2
                             /* That will change things, so, we should relax 
                                again. Note that this is not required, and it 
a1799 1
                       
d1804 3
a1806 3
                        
                  }                    
              } 
d1841 1
a1841 169
  return FALSE;  
}

/* Delete some bytes from a section while changing the size of an instruction.
   The parameter "addr" denotes the section-relative offset pointing just
   behind the shrinked instruction. "addr+count" point at the first
   byte just behind the original unshrinked instruction.  */
static bfd_boolean
elf32_avr_relax_delete_bytes (bfd *abfd, asection *sec, 
                              bfd_vma addr, int count)
{
  Elf_Internal_Shdr *symtab_hdr;
  unsigned int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel, *irelend;
  Elf_Internal_Rela *irelalign;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Sym *isymend;
  bfd_vma toaddr;
  struct elf_link_hash_entry **sym_hashes;
  struct elf_link_hash_entry **end_hashes;
  unsigned int symcount;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sec_shndx = _bfd_elf_section_from_bfd_section (abfd, sec);
  contents = elf_section_data (sec)->this_hdr.contents;

  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */

  irelalign = NULL;
  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  if (toaddr - addr - count > 0)
    memmove (contents + addr, contents + addr + count,
             (size_t) (toaddr - addr - count));
  sec->size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      bfd_vma old_reloc_address;
      bfd_vma shrinked_insn_address;

      old_reloc_address = (sec->output_section->vma
                           + sec->output_offset + irel->r_offset);
      shrinked_insn_address = (sec->output_section->vma
                              + sec->output_offset + addr - count);

      /* Get the new reloc address.  */
      if ((irel->r_offset > addr
           && irel->r_offset < toaddr))
        {
          if (DEBUG_RELAX)
            printf ("Relocation at address 0x%x needs to be moved.\n"
                    "Old section offset: 0x%x, New section offset: 0x%x \n", 
                    (unsigned int) old_reloc_address,
                    (unsigned int) irel->r_offset, 
                    (unsigned int) ((irel->r_offset) - count));

          irel->r_offset -= count;
        }

      /* The reloc's own addresses are now ok. However, we need to readjust
         the reloc's addend if two conditions are met:
         1.) the reloc is relative to a symbol in this section that
             is located in front of the shrinked instruction
         2.) symbol plus addend end up behind the shrinked instruction.  
         
         This should happen only for local symbols that are progmem related.  */

      /* Read this BFD's local symbols if we haven't done so already.  */
      if (isymbuf == NULL && symtab_hdr->sh_info != 0)
        {
          isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
          if (isymbuf == NULL)
            isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
                                            symtab_hdr->sh_info, 0,
                                            NULL, NULL, NULL);
          if (isymbuf == NULL)
             return FALSE;
         }

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
        {
          /* A local symbol.  */
          Elf_Internal_Sym *isym;
          asection *sym_sec;

          isym = isymbuf + ELF32_R_SYM (irel->r_info);
          sym_sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
          symval = isym->st_value;
          /* If the reloc is absolute, it will not have
             a symbol or section associated with it.  */
          if (sym_sec)
            { 
               symval += sym_sec->output_section->vma
                         + sym_sec->output_offset;

               if (DEBUG_RELAX)
                printf ("Checking if the relocation's "
                        "addend needs corrections.\n"
                        "Address of anchor symbol: 0x%x \n"
                        "Address of relocation target: 0x%x \n"
                        "Address of relaxed insn: 0x%x \n",
                        (unsigned int) symval,
                        (unsigned int) (symval + irel->r_addend),
                        (unsigned int) shrinked_insn_address);

               if ( symval <= shrinked_insn_address
                   && (symval + irel->r_addend) > shrinked_insn_address)
                 {
                   irel->r_addend -= count;

                   if (DEBUG_RELAX)
                     printf ("Anchor symbol and relocation target bracket "
                             "shrinked insn address.\n"
                             "Need for new addend : 0x%x\n",
                             (unsigned int) irel->r_addend);
                 }
            }
          else
            {
               /* Reference symbol is absolute.  No adjustment needed.  */
            }
        }
      else
        {
           /* Reference symbol is extern. No need for adjusting the addend.  */
        }
    }

  /* Adjust the local symbols defined in this section.  */
  isym = (Elf_Internal_Sym *) symtab_hdr->contents;
  isymend = isym + symtab_hdr->sh_info;
  for (; isym < isymend; isym++)
    {
      if (isym->st_shndx == sec_shndx
          && isym->st_value > addr
          && isym->st_value < toaddr)
        isym->st_value -= count;
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
              - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  end_hashes = sym_hashes + symcount;
  for (; sym_hashes < end_hashes; sym_hashes++)
    {
      struct elf_link_hash_entry *sym_hash = *sym_hashes;
      if ((sym_hash->root.type == bfd_link_hash_defined
           || sym_hash->root.type == bfd_link_hash_defweak)
          && sym_hash->root.u.def.section == sec
          && sym_hash->root.u.def.value > addr
          && sym_hash->root.u.def.value < toaddr)
        {
          sym_hash->root.u.def.value -= count;
        }
    }

  return TRUE;
d1845 1
a1845 1
   which uses elf32_avr_relocate_section.  
d1847 1
a1847 1
   For avr it's essentially a cut and paste taken from the H8300 port. 
d1849 1
a1849 1
   clue what is happening here but found out that this part of the code 
d1888 1
a1888 2
                         (input_bfd, input_section, (PTR) NULL,
                          (Elf_Internal_Rela *) NULL, FALSE));
d1905 1
a1905 1
      sections = (asection **) bfd_malloc (amt);
@


1.22
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d51 9
d180 2
a181 1
     For LDI command.  */
d210 1
a210 1
  /* A hegative high 8 bit absolute relocation of 16 bit address.
d225 1
a225 1
  /* A hegative high 6 bit absolute relocation of 22 bit address.
d388 29
a416 1
	 FALSE)			/* pcrel_offset */
d438 1
d442 1
d455 26
d653 2
d661 3
a663 1
	  /* Apply WRAPAROUND if possible.  */
d691 5
a695 3
      if ((srel & 0xffff) > 255)
	/* Remove offset for data/eeprom section.  */
	return bfd_reloc_overflow;
d708 2
a709 1
      x = (x & 0xd3f8) | ((srel & 7) | ((srel & (3 << 3)) << 7) | ((srel & (1 << 5)) << 8));
d742 9
d780 10
d1039 1
d1081 927
d2028 4
@


1.21
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d526 6
a531 1
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.20
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.19
log
@Add support for the new R_AVR_LDI, R_AVR_6 and R_AVR_6_ADIW relocs for the
LDI, ADIW/SBIW and LDD/STD instructions.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.18
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d326 1
a326 1
	 complain_overflow_dont, /* complain_on_overflow */
d332 45
d408 4
a411 1
  { BFD_RELOC_AVR_CALL,             R_AVR_CALL }
d612 33
@


1.17
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d739 1
a739 1
      const char *                 name = NULL;
d768 2
d783 2
a784 1
		(info, name, howto->name, (bfd_vma) 0,
@


1.16
log
@bfd/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Report error if
	unresolved symbols in objects aren't allowed.

	* elf-hppa.h (elf_hppa_relocate_section): Properly handle
	unresolved symbols.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	(elf_hppa_unmark_useless_dynamic_symbols):
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	(elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

	* elf-m10200.c (mn10200_elf_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.

include/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Correct comments for the
	unresolved_syms_in_objects field.

ld/

2004-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* lexsup.c (parse_args): Don't set unresolved_syms_in_objects
	or unresolved_syms_in_shared_libs for -Bdynamic and -Bstatic.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d764 4
a767 3
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, warned);
@


1.15
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d761 1
a761 1
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];
d763 3
a765 26
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
	      relocation = 0;
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
	      relocation = 0;
	    }
@


1.15.6.1
log
@Merge from mainline
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d761 1
a761 1
	  bfd_boolean unresolved_reloc, warned;
d763 26
a788 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.15.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d761 1
a761 1
	  bfd_boolean unresolved_reloc, warned;
d763 26
a788 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.15.12.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d761 1
a761 1
	  bfd_boolean unresolved_reloc, warned;
d763 26
a788 3
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx, symtab_hdr,
				   relocation, sec, unresolved_reloc,
				   info, warned);
@


1.14
log
@Correct spelling of "relocatable".
@
text
@d753 1
a753 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.13
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d458 1
a458 1
  if (info->relocateable)
d722 1
a722 1
  if (info->relocateable)
@


1.12
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d34 1
a34 1
static boolean elf32_avr_gc_sweep_hook
d37 1
a37 1
static boolean elf32_avr_check_relocs
d43 1
a43 1
static boolean elf32_avr_relocate_section
d46 2
a47 2
static void bfd_elf_avr_final_write_processing PARAMS ((bfd *, boolean));
static boolean elf32_avr_object_p PARAMS ((bfd *));
d55 1
a55 1
	 false,			/* pc_relative */
d60 1
a60 1
	 false,			/* partial_inplace */
d63 1
a63 1
	 false),		/* pcrel_offset */
d69 1
a69 1
	 false,			/* pc_relative */
d74 1
a74 1
	 false,			/* partial_inplace */
d77 1
a77 1
	 false),		/* pcrel_offset */
d84 1
a84 1
	 true,			/* pc_relative */
d89 1
a89 1
	 false,			/* partial_inplace */
d92 1
a92 1
	 true),			/* pcrel_offset */
d99 1
a99 1
	 true,			/* pc_relative */
d104 1
a104 1
	 false,			/* partial_inplace */
d107 1
a107 1
	 true),			/* pcrel_offset */
d114 1
a114 1
	 false,			/* pc_relative */
d119 1
a119 1
	 false,			/* partial_inplace */
d122 1
a122 1
	 false),		/* pcrel_offset */
d129 1
a129 1
	 false,			/* pc_relative */
d134 1
a134 1
	 false,			/* partial_inplace */
d137 1
a137 1
	 false),		/* pcrel_offset */
d144 1
a144 1
	 false,			/* pc_relative */
d149 1
a149 1
	 false,			/* partial_inplace */
d152 1
a152 1
	 false),		/* pcrel_offset */
d159 1
a159 1
	 false,			/* pc_relative */
d164 1
a164 1
	 false,			/* partial_inplace */
d167 1
a167 1
	 false),		/* pcrel_offset */
d174 1
a174 1
	 false,			/* pc_relative */
d179 1
a179 1
	 false,			/* partial_inplace */
d182 1
a182 1
	 false),		/* pcrel_offset */
d189 1
a189 1
	 false,			/* pc_relative */
d194 1
a194 1
	 false,			/* partial_inplace */
d197 1
a197 1
	 false),		/* pcrel_offset */
d204 1
a204 1
	 false,			/* pc_relative */
d209 1
a209 1
	 false,			/* partial_inplace */
d212 1
a212 1
	 false),		/* pcrel_offset */
d219 1
a219 1
	 false,			/* pc_relative */
d224 1
a224 1
	 false,			/* partial_inplace */
d227 1
a227 1
	 false),		/* pcrel_offset */
d234 1
a234 1
	 false,			/* pc_relative */
d239 1
a239 1
	 false,			/* partial_inplace */
d242 1
a242 1
	 false),		/* pcrel_offset */
d249 1
a249 1
	 false,			/* pc_relative */
d254 1
a254 1
	 false,			/* partial_inplace */
d257 1
a257 1
	 false),		/* pcrel_offset */
d264 1
a264 1
	 false,			/* pc_relative */
d269 1
a269 1
	 false,			/* partial_inplace */
d272 1
a272 1
	 false),		/* pcrel_offset */
d279 1
a279 1
	 false,			/* pc_relative */
d284 1
a284 1
	 false,			/* partial_inplace */
d287 1
a287 1
	 false),		/* pcrel_offset */
d294 1
a294 1
	 false,			/* pc_relative */
d299 1
a299 1
	 false,			/* partial_inplace */
d302 1
a302 1
	 false),		/* pcrel_offset */
d309 1
a309 1
	 false,			/* pc_relative */
d314 1
a314 1
	 false,			/* partial_inplace */
d317 1
a317 1
	 false),		/* pcrel_offset */
d323 1
a323 1
	 false,			/* pc_relative */
d328 1
a328 1
	 false,			/* partial_inplace */
d331 1
a331 1
	 false)			/* pcrel_offset */
d431 1
a431 1
static boolean
d439 1
a439 1
  return true;
d446 1
a446 1
static boolean
d459 1
a459 1
    return true;
d480 1
a480 1
  return true;
d705 1
a705 1
static boolean
d723 1
a723 1
    return true;
d785 2
a786 2
		      input_section, rel->r_offset, true)))
		return false;
d808 1
a808 1
		(info, name, input_bfd, input_section, rel->r_offset, true);
d833 1
a833 1
	    return false;
d837 1
a837 1
  return true;
d847 1
a847 1
     boolean linker ATTRIBUTE_UNUSED;
d882 1
a882 1
static boolean
@


1.11
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d30 1
a30 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
d389 1
a389 1
     Elf32_Internal_Rela *dst;
@


1.11.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d30 1
a30 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d34 1
a34 1
static bfd_boolean elf32_avr_gc_sweep_hook
d37 1
a37 1
static bfd_boolean elf32_avr_check_relocs
d43 1
a43 1
static bfd_boolean elf32_avr_relocate_section
d46 2
a47 2
static void bfd_elf_avr_final_write_processing PARAMS ((bfd *, bfd_boolean));
static bfd_boolean elf32_avr_object_p PARAMS ((bfd *));
d55 1
a55 1
	 FALSE,			/* pc_relative */
d60 1
a60 1
	 FALSE,			/* partial_inplace */
d63 1
a63 1
	 FALSE),		/* pcrel_offset */
d69 1
a69 1
	 FALSE,			/* pc_relative */
d74 1
a74 1
	 FALSE,			/* partial_inplace */
d77 1
a77 1
	 FALSE),		/* pcrel_offset */
d84 1
a84 1
	 TRUE,			/* pc_relative */
d89 1
a89 1
	 FALSE,			/* partial_inplace */
d92 1
a92 1
	 TRUE),			/* pcrel_offset */
d99 1
a99 1
	 TRUE,			/* pc_relative */
d104 1
a104 1
	 FALSE,			/* partial_inplace */
d107 1
a107 1
	 TRUE),			/* pcrel_offset */
d114 1
a114 1
	 FALSE,			/* pc_relative */
d119 1
a119 1
	 FALSE,			/* partial_inplace */
d122 1
a122 1
	 FALSE),		/* pcrel_offset */
d129 1
a129 1
	 FALSE,			/* pc_relative */
d134 1
a134 1
	 FALSE,			/* partial_inplace */
d137 1
a137 1
	 FALSE),		/* pcrel_offset */
d144 1
a144 1
	 FALSE,			/* pc_relative */
d149 1
a149 1
	 FALSE,			/* partial_inplace */
d152 1
a152 1
	 FALSE),		/* pcrel_offset */
d159 1
a159 1
	 FALSE,			/* pc_relative */
d164 1
a164 1
	 FALSE,			/* partial_inplace */
d167 1
a167 1
	 FALSE),		/* pcrel_offset */
d174 1
a174 1
	 FALSE,			/* pc_relative */
d179 1
a179 1
	 FALSE,			/* partial_inplace */
d182 1
a182 1
	 FALSE),		/* pcrel_offset */
d189 1
a189 1
	 FALSE,			/* pc_relative */
d194 1
a194 1
	 FALSE,			/* partial_inplace */
d197 1
a197 1
	 FALSE),		/* pcrel_offset */
d204 1
a204 1
	 FALSE,			/* pc_relative */
d209 1
a209 1
	 FALSE,			/* partial_inplace */
d212 1
a212 1
	 FALSE),		/* pcrel_offset */
d219 1
a219 1
	 FALSE,			/* pc_relative */
d224 1
a224 1
	 FALSE,			/* partial_inplace */
d227 1
a227 1
	 FALSE),		/* pcrel_offset */
d234 1
a234 1
	 FALSE,			/* pc_relative */
d239 1
a239 1
	 FALSE,			/* partial_inplace */
d242 1
a242 1
	 FALSE),		/* pcrel_offset */
d249 1
a249 1
	 FALSE,			/* pc_relative */
d254 1
a254 1
	 FALSE,			/* partial_inplace */
d257 1
a257 1
	 FALSE),		/* pcrel_offset */
d264 1
a264 1
	 FALSE,			/* pc_relative */
d269 1
a269 1
	 FALSE,			/* partial_inplace */
d272 1
a272 1
	 FALSE),		/* pcrel_offset */
d279 1
a279 1
	 FALSE,			/* pc_relative */
d284 1
a284 1
	 FALSE,			/* partial_inplace */
d287 1
a287 1
	 FALSE),		/* pcrel_offset */
d294 1
a294 1
	 FALSE,			/* pc_relative */
d299 1
a299 1
	 FALSE,			/* partial_inplace */
d302 1
a302 1
	 FALSE),		/* pcrel_offset */
d309 1
a309 1
	 FALSE,			/* pc_relative */
d314 1
a314 1
	 FALSE,			/* partial_inplace */
d317 1
a317 1
	 FALSE),		/* pcrel_offset */
d323 1
a323 1
	 FALSE,			/* pc_relative */
d328 1
a328 1
	 FALSE,			/* partial_inplace */
d331 1
a331 1
	 FALSE)			/* pcrel_offset */
d389 1
a389 1
     Elf_Internal_Rela *dst;
d431 1
a431 1
static bfd_boolean
d439 1
a439 1
  return TRUE;
d446 1
a446 1
static bfd_boolean
d458 2
a459 2
  if (info->relocatable)
    return TRUE;
d480 1
a480 1
  return TRUE;
d705 1
a705 1
static bfd_boolean
d722 2
a723 2
  if (info->relocatable)
    return TRUE;
d753 1
a753 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d785 2
a786 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d808 1
a808 1
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
d833 1
a833 1
	    return FALSE;
d837 1
a837 1
  return TRUE;
d847 1
a847 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d882 1
a882 1
static bfd_boolean
@


1.11.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d30 1
a30 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d34 1
a34 1
static bfd_boolean elf32_avr_gc_sweep_hook
d37 1
a37 1
static bfd_boolean elf32_avr_check_relocs
d43 1
a43 1
static bfd_boolean elf32_avr_relocate_section
d46 2
a47 2
static void bfd_elf_avr_final_write_processing PARAMS ((bfd *, bfd_boolean));
static bfd_boolean elf32_avr_object_p PARAMS ((bfd *));
d55 1
a55 1
	 FALSE,			/* pc_relative */
d60 1
a60 1
	 FALSE,			/* partial_inplace */
d63 1
a63 1
	 FALSE),		/* pcrel_offset */
d69 1
a69 1
	 FALSE,			/* pc_relative */
d74 1
a74 1
	 FALSE,			/* partial_inplace */
d77 1
a77 1
	 FALSE),		/* pcrel_offset */
d84 1
a84 1
	 TRUE,			/* pc_relative */
d89 1
a89 1
	 FALSE,			/* partial_inplace */
d92 1
a92 1
	 TRUE),			/* pcrel_offset */
d99 1
a99 1
	 TRUE,			/* pc_relative */
d104 1
a104 1
	 FALSE,			/* partial_inplace */
d107 1
a107 1
	 TRUE),			/* pcrel_offset */
d114 1
a114 1
	 FALSE,			/* pc_relative */
d119 1
a119 1
	 FALSE,			/* partial_inplace */
d122 1
a122 1
	 FALSE),		/* pcrel_offset */
d129 1
a129 1
	 FALSE,			/* pc_relative */
d134 1
a134 1
	 FALSE,			/* partial_inplace */
d137 1
a137 1
	 FALSE),		/* pcrel_offset */
d144 1
a144 1
	 FALSE,			/* pc_relative */
d149 1
a149 1
	 FALSE,			/* partial_inplace */
d152 1
a152 1
	 FALSE),		/* pcrel_offset */
d159 1
a159 1
	 FALSE,			/* pc_relative */
d164 1
a164 1
	 FALSE,			/* partial_inplace */
d167 1
a167 1
	 FALSE),		/* pcrel_offset */
d174 1
a174 1
	 FALSE,			/* pc_relative */
d179 1
a179 1
	 FALSE,			/* partial_inplace */
d182 1
a182 1
	 FALSE),		/* pcrel_offset */
d189 1
a189 1
	 FALSE,			/* pc_relative */
d194 1
a194 1
	 FALSE,			/* partial_inplace */
d197 1
a197 1
	 FALSE),		/* pcrel_offset */
d204 1
a204 1
	 FALSE,			/* pc_relative */
d209 1
a209 1
	 FALSE,			/* partial_inplace */
d212 1
a212 1
	 FALSE),		/* pcrel_offset */
d219 1
a219 1
	 FALSE,			/* pc_relative */
d224 1
a224 1
	 FALSE,			/* partial_inplace */
d227 1
a227 1
	 FALSE),		/* pcrel_offset */
d234 1
a234 1
	 FALSE,			/* pc_relative */
d239 1
a239 1
	 FALSE,			/* partial_inplace */
d242 1
a242 1
	 FALSE),		/* pcrel_offset */
d249 1
a249 1
	 FALSE,			/* pc_relative */
d254 1
a254 1
	 FALSE,			/* partial_inplace */
d257 1
a257 1
	 FALSE),		/* pcrel_offset */
d264 1
a264 1
	 FALSE,			/* pc_relative */
d269 1
a269 1
	 FALSE,			/* partial_inplace */
d272 1
a272 1
	 FALSE),		/* pcrel_offset */
d279 1
a279 1
	 FALSE,			/* pc_relative */
d284 1
a284 1
	 FALSE,			/* partial_inplace */
d287 1
a287 1
	 FALSE),		/* pcrel_offset */
d294 1
a294 1
	 FALSE,			/* pc_relative */
d299 1
a299 1
	 FALSE,			/* partial_inplace */
d302 1
a302 1
	 FALSE),		/* pcrel_offset */
d309 1
a309 1
	 FALSE,			/* pc_relative */
d314 1
a314 1
	 FALSE,			/* partial_inplace */
d317 1
a317 1
	 FALSE),		/* pcrel_offset */
d323 1
a323 1
	 FALSE,			/* pc_relative */
d328 1
a328 1
	 FALSE,			/* partial_inplace */
d331 1
a331 1
	 FALSE)			/* pcrel_offset */
d389 1
a389 1
     Elf_Internal_Rela *dst;
d431 1
a431 1
static bfd_boolean
d439 1
a439 1
  return TRUE;
d446 1
a446 1
static bfd_boolean
d459 1
a459 1
    return TRUE;
d480 1
a480 1
  return TRUE;
d705 1
a705 1
static bfd_boolean
d723 1
a723 1
    return TRUE;
d785 2
a786 2
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
d808 1
a808 1
		(info, name, input_bfd, input_section, rel->r_offset, TRUE);
d833 1
a833 1
	    return FALSE;
d837 1
a837 1
  return TRUE;
d847 1
a847 1
     bfd_boolean linker ATTRIBUTE_UNUSED;
d882 1
a882 1
static bfd_boolean
@


1.11.10.2
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d458 1
a458 1
  if (info->relocatable)
d722 1
a722 1
  if (info->relocatable)
@


1.11.10.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d753 1
a753 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
@


1.10
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@a48 3
/* Use RELA instead of REL */
#undef USE_REL

d722 3
d741 1
a743 22

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;

	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections [r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d934 1
@


1.9
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d32 1
a32 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d402 2
a403 2
elf32_avr_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d429 1
a429 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.9.10.1
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d32 1
a32 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d402 2
a403 2
elf32_avr_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d429 3
a431 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
@


1.9.10.2
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d49 3
a724 3
  if (info->relocateable)
    return true;

a740 1
      /* This is a final link.  */
d743 22
a954 1
#define elf_backend_rela_normal		     1
@


1.8
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d430 1
a430 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && !((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
	       && sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
d432 1
@


1.7
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d781 1
a781 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.6
log
@* elf.c (prep_headers): Get the machine code from the elf
backend data.
* elf-m10200.c (ELF_MACHINE_CODE): Redefine to EM_MN10200.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10200.
* elf-m10300.c (ELF_MACHINE_CODE): Redefine to EM_MN10300.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_MN10300.
* elf-arc.c (arc_elf_final_write_processing): Don't override
e_machine, it's now properly set in prep_headers.
* elf32-avr.c (elf32_avr_object_p): Accept both EM_AVR and
EM_AVR_OLD.
(ELF_MACHINE_ALT1): Define to EM_AVR_OLD.
* elf-d10v.c (ELF_MACHINE_CODE): Redefine to EM_D10V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D10V.
* elf-d30v.c (ELF_MACHINE_CODE): Redefine to EM_D30V.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_D30V.
* elf-fr30.c (ELF_MACHINE_CODE): Redefine to EM_FR30.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_FR30.
* elf-m32r.c (ELF_MACHINE_CODE): Redefine to EM_M32R.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_M32R.
* elf32-pj.c (ELF_MACHINE_ALT1): DEfine to EM_PJ_OLD.
* elf-v850.c (ELF_MACHINE_CODE): Redefine to EM_V850.
(ELF_MACHINE_ALT1): Define to EM_CYGNUS_V850.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d702 1
a702 1
      bfd_put_16 (input_bfd, srel & 0xffff, contents+2);
d916 1
a916 1
  int e_set = bfd_mach_avr2;
@


1.5
log
@Update copyright notices
@
text
@d917 2
a918 1
  if (elf_elfheader (abfd)->e_machine == EM_AVR)
d951 1
@


1.4
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* elf32-arm.h: Fix formatting.
	* elf32-avr.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d10v.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
@


1.4.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.3
log
@Tidy up formatting.
Add  -mall-opcodes, -mno-skip-bug, -mno-wrap.
@
text
@a20 1

a48 1

d473 1
a473 1
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
d517 1
a517 1
      srel -= 2;	/* Branch instructions add 2 to the PC... */
d535 1
a535 1
      srel -= 2;	/* Branch instructions add 2 to the PC... */
a947 1

a964 1

@


1.2
log
@Applied Marek Michalkiewicz <marekm@@linux.org.pl>'s patch to ehance the AVR port.
@
text
@d372 1
a372 1
     bfd *abfd;
d392 1
a392 1
     bfd *abfd;
d406 1
a406 1
     struct bfd_link_info *info;
d445 4
a448 4
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d720 1
a720 1
     bfd *output_bfd;
@


1.1
log
@ATMEL AVR microcontroller support.
@
text
@d551 1
a551 1
	  if (bfd_get_mach (input_bfd) == bfd_mach_avr2)
d553 6
a558 4
	      if (srel > 2047)
		srel -= 4096;
	      else
		srel += 4096;
a559 2
	  else
	    return bfd_reloc_overflow;
d902 3
d939 4
@

