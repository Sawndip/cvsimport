head	1.39;
access;
symbols
	sid-snapshot-20180601:1.39
	sid-snapshot-20180501:1.39
	sid-snapshot-20180401:1.39
	sid-snapshot-20180301:1.39
	sid-snapshot-20180201:1.39
	sid-snapshot-20180101:1.39
	sid-snapshot-20171201:1.39
	sid-snapshot-20171101:1.39
	sid-snapshot-20171001:1.39
	sid-snapshot-20170901:1.39
	sid-snapshot-20170801:1.39
	sid-snapshot-20170701:1.39
	sid-snapshot-20170601:1.39
	sid-snapshot-20170501:1.39
	sid-snapshot-20170401:1.39
	sid-snapshot-20170301:1.39
	sid-snapshot-20170201:1.39
	sid-snapshot-20170101:1.39
	sid-snapshot-20161201:1.39
	sid-snapshot-20161101:1.39
	sid-snapshot-20160901:1.39
	sid-snapshot-20160801:1.39
	sid-snapshot-20160701:1.39
	sid-snapshot-20160601:1.39
	sid-snapshot-20160501:1.39
	sid-snapshot-20160401:1.39
	sid-snapshot-20160301:1.39
	sid-snapshot-20160201:1.39
	sid-snapshot-20160101:1.39
	sid-snapshot-20151201:1.39
	sid-snapshot-20151101:1.39
	sid-snapshot-20151001:1.39
	sid-snapshot-20150901:1.39
	sid-snapshot-20150801:1.39
	sid-snapshot-20150701:1.39
	sid-snapshot-20150601:1.39
	sid-snapshot-20150501:1.39
	sid-snapshot-20150401:1.39
	sid-snapshot-20150301:1.39
	sid-snapshot-20150201:1.39
	sid-snapshot-20150101:1.39
	sid-snapshot-20141201:1.39
	sid-snapshot-20141101:1.39
	sid-snapshot-20141001:1.39
	sid-snapshot-20140901:1.39
	sid-snapshot-20140801:1.39
	sid-snapshot-20140701:1.39
	sid-snapshot-20140601:1.39
	sid-snapshot-20140501:1.39
	sid-snapshot-20140401:1.39
	sid-snapshot-20140301:1.39
	sid-snapshot-20140201:1.39
	sid-snapshot-20140101:1.39
	sid-snapshot-20131201:1.39
	sid-snapshot-20131101:1.39
	sid-snapshot-20131001:1.39
	binutils-2_24-branch:1.39.0.14
	binutils-2_24-branchpoint:1.39
	binutils-2_21_1:1.38
	sid-snapshot-20130901:1.39
	gdb_7_6_1-2013-08-30-release:1.39
	sid-snapshot-20130801:1.39
	sid-snapshot-20130701:1.39
	sid-snapshot-20130601:1.39
	sid-snapshot-20130501:1.39
	gdb_7_6-2013-04-26-release:1.39
	sid-snapshot-20130401:1.39
	binutils-2_23_2:1.39
	gdb_7_6-branch:1.39.0.12
	gdb_7_6-2013-03-12-branchpoint:1.39
	sid-snapshot-20130301:1.39
	sid-snapshot-20130201:1.39
	sid-snapshot-20130101:1.39
	sid-snapshot-20121201:1.39
	gdb_7_5_1-2012-11-29-release:1.39
	binutils-2_23_1:1.39
	sid-snapshot-20121101:1.39
	binutils-2_23:1.39
	sid-snapshot-20121001:1.39
	sid-snapshot-20120901:1.39
	gdb_7_5-2012-08-17-release:1.39
	sid-snapshot-20120801:1.39
	binutils-2_23-branch:1.39.0.10
	binutils-2_23-branchpoint:1.39
	gdb_7_5-branch:1.39.0.8
	gdb_7_5-2012-07-18-branchpoint:1.39
	sid-snapshot-20120701:1.39
	sid-snapshot-20120601:1.39
	sid-snapshot-20120501:1.39
	binutils-2_22_branch:1.39.0.6
	gdb_7_4_1-2012-04-26-release:1.39
	sid-snapshot-20120401:1.39
	sid-snapshot-20120301:1.39
	sid-snapshot-20120201:1.39
	gdb_7_4-2012-01-24-release:1.39
	sid-snapshot-20120101:1.39
	gdb_7_4-branch:1.39.0.4
	gdb_7_4-2011-12-13-branchpoint:1.39
	sid-snapshot-20111201:1.39
	binutils-2_22:1.39
	sid-snapshot-20111101:1.39
	sid-snapshot-20111001:1.39
	binutils-2_22-branch:1.39.0.2
	binutils-2_22-branchpoint:1.39
	gdb_7_3_1-2011-09-04-release:1.38
	sid-snapshot-20110901:1.39
	sid-snapshot-20110801:1.39
	gdb_7_3-2011-07-26-release:1.38
	sid-snapshot-20110701:1.39
	sid-snapshot-20110601:1.38
	sid-snapshot-20110501:1.38
	gdb_7_3-branch:1.38.0.4
	gdb_7_3-2011-04-01-branchpoint:1.38
	sid-snapshot-20110401:1.38
	sid-snapshot-20110301:1.38
	sid-snapshot-20110201:1.38
	sid-snapshot-20110101:1.38
	binutils-2_21:1.38
	sid-snapshot-20101201:1.38
	binutils-2_21-branch:1.38.0.2
	binutils-2_21-branchpoint:1.38
	sid-snapshot-20101101:1.38
	sid-snapshot-20101001:1.38
	binutils-2_20_1:1.30
	gdb_7_2-2010-09-02-release:1.37
	sid-snapshot-20100901:1.38
	sid-snapshot-20100801:1.37
	gdb_7_2-branch:1.37.0.2
	gdb_7_2-2010-07-07-branchpoint:1.37
	sid-snapshot-20100701:1.37
	sid-snapshot-20100601:1.36
	sid-snapshot-20100501:1.33
	sid-snapshot-20100401:1.32
	gdb_7_1-2010-03-18-release:1.31
	sid-snapshot-20100301:1.31
	gdb_7_1-branch:1.31.0.2
	gdb_7_1-2010-02-18-branchpoint:1.31
	sid-snapshot-20100201:1.31
	sid-snapshot-20100101:1.30
	gdb_7_0_1-2009-12-22-release:1.30
	sid-snapshot-20091201:1.30
	sid-snapshot-20091101:1.30
	binutils-2_20:1.30
	gdb_7_0-2009-10-06-release:1.30
	sid-snapshot-20091001:1.30
	gdb_7_0-branch:1.30.0.8
	gdb_7_0-2009-09-16-branchpoint:1.30
	arc-sim-20090309:1.28
	binutils-arc-20081103-branch:1.29.0.12
	binutils-arc-20081103-branchpoint:1.29
	binutils-2_20-branch:1.30.0.6
	binutils-2_20-branchpoint:1.30
	sid-snapshot-20090901:1.30
	sid-snapshot-20090801:1.30
	msnyder-checkpoint-072509-branch:1.30.0.4
	msnyder-checkpoint-072509-branchpoint:1.30
	sid-snapshot-20090701:1.30
	dje-cgen-play1-branch:1.30.0.2
	dje-cgen-play1-branchpoint:1.30
	sid-snapshot-20090601:1.30
	sid-snapshot-20090501:1.30
	sid-snapshot-20090401:1.30
	arc-20081103-branch:1.29.0.10
	arc-20081103-branchpoint:1.29
	arc-insight_6_8-branch:1.28.0.10
	arc-insight_6_8-branchpoint:1.28
	insight_6_8-branch:1.28.0.8
	insight_6_8-branchpoint:1.28
	sid-snapshot-20090301:1.30
	binutils-2_19_1:1.29
	sid-snapshot-20090201:1.29
	sid-snapshot-20090101:1.29
	reverse-20081226-branch:1.29.0.8
	reverse-20081226-branchpoint:1.29
	sid-snapshot-20081201:1.29
	multiprocess-20081120-branch:1.29.0.6
	multiprocess-20081120-branchpoint:1.29
	sid-snapshot-20081101:1.29
	binutils-2_19:1.29
	sid-snapshot-20081001:1.29
	reverse-20080930-branch:1.29.0.4
	reverse-20080930-branchpoint:1.29
	binutils-2_19-branch:1.29.0.2
	binutils-2_19-branchpoint:1.29
	sid-snapshot-20080901:1.29
	sid-snapshot-20080801:1.29
	reverse-20080717-branch:1.28.0.6
	reverse-20080717-branchpoint:1.28
	sid-snapshot-20080701:1.28
	msnyder-reverse-20080609-branch:1.28.0.4
	msnyder-reverse-20080609-branchpoint:1.28
	drow-reverse-20070409-branch:1.24.0.34
	drow-reverse-20070409-branchpoint:1.24
	sid-snapshot-20080601:1.28
	sid-snapshot-20080501:1.28
	sid-snapshot-20080403:1.28
	sid-snapshot-20080401:1.28
	gdb_6_8-2008-03-27-release:1.28
	sid-snapshot-20080301:1.28
	gdb_6_8-branch:1.28.0.2
	gdb_6_8-2008-02-26-branchpoint:1.28
	sid-snapshot-20080201:1.27
	sid-snapshot-20080101:1.27
	sid-snapshot-20071201:1.27
	sid-snapshot-20071101:1.27
	gdb_6_7_1-2007-10-29-release:1.26
	gdb_6_7-2007-10-10-release:1.26
	sid-snapshot-20071001:1.26
	gdb_6_7-branch:1.26.0.4
	gdb_6_7-2007-09-07-branchpoint:1.26
	binutils-2_18:1.26
	binutils-2_18-branch:1.26.0.2
	binutils-2_18-branchpoint:1.26
	insight_6_6-20070208-release:1.24
	binutils-csl-coldfire-4_1-32:1.24
	binutils-csl-sourcerygxx-4_1-32:1.24
	gdb_6_6-2006-12-18-release:1.24
	binutils-csl-innovasic-fido-3_4_4-33:1.24
	binutils-csl-sourcerygxx-3_4_4-32:1.21
	binutils-csl-coldfire-4_1-30:1.24
	binutils-csl-sourcerygxx-4_1-30:1.24
	binutils-csl-coldfire-4_1-28:1.24
	binutils-csl-sourcerygxx-4_1-29:1.24
	binutils-csl-sourcerygxx-4_1-28:1.24
	gdb_6_6-branch:1.24.0.32
	gdb_6_6-2006-11-15-branchpoint:1.24
	binutils-csl-arm-2006q3-27:1.24
	binutils-csl-sourcerygxx-4_1-27:1.24
	binutils-csl-arm-2006q3-26:1.24
	binutils-csl-sourcerygxx-4_1-26:1.24
	binutils-csl-sourcerygxx-4_1-25:1.24
	binutils-csl-sourcerygxx-4_1-24:1.24
	binutils-csl-sourcerygxx-4_1-23:1.24
	insight_6_5-20061003-release:1.24
	gdb-csl-symbian-6_4_50_20060226-12:1.24
	binutils-csl-sourcerygxx-4_1-21:1.24
	binutils-csl-arm-2006q3-21:1.24
	binutils-csl-sourcerygxx-4_1-22:1.24
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.24
	binutils-csl-sourcerygxx-4_1-20:1.24
	binutils-csl-arm-2006q3-19:1.24
	binutils-csl-sourcerygxx-4_1-19:1.24
	binutils-csl-sourcerygxx-4_1-18:1.24
	binutils-csl-renesas-4_1-9:1.24
	gdb-csl-sourcerygxx-3_4_4-25:1.24
	binutils-csl-sourcerygxx-3_4_4-25:1.21
	nickrob-async-20060828-mergepoint:1.24
	gdb-csl-symbian-6_4_50_20060226-11:1.24
	binutils-csl-renesas-4_1-8:1.24
	binutils-csl-renesas-4_1-7:1.24
	binutils-csl-renesas-4_1-6:1.24
	gdb-csl-sourcerygxx-4_1-17:1.24
	binutils-csl-sourcerygxx-4_1-17:1.24
	gdb-csl-20060226-branch-local-2:1.24
	gdb-csl-sourcerygxx-4_1-14:1.24
	binutils-csl-sourcerygxx-4_1-14:1.24
	binutils-csl-sourcerygxx-4_1-15:1.24
	gdb-csl-sourcerygxx-4_1-13:1.24
	binutils-csl-sourcerygxx-4_1-13:1.24
	binutils-2_17:1.24
	gdb-csl-sourcerygxx-4_1-12:1.24
	binutils-csl-sourcerygxx-4_1-12:1.24
	gdb-csl-sourcerygxx-3_4_4-21:1.24
	binutils-csl-sourcerygxx-3_4_4-21:1.24
	gdb_6_5-20060621-release:1.24
	binutils-csl-wrs-linux-3_4_4-24:1.21
	binutils-csl-wrs-linux-3_4_4-23:1.21
	gdb-csl-sourcerygxx-4_1-9:1.24
	binutils-csl-sourcerygxx-4_1-9:1.24
	gdb-csl-sourcerygxx-4_1-8:1.24
	binutils-csl-sourcerygxx-4_1-8:1.24
	gdb-csl-sourcerygxx-4_1-7:1.24
	binutils-csl-sourcerygxx-4_1-7:1.24
	gdb-csl-arm-2006q1-6:1.24
	binutils-csl-arm-2006q1-6:1.24
	gdb-csl-sourcerygxx-4_1-6:1.24
	binutils-csl-sourcerygxx-4_1-6:1.24
	binutils-csl-wrs-linux-3_4_4-22:1.21
	gdb-csl-symbian-6_4_50_20060226-10:1.24
	gdb-csl-symbian-6_4_50_20060226-9:1.24
	gdb-csl-symbian-6_4_50_20060226-8:1.24
	gdb-csl-coldfire-4_1-11:1.24
	binutils-csl-coldfire-4_1-11:1.24
	gdb-csl-sourcerygxx-3_4_4-19:1.24
	binutils-csl-sourcerygxx-3_4_4-19:1.24
	gdb-csl-coldfire-4_1-10:1.24
	gdb_6_5-branch:1.24.0.30
	gdb_6_5-2006-05-14-branchpoint:1.24
	binutils-csl-coldfire-4_1-10:1.24
	gdb-csl-sourcerygxx-4_1-5:1.24
	binutils-csl-sourcerygxx-4_1-5:1.24
	nickrob-async-20060513-branch:1.24.0.28
	nickrob-async-20060513-branchpoint:1.24
	gdb-csl-sourcerygxx-4_1-4:1.24
	binutils-csl-sourcerygxx-4_1-4:1.24
	msnyder-reverse-20060502-branch:1.24.0.26
	msnyder-reverse-20060502-branchpoint:1.24
	binutils-csl-wrs-linux-3_4_4-21:1.21
	gdb-csl-morpho-4_1-4:1.24
	binutils-csl-morpho-4_1-4:1.24
	gdb-csl-sourcerygxx-3_4_4-17:1.24
	binutils-csl-sourcerygxx-3_4_4-17:1.24
	binutils-csl-wrs-linux-3_4_4-20:1.21
	readline_5_1-import-branch:1.24.0.24
	readline_5_1-import-branchpoint:1.24
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.24
	binutils-2_17-branch:1.24.0.22
	binutils-2_17-branchpoint:1.24
	gdb-csl-symbian-20060226-branch:1.24.0.20
	gdb-csl-symbian-20060226-branchpoint:1.24
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.24
	msnyder-reverse-20060331-branch:1.24.0.18
	msnyder-reverse-20060331-branchpoint:1.24
	binutils-csl-2_17-branch:1.24.0.16
	binutils-csl-2_17-branchpoint:1.24
	gdb-csl-available-20060303-branch:1.24.0.14
	gdb-csl-available-20060303-branchpoint:1.24
	gdb-csl-20060226-branch:1.24.0.12
	gdb-csl-20060226-branchpoint:1.24
	gdb_6_4-20051202-release:1.24
	msnyder-fork-checkpoint-branch:1.24.0.10
	msnyder-fork-checkpoint-branchpoint:1.24
	gdb-csl-gxxpro-6_3-branch:1.24.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.24
	gdb_6_4-branch:1.24.0.6
	gdb_6_4-2005-11-01-branchpoint:1.24
	gdb-csl-arm-20051020-branch:1.24.0.4
	gdb-csl-arm-20051020-branchpoint:1.24
	binutils-csl-gxxpro-3_4-branch:1.21.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.21
	binutils-2_16_1:1.21
	msnyder-tracepoint-checkpoint-branch:1.24.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.24
	gdb-csl-arm-20050325-2005-q1b:1.21
	binutils-csl-arm-2005q1b:1.21
	binutils-2_16:1.21
	gdb-csl-arm-20050325-2005-q1a:1.21
	binutils-csl-arm-2005q1a:1.21
	csl-arm-20050325-branch:1.21.0.6
	csl-arm-20050325-branchpoint:1.21
	binutils-csl-arm-2005q1-branch:1.21.0.4
	binutils-csl-arm-2005q1-branchpoint:1.21
	binutils-2_16-branch:1.21.0.2
	binutils-2_16-branchpoint:1.21
	csl-arm-2004-q3d:1.19
	gdb_6_3-20041109-release:1.19
	gdb_6_3-branch:1.19.0.4
	gdb_6_3-20041019-branchpoint:1.19
	csl-arm-2004-q3:1.19
	drow_intercu-merge-20040921:1.19
	drow_intercu-merge-20040915:1.19
	jimb-gdb_6_2-e500-branch:1.19.0.6
	jimb-gdb_6_2-e500-branchpoint:1.19
	gdb_6_2-20040730-release:1.19
	gdb_6_2-branch:1.19.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.19
	gdb_6_1_1-20040616-release:1.18
	binutils-2_15:1.18
	binutils-2_15-branchpoint:1.18
	csl-arm-2004-q1a:1.18
	csl-arm-2004-q1:1.18
	gdb_6_1-2004-04-05-release:1.18
	drow_intercu-merge-20040402:1.18
	drow_intercu-merge-20040327:1.18
	ezannoni_pie-20040323-branch:1.18.0.14
	ezannoni_pie-20040323-branchpoint:1.18
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.18.0.12
	cagney_tramp-20040309-branchpoint:1.18
	gdb_6_1-branch:1.18.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.18
	drow_intercu-20040221-branch:1.18.0.8
	drow_intercu-20040221-branchpoint:1.18
	binutils-2_15-branch:1.18.0.6
	cagney_bfdfile-20040213-branch:1.18.0.4
	cagney_bfdfile-20040213-branchpoint:1.18
	drow-cplus-merge-20040208:1.18
	carlton_dictionary-20040126-merge:1.18
	cagney_bigcore-20040122-branch:1.18.0.2
	cagney_bigcore-20040122-branchpoint:1.18
	drow-cplus-merge-20040113:1.18
	csl-arm-2003-q4:1.18
	drow-cplus-merge-20031224:1.18
	drow-cplus-merge-20031220:1.18
	carlton_dictionary-20031215-merge:1.18
	drow-cplus-merge-20031214:1.18
	carlton-dictionary-20031111-merge:1.17
	gdb_6_0-2003-10-04-release:1.16
	kettenis_sparc-20030918-branch:1.16.0.42
	kettenis_sparc-20030918-branchpoint:1.16
	carlton_dictionary-20030917-merge:1.16
	ezannoni_pie-20030916-branchpoint:1.16
	ezannoni_pie-20030916-branch:1.16.0.40
	cagney_x86i386-20030821-branch:1.16.0.38
	cagney_x86i386-20030821-branchpoint:1.16
	carlton_dictionary-20030805-merge:1.16
	carlton_dictionary-20030627-merge:1.16
	gdb_6_0-branch:1.16.0.36
	gdb_6_0-2003-06-23-branchpoint:1.16
	jimb-ppc64-linux-20030613-branch:1.16.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.16
	binutils-2_14:1.16
	cagney_convert-20030606-branch:1.16.0.32
	cagney_convert-20030606-branchpoint:1.16
	cagney_writestrings-20030508-branch:1.16.0.30
	cagney_writestrings-20030508-branchpoint:1.16
	jimb-ppc64-linux-20030528-branch:1.16.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.16
	carlton_dictionary-20030523-merge:1.16
	cagney_fileio-20030521-branch:1.16.0.26
	cagney_fileio-20030521-branchpoint:1.16
	kettenis_i386newframe-20030517-mergepoint:1.16
	jimb-ppc64-linux-20030509-branch:1.16.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.16
	kettenis_i386newframe-20030504-mergepoint:1.16
	carlton_dictionary-20030430-merge:1.16
	binutils-2_14-branch:1.16.0.22
	binutils-2_14-branchpoint:1.16
	kettenis_i386newframe-20030419-branch:1.16.0.20
	kettenis_i386newframe-20030419-branchpoint:1.16
	carlton_dictionary-20030416-merge:1.16
	cagney_frameaddr-20030409-mergepoint:1.16
	kettenis_i386newframe-20030406-branch:1.16.0.18
	kettenis_i386newframe-20030406-branchpoint:1.16
	cagney_frameaddr-20030403-branchpoint:1.16
	cagney_frameaddr-20030403-branch:1.16.0.16
	cagney_framebase-20030330-mergepoint:1.16
	cagney_framebase-20030326-branch:1.16.0.14
	cagney_framebase-20030326-branchpoint:1.16
	cagney_lazyid-20030317-branch:1.16.0.12
	cagney_lazyid-20030317-branchpoint:1.16
	kettenis-i386newframe-20030316-mergepoint:1.16
	offbyone-20030313-branch:1.16.0.10
	offbyone-20030313-branchpoint:1.16
	kettenis-i386newframe-20030308-branch:1.16.0.8
	kettenis-i386newframe-20030308-branchpoint:1.16
	carlton_dictionary-20030305-merge:1.16
	cagney_offbyone-20030303-branch:1.16.0.6
	cagney_offbyone-20030303-branchpoint:1.16
	carlton_dictionary-20030207-merge:1.16
	interps-20030202-branch:1.16.0.4
	interps-20030202-branchpoint:1.16
	cagney-unwind-20030108-branch:1.16.0.2
	cagney-unwind-20030108-branchpoint:1.16
	binutils-2_13_2_1:1.13.12.1
	binutils-2_13_2:1.13.12.1
	carlton_dictionary-20021223-merge:1.16
	gdb_5_3-2002-12-12-release:1.14
	carlton_dictionary-20021115-merge:1.14
	binutils-2_13_1:1.13.12.1
	kseitz_interps-20021105-merge:1.14
	kseitz_interps-20021103-merge:1.14
	drow-cplus-merge-20021020:1.14
	drow-cplus-merge-20021025:1.14
	carlton_dictionary-20021025-merge:1.14
	carlton_dictionary-20021011-merge:1.14
	drow-cplus-branch:1.14.0.12
	drow-cplus-branchpoint:1.14
	kseitz_interps-20020930-merge:1.14
	carlton_dictionary-20020927-merge:1.14
	carlton_dictionary-branch:1.14.0.10
	carlton_dictionary-20020920-branchpoint:1.14
	sid-20020905-branchpoint:1.14
	sid-20020905-branch:1.14.0.8
	gdb_5_3-branch:1.14.0.6
	gdb_5_3-2002-09-04-branchpoint:1.14
	kseitz_interps-20020829-merge:1.14
	cagney_sysregs-20020825-branch:1.14.0.4
	cagney_sysregs-20020825-branchpoint:1.14
	readline_4_3-import-branch:1.14.0.2
	readline_4_3-import-branchpoint:1.14
	binutils-2_13:1.13
	gdb_5_2_1-2002-07-23-release:1.13
	binutils-2_13-branchpoint:1.13
	binutils-2_13-branch:1.13.0.12
	kseitz_interps-20020528-branch:1.13.0.10
	kseitz_interps-20020528-branchpoint:1.13
	cagney_regbuf-20020515-branch:1.13.0.8
	cagney_regbuf-20020515-branchpoint:1.13
	binutils-2_12_1:1.13
	jimb-macro-020506-branch:1.13.0.6
	jimb-macro-020506-branchpoint:1.13
	gdb_5_2-2002-04-29-release:1.13
	binutils-2_12:1.13
	gdb_5_2-branch:1.13.0.4
	gdb_5_2-2002-03-03-branchpoint:1.13
	binutils-2_12-branch:1.13.0.2
	binutils-2_12-branchpoint:1.13
	gdb_5_1_1-2002-01-24-release:1.10
	gdb_5_1_0_1-2002-01-03-release:1.10
	cygnus_cvs_20020108_pre:1.13
	gdb_5_1_0_1-2002-01-03-branch:1.10.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.10
	gdb_5_1-2001-11-21-release:1.10
	gdb_s390-2001-09-26-branch:1.10.0.4
	gdb_s390-2001-09-26-branchpoint:1.10
	gdb_5_1-2001-07-29-branch:1.10.0.2
	gdb_5_1-2001-07-29-branchpoint:1.10
	binutils-2_11_2:1.8.2.2
	binutils-2_11_1:1.8.2.2
	binutils-2_11:1.8
	x86_64versiong3:1.9
	binutils-2_11-branch:1.8.0.2
	insight-precleanup-2001-01-01:1.7
	binutils-2_10_1:1.4
	binutils-2_10:1.4
	gdb-premipsmulti-2000-06-06-branch:1.4.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.4
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.4
	gdb_5_0-2000-04-10-branchpoint:1.4
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.39
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.4
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.39
date	2011.06.27.08.24.21;	author gingold;	state Exp;
branches;
next	1.38;

1.38
date	2010.08.03.15.18.51;	author gingold;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.11.15.13.32;	author gingold;	state Exp;
branches;
next	1.36;

1.36
date	2010.05.28.09.57.03;	author jkratoch;	state Exp;
branches;
next	1.35;

1.35
date	2010.05.27.13.43.44;	author gingold;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.25.10.14.15;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2010.04.14.09.24.59;	author gingold;	state Exp;
branches;
next	1.32;

1.32
date	2010.04.01.09.47.14;	author gingold;	state Exp;
branches;
next	1.31;

1.31
date	2010.01.27.16.43.27;	author gingold;	state Exp;
branches;
next	1.30;

1.30
date	2009.02.23.09.28.43;	author gingold;	state Exp;
branches;
next	1.29;

1.29
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2008.02.20.17.42.36;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.15.02.00.11;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.03.14.26.43;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.04.15.53.40;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.04.07.19.38;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.21.07.45.38;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.03.11.41.01;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.31.23.13.30;	author bje;	state Exp;
branches;
next	1.19;

1.19
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches
	1.18.8.1;
next	1.17;

1.17
date	2003.11.04.10.41.52;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.20.22.41.13;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.30.05.49.24;	author amodra;	state Exp;
branches
	1.14.10.1
	1.14.12.1;
next	1.13;

1.13
date	2002.01.06.07.30.35;	author amodra;	state Exp;
branches
	1.13.10.1
	1.13.12.1;
next	1.12;

1.12
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.01.10.29.27;	author aj;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.18.21.35.55;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.23.21.50.36;	author hjl;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.12.26.19.50.50;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.18.19.03.30;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.14.18.10.10;	author hjl;	state Exp;
branches;
next	1.4;

1.4
date	99.07.12.10.30.13;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.07.12.07.35.18;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.02.02.56.29;	author schwab;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.18.8.1
date	2004.09.16.17.00.38;	author drow;	state Exp;
branches;
next	;

1.14.10.1
date	2002.12.23.19.38.01;	author carlton;	state Exp;
branches;
next	1.14.10.2;

1.14.10.2
date	2003.11.11.23.50.31;	author carlton;	state Exp;
branches;
next	1.14.10.3;

1.14.10.3
date	2003.12.15.23.59.55;	author carlton;	state Exp;
branches;
next	;

1.14.12.1
date	2003.12.14.20.26.53;	author drow;	state Exp;
branches;
next	;

1.13.10.1
date	2002.08.09.18.34.18;	author kseitz;	state Exp;
branches;
next	;

1.13.12.1
date	2002.09.23.22.12.42;	author drow;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.06.11.10.04.21;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.39
log
@2011-06-27  Tristan Gingold  <gingold@@adacore.com>

	* vms-misc.c (vms_time_to_time_t): Adjust overflow detection.
	Add comment.
@
text
@/* vms-misc.c -- BFD back-end for VMS/VAX (openVMS/VAX) and
   EVAX (openVMS/Alpha) files.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2007, 2008, 2009, 2010  Free Software Foundation, Inc.

   Miscellaneous functions.

   Written by Klaus K"ampf (kkaempf@@rmi.de)

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#if __STDC__
#include <stdarg.h>
#endif

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "safe-ctype.h"

#ifdef VMS
#define __NEW_STARLET
#include <rms.h>
#include <unixlib.h>
#include <gen64def.h>
#include <starlet.h>
#define RME$C_SETRFM 0x00000001
#include <unistd.h>
#endif
#include <time.h>

#include "vms.h"
#include "vms/emh.h"

#if VMS_DEBUG
/* Debug functions.  */

/* Debug function for all vms extensions evaluates environment
   variable VMS_DEBUG for a numerical value on the first call all
   error levels below this value are printed:

   Levels:
   1	toplevel bfd calls (functions from the bfd vector)
   2	functions called by bfd calls
   ...
   9	almost everything

   Level is also indentation level. Indentation is performed
   if level > 0.  */

void
_bfd_vms_debug (int level, char *format, ...)
{
  static int min_level = -1;
  static FILE *output = NULL;
  char *eptr;
  va_list args;
  int abslvl = (level > 0) ? level : - level;

  if (min_level == -1)
    {
      if ((eptr = getenv ("VMS_DEBUG")) != NULL)
	{
	  min_level = atoi (eptr);
	  output = stderr;
	}
      else
	min_level = 0;
    }
  if (output == NULL)
    return;
  if (abslvl > min_level)
    return;

  while (--level > 0)
    fprintf (output, " ");
  va_start (args, format);
  vfprintf (output, format, args);
  fflush (output);
  va_end (args);
}

/* A debug function
   hex dump 'size' bytes starting at 'ptr'.  */

void
_bfd_hexdump (int level, unsigned char *ptr, int size, int offset)
{
  unsigned char *lptr = ptr;
  int count = 0;
  long start = offset;

  while (size-- > 0)
    {
      if ((count % 16) == 0)
	vms_debug (level, "%08lx:", start);
      vms_debug (-level, " %02x", *ptr++);
      count++;
      start++;
      if (size == 0)
	{
	  while ((count % 16) != 0)
	    {
	      vms_debug (-level, "   ");
	      count++;
	    }
	}
      if ((count % 16) == 0)
	{
	  vms_debug (-level, " ");
	  while (lptr < ptr)
	    {
	      vms_debug (-level, "%c", (*lptr < 32) ? '.' : *lptr);
	      lptr++;
	    }
	  vms_debug (-level, "\n");
	}
    }
  if ((count % 16) != 0)
    vms_debug (-level, "\n");
}
#endif


/* Copy sized string (string with fixed size) to new allocated area
   size is string size (size of record)  */

char *
_bfd_vms_save_sized_string (unsigned char *str, int size)
{
  char *newstr = bfd_malloc ((bfd_size_type) size + 1);

  if (newstr == NULL)
    return NULL;
  memcpy (newstr, (char *) str, (size_t) size);
  newstr[size] = 0;

  return newstr;
}

/* Copy counted string (string with size at first byte) to new allocated area
   ptr points to size byte on entry  */

char *
_bfd_vms_save_counted_string (unsigned char *ptr)
{
  int len = *ptr++;

  return _bfd_vms_save_sized_string (ptr, len);
}

/* Object output routines.   */

/* Begin new record.
   Write 2 bytes rectype and 2 bytes record length.  */

void
_bfd_vms_output_begin (struct vms_rec_wr *recwr, int rectype)
{
  vms_debug2 ((6, "_bfd_vms_output_begin (type %d)\n", rectype));

  /* Record must have been closed.  */
  BFD_ASSERT (recwr->size == 0);

  _bfd_vms_output_short (recwr, (unsigned int) rectype);

  /* Placeholder for length.  */
  _bfd_vms_output_short (recwr, 0);
}

/* Begin new sub-record.
   Write 2 bytes rectype, and 2 bytes record length.  */

void
_bfd_vms_output_begin_subrec (struct vms_rec_wr *recwr, int rectype)
{
  vms_debug2 ((6, "_bfd_vms_output_begin_subrec (type %d)\n", rectype));

  /* Subrecord must have been closed.  */
  BFD_ASSERT (recwr->subrec_offset == 0);

  /* Save start of subrecord offset.  */
  recwr->subrec_offset = recwr->size;

  /* Subrecord type.  */
  _bfd_vms_output_short (recwr, (unsigned int) rectype);

  /* Placeholder for length.  */
  _bfd_vms_output_short (recwr, 0);
}

/* Set record/subrecord alignment.   */

void
_bfd_vms_output_alignment (struct vms_rec_wr *recwr, int alignto)
{
  vms_debug2 ((6, "_bfd_vms_output_alignment (%d)\n", alignto));
  recwr->align = alignto;
}

/* Align the size of the current record (whose length is LENGTH).
   Warning: this obviously changes the record (and the possible subrecord)
   length.  */

static void
_bfd_vms_output_align (struct vms_rec_wr *recwr, unsigned int length)
{
  unsigned int real_size = recwr->size;
  unsigned int aligncount;

  /* Pad with 0 if alignment is required.  */
  aligncount = (recwr->align - (length % recwr->align)) % recwr->align;
  vms_debug2 ((6, "align: adding %d bytes\n", aligncount));
  while (aligncount-- > 0)
    recwr->buf[real_size++] = 0;

  recwr->size = real_size;
}

/* Ends current sub-record.  Set length field.  */

void
_bfd_vms_output_end_subrec (struct vms_rec_wr *recwr)
{
  int real_size = recwr->size;
  int length;

  /* Subrecord must be open.  */
  BFD_ASSERT (recwr->subrec_offset != 0);

  length = real_size - recwr->subrec_offset;

  if (length == 0)
    return;

  _bfd_vms_output_align (recwr, length);

  /* Put length to buffer.  */
  bfd_putl16 ((bfd_vma) (recwr->size - recwr->subrec_offset),
              recwr->buf + recwr->subrec_offset + 2);

  /* Close the subrecord.  */
  recwr->subrec_offset = 0;
}

/* Ends current record (and write it).  */

void
_bfd_vms_output_end (bfd *abfd, struct vms_rec_wr *recwr)
{
  vms_debug2 ((6, "_bfd_vms_output_end (size %u)\n", recwr->size));

  /* Subrecord must have been closed.  */
  BFD_ASSERT (recwr->subrec_offset == 0);

  if (recwr->size == 0)
    return;

  _bfd_vms_output_align (recwr, recwr->size);

  /* Write the length word.  */
  bfd_putl16 ((bfd_vma) recwr->size, recwr->buf + 2);

  /* File is open in undefined (UDF) format on VMS, but ultimately will be
     converted to variable length (VAR) format.  VAR format has a length
     word first which must be explicitly output in UDF format.  */
  /* So, first the length word.  */
  bfd_bwrite (recwr->buf + 2, 2, abfd);

  /* Align.  */
  if (recwr->size & 1)
    recwr->buf[recwr->size++] = 0;

  /* Then the record.  */
  bfd_bwrite (recwr->buf, (size_t) recwr->size, abfd);

  recwr->size = 0;
}

/* Check remaining buffer size.  Return what's left.  */

int
_bfd_vms_output_check (struct vms_rec_wr *recwr, int size)
{
  vms_debug2 ((6, "_bfd_vms_output_check (%d)\n", size));

  return (MAX_OUTREC_SIZE - (recwr->size + size + MIN_OUTREC_LUFT));
}

/* Output byte (8 bit) value.  */

void
_bfd_vms_output_byte (struct vms_rec_wr *recwr, unsigned int value)
{
  vms_debug2 ((6, "_bfd_vms_output_byte (%02x)\n", value));

  *(recwr->buf + recwr->size) = value;
  recwr->size += 1;
}

/* Output short (16 bit) value.  */

void
_bfd_vms_output_short (struct vms_rec_wr *recwr, unsigned int value)
{
  vms_debug2 ((6, "_bfd_vms_output_short (%04x)\n", value));

  bfd_putl16 ((bfd_vma) value & 0xffff, recwr->buf + recwr->size);
  recwr->size += 2;
}

/* Output long (32 bit) value.  */

void
_bfd_vms_output_long (struct vms_rec_wr *recwr, unsigned long value)
{
  vms_debug2 ((6, "_bfd_vms_output_long (%08lx)\n", value));

  bfd_putl32 ((bfd_vma) value, recwr->buf + recwr->size);
  recwr->size += 4;
}

/* Output quad (64 bit) value.  */

void
_bfd_vms_output_quad (struct vms_rec_wr *recwr, bfd_vma value)
{
  vms_debug2 ((6, "_bfd_vms_output_quad (%08lx)\n", (unsigned long)value));

  bfd_putl64 (value, recwr->buf + recwr->size);
  recwr->size += 8;
}

/* Output c-string as counted string.  */

void
_bfd_vms_output_counted (struct vms_rec_wr *recwr, const char *value)
{
  int len;

  vms_debug2 ((6, "_bfd_vms_output_counted (%s)\n", value));

  len = strlen (value);
  if (len == 0)
    {
      (*_bfd_error_handler) (_("_bfd_vms_output_counted called with zero bytes"));
      return;
    }
  if (len > 255)
    {
      (*_bfd_error_handler) (_("_bfd_vms_output_counted called with too many bytes"));
      return;
    }
  _bfd_vms_output_byte (recwr, (unsigned int) len & 0xff);
  _bfd_vms_output_dump (recwr, (const unsigned char *)value, len);
}

/* Output character area.  */

void
_bfd_vms_output_dump (struct vms_rec_wr *recwr, const unsigned char *data, int len)
{
  vms_debug2 ((6, "_bfd_vms_output_dump (%d)\n", len));

  if (len == 0)
    return;

  memcpy (recwr->buf + recwr->size, data, (size_t) len);
  recwr->size += len;
}

/* Output count bytes of value.  */

void
_bfd_vms_output_fill (struct vms_rec_wr *recwr, int value, int count)
{
  vms_debug2 ((6, "_bfd_vms_output_fill (val %02x times %d)\n", value, count));

  if (count == 0)
    return;
  memset (recwr->buf + recwr->size, value, (size_t) count);
  recwr->size += count;
}

#ifdef VMS
/* Convert the file to variable record length format. This is done
   using undocumented system call sys$modify().
   Pure VMS version.  */

static void
vms_convert_to_var (char * vms_filename)
{
  struct FAB fab = cc$rms_fab;

  fab.fab$l_fna = vms_filename;
  fab.fab$b_fns = strlen (vms_filename);
  fab.fab$b_fac = FAB$M_PUT;
  fab.fab$l_fop = FAB$M_ESC;
  fab.fab$l_ctx = RME$C_SETRFM;

  sys$open (&fab);

  fab.fab$b_rfm = FAB$C_VAR;

  sys$modify (&fab);
  sys$close (&fab);
}

static int
vms_convert_to_var_1 (char *filename, int type)
{
  if (type != DECC$K_FILE)
    return FALSE;
  vms_convert_to_var (filename);
  return TRUE;
}

/* Convert the file to variable record length format. This is done
   using undocumented system call sys$modify().
   Unix filename version.  */

int
_bfd_vms_convert_to_var_unix_filename (const char *unix_filename)
{
  if (decc$to_vms (unix_filename, &vms_convert_to_var_1, 0, 1) != 1)
    return FALSE;
  return TRUE;
}
#endif /* VMS */

/* Manufacture a VMS like time on a unix based system.
   stolen from obj-vms.c.  */

unsigned char *
get_vms_time_string (void)
{
  static unsigned char tbuf[18];
#ifndef VMS
  char *pnt;
  time_t timeb;

  time (& timeb);
  pnt = ctime (&timeb);
  pnt[3] = 0;
  pnt[7] = 0;
  pnt[10] = 0;
  pnt[16] = 0;
  pnt[24] = 0;
  sprintf ((char *) tbuf, "%2s-%3s-%s %s",
	   pnt + 8, pnt + 4, pnt + 20, pnt + 11);
#else
  struct
  {
    int Size;
    unsigned char *Ptr;
  } Descriptor;
  Descriptor.Size = 17;
  Descriptor.Ptr = tbuf;
  SYS$ASCTIM (0, &Descriptor, 0, 0);
#endif /* not VMS */

  vms_debug2 ((6, "vmstimestring:'%s'\n", tbuf));

  return tbuf;
}

/* Create module name from filename (ie, extract the basename and convert it
   in upper cases).  Works on both VMS and UNIX pathes.
   The result has to be free().  */

char *
vms_get_module_name (const char *filename, bfd_boolean upcase)
{
  char *fname, *fptr;
  const char *fout;

  /* Strip VMS path.  */
  fout = strrchr (filename, ']');
  if (fout == NULL)
    fout = strchr (filename, ':');
  if (fout != NULL)
    fout++;
  else
    fout = filename;

  /* Strip UNIX path.  */
  fptr = strrchr (fout, '/');
  if (fptr != NULL)
    fout = fptr + 1;

  fname = strdup (fout);

  /* Strip suffix.  */
  fptr = strrchr (fname, '.');
  if (fptr != 0)
    *fptr = 0;

  /* Convert to upper case and truncate at 31 characters.
     (VMS object file format restricts module name length to 31).  */
  fptr = fname;
  for (fptr = fname; *fptr != 0; fptr++)
    {
      if (*fptr == ';' || (fptr - fname) >= 31)
        {
          *fptr = 0;
          break;
        }
      if (upcase)
        *fptr = TOUPPER (*fptr);
    }
  return fname;
}

/* Compared to usual UNIX time_t, VMS time has less limits:
   -  64 bit (63 bits in fact as the MSB must be 0)
   -  100ns granularity
   -  epoch is Nov 17, 1858.
   Here has the constants and the routines used to convert VMS from/to UNIX time.
   The conversion routines don't assume 64 bits arithmetic.

   Here we assume that the definition of time_t is the UNIX one, ie integer
   type, expressing seconds since the epoch.  */

/* UNIX time granularity for VMS, ie 1s / 100ns.  */
#define VMS_TIME_FACTOR 10000000

/* Number of seconds since VMS epoch of the UNIX epoch.  */
#define VMS_TIME_OFFSET 3506716800U

/* Convert a VMS time to a unix time.  */

time_t
vms_time_to_time_t (unsigned int hi, unsigned int lo)
{
  unsigned int tmp;
  unsigned int rlo;
  int i;
  time_t res;

  /* First convert to seconds.  */
  tmp = hi % VMS_TIME_FACTOR;
  hi = hi / VMS_TIME_FACTOR;
  rlo = 0;
  for (i = 0; i < 4; i++)
    {
      tmp = (tmp << 8) | (lo >> 24);
      lo <<= 8;

      rlo = (rlo << 8) | (tmp / VMS_TIME_FACTOR);
      tmp %= VMS_TIME_FACTOR;
    }
  lo = rlo;

  /* Return 0 in case of overflow.  */
  if (hi > 1
      || (hi == 1 && lo >= VMS_TIME_OFFSET))
    return 0;

  /* Return 0 in case of underflow.  */
  if (hi == 0 && lo < VMS_TIME_OFFSET)
    return 0;

  res = lo - VMS_TIME_OFFSET;
  if (res <= 0)
    return 0;
  return res;
}

/* Convert a time_t to a VMS time.  */

void
vms_time_t_to_vms_time (time_t ut, unsigned int *hi, unsigned int *lo)
{
  unsigned short val[4];
  unsigned short tmp[4];
  unsigned int carry;
  int i;

  /* Put into val.  */
  val[0] = ut & 0xffff;
  val[1] = (ut >> 16) & 0xffff;
  val[2] = sizeof (ut) > 4 ? (ut >> 32) & 0xffff : 0;
  val[3] = sizeof (ut) > 4 ? (ut >> 48) & 0xffff : 0;

  /* Add offset.  */
  tmp[0] = VMS_TIME_OFFSET & 0xffff;
  tmp[1] = VMS_TIME_OFFSET >> 16;
  tmp[2] = 0;
  tmp[3] = 0;
  carry = 0;
  for (i = 0; i < 4; i++)
    {
      carry += tmp[i] + val[i];
      val[i] = carry & 0xffff;
      carry = carry >> 16;
    }

  /* Multiply by factor, well first by 10000 and then by 1000.  */
  carry = 0;
  for (i = 0; i < 4; i++)
    {
      carry += val[i] * 10000;
      val[i] = carry & 0xffff;
      carry = carry >> 16;
    }
  carry = 0;
  for (i = 0; i < 4; i++)
    {
      carry += val[i] * 1000;
      val[i] = carry & 0xffff;
      carry = carry >> 16;
    }

  /* Write the result.  */
  *lo = val[0] | (val[1] << 16);
  *hi = val[2] | (val[3] << 16);
}

/* Convert a raw (stored in a buffer) VMS time to a unix time.  */

time_t
vms_rawtime_to_time_t (unsigned char *buf)
{
  unsigned int hi = bfd_getl32 (buf + 4);
  unsigned int lo = bfd_getl32 (buf + 0);

  return vms_time_to_time_t (hi, lo);
}

void
vms_get_time (unsigned int *hi, unsigned int *lo)
{
#ifdef VMS
  struct _generic_64 t;

  sys$gettim (&t);
  *lo = t.gen64$q_quadword;
  *hi = t.gen64$q_quadword >> 32;
#else
  time_t t;

  time (&t);
  vms_time_t_to_vms_time (t, hi, lo);
#endif
}

/* Get the current time into a raw buffer BUF.  */

void
vms_raw_get_time (unsigned char *buf)
{
  unsigned int hi, lo;

  vms_get_time (&hi, &lo);
  bfd_putl32 (lo, buf + 0);
  bfd_putl32 (hi, buf + 4);
}
@


1.38
log
@2010-08-03  Tristan Gingold  <gingold@@adacore.com>

	* vms-misc.c (vms_convert_to_var): Make it static.
	(_bfd_vms_convert_to_var_unix_filename): Make it public.
@
text
@d533 4
a536 1
   The conversion routines don't assume 64 bits arithmetic.  */
d552 1
d569 2
a570 1
  if (lo > VMS_TIME_OFFSET && hi > 1)
d574 1
a574 1
  if (lo < VMS_TIME_OFFSET)
d577 4
a580 1
  return lo - VMS_TIME_OFFSET;
@


1.37
log
@2010-06-11  Tristan Gingold  <gingold@@adacore.com>

	* vms-misc.c (_bfd_vms_output_counted): Make VALUE argument const.
	Adjust cast.
	(_bfd_vms_output_dump): Make DATA argument const, adjust cast.
	* vms.h (_bfd_vms_output_counted, _bfd_vms_output_dump): Adjust.
	* vms-alpha.c (evax_section_flags): Make it const.
	(vms_secflag_by_name): Remove unused ABFD argument.
	Make SECTION_FLAGS and NAME arguments const. Clarify comment.
	(vms_esecflag_by_name): Make SECTION_FLAGS and NAME arguments const.
	(_bfd_vms_slurp_egsd): Adjust call to vms_secflag_by_name.
	(_bfd_vms_write_egsd): Remove useless cast.
@
text
@d404 2
a405 2
void
_bfd_vms_convert_to_var (char * vms_filename)
d436 2
a437 2
static int
vms_convert_to_var_unix_filename (const char *unix_filename)
@


1.36
log
@bfd/
	Workaround GCC PR middle-end/4210.
	* vms-misc.c (vms_time_t_to_vms_time): Use ternary operator for val[2]
	and val[3].
@
text
@d351 1
a351 1
_bfd_vms_output_counted (struct vms_rec_wr *recwr, char *value)
d369 1
a369 1
  _bfd_vms_output_dump (recwr, (unsigned char *) value, len);
d375 1
a375 1
_bfd_vms_output_dump (struct vms_rec_wr *recwr, unsigned char *data, int len)
@


1.35
log
@2010-05-27  Tristan Gingold  <gingold@@adacore.com>

	* vms-misc.c: Define __NEW_STARLET.  Remove trailing spaces.
	(VMS_TIME_FACTOR, VMS_TIME_OFFSET): New macros.
	(vms_time_to_time_t): Use them instead of local const.
	(vms_time_t_to_vms_time): New function.
	(vms_get_time): Likewise.
	(vms_raw_get_time): Likewise.
	* vms.h	(vms_time_t_to_vms_time): New declaration.
	(vms_get_time): Likewise.
	(vms_raw_get_time): Likewise.
@
text
@d588 2
a589 10
  if (sizeof (ut) > 4)
    {
      val[2] = (ut >> 32) & 0xffff;
      val[3] = (ut >> 48) & 0xffff;
    }
  else
    {
      val[2] = 0;
      val[3] = 0;
    }
@


1.34
log
@        PR ld/11624
        * archive.c (_bfd_calloc_wrapper): New function.
        (_bfd_add_bfd_to_archive_cache): Use it.

        * configure.in: Add alpha*-*-*vms* to list of natives.
        * configure: Regenerate.

        * vms-misc.c: Define globalref if necessary.
        (vms_convert_to_var_unix_filename): Rename to
        _bfd_vms_convert_to_var_unix_filename and export.
        * vms.h: Add prototype for _bfd_vms_convert_to_var_unix_filename.
        * vms-alpha.c (vms_close_and_cleanup): Update invocation of
        vms_convert_to_var_unix_filename.
@
text
@d36 1
a36 3
#if defined(__GNUC__) && !defined(globalref)
#define globalref extern
#endif
d39 1
d499 1
a499 1
      
d504 1
a504 1
  
d511 1
a511 1
  
d528 14
a541 1
/* Convert a raw VMS time to a unix time.  */
a545 2
  const unsigned int off = 3506716800U;
  const unsigned int factor = 10000000;
d551 2
a552 2
  tmp = hi % factor;
  hi = hi / factor;
d559 2
a560 2
      rlo = (rlo << 8) | (tmp / factor);
      tmp %= factor;
d565 5
a569 1
  if (lo > off && hi > 1)
d572 59
a630 1
  return lo - off;
d643 29
@


1.33
log
@2010-04-14  Tristan Gingold  <gingold@@adacore.com>

	* Makefile.am (BFD32_BACKENDS): Remove vms-gsd.lo, vms-hdr.lo,
	vms-tir.lo, vms.lo and add vms-alpha.lo
	(BFD32_BACKENDS_CFILES): Remove vms-gsd.c, vms-hdr.c,
	vms-tir.c, vms.c and add vms-alpha.c
	* Makefile.in: Regenerate.
	* configure.in (TDEFINES): Adjust file list for vms_alpha_vec.
	Remove vms_vax_vec.
	* configure: Regenerate.
	* targets.c (vms_vax_vec): Remove the declaration.
	(_bfd_target_vector): Remove vms_vax_vec.
	* vms-alpha.c: New file.
	* vms-gsd.c: Removed, rewritten in vms-alpha.c
	* vms-hdr.c: Ditto.
	* vms-tir.c: Ditto.
	* vms.c: Ditto.
	* vms-misc.c: Fix indentation and comments.  Replace most of
	#if VMS_DEBUG/vms_debug with vms_debug2.
	(_bfd_vms_hash_newfunc): Moved to vms-alpha.c
	(hash_string): Ditto.
	(_bfd_vms_length_hash_symbol): Ditto.
	(maybe_adjust_record_pointer_for_object): Ditto.
	(_bfd_vms_get_object_record): Ditto.
	(vms_get_remaining_object_record): Ditto.
	(_bfd_vms_push): Ditto.
	(_bfd_vms_pop): Ditto.
	(_bfd_vms_get_header_values): Removed.
	(_bfd_vms_get_first_record): Removed.
	(vms_get_remaining_image_record): Removed.
	(new_symbol): Removed.
	(_bfd_vms_enter_symbol): Removed.
	(_bfd_vms_save_sized_string): Use memcpy instead of strncpy.
	(_bfd_vms_output_begin): Remove rechead parameter.  Replace bfd
	parameter with struct vms_rec_wr.
	(_bfd_vms_output_push): Removed and replaced by ...
	(_bfd_vms_output_begin_subrec): ... new function.
	(_bfd_vms_output_alignment): Replace bfd parameter with
	struct vms_rec_wr, and adjust.
	(_bfd_vms_output_check): Ditto
	(_bfd_vms_output_byte): Ditto.
	(_bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long): Ditto.
	(_bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted): Ditto.
	(_bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(_bfd_vms_output_pop): Removed and replaced by ...
	(_bfd_vms_output_end_subrec): ... new function.
	(_bfd_vms_output_flush): Removed.
	(_bfd_vms_output_align): New function.
	(_bfd_vms_output_end): Add recwr parameter.  Adjust for this new
	parameter.
	(vms_convert_to_var): New function imported from vms.c
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_get_module_name): Ditto.
	(get_vms_time_string): Ditto.
	(vms_time_to_time_t): Ditto.
	(vms_rawtime_to_time_t): Ditto.
	* vms.h: All macros for the VMS file format are now in include/vms.
	Prototypes for vms.c, vms-gsd.c, vms-misc.c, vms-hdr.c, vms-tir.c
	have been removed.
	(struct vms_symbol_struct, struct stack_struct): Moved to vms-alpha.c
	(struct fileinfo, struct srecinfo, struct lineinfo): Ditto.
	(struct funcinfo, struct vms_private_data_struct): Ditto.
	(struct vms_section_data_struct): Ditto.
	(struct vms_rec_rd, stryct vms_rec_wr): New declarations.
	(vms_get_module_name, get_vms_time_string): New declarations.
	(vms_time_to_time_t, vms_rawtime_to_time_t): Ditto.
	(_bfd_vms_output_begin_subrec, _bfd_vms_output_end_subrec): Ditto.
	(_bfd_vms_save_sized_string, _bfd_vms_save_counted_string): Adjusted.
	(_bfd_vms_output_begin, _bfd_vms_output_alignment): Ditto.
	(_bfd_vms_output_end,_bfd_vms_output_check): Ditto.
	(_bfd_vms_output_byte, _bfd_vms_output_short): Ditto.
	(_bfd_vms_output_long, _bfd_vms_output_quad): Ditto.
	(_bfd_vms_output_counted, _bfd_vms_output_dump): Ditto.
	(_bfd_vms_output_fill): Ditto.
	(bfd_vms_set_section_flags): Ditto.
@
text
@d4 1
a4 1
   2007, 2008, 2009  Free Software Foundation, Inc.
d36 3
d405 2
a406 2
static void
vms_convert_to_var (char *vms_filename)
@


1.32
log
@2010-04-01  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Include time.h. Add prototypes for vms_get_module_name,
	vms_time_to_time_t and vms_rawtime_to_time_t.
	* vms.c (vms_alpha_vec): Add archives support.
	* vms-misc.c: Include safe-ctype.h
	(vms_get_module_name): New function.
	(vms_time_to_time_t, vms_rawtime_to_time_t): Ditto.
	* vms-hdr.c (_bfd_vms_write_hdr): Put module name creation to the
	vms_get_module_name function.  Use this function.
	* targets.c: Declare vms_lib_txt_vec.  Add it to _bfd_target_vector.
	* libbfd-in.h: Add prototype for _bfd_append_relative_path.
	Add prototypes for vms-lib.c
	* libbfd.h: Regenerate.
	* configure.in (TDEFINES): Add an entry for vms_lib_txt_vec.  Add
	vms-lib.lo to vms_alpha_vec.
	* config.bfd (targ_cpu): Add targ_selvecs for alpha*-*-*vms*.
	* configure: Regenerate.
	* bfd.c: Add selective_search field.
	* bfd-in2.h: Regenerate.
	* archive.c (append_relative_path): Rename to
	_bfd_append_relative_path and make it public.
	(_bfd_get_elt_at_filepos): Adjust for above renaming.
	* Makefile.am (BFD32_BACKENDS): Add vms-lib.lo
	(BFD32_BACKENDS_CFILES): Add vms-lib.c
	* Makefile.in: Regenerate.
@
text
@d35 9
d45 1
a45 8

#define MIN(a,b) ((a) < (b) ? (a) : (b))

static int hash_string PARAMS ((const char *));
static asymbol *new_symbol PARAMS ((bfd *, char *));
static void maybe_adjust_record_pointer_for_object PARAMS ((bfd *));
static int vms_get_remaining_object_record PARAMS ((bfd *, int ));
static int vms_get_remaining_image_record PARAMS ((bfd *, int ));
d87 1
a87 1
  while (--level>0)
d99 1
a99 4
_bfd_hexdump (int level,
	      unsigned char *ptr,
	      int size,
	      int offset)
d107 1
a107 1
      if ((count%16) == 0)
d114 1
a114 1
	  while ((count%16) != 0)
d120 1
a120 1
      if ((count%16) == 0)
d125 1
a125 1
	      vms_debug (-level, "%c", (*lptr < 32)?'.':*lptr);
d131 1
a131 1
  if ((count%16) != 0)
a135 410
/* Hash functions

   These are needed when reading an object file.  */

/* Allocate new vms_hash_entry
   keep the symbol name and a pointer to the bfd symbol in the table.  */

struct bfd_hash_entry *
_bfd_vms_hash_newfunc (struct bfd_hash_entry *entry,
		       struct bfd_hash_table *table,
		       const char *string)
{
  vms_symbol_entry *ret;

#if VMS_DEBUG
  vms_debug (5, "_bfd_vms_hash_newfunc (%p, %p, %s)\n", entry, table, string);
#endif

  if (entry == NULL)
    {
      ret = (vms_symbol_entry *)
	      bfd_hash_allocate (table, sizeof (vms_symbol_entry));
      if (ret ==  NULL)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return NULL;
	}
      entry = (struct bfd_hash_entry *) ret;
    }

  /* Call the allocation method of the base class.  */
  ret = (vms_symbol_entry *) bfd_hash_newfunc (entry, table, string);
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_hash_newfunc ret %p\n", ret);
#endif

  ret->symbol = NULL;

  return (struct bfd_hash_entry *)ret;
}

/* Object file input functions.  */

/* Return type and size from record header (buf) on Alpha.  */

void
_bfd_vms_get_header_values (bfd * abfd ATTRIBUTE_UNUSED,
			    unsigned char *buf,
			    int *type,
			    int *size)
{
  if (type)
    *type = bfd_getl16 (buf);

  if (size)
    *size = bfd_getl16 (buf+2);

#if VMS_DEBUG
  vms_debug (10, "_bfd_vms_get_header_values type %x, size %x\n",
	     type ? *type : 0, size ? *size : 0);
#endif
}

/* Get next record from object file to vms_buf.
   Set PRIV(buf_size) and return it

   This is a little tricky since it should be portable.

   The openVMS object file has 'variable length' which means that
   read() returns data in chunks of (hopefully) correct and expected
   size.  The linker (and other tools on VMS) depend on that. Unix
   doesn't know about 'formatted' files, so reading and writing such
   an object file in a Unix environment is not trivial.

   With the tool 'file' (available on all VMS FTP sites), one
   can view and change the attributes of a file.  Changing from
   'variable length' to 'fixed length, 512 bytes' reveals the
   record size at the first 2 bytes of every record.  The same
   may happen during the transfer of object files from VMS to Unix,
   at least with UCX, the DEC implementation of TCP/IP.

   The VMS format repeats the size at bytes 2 & 3 of every record.

   On the first call (file_format == FF_UNKNOWN) we check if
   the first and the third byte pair (!) of the record match.
   If they do it's an object file in an Unix environment or with
   wrong attributes (FF_FOREIGN), else we should be in a VMS
   environment where read() returns the record size (FF_NATIVE).

   Reading is always done in 2 steps:
    1. first just the record header is read and the size extracted,
    2. then the read buffer is adjusted and the remaining bytes are
       read in.

   All file I/O is done on even file positions.  */

#define VMS_OBJECT_ADJUSTMENT  2

static void
maybe_adjust_record_pointer_for_object (bfd *abfd)
{
  /* Set the file format once for all on the first invocation.  */
  if (PRIV (file_format) == FF_UNKNOWN)
    {
      if (PRIV (vms_rec)[0] == PRIV (vms_rec)[4]
	  && PRIV (vms_rec)[1] == PRIV (vms_rec)[5])
	PRIV (file_format) = FF_FOREIGN;
      else
	PRIV (file_format) = FF_NATIVE;
    }

  /* The adjustment is needed only in an Unix environment.  */
  if (PRIV (file_format) == FF_FOREIGN)
    PRIV (vms_rec) += VMS_OBJECT_ADJUSTMENT;
}

/* Get first record from file and return the file type.  */

int
_bfd_vms_get_first_record (bfd *abfd)
{
  unsigned int test_len;

#if VMS_DEBUG
  vms_debug (8, "_bfd_vms_get_first_record\n");
#endif

  if (PRIV (is_vax))
    test_len = 0;
  else
    /* Minimum is 6 bytes for objects (2 bytes size, 2 bytes record id,
       2 bytes size repeated) and 12 bytes for images (4 bytes major id,
       4 bytes minor id, 4 bytes length).  */
    test_len = 12;

  /* Size the main buffer.  */
  if (PRIV (buf_size) == 0)
    {
      /* On VAX there's no size information in the record, so
	 start with OBJ_S_C_MAXRECSIZ.  */
      bfd_size_type amt = (test_len ? test_len : OBJ_S_C_MAXRECSIZ);
      PRIV (vms_buf) = (unsigned char *) bfd_malloc (amt);
      PRIV (buf_size) = amt;
    }

  /* Initialize the record pointer.  */
  PRIV (vms_rec) = PRIV (vms_buf);

  /* We only support modules on VAX.  */
  if (PRIV (is_vax))
    {
      if (vms_get_remaining_object_record (abfd, test_len) <= 0)
	return FT_UNKNOWN;

#if VMS_DEBUG
      vms_debug (2, "file type is VAX module\n");
#endif

      return FT_MODULE;
    }

  if (bfd_bread (PRIV (vms_buf), test_len, abfd) != test_len)
    {
      bfd_set_error (bfd_error_file_truncated);
      return FT_UNKNOWN;
    }

  /* Is it an image?  */
  if ((bfd_getl32 (PRIV (vms_rec)) == EIHD_S_K_MAJORID)
      && (bfd_getl32 (PRIV (vms_rec) + 4) == EIHD_S_K_MINORID))
    {
      if (vms_get_remaining_image_record (abfd, test_len) <= 0)
	return FT_UNKNOWN;

#if VMS_DEBUG
      vms_debug (2, "file type is image\n");
#endif

      return FT_IMAGE;
    }

  /* Assume it's a module and adjust record pointer if necessary.  */
  maybe_adjust_record_pointer_for_object (abfd);

  /* But is it really a module?  */
  if (bfd_getl16 (PRIV (vms_rec)) <= EOBJ_S_C_MAXRECTYP
      && bfd_getl16 (PRIV (vms_rec) + 2) <= EOBJ_S_C_MAXRECSIZ)
    {
      if (vms_get_remaining_object_record (abfd, test_len) <= 0)
	return FT_UNKNOWN;

#if VMS_DEBUG
      vms_debug (2, "file type is module\n");
#endif

      return FT_MODULE;
    }

#if VMS_DEBUG
  vms_debug (2, "file type is unknown\n");
#endif

  return FT_UNKNOWN;
}

/* Implement step #1 of the object record reading procedure.
   Return the record type or -1 on failure.  */

int
_bfd_vms_get_object_record (bfd *abfd)
{
  unsigned int test_len;
  int type;

#if VMS_DEBUG
  vms_debug (8, "_bfd_vms_get_obj_record\n");
#endif

  if (PRIV (is_vax))
    test_len = 0;
  else
    {
      int off = 0;

      /* See _bfd_vms_get_first_record.  */
      test_len = 6;

      /* Skip odd alignment byte.  */
      if (bfd_tell (abfd) & 1)
	{
	  if (bfd_bread (PRIV (vms_buf), 1, abfd) != 1)
	    {
	      bfd_set_error (bfd_error_file_truncated);
	      return -1;
	    }
          /* Alignment byte may be present or not.  This is not easy to
             detect but all object record types are not 0 (on Alpha VMS).
             We also hope that pad byte is 0.  */
          if (PRIV (vms_buf)[0])
            off = 1;
	}

      /* Read the record header  */
      if (bfd_bread (PRIV (vms_buf) + off, test_len - off, abfd)
          != test_len - off)
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return -1;
	}

      /* Reset the record pointer.  */
      PRIV (vms_rec) = PRIV (vms_buf);
      maybe_adjust_record_pointer_for_object (abfd);
    }

  if (vms_get_remaining_object_record (abfd, test_len) <= 0)
    return -1;

  if (PRIV (is_vax))
    type = PRIV (vms_rec) [0];
  else
    type = bfd_getl16 (PRIV (vms_rec));

#if VMS_DEBUG
  vms_debug (8, "_bfd_vms_get_obj_record: rec %p, size %d, type %d\n",
	      PRIV (vms_rec), PRIV (rec_size), type);
#endif

  return type;
}

/* Implement step #2 of the object record reading procedure.
   Return the size of the record or 0 on failure.  */

static int
vms_get_remaining_object_record (bfd *abfd, int read_so_far)
{
#if VMS_DEBUG
  vms_debug (8, "vms_get_remaining_obj_record\n");
#endif

  if (PRIV (is_vax))
    {
      if (read_so_far != 0)
        abort ();

      PRIV (rec_size) = bfd_bread (PRIV (vms_buf), PRIV (buf_size), abfd);

      if (PRIV (rec_size) <= 0)
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return 0;
	}

      /* Reset the record pointer.  */
      PRIV (vms_rec) = PRIV (vms_buf);
    }
  else
    {
      unsigned int to_read;

      /* Extract record size.  */
      PRIV (rec_size) = bfd_getl16 (PRIV (vms_rec) + 2);

      if (PRIV (rec_size) <= 0)
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return 0;
	}

      /* That's what the linker manual says.  */
      if (PRIV (rec_size) > EOBJ_S_C_MAXRECSIZ)
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return 0;
	}

      /* Take into account object adjustment.  */
      to_read = PRIV (rec_size);
      if (PRIV (file_format) == FF_FOREIGN)
	to_read += VMS_OBJECT_ADJUSTMENT;

      /* Adjust the buffer.  */
      if (to_read > PRIV (buf_size))
	{
	  PRIV (vms_buf)
	    = (unsigned char *) bfd_realloc (PRIV (vms_buf), to_read);
	  if (PRIV (vms_buf) == NULL)
	    return 0;
	  PRIV (buf_size) = to_read;
	}

      /* Read the remaining record.  */
      to_read -= read_so_far;

#if VMS_DEBUG
      vms_debug (8, "vms_get_remaining_obj_record: to_read %d\n", to_read);
#endif

      if (bfd_bread (PRIV (vms_buf) + read_so_far, to_read, abfd) != to_read)
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return 0;
	}

      /* Reset the record pointer.  */
      PRIV (vms_rec) = PRIV (vms_buf);
      maybe_adjust_record_pointer_for_object (abfd);
    }

#if VMS_DEBUG
  vms_debug (8, "vms_get_remaining_obj_record: size %d\n", PRIV (rec_size));
#endif

  return PRIV (rec_size);
}

/* Implement step #2 of the record reading procedure for images.
   Return the size of the record or 0 on failure.  */

static int
vms_get_remaining_image_record (bfd *abfd, int read_so_far)
{
  unsigned int to_read;
  int remaining;

  /* Extract record size.  */
  PRIV (rec_size) = bfd_getl32 (PRIV (vms_rec) + EIHD_S_L_SIZE);

  if (PRIV (rec_size) > PRIV (buf_size))
    {
      PRIV (vms_buf) = bfd_realloc (PRIV (vms_buf), PRIV (rec_size));

      if (PRIV (vms_buf) == NULL)
	{
	  bfd_set_error (bfd_error_no_memory);
	  return 0;
	}

      PRIV (buf_size) = PRIV (rec_size);
    }

  /* Read the remaining record.  */
  remaining = PRIV (rec_size) - read_so_far;
  to_read = MIN (VMS_BLOCK_SIZE - read_so_far, remaining);

  while (remaining > 0)
    {
      if (bfd_bread (PRIV (vms_buf) + read_so_far, to_read, abfd) != to_read)
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return 0;
	}

      read_so_far += to_read;
      remaining -= to_read;

      /* Eat trailing 0xff's.  */
      if (remaining > 0)
	while (PRIV (vms_buf) [read_so_far - 1] == 0xff)
	  read_so_far--;

      to_read = MIN (VMS_BLOCK_SIZE, remaining);
    }

  /* Reset the record pointer.  */
  PRIV (vms_rec) = PRIV (vms_buf);

  return PRIV (rec_size);
}
d147 1
a147 1
  strncpy (newstr, (char *) str, (size_t) size);
d164 1
a164 1
/* Stack routines for vms ETIR commands.  */
d166 2
a167 1
/* Push value and section index.  */
d170 1
a170 1
_bfd_vms_push (bfd * abfd, uquad val, int psect)
d172 1
a172 1
  static int last_psect;
d174 2
a175 3
#if VMS_DEBUG
  vms_debug (4, "<push %016lx (%d) at %d>\n", val, psect, PRIV (stackptr));
#endif
d177 1
a177 2
  if (psect >= 0)
    last_psect = psect;
d179 2
a180 34
  PRIV (stack[PRIV (stackptr)]).value = val;
  PRIV (stack[PRIV (stackptr)]).psect = last_psect;
  PRIV (stackptr)++;
  if (PRIV (stackptr) >= STACKSIZE)
    {
      bfd_set_error (bfd_error_bad_value);
      (*_bfd_error_handler) (_("Stack overflow (%d) in _bfd_vms_push"), PRIV (stackptr));
      exit (1);
    }
}

/* Pop value and section index.  */

uquad
_bfd_vms_pop (bfd * abfd, int *psect)
{
  uquad value;

  if (PRIV (stackptr) == 0)
    {
      bfd_set_error (bfd_error_bad_value);
      (*_bfd_error_handler) (_("Stack underflow in _bfd_vms_pop"));
      exit (1);
    }
  PRIV (stackptr)--;
  value = PRIV (stack[PRIV (stackptr)]).value;
  if ((psect != NULL) && (PRIV (stack[PRIV (stackptr)]).psect >= 0))
    *psect = PRIV (stack[PRIV (stackptr)]).psect;

#if VMS_DEBUG
  vms_debug (4, "<pop %016lx(%d)>\n", value, PRIV (stack[PRIV (stackptr)]).psect);
#endif

  return value;
a181 2

/* Object output routines.   */
d183 2
a184 4
/* Begin new record or record header
   write 2 bytes rectype
   write 2 bytes record length (filled in at flush)
   write 2 bytes header type (ommitted if rechead == -1).  */
d187 1
a187 1
_bfd_vms_output_begin (bfd * abfd, int rectype, int rechead)
d189 1
a189 4
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_begin (type %d, head %d)\n", rectype,
	      rechead);
#endif
d191 2
a192 1
  _bfd_vms_output_short (abfd, (unsigned int) rectype);
d194 2
a195 1
  /* Save current output position to fill in length later.   */
d197 2
a198 7
  if (PRIV (push_level) > 0)
    PRIV (length_pos) = PRIV (output_size);

#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_begin: length_pos = %d\n",
	      PRIV (length_pos));
#endif
d201 1
a201 4
  _bfd_vms_output_short (abfd, 0);

  if (rechead != -1)
    _bfd_vms_output_short (abfd, (unsigned int) rechead);
d207 1
a207 1
_bfd_vms_output_alignment (bfd * abfd, int alignto)
d209 2
a210 5
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_alignment (%d)\n", alignto);
#endif

  PRIV (output_alignment) = alignto;
d213 3
a215 1
/* Prepare for subrecord fields.  */
d217 2
a218 2
void
_bfd_vms_output_push (bfd * abfd)
d220 8
a227 3
#if VMS_DEBUG
  vms_debug (6, "vms_output_push (pushed_size = %d)\n", PRIV (output_size));
#endif
d229 1
a229 2
  PRIV (push_level)++;
  PRIV (pushed_size) = PRIV (output_size);
d232 1
a232 1
/* End of subrecord fields.   */
d235 1
a235 1
_bfd_vms_output_pop (bfd * abfd)
d237 10
a246 3
#if VMS_DEBUG
  vms_debug (6, "vms_output_pop (pushed_size = %d)\n", PRIV (pushed_size));
#endif
d248 1
a248 2
  _bfd_vms_output_flush (abfd);
  PRIV (length_pos) = 2;
d250 3
a252 3
#if VMS_DEBUG
  vms_debug (6, "vms_output_pop: length_pos = %d\n", PRIV (length_pos));
#endif
d254 2
a255 2
  PRIV (pushed_size) = 0;
  PRIV (push_level)--;
d258 1
a258 1
/* Flush unwritten output, ends current record.  */
d261 1
a261 1
_bfd_vms_output_flush (bfd * abfd)
d263 1
a263 3
  int real_size = PRIV (output_size);
  int aligncount;
  int length;
d265 2
a266 4
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_flush (real_size = %d, pushed_size %d at lenpos %d)\n",
	      real_size, PRIV (pushed_size), PRIV (length_pos));
#endif
d268 1
a268 6
  if (PRIV (push_level) > 0)
    length = real_size - PRIV (pushed_size);
  else
    length = real_size;

  if (length == 0)
a269 2
  aligncount = (PRIV (output_alignment)
		- (length % PRIV (output_alignment))) % PRIV (output_alignment);
d271 1
a271 3
#if VMS_DEBUG
  vms_debug (6, "align: adding %d bytes\n", aligncount);
#endif
d273 2
a274 5
  while (aligncount-- > 0)
    {
      PRIV (output_buf)[real_size++] = 0;
      length++;
    }
d276 5
a280 3
  /* Put length to buffer.  */
  PRIV (output_size) = PRIV (length_pos);
  _bfd_vms_output_short (abfd, (unsigned int) length);
d282 3
a284 17
  if (PRIV (push_level) == 0)
    {
      /* File is open in undefined (UDF) format on VMS, but ultimately will be
	 converted to variable length (VAR) format.  VAR format has a length
	 word first which must be explicitly output in UDF format.  */
      bfd_bwrite (PRIV (output_buf) + 2, 2, abfd);
      bfd_bwrite (PRIV (output_buf), (size_t) real_size, abfd);
      PRIV (output_size) = 0;
    }
  else
    {
      PRIV (output_size) = real_size;
      PRIV (pushed_size) = PRIV (output_size);
    }
}

/* End record output.   */
d286 2
a287 6
void
_bfd_vms_output_end (bfd * abfd)
{
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_end\n");
#endif
d289 1
a289 1
  _bfd_vms_output_flush (abfd);
d292 1
a292 3
/* Check remaining buffer size

   Return what's left.  */
d295 1
a295 1
_bfd_vms_output_check (bfd * abfd, int size)
d297 1
a297 3
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_check (%d)\n", size);
#endif
d299 1
a299 1
  return (MAX_OUTREC_SIZE - (PRIV (output_size) + size + MIN_OUTREC_LUFT));
d305 1
a305 1
_bfd_vms_output_byte (bfd * abfd, unsigned int value)
d307 1
a307 3
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_byte (%02x)\n", value);
#endif
d309 2
a310 2
  bfd_put_8 (abfd, value & 0xff, PRIV (output_buf) + PRIV (output_size));
  PRIV (output_size) += 1;
d316 1
a316 1
_bfd_vms_output_short (bfd * abfd, unsigned int value)
d318 1
a318 3
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_short (%04x)\n", value);
#endif
d320 2
a321 3
  bfd_put_16 (abfd, (bfd_vma) value & 0xffff,
	      PRIV (output_buf) + PRIV (output_size));
  PRIV (output_size) += 2;
d327 1
a327 1
_bfd_vms_output_long (bfd * abfd, unsigned long value)
d329 1
a329 3
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_long (%08lx)\n", value);
#endif
d331 2
a332 2
  bfd_put_32 (abfd, (bfd_vma) value, PRIV (output_buf) + PRIV (output_size));
  PRIV (output_size) += 4;
d338 1
a338 1
_bfd_vms_output_quad (bfd * abfd, uquad value)
d340 1
a340 3
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_quad (%016lx)\n", value);
#endif
d342 2
a343 2
  bfd_put_64(abfd, value, PRIV (output_buf) + PRIV (output_size));
  PRIV (output_size) += 8;
d349 1
a349 1
_bfd_vms_output_counted (bfd * abfd, char *value)
d353 1
a353 3
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_counted (%s)\n", value);
#endif
d366 2
a367 2
  _bfd_vms_output_byte (abfd, (unsigned int) len & 0xff);
  _bfd_vms_output_dump (abfd, (unsigned char *) value, len);
d373 1
a373 3
_bfd_vms_output_dump (bfd * abfd,
		      unsigned char *data,
		      int length)
d375 1
a375 3
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_dump (%d)\n", length);
#endif
d377 1
a377 1
  if (length == 0)
d380 2
a381 2
  memcpy (PRIV (output_buf) + PRIV (output_size), data, (size_t) length);
  PRIV (output_size) += length;
d387 1
a387 3
_bfd_vms_output_fill (bfd * abfd,
		      int value,
		      int count)
d389 1
a389 3
#if VMS_DEBUG
  vms_debug (6, "_bfd_vms_output_fill (val %02x times %d)\n", value, count);
#endif
d393 2
a394 2
  memset (PRIV (output_buf) + PRIV (output_size), value, (size_t) count);
  PRIV (output_size) += count;
d397 4
a400 1
/* This hash routine borrowed from GNU-EMACS, and strengthened slightly.  ERY.  */
d402 2
a403 20
static int
hash_string (const char *ptr)
{
  const unsigned char *p = (unsigned char *) ptr;
  const unsigned char *end = p + strlen (ptr);
  unsigned char c;
  int hash = 0;

  while (p != end)
    {
      c = *p++;
      hash = ((hash << 3) + (hash << 15) + (hash >> 28) + c);
    }
  return hash;
}

/* Generate a length-hashed VMS symbol name (limited to maxlen chars).  */

char *
_bfd_vms_length_hash_symbol (bfd * abfd, const char *in, int maxlen)
d405 1
a405 11
  unsigned long result;
  int in_len;
  char *new_name;
  const char *old_name;
  int i;
  static char outbuf[EOBJ_S_C_SYMSIZ+1];
  char *out = outbuf;

#if VMS_DEBUG
  vms_debug (4, "_bfd_vms_length_hash_symbol \"%s\"\n", in);
#endif
d407 5
a411 2
  if (maxlen > EOBJ_S_C_SYMSIZ)
    maxlen = EOBJ_S_C_SYMSIZ;
d413 1
a413 2
  /* Save this for later.  */
  new_name = out;
d415 1
a415 2
  /* We may need to truncate the symbol, save the hash for later.  */
  in_len = strlen (in);
d417 2
a418 35
  result = (in_len > maxlen) ? hash_string (in) : 0;

  old_name = in;

  /* Do the length checking.  */
  if (in_len <= maxlen)
    i = in_len;
  else
    {
      if (PRIV (flag_hash_long_names))
	i = maxlen-9;
      else
	i = maxlen;
    }

  strncpy (out, in, (size_t) i);
  in += i;
  out += i;

  if ((in_len > maxlen)
      && PRIV (flag_hash_long_names))
    sprintf (out, "_%08lx", result);
  else
    *out = 0;

#if VMS_DEBUG
  vms_debug (4, "--> [%d]\"%s\"\n", strlen (outbuf), outbuf);
#endif

  if (in_len > maxlen
	&& PRIV (flag_hash_long_names)
	&& PRIV (flag_show_after_trunc))
    printf (_("Symbol %s replaced by %s\n"), old_name, new_name);

  return outbuf;
d421 2
a422 4
/* Allocate and initialize a new symbol.  */

static asymbol *
new_symbol (bfd * abfd, char *name)
d424 4
a427 13
  asymbol *symbol;

#if VMS_DEBUG
  _bfd_vms_debug (7,  "new_symbol %s\n", name);
#endif

  symbol = bfd_make_empty_symbol (abfd);
  if (symbol == 0)
    return symbol;
  symbol->name = name;
  symbol->section = (asection *)(unsigned long)-1;

  return symbol;
d430 3
a432 1
/* Allocate and enter a new private symbol.  */
d434 2
a435 2
vms_symbol_entry *
_bfd_vms_enter_symbol (bfd * abfd, char *name)
d437 36
a472 1
  vms_symbol_entry *entry;
d474 1
a474 35
#if VMS_DEBUG
  _bfd_vms_debug (6,  "_bfd_vms_enter_symbol %s\n", name);
#endif

  entry = (vms_symbol_entry *)
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, FALSE, FALSE);
  if (entry == 0)
    {
#if VMS_DEBUG
      _bfd_vms_debug (8,  "creating hash entry for %s\n", name);
#endif
      entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						    name, TRUE, FALSE);
      if (entry != 0)
	{
	  asymbol *symbol;
	  symbol = new_symbol (abfd, name);
	  if (symbol != 0)
	    {
	      entry->symbol = symbol;
	      PRIV (gsd_sym_count)++;
	      abfd->symcount++;
	    }
	  else
	    entry = 0;
	}
      else
	(*_bfd_error_handler) (_("failed to enter %s"), name);
    }
  else
    {
#if VMS_DEBUG
      _bfd_vms_debug (8,  "found hash entry for %s\n", name);
#endif
    }
d476 1
a476 4
#if VMS_DEBUG
  _bfd_vms_debug (7, "-> entry %p, entry->symbol %p\n", entry, entry->symbol);
#endif
  return entry;
@


1.31
log
@2010-01-27  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Remove trailing spaces.
	(struct hdr_struct): Remove unused hdr_c_cpr field.
	(enum file_format_enum): Add comments.
	* vms.c (vms_bfd_print_private_bfd_data): New function that
	replaces the macro.
	Remove trailing spaces.
	* vms-misc.c: Improve comments.
	(_bfd_vms_get_object_record): Also handle files without pads.
	* vms-hdr.c (_bfd_vms_write_dbg): Fix format string.
	* vms-gsd.c (struct flagdescstruct): Make name field const.
	(gsyflagdesc): Fix typo.
@
text
@d33 1
d1049 90
@


1.30
log
@2009-02-23  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Update copyright year, fix comments, reorder declarations.
	(_bfd_save_vms_section): Remove the prototype.
	(EGPS_S_V_NO_SHIFT): New constant.
	(bfd_vms_set_section_flags): New prototype.
	(EGPS_S_B_ALIGN, EGPS_S_W_FLAGS, EGPS_S_L_ALLOC, EGPS_S_B_NAMLNG): New
	constants.
	(EGSY_S_W_FLAGS): Ditto.
	(EGSY_S_V_QUAD_VAL): Ditto.
	(ESDF_S_L_VALUE, ESDF_S_L_PSINDX, ESDF_S_B_NAMLNG): Ditto.
	(EGST_S_W_FLAGS, EGST_S_Q_LP_1, EGST_S_Q_LP_2, EGST_S_L_PSINDX,
	EGST_S_B_NAMLNG): Ditto.
	(ESRF_S_B_NAMLNG): Ditto.
	(ETIR_S_C_HEADER_SIZE): Ditto.
	(EGPS_S_V_ALLOC_64BIT): Ditto.
	(DST_S_C_EPILOG): Ditto.
	(DST_S_C_SRC_SETLNUM_L, DST_S_C_SRC_SETLNUM_W) : Ditto.
	(DST_S_C_SRC_INCRLNUM_B): Ditto.
	(DST_S_B_PCLINE_UNSBYTE, DST_S_W_PCLINE_UNSWORD): Ditto.
	(DST_S_L_PCLINE_UNSLONG): Ditto.
	(DST_S_B_MODBEG_NAME, DST_S_L_RTNBEG_ADDRESS) : Ditto
	(DST_S_B_RTNBEG_NAME, DST_S_L_RTNEND_SIZE): Ditto
	(DST_S_C_SOURCE_HEADER_SIZE): Ditto.
	(DST_S_B_SRC_DF_LENGTH, DST_S_W_SRC_DF_FILEID): Ditto.
	(DST_S_B_SRC_DF_FILENAME, DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_W_SRC_UNSWORD, DST_S_L_SRC_UNSLONG): Ditto.
	Add prototypes.
	(vms_section, vms_reloc): Remove types.
	(hdr_struc): Replaced by ...
	(hdr_struct): ... new type.
	(EMH_S_W_HDRTYP, EMH_S_B_STRLVL, EMH_S_L_ARCH1): New constants.
	(EMH_S_L_ARCH2, EMH_S_L_RECSIZ, EMH_S_B_NAMLNG): Ditto.
	(EMH_DATE_LENGTH): Ditto.
	(eom_struc): Replaced by ...
	(eom_struct): ... new type.
	(EEOM_S_L_TOTAL_LPS, EEOM_S_W_COMCOD, EEOM_S_B_TFRFLG): New constants.
	(EEOM_S_L_PSINDX, EEOM_S_L_TFRADR): Ditto.
	(EIHD_S_K_MAJORID, EIHD_S_K_MINORID, EIHD_S_K_EXE): Ditto.
	(EIHD_S_L_SIZE, EIHD_S_L_ISDOFF, EIHD_S_L_SYMDBGOFF): Ditto.
	(EIHD_S_Q_SYMVVA, EIHD_S_L_IMGTYPE): Ditto.
	(EISD_S_L_EISDSIZE, EISD_S_L_SECSIZE, EISD_S_Q_VIR_ADDR): Ditto.
	(EISD_S_L_FLAGS, EISD_S_L_VBN, EISD_S_R_CONTROL): Ditto.
	(EISD_S_L_IDENT, EISD_S_T_GBLNAM): Ditto.
	(EISD_S_M_GBL, EISD_S_M_CRF, EISD_S_M_DZRO, EISD_S_M_WRT): Ditto.
	(EISD_S_M_INITALCODE, EISD_S_M_BASED, EISD_S_M_FIXUPVEC): Ditto.
	(EISD_S_M_RESIDENT, EISD_S_M_VECTOR, EISD_S_M_PROTECT): Ditto.
	(EISD_S_M_LASTCLU, EISD_S_M_EXE, EISD_S_M_NONSHRADR): Ditto.
	(EISD_S_M_QUAD_LENGTH, EISD_S_M_ALLOC_64BIT): Ditto.
	(EIHS_S_L_DSTVBN, EIHS_S_L_DSTSIZE, EIHS_S_L_GSTVBN): Ditto.
	(EIHS_S_L_GSTSIZE, EIHS_S_L_DMTVBN, EIHS_S_L_DMTBYTES): Ditto.
	(DBG_S_L_DMT_MODBEG, DBG_S_L_DST_SIZE): Ditto.
	(DBG_S_W_DMT_PSECT_COUNT, DBG_S_C_DMT_HEADER_SIZE): Ditto.
	(DBG_S_L_DMT_PSECT_START, DBG_S_L_DMT_PSECT_LENGTH)
	(DBG_S_C_DMT_PSECT_SIZE): Ditto.
	(enum file_type_enum): New type.
	(struct location_struct): Removed.
	(struct fileinfo, struct srecinfo, struct lineinfo): New types.
	(struct funcinfo, struct module): Ditto.
	(struct vms_private_data_struct): Update fields.
	(struct vms_section_data_struct): New type.

	* vms.c: Update copyright year, fix comments,
	Fix includes for DECC, add prototypes.
	(vms_initialize): Use bfd_alloc instead of bfd_zalloc and remove
	some initializers.
	Use flavour to set is_vax, location_stack is removed.
	(struct pair): Declare.
	(fill_section_ptr): Initialize variables at declaration.
	Add guard to set SECTION_SYM flag, handlde und section.
	(vms_fixup_sections): Use struct pair for fill_section_ptr argument.
	(_bfd_vms_slurp_object_records): New function, replaces previous
	vms_object_p.
	(vms_slurp_module): New function.
	(vms_slurp_image): Ditto.
	(vms_object_p): Complete rewrite.
	(vms_mkobject): Use is_vax field to slect architecture.
	(free_reloc_stream): New function.
	(vms_convert_to_var): Ditto.
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_close_and_cleanup): Call free_reloc_stream, convert file to
	VAR format on VMS.
	(vms_new_section_hook): Set alignment to 0, allocate private data.
	(vms_get_section_contents): Load content.
	(vms_get_symbol_info): Handle undefined section.
	(vms_find_nearest_line): Handle.
	(alloc_reloc_stream): New function.
	(vms_slurp_reloc_table): Ditto.
	(vms_get_reloc_upper_bound): Make it real.
	(vms_canonicalize_reloc): Do the real work.
	(alpha_howto_table): Add ALPHA_R_NOP, ALPHA_R_BSR, ALPHA_R_LDA,
	ALPHA_R_BOH.
	(vms_bfd_reloc_type_lookup): Handle NOP, BSR, LDA and BOH.
	(vms_set_arch_mach): Check arch.
	(vms_set_section_contents): Copy the content after allocation.
	(vms_alpha_vec): Update object flags.

	* vms-tir.c: Update copyright year, fix comments,
	add prototypes for new functions.
	(dst_define_location): New function.
	(dst_restore_location): New function.
	(dst_retrieve_location): New function.
	(dst_check_allocation): New function.
	(image_dump): Call dst_check_allocation.
	(image_write_b): Ditto.
	(image_write_w): Ditto.
	(image_write_l): Ditto.
	(image_write_q): Ditto.
	(cmd_name): Handle STA_LW, STA_QW, STO_OFF, STO_IMM, STO_IMMR, STO_LW,
	STO_QW, OPR_ADD, CTL_SETRB, STC_LP_PSB, CTL_DFLOC, CTL_STLOC,
	CTL_STKDL.
	Call error handler instead of abort if name is not known.
	(etir_sta): Add quarter_relocs argument and set it.
	Fix cast.
	(etir_sto): Ditto.
	(etir_opr): Ditto, return FALSE in case of error.
	(etir_ctl): Add quarter_relocs argument and set it, fix cast.
	Fix CTL_DFLOC, CTL_STLOC, CTL_STKDL.
	(etir_stc): Add quarter_relocs argument and set it, fix cast.
	Fix STC_LP, STC_LP_PSB, STC_GBL and STC_CGA.
	Handle STC_LP_PSB, STC_BSR_GBL, STC_LDA_GBL, STC_BOH_GBL.
	Move STC_NOP_PS, STC_BSR_PS, STC_LDA_PS, STC_BOH_PS, STC_NBH_PS.
	Return FALSE in case of error.
	(tir_sta): Change sign of psect.
	(tir_ctl): Ditto.
	(tir_cmd): Fix cast. Makes tir_table static const.
	(etir_cmd): Add quarter_relocs argument, makes etir_table const,
	add argument to explain.
	(analyze_etir): Initialize maxptr, add quarter_relocs
	declaration, move some declarations into inner scopes.
	Handle quarter_relocs and STO_IMM.
	(_bfd_vms_slurp_tir): Use constant instead of hard-coded values.
	(_bfd_vms_slurp_relocs): New function.
	(_bfd_vms_decode_relocs): New function.
	(sto_imm): Rewritten.
	(start_first_etbt_record): New function.
	(start_another_etbt_record): Ditto.
	(etir_output_check): Ditto.
	(defer_reloc_p): Ditto.
	(_bfd_vms_write_tir): Remove nextoffset, convert a while-loop to
	a for-loop.  Correctly deals with contents, deals with .vmsdebug,
	rewritte relocations handling.
	(_bfd_vms_write_tbt): Removed.
	(_bfd_vms_write_dbg): Ditto.

	* vms-misc.c: Update copyright year, Fix comments.
	(_bfd_vms_get_header_values): Use 'size' instead of 'length'.
	(maybe_adjust_record_pointer_for_object): New function.
	(_bfd_vms_get_first_record): New function, replaces ...
	(_bfd_vms_get_record): ..  removed.
	(_bfd_vms_get_object_record): New function.
	(_bfd_vms_get_object_record): New function.
	(vms_get_remaining_object_record): New function, replaces ...
	(_bfd_vms_get_next_record): ... removed.
	(add_new_contents): Removed.
	(_bfd_save_vms_section): Removed.
	(_bfd_get_vms_section): Removed.
	(_bfd_vms_output_flush): Write in VAR format.
	(new_symbol): Don't make UND section.

	* vms-hdr.c: Update copyright year, update list of record handled.
	(_bfd_vms_slurp_hdr): rec_length renamed to rec_size.
	(_bfd_vms_write_hdr): Strip vms and unix patches,
	add comments, truncate module name at 31 characters,
	use constants instead of hard-coded value,
	write BFD version instead of a fixed string.
	(_bfd_vms_slurp_ihd): New function.
	(_bfd_vms_slurp_isd): Ditto.
	(_bfd_vms_slurp_ihs): Ditto.
	(new_module): Ditto.
	(parse_module): Ditto
	(build_module_list): Ditto.
	(module_find_nearest_line): Ditto.
	(_bfd_vms_find_nearest_dst_line): Ditto.
	(vms_slurp_debug): Ditto.
	(_bfd_vms_slurp_dbg): Ditto.
	(_bfd_vms_slurp_tbt): Ditto.
	(_bfd_vms_write_dbg): Ditto.
	(_bfd_vms_write_tbt): Ditto.

	* vms-gsd.c: Update copyright year, update list of records handled.
	(EVAX_LITERALS_NAME): New macro.
	(evax_section_flags): Add an entry for EVAX_LITERALS_NAME.
	(gpsflagdesc, gsyflagdesc): Moved out of _bfd_vms_slurp_gsd.
	(register_universal_symbol): New function and prototype.
	(_bfd_vms_slurp_gsd): Fix indentations and casts,
	improve debug messages,
	use constants instead of hard-coded value,
	fix missing endianness conversion,
	handle global symbol (SYMG).
	(bfd_vms_set_section_flags): New function.
	(_bfd_vms_write_gsd): Don't write .vmsdebug section,
	handle section literals,
	fix indentation,
	handle section bfd and vms flags,
	don't output LIB$INITIALIZE symbol,
	fix handling of weak symbols,
	fix evax vs vax procedure descriptor,
	handle absolute symbols.

	* reloc.c (BFD_RELOC_ALPHA_NOP, BFD_RELOC_ALPHA_BSR,
	BFD_RELOC_ALPHA_LDA, BFD_RELOC_ALPHA_BOH): New relocations.

	* makefile.vms (DEFS): Fix flags for VMS.

	* bfdio.c (real_fopen): Handle multiple VMS fopen attributes.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
@
text
@d214 1
a214 1
   happens during the transfer of object files from VMS to Unix,
d358 2
d371 5
d379 2
a380 1
      if (bfd_bread (PRIV (vms_buf), test_len, abfd) != test_len)
@


1.29
log
@Silence gcc printf warnings
@
text
@d1 1
a1 1
/* vms-misc.c -- Miscellaneous functions for VAX (openVMS/VAX) and
d4 3
a6 1
   2007, 2008  Free Software Foundation, Inc.
d35 9
a43 1

d47 3
a49 4
/* Debug function for all vms extensions
   evaluates environment variable VMS_DEBUG for a
   numerical value on the first call
   all error levels below this value are printed
d51 1
a51 1
   levels:
d57 1
a57 1
   level is also indentation level. Indentation is performed
d179 1
a179 1
/* Return type and length from record header (buf) on Alpha.  */
d185 1
a185 1
			    int *length)
d187 1
a187 1
  if (type != 0)
d189 3
a191 3
  buf += 2;
  if (length != 0)
    *length = bfd_getl16 (buf);
d194 2
a195 1
  vms_debug (10, "_bfd_vms_get_header_values type %x, length %x\n", (type?*type:0), (length?*length:0));
d206 3
a208 3
   size. The linker (and other tools on vms) depend on that. Unix doesn't
   know about 'formatted' files, so reading and writing such an object
   file in a unix environment is not trivial.
d210 2
a211 2
   With the tool 'file' (available on all vms ftp sites), one
   can view and change the attributes of a file. Changing from
d213 3
a215 3
   record length at the first 2 bytes of every record. The same
   happens during the transfer of object files from vms to unix,
   at least with ucx, dec's implementation of tcp/ip.
d217 1
a217 1
   The vms format repeats the length at bytes 2 & 3 of every record.
d221 2
a222 2
   If they do it's an object file in an unix environment or with
   wrong attributes (FF_FOREIGN), else we should be in a vms
d225 21
a245 5
   Reading is always done in 2 steps.
   First just the record header is read and the length extracted
   by get_header_values,
   then the read buffer is adjusted and the remaining bytes are
   read in.
d247 6
a252 1
   All file i/o is always done on even file positions.  */
d255 1
a255 1
_bfd_vms_get_record (bfd * abfd)
d257 1
a257 2
  int test_len, test_start, remaining;
  unsigned char *vms_buf;
d260 1
a260 1
  vms_debug (8, "_bfd_vms_get_record\n");
d263 7
a269 5
  /* Minimum is 6 bytes on Alpha
     (2 bytes length, 2 bytes record id, 2 bytes length repeated)

     On the VAX there's no length information in the record
     so start with OBJ_S_C_MAXRECSIZ.   */
d271 1
d274 4
a277 10
      bfd_size_type amt;

      if (PRIV (is_vax))
	{
	  amt = OBJ_S_C_MAXRECSIZ;
	  PRIV (file_format) = FF_VAX;
	}
      else
	amt = 6;
      PRIV (vms_buf) = bfd_malloc (amt);
d281 12
a292 1
  vms_buf = PRIV (vms_buf);
d294 8
a301 2
  if (vms_buf == 0)
    return -1;
d303 3
a305 1
  switch (PRIV (file_format))
d307 2
a308 5
    case FF_UNKNOWN:
    case FF_FOREIGN:
      test_len = 6;			/* Probe 6 bytes.  */
      test_start = 2;			/* Where the record starts.  */
      break;
d310 3
a312 4
    case FF_NATIVE:
      test_len = 4;
      test_start = 0;
      break;
d314 1
a314 5
    default:
    case FF_VAX:
      test_len = 0;
      test_start = 0;
      break;
d317 2
a318 1
  /* Skip odd alignment byte.  */
d320 3
a322 1
  if (bfd_tell (abfd) & 1)
d324 8
a331 5
      if (bfd_bread (PRIV (vms_buf), (bfd_size_type) 1, abfd) != 1)
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return 0;
	}
d334 23
a356 4
  /* Read the record header on Alpha.  */
  if ((test_len != 0)
      && (bfd_bread (PRIV (vms_buf), (bfd_size_type) test_len, abfd)
	  != (bfd_size_type) test_len))
d358 2
a359 3
      bfd_set_error (bfd_error_file_truncated);
      return 0;
    }
d361 2
a362 5
  /* Check file format on first call.  */
  if (PRIV (file_format) == FF_UNKNOWN)
    {						/* Record length repeats ?  */
      if (vms_buf[0] == vms_buf[4]
	  && vms_buf[1] == vms_buf[5])
d364 5
a368 2
	  PRIV (file_format) = FF_FOREIGN;	/* Y: foreign environment.  */
	  test_start = 2;
d370 3
a372 1
      else
d374 2
a375 2
	  PRIV (file_format) = FF_NATIVE;	/* N: native environment.  */
	  test_start = 0;
d377 4
d383 26
d411 6
a416 3
      PRIV (rec_length) = bfd_bread (vms_buf, (bfd_size_type) PRIV (buf_size),
				     abfd);
      if (PRIV (rec_length) <= 0)
d421 3
a423 1
      PRIV (vms_rec) = vms_buf;
d427 1
a427 2
      /* Alpha.   */
      /* Extract vms record length.  */
d429 2
a430 2
      _bfd_vms_get_header_values (abfd, vms_buf + test_start, NULL,
				  & PRIV (rec_length));
d432 1
a432 1
      if (PRIV (rec_length) <= 0)
d439 1
a439 2

      if (PRIV (rec_length) > EOBJ_S_C_MAXRECSIZ)
d445 5
d451 1
a451 2

      if (PRIV (rec_length) > PRIV (buf_size))
d453 5
a457 6
	  PRIV (vms_buf) = bfd_realloc_or_free (vms_buf,
					(bfd_size_type) PRIV (rec_length));
	  vms_buf = PRIV (vms_buf);
	  if (vms_buf == 0)
	    return -1;
	  PRIV (buf_size) = PRIV (rec_length);
d461 1
a461 1
      remaining = PRIV (rec_length) - test_len + test_start;
d464 1
a464 1
      vms_debug (10, "bfd_bread remaining %d\n", remaining);
d466 2
a467 2
      if (bfd_bread (vms_buf + test_len, (bfd_size_type) remaining, abfd) !=
	  (bfd_size_type) remaining)
d472 4
a475 1
      PRIV (vms_rec) = vms_buf + test_start;
d479 1
a479 1
  vms_debug (11, "bfd_bread rec_length %d\n", PRIV (rec_length));
d482 1
a482 1
  return PRIV (rec_length);
d485 2
a486 2
/* Get next vms record from file
   update vms_rec and rec_length to new (remaining) values.  */
d488 2
a489 2
int
_bfd_vms_next_record (bfd * abfd)
d491 5
a495 4
#if VMS_DEBUG
  vms_debug (8, "_bfd_vms_next_record (len %d, size %d)\n",
	      PRIV (rec_length), PRIV (rec_size));
#endif
d497 1
a497 3
  if (PRIV (rec_length) > 0)
    PRIV (vms_rec) += PRIV (rec_size);
  else
d499 9
a507 2
      if (_bfd_vms_get_record (abfd) <= 0)
	return -1;
d510 3
a512 3
  if (!PRIV (vms_rec) || !PRIV (vms_buf)
      || PRIV (vms_rec) >= (PRIV (vms_buf) + PRIV (buf_size)))
    return -1;
d514 1
a514 1
  if (PRIV (is_vax))
d516 15
a530 2
      PRIV (rec_type) = *(PRIV (vms_rec));
      PRIV (rec_size) = PRIV (rec_length);
a531 3
  else
    _bfd_vms_get_header_values (abfd, PRIV (vms_rec), &PRIV (rec_type),
				&PRIV (rec_size));
d533 2
a534 1
  PRIV (rec_length) -= PRIV (rec_size);
d536 2
a537 5
#if VMS_DEBUG
  vms_debug (8, "_bfd_vms_next_record: rec %p, size %d, length %d, type %d\n",
	      PRIV (vms_rec), PRIV (rec_size), PRIV (rec_length),
	      PRIV (rec_type));
#endif
d539 2
a540 5
  return PRIV (rec_type);
}

/* Copy sized string (string with fixed length) to new allocated area
   size is string length (size of record)  */
d555 2
a556 2
/* Copy counted string (string with length at first byte) to new allocated area
   ptr points to length byte on entry  */
a617 71
/* Object file output functions.  */

/* GAS tends to write sections in little chunks (bfd_set_section_contents)
   which we can't use directly. So we save the little chunks in linked
   lists (one per section) and write them later.  */

/* Add a new vms_section structure to vms_section_table
   - forward chaining -.  */

static vms_section *
add_new_contents (bfd * abfd, sec_ptr section)
{
  vms_section *sptr, *newptr;

  sptr = PRIV (vms_section_table)[section->index];
  if (sptr != NULL)
    return sptr;

  newptr = bfd_alloc (abfd, (bfd_size_type) sizeof (vms_section));
  if (newptr == NULL)
    return NULL;
  newptr->contents = bfd_alloc (abfd, section->size);
  if (newptr->contents == NULL)
    return NULL;
  newptr->offset = 0;
  newptr->size = section->size;
  newptr->next = 0;
  PRIV (vms_section_table)[section->index] = newptr;
  return newptr;
}

/* Save section data & offset to a vms_section structure
   vms_section_table[] holds the vms_section chain.  */

bfd_boolean
_bfd_save_vms_section (bfd * abfd,
		       sec_ptr section,
		       const void * data,
		       file_ptr offset,
		       bfd_size_type count)
{
  vms_section *sptr;

  if (section->index >= VMS_SECTION_COUNT)
    {
      bfd_set_error (bfd_error_nonrepresentable_section);
      return FALSE;
    }
  if (count == (bfd_size_type)0)
    return TRUE;
  sptr = add_new_contents (abfd, section);
  if (sptr == NULL)
    return FALSE;
  memcpy (sptr->contents + offset, data, (size_t) count);

  return TRUE;
}

/* Get vms_section pointer to saved contents for section # index  */

vms_section *
_bfd_get_vms_section (bfd * abfd, int index)
{
  if (index >=  VMS_SECTION_COUNT)
    {
      bfd_set_error (bfd_error_nonrepresentable_section);
      return NULL;
    }
  return PRIV (vms_section_table)[index];
}

d623 1
a623 1
   write 2 bytes header type (ommitted if rechead == -1).   */
d737 5
a741 12
      if (0
#ifndef VMS
	  /* Write length first, see FF_FOREIGN in the input routines.  */
	  || fwrite (PRIV (output_buf) + 2, 2, 1,
		     (FILE *) abfd->iostream) != 1
#endif
	  || (real_size != 0
	      && fwrite (PRIV (output_buf), (size_t) real_size, 1,
			 (FILE *) abfd->iostream) != 1))
	/* FIXME: Return error status.  */
	abort ();

d987 1
a987 1
  symbol->section = bfd_make_section (abfd, BFD_UND_SECTION_NAME);
@


1.28
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d878 1
a878 1
  long int result;
@


1.27
log
@	* coff-arm.c (arm_emit_base_file_entry): Check fwrite return value.
	Return status.  Adjust callers.
	* coff-mcore.c (mcore_emit_base_file_entry): Likewise.
	* coff-ppc.c (write_base_file_entry): New function.
	(coff_ppc_relocate_section): Use it.
	* elf32-arm.c (find_thumb_glue): Check asprintf return status.
	(find_arm_glue): Likewise.
	* vms-misc.c (_bfd_vms_output_flush): Check fwrite return value.
@
text
@d4 1
a4 1
   2007 Free Software Foundation, Inc.
d352 1
a352 1
	  PRIV (vms_buf) = bfd_realloc (vms_buf,
@


1.26
log
@Switch sources over to use the GPL version 3
@
text
@d694 1
d696 9
a704 5
	/* Write length first, see FF_FOREIGN in the input routines.  */
      fwrite (PRIV (output_buf) + 2, 2, 1, (FILE *) abfd->iostream);
#endif
      fwrite (PRIV (output_buf), (size_t) real_size, 1,
	      (FILE *) abfd->iostream);
@


1.25
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.24
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 2
a4 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d26 1
a27 1
#include "sysdep.h"
@


1.23
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.22
log
@Update to ISO-C90 and fix formatting
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.21
log
@update copyright dates
@
text
@d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a32 6

static vms_section *add_new_contents PARAMS ((bfd *, sec_ptr));
static int hash_string PARAMS ((const char *));
static asymbol *new_symbol PARAMS ((bfd *, char *));

/*-----------------------------------------------------------------------------*/
d34 1
a34 1
/* debug functions */
d36 1
a36 1
/* debug function for all vms extensions
d48 1
a48 2
   if level > 0
	*/
a49 1
#if __STDC__
d57 1
a57 1
  int abslvl = (level > 0)?level:-level;
d61 1
a61 1
      if ((eptr = getenv("VMS_DEBUG")) != NULL)
d63 1
a63 1
	  min_level = atoi(eptr);
d76 1
a76 1
  va_start(args, format);
d78 2
a79 4
  fflush(output);
  va_end(args);

  return;
d82 2
a83 1
#else /* not __STDC__ */
d86 4
a89 43
_bfd_vms_debug (level, format, a1, a2, a3, a4, a5, a6)
     int level;
     char *format;
     long a1; long a2; long a3;
     long a4; long a5; long a6;
{
  static int min_level = -1;
  static FILE *output = NULL;
  char *eptr;

  if (min_level == -1)
    {
      if ((eptr = getenv("VMS_DEBUG")) != NULL)
	{
	  min_level = atoi(eptr);
	  output = stderr;
	}
      else
	min_level = 0;
    }
  if (output == NULL)
    return;
  if (level > min_level)
    return;

  while (--level>0)
    fprintf (output, " ");
  fprintf (output, format, a1, a2, a3, a4, a5, a6);
  fflush(output);

  return;
}
#endif /* __STDC__ */

/* a debug function
   hex dump 'size' bytes starting at 'ptr'  */

void
_bfd_hexdump (level, ptr, size, offset)
     int level;
     unsigned char *ptr;
     int size;
     int offset;
a122 2

  return;
d126 1
a126 1
/* hash functions
d130 2
a131 2
/* allocate new vms_hash_entry
   keep the symbol name and a pointer to the bfd symbol in the table  */
d134 3
a136 4
_bfd_vms_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d141 1
a141 1
  vms_debug (5, "_bfd_vms_hash_newfunc(%p, %p, %s)\n", entry, table, string);
d144 1
a144 1
  if (entry == (struct bfd_hash_entry *)NULL)
d148 1
a148 1
      if (ret == (vms_symbol_entry *) NULL)
d151 1
a151 1
	  return (struct bfd_hash_entry *)NULL;
a156 1

d162 1
a162 1
  ret->symbol = (asymbol *)NULL;
d167 1
a167 1
/* object file input functions */
d172 4
a175 5
_bfd_vms_get_header_values (abfd, buf, type, length)
     bfd *abfd ATTRIBUTE_UNUSED;
     unsigned char *buf;
     int *type;
     int *length;
a185 2

  return;
d188 2
a189 2
/* Get next record from object file to vms_buf
   set PRIV(buf_size) and return it
d191 1
a191 1
   this is a little tricky since it should be portable.
d193 1
a193 1
   the openVMS object file has 'variable length' which means that
d214 3
a216 3
   reading is always done in 2 steps.
   first just the record header is read and the length extracted
   by get_header_values
d220 1
a220 1
   all file i/o is always done on even file positions  */
d223 1
a223 2
_bfd_vms_get_record (abfd)
     bfd *abfd;
d232 1
a232 1
  /* minimum is 6 bytes on Alpha
d235 2
a236 2
     on VAX there's no length information in the record
     so start with OBJ_S_C_MAXRECSIZ  */
d249 1
a249 1
      PRIV (vms_buf) = (unsigned char *) bfd_malloc (amt);
d262 2
a263 2
      test_len = 6;			/* probe 6 bytes */
      test_start = 2;			/* where the record starts */
d278 1
a278 1
  /* skip odd alignment byte  */
d289 1
a289 2
  /* read the record header on Alpha.  */

d298 1
a298 2
  /* check file format on first call  */

d300 1
a300 1
    {						/* record length repeats ? */
d304 1
a304 1
	  PRIV (file_format) = FF_FOREIGN;	/* Y: foreign environment */
d309 1
a309 1
	  PRIV (file_format) = FF_NATIVE;	/* N: native environment */
d325 1
a325 1
  else		/* Alpha  */
d327 2
a328 1
      /* extract vms record length  */
d331 1
a331 1
				  &PRIV (rec_length));
d339 1
a339 1
      /* that's what the linker manual says  */
d347 1
a347 1
      /* adjust the buffer  */
d351 2
a352 3
	  PRIV (vms_buf) = ((unsigned char *)
			    bfd_realloc (vms_buf,
					 (bfd_size_type) PRIV (rec_length)));
d359 1
a359 2
      /* read the remaining record  */

d381 2
a382 2
/* get next vms record from file
   update vms_rec and rec_length to new (remaining) values  */
d385 1
a385 2
_bfd_vms_next_record (abfd)
     bfd *abfd;
d393 1
a393 3
    {
      PRIV (vms_rec) += PRIV (rec_size);
    }
d410 3
a412 4
    {
      _bfd_vms_get_header_values (abfd, PRIV (vms_rec), &PRIV (rec_type),
				  &PRIV (rec_size));
    }
d428 1
a428 3
_bfd_vms_save_sized_string (str, size)
     unsigned char *str;
     int size;
d433 1
a433 1
    return 0;
d444 1
a444 2
_bfd_vms_save_counted_string (ptr)
     unsigned char *ptr;
d451 1
a451 1
/* stack routines for vms ETIR commands */
d453 1
a453 1
/* Push value and section index  */
d456 1
a456 4
_bfd_vms_push (abfd, val, psect)
     bfd *abfd;
     uquad val;
     int psect;
d461 1
a461 1
  vms_debug (4, "<push %016lx(%d) at %d>\n", val, psect, PRIV (stackptr));
a475 1
  return;
d478 1
a478 1
/* Pop value and section index  */
d481 1
a481 3
_bfd_vms_pop (abfd, psect)
     bfd *abfd;
     int *psect;
d503 1
a503 1
/* object file output functions */
d510 1
a510 1
   - forward chaining -  */
d513 1
a513 3
add_new_contents (abfd, section)
     bfd *abfd;
     sec_ptr section;
d521 2
a522 3
  newptr = (vms_section *) bfd_alloc (abfd,
				      (bfd_size_type) sizeof (vms_section));
  if (newptr == (vms_section *) NULL)
d524 2
a525 2
  newptr->contents = (unsigned char *) bfd_alloc (abfd, section->size);
  if (newptr->contents == (unsigned char *) NULL)
d538 5
a542 6
_bfd_save_vms_section (abfd, section, data, offset, count)
     bfd *abfd;
     sec_ptr section;
     const PTR data;
     file_ptr offset;
     bfd_size_type count;
d564 1
a564 3
_bfd_get_vms_section (abfd, index)
     bfd *abfd;
     int index;
d574 1
a574 1
/* Object output routines  */
d579 1
a579 1
   write 2 bytes header type (ommitted if rechead == -1)  */
d582 1
a582 4
_bfd_vms_output_begin (abfd, rectype, rechead)
     bfd *abfd;
     int rectype;
     int rechead;
d585 1
a585 1
  vms_debug (6, "_bfd_vms_output_begin(type %d, head %d)\n", rectype,
d591 1
a591 1
  /* save current output position to fill in length later  */
d601 2
a602 1
  _bfd_vms_output_short (abfd, 0);		/* placeholder for length */
a605 2

  return;
d608 1
a608 1
/* Set record/subrecord alignment  */
d611 1
a611 3
_bfd_vms_output_alignment (abfd, alignto)
     bfd *abfd;
     int alignto;
d614 1
a614 1
  vms_debug (6, "_bfd_vms_output_alignment(%d)\n", alignto);
a617 1
  return;
d620 1
a620 1
/* Prepare for subrecord fields  */
d623 1
a623 2
_bfd_vms_output_push (abfd)
     bfd *abfd;
d626 1
a626 1
  vms_debug (6, "vms_output_push(pushed_size = %d)\n", PRIV (output_size));
a630 1
  return;
d633 1
a633 1
/* End of subrecord fields  */
d636 1
a636 2
_bfd_vms_output_pop (abfd)
     bfd *abfd;
d639 1
a639 1
  vms_debug (6, "vms_output_pop(pushed_size = %d)\n", PRIV (pushed_size));
a650 1
  return;
d653 1
a653 1
/* Flush unwritten output, ends current record  */
d656 1
a656 2
_bfd_vms_output_flush (abfd)
     bfd *abfd;
d663 1
a663 1
  vms_debug (6, "_bfd_vms_output_flush(real_size = %d, pushed_size %d at lenpos %d)\n",
d687 1
a687 1
  /* put length to buffer  */
d694 1
a694 1
	/* write length first, see FF_FOREIGN in the input routines */
a706 2

  return;
d709 1
a709 1
/* End record output  */
d712 1
a712 2
_bfd_vms_output_end (abfd)
     bfd *abfd;
a718 2

  return;
d721 1
a721 1
/* check remaining buffer size
d723 1
a723 1
   return what's left.  */
d726 1
a726 3
_bfd_vms_output_check (abfd, size)
    bfd *abfd;
    int size;
d729 1
a729 1
  vms_debug (6, "_bfd_vms_output_check(%d)\n", size);
d735 1
a735 1
/* Output byte (8 bit) value  */
d738 1
a738 3
_bfd_vms_output_byte (abfd, value)
     bfd *abfd;
     unsigned int value;
d741 1
a741 1
  vms_debug (6, "_bfd_vms_output_byte(%02x)\n", value);
a745 1
  return;
d748 1
a748 1
/* Output short (16 bit) value  */
d751 1
a751 3
_bfd_vms_output_short (abfd, value)
     bfd *abfd;
     unsigned int value;
a759 1
  return;
d762 1
a762 1
/* Output long (32 bit) value  */
d765 1
a765 3
_bfd_vms_output_long (abfd, value)
     bfd *abfd;
     unsigned long value;
a772 1
  return;
d775 1
a775 1
/* Output quad (64 bit) value  */
d778 1
a778 3
_bfd_vms_output_quad (abfd, value)
     bfd *abfd;
     uquad value;
d781 1
a781 1
  vms_debug (6, "_bfd_vms_output_quad(%016lx)\n", value);
a785 1
  return;
d788 1
a788 1
/* Output c-string as counted string  */
d791 1
a791 3
_bfd_vms_output_counted (abfd, value)
     bfd *abfd;
     char *value;
d793 1
a793 1
int len;
d796 1
a796 1
  vms_debug (6, "_bfd_vms_output_counted(%s)\n", value);
d811 1
a811 1
  _bfd_vms_output_dump (abfd, (unsigned char *)value, len);
d814 1
a814 1
/* Output character area  */
d817 3
a819 4
_bfd_vms_output_dump (abfd, data, length)
     bfd *abfd;
     unsigned char *data;
     int length;
d822 1
a822 1
  vms_debug (6, "_bfd_vms_output_dump(%d)\n", length);
a829 2

  return;
d832 1
a832 1
/* Output count bytes of value  */
d835 3
a837 4
_bfd_vms_output_fill (abfd, value, count)
     bfd *abfd;
     int value;
     int count;
d840 1
a840 1
  vms_debug (6, "_bfd_vms_output_fill(val %02x times %d)\n", value, count);
a846 2

  return;
d849 1
a849 1
/* this hash routine borrowed from GNU-EMACS, and strengthened slightly  ERY*/
d852 1
a852 2
hash_string (ptr)
     const char *ptr;
d854 4
a857 4
  register const unsigned char *p = (unsigned char *) ptr;
  register const unsigned char *end = p + strlen (ptr);
  register unsigned char c;
  register int hash = 0;
d870 1
a870 4
_bfd_vms_length_hash_symbol (abfd, in, maxlen)
     bfd *abfd;
     const char *in;
     int maxlen;
d881 1
a881 1
  vms_debug(4, "_bfd_vms_length_hash_symbol \"%s\"\n", in);
d887 2
a888 1
  new_name = out;		/* save this for later.  */
a890 1

a897 1

d899 1
a899 3
    {
      i = in_len;
    }
d919 1
a919 1
  vms_debug(4, "--> [%d]\"%s\"\n", strlen (outbuf), outbuf);
d933 1
a933 3
new_symbol (abfd, name)
     bfd *abfd;
     char *name;
d953 1
a953 3
_bfd_vms_enter_symbol (abfd, name)
     bfd *abfd;
     char *name;
@


1.20
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
@


1.19
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d773 1
a773 7
#if 0
      /* this is why I *love* vms: inconsistency :-}
	 alignment is added to the subrecord length
	 but not to the record length  */
      if (PRIV (push_level) > 0)
#endif
	length++;
@


1.18
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d598 1
a598 1
  newptr->contents = (unsigned char *) bfd_alloc (abfd, section->_raw_size);
d602 1
a602 1
  newptr->size = section->_raw_size;
@


1.18.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d598 1
a598 1
  newptr->contents = (unsigned char *) bfd_alloc (abfd, section->size);
d602 1
a602 1
  newptr->size = section->size;
@


1.17
log
@	* aout-adobe.c (aout_adobe_set_section_contents): Constify location.
	* aoutx.h (NAME(aout,set_section_contents)): Ditto.
	* bfd-in2.h: Regenerate.
	* binary.c (binary_set_section_contents): Ditto.
	* bout.c (b_out_set_section_contents): Ditto.
	* coff-tic54x.c (tic54x_set_section_contents): Ditto.
	* coffcode.h (coff_set_section_contents): Ditto.
	* ecoff.c (_bfd_ecoff_set_section_contents): Ditto.
	* elf-bfd.h (_bfd_elf_set_section_contents): Ditto.
	* elf.c (_bfd_elf_set_section_contents): Ditto.
	* elfxx-mips.c (_bfd_mips_elf_set_section_contents): Ditto.
	* elfxx-mips.h (_bfd_mips_elf_set_section_contents): Ditto.
	* i386msdos.c (msdos_set_section_contents): Ditto.
	* ieee.c (ieee_set_section_contents): Ditto.
	* ihex.c (ihex_set_section_contents): Ditto.
	* libaout.h (NAME(aout,set_section_contents)): Ditto.
	* libbfd-in.h (_bfd_nowrite_set_section_contents): Ditto.
	(_bfd_generic_set_section_contents): Ditto.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_generic_set_section_contents): Ditto.
	* libecoff.h (_bfd_ecoff_set_section_contents): Ditto.
	* libnlm.h (nlmNAME(set_section_contents)): Ditto.
	(struct nlm_backend_data <nlm_mangle_relocs>): Ditto.
	* mmo.c (mmo_set_section_contents): Ditto.
	* nlm32-alpha.c (nlm_alpha_mangle_relocs): Ditto.
	* nlm32-i386.c (nlm_i386_mangle_relocs): Ditto.
	* nlm32-ppc.c (nlm_powerpc_mangle_relocs): Ditto.
	* nlm32-sparc.c (nlm_sparc_mangle_relocs): Ditto.
	* nlmcode.h (nlm_set_section_contents): Ditto.
	* oasys.c (oasys_set_section_contents): Ditto.
	* pdp11.c (NAME(aout,set_section_contents)): Ditto.
	* ppcboot.c (ppcboot_set_section_contents): Ditto.
	* srec.c (srec_set_section_contents): Ditto.
	* targets.c (BFD_JUMP_TABLE_WRITE <_bfd_set_section_contents>): Ditto.
	* tekhex.c (tekhex_set_section_contents): Ditto.
	(move_section_contents): Ditto.
	* versados.c (versados_set_section_contents): Ditto.
	* vms-misc.c (_bfd_save_vms_section): Ditto.
	* vms.c (vms_set_section_contents): Ditto.
	* vms.h (_bfd_save_vms_section): Ditto.
@
text
@d52 1
a52 1
   level is also identation level. Indentation is performed
d671 1
a671 1
  /* save current output position to fill in lenght later  */
@


1.16
log
@	* coff-h8300.c: Fix comment typos.
	* coffcode.h: Likewise.
	* cpu-cris.c: Likewise.
	* elf32-vax.c: Likewise.
	* genlink.h: Likewise.
	* linker.c: Likewise.
	* som.c: Likewise.
	* tekhex.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d615 1
a615 1
     PTR data;
@


1.15
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d608 2
a609 2
/* Save section data & offset to an vms_section structure
   vms_section_table[] holds the vms_section chain  */
@


1.14
log
@	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.
@
text
@d358 2
a359 2
      if ( (vms_buf[0] == vms_buf[4])
        && (vms_buf[1] == vms_buf[5]))
d611 1
a611 1
boolean
d624 1
a624 1
      return false;
d627 1
a627 1
    return true;
d630 1
a630 1
    return false;
d633 1
a633 1
  return true;
d1095 1
a1095 1
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, false, false);
d1101 2
a1102 1
      entry = (vms_symbol_entry *)bfd_hash_lookup (PRIV (vms_symbol_table), name, true, false);
@


1.14.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d52 1
a52 1
   level is also indentation level. Indentation is performed
d358 2
a359 2
      if (vms_buf[0] == vms_buf[4]
	  && vms_buf[1] == vms_buf[5])
d608 2
a609 2
/* Save section data & offset to a vms_section structure
   vms_section_table[] holds the vms_section chain.  */
d611 1
a611 1
bfd_boolean
d615 1
a615 1
     const PTR data;
d624 1
a624 1
      return FALSE;
d627 1
a627 1
    return TRUE;
d630 1
a630 1
    return FALSE;
d633 1
a633 1
  return TRUE;
d671 1
a671 1
  /* save current output position to fill in length later  */
d1095 1
a1095 1
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, FALSE, FALSE);
d1101 1
a1101 2
      entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						    name, TRUE, FALSE);
@


1.14.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d358 2
a359 2
      if (vms_buf[0] == vms_buf[4]
	  && vms_buf[1] == vms_buf[5])
d608 2
a609 2
/* Save section data & offset to a vms_section structure
   vms_section_table[] holds the vms_section chain.  */
d611 1
a611 1
bfd_boolean
d624 1
a624 1
      return FALSE;
d627 1
a627 1
    return TRUE;
d630 1
a630 1
    return FALSE;
d633 1
a633 1
  return TRUE;
d1095 1
a1095 1
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, FALSE, FALSE);
d1101 1
a1101 2
      entry = (vms_symbol_entry *) bfd_hash_lookup (PRIV (vms_symbol_table),
						    name, TRUE, FALSE);
@


1.14.10.2
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d615 1
a615 1
     const PTR data;
@


1.14.10.3
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d52 1
a52 1
   level is also indentation level. Indentation is performed
d671 1
a671 1
  /* save current output position to fill in length later  */
@


1.13
log
@	* syms.c (_bfd_generic_make_empty_symbol): New function.
	* libbfd-in.h (_bfd_nosymbols_make_empty_symbol): Define as
	_bfd_generic_make_empty_symbol.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* hppabsd-core.c (hppabsd_core_make_empty_symbol): Delete function.
	(hppabsd_core_get_symtab_upper_bound): Don't define.
	(hppabsd_core_get_symtab): Likewise.
	(hppabsd_core_print_symbol): Likewise.
	(hppabsd_core_get_symbol_info): Likewise.
	(hppabsd_core_bfd_is_local_label_name): Likewise.
	(hppabsd_core_get_lineno): Likewise.
	(hppabsd_core_find_nearest_line): Likewise.
	(hppabsd_core_bfd_make_debug_symbol): Likewise.
	(hppabsd_core_read_minisymbols): Likewise.
	(hppabsd_core_minisymbol_to_symbol): Likewise.
	(hppabsd_core_vec): Use BFD_JUMP_TABLE_SYMBOLS (_bfd_nosymbols).
	Formatting fixes.
	* hpux-core.c: Similarly.
	* irix-core.c: Similarly.
	* osf-core.c: Similarly.
	* sco5-core.c: Similarly.
	* binary.c (binary_make_empty_symbol): Remove function, define as
	_bfd_generic_make_empty_symbol.
	* ihex.c (ihex_make_empty_symbol): Likewise.
	* mmo.c (mmo_make_empty_symbol): Likewise.
	* ppcboot.c (ppcboot_make_empty_symbol): Likewise.
	* srec.c (srec_make_empty_symbol): Likewise.
	* versados.c (versados_make_empty_symbol): Likewise.
	* vms.c (_bfd_vms_make_empty_symbol): Remove.
	(vms_make_empty_symbol): Define as _bfd_generic_make_empty_symbol.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Call bfd_make_empty_symbol
	rather than _bfd_vms_make_empty_symbol.
	* vms-misc.c (new_symbol): Likewise.
@
text
@d295 2
d299 1
a299 2
	  PRIV (vms_buf) = (unsigned char *) malloc (OBJ_S_C_MAXRECSIZ);
	  PRIV (buf_size) = OBJ_S_C_MAXRECSIZ;
d303 3
a305 1
	PRIV (vms_buf) = (unsigned char *) malloc (6);
d311 1
a311 4
    {
      bfd_set_error (bfd_error_no_memory);
      return -1;
    }
d374 1
a374 1
				    abfd);
d386 1
a386 1
      _bfd_vms_get_header_values (abfd, vms_buf+test_start, NULL,
d408 2
a409 1
			    realloc (vms_buf, (size_t) PRIV (rec_length)));
d412 1
a412 4
	    {
	      bfd_set_error (bfd_error_no_memory);
	      return -1;
	    }
d594 2
a595 1
  newptr = (vms_section *) bfd_malloc ((bfd_size_type) sizeof (vms_section));
@


1.13.12.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@a294 2
      bfd_size_type amt;

d297 2
a298 1
	  amt = OBJ_S_C_MAXRECSIZ;
d302 1
a302 3
	amt = 6;
      PRIV (vms_buf) = (unsigned char *) bfd_malloc (amt);
      PRIV (buf_size) = amt;
d308 4
a311 1
    return -1;
d374 1
a374 1
				     abfd);
d386 1
a386 1
      _bfd_vms_get_header_values (abfd, vms_buf + test_start, NULL,
d408 1
a408 2
			    bfd_realloc (vms_buf,
					 (bfd_size_type) PRIV (rec_length)));
d411 4
a414 1
	    return -1;
d596 1
a596 2
  newptr = (vms_section *) bfd_alloc (abfd,
				      (bfd_size_type) sizeof (vms_section));
@


1.13.10.1
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@a294 2
      bfd_size_type amt;

d297 2
a298 1
	  amt = OBJ_S_C_MAXRECSIZ;
d302 1
a302 3
	amt = 6;
      PRIV (vms_buf) = (unsigned char *) bfd_malloc (amt);
      PRIV (buf_size) = amt;
d308 4
a311 1
    return -1;
d374 1
a374 1
				     abfd);
d386 1
a386 1
      _bfd_vms_get_header_values (abfd, vms_buf + test_start, NULL,
d408 1
a408 2
			    bfd_realloc (vms_buf,
					 (bfd_size_type) PRIV (rec_length)));
d411 4
a414 1
	    return -1;
d596 1
a596 2
  newptr = (vms_section *) bfd_alloc (abfd,
				      (bfd_size_type) sizeof (vms_section));
@


1.12
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d1073 1
a1073 1
  symbol = _bfd_vms_make_empty_symbol (abfd);
@


1.11
log
@	* vms-tir.c: Add missing prototypes.
	* vms-hdr.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d36 1
a36 1
  
d337 1
a337 1
      if (bfd_read (PRIV (vms_buf), 1, 1, abfd) != 1)
d347 1
a347 1
      && (bfd_read (PRIV (vms_buf), 1, test_len, abfd)
d373 2
a374 1
      PRIV (rec_length) = bfd_read (vms_buf, 1, PRIV (buf_size), abfd);
d407 2
a408 1
	  PRIV (vms_buf) = (unsigned char *) realloc (vms_buf, PRIV (rec_length));
d423 1
a423 1
      vms_debug (10, "bfd_read remaining %d\n", remaining);
d425 1
a425 1
      if (bfd_read (vms_buf + test_len, 1, remaining, abfd) !=
d435 1
a435 1
  vms_debug (11, "bfd_read rec_length %d\n", PRIV (rec_length));
d496 1
a496 1
  char *newstr = bfd_malloc (size + 1);
d500 1
a500 1
  strncpy (newstr, (char *)str, size);
d596 1
a596 1
  newptr = (vms_section *) bfd_malloc (sizeof (vms_section));
d599 2
a600 2
  newptr->contents = (unsigned char *) bfd_alloc (abfd, (int)section->_raw_size);
  if (newptr->contents == (unsigned char *)NULL)
d670 1
a670 1
  _bfd_vms_output_short (abfd,rectype);
d682 1
a682 1
  _bfd_vms_output_short (abfd,0);		/* placeholder for length */
d685 1
a685 1
    _bfd_vms_output_short (abfd,rechead);
d785 1
a785 1
  _bfd_vms_output_short (abfd, (unsigned int)length);
d791 1
a791 1
      fwrite (PRIV (output_buf)+2, 2, 1, (FILE *)abfd->iostream);
d793 2
a794 1
      fwrite (PRIV (output_buf), real_size, 1, (FILE *)abfd->iostream);
d865 2
a866 1
  bfd_put_16 (abfd, value & 0xffff, PRIV (output_buf) + PRIV (output_size));
d882 1
a882 1
  bfd_put_32 (abfd, value, PRIV (output_buf) + PRIV (output_size));
d927 1
a927 1
  _bfd_vms_output_byte (abfd, len & 0xff);
d946 1
a946 1
  memcpy (PRIV (output_buf) + PRIV (output_size), data, length);
d966 1
a966 1
  memset (PRIV (output_buf) + PRIV (output_size), value, count);
d1038 1
a1038 1
  strncpy (out, in, i);
@


1.10
log
@Update copyright notices
@
text
@d33 4
@


1.9
log
@2001-02-18  Kazu Hirata  <kazu@@hxi.com>

	* vms-misc.c: Fix formatting.
@
text
@d3 2
a4 1
   Copyright 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.8
log
@2001-01-23  H.J. Lu  <hjl@@gnu.org>

	* vms-misc.c (_bfd_vms_next_record): Return -1 if PRIV(vms_buf)
	is NULL or PRIV(vms_rec) is outside of the buffer.
@
text
@a168 1

a211 1

d288 1
a288 1
  if (PRIV(buf_size) == 0)
d290 1
a290 1
      if (PRIV(is_vax))
d292 3
a294 3
	  PRIV(vms_buf) = (unsigned char *) malloc (OBJ_S_C_MAXRECSIZ);
	  PRIV(buf_size) = OBJ_S_C_MAXRECSIZ;
	  PRIV(file_format) = FF_VAX;
d297 1
a297 1
	PRIV(vms_buf) = (unsigned char *) malloc (6);
d300 1
a300 1
  vms_buf = PRIV(vms_buf);
d308 1
a308 1
  switch (PRIV(file_format))
d332 1
a332 1
      if (bfd_read (PRIV(vms_buf), 1, 1, abfd) != 1)
d342 1
a342 1
      && (bfd_read (PRIV(vms_buf), 1, test_len, abfd)
d351 1
a351 1
  if (PRIV(file_format) == FF_UNKNOWN)
d356 1
a356 1
	  PRIV(file_format) = FF_FOREIGN;	/* Y: foreign environment */
d361 1
a361 1
	  PRIV(file_format) = FF_NATIVE;	/* N: native environment */
d366 1
a366 1
  if (PRIV(is_vax))
d368 2
a369 2
      PRIV(rec_length) = bfd_read (vms_buf, 1, PRIV(buf_size), abfd);
      if (PRIV(rec_length) <= 0)
d374 1
a374 1
      PRIV(vms_rec) = vms_buf;
d381 1
a381 1
				  &PRIV(rec_length));
d383 1
a383 1
      if (PRIV(rec_length) <= 0)
d391 1
a391 1
      if (PRIV(rec_length) > EOBJ_S_C_MAXRECSIZ)
d399 1
a399 1
      if (PRIV(rec_length) > PRIV(buf_size))
d401 2
a402 2
	  PRIV(vms_buf) = (unsigned char *) realloc (vms_buf, PRIV(rec_length));
	  vms_buf = PRIV(vms_buf);
d408 1
a408 1
	  PRIV(buf_size) = PRIV(rec_length);
d413 1
a413 1
      remaining = PRIV(rec_length) - test_len + test_start;
d424 1
a424 1
      PRIV(vms_rec) = vms_buf + test_start;
d428 1
a428 1
  vms_debug (11, "bfd_read rec_length %d\n", PRIV(rec_length));
d431 1
a431 1
  return PRIV(rec_length);
d443 1
a443 1
	      PRIV(rec_length), PRIV(rec_size));
d446 1
a446 1
  if (PRIV(rec_length) > 0)
d448 1
a448 1
      PRIV(vms_rec) += PRIV(rec_size);
d456 2
a457 2
  if (!PRIV(vms_rec) || !PRIV(vms_buf)
      || PRIV(vms_rec) >= (PRIV(vms_buf) + PRIV(buf_size)))
d460 1
a460 1
  if (PRIV(is_vax))
d462 2
a463 2
      PRIV(rec_type) = *(PRIV(vms_rec));
      PRIV(rec_size) = PRIV(rec_length);
d467 2
a468 2
      _bfd_vms_get_header_values (abfd, PRIV(vms_rec), &PRIV(rec_type),
				  &PRIV(rec_size));
d470 1
a470 1
  PRIV(rec_length) -= PRIV(rec_size);
d474 2
a475 2
	      PRIV(vms_rec), PRIV(rec_size), PRIV(rec_length),
	      PRIV(rec_type));
d478 1
a478 1
  return PRIV(rec_type);
a479 1

a509 1

d524 1
a524 1
  vms_debug (4, "<push %016lx(%d) at %d>\n", val, psect, PRIV(stackptr));
d530 4
a533 4
  PRIV(stack[PRIV(stackptr)]).value = val;
  PRIV(stack[PRIV(stackptr)]).psect = last_psect;
  PRIV(stackptr)++;
  if (PRIV(stackptr) >= STACKSIZE)
d536 1
a536 1
      (*_bfd_error_handler) (_("Stack overflow (%d) in _bfd_vms_push"), PRIV(stackptr));
d551 1
a551 1
  if (PRIV(stackptr) == 0)
d557 4
a560 4
  PRIV(stackptr)--;
  value = PRIV(stack[PRIV(stackptr)]).value;
  if ((psect != NULL) && (PRIV(stack[PRIV(stackptr)]).psect >= 0))
    *psect = PRIV(stack[PRIV(stackptr)]).psect;
d563 1
a563 1
  vms_debug (4, "<pop %016lx(%d)>\n", value, PRIV(stack[PRIV(stackptr)]).psect);
a567 1

d585 1
a585 1
  sptr = PRIV(vms_section_table)[section->index];
d598 1
a598 1
  PRIV(vms_section_table)[section->index] = newptr;
d642 1
a642 1
  return PRIV(vms_section_table)[index];
a643 1

d667 2
a668 2
  if (PRIV(push_level) > 0)
    PRIV(length_pos) = PRIV(output_size);
d672 1
a672 1
	      PRIV(length_pos));
d694 1
a694 1
  PRIV(output_alignment) = alignto;
d705 1
a705 1
  vms_debug (6, "vms_output_push(pushed_size = %d)\n", PRIV(output_size));
d708 2
a709 2
  PRIV(push_level)++;
  PRIV(pushed_size) = PRIV(output_size);
d720 1
a720 1
  vms_debug (6, "vms_output_pop(pushed_size = %d)\n", PRIV(pushed_size));
d724 1
a724 1
  PRIV(length_pos) = 2;
d727 1
a727 1
  vms_debug (6, "vms_output_pop: length_pos = %d\n", PRIV(length_pos));
d730 2
a731 2
  PRIV(pushed_size) = 0;
  PRIV(push_level)--;
d741 1
a741 1
  int real_size = PRIV(output_size);
d747 1
a747 1
	      real_size, PRIV(pushed_size), PRIV(length_pos));
d750 2
a751 2
  if (PRIV(push_level) > 0)
    length = real_size - PRIV(pushed_size);
d757 2
a758 2
  aligncount = (PRIV(output_alignment)
		- (length % PRIV(output_alignment))) % PRIV(output_alignment);
d766 1
a766 1
      PRIV(output_buf)[real_size++] = 0;
d771 1
a771 1
      if (PRIV(push_level) > 0)
d777 1
a777 1
  PRIV(output_size) = PRIV(length_pos);
d780 1
a780 1
  if (PRIV(push_level) == 0)
d784 1
a784 1
      fwrite (PRIV(output_buf)+2, 2, 1, (FILE *)abfd->iostream);
d786 1
a786 1
      fwrite (PRIV(output_buf), real_size, 1, (FILE *)abfd->iostream);
d788 1
a788 1
      PRIV(output_size) = 0;
d792 2
a793 2
      PRIV(output_size) = real_size;
      PRIV(pushed_size) = PRIV(output_size);
d827 1
a827 1
  return (MAX_OUTREC_SIZE - (PRIV(output_size) + size + MIN_OUTREC_LUFT));
d841 2
a842 2
  bfd_put_8 (abfd, value & 0xff, PRIV(output_buf) + PRIV(output_size));
  PRIV(output_size) += 1;
d857 2
a858 2
  bfd_put_16 (abfd, value & 0xffff, PRIV(output_buf) + PRIV(output_size));
  PRIV(output_size) += 2;
d873 2
a874 2
  bfd_put_32 (abfd, value, PRIV(output_buf) + PRIV(output_size));
  PRIV(output_size) += 4;
d889 2
a890 2
  bfd_put_64(abfd, value, PRIV(output_buf) + PRIV(output_size));
  PRIV(output_size) += 8;
d937 2
a938 2
  memcpy (PRIV(output_buf) + PRIV(output_size), data, length);
  PRIV(output_size) += length;
d957 2
a958 2
  memset (PRIV(output_buf) + PRIV(output_size), value, count);
  PRIV(output_size) += count;
d1023 1
a1023 1
      if (PRIV(flag_hash_long_names))
d1034 1
a1034 1
      && PRIV(flag_hash_long_names))
d1044 2
a1045 2
	&& PRIV(flag_hash_long_names)
	&& PRIV(flag_show_after_trunc))
d1087 1
a1087 1
	  bfd_hash_lookup (PRIV(vms_symbol_table), name, false, false);
d1093 1
a1093 1
      entry = (vms_symbol_entry *)bfd_hash_lookup (PRIV(vms_symbol_table), name, true, false);
d1101 1
a1101 1
	      PRIV(gsd_sym_count)++;
@


1.8.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.8.2.2
log
@Merge from mainline.
@
text
@d170 1
d214 1
d291 1
a291 1
  if (PRIV (buf_size) == 0)
d293 1
a293 1
      if (PRIV (is_vax))
d295 3
a297 3
	  PRIV (vms_buf) = (unsigned char *) malloc (OBJ_S_C_MAXRECSIZ);
	  PRIV (buf_size) = OBJ_S_C_MAXRECSIZ;
	  PRIV (file_format) = FF_VAX;
d300 1
a300 1
	PRIV (vms_buf) = (unsigned char *) malloc (6);
d303 1
a303 1
  vms_buf = PRIV (vms_buf);
d311 1
a311 1
  switch (PRIV (file_format))
d335 1
a335 1
      if (bfd_read (PRIV (vms_buf), 1, 1, abfd) != 1)
d345 1
a345 1
      && (bfd_read (PRIV (vms_buf), 1, test_len, abfd)
d354 1
a354 1
  if (PRIV (file_format) == FF_UNKNOWN)
d359 1
a359 1
	  PRIV (file_format) = FF_FOREIGN;	/* Y: foreign environment */
d364 1
a364 1
	  PRIV (file_format) = FF_NATIVE;	/* N: native environment */
d369 1
a369 1
  if (PRIV (is_vax))
d371 2
a372 2
      PRIV (rec_length) = bfd_read (vms_buf, 1, PRIV (buf_size), abfd);
      if (PRIV (rec_length) <= 0)
d377 1
a377 1
      PRIV (vms_rec) = vms_buf;
d384 1
a384 1
				  &PRIV (rec_length));
d386 1
a386 1
      if (PRIV (rec_length) <= 0)
d394 1
a394 1
      if (PRIV (rec_length) > EOBJ_S_C_MAXRECSIZ)
d402 1
a402 1
      if (PRIV (rec_length) > PRIV (buf_size))
d404 2
a405 2
	  PRIV (vms_buf) = (unsigned char *) realloc (vms_buf, PRIV (rec_length));
	  vms_buf = PRIV (vms_buf);
d411 1
a411 1
	  PRIV (buf_size) = PRIV (rec_length);
d416 1
a416 1
      remaining = PRIV (rec_length) - test_len + test_start;
d427 1
a427 1
      PRIV (vms_rec) = vms_buf + test_start;
d431 1
a431 1
  vms_debug (11, "bfd_read rec_length %d\n", PRIV (rec_length));
d434 1
a434 1
  return PRIV (rec_length);
d446 1
a446 1
	      PRIV (rec_length), PRIV (rec_size));
d449 1
a449 1
  if (PRIV (rec_length) > 0)
d451 1
a451 1
      PRIV (vms_rec) += PRIV (rec_size);
d459 2
a460 2
  if (!PRIV (vms_rec) || !PRIV (vms_buf)
      || PRIV (vms_rec) >= (PRIV (vms_buf) + PRIV (buf_size)))
d463 1
a463 1
  if (PRIV (is_vax))
d465 2
a466 2
      PRIV (rec_type) = *(PRIV (vms_rec));
      PRIV (rec_size) = PRIV (rec_length);
d470 2
a471 2
      _bfd_vms_get_header_values (abfd, PRIV (vms_rec), &PRIV (rec_type),
				  &PRIV (rec_size));
d473 1
a473 1
  PRIV (rec_length) -= PRIV (rec_size);
d477 2
a478 2
	      PRIV (vms_rec), PRIV (rec_size), PRIV (rec_length),
	      PRIV (rec_type));
d481 1
a481 1
  return PRIV (rec_type);
d483 1
d514 1
d529 1
a529 1
  vms_debug (4, "<push %016lx(%d) at %d>\n", val, psect, PRIV (stackptr));
d535 4
a538 4
  PRIV (stack[PRIV (stackptr)]).value = val;
  PRIV (stack[PRIV (stackptr)]).psect = last_psect;
  PRIV (stackptr)++;
  if (PRIV (stackptr) >= STACKSIZE)
d541 1
a541 1
      (*_bfd_error_handler) (_("Stack overflow (%d) in _bfd_vms_push"), PRIV (stackptr));
d556 1
a556 1
  if (PRIV (stackptr) == 0)
d562 4
a565 4
  PRIV (stackptr)--;
  value = PRIV (stack[PRIV (stackptr)]).value;
  if ((psect != NULL) && (PRIV (stack[PRIV (stackptr)]).psect >= 0))
    *psect = PRIV (stack[PRIV (stackptr)]).psect;
d568 1
a568 1
  vms_debug (4, "<pop %016lx(%d)>\n", value, PRIV (stack[PRIV (stackptr)]).psect);
d573 1
d591 1
a591 1
  sptr = PRIV (vms_section_table)[section->index];
d604 1
a604 1
  PRIV (vms_section_table)[section->index] = newptr;
d648 1
a648 1
  return PRIV (vms_section_table)[index];
d650 1
d674 2
a675 2
  if (PRIV (push_level) > 0)
    PRIV (length_pos) = PRIV (output_size);
d679 1
a679 1
	      PRIV (length_pos));
d701 1
a701 1
  PRIV (output_alignment) = alignto;
d712 1
a712 1
  vms_debug (6, "vms_output_push(pushed_size = %d)\n", PRIV (output_size));
d715 2
a716 2
  PRIV (push_level)++;
  PRIV (pushed_size) = PRIV (output_size);
d727 1
a727 1
  vms_debug (6, "vms_output_pop(pushed_size = %d)\n", PRIV (pushed_size));
d731 1
a731 1
  PRIV (length_pos) = 2;
d734 1
a734 1
  vms_debug (6, "vms_output_pop: length_pos = %d\n", PRIV (length_pos));
d737 2
a738 2
  PRIV (pushed_size) = 0;
  PRIV (push_level)--;
d748 1
a748 1
  int real_size = PRIV (output_size);
d754 1
a754 1
	      real_size, PRIV (pushed_size), PRIV (length_pos));
d757 2
a758 2
  if (PRIV (push_level) > 0)
    length = real_size - PRIV (pushed_size);
d764 2
a765 2
  aligncount = (PRIV (output_alignment)
		- (length % PRIV (output_alignment))) % PRIV (output_alignment);
d773 1
a773 1
      PRIV (output_buf)[real_size++] = 0;
d778 1
a778 1
      if (PRIV (push_level) > 0)
d784 1
a784 1
  PRIV (output_size) = PRIV (length_pos);
d787 1
a787 1
  if (PRIV (push_level) == 0)
d791 1
a791 1
      fwrite (PRIV (output_buf)+2, 2, 1, (FILE *)abfd->iostream);
d793 1
a793 1
      fwrite (PRIV (output_buf), real_size, 1, (FILE *)abfd->iostream);
d795 1
a795 1
      PRIV (output_size) = 0;
d799 2
a800 2
      PRIV (output_size) = real_size;
      PRIV (pushed_size) = PRIV (output_size);
d834 1
a834 1
  return (MAX_OUTREC_SIZE - (PRIV (output_size) + size + MIN_OUTREC_LUFT));
d848 2
a849 2
  bfd_put_8 (abfd, value & 0xff, PRIV (output_buf) + PRIV (output_size));
  PRIV (output_size) += 1;
d864 2
a865 2
  bfd_put_16 (abfd, value & 0xffff, PRIV (output_buf) + PRIV (output_size));
  PRIV (output_size) += 2;
d880 2
a881 2
  bfd_put_32 (abfd, value, PRIV (output_buf) + PRIV (output_size));
  PRIV (output_size) += 4;
d896 2
a897 2
  bfd_put_64(abfd, value, PRIV (output_buf) + PRIV (output_size));
  PRIV (output_size) += 8;
d944 2
a945 2
  memcpy (PRIV (output_buf) + PRIV (output_size), data, length);
  PRIV (output_size) += length;
d964 2
a965 2
  memset (PRIV (output_buf) + PRIV (output_size), value, count);
  PRIV (output_size) += count;
d1030 1
a1030 1
      if (PRIV (flag_hash_long_names))
d1041 1
a1041 1
      && PRIV (flag_hash_long_names))
d1051 2
a1052 2
	&& PRIV (flag_hash_long_names)
	&& PRIV (flag_show_after_trunc))
d1094 1
a1094 1
	  bfd_hash_lookup (PRIV (vms_symbol_table), name, false, false);
d1100 1
a1100 1
      entry = (vms_symbol_entry *)bfd_hash_lookup (PRIV (vms_symbol_table), name, true, false);
d1108 1
a1108 1
	      PRIV (gsd_sym_count)++;
@


1.7
log
@2000-12-26  Kazu Hirata  <kazu@@hxi.com>

	* vaxnetbsd.c: Fix formatting.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d458 2
a459 1
  if (!PRIV(vms_rec))
@


1.6
log
@Add default case to file_format switch.
@
text
@a20 1

d40 1
a40 1
  
d76 2
a77 2
  while(--level>0)
    fprintf(output, " ");
d79 1
a79 1
  vfprintf(output, format, args);
d114 3
a116 3
  while(--level>0)
    fprintf(output, " ");
  fprintf(output, format, a1, a2, a3, a4, a5, a6);
a122 1

a235 1

a238 1

d241 1
a241 1
  
d243 1
a243 1
  
d249 1
a249 1
  
d256 1
a256 1
  
d258 1
a258 1
  
d264 1
a264 1
  
d270 1
a270 1
  
d317 1
a317 1
      
d322 1
a322 1
      
a435 1

a481 1

a544 1

a605 1

a633 1

a687 1

a702 1

a717 1

a739 1

d769 1
a769 1
  while(aligncount-- > 0)
a803 1

a818 1

a834 1

a850 1

a866 1

a882 1

a898 1

a926 1

a947 1

a1055 1

a1076 1

@


1.5
log
@2000-06-14  H.J. Lu  <hjl@@gnu.org>

	* vms-misc.c (_bfd_vms_next_record): Return -1 if PRIV(vms_rec)
	is NULL.
@
text
@d316 4
a319 4
      case FF_UNKNOWN:
      case FF_FOREIGN:
	test_len = 6;			/* probe 6 bytes */
	test_start = 2;			/* where the record starts */
d321 4
a324 4

      case FF_NATIVE:
	test_len = 4;
	test_start = 0;
d326 5
a330 4

      case FF_VAX:
	test_len = 0;
	test_start = 0;
d332 1
a332 1
  }
@


1.4
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d462 3
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Remove unused local
	variables.  Add default case to enum switches.
	* coff-arm.c (bfd_arm_allocate_interworking_sections): Only
	compile if not COFF_IMAGE_WITH_PE.
	(record_arm_to_thumb_glue, record_thumb_to_arm_glue): Likewise.
	(bfd_arm_get_bfd_for_interworking): Likewise.
	(bfd_arm_process_before_allocation): Likewise.
	* epoc-pei-arm.c: Don't rename bfd_arm functions.
	* pei-arm.c: Likewise.
	* elf32-mips.c (mips_elf_link_hash_table_create): Don't declare.
	(MIPS_ELF_ADD_DYNAMIC_ENTRY): Correct last change.
	(mips_elf_got16_entry): Put parens around & in body of ==.
	(mips_elf_calculate_relocation): Correct test for empty string.
	* vms-gsd.c: Use _bfd_error_handler rather than fprintf to
	stderr.
	* vms-misc.c (_bfd_vms_length_hash_symbol): Correct sprintf
	format.
@
text
@d223 1
a223 1
     bfd *abfd;
d347 2
a348 1
      && (bfd_read (PRIV(vms_buf), 1, test_len, abfd) != test_len))
d423 2
a424 1
      if (bfd_read (vms_buf + test_len, 1, remaining, abfd) != remaining)
@


1.2
log
@	* vms-misc.c (_bfd_vms_hash_newfunc): Fix use of uninitialized
	variable.
@
text
@d3 1
a3 1
   Copyright 1996, 1997, 1998 Free Software Foundation, Inc.
a1010 1
  long int init;
a1012 1
  char *pnt = 0;
d1056 1
a1056 1
    sprintf (out, "_%08x", result);
@


1.1
log
@Initial revision
@
text
@d201 1
d206 1
a206 1
  ret = (vms_symbol_entry *) bfd_hash_newfunc ((struct bfd_hash_entry *)ret, table, string);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

