head	1.32;
access;
symbols
	sid-snapshot-20180601:1.32
	sid-snapshot-20180501:1.32
	sid-snapshot-20180401:1.32
	sid-snapshot-20180301:1.32
	sid-snapshot-20180201:1.32
	sid-snapshot-20180101:1.32
	sid-snapshot-20171201:1.32
	sid-snapshot-20171101:1.32
	sid-snapshot-20171001:1.32
	sid-snapshot-20170901:1.32
	sid-snapshot-20170801:1.32
	sid-snapshot-20170701:1.32
	sid-snapshot-20170601:1.32
	sid-snapshot-20170501:1.32
	sid-snapshot-20170401:1.32
	sid-snapshot-20170301:1.32
	sid-snapshot-20170201:1.32
	sid-snapshot-20170101:1.32
	sid-snapshot-20161201:1.32
	sid-snapshot-20161101:1.32
	sid-snapshot-20160901:1.32
	sid-snapshot-20160801:1.32
	sid-snapshot-20160701:1.32
	sid-snapshot-20160601:1.32
	sid-snapshot-20160501:1.32
	sid-snapshot-20160401:1.32
	sid-snapshot-20160301:1.32
	sid-snapshot-20160201:1.32
	sid-snapshot-20160101:1.32
	sid-snapshot-20151201:1.32
	sid-snapshot-20151101:1.32
	sid-snapshot-20151001:1.32
	sid-snapshot-20150901:1.32
	sid-snapshot-20150801:1.32
	sid-snapshot-20150701:1.32
	sid-snapshot-20150601:1.32
	sid-snapshot-20150501:1.32
	sid-snapshot-20150401:1.32
	sid-snapshot-20150301:1.32
	sid-snapshot-20150201:1.32
	sid-snapshot-20150101:1.32
	sid-snapshot-20141201:1.32
	sid-snapshot-20141101:1.32
	sid-snapshot-20141001:1.32
	sid-snapshot-20140901:1.32
	sid-snapshot-20140801:1.32
	sid-snapshot-20140701:1.32
	sid-snapshot-20140601:1.32
	sid-snapshot-20140501:1.32
	sid-snapshot-20140401:1.32
	sid-snapshot-20140301:1.32
	sid-snapshot-20140201:1.32
	sid-snapshot-20140101:1.32
	sid-snapshot-20131201:1.32
	sid-snapshot-20131101:1.32
	sid-snapshot-20131001:1.31
	binutils-2_24-branch:1.31.0.2
	binutils-2_24-branchpoint:1.31
	binutils-2_21_1:1.23
	sid-snapshot-20130901:1.31
	gdb_7_6_1-2013-08-30-release:1.30
	sid-snapshot-20130801:1.31
	sid-snapshot-20130701:1.31
	sid-snapshot-20130601:1.31
	sid-snapshot-20130501:1.31
	gdb_7_6-2013-04-26-release:1.30
	sid-snapshot-20130401:1.31
	binutils-2_23_2:1.29
	gdb_7_6-branch:1.30.0.2
	gdb_7_6-2013-03-12-branchpoint:1.30
	sid-snapshot-20130301:1.30
	sid-snapshot-20130201:1.30
	sid-snapshot-20130101:1.29
	sid-snapshot-20121201:1.29
	gdb_7_5_1-2012-11-29-release:1.29
	binutils-2_23_1:1.29
	sid-snapshot-20121101:1.29
	binutils-2_23:1.29
	sid-snapshot-20121001:1.29
	sid-snapshot-20120901:1.29
	gdb_7_5-2012-08-17-release:1.29
	sid-snapshot-20120801:1.29
	binutils-2_23-branch:1.29.0.4
	binutils-2_23-branchpoint:1.29
	gdb_7_5-branch:1.29.0.2
	gdb_7_5-2012-07-18-branchpoint:1.29
	sid-snapshot-20120701:1.27
	sid-snapshot-20120601:1.26
	sid-snapshot-20120501:1.25
	binutils-2_22_branch:1.24.0.6
	gdb_7_4_1-2012-04-26-release:1.24
	sid-snapshot-20120401:1.24
	sid-snapshot-20120301:1.24
	sid-snapshot-20120201:1.24
	gdb_7_4-2012-01-24-release:1.24
	sid-snapshot-20120101:1.24
	gdb_7_4-branch:1.24.0.4
	gdb_7_4-2011-12-13-branchpoint:1.24
	sid-snapshot-20111201:1.24
	binutils-2_22:1.24
	sid-snapshot-20111101:1.24
	sid-snapshot-20111001:1.24
	binutils-2_22-branch:1.24.0.2
	binutils-2_22-branchpoint:1.24
	gdb_7_3_1-2011-09-04-release:1.23
	sid-snapshot-20110901:1.24
	sid-snapshot-20110801:1.24
	gdb_7_3-2011-07-26-release:1.23
	sid-snapshot-20110701:1.24
	sid-snapshot-20110601:1.23
	sid-snapshot-20110501:1.23
	gdb_7_3-branch:1.23.0.4
	gdb_7_3-2011-04-01-branchpoint:1.23
	sid-snapshot-20110401:1.23
	sid-snapshot-20110301:1.23
	sid-snapshot-20110201:1.23
	sid-snapshot-20110101:1.23
	binutils-2_21:1.23
	sid-snapshot-20101201:1.23
	binutils-2_21-branch:1.23.0.2
	binutils-2_21-branchpoint:1.23
	sid-snapshot-20101101:1.23
	sid-snapshot-20101001:1.22
	binutils-2_20_1:1.20
	gdb_7_2-2010-09-02-release:1.21
	sid-snapshot-20100901:1.22
	sid-snapshot-20100801:1.21
	gdb_7_2-branch:1.21.0.2
	gdb_7_2-2010-07-07-branchpoint:1.21
	sid-snapshot-20100701:1.21
	sid-snapshot-20100601:1.20
	sid-snapshot-20100501:1.20
	sid-snapshot-20100401:1.20
	gdb_7_1-2010-03-18-release:1.20
	sid-snapshot-20100301:1.20
	gdb_7_1-branch:1.20.0.6
	gdb_7_1-2010-02-18-branchpoint:1.20
	sid-snapshot-20100201:1.20
	sid-snapshot-20100101:1.20
	gdb_7_0_1-2009-12-22-release:1.20
	sid-snapshot-20091201:1.20
	sid-snapshot-20091101:1.20
	binutils-2_20:1.20
	gdb_7_0-2009-10-06-release:1.20
	sid-snapshot-20091001:1.20
	gdb_7_0-branch:1.20.0.4
	gdb_7_0-2009-09-16-branchpoint:1.20
	arc-sim-20090309:1.16
	binutils-arc-20081103-branch:1.18.0.16
	binutils-arc-20081103-branchpoint:1.18
	binutils-2_20-branch:1.20.0.2
	binutils-2_20-branchpoint:1.20
	sid-snapshot-20090901:1.19
	sid-snapshot-20090801:1.18
	msnyder-checkpoint-072509-branch:1.18.0.14
	msnyder-checkpoint-072509-branchpoint:1.18
	sid-snapshot-20090701:1.18
	dje-cgen-play1-branch:1.18.0.12
	dje-cgen-play1-branchpoint:1.18
	sid-snapshot-20090601:1.18
	sid-snapshot-20090501:1.18
	sid-snapshot-20090401:1.18
	arc-20081103-branch:1.18.0.10
	arc-20081103-branchpoint:1.18
	arc-insight_6_8-branch:1.16.0.8
	arc-insight_6_8-branchpoint:1.16
	insight_6_8-branch:1.16.0.6
	insight_6_8-branchpoint:1.16
	sid-snapshot-20090301:1.18
	binutils-2_19_1:1.18
	sid-snapshot-20090201:1.18
	sid-snapshot-20090101:1.18
	reverse-20081226-branch:1.18.0.8
	reverse-20081226-branchpoint:1.18
	sid-snapshot-20081201:1.18
	multiprocess-20081120-branch:1.18.0.6
	multiprocess-20081120-branchpoint:1.18
	sid-snapshot-20081101:1.18
	binutils-2_19:1.18
	sid-snapshot-20081001:1.18
	reverse-20080930-branch:1.18.0.4
	reverse-20080930-branchpoint:1.18
	binutils-2_19-branch:1.18.0.2
	binutils-2_19-branchpoint:1.18
	sid-snapshot-20080901:1.18
	sid-snapshot-20080801:1.18
	reverse-20080717-branch:1.17.0.2
	reverse-20080717-branchpoint:1.17
	sid-snapshot-20080701:1.17
	msnyder-reverse-20080609-branch:1.16.0.4
	msnyder-reverse-20080609-branchpoint:1.16
	drow-reverse-20070409-branch:1.12.0.2
	drow-reverse-20070409-branchpoint:1.12
	sid-snapshot-20080601:1.16
	sid-snapshot-20080501:1.16
	sid-snapshot-20080403:1.16
	sid-snapshot-20080401:1.16
	gdb_6_8-2008-03-27-release:1.16
	sid-snapshot-20080301:1.16
	gdb_6_8-branch:1.16.0.2
	gdb_6_8-2008-02-26-branchpoint:1.16
	sid-snapshot-20080201:1.16
	sid-snapshot-20080101:1.15
	sid-snapshot-20071201:1.15
	sid-snapshot-20071101:1.15
	gdb_6_7_1-2007-10-29-release:1.14
	gdb_6_7-2007-10-10-release:1.14
	sid-snapshot-20071001:1.15
	gdb_6_7-branch:1.14.0.4
	gdb_6_7-2007-09-07-branchpoint:1.14
	binutils-2_18:1.14
	binutils-2_18-branch:1.14.0.2
	binutils-2_18-branchpoint:1.14
	insight_6_6-20070208-release:1.9
	binutils-csl-coldfire-4_1-32:1.5.4.1
	binutils-csl-sourcerygxx-4_1-32:1.5.4.1
	gdb_6_6-2006-12-18-release:1.9
	binutils-csl-innovasic-fido-3_4_4-33:1.5.4.1
	binutils-csl-coldfire-4_1-30:1.5.4.1
	binutils-csl-sourcerygxx-4_1-30:1.5.4.1
	binutils-csl-coldfire-4_1-28:1.5.4.1
	binutils-csl-sourcerygxx-4_1-29:1.5.4.1
	binutils-csl-sourcerygxx-4_1-28:1.5.4.1
	gdb_6_6-branch:1.9.0.2
	gdb_6_6-2006-11-15-branchpoint:1.9
	binutils-csl-arm-2006q3-27:1.5.4.1
	binutils-csl-sourcerygxx-4_1-27:1.5.4.1
	binutils-csl-arm-2006q3-26:1.5.4.1
	binutils-csl-sourcerygxx-4_1-26:1.5.4.1
	binutils-csl-sourcerygxx-4_1-25:1.5.4.1
	binutils-csl-sourcerygxx-4_1-24:1.5.4.1
	binutils-csl-sourcerygxx-4_1-23:1.5.4.1
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.3
	binutils-csl-sourcerygxx-4_1-21:1.5.4.1
	binutils-csl-arm-2006q3-21:1.5.4.1
	binutils-csl-sourcerygxx-4_1-22:1.5.4.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.5.4.1
	binutils-csl-sourcerygxx-4_1-20:1.5.4.1
	binutils-csl-arm-2006q3-19:1.5.4.1
	binutils-csl-sourcerygxx-4_1-19:1.5.4.1
	binutils-csl-sourcerygxx-4_1-18:1.5.4.1
	binutils-csl-renesas-4_1-9:1.5.4.1
	gdb-csl-sourcerygxx-3_4_4-25:1.2
	nickrob-async-20060828-mergepoint:1.8
	gdb-csl-symbian-6_4_50_20060226-11:1.3
	binutils-csl-renesas-4_1-8:1.5
	binutils-csl-renesas-4_1-7:1.5
	binutils-csl-renesas-4_1-6:1.5
	gdb-csl-sourcerygxx-4_1-17:1.3
	binutils-csl-sourcerygxx-4_1-17:1.5
	gdb-csl-20060226-branch-local-2:1.3
	gdb-csl-sourcerygxx-4_1-14:1.3
	binutils-csl-sourcerygxx-4_1-14:1.5
	binutils-csl-sourcerygxx-4_1-15:1.5
	gdb-csl-sourcerygxx-4_1-13:1.3
	binutils-csl-sourcerygxx-4_1-13:1.5
	binutils-2_17:1.6
	gdb-csl-sourcerygxx-4_1-12:1.3
	binutils-csl-sourcerygxx-4_1-12:1.5
	gdb-csl-sourcerygxx-3_4_4-21:1.3
	binutils-csl-sourcerygxx-3_4_4-21:1.5
	gdb_6_5-20060621-release:1.7
	gdb-csl-sourcerygxx-4_1-9:1.3
	binutils-csl-sourcerygxx-4_1-9:1.5
	gdb-csl-sourcerygxx-4_1-8:1.3
	binutils-csl-sourcerygxx-4_1-8:1.5
	gdb-csl-sourcerygxx-4_1-7:1.3
	binutils-csl-sourcerygxx-4_1-7:1.5
	gdb-csl-arm-2006q1-6:1.3
	binutils-csl-arm-2006q1-6:1.5
	gdb-csl-sourcerygxx-4_1-6:1.3
	binutils-csl-sourcerygxx-4_1-6:1.5
	gdb-csl-symbian-6_4_50_20060226-10:1.3
	gdb-csl-symbian-6_4_50_20060226-9:1.3
	gdb-csl-symbian-6_4_50_20060226-8:1.3
	gdb-csl-coldfire-4_1-11:1.3
	binutils-csl-coldfire-4_1-11:1.5
	gdb-csl-sourcerygxx-3_4_4-19:1.3
	binutils-csl-sourcerygxx-3_4_4-19:1.5
	gdb-csl-coldfire-4_1-10:1.3
	gdb_6_5-branch:1.7.0.4
	gdb_6_5-2006-05-14-branchpoint:1.7
	binutils-csl-coldfire-4_1-10:1.5
	gdb-csl-sourcerygxx-4_1-5:1.3
	binutils-csl-sourcerygxx-4_1-5:1.5
	nickrob-async-20060513-branch:1.7.0.2
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.3
	binutils-csl-sourcerygxx-4_1-4:1.5
	msnyder-reverse-20060502-branch:1.6.0.6
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.3
	binutils-csl-morpho-4_1-4:1.5
	gdb-csl-sourcerygxx-3_4_4-17:1.3
	binutils-csl-sourcerygxx-3_4_4-17:1.5
	readline_5_1-import-branch:1.6.0.4
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.3
	binutils-2_17-branch:1.6.0.2
	binutils-2_17-branchpoint:1.6
	gdb-csl-symbian-20060226-branch:1.3.0.4
	gdb-csl-symbian-20060226-branchpoint:1.3
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.3
	msnyder-reverse-20060331-branch:1.5.0.6
	msnyder-reverse-20060331-branchpoint:1.5
	binutils-csl-2_17-branch:1.5.0.4
	binutils-csl-2_17-branchpoint:1.5
	gdb-csl-available-20060303-branch:1.5.0.2
	gdb-csl-available-20060303-branchpoint:1.5
	gdb-csl-20060226-branch:1.3.0.2
	gdb-csl-20060226-branchpoint:1.3
	gdb_6_4-20051202-release:1.2
	msnyder-fork-checkpoint-branch:1.2.0.8
	msnyder-fork-checkpoint-branchpoint:1.2
	gdb-csl-gxxpro-6_3-branch:1.2.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.2
	gdb_6_4-branch:1.2.0.4
	gdb_6_4-2005-11-01-branchpoint:1.2
	gdb-csl-arm-20051020-branch:1.2.0.2
	gdb-csl-arm-20051020-branchpoint:1.2
	binutils_latest_snapshot:1.32;
locks; strict;
comment	@ * @;


1.32
date	2013.10.09.05.23.23;	author sergiodj;	state Exp;
branches;
next	1.31;

1.31
date	2013.03.30.10.14.14;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.29;

1.29
date	2012.07.13.14.22.46;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2012.07.02.03.02.44;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2012.06.29.14.45.59;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2012.05.07.03.27.50;	author macro;	state Exp;
branches;
next	1.25;

1.25
date	2012.04.24.05.12.34;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2011.06.13.00.59.10;	author amodra;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.04.03.42.45;	author dj;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.14.03.44.21;	author dj;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.12.19.49.48;	author dj;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.25.21.06.11;	author dj;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.28.08.43.45;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2007.01.26.00.00.47;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2006.09.28.13.27.33;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.02.01.41.20;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.07.01.08.34;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.03.03.13.49;	author dj;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2006.03.02.09.38.57;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2006.02.24.22.10.35;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.26.03.21.50;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.14.22.51.55;	author jimb;	state Exp;
branches;
next	;

1.24.2.1
date	2012.05.11.12.24.24;	author nickc;	state Exp;
branches;
next	;

1.5.4.1
date	2006.08.22.15.08.28;	author jsm28;	state Exp;
branches;
next	;


desc
@@


1.32
log
@bfd/ChangeLog
2013-10-09  Sergio Durigan Junior  <sergiodj@@redhat.com>

	PR binutils/15993
	* elf32-m32c.c (dump_symtab): Add missing "break;" statement on each
	"case".  Reindent "switch" statements.
@
text
@/* M16C/M32C specific support for 32-bit ELF.
   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/m32c.h"
#include "libiberty.h"

/* Forward declarations.  */
static reloc_howto_type * m32c_reloc_type_lookup
  (bfd *, bfd_reloc_code_real_type);
static void m32c_info_to_howto_rela
  (bfd *, arelent *, Elf_Internal_Rela *);
static bfd_boolean m32c_elf_relocate_section
  (bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *, Elf_Internal_Rela *, Elf_Internal_Sym *, asection **);
static bfd_boolean m32c_elf_check_relocs
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
static bfd_boolean m32c_elf_relax_delete_bytes (bfd *, asection *, bfd_vma, int);
#ifdef DEBUG
char * m32c_get_reloc (long reloc);
void dump_symtab (bfd *, void *, void *);
#endif
static bfd_boolean m32c_elf_relax_section
(bfd *abfd, asection *sec, struct bfd_link_info *link_info, bfd_boolean *again);


static reloc_howto_type m32c_elf_howto_table [] =
{
  /* This reloc does nothing.  */
  HOWTO (R_M32C_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GCC intentionally overflows these next two in order to work
     around limitations in the addressing modes, so don't complain
     about overflow.  */
  HOWTO (R_M32C_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32C_24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_24",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32C_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_M32C_8_PCREL,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_8_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,     		/* src_mask */
	 0xff,   		/* dst_mask */
	 TRUE), 		/* pcrel_offset */

  HOWTO (R_M32C_16_PCREL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_16_PCREL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,     		/* src_mask */
	 0xffff,             	/* dst_mask */
	 TRUE), 		/* pcrel_offset */

  HOWTO (R_M32C_8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_unsigned, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,     		/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE), 		/* pcrel_offset */

  HOWTO (R_M32C_LO16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_LO16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,     		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE), 		/* pcrel_offset */

  HOWTO (R_M32C_HI8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_HI8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,     		/* src_mask */
	 0xff,			/* dst_mask */
	 FALSE), 		/* pcrel_offset */

  HOWTO (R_M32C_HI16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_HI16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,     		/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE), 		/* pcrel_offset */

  HOWTO (R_M32C_RL_JUMP,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_RL_JUMP",	/* name */
	 FALSE,			/* partial_inplace */
	 0,     		/* src_mask */
	 0,   			/* dst_mask */
	 FALSE), 		/* pcrel_offset */

  HOWTO (R_M32C_RL_1ADDR,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_RL_1ADDR",	/* name */
	 FALSE,			/* partial_inplace */
	 0,     		/* src_mask */
	 0,   			/* dst_mask */
	 FALSE), 		/* pcrel_offset */

  HOWTO (R_M32C_RL_2ADDR,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_M32C_RL_2ADDR",	/* name */
	 FALSE,			/* partial_inplace */
	 0,     		/* src_mask */
	 0,   			/* dst_mask */
	 FALSE), 		/* pcrel_offset */

};

/* Map BFD reloc types to M32C ELF reloc types.  */

struct m32c_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned int m32c_reloc_val;
};

static const struct m32c_reloc_map m32c_reloc_map [] =
{
  { BFD_RELOC_NONE,		R_M32C_NONE },
  { BFD_RELOC_16,		R_M32C_16 },
  { BFD_RELOC_24,               R_M32C_24 },
  { BFD_RELOC_32,		R_M32C_32 },
  { BFD_RELOC_8_PCREL,          R_M32C_8_PCREL },
  { BFD_RELOC_16_PCREL,         R_M32C_16_PCREL },
  { BFD_RELOC_8,		R_M32C_8 },
  { BFD_RELOC_LO16,		R_M32C_LO16 },
  { BFD_RELOC_HI16,		R_M32C_HI16 },
  { BFD_RELOC_M32C_HI8,		R_M32C_HI8 },
  { BFD_RELOC_M32C_RL_JUMP,	R_M32C_RL_JUMP },
  { BFD_RELOC_M32C_RL_1ADDR,	R_M32C_RL_1ADDR },
  { BFD_RELOC_M32C_RL_2ADDR,	R_M32C_RL_2ADDR }
};

static reloc_howto_type *
m32c_reloc_type_lookup
    (bfd *                    abfd ATTRIBUTE_UNUSED,
     bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = ARRAY_SIZE (m32c_reloc_map); --i;)
    if (m32c_reloc_map [i].bfd_reloc_val == code)
      return & m32c_elf_howto_table [m32c_reloc_map[i].m32c_reloc_val];

  return NULL;
}

static reloc_howto_type *
m32c_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED, const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (m32c_elf_howto_table) / sizeof (m32c_elf_howto_table[0]);
       i++)
    if (m32c_elf_howto_table[i].name != NULL
	&& strcasecmp (m32c_elf_howto_table[i].name, r_name) == 0)
      return &m32c_elf_howto_table[i];

  return NULL;
}

/* Set the howto pointer for an M32C ELF reloc.  */

static void
m32c_info_to_howto_rela
    (bfd *               abfd ATTRIBUTE_UNUSED,
     arelent *           cache_ptr,
     Elf_Internal_Rela * dst)
{
  unsigned int r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  BFD_ASSERT (r_type < (unsigned int) R_M32C_max);
  cache_ptr->howto = & m32c_elf_howto_table [r_type];
}



/* Relocate an M32C ELF section.
   There is some attempt to make this function usable for many architectures,
   both USE_REL and USE_RELA ['twould be nice if such a critter existed],
   if only to serve as a learning tool.

   The RELOCATE_SECTION function is called by the new ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjusting the section contents as
   necessary, and (if using Rela relocs and generating a relocatable
   output file) adjusting the reloc addend as necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */

static bfd_boolean
m32c_elf_relocate_section
    (bfd *                   output_bfd ATTRIBUTE_UNUSED,
     struct bfd_link_info *  info,
     bfd *                   input_bfd,
     asection *              input_section,
     bfd_byte *              contents,
     Elf_Internal_Rela *     relocs,
     Elf_Internal_Sym *      local_syms,
     asection **             local_sections)
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  Elf_Internal_Rela *           rel;
  Elf_Internal_Rela *           relend;
  bfd *dynobj;
  asection *splt;

  symtab_hdr = & elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  relend     = relocs + input_section->reloc_count;

  dynobj = elf_hash_table (info)->dynobj;
  splt = NULL;
  if (dynobj != NULL)
    splt = bfd_get_linker_section (dynobj, ".plt");

  for (rel = relocs; rel < relend; rel ++)
    {
      reloc_howto_type *           howto;
      unsigned long                r_symndx;
      Elf_Internal_Sym *           sym;
      asection *                   sec;
      struct elf_link_hash_entry * h;
      bfd_vma                      relocation;
      bfd_reloc_status_type        r;
      const char *                 name = NULL;
      int                          r_type;

      r_type = ELF32_R_TYPE (rel->r_info);

      /* These are only used for relaxing; we don't actually relocate
	 anything with them, so skip them.  */
      if (r_type == R_M32C_RL_JUMP
	  || r_type == R_M32C_RL_1ADDR
	  || r_type == R_M32C_RL_2ADDR)
	continue;

      r_symndx = ELF32_R_SYM (rel->r_info);

      howto  = m32c_elf_howto_table + ELF32_R_TYPE (rel->r_info);
      h      = NULL;
      sym    = NULL;
      sec    = NULL;
      relocation = 0;

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections [r_symndx];
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);

	  name = bfd_elf_string_from_elf_section
	    (input_bfd, symtab_hdr->sh_link, sym->st_name);
	  name = (sym->st_name == 0) ? bfd_section_name (input_bfd, sec) : name;
	}
      else
	{
	  h = sym_hashes [r_symndx - symtab_hdr->sh_info];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  name = h->root.root.string;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      relocation = (h->root.u.def.value
			    + sec->output_section->vma
			    + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    ;
	  else if (!info->relocatable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset, TRUE)))
		return FALSE;
	    }
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	{
	  /* This is a relocatable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (sym != NULL && ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    rel->r_addend += sec->output_offset;
	  continue;
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_M32C_16:
	  {
	    bfd_vma *plt_offset;

	    if (h != NULL)
	      plt_offset = &h->plt.offset;
	    else
	      plt_offset = elf_local_got_offsets (input_bfd) + r_symndx;

	    /*	    printf("%s: rel %x plt %d\n", h ? h->root.root.string : "(none)",
		    relocation, *plt_offset);*/
	    if (relocation <= 0xffff)
	      {
	        /* If the symbol is in range for a 16-bit address, we should
		   have deallocated the plt entry in relax_section.  */
	        BFD_ASSERT (*plt_offset == (bfd_vma) -1);
	      }
	    else
	      {
		/* If the symbol is out of range for a 16-bit address,
		   we must have allocated a plt entry.  */
		BFD_ASSERT (*plt_offset != (bfd_vma) -1);

		/* If this is the first time we've processed this symbol,
		   fill in the plt entry with the correct symbol address.  */
		if ((*plt_offset & 1) == 0)
		  {
		    unsigned int x;

		    x = 0x000000fc;  /* jmpf */
		    x |= (relocation << 8) & 0xffffff00;
		    bfd_put_32 (input_bfd, x, splt->contents + *plt_offset);
		    *plt_offset |= 1;
		  }

		relocation = (splt->output_section->vma
			      + splt->output_offset
			      + (*plt_offset & -2));
		if (name)
		{
		  char *newname = bfd_malloc (strlen(name)+5);
		  strcpy (newname, name);
		  strcat(newname, ".plt");
		  _bfd_generic_link_add_one_symbol (info,
						    input_bfd,
						    newname,
						    BSF_FUNCTION | BSF_WEAK,
						    splt,
						    (*plt_offset & -2),
						    0,
						    1,
						    0,
						    0);
		}
	      }
	  }
	  break;

	case R_M32C_HI8:
	case R_M32C_HI16:
	  relocation >>= 16;
	  break;
	}

#if 0
      printf ("relocate %s at %06lx relocation %06lx addend %ld  ",
	      m32c_elf_howto_table[ELF32_R_TYPE(rel->r_info)].name,
	      rel->r_offset + input_section->output_section->vma + input_section->output_offset,
	      relocation, rel->r_addend);
      {
	int i;
	for (i=0; i<4; i++)
	  printf (" %02x", contents[rel->r_offset+i]);
	printf ("\n");
      }
#endif
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
                                    contents, rel->r_offset, relocation,
                                    rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  const char * msg = (const char *) NULL;

	  switch (r)
	    {
	    case bfd_reloc_overflow:
	      r = info->callbacks->reloc_overflow
		(info, (h ? &h->root : NULL), name, howto->name, (bfd_vma) 0,
		 input_bfd, input_section, rel->r_offset);
	      break;

	    case bfd_reloc_undefined:
	      r = info->callbacks->undefined_symbol
		(info, name, input_bfd, input_section, rel->r_offset,
		 TRUE);
	      break;

	    case bfd_reloc_outofrange:
	      msg = _("internal error: out of range error");
	      break;

	    case bfd_reloc_notsupported:
	      msg = _("internal error: unsupported relocation error");
	      break;

	    case bfd_reloc_dangerous:
	      msg = _("internal error: dangerous relocation");
	      break;

	    default:
	      msg = _("internal error: unknown error");
	      break;
	    }

	  if (msg)
	    r = info->callbacks->warning
	      (info, msg, name, input_bfd, input_section, rel->r_offset);

	  if (! r)
	    return FALSE;
	}
    }

  return TRUE;
}

/* We support 16-bit pointers to code above 64k by generating a thunk
   below 64k containing a JMP instruction to the final address.  */

static bfd_boolean
m32c_elf_check_relocs
    (bfd *                     abfd,
     struct bfd_link_info *    info,
     asection *                sec,
     const Elf_Internal_Rela * relocs)
{
  Elf_Internal_Shdr *           symtab_hdr;
  struct elf_link_hash_entry ** sym_hashes;
  const Elf_Internal_Rela *     rel;
  const Elf_Internal_Rela *     rel_end;
  bfd_vma *local_plt_offsets;
  asection *splt;
  bfd *dynobj;

  if (info->relocatable)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_plt_offsets = elf_local_got_offsets (abfd);
  splt = NULL;
  dynobj = elf_hash_table(info)->dynobj;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      struct elf_link_hash_entry *h;
      unsigned long r_symndx;
      bfd_vma *offset;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
        h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      switch (ELF32_R_TYPE (rel->r_info))
        {
	  /* This relocation describes a 16-bit pointer to a function.
	     We may need to allocate a thunk in low memory; reserve memory
	     for it now.  */
	case R_M32C_16:
	  if (dynobj == NULL)
	    elf_hash_table (info)->dynobj = dynobj = abfd;
	  if (splt == NULL)
	    {
	      splt = bfd_get_linker_section (dynobj, ".plt");
	      if (splt == NULL)
		{
		  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY | SEC_LINKER_CREATED
				    | SEC_READONLY | SEC_CODE);
		  splt = bfd_make_section_anyway_with_flags (dynobj, ".plt",
							     flags);
		  if (splt == NULL
		      || ! bfd_set_section_alignment (dynobj, splt, 1))
		    return FALSE;
		}
	    }

	  if (h != NULL)
	    offset = &h->plt.offset;
	  else
	    {
	      if (local_plt_offsets == NULL)
		{
		  size_t size;
		  unsigned int i;

		  size = symtab_hdr->sh_info * sizeof (bfd_vma);
		  local_plt_offsets = (bfd_vma *) bfd_alloc (abfd, size);
		  if (local_plt_offsets == NULL)
		    return FALSE;
		  elf_local_got_offsets (abfd) = local_plt_offsets;

		  for (i = 0; i < symtab_hdr->sh_info; i++)
		    local_plt_offsets[i] = (bfd_vma) -1;
		}
	      offset = &local_plt_offsets[r_symndx];
	    }

	  if (*offset == (bfd_vma) -1)
	    {
	      *offset = splt->size;
	      splt->size += 4;
	    }
	  break;
        }
    }

  return TRUE;
}

/* This must exist if dynobj is ever set.  */

static bfd_boolean
m32c_elf_finish_dynamic_sections (bfd *abfd ATTRIBUTE_UNUSED,
                                  struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *splt;

  /* As an extra sanity check, verify that all plt entries have
     been filled in.  */

  if ((dynobj = elf_hash_table (info)->dynobj) != NULL
      && (splt = bfd_get_linker_section (dynobj, ".plt")) != NULL)
    {
      bfd_byte *contents = splt->contents;
      unsigned int i, size = splt->size;
      for (i = 0; i < size; i += 4)
	{
	  unsigned int x = bfd_get_32 (dynobj, contents + i);
	  BFD_ASSERT (x != 0);
	}
    }

  return TRUE;
}

static bfd_boolean
m32c_elf_always_size_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
                               struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *splt;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return TRUE;

  splt = bfd_get_linker_section (dynobj, ".plt");
  BFD_ASSERT (splt != NULL);

  splt->contents = (bfd_byte *) bfd_zalloc (dynobj, splt->size);
  if (splt->contents == NULL)
    return FALSE;

  return TRUE;
}

/* Function to set the ELF flag bits.  */

static bfd_boolean
m32c_elf_set_private_flags (bfd *abfd, flagword flags)
{
  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
m32c_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword old_flags, old_partial;
  flagword new_flags, new_partial;
  bfd_boolean error = FALSE;
  char new_opt[80];
  char old_opt[80];

  new_opt[0] = old_opt[0] = '\0';
  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;

#ifdef DEBUG
  (*_bfd_error_handler) ("old_flags = 0x%.8lx, new_flags = 0x%.8lx, init = %s, filename = %s",
			 old_flags, new_flags, elf_flags_init (obfd) ? "yes" : "no",
			 bfd_get_filename (ibfd));
#endif

  if (!elf_flags_init (obfd))
    {
      /* First call, no flags set.  */
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
    }

  else if (new_flags == old_flags)
    /* Compatible flags are ok.	 */
    ;

  else		/* Possibly incompatible flags.	 */
    {
      /* Warn if different cpu is used (allow a specific cpu to override
	 the generic cpu).  */
      new_partial = (new_flags & EF_M32C_CPU_MASK);
      old_partial = (old_flags & EF_M32C_CPU_MASK);
      if (new_partial == old_partial)
	;

      else
	{
	  switch (new_partial)
	    {
	    default:		  strcat (new_opt, " -m16c");	break;
	    case EF_M32C_CPU_M16C:	strcat (new_opt, " -m16c");  break;
	    case EF_M32C_CPU_M32C:  strcat (new_opt, " -m32c");  break;
	    }

	  switch (old_partial)
	    {
	    default:		  strcat (old_opt, " -m16c");	break;
	    case EF_M32C_CPU_M16C:	strcat (old_opt, " -m16c");  break;
	    case EF_M32C_CPU_M32C:  strcat (old_opt, " -m32c");  break;
	    }
	}

      /* Print out any mismatches from above.  */
      if (new_opt[0])
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%s: compiled with %s and linked with modules compiled with %s"),
	     bfd_get_filename (ibfd), new_opt, old_opt);
	}

      new_flags &= ~ EF_M32C_ALL_FLAGS;
      old_flags &= ~ EF_M32C_ALL_FLAGS;

      /* Warn about any other mismatches.  */
      if (new_flags != old_flags)
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
	     bfd_get_filename (ibfd), (long)new_flags, (long)old_flags);
	}
    }

  if (error)
    bfd_set_error (bfd_error_bad_value);

  return !error;
}


static bfd_boolean
m32c_elf_print_private_bfd_data (bfd *abfd, void *ptr)
{
  FILE *file = (FILE *) ptr;
  flagword flags;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  flags = elf_elfheader (abfd)->e_flags;
  fprintf (file, _("private flags = 0x%lx:"), (unsigned long) flags);

  switch (flags & EF_M32C_CPU_MASK)
    {
    default:							break;
    case EF_M32C_CPU_M16C:	fprintf (file, " -m16c");	break;
    case EF_M32C_CPU_M32C:  fprintf (file, " -m32c");	break;
    }

  fputc ('\n', file);
  return TRUE;
}

/* Return the MACH for an e_flags value.  */

static int
elf32_m32c_machine (bfd *abfd)
{
  switch (elf_elfheader (abfd)->e_flags & EF_M32C_CPU_MASK)
    {
    case EF_M32C_CPU_M16C:	return bfd_mach_m16c;
    case EF_M32C_CPU_M32C:  	return bfd_mach_m32c;
    }

  return bfd_mach_m16c;
}

static bfd_boolean
m32c_elf_object_p (bfd *abfd)
{
  bfd_default_set_arch_mach (abfd, bfd_arch_m32c,
			     elf32_m32c_machine (abfd));
  return TRUE;
}
 

#ifdef DEBUG
void
dump_symtab (bfd * abfd, void *internal_syms, void *external_syms)
{
  size_t locsymcount;
  Elf_Internal_Sym *isymbuf;
  Elf_Internal_Sym *isymend;
  Elf_Internal_Sym *isym;
  Elf_Internal_Shdr *symtab_hdr;
  bfd_boolean free_internal = 0, free_external = 0;
  char * st_info_str;
  char * st_info_stb_str;
  char * st_other_str;
  char * st_shndx_str;

  if (! internal_syms)
    {
      internal_syms = bfd_malloc (1000);
      free_internal = 1;
    }
  if (! external_syms)
    {
      external_syms = bfd_malloc (1000);
      free_external = 1;
    }

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  locsymcount = symtab_hdr->sh_size / get_elf_backend_data(abfd)->s->sizeof_sym;
  if (free_internal)
    isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
				    symtab_hdr->sh_info, 0,
				    internal_syms, external_syms, NULL);
  else
    isymbuf = internal_syms;
  isymend = isymbuf + locsymcount;

  for (isym = isymbuf ; isym < isymend ; isym++)
    {
      switch (ELF_ST_TYPE (isym->st_info))
	{
	case STT_FUNC:
	  st_info_str = "STT_FUNC";
	  break;

	case STT_SECTION:
	  st_info_str = "STT_SECTION";
	  break;

	case STT_FILE:
	  st_info_str = "STT_FILE";
	  break;

	case STT_OBJECT:
	  st_info_str = "STT_OBJECT";
	  break;

	case STT_TLS:
	  st_info_str = "STT_TLS";
	  break;

	default:
	  st_info_str = "";
	}

      switch (ELF_ST_BIND (isym->st_info))
	{
	case STB_LOCAL:
	  st_info_stb_str = "STB_LOCAL";
	  break;

	case STB_GLOBAL:
	  st_info_stb_str = "STB_GLOBAL";
	  break;

	default:
	  st_info_stb_str = "";
	}

      switch (ELF_ST_VISIBILITY (isym->st_other))
	{
	case STV_DEFAULT:
	  st_other_str = "STV_DEFAULT";
	  break;

	case STV_INTERNAL:
	  st_other_str = "STV_INTERNAL";
	  break;

	case STV_PROTECTED:
	  st_other_str = "STV_PROTECTED";
	  break;

	default:
	  st_other_str = "";
	}

      switch (isym->st_shndx)
	{
	case SHN_ABS:
	  st_shndx_str = "SHN_ABS";
	  break;

	case SHN_COMMON:
	  st_shndx_str = "SHN_COMMON";
	  break;

	case SHN_UNDEF:
	  st_shndx_str = "SHN_UNDEF";
	  break;

	default:
	  st_shndx_str = "";
	}

      printf ("isym = %p st_value = %lx st_size = %lx st_name = (%lu) %s "
	      "st_info = (%d) %s %s st_other = (%d) %s st_shndx = (%d) %s\n",
	      isym,
	      (unsigned long) isym->st_value,
	      (unsigned long) isym->st_size,
	      isym->st_name,
	      bfd_elf_string_from_elf_section (abfd, symtab_hdr->sh_link,
					       isym->st_name),
	      isym->st_info, st_info_str, st_info_stb_str,
	      isym->st_other, st_other_str,
	      isym->st_shndx, st_shndx_str);
    }
  if (free_internal)
    free (internal_syms);
  if (free_external)
    free (external_syms);
}

char *
m32c_get_reloc (long reloc)
{
  if (0 <= reloc && reloc < R_M32C_max)
    return m32c_elf_howto_table[reloc].name;
  else
    return "";
}
#endif /* DEBUG */

/* Handle relaxing.  */

/* A subroutine of m32c_elf_relax_section.  If the global symbol H
   is within the low 64k, remove any entry for it in the plt.  */

struct relax_plt_data
{
  asection *splt;
  bfd_boolean *again;
};

static bfd_boolean
m32c_relax_plt_check (struct elf_link_hash_entry *h, void * xdata)
{
  struct relax_plt_data *data = (struct relax_plt_data *) xdata;

  if (h->plt.offset != (bfd_vma) -1)
    {
      bfd_vma address;

      if (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	address = 0;
      else
	address = (h->root.u.def.section->output_section->vma
		   + h->root.u.def.section->output_offset
		   + h->root.u.def.value);

      if (address <= 0xffff)
	{
	  h->plt.offset = -1;
	  data->splt->size -= 4;
	  *data->again = TRUE;
	}
    }

  return TRUE;
}

/* A subroutine of m32c_elf_relax_section.  If the global symbol H
   previously had a plt entry, give it a new entry offset.  */

static bfd_boolean
m32c_relax_plt_realloc (struct elf_link_hash_entry *h, void * xdata)
{
  bfd_vma *entry = (bfd_vma *) xdata;

  if (h->plt.offset != (bfd_vma) -1)
    {
      h->plt.offset = *entry;
      *entry += 4;
    }

  return TRUE;
}

static bfd_boolean
m32c_elf_relax_plt_section (asection *splt,
                            struct bfd_link_info *info,
                            bfd_boolean *again)
{
  struct relax_plt_data relax_plt_data;
  bfd *ibfd;

  /* Assume nothing changes.  */
  *again = FALSE;

  if (info->relocatable)
    return TRUE;

  /* Quick check for an empty plt.  */
  if (splt->size == 0)
    return TRUE;

  /* Map across all global symbols; see which ones happen to
     fall in the low 64k.  */
  relax_plt_data.splt = splt;
  relax_plt_data.again = again;
  elf_link_hash_traverse (elf_hash_table (info), m32c_relax_plt_check,
			  &relax_plt_data);

  /* Likewise for local symbols, though that's somewhat less convenient
     as we have to walk the list of input bfds and swap in symbol data.  */
  for (ibfd = info->input_bfds; ibfd ; ibfd = ibfd->link_next)
    {
      bfd_vma *local_plt_offsets = elf_local_got_offsets (ibfd);
      Elf_Internal_Shdr *symtab_hdr;
      Elf_Internal_Sym *isymbuf = NULL;
      unsigned int idx;

      if (! local_plt_offsets)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      if (symtab_hdr->sh_info != 0)
	{
	  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	  if (isymbuf == NULL)
	    isymbuf = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
					    symtab_hdr->sh_info, 0,
					    NULL, NULL, NULL);
	  if (isymbuf == NULL)
	    return FALSE;
	}

      for (idx = 0; idx < symtab_hdr->sh_info; ++idx)
	{
	  Elf_Internal_Sym *isym;
	  asection *tsec;
	  bfd_vma address;

	  if (local_plt_offsets[idx] == (bfd_vma) -1)
	    continue;

	  isym = &isymbuf[idx];
	  if (isym->st_shndx == SHN_UNDEF)
	    continue;
	  else if (isym->st_shndx == SHN_ABS)
	    tsec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    tsec = bfd_com_section_ptr;
	  else
	    tsec = bfd_section_from_elf_index (ibfd, isym->st_shndx);

	  address = (tsec->output_section->vma
		     + tsec->output_offset
		     + isym->st_value);
	  if (address <= 0xffff)
	    {
	      local_plt_offsets[idx] = -1;
	      splt->size -= 4;
	      *again = TRUE;
	    }
	}

      if (isymbuf != NULL
	  && symtab_hdr->contents != (unsigned char *) isymbuf)
	{
	  if (! info->keep_memory)
	    free (isymbuf);
	  else
	    {
	      /* Cache the symbols for elf_link_input_bfd.  */
	      symtab_hdr->contents = (unsigned char *) isymbuf;
	    }
	}
    }

  /* If we changed anything, walk the symbols again to reallocate
     .plt entry addresses.  */
  if (*again && splt->size > 0)
    {
      bfd_vma entry = 0;

      elf_link_hash_traverse (elf_hash_table (info),
			      m32c_relax_plt_realloc, &entry);

      for (ibfd = info->input_bfds; ibfd ; ibfd = ibfd->link_next)
	{
	  bfd_vma *local_plt_offsets = elf_local_got_offsets (ibfd);
	  unsigned int nlocals = elf_tdata (ibfd)->symtab_hdr.sh_info;
	  unsigned int idx;

	  if (! local_plt_offsets)
	    continue;

	  for (idx = 0; idx < nlocals; ++idx)
	    if (local_plt_offsets[idx] != (bfd_vma) -1)
	      {
	        local_plt_offsets[idx] = entry;
		entry += 4;
	      }
	}
    }

  return TRUE;
}

static int
compare_reloc (const void *e1, const void *e2)
{
  const Elf_Internal_Rela *i1 = (const Elf_Internal_Rela *) e1;
  const Elf_Internal_Rela *i2 = (const Elf_Internal_Rela *) e2;

  if (i1->r_offset == i2->r_offset)
    return 0;
  else
    return i1->r_offset < i2->r_offset ? -1 : 1;
}

#define OFFSET_FOR_RELOC(rel) m32c_offset_for_reloc (abfd, rel, symtab_hdr, shndx_buf, intsyms)
static bfd_vma
m32c_offset_for_reloc (bfd *abfd,
		       Elf_Internal_Rela *rel,
		       Elf_Internal_Shdr *symtab_hdr,
		       Elf_External_Sym_Shndx *shndx_buf ATTRIBUTE_UNUSED,
		       Elf_Internal_Sym *intsyms)
{
  bfd_vma symval;

  /* Get the value of the symbol referred to by the reloc.  */
  if (ELF32_R_SYM (rel->r_info) < symtab_hdr->sh_info)
    {
      /* A local symbol.  */
      Elf_Internal_Sym *isym;
      asection *ssec;

      isym = intsyms + ELF32_R_SYM (rel->r_info);
      ssec = bfd_section_from_elf_index (abfd, isym->st_shndx);
      symval = isym->st_value;
      if (ssec)
	symval += ssec->output_section->vma
	  + ssec->output_offset;
    }
  else
    {
      unsigned long indx;
      struct elf_link_hash_entry *h;

      /* An external symbol.  */
      indx = ELF32_R_SYM (rel->r_info) - symtab_hdr->sh_info;
      h = elf_sym_hashes (abfd)[indx];
      BFD_ASSERT (h != NULL);

      if (h->root.type != bfd_link_hash_defined
	  && h->root.type != bfd_link_hash_defweak)
	/* This appears to be a reference to an undefined
	   symbol.  Just ignore it--it will be caught by the
	   regular reloc processing.  */
	return 0;

      symval = (h->root.u.def.value
		+ h->root.u.def.section->output_section->vma
		+ h->root.u.def.section->output_offset);
    }
  return symval;
}

static int bytes_saved = 0;

static int bytes_to_reloc[] = {
  R_M32C_NONE,
  R_M32C_8,
  R_M32C_16,
  R_M32C_24,
  R_M32C_32
};

/* What we use the bits in a relax reloc addend (R_M32C_RL_*) for.  */

/* Mask for the number of relocs associated with this insn.  */
#define RLA_RELOCS		0x0000000f
/* Number of bytes gas emitted (before gas's relaxing) */
#define RLA_NBYTES		0x00000ff0

/* If the displacement is within the given range and the new encoding
   differs from the old encoding (the index), then the insn can be
   relaxed to the new encoding.  */
typedef struct {
  int bytes;
  unsigned int max_disp;
  unsigned char new_encoding;
} EncodingTable;

static EncodingTable m16c_addr_encodings[] = {
  { 0,   0,  0 }, /* R0 */
  { 0,   0,  1 }, /* R1 */
  { 0,   0,  2 }, /* R2 */
  { 0,   0,  3 }, /* R3 */
  { 0,   0,  4 }, /* A0 */
  { 0,   0,  5 }, /* A1 */
  { 0,   0,  6 }, /* [A0] */
  { 0,   0,  7 }, /* [A1] */
  { 1,   0,  6 }, /* udsp:8[A0] */
  { 1,   0,  7 }, /* udsp:8[A1] */
  { 1,   0, 10 }, /* udsp:8[SB] */
  { 1,   0, 11 }, /* sdsp:8[FB] */
  { 2, 255,  8 }, /* udsp:16[A0] */
  { 2, 255,  9 }, /* udsp:16[A1] */
  { 2, 255, 10 }, /* udsp:16[SB] */
  { 2,   0, 15 }, /* abs:16 */
};

static EncodingTable m16c_jmpaddr_encodings[] = {
  { 0,   0,  0 }, /* R0 */
  { 0,   0,  1 }, /* R1 */
  { 0,   0,  2 }, /* R2 */
  { 0,   0,  3 }, /* R3 */
  { 0,   0,  4 }, /* A0 */
  { 0,   0,  5 }, /* A1 */
  { 0,   0,  6 }, /* [A0] */
  { 0,   0,  7 }, /* [A1] */
  { 1,   0,  6 }, /* udsp:8[A0] */
  { 1,   0,  7 }, /* udsp:8[A1] */
  { 1,   0, 10 }, /* udsp:8[SB] */
  { 1,   0, 11 }, /* sdsp:8[FB] */
  { 3, 255,  8 }, /* udsp:20[A0] */
  { 3, 255,  9 }, /* udsp:20[A1] */
  { 2, 255, 10 }, /* udsp:16[SB] */
  { 2,   0, 15 }, /* abs:16 */
};

static EncodingTable m32c_addr_encodings[] = {
  { 0,     0,  0 }, /* [A0] */
  { 0,     0,  1 }, /* [A1] */
  { 0,     0,  2 }, /* A0 */
  { 0,     0,  3 }, /* A1 */
  { 1,     0,  0 }, /* udsp:8[A0] */
  { 1,     0,  1 }, /* udsp:8[A1] */
  { 1,     0,  6 }, /* udsp:8[SB] */
  { 1,     0,  7 }, /* sdsp:8[FB] */
  { 2,   255,  4 }, /* udsp:16[A0] */
  { 2,   255,  5 }, /* udsp:16[A1] */
  { 2,   255,  6 }, /* udsp:16[SB] */
  { 2,   127,  7 }, /* sdsp:16[FB] */
  { 3, 65535, 8 }, /* udsp:24[A0] */
  { 3, 65535, 9 }, /* udsp:24[A1] */
  { 3, 65535, 15 }, /* abs24 */
  { 2,     0, 15 }, /* abs16 */
  { 0,     0, 16 }, /* R2 */
  { 0,     0, 17 }, /* R3 */
  { 0,     0, 18 }, /* R0 */
  { 0,     0, 19 }, /* R1 */
  { 0,     0, 20 }, /*  */
  { 0,     0, 21 }, /*  */
  { 0,     0, 22 }, /*  */
  { 0,     0, 23 }, /*  */
  { 0,     0, 24 }, /*  */
  { 0,     0, 25 }, /*  */
  { 0,     0, 26 }, /*  */
  { 0,     0, 27 }, /*  */
  { 0,     0, 28 }, /*  */
  { 0,     0, 29 }, /*  */
  { 0,     0, 30 }, /*  */
  { 0,     0, 31 }, /*  */
};

static bfd_boolean
m32c_elf_relax_section
    (bfd *                  abfd,
     asection *             sec,
     struct bfd_link_info * link_info,
     bfd_boolean *          again)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *shndx_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *free_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend, *srel;
  bfd_byte * contents = NULL;
  bfd_byte * free_contents = NULL;
  Elf_Internal_Sym *intsyms = NULL;
  Elf_Internal_Sym *free_intsyms = NULL;
  Elf_External_Sym_Shndx *shndx_buf = NULL;
  int machine;

  if (abfd == elf_hash_table (link_info)->dynobj
      && (sec->flags & SEC_LINKER_CREATED) != 0
      && strcmp (sec->name, ".plt") == 0)
    return m32c_elf_relax_plt_section (sec, link_info, again);

  /* Assume nothing changes.  */
  *again = FALSE;

  machine = elf32_m32c_machine (abfd);

  /* We don't have to do anything for a relocatable link, if
     this section does not have relocs, or if this is not a
     code section.  */
  if (link_info->relocatable
      || (sec->flags & SEC_RELOC) == 0
      || sec->reloc_count == 0
      || (sec->flags & SEC_CODE) == 0)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  shndx_hdr = &elf_tdata (abfd)->symtab_shndx_hdr;

  /* Get the section contents.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    contents = elf_section_data (sec)->this_hdr.contents;
  /* Go get them off disk.  */
  else if (!bfd_malloc_and_get_section (abfd, sec, &contents))
    goto error_return;

  /* Read this BFD's symbols.  */
  /* Get cached copy if it exists.  */
  if (symtab_hdr->contents != NULL)
    {
      intsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
    }
  else
    {
      intsyms = bfd_elf_get_elf_syms (abfd, symtab_hdr, symtab_hdr->sh_info, 0, NULL, NULL, NULL);
      symtab_hdr->contents = (bfd_byte *) intsyms;
    }

  if (shndx_hdr->sh_size != 0)
    {
      bfd_size_type amt;

      amt = symtab_hdr->sh_info;
      amt *= sizeof (Elf_External_Sym_Shndx);
      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
      if (shndx_buf == NULL)
	goto error_return;
      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
	  || bfd_bread (shndx_buf, amt, abfd) != amt)
	goto error_return;
      shndx_hdr->contents = (bfd_byte *) shndx_buf;
    }

  /* Get a copy of the native relocations.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    goto error_return;
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;

  /* The RL_ relocs must be just before the operand relocs they go
     with, so we must sort them to guarantee this.  */
  qsort (internal_relocs, sec->reloc_count, sizeof (Elf_Internal_Rela),
         compare_reloc);

  /* Walk through them looking for relaxing opportunities.  */
  irelend = internal_relocs + sec->reloc_count;

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      bfd_vma symval;
      unsigned char *insn, *gap, *einsn;
      bfd_vma pc;
      bfd_signed_vma pcrel;
      int relax_relocs;
      int gap_size;
      int new_type;
      int posn;
      int enc;
      EncodingTable *enctbl;
      EncodingTable *e;

      if (ELF32_R_TYPE(irel->r_info) != R_M32C_RL_JUMP
	  && ELF32_R_TYPE(irel->r_info) != R_M32C_RL_1ADDR
	  && ELF32_R_TYPE(irel->r_info) != R_M32C_RL_2ADDR)
	continue;

      srel = irel;

      /* There will always be room for the relaxed insn, since it is smaller
	 than the one it would replace.  */
      BFD_ASSERT (irel->r_offset < sec->size);

      insn = contents + irel->r_offset;
      relax_relocs = irel->r_addend % 16;

      /* Ok, we only have three relocs we care about, and they're all
	 fake.  The lower four bits of the addend is always the number
	 of following relocs (hence the qsort above) that are assigned
	 to this opcode.  The next 8 bits of the addend indicates the
	 number of bytes in the insn.  We use the rest of them
	 ourselves as flags for the more expensive operations (defines
	 above).  The three relocs are:

	 RL_JUMP: This marks all direct jump insns.  We check the
		displacement and replace them with shorter jumps if
		they're in range.  We also use this to find JMP.S
		insns and manually shorten them when we delete bytes.
		We have to decode these insns to figure out what to
		do.

	 RL_1ADDR: This is a :G or :Q insn, which has a single
		"standard" operand.  We have to extract the type
		field, see if it's a wide displacement, then figure
		out if we can replace it with a narrow displacement.
		We don't have to decode these insns.

	 RL_2ADDR: Similarly, but two "standard" operands.  Note that
		r_addend may still be 1, as standard operands don't
		always have displacements.  Gas shouldn't give us one
		with zero operands, but since we don't know which one
		has the displacement, we check them both anyway.

	 These all point to the beginning of the insn itself, not the
	 operands.

	 Note that we only relax one step at a time, relying on the
	 linker to call us repeatedly.  Thus, there is no code for
	 JMP.A->JMP.B although that will happen in two steps.
	 Likewise, for 2ADDR relaxes, we do one operand per cycle.
      */

      /* Get the value of the symbol referred to by the reloc.  Just
         in case this is the last reloc in the list, use the RL's
         addend to choose between this reloc (no addend) or the next
         (yes addend, which means at least one following reloc).  */
      srel = irel + (relax_relocs ? 1 : 0);
      symval = OFFSET_FOR_RELOC (srel);

      /* Setting gap_size nonzero is the flag which means "something
	 shrunk".  */
      gap_size = 0;
      gap = NULL;
      new_type = ELF32_R_TYPE(srel->r_info);

      pc = sec->output_section->vma + sec->output_offset
	+ srel->r_offset;
      pcrel = symval - pc + srel->r_addend;

      if (machine == bfd_mach_m16c)
	{
	  /* R8C / M16C */

	  switch (ELF32_R_TYPE(irel->r_info))
	    {

	    case R_M32C_RL_JUMP:
	      switch (insn[0])
		{
		case 0xfe: /* jmp.b */
		  if (pcrel >= 2 && pcrel <= 9)
		    {
		      /* Relax JMP.B -> JMP.S.  We need to get rid of
			 the following reloc though. */
		      insn[0] = 0x60 | (pcrel - 2);
		      new_type = R_M32C_NONE;
		      irel->r_addend = 0x10;
		      gap_size = 1;
		      gap = insn + 1;
		    }
		  break;

		case 0xf4: /* jmp.w */
		  /* 128 is allowed because it will be one byte closer
		     after relaxing.  Likewise for all other pc-rel
		     jumps.  */
		  if (pcrel <= 128 && pcrel >= -128)
		    {
		      /* Relax JMP.W -> JMP.B */
		      insn[0] = 0xfe;
		      insn[1] = 0;
		      new_type = R_M32C_8_PCREL;
		      gap_size = 1;
		      gap = insn + 2;
		    }
		  break;

		case 0xfc: /* jmp.a */
		  if (pcrel <= 32768 && pcrel >= -32768)
		    {
		      /* Relax JMP.A -> JMP.W */
		      insn[0] = 0xf4;
		      insn[1] = 0;
		      insn[2] = 0;
		      new_type = R_M32C_16_PCREL;
		      gap_size = 1;
		      gap = insn + 3;
		    }
		  break;

		case 0xfd: /* jsr.a */
		  if (pcrel <= 32768 && pcrel >= -32768)
		    {
		      /* Relax JSR.A -> JSR.W */
		      insn[0] = 0xf5;
		      insn[1] = 0;
		      insn[2] = 0;
		      new_type = R_M32C_16_PCREL;
		      gap_size = 1;
		      gap = insn + 3;
		    }
		  break;
		}
	      break;

	    case R_M32C_RL_2ADDR:
	      /* xxxx xxxx srce dest [src-disp] [dest-disp]*/

	      enctbl = m16c_addr_encodings;
	      posn = 2;
	      enc = (insn[1] >> 4) & 0x0f;
	      e = & enctbl[enc];

	      if (srel->r_offset == irel->r_offset + posn
		  && e->new_encoding != enc
		  && symval <= e->max_disp)
		{
		  insn[1] &= 0x0f;
		  insn[1] |= e->new_encoding << 4;
		  gap_size = e->bytes - enctbl[e->new_encoding].bytes;
		  gap = insn + posn + enctbl[e->new_encoding].bytes;
		  new_type = bytes_to_reloc[enctbl[e->new_encoding].bytes];
		  break;
		}
	      if (relax_relocs == 2)
		srel ++;
	      posn += e->bytes;

	      goto try_1addr_16;

	    case R_M32C_RL_1ADDR:
	      /* xxxx xxxx xxxx dest [disp] */

	      enctbl = m16c_addr_encodings;
	      posn = 2;

	      /* Check the opcode for jumps.  We know it's safe to
		 do this because all 2ADDR insns are at least two
		 bytes long.  */
	      enc = insn[0] * 256 + insn[1];
	      enc &= 0xfff0;
	      if (enc == 0x7d20
		  || enc == 0x7d00
		  || enc == 0x7d30
		  || enc == 0x7d10)
		{
		  enctbl = m16c_jmpaddr_encodings;
		}

	    try_1addr_16:
	      /* srel, posn, and enc must be set here.  */

	      symval = OFFSET_FOR_RELOC (srel);
	      enc = insn[1] & 0x0f;
	      e = & enctbl[enc];

	      if (srel->r_offset == irel->r_offset + posn
		  && e->new_encoding != enc
		  && symval <= e->max_disp)
		{
		  insn[1] &= 0xf0;
		  insn[1] |= e->new_encoding;
		  gap_size = e->bytes - enctbl[e->new_encoding].bytes;
		  gap = insn + posn + enctbl[e->new_encoding].bytes;
		  new_type = bytes_to_reloc[enctbl[e->new_encoding].bytes];
		  break;
		}

	      break;

	    } /* Ends switch (reloc type) for m16c.  */
	}
      else /* machine == bfd_mach_m32c */
	{
	  /* M32CM / M32C */

	  switch (ELF32_R_TYPE(irel->r_info))
	    {

	    case R_M32C_RL_JUMP:
	      switch (insn[0])
		{
		case 0xbb: /* jmp.b */
		  if (pcrel >= 2 && pcrel <= 9)
		    {
		      int p = pcrel - 2;
		      /* Relax JMP.B -> JMP.S.  We need to get rid of
			 the following reloc though. */
		      insn[0] = 0x4a | ((p << 3) & 0x30) | (p & 1);
		      new_type = R_M32C_NONE;
		      irel->r_addend = 0x10;
		      gap_size = 1;
		      gap = insn + 1;
		    }
		  break;

		case 0xce: /* jmp.w */
		  if (pcrel <= 128 && pcrel >= -128)
		    {
		      /* Relax JMP.W -> JMP.B */
		      insn[0] = 0xbb;
		      insn[1] = 0;
		      new_type = R_M32C_8_PCREL;
		      gap_size = 1;
		      gap = insn + 2;
		    }
		  break;

		case 0xcc: /* jmp.a */
		  if (pcrel <= 32768 && pcrel >= -32768)
		    {
		      /* Relax JMP.A -> JMP.W */
		      insn[0] = 0xce;
		      insn[1] = 0;
		      insn[2] = 0;
		      new_type = R_M32C_16_PCREL;
		      gap_size = 1;
		      gap = insn + 3;
		    }
		  break;

		case 0xcd: /* jsr.a */
		  if (pcrel <= 32768 && pcrel >= -32768)
		    {
		      /* Relax JSR.A -> JSR.W */
		      insn[0] = 0xcf;
		      insn[1] = 0;
		      insn[2] = 0;
		      new_type = R_M32C_16_PCREL;
		      gap_size = 1;
		      gap = insn + 3;
		    }
		  break;
		}
	      break;

	    case R_M32C_RL_2ADDR:
	      /* xSSS DDDx DDSS xxxx [src-disp] [dest-disp]*/

	      einsn = insn;
	      posn = 2;
	      if (einsn[0] == 1)
		{
		  /* prefix; remove it as far as the RL reloc is concerned.  */
		  einsn ++;
		  posn ++;
		}

	      enctbl = m32c_addr_encodings;
	      enc = ((einsn[0] & 0x70) >> 2) | ((einsn[1] & 0x30) >> 4);
	      e = & enctbl[enc];

	      if (srel->r_offset == irel->r_offset + posn
		  && e->new_encoding != enc
		  && symval <= e->max_disp)
		{
		  einsn[0] &= 0x8f;
		  einsn[0] |= (e->new_encoding & 0x1c) << 2;
		  einsn[1] &= 0xcf;
		  einsn[1] |= (e->new_encoding & 0x03) << 4;
		  gap_size = e->bytes - enctbl[e->new_encoding].bytes;
		  gap = insn + posn + enctbl[e->new_encoding].bytes;
		  new_type = bytes_to_reloc[enctbl[e->new_encoding].bytes];
		  break;
		}
	      if (relax_relocs == 2)
		  srel ++;
	      posn += e->bytes;

	      goto try_1addr_32;

	    case R_M32C_RL_1ADDR:
	      /* xxxx DDDx DDxx xxxx [disp] */

	      einsn = insn;
	      posn = 2;
	      if (einsn[0] == 1)
		{
		  /* prefix; remove it as far as the RL reloc is concerned.  */
		  einsn ++;
		  posn ++;
		}

	      enctbl = m32c_addr_encodings;

	    try_1addr_32:
	      /* srel, posn, and enc must be set here.  */

	      symval = OFFSET_FOR_RELOC (srel);
	      enc = ((einsn[0] & 0x0e) << 1) |  ((einsn[1] & 0xc0) >> 6);
	      e = & enctbl[enc];

	      if (srel->r_offset == irel->r_offset + posn
		  && e->new_encoding != enc
		  && symval <= e->max_disp)
		{
		  einsn[0] &= 0xf1;
		  einsn[0] |= (e->new_encoding & 0x1c) >> 1;
		  einsn[1] &= 0x3f;
		  einsn[1] |= (e->new_encoding & 0x03) << 6;
		  gap_size = e->bytes - enctbl[e->new_encoding].bytes;
		  gap = insn + posn + enctbl[e->new_encoding].bytes;
		  new_type = bytes_to_reloc[enctbl[e->new_encoding].bytes];
		  break;
		}

	      break;

	    } /* Ends switch (reloc type) for m32c.  */
	}

      if (gap_size == 0)
	continue;

      *again = TRUE;

      srel->r_info = ELF32_R_INFO (ELF32_R_SYM (srel->r_info), new_type);

      /* Note that we've changed the relocs, section contents, etc.  */
      elf_section_data (sec)->relocs = internal_relocs;
      free_relocs = NULL;

      elf_section_data (sec)->this_hdr.contents = contents;
      free_contents = NULL;

      symtab_hdr->contents = (bfd_byte *) intsyms;
      free_intsyms = NULL;

      bytes_saved += gap_size;

      if (! m32c_elf_relax_delete_bytes(abfd, sec, gap - contents, gap_size))
	goto error_return;

    } /* next relocation */

  if (free_relocs != NULL)
    {
      free (free_relocs);
      free_relocs = NULL;
    }

  if (free_contents != NULL)
    {
      if (! link_info->keep_memory)
	free (free_contents);
      /* Cache the section contents for elf_link_input_bfd.  */
      else
	elf_section_data (sec)->this_hdr.contents = contents;

      free_contents = NULL;
    }

  if (shndx_buf != NULL)
    {
      shndx_hdr->contents = NULL;
      free (shndx_buf);
    }

  if (free_intsyms != NULL)
    {
      if (! link_info->keep_memory)
	free (free_intsyms);
      /* Cache the symbols for elf_link_input_bfd.  */
      else
	{
	symtab_hdr->contents = NULL /* (unsigned char *) intsyms*/;
	}

      free_intsyms = NULL;
    }

  return TRUE;

 error_return:
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
  if (shndx_buf != NULL)
    {
      shndx_hdr->contents = NULL;
      free (shndx_buf);
    }
  if (free_intsyms != NULL)
    free (free_intsyms);
  return FALSE;
}

/* Delete some bytes from a section while relaxing.  */

static bfd_boolean
m32c_elf_relax_delete_bytes
 (bfd *      abfd,
  asection * sec,
  bfd_vma    addr,
  int        count)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Shdr *shndx_hdr;
  int sec_shndx;
  bfd_byte *contents;
  Elf_Internal_Rela *irel;
  Elf_Internal_Rela *irelend;
  bfd_vma toaddr;
  Elf_Internal_Sym *isym;
  Elf_Internal_Sym *isymend;
  Elf_Internal_Sym *intsyms;
  Elf_External_Sym_Shndx *shndx_buf;
  Elf_External_Sym_Shndx *shndx;
  struct elf_link_hash_entry ** sym_hashes;
  struct elf_link_hash_entry ** end_hashes;
  unsigned int                  symcount;

  contents   = elf_section_data (sec)->this_hdr.contents;

  toaddr = sec->size;

  irel = elf_section_data (sec)->relocs;
  irelend = irel + sec->reloc_count;

  /* Actually delete the bytes.  */
  memmove (contents + addr, contents + addr + count, (size_t) (toaddr - addr - count));
  sec->size -= count;

  /* Adjust all the relocs.  */
  for (irel = elf_section_data (sec)->relocs; irel < irelend; irel ++)
    {
      /* Get the new reloc address.  */
      if (irel->r_offset > addr && irel->r_offset < toaddr)
	irel->r_offset -= count;

      if (ELF32_R_TYPE(irel->r_info) == R_M32C_RL_JUMP
	  && irel->r_addend == 0x10 /* one byte insn, no relocs */
	  && irel->r_offset + 1 < addr
	  && irel->r_offset + 7 > addr)
	{
	  bfd_vma disp;
	  unsigned char *insn = &contents[irel->r_offset];
	  disp = *insn;
	  /* This is a JMP.S, which we have to manually update. */
	  if (elf32_m32c_machine (abfd) == bfd_mach_m16c)
	    {
	      if ((*insn & 0xf8) != 0x60)
		continue;
	      disp = (disp & 7);
	    }
	  else
	    {
	      if ((*insn & 0xce) != 0x4a)
		continue;
	      disp = ((disp & 0x30) >> 3) | (disp & 1);
	    }
	  if (irel->r_offset + disp + 2 >= addr+count)
	    {
	      disp -= count;
	      if (elf32_m32c_machine (abfd) == bfd_mach_m16c)
		{
		  *insn = (*insn & 0xf8) | disp;
		}
	      else
		{
		  *insn = (*insn & 0xce) | ((disp & 6) << 3) | (disp & 1);
		}
	    }
	}
    }

  /* Adjust the local symbols defined in this section.  */
  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
  intsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
  isym = intsyms;
  isymend = isym + symtab_hdr->sh_info;

  sec_shndx  = _bfd_elf_section_from_bfd_section (abfd, sec);
  shndx_hdr  = & elf_tdata (abfd)->symtab_shndx_hdr;
  shndx_buf  = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
  shndx = shndx_buf;

  for (; isym < isymend; isym++, shndx = (shndx ? shndx + 1 : NULL))
    {
      /* If the symbol is in the range of memory we just moved, we
	 have to adjust its value.  */
      if ((int) isym->st_shndx == sec_shndx
	  && isym->st_value > addr
	  && isym->st_value < toaddr)
	{
	  isym->st_value -= count;
	}
      /* If the symbol *spans* the bytes we just deleted (i.e. it's
	 *end* is in the moved bytes but it's *start* isn't), then we
	 must adjust its size.  */
      if ((int) isym->st_shndx == sec_shndx
	    && isym->st_value < addr
	  && isym->st_value + isym->st_size > addr
	  && isym->st_value + isym->st_size < toaddr)
	{
	  isym->st_size -= count;
	}
    }

  /* Now adjust the global symbols defined in this section.  */
  symcount = (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)
	      - symtab_hdr->sh_info);
  sym_hashes = elf_sym_hashes (abfd);
  //  sym_hashes += symtab_hdr->sh_info;
  end_hashes = sym_hashes + symcount;

  for (; sym_hashes < end_hashes; sym_hashes ++)
    {
      struct elf_link_hash_entry * sym_hash = * sym_hashes;

      if (sym_hash &&
	  (sym_hash->root.type == bfd_link_hash_defined
	   || sym_hash->root.type == bfd_link_hash_defweak)
	  && sym_hash->root.u.def.section == sec)
	{
	  if (sym_hash->root.u.def.value > addr
	      && sym_hash->root.u.def.value < toaddr)
	    {
	      sym_hash->root.u.def.value -= count;
	    }
	  if (sym_hash->root.u.def.value < addr
	      && sym_hash->root.u.def.value + sym_hash->size > addr
	      && sym_hash->root.u.def.value + sym_hash->size < toaddr)
	    {
	      sym_hash->size -= count;
	    }
	}
    }

  return TRUE;
}

/* This is for versions of gcc prior to 4.3.  */
static unsigned int
_bfd_m32c_elf_eh_frame_address_size (bfd *abfd, asection *sec ATTRIBUTE_UNUSED)
{
  if ((elf_elfheader (abfd)->e_flags & EF_M32C_CPU_MASK) == EF_M32C_CPU_M16C)
    return 2;
  return 4;
}



#define ELF_ARCH		bfd_arch_m32c
#define ELF_MACHINE_CODE	EM_M32C
#define ELF_MACHINE_ALT1	EM_M32C_OLD
#define ELF_MAXPAGESIZE		0x100

#if 0
#define TARGET_BIG_SYM		bfd_elf32_m32c_vec
#define TARGET_BIG_NAME		"elf32-m32c"
#else
#define TARGET_LITTLE_SYM		bfd_elf32_m32c_vec
#define TARGET_LITTLE_NAME		"elf32-m32c"
#endif

#define elf_info_to_howto_rel			NULL
#define elf_info_to_howto			m32c_info_to_howto_rela
#define elf_backend_object_p			m32c_elf_object_p
#define elf_backend_relocate_section		m32c_elf_relocate_section
#define elf_backend_check_relocs                m32c_elf_check_relocs
#define elf_backend_object_p			m32c_elf_object_p
#define elf_symbol_leading_char                 ('_')
#define elf_backend_always_size_sections \
  m32c_elf_always_size_sections
#define elf_backend_finish_dynamic_sections \
  m32c_elf_finish_dynamic_sections

#define elf_backend_can_gc_sections		1
#define elf_backend_eh_frame_address_size _bfd_m32c_elf_eh_frame_address_size

#define bfd_elf32_bfd_reloc_type_lookup		m32c_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup	m32c_reloc_name_lookup
#define bfd_elf32_bfd_relax_section		m32c_elf_relax_section
#define bfd_elf32_bfd_set_private_flags		m32c_elf_set_private_flags
#define bfd_elf32_bfd_merge_private_bfd_data	m32c_elf_merge_private_bfd_data
#define bfd_elf32_bfd_print_private_bfd_data	m32c_elf_print_private_bfd_data

#include "elf32-target.h"
@


1.31
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d924 22
a945 6
	case STT_FUNC: st_info_str = "STT_FUNC";
	case STT_SECTION: st_info_str = "STT_SECTION";
	case STT_FILE: st_info_str = "STT_FILE";
	case STT_OBJECT: st_info_str = "STT_OBJECT";
	case STT_TLS: st_info_str = "STT_TLS";
	default: st_info_str = "";
d947 1
d950 10
a959 3
	case STB_LOCAL: st_info_stb_str = "STB_LOCAL";
	case STB_GLOBAL: st_info_stb_str = "STB_GLOBAL";
	default: st_info_stb_str = "";
d961 1
d964 14
a977 4
	case STV_DEFAULT: st_other_str = "STV_DEFAULT";
	case STV_INTERNAL: st_other_str = "STV_INTERNAL";
	case STV_PROTECTED: st_other_str = "STV_PROTECTED";
	default: st_other_str = "";
d979 1
d982 14
a995 4
	case SHN_ABS: st_shndx_str = "SHN_ABS";
	case SHN_COMMON: st_shndx_str = "SHN_COMMON";
	case SHN_UNDEF: st_shndx_str = "SHN_UNDEF";
	default: st_shndx_str = "";
@


1.30
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d624 4
@


1.29
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d31 1
a31 1
static void m32c_info_to_howto_rela 
d33 1
a33 1
static bfd_boolean m32c_elf_relocate_section 
d271 1
a271 1
  
d378 1
a378 1
      
d387 1
a387 1
      
d403 1
a403 1
	  
d411 1
a411 1
	  
d417 1
a417 1
	  
d545 1
a545 1
	      
d551 1
a551 1
	      
d583 1
a583 1
 
d598 1
a598 1
 
d601 1
a601 1
 
d614 1
a614 1
 
d625 1
a625 1
 
d679 1
a679 1
 
d802 1
a802 1
      
d905 1
a905 1
  
d947 1
a947 1
      
d950 1
a950 1
	      isym, 
d1582 1
a1582 1
	      
d1768 1
a1768 1
      
@


1.28
log
@	* elf32-m32c.c (m32c_elf_check_relocs): Use bfd_make_section
	"anyway" variant when creating .plt.
	(m32c_elf_relax_plt_section): Remove redundant test and unused param.
	(m32c_elf_relax_section): Test SEC_LINKER_CREATED before calling
	m32c_elf_relax_plt_section.
	* elfxx-mips.c (mips_elf_create_got_section): Use make anyway variant
	when creating .got and .got.plt.
	(_bfd_mips_elf_final_link): Likewise for .rtproc, and use
	bfd_get_linker_section.
	* sunos.c: Similarly throughout.
@
text
@d833 1
a833 1
m32c_elf_print_private_bfd_data (bfd *abfd, PTR ptr)
d988 1
a988 2
m32c_relax_plt_check (struct elf_link_hash_entry *h,
                      PTR xdata)
d1019 1
a1019 2
m32c_relax_plt_realloc (struct elf_link_hash_entry *h,
                        PTR xdata)
d1383 1
a1383 1
	  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
d1390 1
a1390 1
		     (abfd, sec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
@


1.27
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d642 2
a643 1
		  splt = bfd_make_section_with_flags (dynobj, ".plt", flags);
d1035 1
a1035 2
m32c_elf_relax_plt_section (bfd *dynobj,
                            asection *splt,
a1047 5
  /* We only relax the .plt section at the moment.  */
  if (dynobj != elf_hash_table (info)->dynobj
      || strcmp (splt->name, ".plt") != 0)
    return TRUE;

d1335 1
d1337 1
a1337 1
    return m32c_elf_relax_plt_section (abfd, sec, link_info, again);
@


1.26
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d365 1
a365 1
    splt = bfd_get_section_by_name (dynobj, ".plt");
d636 1
a636 1
	      splt = bfd_get_section_by_name (dynobj, ".plt");
d695 1
a695 1
      && (splt = bfd_get_section_by_name (dynobj, ".plt")) != NULL)
d723 1
a723 1
  splt = bfd_get_section_by_name (dynobj, ".plt");
@


1.25
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d439 1
a439 1
					 rel, relend, howto, contents);
@


1.24
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d2 1
a2 1
   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011
d437 1
a437 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.24.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d437 1
a437 1
      if (sec != NULL && discarded_section (sec))
@


1.23
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d2 1
a2 1
   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010
a991 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a1023 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.22
log
@* elf32-m32c.c (ELF_MAXPAGESIZE): Change page size to 256 bytes.
@
text
@d438 2
a439 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.21
log
@fix set but unused variable warnings
@
text
@d2013 1
a2013 1
#define ELF_MAXPAGESIZE		0x1000
@


1.20
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright (C) 2005, 2006, 2007, 2008, 2009
d1191 1
a1191 1
		       Elf_External_Sym_Shndx *shndx_buf,
a1200 1
      Elf_External_Sym_Shndx *shndx;
a1202 1

a1204 2
      shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (rel->r_info) : 0);

a1868 1
  Elf_Internal_Rela *irelalign;
a1880 3
  /* The deletion must stop at the next ALIGN reloc for an aligment
     power larger than the number of bytes we are deleting.  */
  irelalign = NULL;
@


1.19
log
@* elf32-m32c.c (m32c_elf_relax_delete_bytes): Adjust symbol sizes
if needed.
@
text
@d2 1
a2 1
   Copyright (C) 2005, 2006, 2007, 2008
@


1.18
log
@Silence gcc printf warnings
@
text
@d1954 2
a1955 1

d1962 10
d1986 1
a1986 1
	  (   sym_hash->root.type == bfd_link_hash_defined
d1988 1
a1988 3
	  && sym_hash->root.u.def.section == sec
	  && sym_hash->root.u.def.value > addr
	  && sym_hash->root.u.def.value < toaddr)
d1990 11
a2000 1
	  sym_hash->root.u.def.value -= count;
@


1.17
log
@* common.h (EM_M32C_NEW): Rename to EM_M32C.
(EM_M32C): Rename to EM_M32C_OLD.

* elf32-m32c.c (ELF_MACHINE_ALT1): Define as EM_M32C_OLD.

* readelf.c (guess_is_rela): Add EM_M32C_OLD.
(dump_relocations): Likewise.
(process_section_headers): Likewise.
(is_32bit_abs_reloc): Likewise.
(is_16bit_abs_reloc): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 2005, 2006, 2007
d850 1
a850 1
  fprintf (file, _("private flags = 0x%lx:"), (long)flags);
@


1.16
log
@* elf32-m32c.c (_bfd_m32c_elf_eh_frame_address_size): New.
@
text
@d2001 1
@


1.15
log
@	* elf-m10300.c (mn10300_elf_check_relocs): Delete dead code.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-bfin.c (bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (_frvfdpic_check_discarded_relocs): Likewise.
	(elf32_frv_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	(score_elf_local_relocation_p): Likewise.
	(_bfd_score_elf_relocate_section): Likewise.
	(score_elf_final_link_relocate): Likewise.
@
text
@d1988 10
d2024 1
@


1.14
log
@Switch sources over to use the GPL version 3
@
text
@a599 1
  struct elf_link_hash_entry ** sym_hashes_end;
a614 4
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;
 
@


1.13
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
@


1.12
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d21 1
a22 1
#include "sysdep.h"
@


1.11
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d275 15
d2021 1
@


1.10
log
@* elf32-m32c.c (m32c_elf_howto_table): Don't complain about
R_M32C_16 or R_M32C_24 relocs.
@
text
@d2 1
a2 1
   Copyright (C) 2005, 2006
a374 21
      if (info->relocatable)
	{
	  /* This is a relocatable link.  We don't have to change
             anything, unless the reloc is against a section symbol,
             in which case we have to adjust according to where the
             section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections [r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d379 1
d412 2
a413 4
	    {
	      relocation = 0;
	    }
	  else
a418 1
	      relocation = 0;
d422 22
@


1.9
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d63 3
d72 1
a72 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d86 1
a86 1
	 complain_overflow_bitfield, /* complain_on_overflow */
@


1.8
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@a34 4
static bfd_boolean m32c_elf_gc_sweep_hook
  (bfd *, struct bfd_link_info *, asection *, const Elf_Internal_Rela *);
static asection * m32c_elf_gc_mark_hook
  (asection *, struct bfd_link_info *, Elf_Internal_Rela *, struct elf_link_hash_entry *, Elf_Internal_Sym *);
a570 56
/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
m32c_elf_gc_mark_hook
    (asection *                   sec,
     struct bfd_link_info *       info ATTRIBUTE_UNUSED,
     Elf_Internal_Rela *          rel,
     struct elf_link_hash_entry * h,
     Elf_Internal_Sym *           sym)
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    {
      if (!(elf_bad_symtab (sec->owner)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
	}
    }

  return NULL;
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
m32c_elf_gc_sweep_hook
    (bfd *                     abfd ATTRIBUTE_UNUSED,
     struct bfd_link_info *    info ATTRIBUTE_UNUSED,
     asection *                sec ATTRIBUTE_UNUSED,
     const Elf_Internal_Rela * relocs ATTRIBUTE_UNUSED)
{
  return TRUE;
}

a1992 2
#define elf_backend_gc_mark_hook		m32c_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook		m32c_elf_gc_sweep_hook
@


1.7
log
@	* dwarf2.c: Formatting.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Simplify
	output section check.
	* elf32-i370.c: Warning fixes inside #ifdef DEBUG.
	* elf32-m32c.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-v850.c: Similarly.
	* nlm32-sparc.c: Similarly.
	* elfcode.h: Similarly.
	(elf_symbol_flags): Delete.
	* elflink.c (elf_link_input_bfd): Comment typo.
@
text
@d694 4
a697 1
		  splt = bfd_make_section (dynobj, ".plt");
a698 8
		      || ! bfd_set_section_flags (dynobj, splt,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY
						   | SEC_CODE))
@


1.6
log
@* elf32-m32c.c (m32c_elf_relocate_section): Generate a symbol for
each plt entry we create.
@
text
@d43 2
a44 1
static char * m32c_get_reloc (long reloc);
d940 1
a940 1
static void
a980 1
	case STT_SRELC: st_info_str = "STT_SRELC";
d1025 1
a1025 1
static char *
@


1.5
log
@* elf32-m32c.c (m32c_offset_for_reloc): Fix local symbol
calculations.
@
text
@d485 16
@


1.5.4.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a484 16
		if (name)
		{
		  char *newname = bfd_malloc (strlen(name)+5);
		  strcpy (newname, name);
		  strcat(newname, ".plt");
		  _bfd_generic_link_add_one_symbol (info,
						    input_bfd,
						    newname,
						    BSF_FUNCTION | BSF_WEAK,
						    splt,
						    (*plt_offset & -2),
						    0,
						    1,
						    0,
						    0);
		}
@


1.4
log
@Initialise 'gap'.
@
text
@d496 4
a499 3
      printf("relocate %s at %06lx relocation %06lx addend %ld  ",
	     m32c_elf_howto_table[ELF32_R_TYPE(rel->r_info)].name,
	     rel->r_offset, relocation, rel->r_addend);
d503 2
a504 2
	  printf(" %02x", contents[rel->r_offset+i]);
	printf("\n");
d1223 1
a1223 1
#define OFFSET_FOR_RELOC(rel) m32c_offset_for_reloc (abfd, sec, rel, symtab_hdr, shndx_buf, intsyms)
a1225 1
		       asection * sec,
d1239 2
d1243 1
d1246 4
a1249 3
      symval = (isym->st_value
		+ sec->output_section->vma
		+ sec->output_offset);
@


1.3
log
@[include/elf]
	* m32c.h: Add relax relocs.

[cpu]
	* m32c.cpu (RL_TYPE): New attribute, with macros.
	(Lab-8-24): Add RELAX.
	(unary-insn-defn-g, binary-arith-imm-dst-defn,
	binary-arith-imm4-dst-defn): Add 1ADDR attribute.
	(binary-arith-src-dst-defn): Add 2ADDR attribute.
	(jcnd16-5, jcnd16, jcnd32, jmp16.s, jmp16.b, jmp16.w, jmp16.a,
	jmp32.s, jmp32.b, jmp32.w, jmp32.a, jsr16.w, jsr16.a): Add JUMP
	attribute.
	(jsri16, jsri32): Add 1ADDR attribute.
	(jsr32.w, jsr32.a): Add JUMP attribute.

[opcodes]
	* m32c-desc.c: Regenerate with linker relaxation attributes.
	* m32c-desc.h: Likewise.
	* m32c-dis.c: Likewise.
	* m32c-opc.c: Likewise.

[gas]
	* config/tc-m32c.h (md_apply_fix): Define to m32c_apply_fix.
	(tc_gen_reloc): Don't define.
	* config/tc-m32c.c (rl_for, relaxable): New convenience macros.
	(OPTION_LINKRELAX): New.
	(md_longopts): Add it.
	(m32c_relax): New.
	(md_parse_options): Set it.
	(md_assemble): Emit relaxation relocs as needed.
	(md_convert_frag): Emit relaxation relocs as needed.
	(md_cgen_lookup_reloc): Add LAB_8_8 and LAB_8_16.
	(m32c_apply_fix): New.
	(tc_gen_reloc): New.
	(m32c_force_relocation): Force out jump relocs when relaxing.
	(m32c_fix_adjustable): Return false if relaxing.

[bfd]
	* elf32-m32c.c (m32c_elf_howto_table): Add relaxation relocs.
	(m32c_elf_relocate_section): Don't relocate them.
	(compare_reloc): New.
	(relax_reloc): Remove.
	(m32c_offset_for_reloc): New.
	(m16c_addr_encodings): New.
	(m16c_jmpaddr_encodings): New.
	(m32c_addr_encodings): New.
	(m32c_elf_relax_section): Relax jumps and address displacements.
	(m32c_elf_relax_delete_bytes): Adjust for internal syms.  Fix up
	short jumps.

	* reloc.c: Add m32c relax relocs.
	* libbfd.h: Regenerate.
@
text
@d1535 1
@


1.2
log
@[bfd]
	* reloc.c: Remove unused M32C relocs, add BFD_RELOC_M32C_HI8.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	* elf32-m32c.c (m32c_elf_howto_table): Add R_M32C_8, R_M32C_LO16,
	R_M32C_HI8, R_M32C_HI16.
	(m32c_reloc_map): Likewise.
	(m32c_elf_relocate_section): Add R_M32C_HI8 and R_M32C_HI16.

[cpu]
	* m32c.opc (parse_unsigned8): Add %dsp8().
	(parse_signed8): Add %hi8().
	(parse_unsigned16): Add %dsp16().
	(parse_signed16): Add %lo16() and %hi16().
	(parse_lab_5_3): Make valuep a bfd_vma *.

[gas]
	* config/tc-m32c.c (md_cgen_lookup_reloc): Add 8 bit operands.
	Support %mod() modifiers from opcodes.
	* doc/c-m32c.texi (M32C-Modifiers): New section.

[include/elf]

	* m32c.h: Add R_M32C_8, R_M32C_LO16, R_M32C_HI8, and R_M32C_HI16.

[opcodes]
	* m32c-asm.c Regenerate.
	* m32c-dis.c Regenerate.
@
text
@d2 1
a2 1
   Copyright (C) 2005
d77 1
a77 1
	 0x0000ffff,		/* dst_mask */
d91 1
a91 1
	 0x00ffffff,            /* dst_mask */
d119 1
a119 1
	 0x000000ff,   		/* dst_mask */
d133 1
a133 1
	 0,             	/* dst_mask */
d147 1
a147 1
	 0x000000ff,		/* dst_mask */
d161 1
a161 1
	 0x0000ffff,		/* dst_mask */
d175 1
a175 1
	 0x000000ff,		/* dst_mask */
d189 1
a189 1
	 0x0000ffff,		/* dst_mask */
d191 43
d255 4
a258 1
  { BFD_RELOC_M32C_HI8,		R_M32C_HI8 }
d365 7
d400 1
a400 1
      
d411 1
a411 1
	  name = (name == NULL) ? bfd_section_name (input_bfd, sec) : name;
d495 11
d1210 2
a1211 1
struct relax_reloc_s
d1213 35
a1247 16
  int machine;
  int opcode_mask;
  bfd_vma opcode;		/* original opcode or insn part */
  int relax_backward;		/* lbound */
  int relax_forward;		/* hbound */
  int value_shift;
  int mask;
  int new_opcode;		/* new opcode */
  int old_reloc;		/* old relocation */
  int new_reloc;		/* new relocation  */
  int use_pcrel;
  int delete_n;		/* # bytes differ between original and new */
};
static struct relax_reloc_s relax_reloc [] =
  {
#if 0
d1249 18
a1266 142
      bfd_mach_m16c,
      0xff,
      0xfc,			/* jmp.a */
      -32768,
      32767,
      2,
      0xffffff00,
      0xf4,			/* jmp.w */
      R_M32C_8_ELABEL24,
      R_M32C_8_PCREL16,
      1,
      1,
    },
    {
      bfd_mach_m32c,
      0xff,
      0xcc,			/* jmp.a */
      -32768,
      32767,
      2,
      0xffffff00,
      0xce,			/* jmp.w */
      R_M32C_8_ELABEL24,
      R_M32C_8_PCREL16,
      1,
      1,
    },
    {
      bfd_mach_m32c,
      0xff,
      0xcd,			/* jsr.a */
      -32768,
      32767,
      2,
      0xffffff00,
      0xcf,			/* jsr.w */
      R_M32C_8_ELABEL24,
      R_M32C_8_PCREL16,
      1,
      1,
    },
    {
      bfd_mach_m16c,
      0xff,
      0xf4,			/* jmp.w */
      -128,
      127,
      2,
      0xffffff00,
      0xfe,			/* jmp.b */
      R_M32C_8_PCREL16,
      R_M32C_8_PCREL8,
      1,
      1,
    },
    {
      bfd_mach_m32c,
      0xff,
      0xce,			/* jmp.w */
      -128,
      127,
      2,
      0xffffff00,
      0xbb,			/* jmp.b */
      R_M32C_8_PCREL16,
      R_M32C_8_PCREL8,
      1,
      1,
    },
    {
      bfd_mach_m32c,
      0xc0f6,
      0x8096,			/* dest */
      0,
      0xffff,
      3,
      0xffff3fff,
      0xc000,			/* abs16 */
      R_M32C_24_ABS24,
      R_M32C_24_ABS16,
      0,
      1,
    },
    {
      bfd_mach_m32c,
      0xc0f6,
      0x80a6,			/* dest */
      0,
      0xffff,
      4,
      0xffff3fff,
      0xc000,			/* abs16 */
      R_M32C_32_ABS24,
      R_M32C_32_ABS16,
      0,
      1,
    },
    {
      bfd_mach_m32c,
      0xc0f6,
      0x80b6,			/* dest */
      0,
      0xffff,
      5,
      0xffff3fff,
      0xc000,			/* abs16 */
      R_M32C_40_ABS24,
      R_M32C_40_ABS16,
      0,
      1,
    },
    {
      bfd_mach_m32c,
      0x30f0,
      0x20b0,			/* src */
      0,
      0xffff,
      2,
      0xffffcfff,
      0x3000,			/* abs16 */
      R_M32C_16_ABS24,
      R_M32C_16_ABS16,
      0,
      1,
    },
    {
      bfd_mach_m32c,
      0xc086,
      0x8086,			/* dest */
      0,
      0xffff,
      2,
      0xffff3fff,
      0xc000,			/* abs16 */
      R_M32C_16_ABS24,
      R_M32C_16_ABS16,
      0,
      1,
    },
#endif
    {
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
d1268 102
a1369 1
  };
d1381 1
a1381 1
  Elf_Internal_Rela *irel, *irelend;
d1384 2
a1385 2
  Elf32_External_Sym *extsyms = NULL;
  Elf32_External_Sym *free_extsyms = NULL;
a1406 3
  /* Relaxing doesn't quite work right yet.  */
  return TRUE;

d1410 34
d1453 5
d1464 1
a1464 1
      bfd_vma insn;
d1466 80
a1545 22
      bfd_signed_vma pcrel_value;
      bfd_vma addend;
      int to_delete;
      int i;

      /* Get the section contents.  */
      if (contents == NULL)
	{
	  if (elf_section_data (sec)->this_hdr.contents != NULL)
	    contents = elf_section_data (sec)->this_hdr.contents;
	  /* Go get them off disk.  */
	  else if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	    goto error_return;
	}

      /* Read this BFD's symbols if we haven't done so already.  */
      if (extsyms == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (symtab_hdr->contents != NULL)
	    extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
	  else
a1546 1
	      bfd_size_type amt = symtab_hdr->sh_size;
d1548 105
a1652 10
	      /* Go get them off disk.  */
	      extsyms = (Elf32_External_Sym *) bfd_malloc (amt);
	      if (extsyms == NULL)
		goto error_return;
	      free_extsyms = extsyms;
	      if (bfd_seek (abfd, symtab_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread (extsyms, amt, abfd) != amt)
		goto error_return;
	      symtab_hdr->contents = (bfd_byte *) extsyms;
	    }
d1654 15
a1668 3
	  if (shndx_hdr->sh_size != 0)
	    {
	      bfd_size_type amt;
d1670 1
a1670 11
	      amt = symtab_hdr->sh_info;
	      amt *= sizeof (Elf_External_Sym_Shndx);
	      shndx_buf = (Elf_External_Sym_Shndx *) bfd_malloc (amt);
	      if (shndx_buf == NULL)
		goto error_return;
	      if (bfd_seek (abfd, shndx_hdr->sh_offset, SEEK_SET) != 0
		  || bfd_bread ((PTR) shndx_buf, amt, abfd) != amt)
		goto error_return;
	      shndx_hdr->contents = (bfd_byte *) shndx_buf;
	    }
	}
d1672 1
a1672 15
      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf32_External_Sym *esym;
	  Elf_External_Sym_Shndx *shndx;
	  Elf_Internal_Sym isym;

	  esym = extsyms + ELF32_R_SYM (irel->r_info);
	  shndx = shndx_buf + (shndx_buf ? ELF32_R_SYM (irel->r_info) : 0);
	  bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);

	  symval = (isym.st_value
		    + sec->output_section->vma
		    + sec->output_offset);
d1674 1
a1674 1
      else
d1676 61
a1736 2
	  unsigned long indx;
	  struct elf_link_hash_entry *h;
d1738 51
a1788 11
	  /* An external symbol.  */
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
	  BFD_ASSERT (h != NULL);

	  if (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	    /* This appears to be a reference to an undefined
	       symbol.  Just ignore it--it will be caught by the
	       regular reloc processing.  */
	    continue;
d1790 17
a1806 4
	  symval = (h->root.u.def.value
		    + h->root.u.def.section->output_section->vma
		    + h->root.u.def.section->output_offset);
	}
d1808 1
a1808 3
      /* There will always be room for the relaxed insn, since it is smaller
	 than the one it would replace.  */
      BFD_ASSERT (irel->r_offset <= sec->size - 2);
d1810 2
a1811 1
      insn = bfd_get_16 (abfd, contents + irel->r_offset + 0);
d1813 2
a1814 14
      addend = irel->r_addend;
      for (i = 0; relax_reloc[i].machine; i++)
	{
#ifdef DEBUG
	  _bfd_error_handler ("insn %x %d mask %x opcode %x =%x\n",
			      insn, i, relax_reloc[i].opcode_mask,
			      relax_reloc[i].opcode,
			      (insn & relax_reloc[i].opcode_mask) == relax_reloc[i].opcode);
#endif
	  if (!(machine == relax_reloc[i].machine
		&& (insn & relax_reloc[i].opcode_mask) == relax_reloc[i].opcode
		&& (relax_reloc[i].old_reloc
		    == (int) ELF32_R_TYPE(irel->r_info))))
	    continue;
d1816 1
a1816 16
	  /* At this point we've confirmed we have a matching insn.  Now
	     ensure the operand is in range.  */
	  if (relax_reloc[i].use_pcrel)
	    {
	      pc = sec->output_section->vma + sec->output_offset
		+ irel->r_offset;
	      pcrel_value = symval - pc;
#ifndef USE_REL /* put in for learning purposes */
	      pcrel_value += addend;
#else
	      addend = bfd_get_signed_16 (abfd, contents + irel->r_offset + 2);
	      pcrel_value += addend;
#endif
	    }
	  else
	    pcrel_value = symval;
d1818 1
a1818 5
	  if (pcrel_value >= relax_reloc[i].relax_backward
	      && pcrel_value < relax_reloc[i].relax_forward + 2)
	    {
	      /* We can relax to a shorter operand.  */
	      insn = (insn & relax_reloc[i].mask) | relax_reloc[i].new_opcode;
d1820 6
a1825 1
	      to_delete = relax_reloc[i].delete_n;
d1827 2
a1828 2
	      /* Rewrite the insn.  */
	      bfd_put_16 (abfd, insn, contents + irel->r_offset);
d1830 1
a1830 7
	      /* Set the new reloc type.  */
	      irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					   relax_reloc[i].new_reloc);
	      irel->r_addend = pcrel_value;
	    }
	  else
	    continue;
d1832 2
a1833 10
#ifdef DEBUG
	  _bfd_error_handler  ("insn %x pc %x index %d mask %x shift %d delete %d\n"
			       "old reloc %s new reloc %s",
			       insn, sec->output_section->vma
			       + sec->output_offset + irel->r_offset + 2,
			       i, relax_reloc[i].opcode_mask,
			       relax_reloc[i].value_shift, to_delete,
			       m32c_get_reloc (relax_reloc[i].old_reloc),
			       m32c_get_reloc (relax_reloc[i].new_reloc));
#endif
a1834 16
	  /* Note that we've changed the relocs, section contents, etc.  */
	  elf_section_data (sec)->relocs = internal_relocs;
	  free_relocs = NULL;

	  elf_section_data (sec)->this_hdr.contents = contents;
	  free_contents = NULL;

	  symtab_hdr->contents = (bfd_byte *) extsyms;
	  free_extsyms = NULL;

	  /* Delete TO_DELETE bytes of data.  */
	  if (! m32c_elf_relax_delete_bytes
	      (abfd, sec, irel->r_offset + relax_reloc[i].value_shift,
	       to_delete))
	    goto error_return;
	} /* next relax_reloc */
d1860 1
a1860 1
  if (free_extsyms != NULL)
d1863 1
a1863 1
	free (free_extsyms);
d1866 3
a1868 1
	symtab_hdr->contents = NULL /* (unsigned char *) extsyms*/;
d1870 1
a1870 1
      free_extsyms = NULL;
a1871 2
  /* elf_link_input_bfd expects internal syms.  */
  symtab_hdr->contents = NULL;
d1885 2
a1886 2
  if (free_extsyms != NULL)
    free (free_extsyms);
d1907 3
a1909 3
  Elf32_External_Sym *esym;
  Elf32_External_Sym *esymend;
  Elf32_External_Sym *extsyms;
d1915 1
a1915 6
 
  symtab_hdr = & elf_tdata (abfd)->symtab_hdr;
  extsyms = (Elf32_External_Sym *) symtab_hdr->contents;
  shndx_hdr  = & elf_tdata (abfd)->symtab_shndx_hdr;
  shndx_buf  = (Elf_External_Sym_Shndx *) shndx_hdr->contents;
  sec_shndx  = _bfd_elf_section_from_bfd_section (abfd, sec);
d1936 35
a1970 2
      if (irel->r_addend > addr && irel->r_addend < toaddr)
	irel->r_addend -= count;
d1974 8
d1983 2
a1984 3
  esym = extsyms;
  esymend = esym + symtab_hdr->sh_info;
  for (; esym < esymend; esym++, shndx = (shndx ? shndx + 1 : NULL))
a1985 4
      Elf_Internal_Sym isym;
      Elf_External_Sym_Shndx dummy;

      bfd_elf32_swap_symbol_in (abfd, esym, shndx, &isym);
d1987 3
a1989 3
      if ((int) isym.st_shndx == sec_shndx
	  && isym.st_value > addr
	  && isym.st_value < toaddr)
d1991 1
a1991 2
	  isym.st_value -= count;
	  bfd_elf32_swap_symbol_out (abfd, &isym, (PTR) esym, (PTR) & dummy);
d2012 3
a2014 1
	sym_hash->root.u.def.value -= count;
@


1.1
log
@ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* configure.in: Add cases for Renesas m32c.
	* configure: Regenerated.

bfd/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for m32c-*-elf (Renesas m32c and m16c).
	* Makefile.am (ALL_MACHINES): Add cpu-m32c.lo.
	(ALL_MACHINES_CFILES): Add cpu-m32c.c.
	(BFD32_BACKENDS): Add elf32-m32c.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-m32c.c.
	(cpu-m32c.lo, elf32-m32c.lo): New rules, generated by 'make dep-am'.
	* Makefile.in: Regenerated.
	* archures.c (bfd_arch_m32c, bfd_mach_m16c, bfd_mach_m32c): New
	arch and mach codes.
	(bfd_m32c_arch): New arch info object.
	(bfd_archures_list): List bfd_m32c_arch.
	* bfd-in2.h: Regenerated.
	* config.bfd: Add case for the m32c.
	* configure.in: Add case for the m32c.
	* configure: Regenerated.
	* cpu-m32c.c, elf32-m32c.c: New files.
	* libbfd.h: Regenerated.
	* targets.c (bfd_elf32_m32c_vec): Declare.
	(_bfd_target_vector): List bfd_elf32_m32c_vec.

binutils/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* readelf.c: #include "elf/m32c.h"
	(guess_is_rela, dump_relocations, get_machine_name): Add cases for
	EM_M32C.
	* Makefile.am (readelf.o): Update dependencies.
	* Makefile.in: Regenerated.

cpu/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* m32c.cpu, m32c.opc: Machine description for the Renesas M32C.

gas/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for the Renesas M32C.
	* Makefile.am (CPU_TYPES): List m32c.
	(TARGET_CPU_CFILES): List config/tc-m32c.c.
	(TARGET_CPU_HFILES): List config/tc-m32c.h.
	* configure.in: Add case for m32c.
	* configure.tgt: Add cases for m32c and m32c-*-elf.
	* configure: Regenerated.
	* config/tc-m32c.c, config/tc-m32c.h: New files.
	* doc/Makefile.am (CPU_DOCS): Add c-m32c.texi.
	* doc/Makefile.in: Regenerated.
	* doc/all.texi: Set M32C.
	* doc/as.texinfo: Add text for the M32C-specific options and line
	comment characters, and refer to c-m32c.texi.
	* doc/c-m32c.texi: New file.

include/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* dis-asm.h (print_insn_m32c): New declaration.

include/elf/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for Renesas M32C and M16C.
	* common.h (EM_M32C): New machine number.
	* m32c.h: New file.

ld/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for the Renesas M32C and M16C.
	* Makefile.am (ALL_EMULATIONS): Add eelf32m32c.o.
	(eelf32m32c.c): New target.
	* Makefile.in: Regenerated.
	* configure.tgt: Add case for m32c-*-elf.
	* emulparams/elf32m32c.sh: New file.

opcodes/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for the Renesas M32C and M16C.
	* m32c-asm.c, m32c-desc.c, m32c-dis.c, m32c-ibld.c, m32c-opc.c: New.
	* m32c-desc.h, m32c-opc.h: New.
	* Makefile.am (HFILES): List m32c-desc.h and m32c-opc.h.
	(CFILES): List m32c-asm.c, m32c-desc.c, m32c-dis.c, m32c-ibld.c,
	m32c-opc.c.
	(ALL_MACHINES): List m32c-asm.lo, m32c-desc.lo, m32c-dis.lo,
	m32c-ibld.lo, m32c-opc.lo.
	(CLEANFILES): List stamp-m32c.
	(M32C_DEPS): List stamp-m32c, if CGEN_MAINT.
	(CGEN_CPUS): Add m32c.
	(m32c-asm.c, m32c-desc.c, m32c-dis.c, m32c-ibld.c, m32c-opc.c)
	(m32c-desc.h, m32c-opc.h): Depend on M32C_DEPS.
	(m32c_opc_h): New variable.
	(stamp-m32c, m32c-asm.lo, m32c-desc.lo, m32c-dis.lo, m32c-ibld.lo)
	(m32c-opc.lo): New rules.
	* Makefile.in: Regenerated.
	* configure.in: Add case for bfd_m32c_arch.
	* configure: Regenerated.
	* disassemble.c (ARCH_m32c): New.
	[ARCH_m32c]: #include "m32c-desc.h".
	(disassembler) [ARCH_m32c]: Add case for bfd_arch_m32c.
	(disassemble_init_for_target) [ARCH_m32c]: Same.

	* cgen-ops.h, cgen-types.h: New files.
	* Makefile.am (HFILES): List them.
	* Makefile.in: Regenerated.
@
text
@d135 56
d208 5
a212 1
  { BFD_RELOC_16_PCREL,         R_M32C_16_PCREL }
d435 5
@

