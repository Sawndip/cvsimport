head	1.84;
access;
symbols
	sid-snapshot-20180601:1.84
	sid-snapshot-20180501:1.84
	sid-snapshot-20180401:1.84
	sid-snapshot-20180301:1.84
	sid-snapshot-20180201:1.84
	sid-snapshot-20180101:1.84
	sid-snapshot-20171201:1.84
	sid-snapshot-20171101:1.84
	sid-snapshot-20171001:1.84
	sid-snapshot-20170901:1.84
	sid-snapshot-20170801:1.84
	sid-snapshot-20170701:1.84
	sid-snapshot-20170601:1.84
	sid-snapshot-20170501:1.84
	sid-snapshot-20170401:1.84
	sid-snapshot-20170301:1.84
	sid-snapshot-20170201:1.84
	sid-snapshot-20170101:1.84
	sid-snapshot-20161201:1.84
	sid-snapshot-20161101:1.84
	sid-snapshot-20160901:1.84
	sid-snapshot-20160801:1.84
	sid-snapshot-20160701:1.84
	sid-snapshot-20160601:1.84
	sid-snapshot-20160501:1.84
	sid-snapshot-20160401:1.84
	sid-snapshot-20160301:1.84
	sid-snapshot-20160201:1.84
	sid-snapshot-20160101:1.84
	sid-snapshot-20151201:1.84
	sid-snapshot-20151101:1.84
	sid-snapshot-20151001:1.84
	sid-snapshot-20150901:1.84
	sid-snapshot-20150801:1.84
	sid-snapshot-20150701:1.84
	sid-snapshot-20150601:1.84
	sid-snapshot-20150501:1.84
	sid-snapshot-20150401:1.84
	sid-snapshot-20150301:1.84
	sid-snapshot-20150201:1.84
	sid-snapshot-20150101:1.84
	sid-snapshot-20141201:1.84
	sid-snapshot-20141101:1.84
	sid-snapshot-20141001:1.84
	sid-snapshot-20140901:1.84
	sid-snapshot-20140801:1.84
	sid-snapshot-20140701:1.84
	sid-snapshot-20140601:1.84
	sid-snapshot-20140501:1.84
	sid-snapshot-20140401:1.84
	sid-snapshot-20140301:1.84
	sid-snapshot-20140201:1.84
	sid-snapshot-20140101:1.84
	sid-snapshot-20131201:1.84
	sid-snapshot-20131101:1.84
	sid-snapshot-20131001:1.83
	binutils-2_24-branch:1.83.0.4
	binutils-2_24-branchpoint:1.83
	binutils-2_21_1:1.76.2.2
	sid-snapshot-20130901:1.83
	gdb_7_6_1-2013-08-30-release:1.83
	sid-snapshot-20130801:1.83
	sid-snapshot-20130701:1.83
	sid-snapshot-20130601:1.83
	sid-snapshot-20130501:1.83
	gdb_7_6-2013-04-26-release:1.83
	sid-snapshot-20130401:1.83
	binutils-2_23_2:1.81
	gdb_7_6-branch:1.83.0.2
	gdb_7_6-2013-03-12-branchpoint:1.83
	sid-snapshot-20130301:1.83
	sid-snapshot-20130201:1.82
	sid-snapshot-20130101:1.81
	sid-snapshot-20121201:1.81
	gdb_7_5_1-2012-11-29-release:1.81
	binutils-2_23_1:1.81
	sid-snapshot-20121101:1.81
	binutils-2_23:1.81
	sid-snapshot-20121001:1.81
	sid-snapshot-20120901:1.81
	gdb_7_5-2012-08-17-release:1.81
	sid-snapshot-20120801:1.81
	binutils-2_23-branch:1.81.0.10
	binutils-2_23-branchpoint:1.81
	gdb_7_5-branch:1.81.0.8
	gdb_7_5-2012-07-18-branchpoint:1.81
	sid-snapshot-20120701:1.81
	sid-snapshot-20120601:1.81
	sid-snapshot-20120501:1.81
	binutils-2_22_branch:1.81.0.6
	gdb_7_4_1-2012-04-26-release:1.81
	sid-snapshot-20120401:1.81
	sid-snapshot-20120301:1.81
	sid-snapshot-20120201:1.81
	gdb_7_4-2012-01-24-release:1.81
	sid-snapshot-20120101:1.81
	gdb_7_4-branch:1.81.0.4
	gdb_7_4-2011-12-13-branchpoint:1.81
	sid-snapshot-20111201:1.81
	binutils-2_22:1.81
	sid-snapshot-20111101:1.81
	sid-snapshot-20111001:1.81
	binutils-2_22-branch:1.81.0.2
	binutils-2_22-branchpoint:1.81
	gdb_7_3_1-2011-09-04-release:1.78
	sid-snapshot-20110901:1.81
	sid-snapshot-20110801:1.81
	gdb_7_3-2011-07-26-release:1.78
	sid-snapshot-20110701:1.81
	sid-snapshot-20110601:1.80
	sid-snapshot-20110501:1.79
	gdb_7_3-branch:1.78.0.2
	gdb_7_3-2011-04-01-branchpoint:1.78
	sid-snapshot-20110401:1.78
	sid-snapshot-20110301:1.78
	sid-snapshot-20110201:1.77
	sid-snapshot-20110101:1.77
	binutils-2_21:1.76
	sid-snapshot-20101201:1.76
	binutils-2_21-branch:1.76.0.2
	binutils-2_21-branchpoint:1.76
	sid-snapshot-20101101:1.76
	sid-snapshot-20101001:1.75
	binutils-2_20_1:1.70
	gdb_7_2-2010-09-02-release:1.75
	sid-snapshot-20100901:1.75
	sid-snapshot-20100801:1.75
	gdb_7_2-branch:1.75.0.2
	gdb_7_2-2010-07-07-branchpoint:1.75
	sid-snapshot-20100701:1.75
	sid-snapshot-20100601:1.75
	sid-snapshot-20100501:1.74
	sid-snapshot-20100401:1.74
	gdb_7_1-2010-03-18-release:1.74
	sid-snapshot-20100301:1.74
	gdb_7_1-branch:1.74.0.2
	gdb_7_1-2010-02-18-branchpoint:1.74
	sid-snapshot-20100201:1.73
	sid-snapshot-20100101:1.72
	gdb_7_0_1-2009-12-22-release:1.70
	sid-snapshot-20091201:1.70
	sid-snapshot-20091101:1.70
	binutils-2_20:1.70
	gdb_7_0-2009-10-06-release:1.70
	sid-snapshot-20091001:1.70
	gdb_7_0-branch:1.70.0.4
	gdb_7_0-2009-09-16-branchpoint:1.70
	arc-sim-20090309:1.48
	binutils-arc-20081103-branch:1.48.0.22
	binutils-arc-20081103-branchpoint:1.48
	binutils-2_20-branch:1.70.0.2
	binutils-2_20-branchpoint:1.70
	sid-snapshot-20090901:1.69
	sid-snapshot-20090801:1.69
	msnyder-checkpoint-072509-branch:1.69.0.4
	msnyder-checkpoint-072509-branchpoint:1.69
	sid-snapshot-20090701:1.69
	dje-cgen-play1-branch:1.69.0.2
	dje-cgen-play1-branchpoint:1.69
	sid-snapshot-20090601:1.68
	sid-snapshot-20090501:1.68
	sid-snapshot-20090401:1.61
	arc-20081103-branch:1.48.0.20
	arc-20081103-branchpoint:1.48
	arc-insight_6_8-branch:1.48.0.18
	arc-insight_6_8-branchpoint:1.48
	insight_6_8-branch:1.48.0.16
	insight_6_8-branchpoint:1.48
	sid-snapshot-20090301:1.48
	binutils-2_19_1:1.48
	sid-snapshot-20090201:1.48
	sid-snapshot-20090101:1.48
	reverse-20081226-branch:1.48.0.14
	reverse-20081226-branchpoint:1.48
	sid-snapshot-20081201:1.48
	multiprocess-20081120-branch:1.48.0.12
	multiprocess-20081120-branchpoint:1.48
	sid-snapshot-20081101:1.48
	binutils-2_19:1.48
	sid-snapshot-20081001:1.48
	reverse-20080930-branch:1.48.0.10
	reverse-20080930-branchpoint:1.48
	binutils-2_19-branch:1.48.0.8
	binutils-2_19-branchpoint:1.48
	sid-snapshot-20080901:1.48
	sid-snapshot-20080801:1.48
	reverse-20080717-branch:1.48.0.6
	reverse-20080717-branchpoint:1.48
	sid-snapshot-20080701:1.48
	msnyder-reverse-20080609-branch:1.48.0.4
	msnyder-reverse-20080609-branchpoint:1.48
	drow-reverse-20070409-branch:1.45.0.4
	drow-reverse-20070409-branchpoint:1.45
	sid-snapshot-20080601:1.48
	sid-snapshot-20080501:1.48
	sid-snapshot-20080403:1.48
	sid-snapshot-20080401:1.48
	gdb_6_8-2008-03-27-release:1.48
	sid-snapshot-20080301:1.48
	gdb_6_8-branch:1.48.0.2
	gdb_6_8-2008-02-26-branchpoint:1.48
	sid-snapshot-20080201:1.47
	sid-snapshot-20080101:1.47
	sid-snapshot-20071201:1.47
	sid-snapshot-20071101:1.47
	gdb_6_7_1-2007-10-29-release:1.47
	gdb_6_7-2007-10-10-release:1.47
	sid-snapshot-20071001:1.47
	gdb_6_7-branch:1.47.0.4
	gdb_6_7-2007-09-07-branchpoint:1.47
	binutils-2_18:1.47
	binutils-2_18-branch:1.47.0.2
	binutils-2_18-branchpoint:1.47
	insight_6_6-20070208-release:1.45
	binutils-csl-coldfire-4_1-32:1.44
	binutils-csl-sourcerygxx-4_1-32:1.44
	gdb_6_6-2006-12-18-release:1.45
	binutils-csl-innovasic-fido-3_4_4-33:1.44
	binutils-csl-sourcerygxx-3_4_4-32:1.37
	binutils-csl-coldfire-4_1-30:1.44
	binutils-csl-sourcerygxx-4_1-30:1.44
	binutils-csl-coldfire-4_1-28:1.44
	binutils-csl-sourcerygxx-4_1-29:1.44
	binutils-csl-sourcerygxx-4_1-28:1.44
	gdb_6_6-branch:1.45.0.2
	gdb_6_6-2006-11-15-branchpoint:1.45
	binutils-csl-arm-2006q3-27:1.44
	binutils-csl-sourcerygxx-4_1-27:1.44
	binutils-csl-arm-2006q3-26:1.44
	binutils-csl-sourcerygxx-4_1-26:1.44
	binutils-csl-sourcerygxx-4_1-25:1.44
	binutils-csl-sourcerygxx-4_1-24:1.44
	binutils-csl-sourcerygxx-4_1-23:1.44
	insight_6_5-20061003-release:1.44
	gdb-csl-symbian-6_4_50_20060226-12:1.43
	binutils-csl-sourcerygxx-4_1-21:1.44
	binutils-csl-arm-2006q3-21:1.44
	binutils-csl-sourcerygxx-4_1-22:1.44
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.44
	binutils-csl-sourcerygxx-4_1-20:1.44
	binutils-csl-arm-2006q3-19:1.44
	binutils-csl-sourcerygxx-4_1-19:1.44
	binutils-csl-sourcerygxx-4_1-18:1.44
	binutils-csl-renesas-4_1-9:1.44
	gdb-csl-sourcerygxx-3_4_4-25:1.43
	binutils-csl-sourcerygxx-3_4_4-25:1.37
	nickrob-async-20060828-mergepoint:1.45
	gdb-csl-symbian-6_4_50_20060226-11:1.43
	binutils-csl-renesas-4_1-8:1.44
	binutils-csl-renesas-4_1-7:1.44
	binutils-csl-renesas-4_1-6:1.44
	gdb-csl-sourcerygxx-4_1-17:1.43
	binutils-csl-sourcerygxx-4_1-17:1.44
	gdb-csl-20060226-branch-local-2:1.43
	gdb-csl-sourcerygxx-4_1-14:1.43
	binutils-csl-sourcerygxx-4_1-14:1.44
	binutils-csl-sourcerygxx-4_1-15:1.44
	gdb-csl-sourcerygxx-4_1-13:1.43
	binutils-csl-sourcerygxx-4_1-13:1.44
	binutils-2_17:1.44
	gdb-csl-sourcerygxx-4_1-12:1.43
	binutils-csl-sourcerygxx-4_1-12:1.44
	gdb-csl-sourcerygxx-3_4_4-21:1.43
	binutils-csl-sourcerygxx-3_4_4-21:1.44
	gdb_6_5-20060621-release:1.44
	binutils-csl-wrs-linux-3_4_4-24:1.37
	binutils-csl-wrs-linux-3_4_4-23:1.37
	gdb-csl-sourcerygxx-4_1-9:1.43
	binutils-csl-sourcerygxx-4_1-9:1.44
	gdb-csl-sourcerygxx-4_1-8:1.43
	binutils-csl-sourcerygxx-4_1-8:1.44
	gdb-csl-sourcerygxx-4_1-7:1.43
	binutils-csl-sourcerygxx-4_1-7:1.44
	gdb-csl-arm-2006q1-6:1.43
	binutils-csl-arm-2006q1-6:1.44
	gdb-csl-sourcerygxx-4_1-6:1.43
	binutils-csl-sourcerygxx-4_1-6:1.44
	binutils-csl-wrs-linux-3_4_4-22:1.37
	gdb-csl-symbian-6_4_50_20060226-10:1.43
	gdb-csl-symbian-6_4_50_20060226-9:1.43
	gdb-csl-symbian-6_4_50_20060226-8:1.43
	gdb-csl-coldfire-4_1-11:1.43
	binutils-csl-coldfire-4_1-11:1.44
	gdb-csl-sourcerygxx-3_4_4-19:1.43
	binutils-csl-sourcerygxx-3_4_4-19:1.44
	gdb-csl-coldfire-4_1-10:1.43
	gdb_6_5-branch:1.44.0.14
	gdb_6_5-2006-05-14-branchpoint:1.44
	binutils-csl-coldfire-4_1-10:1.44
	gdb-csl-sourcerygxx-4_1-5:1.43
	binutils-csl-sourcerygxx-4_1-5:1.44
	nickrob-async-20060513-branch:1.44.0.12
	nickrob-async-20060513-branchpoint:1.44
	gdb-csl-sourcerygxx-4_1-4:1.43
	binutils-csl-sourcerygxx-4_1-4:1.44
	msnyder-reverse-20060502-branch:1.44.0.10
	msnyder-reverse-20060502-branchpoint:1.44
	binutils-csl-wrs-linux-3_4_4-21:1.37
	gdb-csl-morpho-4_1-4:1.43
	binutils-csl-morpho-4_1-4:1.44
	gdb-csl-sourcerygxx-3_4_4-17:1.43
	binutils-csl-sourcerygxx-3_4_4-17:1.44
	binutils-csl-wrs-linux-3_4_4-20:1.37
	readline_5_1-import-branch:1.44.0.8
	readline_5_1-import-branchpoint:1.44
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.43
	binutils-2_17-branch:1.44.0.6
	binutils-2_17-branchpoint:1.44
	gdb-csl-symbian-20060226-branch:1.43.0.16
	gdb-csl-symbian-20060226-branchpoint:1.43
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.43
	msnyder-reverse-20060331-branch:1.44.0.4
	msnyder-reverse-20060331-branchpoint:1.44
	binutils-csl-2_17-branch:1.44.0.2
	binutils-csl-2_17-branchpoint:1.44
	gdb-csl-available-20060303-branch:1.43.0.14
	gdb-csl-available-20060303-branchpoint:1.43
	gdb-csl-20060226-branch:1.43.0.12
	gdb-csl-20060226-branchpoint:1.43
	gdb_6_4-20051202-release:1.43
	msnyder-fork-checkpoint-branch:1.43.0.10
	msnyder-fork-checkpoint-branchpoint:1.43
	gdb-csl-gxxpro-6_3-branch:1.43.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.43
	gdb_6_4-branch:1.43.0.6
	gdb_6_4-2005-11-01-branchpoint:1.43
	gdb-csl-arm-20051020-branch:1.43.0.4
	gdb-csl-arm-20051020-branchpoint:1.43
	binutils-csl-gxxpro-3_4-branch:1.37.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.37
	binutils-2_16_1:1.37
	msnyder-tracepoint-checkpoint-branch:1.43.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.43
	gdb-csl-arm-20050325-2005-q1b:1.37
	binutils-csl-arm-2005q1b:1.37
	binutils-2_16:1.37
	gdb-csl-arm-20050325-2005-q1a:1.37
	binutils-csl-arm-2005q1a:1.37
	csl-arm-20050325-branch:1.37.0.6
	csl-arm-20050325-branchpoint:1.37
	binutils-csl-arm-2005q1-branch:1.37.0.4
	binutils-csl-arm-2005q1-branchpoint:1.37
	binutils-2_16-branch:1.37.0.2
	binutils-2_16-branchpoint:1.37
	csl-arm-2004-q3d:1.37
	gdb_6_3-20041109-release:1.36
	gdb_6_3-branch:1.36.0.2
	gdb_6_3-20041019-branchpoint:1.36
	csl-arm-2004-q3:1.36
	drow_intercu-merge-20040921:1.36
	drow_intercu-merge-20040915:1.35
	jimb-gdb_6_2-e500-branch:1.34.0.6
	jimb-gdb_6_2-e500-branchpoint:1.34
	gdb_6_2-20040730-release:1.34
	gdb_6_2-branch:1.34.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.34
	gdb_6_1_1-20040616-release:1.33
	binutils-2_15:1.33
	binutils-2_15-branchpoint:1.33
	csl-arm-2004-q1a:1.33
	csl-arm-2004-q1:1.33
	gdb_6_1-2004-04-05-release:1.33
	drow_intercu-merge-20040402:1.33
	drow_intercu-merge-20040327:1.33
	ezannoni_pie-20040323-branch:1.33.0.14
	ezannoni_pie-20040323-branchpoint:1.33
	cagney_tramp-20040321-mergepoint:1.33
	cagney_tramp-20040309-branch:1.33.0.12
	cagney_tramp-20040309-branchpoint:1.33
	gdb_6_1-branch:1.33.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.33
	drow_intercu-20040221-branch:1.33.0.8
	drow_intercu-20040221-branchpoint:1.33
	binutils-2_15-branch:1.33.0.6
	cagney_bfdfile-20040213-branch:1.33.0.4
	cagney_bfdfile-20040213-branchpoint:1.33
	drow-cplus-merge-20040208:1.33
	carlton_dictionary-20040126-merge:1.33
	cagney_bigcore-20040122-branch:1.33.0.2
	cagney_bigcore-20040122-branchpoint:1.33
	drow-cplus-merge-20040113:1.33
	csl-arm-2003-q4:1.33
	drow-cplus-merge-20031224:1.33
	drow-cplus-merge-20031220:1.33
	carlton_dictionary-20031215-merge:1.33
	drow-cplus-merge-20031214:1.33
	carlton-dictionary-20031111-merge:1.31
	gdb_6_0-2003-10-04-release:1.30
	kettenis_sparc-20030918-branch:1.31.0.6
	kettenis_sparc-20030918-branchpoint:1.31
	carlton_dictionary-20030917-merge:1.31
	ezannoni_pie-20030916-branchpoint:1.31
	ezannoni_pie-20030916-branch:1.31.0.4
	cagney_x86i386-20030821-branch:1.31.0.2
	cagney_x86i386-20030821-branchpoint:1.31
	carlton_dictionary-20030805-merge:1.31
	carlton_dictionary-20030627-merge:1.31
	gdb_6_0-branch:1.30.0.36
	gdb_6_0-2003-06-23-branchpoint:1.30
	jimb-ppc64-linux-20030613-branch:1.30.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.30
	binutils-2_14:1.30
	cagney_convert-20030606-branch:1.30.0.32
	cagney_convert-20030606-branchpoint:1.30
	cagney_writestrings-20030508-branch:1.30.0.30
	cagney_writestrings-20030508-branchpoint:1.30
	jimb-ppc64-linux-20030528-branch:1.30.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.30
	carlton_dictionary-20030523-merge:1.30
	cagney_fileio-20030521-branch:1.30.0.26
	cagney_fileio-20030521-branchpoint:1.30
	kettenis_i386newframe-20030517-mergepoint:1.30
	jimb-ppc64-linux-20030509-branch:1.30.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.30
	kettenis_i386newframe-20030504-mergepoint:1.30
	carlton_dictionary-20030430-merge:1.30
	binutils-2_14-branch:1.30.0.22
	binutils-2_14-branchpoint:1.30
	kettenis_i386newframe-20030419-branch:1.30.0.20
	kettenis_i386newframe-20030419-branchpoint:1.30
	carlton_dictionary-20030416-merge:1.30
	cagney_frameaddr-20030409-mergepoint:1.30
	kettenis_i386newframe-20030406-branch:1.30.0.18
	kettenis_i386newframe-20030406-branchpoint:1.30
	cagney_frameaddr-20030403-branchpoint:1.30
	cagney_frameaddr-20030403-branch:1.30.0.16
	cagney_framebase-20030330-mergepoint:1.30
	cagney_framebase-20030326-branch:1.30.0.14
	cagney_framebase-20030326-branchpoint:1.30
	cagney_lazyid-20030317-branch:1.30.0.12
	cagney_lazyid-20030317-branchpoint:1.30
	kettenis-i386newframe-20030316-mergepoint:1.30
	offbyone-20030313-branch:1.30.0.10
	offbyone-20030313-branchpoint:1.30
	kettenis-i386newframe-20030308-branch:1.30.0.8
	kettenis-i386newframe-20030308-branchpoint:1.30
	carlton_dictionary-20030305-merge:1.30
	cagney_offbyone-20030303-branch:1.30.0.6
	cagney_offbyone-20030303-branchpoint:1.30
	carlton_dictionary-20030207-merge:1.30
	interps-20030202-branch:1.30.0.4
	interps-20030202-branchpoint:1.30
	cagney-unwind-20030108-branch:1.30.0.2
	cagney-unwind-20030108-branchpoint:1.30
	binutils-2_13_2_1:1.27.2.2
	binutils-2_13_2:1.27.2.2
	carlton_dictionary-20021223-merge:1.30
	gdb_5_3-2002-12-12-release:1.28
	carlton_dictionary-20021115-merge:1.29
	binutils-2_13_1:1.27.2.2
	kseitz_interps-20021105-merge:1.29
	kseitz_interps-20021103-merge:1.29
	drow-cplus-merge-20021020:1.29
	drow-cplus-merge-20021025:1.29
	carlton_dictionary-20021025-merge:1.29
	carlton_dictionary-20021011-merge:1.29
	drow-cplus-branch:1.28.0.12
	drow-cplus-branchpoint:1.28
	kseitz_interps-20020930-merge:1.28
	carlton_dictionary-20020927-merge:1.28
	carlton_dictionary-branch:1.28.0.10
	carlton_dictionary-20020920-branchpoint:1.28
	sid-20020905-branchpoint:1.28
	sid-20020905-branch:1.28.0.8
	gdb_5_3-branch:1.28.0.6
	gdb_5_3-2002-09-04-branchpoint:1.28
	kseitz_interps-20020829-merge:1.28
	cagney_sysregs-20020825-branch:1.28.0.4
	cagney_sysregs-20020825-branchpoint:1.28
	readline_4_3-import-branch:1.28.0.2
	readline_4_3-import-branchpoint:1.28
	binutils-2_13:1.27
	gdb_5_2_1-2002-07-23-release:1.19
	binutils-2_13-branchpoint:1.27
	binutils-2_13-branch:1.27.0.2
	kseitz_interps-20020528-branch:1.25.0.6
	kseitz_interps-20020528-branchpoint:1.25
	cagney_regbuf-20020515-branch:1.25.0.4
	cagney_regbuf-20020515-branchpoint:1.25
	binutils-2_12_1:1.18.2.2
	jimb-macro-020506-branch:1.25.0.2
	jimb-macro-020506-branchpoint:1.25
	gdb_5_2-2002-04-29-release:1.19
	binutils-2_12:1.18
	gdb_5_2-branch:1.19.0.2
	gdb_5_2-2002-03-03-branchpoint:1.19
	binutils-2_12-branch:1.18.0.2
	binutils-2_12-branchpoint:1.18
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.4
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.2
	gdb_5_1-2001-07-29-branchpoint:1.11
	binutils-2_11_2:1.9.2.1
	binutils-2_11_1:1.9.2.1
	binutils-2_11:1.9
	x86_64versiong3:1.9
	binutils-2_11-branch:1.9.0.2
	insight-precleanup-2001-01-01:1.9
	binutils-2_10_1:1.4
	binutils-2_10:1.4
	gdb-premipsmulti-2000-06-06-branch:1.5.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.5
	gdb_5_0-2000-05-19-release:1.4
	gdb_4_18_2-2000-05-18-release:1.4
	gdb_4_95_1-2000-05-11-snapshot:1.4
	gdb_4_95_0-2000-04-27-snapshot:1.4
	gdb_5_0-2000-04-10-branch:1.4.0.4
	gdb_5_0-2000-04-10-branchpoint:1.4
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.84
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.84
date	2013.10.09.18.02.48;	author roland;	state Exp;
branches;
next	1.83;

1.83
date	2013.02.10.04.36.30;	author amodra;	state Exp;
branches
	1.83.4.1;
next	1.82;

1.82
date	2013.01.10.20.03.55;	author hjl;	state Exp;
branches;
next	1.81;

1.81
date	2011.06.13.00.59.15;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2011.05.18.08.00.08;	author gingold;	state Exp;
branches;
next	1.79;

1.79
date	2011.04.20.00.11.32;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2011.02.28.18.30.16;	author ktietz;	state Exp;
branches;
next	1.77;

1.77
date	2010.12.13.01.06.15;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2010.10.14.01.31.27;	author davek;	state Exp;
branches
	1.76.2.1;
next	1.75;

1.75
date	2010.05.26.07.37.36;	author gingold;	state Exp;
branches;
next	1.74;

1.74
date	2010.02.08.20.00.54;	author rsandifo;	state Exp;
branches;
next	1.73;

1.73
date	2010.01.01.18.06.06;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2010.01.01.13.42.26;	author brobecke;	state Exp;
branches;
next	1.71;

1.71
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2009.06.02.18.51.33;	author rsandifo;	state Exp;
branches;
next	1.68;

1.68
date	2009.04.16.23.06.59;	author rsandifo;	state Exp;
branches;
next	1.67;

1.67
date	2009.04.01.20.13.10;	author rsandifo;	state Exp;
branches;
next	1.66;

1.66
date	2009.04.01.20.09.02;	author rsandifo;	state Exp;
branches;
next	1.65;

1.65
date	2009.04.01.19.53.52;	author rsandifo;	state Exp;
branches;
next	1.64;

1.64
date	2009.04.01.19.38.11;	author rsandifo;	state Exp;
branches;
next	1.63;

1.63
date	2009.04.01.19.27.37;	author rsandifo;	state Exp;
branches;
next	1.62;

1.62
date	2009.04.01.19.05.53;	author rsandifo;	state Exp;
branches;
next	1.61;

1.61
date	2009.03.14.09.36.38;	author rsandifo;	state Exp;
branches;
next	1.60;

1.60
date	2009.03.14.09.36.11;	author rsandifo;	state Exp;
branches;
next	1.59;

1.59
date	2009.03.14.09.35.45;	author rsandifo;	state Exp;
branches;
next	1.58;

1.58
date	2009.03.14.09.35.06;	author rsandifo;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.14.09.34.27;	author rsandifo;	state Exp;
branches;
next	1.56;

1.56
date	2009.03.14.09.33.38;	author rsandifo;	state Exp;
branches;
next	1.55;

1.55
date	2009.03.14.09.32.56;	author rsandifo;	state Exp;
branches;
next	1.54;

1.54
date	2009.03.14.09.32.33;	author rsandifo;	state Exp;
branches;
next	1.53;

1.53
date	2009.03.14.09.32.06;	author rsandifo;	state Exp;
branches;
next	1.52;

1.52
date	2009.03.14.09.18.22;	author rsandifo;	state Exp;
branches;
next	1.51;

1.51
date	2009.03.14.09.17.56;	author rsandifo;	state Exp;
branches;
next	1.50;

1.50
date	2009.03.14.09.17.32;	author rsandifo;	state Exp;
branches;
next	1.49;

1.49
date	2009.03.14.09.15.34;	author rsandifo;	state Exp;
branches;
next	1.48;

1.48
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2007.07.03.14.26.43;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.04.15.53.41;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.04.11.00.23;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.04.07.19.39;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2005.05.03.17.05.50;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2005.05.03.01.05.03;	author hjl;	state Exp;
branches;
next	1.38;

1.38
date	2005.04.11.08.23.05;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.21.15.28.30;	author hjl;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.17.07.14.30;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2004.08.13.03.16.00;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2003.12.02.22.59.59;	author amodra;	state Exp;
branches
	1.33.8.1;
next	1.32;

1.32
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches;
next	1.31;

1.31
date	2003.06.25.06.40.22;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.10.11.08.33.11;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.06.11.24.40;	author amodra;	state Exp;
branches
	1.28.10.1
	1.28.12.1;
next	1.27;

1.27
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.06.07.15.04.49;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.30.04.32.51;	author trix;	state Exp;
branches
	1.25.4.1
	1.25.6.1;
next	1.24;

1.24
date	2002.04.26.13.43.10;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2002.04.04.19.53.38;	author drow;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.28.03.27.46;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.20.12.03.27;	author trix;	state Exp;
branches;
next	1.20;

1.20
date	2002.03.18.12.45.44;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2002.02.19.05.01.27;	author trix;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.05.13.11.31;	author amodra;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2002.01.03.22.06.38;	author trix;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.22.17.18.34;	author trix;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.20.23.30.37;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.06.15.20.00;	author trix;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.30.12.48.35;	author trix;	state Exp;
branches;
next	1.11;

1.11
date	2001.05.24.20.50.50;	author trix;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.30.08.04.42;	author kazu;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.09.06.21.21.51;	author geoffk;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.16.00.34.19;	author geoffk;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.16.20.35.08;	author nsd;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.26.15.09.43;	author cpopetz;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.01.19.40.54;	author hjl;	state Exp;
branches;
next	1.3;

1.3
date	99.07.12.10.30.21;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.19.14.08.46;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.83.4.1
date	2013.10.09.18.03.17;	author roland;	state Exp;
branches;
next	;

1.76.2.1
date	2011.02.01.12.25.34;	author amodra;	state Exp;
branches;
next	1.76.2.2;

1.76.2.2
date	2011.04.27.07.17.41;	author amodra;	state Exp;
branches;
next	;

1.33.8.1
date	2004.09.16.17.00.38;	author drow;	state Exp;
branches;
next	1.33.8.2;

1.33.8.2
date	2004.09.21.20.44.08;	author drow;	state Exp;
branches;
next	;

1.28.10.1
date	2002.10.11.22.22.50;	author carlton;	state Exp;
branches;
next	1.28.10.2;

1.28.10.2
date	2002.12.23.19.38.01;	author carlton;	state Exp;
branches;
next	1.28.10.3;

1.28.10.3
date	2003.06.27.21.49.31;	author carlton;	state Exp;
branches;
next	1.28.10.4;

1.28.10.4
date	2003.12.15.23.59.55;	author carlton;	state Exp;
branches;
next	;

1.28.12.1
date	2002.10.26.17.12.00;	author drow;	state Exp;
branches;
next	1.28.12.2;

1.28.12.2
date	2003.12.14.20.26.53;	author drow;	state Exp;
branches;
next	;

1.27.2.1
date	2002.09.23.22.12.42;	author drow;	state Exp;
branches;
next	1.27.2.2;

1.27.2.2
date	2002.10.11.08.56.14;	author amodra;	state Exp;
branches;
next	;

1.25.4.1
date	2002.06.15.16.42.42;	author cagney;	state Exp;
branches;
next	;

1.25.6.1
date	2002.06.20.01.31.19;	author kseitz;	state Exp;
branches;
next	1.25.6.2;

1.25.6.2
date	2002.07.22.21.46.49;	author kseitz;	state Exp;
branches;
next	1.25.6.3;

1.25.6.3
date	2002.08.09.18.34.18;	author kseitz;	state Exp;
branches;
next	1.25.6.4;

1.25.6.4
date	2002.11.03.22.01.38;	author ezannoni;	state Exp;
branches;
next	;

1.18.2.1
date	2002.04.04.14.53.01;	author amodra;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.04.27.08.30.16;	author amodra;	state Exp;
branches;
next	;

1.9.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.84
log
@bfd/
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Don't touch EREL in
	loop that doesn't use (or initialize) it.
@
text
@/* POWER/PowerPC XCOFF linker support.
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>, Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "coff/xcoff.h"
#include "libcoff.h"
#include "libxcoff.h"
#include "libiberty.h"

/* This file holds the XCOFF linker code.  */

#undef  STRING_SIZE_SIZE
#define STRING_SIZE_SIZE 4

/* We reuse the SEC_ROM flag as a mark flag for garbage collection.
   This flag will only be used on input sections.  */

#define SEC_MARK (SEC_ROM)

/* The list of import files.  */

struct xcoff_import_file
{
  /* The next entry in the list.  */
  struct xcoff_import_file *next;
  /* The path.  */
  const char *path;
  /* The file name.  */
  const char *file;
  /* The member name.  */
  const char *member;
};

/* Information we keep for each section in the output file during the
   final link phase.  */

struct xcoff_link_section_info
{
  /* The relocs to be output.  */
  struct internal_reloc *relocs;
  /* For each reloc against a global symbol whose index was not known
     when the reloc was handled, the global hash table entry.  */
  struct xcoff_link_hash_entry **rel_hashes;
  /* If there is a TOC relative reloc against a global symbol, and the
     index of the TOC symbol is not known when the reloc was handled,
     an entry is added to this linked list.  This is not an array,
     like rel_hashes, because this case is quite uncommon.  */
  struct xcoff_toc_rel_hash
  {
    struct xcoff_toc_rel_hash *next;
    struct xcoff_link_hash_entry *h;
    struct internal_reloc *rel;
  } *toc_rel_hashes;
};

/* Information that the XCOFF linker collects about an archive.  */
struct xcoff_archive_info
{
  /* The archive described by this entry.  */
  bfd *archive;

  /* The import path and import filename to use when referring to
     this archive in the .loader section.  */
  const char *imppath;
  const char *impfile;

  /* True if the archive contains a dynamic object.  */
  unsigned int contains_shared_object_p : 1;

  /* True if the previous field is valid.  */
  unsigned int know_contains_shared_object_p : 1;
};

struct xcoff_link_hash_table
{
  struct bfd_link_hash_table root;

  /* The .debug string hash table.  We need to compute this while
     reading the input files, so that we know how large the .debug
     section will be before we assign section positions.  */
  struct bfd_strtab_hash *debug_strtab;

  /* The .debug section we will use for the final output.  */
  asection *debug_section;

  /* The .loader section we will use for the final output.  */
  asection *loader_section;

  /* A count of non TOC relative relocs which will need to be
     allocated in the .loader section.  */
  size_t ldrel_count;

  /* The .loader section header.  */
  struct internal_ldhdr ldhdr;

  /* The .gl section we use to hold global linkage code.  */
  asection *linkage_section;

  /* The .tc section we use to hold toc entries we build for global
     linkage code.  */
  asection *toc_section;

  /* The .ds section we use to hold function descriptors which we
     create for exported symbols.  */
  asection *descriptor_section;

  /* The list of import files.  */
  struct xcoff_import_file *imports;

  /* Required alignment of sections within the output file.  */
  unsigned long file_align;

  /* Whether the .text section must be read-only.  */
  bfd_boolean textro;

  /* Whether -brtl was specified.  */
  bfd_boolean rtld;

  /* Whether garbage collection was done.  */
  bfd_boolean gc;

  /* A linked list of symbols for which we have size information.  */
  struct xcoff_link_size_list
  {
    struct xcoff_link_size_list *next;
    struct xcoff_link_hash_entry *h;
    bfd_size_type size;
  }
  *size_list;

  /* Information about archives.  */
  htab_t archive_info;

  /* Magic sections: _text, _etext, _data, _edata, _end, end. */
  asection *special_sections[XCOFF_NUMBER_OF_SPECIAL_SECTIONS];
};

/* Information that we pass around while doing the final link step.  */

struct xcoff_final_link_info
{
  /* General link information.  */
  struct bfd_link_info *info;
  /* Output BFD.  */
  bfd *output_bfd;
  /* Hash table for long symbol names.  */
  struct bfd_strtab_hash *strtab;
  /* Array of information kept for each output section, indexed by the
     target_index field.  */
  struct xcoff_link_section_info *section_info;
  /* Symbol index of last C_FILE symbol (-1 if none).  */
  long last_file_index;
  /* Contents of last C_FILE symbol.  */
  struct internal_syment last_file;
  /* Symbol index of TOC symbol.  */
  long toc_symindx;
  /* Start of .loader symbols.  */
  bfd_byte *ldsym;
  /* Next .loader reloc to swap out.  */
  bfd_byte *ldrel;
  /* File position of start of line numbers.  */
  file_ptr line_filepos;
  /* Buffer large enough to hold swapped symbols of any input file.  */
  struct internal_syment *internal_syms;
  /* Buffer large enough to hold output indices of symbols of any
     input file.  */
  long *sym_indices;
  /* Buffer large enough to hold output symbols for any input file.  */
  bfd_byte *outsyms;
  /* Buffer large enough to hold external line numbers for any input
     section.  */
  bfd_byte *linenos;
  /* Buffer large enough to hold any input section.  */
  bfd_byte *contents;
  /* Buffer large enough to hold external relocs of any input section.  */
  bfd_byte *external_relocs;
};

static bfd_boolean xcoff_mark (struct bfd_link_info *, asection *);



/* Routines to read XCOFF dynamic information.  This don't really
   belong here, but we already have the ldsym manipulation routines
   here.  */

/* Read the contents of a section.  */

static bfd_boolean
xcoff_get_section_contents (bfd *abfd, asection *sec)
{
  if (coff_section_data (abfd, sec) == NULL)
    {
      bfd_size_type amt = sizeof (struct coff_section_tdata);

      sec->used_by_bfd = bfd_zalloc (abfd, amt);
      if (sec->used_by_bfd == NULL)
	return FALSE;
    }

  if (coff_section_data (abfd, sec)->contents == NULL)
    {
      bfd_byte *contents;

      if (! bfd_malloc_and_get_section (abfd, sec, &contents))
	{
	  if (contents != NULL)
	    free (contents);
	  return FALSE;
	}
      coff_section_data (abfd, sec)->contents = contents;
    }

  return TRUE;
}

/* Get the size required to hold the dynamic symbols.  */

long
_bfd_xcoff_get_dynamic_symtab_upper_bound (bfd *abfd)
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  bfd_xcoff_swap_ldhdr_in (abfd, (void *) contents, &ldhdr);

  return (ldhdr.l_nsyms + 1) * sizeof (asymbol *);
}

/* Get the dynamic symbols.  */

long
_bfd_xcoff_canonicalize_dynamic_symtab (bfd *abfd, asymbol **psyms)
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  const char *strings;
  bfd_byte *elsym, *elsymend;
  coff_symbol_type *symbuf;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  coff_section_data (abfd, lsec)->keep_contents = TRUE;

  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);

  strings = (char *) contents + ldhdr.l_stoff;

  symbuf = bfd_zalloc (abfd, ldhdr.l_nsyms * sizeof (* symbuf));
  if (symbuf == NULL)
    return -1;

  elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);

  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);
  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz(abfd), symbuf++, psyms++)
    {
      struct internal_ldsym ldsym;

      bfd_xcoff_swap_ldsym_in (abfd, elsym, &ldsym);

      symbuf->symbol.the_bfd = abfd;

      if (ldsym._l._l_l._l_zeroes == 0)
	symbuf->symbol.name = strings + ldsym._l._l_l._l_offset;
      else
	{
	  char *c;

	  c = bfd_alloc (abfd, (bfd_size_type) SYMNMLEN + 1);
	  if (c == NULL)
	    return -1;
	  memcpy (c, ldsym._l._l_name, SYMNMLEN);
	  c[SYMNMLEN] = '\0';
	  symbuf->symbol.name = c;
	}

      if (ldsym.l_smclas == XMC_XO)
	symbuf->symbol.section = bfd_abs_section_ptr;
      else
	symbuf->symbol.section = coff_section_from_bfd_index (abfd,
							      ldsym.l_scnum);
      symbuf->symbol.value = ldsym.l_value - symbuf->symbol.section->vma;

      symbuf->symbol.flags = BSF_NO_FLAGS;
      if ((ldsym.l_smtype & L_EXPORT) != 0)
	{
	  if ((ldsym.l_smtype & L_WEAK) != 0)
	    symbuf->symbol.flags |= BSF_WEAK;
	  else
	    symbuf->symbol.flags |= BSF_GLOBAL;
	}

      /* FIXME: We have no way to record the other information stored
	 with the loader symbol.  */
      *psyms = (asymbol *) symbuf;
    }

  *psyms = NULL;

  return ldhdr.l_nsyms;
}

/* Get the size required to hold the dynamic relocs.  */

long
_bfd_xcoff_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  bfd_xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);

  return (ldhdr.l_nreloc + 1) * sizeof (arelent *);
}

/* Get the dynamic relocs.  */

long
_bfd_xcoff_canonicalize_dynamic_reloc (bfd *abfd,
				       arelent **prelocs,
				       asymbol **syms)
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  arelent *relbuf;
  bfd_byte *elrel, *elrelend;

  if ((abfd->flags & DYNAMIC) == 0)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      bfd_set_error (bfd_error_no_symbols);
      return -1;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return -1;
  contents = coff_section_data (abfd, lsec)->contents;

  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);

  relbuf = bfd_alloc (abfd, ldhdr.l_nreloc * sizeof (arelent));
  if (relbuf == NULL)
    return -1;

  elrel = contents + bfd_xcoff_loader_reloc_offset(abfd, &ldhdr);

  elrelend = elrel + ldhdr.l_nreloc * bfd_xcoff_ldrelsz(abfd);
  for (; elrel < elrelend; elrel += bfd_xcoff_ldrelsz(abfd), relbuf++,
	 prelocs++)
    {
      struct internal_ldrel ldrel;

      bfd_xcoff_swap_ldrel_in (abfd, elrel, &ldrel);

      if (ldrel.l_symndx >= 3)
	relbuf->sym_ptr_ptr = syms + (ldrel.l_symndx - 3);
      else
	{
	  const char *name;
	  asection *sec;

	  switch (ldrel.l_symndx)
	    {
	    case 0:
	      name = ".text";
	      break;
	    case 1:
	      name = ".data";
	      break;
	    case 2:
	      name = ".bss";
	      break;
	    default:
	      abort ();
	      break;
	    }

	  sec = bfd_get_section_by_name (abfd, name);
	  if (sec == NULL)
	    {
	      bfd_set_error (bfd_error_bad_value);
	      return -1;
	    }

	  relbuf->sym_ptr_ptr = sec->symbol_ptr_ptr;
	}

      relbuf->address = ldrel.l_vaddr;
      relbuf->addend = 0;

      /* Most dynamic relocs have the same type.  FIXME: This is only
	 correct if ldrel.l_rtype == 0.  In other cases, we should use
	 a different howto.  */
      relbuf->howto = bfd_xcoff_dynamic_reloc_howto(abfd);

      /* FIXME: We have no way to record the l_rsecnm field.  */

      *prelocs = relbuf;
    }

  *prelocs = NULL;

  return ldhdr.l_nreloc;
}

/* Hash functions for xcoff_link_hash_table's archive_info.  */

static hashval_t
xcoff_archive_info_hash (const void *data)
{
  const struct xcoff_archive_info *info;

  info = (const struct xcoff_archive_info *) data;
  return htab_hash_pointer (info->archive);
}

static int
xcoff_archive_info_eq (const void *data1, const void *data2)
{
  const struct xcoff_archive_info *info1;
  const struct xcoff_archive_info *info2;

  info1 = (const struct xcoff_archive_info *) data1;
  info2 = (const struct xcoff_archive_info *) data2;
  return info1->archive == info2->archive;
}

/* Return information about archive ARCHIVE.  Return NULL on error.  */

static struct xcoff_archive_info *
xcoff_get_archive_info (struct bfd_link_info *info, bfd *archive)
{
  struct xcoff_link_hash_table *htab;
  struct xcoff_archive_info *entryp, entry;
  void **slot;

  htab = xcoff_hash_table (info);
  entry.archive = archive;
  slot = htab_find_slot (htab->archive_info, &entry, INSERT);
  if (!slot)
    return NULL;

  entryp = *slot;
  if (!entryp)
    {
      entryp = bfd_zalloc (archive, sizeof (entry));
      if (!entryp)
	return NULL;

      entryp->archive = archive;
      *slot = entryp;
    }
  return entryp;
}

/* Routine to create an entry in an XCOFF link hash table.  */

static struct bfd_hash_entry *
xcoff_link_hash_newfunc (struct bfd_hash_entry *entry,
			 struct bfd_hash_table *table,
			 const char *string)
{
  struct xcoff_link_hash_entry *ret = (struct xcoff_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = bfd_hash_allocate (table, sizeof (* ret));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct xcoff_link_hash_entry *)
	 _bfd_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				 table, string));
  if (ret != NULL)
    {
      /* Set local fields.  */
      ret->indx = -1;
      ret->toc_section = NULL;
      ret->u.toc_indx = -1;
      ret->descriptor = NULL;
      ret->ldsym = NULL;
      ret->ldindx = -1;
      ret->flags = 0;
      ret->smclas = XMC_UA;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create a XCOFF link hash table.  */

struct bfd_link_hash_table *
_bfd_xcoff_bfd_link_hash_table_create (bfd *abfd)
{
  struct xcoff_link_hash_table *ret;
  bfd_size_type amt = sizeof (* ret);

  ret = bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;
  if (!_bfd_link_hash_table_init (&ret->root, abfd, xcoff_link_hash_newfunc,
				  sizeof (struct xcoff_link_hash_entry)))
    {
      free (ret);
      return NULL;
    }

  ret->debug_strtab = _bfd_xcoff_stringtab_init ();
  ret->archive_info = htab_create (37, xcoff_archive_info_hash,
				   xcoff_archive_info_eq, NULL);

  /* The linker will always generate a full a.out header.  We need to
     record that fact now, before the sizeof_headers routine could be
     called.  */
  xcoff_data (abfd)->full_aouthdr = TRUE;

  return &ret->root;
}

/* Free a XCOFF link hash table.  */

void
_bfd_xcoff_bfd_link_hash_table_free (struct bfd_link_hash_table *hash)
{
  struct xcoff_link_hash_table *ret = (struct xcoff_link_hash_table *) hash;

  _bfd_stringtab_free (ret->debug_strtab);
  bfd_hash_table_free (&ret->root.table);
  free (ret);
}

/* Read internal relocs for an XCOFF csect.  This is a wrapper around
   _bfd_coff_read_internal_relocs which tries to take advantage of any
   relocs which may have been cached for the enclosing section.  */

static struct internal_reloc *
xcoff_read_internal_relocs (bfd *abfd,
			    asection *sec,
			    bfd_boolean cache,
			    bfd_byte *external_relocs,
			    bfd_boolean require_internal,
			    struct internal_reloc *internal_relocs)
{
  if (coff_section_data (abfd, sec) != NULL
      && coff_section_data (abfd, sec)->relocs == NULL
      && xcoff_section_data (abfd, sec) != NULL)
    {
      asection *enclosing;

      enclosing = xcoff_section_data (abfd, sec)->enclosing;

      if (enclosing != NULL
	  && (coff_section_data (abfd, enclosing) == NULL
	      || coff_section_data (abfd, enclosing)->relocs == NULL)
	  && cache
	  && enclosing->reloc_count > 0)
	{
	  if (_bfd_coff_read_internal_relocs (abfd, enclosing, TRUE,
					      external_relocs, FALSE, NULL)
	      == NULL)
	    return NULL;
	}

      if (enclosing != NULL
	  && coff_section_data (abfd, enclosing) != NULL
	  && coff_section_data (abfd, enclosing)->relocs != NULL)
	{
	  size_t off;

	  off = ((sec->rel_filepos - enclosing->rel_filepos)
		 / bfd_coff_relsz (abfd));

	  if (! require_internal)
	    return coff_section_data (abfd, enclosing)->relocs + off;
	  memcpy (internal_relocs,
		  coff_section_data (abfd, enclosing)->relocs + off,
		  sec->reloc_count * sizeof (struct internal_reloc));
	  return internal_relocs;
	}
    }

  return _bfd_coff_read_internal_relocs (abfd, sec, cache, external_relocs,
					 require_internal, internal_relocs);
}

/* Split FILENAME into an import path and an import filename,
   storing them in *IMPPATH and *IMPFILE respectively.  */

bfd_boolean
bfd_xcoff_split_import_path (bfd *abfd, const char *filename,
			     const char **imppath, const char **impfile)
{
  const char *base;
  size_t length;
  char *path;

  base = lbasename (filename);
  length = base - filename;
  if (length == 0)
    /* The filename has no directory component, so use an empty path.  */
    *imppath = "";
  else if (length == 1)
    /* The filename is in the root directory.  */
    *imppath = "/";
  else
    {
      /* Extract the (non-empty) directory part.  Note that we don't
	 need to strip duplicate directory separators from any part
	 of the string; the native linker doesn't do that either.  */
      path = bfd_alloc (abfd, length);
      if (path == NULL)
	return FALSE;
      memcpy (path, filename, length - 1);
      path[length - 1] = 0;
      *imppath = path;
    }
  *impfile = base;
  return TRUE;
}

/* Set ARCHIVE's import path as though its filename had been given
   as FILENAME.  */

bfd_boolean
bfd_xcoff_set_archive_import_path (struct bfd_link_info *info,
				   bfd *archive, const char *filename)
{
  struct xcoff_archive_info *archive_info;

  archive_info = xcoff_get_archive_info (info, archive);
  return (archive_info != NULL
	  && bfd_xcoff_split_import_path (archive, filename,
					  &archive_info->imppath,
					  &archive_info->impfile));
}

/* H is an imported symbol.  Set the import module's path, file and member
   to IMPATH, IMPFILE and IMPMEMBER respectively.  All three are null if
   no specific import module is specified.  */

static bfd_boolean
xcoff_set_import_path (struct bfd_link_info *info,
		       struct xcoff_link_hash_entry *h,
		       const char *imppath, const char *impfile,
		       const char *impmember)
{
  unsigned int c;
  struct xcoff_import_file **pp;

  /* We overload the ldindx field to hold the l_ifile value for this
     symbol.  */
  BFD_ASSERT (h->ldsym == NULL);
  BFD_ASSERT ((h->flags & XCOFF_BUILT_LDSYM) == 0);
  if (imppath == NULL)
    h->ldindx = -1;
  else
    {
      /* We start c at 1 because the first entry in the import list is
	 reserved for the library search path.  */
      for (pp = &xcoff_hash_table (info)->imports, c = 1;
	   *pp != NULL;
	   pp = &(*pp)->next, ++c)
	{
	  if (filename_cmp ((*pp)->path, imppath) == 0
	      && filename_cmp ((*pp)->file, impfile) == 0
	      && filename_cmp ((*pp)->member, impmember) == 0)
	    break;
	}

      if (*pp == NULL)
	{
	  struct xcoff_import_file *n;
	  bfd_size_type amt = sizeof (* n);

	  n = bfd_alloc (info->output_bfd, amt);
	  if (n == NULL)
	    return FALSE;
	  n->next = NULL;
	  n->path = imppath;
	  n->file = impfile;
	  n->member = impmember;
	  *pp = n;
	}
      h->ldindx = c;
    }
  return TRUE;
}

/* H is the bfd symbol associated with exported .loader symbol LDSYM.
   Return true if LDSYM defines H.  */

static bfd_boolean
xcoff_dynamic_definition_p (struct xcoff_link_hash_entry *h,
			    struct internal_ldsym *ldsym)
{
  /* If we didn't know about H before processing LDSYM, LDSYM
     definitely defines H.  */
  if (h->root.type == bfd_link_hash_new)
    return TRUE;

  /* If H is currently a weak dynamic symbol, and if LDSYM is a strong
     dynamic symbol, LDSYM trumps the current definition of H.  */
  if ((ldsym->l_smtype & L_WEAK) == 0
      && (h->flags & XCOFF_DEF_DYNAMIC) != 0
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->root.type == bfd_link_hash_defweak
	  || h->root.type == bfd_link_hash_undefweak))
    return TRUE;

  /* If H is currently undefined, LDSYM defines it.  */
  if ((h->flags & XCOFF_DEF_DYNAMIC) == 0
      && (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak))
    return TRUE;

  return FALSE;
}

/* This function is used to add symbols from a dynamic object to the
   global symbol table.  */

static bfd_boolean
xcoff_link_add_dynamic_symbols (bfd *abfd, struct bfd_link_info *info)
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  const char *strings;
  bfd_byte *elsym, *elsymend;
  struct xcoff_import_file *n;
  unsigned int c;
  struct xcoff_import_file **pp;

  /* We can only handle a dynamic object if we are generating an XCOFF
     output file.  */
   if (info->output_bfd->xvec != abfd->xvec)
    {
      (*_bfd_error_handler)
	(_("%s: XCOFF shared object when not producing XCOFF output"),
	 bfd_get_filename (abfd));
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* The symbols we use from a dynamic object are not the symbols in
     the normal symbol table, but, rather, the symbols in the export
     table.  If there is a global symbol in a dynamic object which is
     not in the export table, the loader will not be able to find it,
     so we don't want to find it either.  Also, on AIX 4.1.3, shr.o in
     libc.a has symbols in the export table which are not in the
     symbol table.  */

  /* Read in the .loader section.  FIXME: We should really use the
     o_snloader field in the a.out header, rather than grabbing the
     section by name.  */
  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    {
      (*_bfd_error_handler)
	(_("%s: dynamic object with no .loader section"),
	 bfd_get_filename (abfd));
      bfd_set_error (bfd_error_no_symbols);
      return FALSE;
    }

  if (! xcoff_get_section_contents (abfd, lsec))
    return FALSE;
  contents = coff_section_data (abfd, lsec)->contents;

  /* Remove the sections from this object, so that they do not get
     included in the link.  */
  bfd_section_list_clear (abfd);

  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);

  strings = (char *) contents + ldhdr.l_stoff;

  elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);

  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);

  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz(abfd))
    {
      struct internal_ldsym ldsym;
      char nambuf[SYMNMLEN + 1];
      const char *name;
      struct xcoff_link_hash_entry *h;

      bfd_xcoff_swap_ldsym_in (abfd, elsym, &ldsym);

      /* We are only interested in exported symbols.  */
      if ((ldsym.l_smtype & L_EXPORT) == 0)
	continue;

      if (ldsym._l._l_l._l_zeroes == 0)
	name = strings + ldsym._l._l_l._l_offset;
      else
	{
	  memcpy (nambuf, ldsym._l._l_name, SYMNMLEN);
	  nambuf[SYMNMLEN] = '\0';
	  name = nambuf;
	}

      /* Normally we could not call xcoff_link_hash_lookup in an add
	 symbols routine, since we might not be using an XCOFF hash
	 table.  However, we verified above that we are using an XCOFF
	 hash table.  */

      h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE,
				  TRUE, TRUE);
      if (h == NULL)
	return FALSE;

      if (!xcoff_dynamic_definition_p (h, &ldsym))
	continue;

      h->flags |= XCOFF_DEF_DYNAMIC;
      h->smclas = ldsym.l_smclas;
      if (h->smclas == XMC_XO)
	{
	  /* This symbol has an absolute value.  */
	  if ((ldsym.l_smtype & L_WEAK) != 0)
	    h->root.type = bfd_link_hash_defweak;
	  else
	    h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = bfd_abs_section_ptr;
	  h->root.u.def.value = ldsym.l_value;
	}
      else
	{
	  /* Otherwise, we don't bother to actually define the symbol,
	     since we don't have a section to put it in anyhow.
	     We assume instead that an undefined XCOFF_DEF_DYNAMIC symbol
	     should be imported from the symbol's undef.abfd.  */
	  if ((ldsym.l_smtype & L_WEAK) != 0)
	    h->root.type = bfd_link_hash_undefweak;
	  else
	    h->root.type = bfd_link_hash_undefined;
	  h->root.u.undef.abfd = abfd;
	}

      /* If this symbol defines a function descriptor, then it
	 implicitly defines the function code as well.  */
      if (h->smclas == XMC_DS
	  || (h->smclas == XMC_XO && name[0] != '.'))
	h->flags |= XCOFF_DESCRIPTOR;
      if ((h->flags & XCOFF_DESCRIPTOR) != 0)
	{
	  struct xcoff_link_hash_entry *hds;

	  hds = h->descriptor;
	  if (hds == NULL)
	    {
	      char *dsnm;

	      dsnm = bfd_malloc ((bfd_size_type) strlen (name) + 2);
	      if (dsnm == NULL)
		return FALSE;
	      dsnm[0] = '.';
	      strcpy (dsnm + 1, name);
	      hds = xcoff_link_hash_lookup (xcoff_hash_table (info), dsnm,
					    TRUE, TRUE, TRUE);
	      free (dsnm);
	      if (hds == NULL)
		return FALSE;

	      hds->descriptor = h;
	      h->descriptor = hds;
	    }

	  if (xcoff_dynamic_definition_p (hds, &ldsym))
	    {
	      hds->root.type = h->root.type;
	      hds->flags |= XCOFF_DEF_DYNAMIC;
	      if (h->smclas == XMC_XO)
		{
		  /* An absolute symbol appears to actually define code, not a
		     function descriptor.  This is how some math functions are
		     implemented on AIX 4.1.  */
		  hds->smclas = XMC_XO;
		  hds->root.u.def.section = bfd_abs_section_ptr;
		  hds->root.u.def.value = ldsym.l_value;
		}
	      else
		{
		  hds->smclas = XMC_PR;
		  hds->root.u.undef.abfd = abfd;
		  /* We do not want to add this to the undefined
		     symbol list.  */
		}
	    }
	}
    }

  if (contents != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
    {
      free (coff_section_data (abfd, lsec)->contents);
      coff_section_data (abfd, lsec)->contents = NULL;
    }

  /* Record this file in the import files.  */
  n = bfd_alloc (abfd, (bfd_size_type) sizeof (struct xcoff_import_file));
  if (n == NULL)
    return FALSE;
  n->next = NULL;

  if (abfd->my_archive == NULL)
    {
      if (!bfd_xcoff_split_import_path (abfd, abfd->filename,
					&n->path, &n->file))
	return FALSE;
      n->member = "";
    }
  else
    {
      struct xcoff_archive_info *archive_info;

      archive_info = xcoff_get_archive_info (info, abfd->my_archive);
      if (!archive_info->impfile)
	{
	  if (!bfd_xcoff_split_import_path (archive_info->archive,
					    archive_info->archive->filename,
					    &archive_info->imppath,
					    &archive_info->impfile))
	    return FALSE;
	}
      n->path = archive_info->imppath;
      n->file = archive_info->impfile;
      n->member = bfd_get_filename (abfd);
    }

  /* We start c at 1 because the first import file number is reserved
     for LIBPATH.  */
  for (pp = &xcoff_hash_table (info)->imports, c = 1;
       *pp != NULL;
       pp = &(*pp)->next, ++c)
    ;
  *pp = n;

  xcoff_data (abfd)->import_file_id = c;

  return TRUE;
}

/* xcoff_link_create_extra_sections

   Takes care of creating the .loader, .gl, .ds, .debug and sections.  */

static bfd_boolean
xcoff_link_create_extra_sections (bfd * abfd, struct bfd_link_info *info)
{
  bfd_boolean return_value = FALSE;

  if (info->output_bfd->xvec == abfd->xvec)
    {
      /* We need to build a .loader section, so we do it here.  This
	 won't work if we're producing an XCOFF output file with no
	 XCOFF input files.  FIXME.  */

      if (!info->relocatable
	  && xcoff_hash_table (info)->loader_section == NULL)
	{
	  asection *lsec;
	  flagword flags = SEC_HAS_CONTENTS | SEC_IN_MEMORY;

	  lsec = bfd_make_section_anyway_with_flags (abfd, ".loader", flags);
	  if (lsec == NULL)
	    goto end_return;

	  xcoff_hash_table (info)->loader_section = lsec;
	}

      /* Likewise for the linkage section.  */
      if (xcoff_hash_table (info)->linkage_section == NULL)
	{
	  asection *lsec;
	  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_IN_MEMORY);

	  lsec = bfd_make_section_anyway_with_flags (abfd, ".gl", flags);
	  if (lsec == NULL)
	    goto end_return;

	  xcoff_hash_table (info)->linkage_section = lsec;
	  lsec->alignment_power = 2;
	}

      /* Likewise for the TOC section.  */
      if (xcoff_hash_table (info)->toc_section == NULL)
	{
	  asection *tsec;
	  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_IN_MEMORY);

	  tsec = bfd_make_section_anyway_with_flags (abfd, ".tc", flags);
	  if (tsec == NULL)
	    goto end_return;

	  xcoff_hash_table (info)->toc_section = tsec;
	  tsec->alignment_power = 2;
	}

      /* Likewise for the descriptor section.  */
      if (xcoff_hash_table (info)->descriptor_section == NULL)
	{
	  asection *dsec;
	  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_IN_MEMORY);

	  dsec = bfd_make_section_anyway_with_flags (abfd, ".ds", flags);
	  if (dsec == NULL)
	    goto end_return;

	  xcoff_hash_table (info)->descriptor_section = dsec;
	  dsec->alignment_power = 2;
	}

      /* Likewise for the .debug section.  */
      if (xcoff_hash_table (info)->debug_section == NULL
	  && info->strip != strip_all)
	{
	  asection *dsec;
	  flagword flags = SEC_HAS_CONTENTS | SEC_IN_MEMORY;

	  dsec = bfd_make_section_anyway_with_flags (abfd, ".debug", flags);
	  if (dsec == NULL)
	    goto end_return;

	  xcoff_hash_table (info)->debug_section = dsec;
	}
    }

  return_value = TRUE;

 end_return:

  return return_value;
}

/* Returns the index of reloc in RELOCS with the least address greater
   than or equal to ADDRESS.  The relocs are sorted by address.  */

static bfd_size_type
xcoff_find_reloc (struct internal_reloc *relocs,
		  bfd_size_type count,
		  bfd_vma address)
{
  bfd_size_type min, max, this;

  if (count < 2)
    {
      if (count == 1 && relocs[0].r_vaddr < address)
	return 1;
      else
	return 0;
    }

  min = 0;
  max = count;

  /* Do a binary search over (min,max].  */
  while (min + 1 < max)
    {
      bfd_vma raddr;

      this = (max + min) / 2;
      raddr = relocs[this].r_vaddr;
      if (raddr > address)
	max = this;
      else if (raddr < address)
	min = this;
      else
	{
	  min = this;
	  break;
	}
    }

  if (relocs[min].r_vaddr < address)
    return min + 1;

  while (min > 0
	 && relocs[min - 1].r_vaddr == address)
    --min;

  return min;
}

/* Add all the symbols from an object file to the hash table.

   XCOFF is a weird format.  A normal XCOFF .o files will have three
   COFF sections--.text, .data, and .bss--but each COFF section will
   contain many csects.  These csects are described in the symbol
   table.  From the linker's point of view, each csect must be
   considered a section in its own right.  For example, a TOC entry is
   handled as a small XMC_TC csect.  The linker must be able to merge
   different TOC entries together, which means that it must be able to
   extract the XMC_TC csects from the .data section of the input .o
   file.

   From the point of view of our linker, this is, of course, a hideous
   nightmare.  We cope by actually creating sections for each csect,
   and discarding the original sections.  We then have to handle the
   relocation entries carefully, since the only way to tell which
   csect they belong to is to examine the address.  */

static bfd_boolean
xcoff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  unsigned int n_tmask;
  unsigned int n_btshft;
  bfd_boolean default_copy;
  bfd_size_type symcount;
  struct xcoff_link_hash_entry **sym_hash;
  asection **csect_cache;
  unsigned int *lineno_counts;
  bfd_size_type linesz;
  asection *o;
  asection *last_real;
  bfd_boolean keep_syms;
  asection *csect;
  unsigned int csect_index;
  asection *first_csect;
  bfd_size_type symesz;
  bfd_byte *esym;
  bfd_byte *esym_end;
  struct reloc_info_struct
  {
    struct internal_reloc *relocs;
    asection **csects;
    bfd_byte *linenos;
  } *reloc_info = NULL;
  bfd_size_type amt;

  keep_syms = obj_coff_keep_syms (abfd);

  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link)
    {
      if (! xcoff_link_add_dynamic_symbols (abfd, info))
	return FALSE;
    }

  /* Create the loader, toc, gl, ds and debug sections, if needed.  */
  if (! xcoff_link_create_extra_sections (abfd, info))
    goto error_return;

  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link)
    return TRUE;

  n_tmask = coff_data (abfd)->local_n_tmask;
  n_btshft = coff_data (abfd)->local_n_btshft;

  /* Define macros so that ISFCN, et. al., macros work correctly.  */
#define N_TMASK n_tmask
#define N_BTSHFT n_btshft

  if (info->keep_memory)
    default_copy = FALSE;
  else
    default_copy = TRUE;

  symcount = obj_raw_syment_count (abfd);

  /* We keep a list of the linker hash table entries that correspond
     to each external symbol.  */
  amt = symcount * sizeof (struct xcoff_link_hash_entry *);
  sym_hash = bfd_zalloc (abfd, amt);
  if (sym_hash == NULL && symcount != 0)
    goto error_return;
  coff_data (abfd)->sym_hashes = (struct coff_link_hash_entry **) sym_hash;

  /* Because of the weird stuff we are doing with XCOFF csects, we can
     not easily determine which section a symbol is in, so we store
     the information in the tdata for the input file.  */
  amt = symcount * sizeof (asection *);
  csect_cache = bfd_zalloc (abfd, amt);
  if (csect_cache == NULL && symcount != 0)
    goto error_return;
  xcoff_data (abfd)->csects = csect_cache;

  /* We garbage-collect line-number information on a symbol-by-symbol
     basis, so we need to have quick access to the number of entries
     per symbol.  */
  amt = symcount * sizeof (unsigned int);
  lineno_counts = bfd_zalloc (abfd, amt);
  if (lineno_counts == NULL && symcount != 0)
    goto error_return;
  xcoff_data (abfd)->lineno_counts = lineno_counts;

  /* While splitting sections into csects, we need to assign the
     relocs correctly.  The relocs and the csects must both be in
     order by VMA within a given section, so we handle this by
     scanning along the relocs as we process the csects.  We index
     into reloc_info using the section target_index.  */
  amt = abfd->section_count + 1;
  amt *= sizeof (struct reloc_info_struct);
  reloc_info = bfd_zmalloc (amt);
  if (reloc_info == NULL)
    goto error_return;

  /* Read in the relocs and line numbers for each section.  */
  linesz = bfd_coff_linesz (abfd);
  last_real = NULL;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      last_real = o;

      if ((o->flags & SEC_RELOC) != 0)
	{
	  reloc_info[o->target_index].relocs =
	    xcoff_read_internal_relocs (abfd, o, TRUE, NULL, FALSE, NULL);
	  amt = o->reloc_count;
	  amt *= sizeof (asection *);
	  reloc_info[o->target_index].csects = bfd_zmalloc (amt);
	  if (reloc_info[o->target_index].csects == NULL)
	    goto error_return;
	}

      if ((info->strip == strip_none || info->strip == strip_some)
	  && o->lineno_count > 0)
	{
	  bfd_byte *linenos;

	  amt = linesz * o->lineno_count;
	  linenos = bfd_malloc (amt);
	  if (linenos == NULL)
	    goto error_return;
	  reloc_info[o->target_index].linenos = linenos;
	  if (bfd_seek (abfd, o->line_filepos, SEEK_SET) != 0
	      || bfd_bread (linenos, amt, abfd) != amt)
	    goto error_return;
	}
    }

  /* Don't let the linker relocation routines discard the symbols.  */
  obj_coff_keep_syms (abfd) = TRUE;

  csect = NULL;
  csect_index = 0;
  first_csect = NULL;

  symesz = bfd_coff_symesz (abfd);
  BFD_ASSERT (symesz == bfd_coff_auxesz (abfd));
  esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esym_end = esym + symcount * symesz;

  while (esym < esym_end)
    {
      struct internal_syment sym;
      union internal_auxent aux;
      const char *name;
      char buf[SYMNMLEN + 1];
      int smtyp;
      asection *section;
      bfd_vma value;
      struct xcoff_link_hash_entry *set_toc;

      bfd_coff_swap_sym_in (abfd, (void *) esym, (void *) &sym);

      /* In this pass we are only interested in symbols with csect
	 information.  */
      if (!CSECT_SYM_P (sym.n_sclass))
	{
	  /* Set csect_cache,
	     Normally csect is a .pr, .rw  etc. created in the loop
	     If C_FILE or first time, handle special

	     Advance esym, sym_hash, csect_hash ptrs.  */
	  if (sym.n_sclass == C_FILE || sym.n_sclass == C_DWARF)
	    csect = NULL;
	  if (csect != NULL)
	    *csect_cache = csect;
	  else if (first_csect == NULL
                   || sym.n_sclass == C_FILE || sym.n_sclass == C_DWARF)
	    *csect_cache = coff_section_from_bfd_index (abfd, sym.n_scnum);
	  else
	    *csect_cache = NULL;
	  esym += (sym.n_numaux + 1) * symesz;
	  sym_hash += sym.n_numaux + 1;
	  csect_cache += sym.n_numaux + 1;
	  lineno_counts += sym.n_numaux + 1;

	  continue;
	}

      name = _bfd_coff_internal_syment_name (abfd, &sym, buf);

      if (name == NULL)
	goto error_return;

      /* If this symbol has line number information attached to it,
	 and we're not stripping it, count the number of entries and
	 add them to the count for this csect.  In the final link pass
	 we are going to attach line number information by symbol,
	 rather than by section, in order to more easily handle
	 garbage collection.  */
      if ((info->strip == strip_none || info->strip == strip_some)
	  && sym.n_numaux > 1
	  && csect != NULL
	  && ISFCN (sym.n_type))
	{
	  union internal_auxent auxlin;

	  bfd_coff_swap_aux_in (abfd, (void *) (esym + symesz),
				sym.n_type, sym.n_sclass,
				0, sym.n_numaux, (void *) &auxlin);

	  if (auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr != 0)
	    {
	      asection *enclosing;
	      bfd_signed_vma linoff;

	      enclosing = xcoff_section_data (abfd, csect)->enclosing;
	      if (enclosing == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%B: `%s' has line numbers but no enclosing section"),
		     abfd, name);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}
	      linoff = (auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr
			- enclosing->line_filepos);
	      /* Explicit cast to bfd_signed_vma for compiler.  */
	      if (linoff < (bfd_signed_vma) (enclosing->lineno_count * linesz))
		{
		  struct internal_lineno lin;
		  bfd_byte *linpstart;

		  linpstart = (reloc_info[enclosing->target_index].linenos
			       + linoff);
		  bfd_coff_swap_lineno_in (abfd, (void *) linpstart, (void *) &lin);
		  if (lin.l_lnno == 0
		      && ((bfd_size_type) lin.l_addr.l_symndx
			  == ((esym
			       - (bfd_byte *) obj_coff_external_syms (abfd))
			      / symesz)))
		    {
		      bfd_byte *linpend, *linp;

		      linpend = (reloc_info[enclosing->target_index].linenos
				 + enclosing->lineno_count * linesz);
		      for (linp = linpstart + linesz;
			   linp < linpend;
			   linp += linesz)
			{
			  bfd_coff_swap_lineno_in (abfd, (void *) linp,
						   (void *) &lin);
			  if (lin.l_lnno == 0)
			    break;
			}
		      *lineno_counts = (linp - linpstart) / linesz;
		      /* The setting of line_filepos will only be
			 useful if all the line number entries for a
			 csect are contiguous; this only matters for
			 error reporting.  */
		      if (csect->line_filepos == 0)
			csect->line_filepos =
			  auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr;
		    }
		}
	    }
	}

      /* Pick up the csect auxiliary information.  */
      if (sym.n_numaux == 0)
	{
	  (*_bfd_error_handler)
	    (_("%B: class %d symbol `%s' has no aux entries"),
	     abfd, sym.n_sclass, name);
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}

      bfd_coff_swap_aux_in (abfd,
			    (void *) (esym + symesz * sym.n_numaux),
			    sym.n_type, sym.n_sclass,
			    sym.n_numaux - 1, sym.n_numaux,
			    (void *) &aux);

      smtyp = SMTYP_SMTYP (aux.x_csect.x_smtyp);

      section = NULL;
      value = 0;
      set_toc = NULL;

      switch (smtyp)
	{
	default:
	  (*_bfd_error_handler)
	    (_("%B: symbol `%s' has unrecognized csect type %d"),
	     abfd, name, smtyp);
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;

	case XTY_ER:
	  /* This is an external reference.  */
	  if (sym.n_sclass == C_HIDEXT
	      || sym.n_scnum != N_UNDEF
	      || aux.x_csect.x_scnlen.l != 0)
	    {
	      (*_bfd_error_handler)
		(_("%B: bad XTY_ER symbol `%s': class %d scnum %d scnlen %d"),
		 abfd, name, sym.n_sclass, sym.n_scnum,
		 aux.x_csect.x_scnlen.l);
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }

	  /* An XMC_XO external reference is actually a reference to
	     an absolute location.  */
	  if (aux.x_csect.x_smclas != XMC_XO)
	    section = bfd_und_section_ptr;
	  else
	    {
	      section = bfd_abs_section_ptr;
	      value = sym.n_value;
	    }
	  break;

	case XTY_SD:
	  csect = NULL;
	  csect_index = -(unsigned) 1;

	  /* When we see a TOC anchor, we record the TOC value.  */
	  if (aux.x_csect.x_smclas == XMC_TC0)
	    {
	      if (sym.n_sclass != C_HIDEXT
		  || aux.x_csect.x_scnlen.l != 0)
		{
		  (*_bfd_error_handler)
		    (_("%B: XMC_TC0 symbol `%s' is class %d scnlen %d"),
		     abfd, name, sym.n_sclass, aux.x_csect.x_scnlen.l);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}
	      xcoff_data (abfd)->toc = sym.n_value;
	    }

	  /* We must merge TOC entries for the same symbol.  We can
	     merge two TOC entries if they are both C_HIDEXT, they
	     both have the same name, they are both 4 or 8 bytes long, and
	     they both have a relocation table entry for an external
	     symbol with the same name.  Unfortunately, this means
	     that we must look through the relocations.  Ick.

	     Logic for 32 bit vs 64 bit.
	     32 bit has a csect length of 4 for TOC
	     64 bit has a csect length of 8 for TOC

	     The conditions to get past the if-check are not that bad.
	     They are what is used to create the TOC csects in the first
	     place.  */
	  if (aux.x_csect.x_smclas == XMC_TC
	      && sym.n_sclass == C_HIDEXT
	      && info->output_bfd->xvec == abfd->xvec
	      && ((bfd_xcoff_is_xcoff32 (abfd)
		   && aux.x_csect.x_scnlen.l == 4)
		  || (bfd_xcoff_is_xcoff64 (abfd)
		      && aux.x_csect.x_scnlen.l == 8)))
	    {
	      asection *enclosing;
	      struct internal_reloc *relocs;
	      bfd_size_type relindx;
	      struct internal_reloc *rel;

	      enclosing = coff_section_from_bfd_index (abfd, sym.n_scnum);
	      if (enclosing == NULL)
		goto error_return;

	      relocs = reloc_info[enclosing->target_index].relocs;
	      amt = enclosing->reloc_count;
	      relindx = xcoff_find_reloc (relocs, amt, sym.n_value);
	      rel = relocs + relindx;

	      /* 32 bit R_POS r_size is 31
		 64 bit R_POS r_size is 63  */
	      if (relindx < enclosing->reloc_count
		  && rel->r_vaddr == (bfd_vma) sym.n_value
		  && rel->r_type == R_POS
		  && ((bfd_xcoff_is_xcoff32 (abfd)
		       && rel->r_size == 31)
		      || (bfd_xcoff_is_xcoff64 (abfd)
			  && rel->r_size == 63)))
		{
		  bfd_byte *erelsym;

		  struct internal_syment relsym;

		  erelsym = ((bfd_byte *) obj_coff_external_syms (abfd)
			     + rel->r_symndx * symesz);
		  bfd_coff_swap_sym_in (abfd, (void *) erelsym, (void *) &relsym);
		  if (EXTERN_SYM_P (relsym.n_sclass))
		    {
		      const char *relname;
		      char relbuf[SYMNMLEN + 1];
		      bfd_boolean copy;
		      struct xcoff_link_hash_entry *h;

		      /* At this point we know that the TOC entry is
			 for an externally visible symbol.  */
		      relname = _bfd_coff_internal_syment_name (abfd, &relsym,
								relbuf);
		      if (relname == NULL)
			goto error_return;

		      /* We only merge TOC entries if the TC name is
			 the same as the symbol name.  This handles
			 the normal case, but not common cases like
			 SYM.P4 which gcc generates to store SYM + 4
			 in the TOC.  FIXME.  */
		      if (strcmp (name, relname) == 0)
			{
			  copy = (! info->keep_memory
				  || relsym._n._n_n._n_zeroes != 0
				  || relsym._n._n_n._n_offset == 0);
			  h = xcoff_link_hash_lookup (xcoff_hash_table (info),
						      relname, TRUE, copy,
						      FALSE);
			  if (h == NULL)
			    goto error_return;

			  /* At this point h->root.type could be
			     bfd_link_hash_new.  That should be OK,
			     since we know for sure that we will come
			     across this symbol as we step through the
			     file.  */

			  /* We store h in *sym_hash for the
			     convenience of the relocate_section
			     function.  */
			  *sym_hash = h;

			  if (h->toc_section != NULL)
			    {
			      asection **rel_csects;

			      /* We already have a TOC entry for this
				 symbol, so we can just ignore this
				 one.  */
			      rel_csects =
				reloc_info[enclosing->target_index].csects;
			      rel_csects[relindx] = bfd_und_section_ptr;
			      break;
			    }

			  /* We are about to create a TOC entry for
			     this symbol.  */
			  set_toc = h;
			}
		    }
		}
	    }

	  {
	    asection *enclosing;

	    /* We need to create a new section.  We get the name from
	       the csect storage mapping class, so that the linker can
	       accumulate similar csects together.  */

	    csect = bfd_xcoff_create_csect_from_smclas(abfd, &aux, name);
	    if (NULL == csect)
	      goto error_return;

	    /* The enclosing section is the main section : .data, .text
	       or .bss that the csect is coming from.  */
	    enclosing = coff_section_from_bfd_index (abfd, sym.n_scnum);
	    if (enclosing == NULL)
	      goto error_return;

	    if (! bfd_is_abs_section (enclosing)
		&& ((bfd_vma) sym.n_value < enclosing->vma
		    || ((bfd_vma) sym.n_value + aux.x_csect.x_scnlen.l
			> enclosing->vma + enclosing->size)))
	      {
		(*_bfd_error_handler)
		  (_("%B: csect `%s' not in enclosing section"),
		   abfd, name);
		bfd_set_error (bfd_error_bad_value);
		goto error_return;
	      }
	    csect->vma = sym.n_value;
	    csect->filepos = (enclosing->filepos
			      + sym.n_value
			      - enclosing->vma);
	    csect->size = aux.x_csect.x_scnlen.l;
	    csect->flags |= SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS;
	    csect->alignment_power = SMTYP_ALIGN (aux.x_csect.x_smtyp);

	    /* Record the enclosing section in the tdata for this new
	       section.  */
	    amt = sizeof (struct coff_section_tdata);
	    csect->used_by_bfd = bfd_zalloc (abfd, amt);
	    if (csect->used_by_bfd == NULL)
	      goto error_return;
	    amt = sizeof (struct xcoff_section_tdata);
	    coff_section_data (abfd, csect)->tdata = bfd_zalloc (abfd, amt);
	    if (coff_section_data (abfd, csect)->tdata == NULL)
	      goto error_return;
	    xcoff_section_data (abfd, csect)->enclosing = enclosing;
	    xcoff_section_data (abfd, csect)->lineno_count =
	      enclosing->lineno_count;

	    if (enclosing->owner == abfd)
	      {
		struct internal_reloc *relocs;
		bfd_size_type relindx;
		struct internal_reloc *rel;
		asection **rel_csect;

		relocs = reloc_info[enclosing->target_index].relocs;
		amt = enclosing->reloc_count;
		relindx = xcoff_find_reloc (relocs, amt, csect->vma);

		rel = relocs + relindx;
		rel_csect = (reloc_info[enclosing->target_index].csects
			     + relindx);

		csect->rel_filepos = (enclosing->rel_filepos
				      + relindx * bfd_coff_relsz (abfd));
		while (relindx < enclosing->reloc_count
		       && *rel_csect == NULL
		       && rel->r_vaddr < csect->vma + csect->size)
		  {

		    *rel_csect = csect;
		    csect->flags |= SEC_RELOC;
		    ++csect->reloc_count;
		    ++relindx;
		    ++rel;
		    ++rel_csect;
		  }
	      }

	    /* There are a number of other fields and section flags
	       which we do not bother to set.  */

	    csect_index = ((esym
			    - (bfd_byte *) obj_coff_external_syms (abfd))
			   / symesz);

	    xcoff_section_data (abfd, csect)->first_symndx = csect_index;

	    if (first_csect == NULL)
	      first_csect = csect;

	    /* If this symbol is external, we treat it as starting at the
	       beginning of the newly created section.  */
	    if (EXTERN_SYM_P (sym.n_sclass))
	      {
		section = csect;
		value = 0;
	      }

	    /* If this is a TOC section for a symbol, record it.  */
	    if (set_toc != NULL)
	      set_toc->toc_section = csect;
	  }
	  break;

	case XTY_LD:
	  /* This is a label definition.  The x_scnlen field is the
	     symbol index of the csect.  Usually the XTY_LD symbol will
	     follow its appropriate XTY_SD symbol.  The .set pseudo op can
	     cause the XTY_LD to not follow the XTY_SD symbol. */
	  {
	    bfd_boolean bad;

	    bad = FALSE;
	    if (aux.x_csect.x_scnlen.l < 0
		|| (aux.x_csect.x_scnlen.l
		    >= esym - (bfd_byte *) obj_coff_external_syms (abfd)))
	      bad = TRUE;
	    if (! bad)
	      {
		section = xcoff_data (abfd)->csects[aux.x_csect.x_scnlen.l];
		if (section == NULL
		    || (section->flags & SEC_HAS_CONTENTS) == 0)
		  bad = TRUE;
	      }
	    if (bad)
	      {
		(*_bfd_error_handler)
		  (_("%B: misplaced XTY_LD `%s'"),
		   abfd, name);
		bfd_set_error (bfd_error_bad_value);
		goto error_return;
	      }
 	    csect = section;
	    value = sym.n_value - csect->vma;
	  }
	  break;

	case XTY_CM:
	  /* This is an unitialized csect.  We could base the name on
	     the storage mapping class, but we don't bother except for
	     an XMC_TD symbol.  If this csect is externally visible,
	     it is a common symbol.  We put XMC_TD symbols in sections
	     named .tocbss, and rely on the linker script to put that
	     in the TOC area.  */

	  if (aux.x_csect.x_smclas == XMC_TD)
	    {
	      /* The linker script puts the .td section in the data
		 section after the .tc section.  */
	      csect = bfd_make_section_anyway_with_flags (abfd, ".td",
							  SEC_ALLOC);
	    }
	  else
	    csect = bfd_make_section_anyway_with_flags (abfd, ".bss",
							SEC_ALLOC);

	  if (csect == NULL)
	    goto error_return;
	  csect->vma = sym.n_value;
	  csect->size = aux.x_csect.x_scnlen.l;
	  csect->alignment_power = SMTYP_ALIGN (aux.x_csect.x_smtyp);
	  /* There are a number of other fields and section flags
	     which we do not bother to set.  */

	  csect_index = ((esym
			  - (bfd_byte *) obj_coff_external_syms (abfd))
			 / symesz);

	  amt = sizeof (struct coff_section_tdata);
	  csect->used_by_bfd = bfd_zalloc (abfd, amt);
	  if (csect->used_by_bfd == NULL)
	    goto error_return;
	  amt = sizeof (struct xcoff_section_tdata);
	  coff_section_data (abfd, csect)->tdata = bfd_zalloc (abfd, amt);
	  if (coff_section_data (abfd, csect)->tdata == NULL)
	    goto error_return;
	  xcoff_section_data (abfd, csect)->first_symndx = csect_index;

	  if (first_csect == NULL)
	    first_csect = csect;

	  if (EXTERN_SYM_P (sym.n_sclass))
	    {
	      csect->flags |= SEC_IS_COMMON;
	      csect->size = 0;
	      section = csect;
	      value = aux.x_csect.x_scnlen.l;
	    }

	  break;
	}

      /* Check for magic symbol names.  */
      if ((smtyp == XTY_SD || smtyp == XTY_CM)
	  && aux.x_csect.x_smclas != XMC_TC
	  && aux.x_csect.x_smclas != XMC_TD)
	{
	  int i = -1;

	  if (name[0] == '_')
	    {
	      if (strcmp (name, "_text") == 0)
		i = XCOFF_SPECIAL_SECTION_TEXT;
	      else if (strcmp (name, "_etext") == 0)
		i = XCOFF_SPECIAL_SECTION_ETEXT;
	      else if (strcmp (name, "_data") == 0)
		i = XCOFF_SPECIAL_SECTION_DATA;
	      else if (strcmp (name, "_edata") == 0)
		i = XCOFF_SPECIAL_SECTION_EDATA;
	      else if (strcmp (name, "_end") == 0)
		i = XCOFF_SPECIAL_SECTION_END;
	    }
	  else if (name[0] == 'e' && strcmp (name, "end") == 0)
	    i = XCOFF_SPECIAL_SECTION_END2;

	  if (i != -1)
	    xcoff_hash_table (info)->special_sections[i] = csect;
	}

      /* Now we have enough information to add the symbol to the
	 linker hash table.  */

      if (EXTERN_SYM_P (sym.n_sclass))
	{
	  bfd_boolean copy;
	  flagword flags;

	  BFD_ASSERT (section != NULL);

	  /* We must copy the name into memory if we got it from the
	     syment itself, rather than the string table.  */
	  copy = default_copy;
	  if (sym._n._n_n._n_zeroes != 0
	      || sym._n._n_n._n_offset == 0)
	    copy = TRUE;

	  /* Ignore global linkage code when linking statically.  */
	  if (info->static_link
	      && (smtyp == XTY_SD || smtyp == XTY_LD)
	      && aux.x_csect.x_smclas == XMC_GL)
	    {
	      section = bfd_und_section_ptr;
	      value = 0;
	    }

	  /* The AIX linker appears to only detect multiple symbol
	     definitions when there is a reference to the symbol.  If
	     a symbol is defined multiple times, and the only
	     references are from the same object file, the AIX linker
	     appears to permit it.  It does not merge the different
	     definitions, but handles them independently.  On the
	     other hand, if there is a reference, the linker reports
	     an error.

	     This matters because the AIX <net/net_globals.h> header
	     file actually defines an initialized array, so we have to
	     actually permit that to work.

	     Just to make matters even more confusing, the AIX linker
	     appears to permit multiple symbol definitions whenever
	     the second definition is in an archive rather than an
	     object file.  This may be a consequence of the manner in
	     which it handles archives: I think it may load the entire
	     archive in as separate csects, and then let garbage
	     collection discard symbols.

	     We also have to handle the case of statically linking a
	     shared object, which will cause symbol redefinitions,
	     although this is an easier case to detect.  */
 	  else if (info->output_bfd->xvec == abfd->xvec)
	    {
	      if (! bfd_is_und_section (section))
		*sym_hash = xcoff_link_hash_lookup (xcoff_hash_table (info),
						    name, TRUE, copy, FALSE);
	      else
		/* Make a copy of the symbol name to prevent problems with
		   merging symbols.  */
		*sym_hash = ((struct xcoff_link_hash_entry *)
			     bfd_wrapped_link_hash_lookup (abfd, info, name,
							   TRUE, TRUE, FALSE));

	      if (*sym_hash == NULL)
		goto error_return;
	      if (((*sym_hash)->root.type == bfd_link_hash_defined
		   || (*sym_hash)->root.type == bfd_link_hash_defweak)
		  && ! bfd_is_und_section (section)
		  && ! bfd_is_com_section (section))
		{
		  /* This is a second definition of a defined symbol.  */
		  if (((*sym_hash)->flags & XCOFF_DEF_REGULAR) == 0
		      && ((*sym_hash)->flags & XCOFF_DEF_DYNAMIC) != 0)
		    {
		      /* The existing symbol is from a shared library.
			 Replace it.  */
		      (*sym_hash)->root.type = bfd_link_hash_undefined;
		      (*sym_hash)->root.u.undef.abfd =
			(*sym_hash)->root.u.def.section->owner;
		    }
		  else if (abfd->my_archive != NULL)
		    {
		      /* This is a redefinition in an object contained
			 in an archive.  Just ignore it.  See the
			 comment above.  */
		      section = bfd_und_section_ptr;
		      value = 0;
		    }
		  else if (sym.n_sclass == C_AIX_WEAKEXT
			   || (*sym_hash)->root.type == bfd_link_hash_defweak)
		    {
		      /* At least one of the definitions is weak.
			 Allow the normal rules to take effect.  */
		    }
		  else if ((*sym_hash)->root.u.undef.next != NULL
			   || info->hash->undefs_tail == &(*sym_hash)->root)
		    {
		      /* This symbol has been referenced.  In this
			 case, we just continue and permit the
			 multiple definition error.  See the comment
			 above about the behaviour of the AIX linker.  */
		    }
		  else if ((*sym_hash)->smclas == aux.x_csect.x_smclas)
		    {
		      /* The symbols are both csects of the same
			 class.  There is at least a chance that this
			 is a semi-legitimate redefinition.  */
		      section = bfd_und_section_ptr;
		      value = 0;
		      (*sym_hash)->flags |= XCOFF_MULTIPLY_DEFINED;
		    }
		}
	      else if (((*sym_hash)->flags & XCOFF_MULTIPLY_DEFINED) != 0
		       && (*sym_hash)->root.type == bfd_link_hash_defined
		       && (bfd_is_und_section (section)
			   || bfd_is_com_section (section)))
		{
		  /* This is a reference to a multiply defined symbol.
		     Report the error now.  See the comment above
		     about the behaviour of the AIX linker.  We could
		     also do this with warning symbols, but I'm not
		     sure the XCOFF linker is wholly prepared to
		     handle them, and that would only be a warning,
		     not an error.  */
		  if (! ((*info->callbacks->multiple_definition)
			 (info, &(*sym_hash)->root, NULL, NULL, (bfd_vma) 0)))
		    goto error_return;
		  /* Try not to give this error too many times.  */
		  (*sym_hash)->flags &= ~XCOFF_MULTIPLY_DEFINED;
		}
	    }

	  /* _bfd_generic_link_add_one_symbol may call the linker to
	     generate an error message, and the linker may try to read
	     the symbol table to give a good error.  Right now, the
	     line numbers are in an inconsistent state, since they are
	     counted both in the real sections and in the new csects.
	     We need to leave the count in the real sections so that
	     the linker can report the line number of the error
	     correctly, so temporarily clobber the link to the csects
	     so that the linker will not try to read the line numbers
	     a second time from the csects.  */
	  BFD_ASSERT (last_real->next == first_csect);
	  last_real->next = NULL;
	  flags = (sym.n_sclass == C_EXT ? BSF_GLOBAL : BSF_WEAK);
	  if (! (_bfd_generic_link_add_one_symbol
		 (info, abfd, name, flags, section, value,
		  NULL, copy, TRUE,
		  (struct bfd_link_hash_entry **) sym_hash)))
	    goto error_return;
	  last_real->next = first_csect;

	  if (smtyp == XTY_CM)
	    {
	      if ((*sym_hash)->root.type != bfd_link_hash_common
		  || (*sym_hash)->root.u.c.p->section != csect)
		/* We don't need the common csect we just created.  */
		csect->size = 0;
	      else
		(*sym_hash)->root.u.c.p->alignment_power
		  = csect->alignment_power;
	    }

 	  if (info->output_bfd->xvec == abfd->xvec)
	    {
	      int flag;

	      if (smtyp == XTY_ER
		  || smtyp == XTY_CM
		  || section == bfd_und_section_ptr)
		flag = XCOFF_REF_REGULAR;
	      else
		flag = XCOFF_DEF_REGULAR;
	      (*sym_hash)->flags |= flag;

	      if ((*sym_hash)->smclas == XMC_UA
		  || flag == XCOFF_DEF_REGULAR)
		(*sym_hash)->smclas = aux.x_csect.x_smclas;
	    }
	}

      if (smtyp == XTY_ER)
	*csect_cache = section;
      else
	{
	  *csect_cache = csect;
	  if (csect != NULL)
	    xcoff_section_data (abfd, csect)->last_symndx
	      = (esym - (bfd_byte *) obj_coff_external_syms (abfd)) / symesz;
	}

      esym += (sym.n_numaux + 1) * symesz;
      sym_hash += sym.n_numaux + 1;
      csect_cache += sym.n_numaux + 1;
      lineno_counts += sym.n_numaux + 1;
    }

  BFD_ASSERT (last_real == NULL || last_real->next == first_csect);

  /* Make sure that we have seen all the relocs.  */
  for (o = abfd->sections; o != first_csect; o = o->next)
    {
      /* Debugging sections have no csects.  */
      if (bfd_get_section_flags (abfd, o) & SEC_DEBUGGING)
        continue;

      /* Reset the section size and the line number count, since the
	 data is now attached to the csects.  Don't reset the size of
	 the .debug section, since we need to read it below in
	 bfd_xcoff_size_dynamic_sections.  */
      if (strcmp (bfd_get_section_name (abfd, o), ".debug") != 0)
	o->size = 0;
      o->lineno_count = 0;

      if ((o->flags & SEC_RELOC) != 0)
	{
	  bfd_size_type i;
	  struct internal_reloc *rel;
	  asection **rel_csect;

	  rel = reloc_info[o->target_index].relocs;
	  rel_csect = reloc_info[o->target_index].csects;

	  for (i = 0; i < o->reloc_count; i++, rel++, rel_csect++)
	    {
	      if (*rel_csect == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%B: reloc %s:%d not in csect"),
		     abfd, o->name, i);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}

	      /* We identify all function symbols that are the target
		 of a relocation, so that we can create glue code for
		 functions imported from dynamic objects.  */
 	      if (info->output_bfd->xvec == abfd->xvec
		  && *rel_csect != bfd_und_section_ptr
		  && obj_xcoff_sym_hashes (abfd)[rel->r_symndx] != NULL)
		{
		  struct xcoff_link_hash_entry *h;

		  h = obj_xcoff_sym_hashes (abfd)[rel->r_symndx];
		  /* If the symbol name starts with a period, it is
		     the code of a function.  If the symbol is
		     currently undefined, then add an undefined symbol
		     for the function descriptor.  This should do no
		     harm, because any regular object that defines the
		     function should also define the function
		     descriptor.  It helps, because it means that we
		     will identify the function descriptor with a
		     dynamic object if a dynamic object defines it.  */
		  if (h->root.root.string[0] == '.'
		      && h->descriptor == NULL)
		    {
		      struct xcoff_link_hash_entry *hds;
		      struct bfd_link_hash_entry *bh;

		      hds = xcoff_link_hash_lookup (xcoff_hash_table (info),
						    h->root.root.string + 1,
						    TRUE, FALSE, TRUE);
		      if (hds == NULL)
			goto error_return;
		      if (hds->root.type == bfd_link_hash_new)
			{
			  bh = &hds->root;
			  if (! (_bfd_generic_link_add_one_symbol
				 (info, abfd, hds->root.root.string,
				  (flagword) 0, bfd_und_section_ptr,
				  (bfd_vma) 0, NULL, FALSE,
				  TRUE, &bh)))
			    goto error_return;
			  hds = (struct xcoff_link_hash_entry *) bh;
			}
		      hds->flags |= XCOFF_DESCRIPTOR;
		      BFD_ASSERT ((h->flags & XCOFF_DESCRIPTOR) == 0);
		      hds->descriptor = h;
		      h->descriptor = hds;
		    }
		  if (h->root.root.string[0] == '.')
		    h->flags |= XCOFF_CALLED;
		}
	    }

	  free (reloc_info[o->target_index].csects);
	  reloc_info[o->target_index].csects = NULL;

	  /* Reset SEC_RELOC and the reloc_count, since the reloc
	     information is now attached to the csects.  */
	  o->flags &=~ SEC_RELOC;
	  o->reloc_count = 0;

	  /* If we are not keeping memory, free the reloc information.  */
	  if (! info->keep_memory
	      && coff_section_data (abfd, o) != NULL
	      && coff_section_data (abfd, o)->relocs != NULL
	      && ! coff_section_data (abfd, o)->keep_relocs)
	    {
	      free (coff_section_data (abfd, o)->relocs);
	      coff_section_data (abfd, o)->relocs = NULL;
	    }
	}

      /* Free up the line numbers.  FIXME: We could cache these
	 somewhere for the final link, to avoid reading them again.  */
      if (reloc_info[o->target_index].linenos != NULL)
	{
	  free (reloc_info[o->target_index].linenos);
	  reloc_info[o->target_index].linenos = NULL;
	}
    }

  free (reloc_info);

  obj_coff_keep_syms (abfd) = keep_syms;

  return TRUE;

 error_return:
  if (reloc_info != NULL)
    {
      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  if (reloc_info[o->target_index].csects != NULL)
	    free (reloc_info[o->target_index].csects);
	  if (reloc_info[o->target_index].linenos != NULL)
	    free (reloc_info[o->target_index].linenos);
	}
      free (reloc_info);
    }
  obj_coff_keep_syms (abfd) = keep_syms;
  return FALSE;
}

#undef N_TMASK
#undef N_BTSHFT

/* Add symbols from an XCOFF object file.  */

static bfd_boolean
xcoff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
{
  if (! _bfd_coff_get_external_symbols (abfd))
    return FALSE;
  if (! xcoff_link_add_symbols (abfd, info))
    return FALSE;
  if (! info->keep_memory)
    {
      if (! _bfd_coff_free_symbols (abfd))
	return FALSE;
    }
  return TRUE;
}

/* Look through the loader symbols to see if this dynamic object
   should be included in the link.  The native linker uses the loader
   symbols, not the normal symbol table, so we do too.  */

static bfd_boolean
xcoff_link_check_dynamic_ar_symbols (bfd *abfd,
				     struct bfd_link_info *info,
				     bfd_boolean *pneeded,
				     bfd **subsbfd)
{
  asection *lsec;
  bfd_byte *contents;
  struct internal_ldhdr ldhdr;
  const char *strings;
  bfd_byte *elsym, *elsymend;

  *pneeded = FALSE;

  lsec = bfd_get_section_by_name (abfd, ".loader");
  if (lsec == NULL)
    /* There are no symbols, so don't try to include it.  */
    return TRUE;

  if (! xcoff_get_section_contents (abfd, lsec))
    return FALSE;
  contents = coff_section_data (abfd, lsec)->contents;

  bfd_xcoff_swap_ldhdr_in (abfd, contents, &ldhdr);

  strings = (char *) contents + ldhdr.l_stoff;

  elsym = contents + bfd_xcoff_loader_symbol_offset (abfd, &ldhdr);

  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz (abfd);
  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz (abfd))
    {
      struct internal_ldsym ldsym;
      char nambuf[SYMNMLEN + 1];
      const char *name;
      struct bfd_link_hash_entry *h;

      bfd_xcoff_swap_ldsym_in (abfd, elsym, &ldsym);

      /* We are only interested in exported symbols.  */
      if ((ldsym.l_smtype & L_EXPORT) == 0)
	continue;

      if (ldsym._l._l_l._l_zeroes == 0)
	name = strings + ldsym._l._l_l._l_offset;
      else
	{
	  memcpy (nambuf, ldsym._l._l_name, SYMNMLEN);
	  nambuf[SYMNMLEN] = '\0';
	  name = nambuf;
	}

      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

      /* We are only interested in symbols that are currently
	 undefined.  At this point we know that we are using an XCOFF
	 hash table.  */
      if (h != NULL
	  && h->type == bfd_link_hash_undefined
	  && (((struct xcoff_link_hash_entry *) h)->flags
	      & XCOFF_DEF_DYNAMIC) == 0)
	{
	  if (!(*info->callbacks
		->add_archive_element) (info, abfd, name, subsbfd))
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
	}
    }

  /* We do not need this shared object.  */
  if (contents != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
    {
      free (coff_section_data (abfd, lsec)->contents);
      coff_section_data (abfd, lsec)->contents = NULL;
    }

  return TRUE;
}

/* Look through the symbols to see if this object file should be
   included in the link.  */

static bfd_boolean
xcoff_link_check_ar_symbols (bfd *abfd,
			     struct bfd_link_info *info,
			     bfd_boolean *pneeded,
			     bfd **subsbfd)
{
  bfd_size_type symesz;
  bfd_byte *esym;
  bfd_byte *esym_end;

  *pneeded = FALSE;

  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link
      && info->output_bfd->xvec == abfd->xvec)
    return xcoff_link_check_dynamic_ar_symbols (abfd, info, pneeded, subsbfd);

  symesz = bfd_coff_symesz (abfd);
  esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esym_end = esym + obj_raw_syment_count (abfd) * symesz;
  while (esym < esym_end)
    {
      struct internal_syment sym;

      bfd_coff_swap_sym_in (abfd, (void *) esym, (void *) &sym);

      if (EXTERN_SYM_P (sym.n_sclass) && sym.n_scnum != N_UNDEF)
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];
	  struct bfd_link_hash_entry *h;

	  /* This symbol is externally visible, and is defined by this
	     object file.  */
	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);

	  if (name == NULL)
	    return FALSE;
	  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

	  /* We are only interested in symbols that are currently
	     undefined.  If a symbol is currently known to be common,
	     XCOFF linkers do not bring in an object file which
	     defines it.  We also don't bring in symbols to satisfy
	     undefined references in shared objects.  */
	  if (h != NULL
	      && h->type == bfd_link_hash_undefined
 	      && (info->output_bfd->xvec != abfd->xvec
		  || (((struct xcoff_link_hash_entry *) h)->flags
		      & XCOFF_DEF_DYNAMIC) == 0))
	    {
	      if (!(*info->callbacks
		    ->add_archive_element) (info, abfd, name, subsbfd))
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
	    }
	}

      esym += (sym.n_numaux + 1) * symesz;
    }

  /* We do not need this object file.  */
  return TRUE;
}

/* Check a single archive element to see if we need to include it in
   the link.  *PNEEDED is set according to whether this element is
   needed in the link or not.  This is called via
   _bfd_generic_link_add_archive_symbols.  */

static bfd_boolean
xcoff_link_check_archive_element (bfd *abfd,
				  struct bfd_link_info *info,
				  bfd_boolean *pneeded)
{
  bfd_boolean keep_syms_p;
  bfd *oldbfd;

  keep_syms_p = (obj_coff_external_syms (abfd) != NULL);
  if (!_bfd_coff_get_external_symbols (abfd))
    return FALSE;

  oldbfd = abfd;
  if (!xcoff_link_check_ar_symbols (abfd, info, pneeded, &abfd))
    return FALSE;

  if (*pneeded)
    {
      /* Potentially, the add_archive_element hook may have set a
	 substitute BFD for us.  */
      if (abfd != oldbfd)
	{
	  if (!keep_syms_p
	      && !_bfd_coff_free_symbols (oldbfd))
	    return FALSE;
	  keep_syms_p = (obj_coff_external_syms (abfd) != NULL);
	  if (!_bfd_coff_get_external_symbols (abfd))
	    return FALSE;
	}
      if (!xcoff_link_add_symbols (abfd, info))
	return FALSE;
      if (info->keep_memory)
	keep_syms_p = TRUE;
    }

  if (!keep_syms_p)
    {
      if (!_bfd_coff_free_symbols (abfd))
	return FALSE;
    }

  return TRUE;
}

/* Given an XCOFF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
_bfd_xcoff_bfd_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return xcoff_link_add_object_symbols (abfd, info);

    case bfd_archive:
      /* If the archive has a map, do the usual search.  We then need
	 to check the archive for dynamic objects, because they may not
	 appear in the archive map even though they should, perhaps, be
	 included.  If the archive has no map, we just consider each object
	 file in turn, since that apparently is what the AIX native linker
	 does.  */
      if (bfd_has_map (abfd))
	{
	  if (! (_bfd_generic_link_add_archive_symbols
		 (abfd, info, xcoff_link_check_archive_element)))
	    return FALSE;
	}

      {
	bfd *member;

	member = bfd_openr_next_archived_file (abfd, NULL);
	while (member != NULL)
	  {
	    if (bfd_check_format (member, bfd_object)
		&& (info->output_bfd->xvec == member->xvec)
		&& (! bfd_has_map (abfd) || (member->flags & DYNAMIC) != 0))
	      {
		bfd_boolean needed;

		if (! xcoff_link_check_archive_element (member, info,
							&needed))
		  return FALSE;
		if (needed)
		  member->archive_pass = -1;
	      }
	    member = bfd_openr_next_archived_file (abfd, member);
	  }
      }

      return TRUE;

    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

bfd_boolean
_bfd_xcoff_define_common_symbol (bfd *output_bfd ATTRIBUTE_UNUSED,
				 struct bfd_link_info *info ATTRIBUTE_UNUSED,
				 struct bfd_link_hash_entry *harg)
{
  struct xcoff_link_hash_entry *h;

  if (!bfd_generic_define_common_symbol (output_bfd, info, harg))
    return FALSE;

  h = (struct xcoff_link_hash_entry *) harg;
  h->flags |= XCOFF_DEF_REGULAR;
  return TRUE;
}

/* If symbol H has not been interpreted as a function descriptor,
   see whether it should be.  Set up its descriptor information if so.  */

static bfd_boolean
xcoff_find_function (struct bfd_link_info *info,
		     struct xcoff_link_hash_entry *h)
{
  if ((h->flags & XCOFF_DESCRIPTOR) == 0
      && h->root.root.string[0] != '.')
    {
      char *fnname;
      struct xcoff_link_hash_entry *hfn;
      bfd_size_type amt;

      amt = strlen (h->root.root.string) + 2;
      fnname = bfd_malloc (amt);
      if (fnname == NULL)
	return FALSE;
      fnname[0] = '.';
      strcpy (fnname + 1, h->root.root.string);
      hfn = xcoff_link_hash_lookup (xcoff_hash_table (info),
				    fnname, FALSE, FALSE, TRUE);
      free (fnname);
      if (hfn != NULL
	  && hfn->smclas == XMC_PR
	  && (hfn->root.type == bfd_link_hash_defined
	      || hfn->root.type == bfd_link_hash_defweak))
	{
	  h->flags |= XCOFF_DESCRIPTOR;
	  h->descriptor = hfn;
	  hfn->descriptor = h;
	}
    }
  return TRUE;
}

/* Return true if the given bfd contains at least one shared object.  */

static bfd_boolean
xcoff_archive_contains_shared_object_p (struct bfd_link_info *info,
					bfd *archive)
{
  struct xcoff_archive_info *archive_info;
  bfd *member;

  archive_info = xcoff_get_archive_info (info, archive);
  if (!archive_info->know_contains_shared_object_p)
    {
      member = bfd_openr_next_archived_file (archive, NULL);
      while (member != NULL && (member->flags & DYNAMIC) == 0)
	member = bfd_openr_next_archived_file (archive, member);

      archive_info->contains_shared_object_p = (member != NULL);
      archive_info->know_contains_shared_object_p = 1;
    }
  return archive_info->contains_shared_object_p;
}

/* Symbol H qualifies for export by -bexpfull.  Return true if it also
   qualifies for export by -bexpall.  */

static bfd_boolean
xcoff_covered_by_expall_p (struct xcoff_link_hash_entry *h)
{
  /* Exclude symbols beginning with '_'.  */
  if (h->root.root.string[0] == '_')
    return FALSE;

  /* Exclude archive members that would otherwise be unreferenced.  */
  if ((h->flags & XCOFF_MARK) == 0
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
      && h->root.u.def.section->owner != NULL
      && h->root.u.def.section->owner->my_archive != NULL)
    return FALSE;

  return TRUE;
}

/* Return true if symbol H qualifies for the forms of automatic export
   specified by AUTO_EXPORT_FLAGS.  */

static bfd_boolean
xcoff_auto_export_p (struct bfd_link_info *info,
		     struct xcoff_link_hash_entry *h,
		     unsigned int auto_export_flags)
{
  /* Don't automatically export things that were explicitly exported.  */
  if ((h->flags & XCOFF_EXPORT) != 0)
    return FALSE;

  /* Don't export things that we don't define.  */
  if ((h->flags & XCOFF_DEF_REGULAR) == 0)
    return FALSE;

  /* Don't export functions; export their descriptors instead.  */
  if (h->root.root.string[0] == '.')
    return FALSE;

  /* We don't export a symbol which is being defined by an object
     included from an archive which contains a shared object.  The
     rationale is that if an archive contains both an unshared and
     a shared object, then there must be some reason that the
     unshared object is unshared, and we don't want to start
     providing a shared version of it.  In particular, this solves
     a bug involving the _savefNN set of functions.  gcc will call
     those functions without providing a slot to restore the TOC,
     so it is essential that these functions be linked in directly
     and not from a shared object, which means that a shared
     object which also happens to link them in must not export
     them.  This is confusing, but I haven't been able to think of
     a different approach.  Note that the symbols can, of course,
     be exported explicitly.  */
  if (h->root.type == bfd_link_hash_defined
      || h->root.type == bfd_link_hash_defweak)
    {
      bfd *owner;

      owner = h->root.u.def.section->owner;
      if (owner != NULL
	  && owner->my_archive != NULL
	  && xcoff_archive_contains_shared_object_p (info, owner->my_archive))
	return FALSE;
    }

  /* Otherwise, all symbols are exported by -bexpfull.  */
  if ((auto_export_flags & XCOFF_EXPFULL) != 0)
    return TRUE;

  /* Despite its name, -bexpall exports most but not all symbols.  */
  if ((auto_export_flags & XCOFF_EXPALL) != 0
      && xcoff_covered_by_expall_p (h))
    return TRUE;

  return FALSE;
}

/* Return true if relocation REL needs to be copied to the .loader section.
   If REL is against a global symbol, H is that symbol, otherwise it
   is null.  */

static bfd_boolean
xcoff_need_ldrel_p (struct bfd_link_info *info, struct internal_reloc *rel,
		    struct xcoff_link_hash_entry *h)
{
  if (!xcoff_hash_table (info)->loader_section)
    return FALSE;

  switch (rel->r_type)
    {
    case R_TOC:
    case R_GL:
    case R_TCL:
    case R_TRL:
    case R_TRLA:
      /* We should never need a .loader reloc for a TOC-relative reloc.  */
      return FALSE;

    default:
      /* In this case, relocations against defined symbols can be resolved
	 statically.  */
      if (h == NULL
	  || h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak
	  || h->root.type == bfd_link_hash_common)
	return FALSE;

      /* We will always provide a local definition of function symbols,
	 even if we don't have one yet.  */
      if ((h->flags & XCOFF_CALLED) != 0)
	return FALSE;

      return TRUE;

    case R_POS:
    case R_NEG:
    case R_RL:
    case R_RLA:
      /* Absolute relocations against absolute symbols can be
	 resolved statically.  */
      if (h != NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	  && bfd_is_abs_section (h->root.u.def.section))
	return FALSE;

      return TRUE;
    }
}

/* Mark a symbol as not being garbage, including the section in which
   it is defined.  */

static inline bfd_boolean
xcoff_mark_symbol (struct bfd_link_info *info, struct xcoff_link_hash_entry *h)
{
  if ((h->flags & XCOFF_MARK) != 0)
    return TRUE;

  h->flags |= XCOFF_MARK;

  /* If we're marking an undefined symbol, try find some way of
     defining it.  */
  if (!info->relocatable
      && (h->flags & XCOFF_IMPORT) == 0
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak))
    {
      /* First check whether this symbol can be interpreted as an
	 undefined function descriptor for a defined function symbol.  */
      if (!xcoff_find_function (info, h))
	return FALSE;

      if ((h->flags & XCOFF_DESCRIPTOR) != 0
	  && (h->descriptor->root.type == bfd_link_hash_defined
	      || h->descriptor->root.type == bfd_link_hash_defweak))
	{
	  /* This is a descriptor for a defined symbol, but the input
	     objects have not defined the descriptor itself.  Fill in
	     the definition automatically.

	     Note that we do this even if we found a dynamic definition
	     of H.  The local function definition logically overrides
	     the dynamic one.  */
	  asection *sec;

	  sec = xcoff_hash_table (info)->descriptor_section;
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = sec;
	  h->root.u.def.value = sec->size;
	  h->smclas = XMC_DS;
	  h->flags |= XCOFF_DEF_REGULAR;

	  /* The size of the function descriptor depends on whether this
	     is xcoff32 (12) or xcoff64 (24).  */
	  sec->size += bfd_xcoff_function_descriptor_size (sec->owner);

	  /* A function descriptor uses two relocs: one for the
	     associated code, and one for the TOC address.  */
	  xcoff_hash_table (info)->ldrel_count += 2;
	  sec->reloc_count += 2;

	  /* Mark the function itself.  */
	  if (!xcoff_mark_symbol (info, h->descriptor))
	    return FALSE;

	  /* Mark the TOC section, so that we get an anchor
	     to relocate against.  */
	  if (!xcoff_mark (info, xcoff_hash_table (info)->toc_section))
	    return FALSE;

	  /* We handle writing out the contents of the descriptor in
	     xcoff_write_global_symbol.  */
	}
      else if (info->static_link)
	/* We can't get a symbol value dynamically, so just assume
	   that it's undefined.  */
	h->flags |= XCOFF_WAS_UNDEFINED;
      else if ((h->flags & XCOFF_CALLED) != 0)
	{
	  /* This is a function symbol for which we need to create
	     linkage code.  */
	  asection *sec;
	  struct xcoff_link_hash_entry *hds;

	  /* Mark the descriptor (and its TOC section).  */
	  hds = h->descriptor;
	  BFD_ASSERT ((hds->root.type == bfd_link_hash_undefined
		       || hds->root.type == bfd_link_hash_undefweak)
		      && (hds->flags & XCOFF_DEF_REGULAR) == 0);
	  if (!xcoff_mark_symbol (info, hds))
	    return FALSE;

	  /* Treat this symbol as undefined if the descriptor was.  */
	  if ((hds->flags & XCOFF_WAS_UNDEFINED) != 0)
	    h->flags |= XCOFF_WAS_UNDEFINED;

	  /* Allocate room for the global linkage code itself.  */
	  sec = xcoff_hash_table (info)->linkage_section;
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = sec;
	  h->root.u.def.value = sec->size;
	  h->smclas = XMC_GL;
	  h->flags |= XCOFF_DEF_REGULAR;
	  sec->size += bfd_xcoff_glink_code_size (info->output_bfd);

	  /* The global linkage code requires a TOC entry for the
	     descriptor.  */
	  if (hds->toc_section == NULL)
	    {
	      int byte_size;

	      /* 32 vs 64
		 xcoff32 uses 4 bytes in the toc.
		 xcoff64 uses 8 bytes in the toc.  */
	      if (bfd_xcoff_is_xcoff64 (info->output_bfd))
		byte_size = 8;
	      else if (bfd_xcoff_is_xcoff32 (info->output_bfd))
		byte_size = 4;
	      else
		return FALSE;

	      /* Allocate room in the fallback TOC section.  */
	      hds->toc_section = xcoff_hash_table (info)->toc_section;
	      hds->u.toc_offset = hds->toc_section->size;
	      hds->toc_section->size += byte_size;
	      if (!xcoff_mark (info, hds->toc_section))
		return FALSE;

	      /* Allocate room for a static and dynamic R_TOC
		 relocation.  */
	      ++xcoff_hash_table (info)->ldrel_count;
	      ++hds->toc_section->reloc_count;

	      /* Set the index to -2 to force this symbol to
		 get written out.  */
	      hds->indx = -2;
	      hds->flags |= XCOFF_SET_TOC | XCOFF_LDREL;
	    }
	}
      else if ((h->flags & XCOFF_DEF_DYNAMIC) == 0)
	{
	  /* Record that the symbol was undefined, then import it.
	     -brtl links use a special fake import file.  */
	  h->flags |= XCOFF_WAS_UNDEFINED | XCOFF_IMPORT;
	  if (xcoff_hash_table (info)->rtld)
	    {
	      if (!xcoff_set_import_path (info, h, "", "..", ""))
		return FALSE;
	    }
	  else
	    {
	      if (!xcoff_set_import_path (info, h, NULL, NULL, NULL))
		return FALSE;
	    }
	}
    }

  if (h->root.type == bfd_link_hash_defined
      || h->root.type == bfd_link_hash_defweak)
    {
      asection *hsec;

      hsec = h->root.u.def.section;
      if (! bfd_is_abs_section (hsec)
	  && (hsec->flags & SEC_MARK) == 0)
	{
	  if (! xcoff_mark (info, hsec))
	    return FALSE;
	}
    }

  if (h->toc_section != NULL
      && (h->toc_section->flags & SEC_MARK) == 0)
    {
      if (! xcoff_mark (info, h->toc_section))
	return FALSE;
    }

  return TRUE;
}

/* Look for a symbol called NAME.  If the symbol is defined, mark it.
   If the symbol exists, set FLAGS.  */

static bfd_boolean
xcoff_mark_symbol_by_name (struct bfd_link_info *info,
			   const char *name, unsigned int flags)
{
  struct xcoff_link_hash_entry *h;

  h = xcoff_link_hash_lookup (xcoff_hash_table (info), name,
			      FALSE, FALSE, TRUE);
  if (h != NULL)
    {
      h->flags |= flags;
      if (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
	{
	  if (!xcoff_mark (info, h->root.u.def.section))
	    return FALSE;
	}
    }
  return TRUE;
}

/* The mark phase of garbage collection.  For a given section, mark
   it, and all the sections which define symbols to which it refers.
   Because this function needs to look at the relocs, we also count
   the number of relocs which need to be copied into the .loader
   section.  */

static bfd_boolean
xcoff_mark (struct bfd_link_info *info, asection *sec)
{
  if (bfd_is_abs_section (sec)
      || (sec->flags & SEC_MARK) != 0)
    return TRUE;

  sec->flags |= SEC_MARK;

  if (sec->owner->xvec == info->output_bfd->xvec
      && coff_section_data (sec->owner, sec) != NULL
      && xcoff_section_data (sec->owner, sec) != NULL)
    {
      struct xcoff_link_hash_entry **syms;
      struct internal_reloc *rel, *relend;
      asection **csects;
      unsigned long i, first, last;

      /* Mark all the symbols in this section.  */
      syms = obj_xcoff_sym_hashes (sec->owner);
      csects = xcoff_data (sec->owner)->csects;
      first = xcoff_section_data (sec->owner, sec)->first_symndx;
      last = xcoff_section_data (sec->owner, sec)->last_symndx;
      for (i = first; i <= last; i++)
	if (csects[i] == sec
	    && syms[i] != NULL
	    && (syms[i]->flags & XCOFF_MARK) == 0)
	  {
	    if (!xcoff_mark_symbol (info, syms[i]))
	      return FALSE;
	  }

      /* Look through the section relocs.  */
      if ((sec->flags & SEC_RELOC) != 0
	  && sec->reloc_count > 0)
	{
	  rel = xcoff_read_internal_relocs (sec->owner, sec, TRUE,
					    NULL, FALSE, NULL);
	  if (rel == NULL)
	    return FALSE;
	  relend = rel + sec->reloc_count;
	  for (; rel < relend; rel++)
	    {
	      struct xcoff_link_hash_entry *h;

	      if ((unsigned int) rel->r_symndx
		  > obj_raw_syment_count (sec->owner))
		continue;

	      h = obj_xcoff_sym_hashes (sec->owner)[rel->r_symndx];
	      if (h != NULL)
		{
		  if ((h->flags & XCOFF_MARK) == 0)
		    {
		      if (!xcoff_mark_symbol (info, h))
			return FALSE;
		    }
		}
	      else
		{
		  asection *rsec;

		  rsec = xcoff_data (sec->owner)->csects[rel->r_symndx];
		  if (rsec != NULL
		      && (rsec->flags & SEC_MARK) == 0)
		    {
		      if (!xcoff_mark (info, rsec))
			return FALSE;
		    }
		}

	      /* See if this reloc needs to be copied into the .loader
		 section.  */
	      if (xcoff_need_ldrel_p (info, rel, h))
		{
		  ++xcoff_hash_table (info)->ldrel_count;
		  if (h != NULL)
		    h->flags |= XCOFF_LDREL;
		}
	    }

	  if (! info->keep_memory
	      && coff_section_data (sec->owner, sec) != NULL
	      && coff_section_data (sec->owner, sec)->relocs != NULL
	      && ! coff_section_data (sec->owner, sec)->keep_relocs)
	    {
	      free (coff_section_data (sec->owner, sec)->relocs);
	      coff_section_data (sec->owner, sec)->relocs = NULL;
	    }
	}
    }

  return TRUE;
}

/* Routines that are called after all the input files have been
   handled, but before the sections are laid out in memory.  */

/* The sweep phase of garbage collection.  Remove all garbage
   sections.  */

static void
xcoff_sweep (struct bfd_link_info *info)
{
  bfd *sub;

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *o;

      for (o = sub->sections; o != NULL; o = o->next)
	{
	  if ((o->flags & SEC_MARK) == 0)
	    {
	      /* Keep all sections from non-XCOFF input files.  Keep
		 special sections.  Keep .debug sections for the
		 moment.  */
	      if (sub->xvec != info->output_bfd->xvec
		  || o == xcoff_hash_table (info)->debug_section
		  || o == xcoff_hash_table (info)->loader_section
		  || o == xcoff_hash_table (info)->linkage_section
		  || o == xcoff_hash_table (info)->descriptor_section
                  || (bfd_get_section_flags (sub, o) & SEC_DEBUGGING)
		  || strcmp (o->name, ".debug") == 0)
		o->flags |= SEC_MARK;
	      else
		{
		  o->size = 0;
		  o->reloc_count = 0;
		}
	    }
	}
    }
}

/* Record the number of elements in a set.  This is used to output the
   correct csect length.  */

bfd_boolean
bfd_xcoff_link_record_set (bfd *output_bfd,
			   struct bfd_link_info *info,
			   struct bfd_link_hash_entry *harg,
			   bfd_size_type size)
{
  struct xcoff_link_hash_entry *h = (struct xcoff_link_hash_entry *) harg;
  struct xcoff_link_size_list *n;
  bfd_size_type amt;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  /* This will hardly ever be called.  I don't want to burn four bytes
     per global symbol, so instead the size is kept on a linked list
     attached to the hash table.  */
  amt = sizeof (* n);
  n = bfd_alloc (output_bfd, amt);
  if (n == NULL)
    return FALSE;
  n->next = xcoff_hash_table (info)->size_list;
  n->h = h;
  n->size = size;
  xcoff_hash_table (info)->size_list = n;

  h->flags |= XCOFF_HAS_SIZE;

  return TRUE;
}

/* Import a symbol.  */

bfd_boolean
bfd_xcoff_import_symbol (bfd *output_bfd,
			 struct bfd_link_info *info,
			 struct bfd_link_hash_entry *harg,
			 bfd_vma val,
			 const char *imppath,
			 const char *impfile,
			 const char *impmember,
			 unsigned int syscall_flag)
{
  struct xcoff_link_hash_entry *h = (struct xcoff_link_hash_entry *) harg;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  /* A symbol name which starts with a period is the code for a
     function.  If the symbol is undefined, then add an undefined
     symbol for the function descriptor, and import that instead.  */
  if (h->root.root.string[0] == '.'
      && h->root.type == bfd_link_hash_undefined
      && val == (bfd_vma) -1)
    {
      struct xcoff_link_hash_entry *hds;

      hds = h->descriptor;
      if (hds == NULL)
	{
	  hds = xcoff_link_hash_lookup (xcoff_hash_table (info),
					h->root.root.string + 1,
					TRUE, FALSE, TRUE);
	  if (hds == NULL)
	    return FALSE;
	  if (hds->root.type == bfd_link_hash_new)
	    {
	      hds->root.type = bfd_link_hash_undefined;
	      hds->root.u.undef.abfd = h->root.u.undef.abfd;
	    }
	  hds->flags |= XCOFF_DESCRIPTOR;
	  BFD_ASSERT ((h->flags & XCOFF_DESCRIPTOR) == 0);
	  hds->descriptor = h;
	  h->descriptor = hds;
	}

      /* Now, if the descriptor is undefined, import the descriptor
	 rather than the symbol we were told to import.  FIXME: Is
	 this correct in all cases?  */
      if (hds->root.type == bfd_link_hash_undefined)
	h = hds;
    }

  h->flags |= (XCOFF_IMPORT | syscall_flag);

  if (val != (bfd_vma) -1)
    {
      if (h->root.type == bfd_link_hash_defined
	  && (! bfd_is_abs_section (h->root.u.def.section)
	      || h->root.u.def.value != val))
	{
	  if (! ((*info->callbacks->multiple_definition)
		 (info, &h->root, output_bfd, bfd_abs_section_ptr, val)))
	    return FALSE;
	}

      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = bfd_abs_section_ptr;
      h->root.u.def.value = val;
      h->smclas = XMC_XO;
    }

  if (!xcoff_set_import_path (info, h, imppath, impfile, impmember))
    return FALSE;

  return TRUE;
}

/* Export a symbol.  */

bfd_boolean
bfd_xcoff_export_symbol (bfd *output_bfd,
			 struct bfd_link_info *info,
			 struct bfd_link_hash_entry *harg)
{
  struct xcoff_link_hash_entry *h = (struct xcoff_link_hash_entry *) harg;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  h->flags |= XCOFF_EXPORT;

  /* FIXME: I'm not at all sure what syscall is supposed to mean, so
     I'm just going to ignore it until somebody explains it.  */

  /* Make sure we don't garbage collect this symbol.  */
  if (! xcoff_mark_symbol (info, h))
    return FALSE;

  /* If this is a function descriptor, make sure we don't garbage
     collect the associated function code.  We normally don't have to
     worry about this, because the descriptor will be attached to a
     section with relocs, but if we are creating the descriptor
     ourselves those relocs will not be visible to the mark code.  */
  if ((h->flags & XCOFF_DESCRIPTOR) != 0)
    {
      if (! xcoff_mark_symbol (info, h->descriptor))
	return FALSE;
    }

  return TRUE;
}

/* Count a reloc against a symbol.  This is called for relocs
   generated by the linker script, typically for global constructors
   and destructors.  */

bfd_boolean
bfd_xcoff_link_count_reloc (bfd *output_bfd,
			    struct bfd_link_info *info,
			    const char *name)
{
  struct xcoff_link_hash_entry *h;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  h = ((struct xcoff_link_hash_entry *)
       bfd_wrapped_link_hash_lookup (output_bfd, info, name, FALSE, FALSE,
				     FALSE));
  if (h == NULL)
    {
      (*_bfd_error_handler) (_("%s: no such symbol"), name);
      bfd_set_error (bfd_error_no_symbols);
      return FALSE;
    }

  h->flags |= XCOFF_REF_REGULAR;
  if (xcoff_hash_table (info)->loader_section)
    {
      h->flags |= XCOFF_LDREL;
      ++xcoff_hash_table (info)->ldrel_count;
    }

  /* Mark the symbol to avoid garbage collection.  */
  if (! xcoff_mark_symbol (info, h))
    return FALSE;

  return TRUE;
}

/* This function is called for each symbol to which the linker script
   assigns a value.  */

bfd_boolean
bfd_xcoff_record_link_assignment (bfd *output_bfd,
				  struct bfd_link_info *info,
				  const char *name)
{
  struct xcoff_link_hash_entry *h;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    return TRUE;

  h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE, TRUE,
			      FALSE);
  if (h == NULL)
    return FALSE;

  h->flags |= XCOFF_DEF_REGULAR;

  return TRUE;
}

/* An xcoff_link_hash_traverse callback for which DATA points to an
   xcoff_loader_info.  Mark all symbols that should be automatically
   exported.  */

static bfd_boolean
xcoff_mark_auto_exports (struct xcoff_link_hash_entry *h, void *data)
{
  struct xcoff_loader_info *ldinfo;

  ldinfo = (struct xcoff_loader_info *) data;
  if (xcoff_auto_export_p (ldinfo->info, h, ldinfo->auto_export_flags))
    {
      if (!xcoff_mark_symbol (ldinfo->info, h))
	ldinfo->failed = TRUE;
    }
  return TRUE;
}

/* Add a symbol to the .loader symbols, if necessary.  */

/* INPUT_BFD has an external symbol associated with hash table entry H
   and csect CSECT.   Return true if INPUT_BFD defines H.  */

static bfd_boolean
xcoff_final_definition_p (bfd *input_bfd, struct xcoff_link_hash_entry *h,
			  asection *csect)
{
  switch (h->root.type)
    {
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      /* No input bfd owns absolute symbols.  They are written by
	 xcoff_write_global_symbol instead.  */
      return (!bfd_is_abs_section (csect)
	      && h->root.u.def.section == csect);

    case bfd_link_hash_common:
      return h->root.u.c.p->section->owner == input_bfd;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      /* We can't treat undef.abfd as the owner because that bfd
	 might be a dynamic object.  Allow any bfd to claim it.  */
      return TRUE;

    default:
      abort ();
    }
}

/* See if H should have a loader symbol associated with it.  */

static bfd_boolean
xcoff_build_ldsym (struct xcoff_loader_info *ldinfo,
		   struct xcoff_link_hash_entry *h)
{
  bfd_size_type amt;

  /* Warn if this symbol is exported but not defined.  */
  if ((h->flags & XCOFF_EXPORT) != 0
      && (h->flags & XCOFF_WAS_UNDEFINED) != 0)
    {
      (*_bfd_error_handler)
	(_("warning: attempt to export undefined symbol `%s'"),
	 h->root.root.string);
      return TRUE;
    }

  /* We need to add a symbol to the .loader section if it is mentioned
     in a reloc which we are copying to the .loader section and it was
     not defined or common, or if it is the entry point, or if it is
     being exported.  */
  if (((h->flags & XCOFF_LDREL) == 0
       || h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak
       || h->root.type == bfd_link_hash_common)
      && (h->flags & XCOFF_ENTRY) == 0
      && (h->flags & XCOFF_EXPORT) == 0)
    return TRUE;

  /* We need to add this symbol to the .loader symbols.  */

  BFD_ASSERT (h->ldsym == NULL);
  amt = sizeof (struct internal_ldsym);
  h->ldsym = bfd_zalloc (ldinfo->output_bfd, amt);
  if (h->ldsym == NULL)
    {
      ldinfo->failed = TRUE;
      return FALSE;
    }

  if ((h->flags & XCOFF_IMPORT) != 0)
    {
      /* Give imported descriptors class XMC_DS rather than XMC_UA.  */
      if ((h->flags & XCOFF_DESCRIPTOR) != 0)
	h->smclas = XMC_DS;
      h->ldsym->l_ifile = h->ldindx;
    }

  /* The first 3 symbol table indices are reserved to indicate the
     data, text and bss sections.  */
  h->ldindx = ldinfo->ldsym_count + 3;

  ++ldinfo->ldsym_count;

  if (! bfd_xcoff_put_ldsymbol_name (ldinfo->output_bfd, ldinfo,
				     h->ldsym, h->root.root.string))
    return FALSE;

  h->flags |= XCOFF_BUILT_LDSYM;
  return TRUE;
}

/* An xcoff_htab_traverse callback that is called for each symbol
   once garbage collection is complete.  */

static bfd_boolean
xcoff_post_gc_symbol (struct xcoff_link_hash_entry *h, void * p)
{
  struct xcoff_loader_info *ldinfo = (struct xcoff_loader_info *) p;

  /* __rtinit, this symbol has special handling. */
  if (h->flags & XCOFF_RTINIT)
    return TRUE;

  /* We don't want to garbage collect symbols which are not defined in
     XCOFF files.  This is a convenient place to mark them.  */
  if (xcoff_hash_table (ldinfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
      && (h->root.u.def.section->owner == NULL
	  || (h->root.u.def.section->owner->xvec
	      != ldinfo->info->output_bfd->xvec)))
    h->flags |= XCOFF_MARK;

  /* Skip discarded symbols.  */
  if (xcoff_hash_table (ldinfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0)
    return TRUE;

  /* If this is still a common symbol, and it wasn't garbage
     collected, we need to actually allocate space for it in the .bss
     section.  */
  if (h->root.type == bfd_link_hash_common
      && h->root.u.c.p->section->size == 0)
    {
      BFD_ASSERT (bfd_is_com_section (h->root.u.c.p->section));
      h->root.u.c.p->section->size = h->root.u.c.size;
    }

  if (xcoff_hash_table (ldinfo->info)->loader_section)
    {
      if (xcoff_auto_export_p (ldinfo->info, h, ldinfo->auto_export_flags))
	h->flags |= XCOFF_EXPORT;

      if (!xcoff_build_ldsym (ldinfo, h))
	return FALSE;
    }

  return TRUE;
}

/* INPUT_BFD includes XCOFF symbol ISYM, which is associated with linker
   hash table entry H and csect CSECT.  AUX contains ISYM's auxillary
   csect information, if any.  NAME is the function's name if the name
   is stored in the .debug section, otherwise it is null.

   Return 1 if we should include an appropriately-adjusted ISYM
   in the output file, 0 if we should discard ISYM, or -1 if an
   error occured.  */

static int
xcoff_keep_symbol_p (struct bfd_link_info *info, bfd *input_bfd,
		     struct internal_syment *isym,
		     union internal_auxent *aux,
		     struct xcoff_link_hash_entry *h,
		     asection *csect, const char *name)
{
  int smtyp;

  /* If we are skipping this csect, we want to strip the symbol too.  */
  if (csect == NULL)
    return 0;

  /* Likewise if we garbage-collected the csect.  */
  if (xcoff_hash_table (info)->gc
      && !bfd_is_abs_section (csect)
      && !bfd_is_und_section (csect)
      && (csect->flags & SEC_MARK) == 0)
    return 0;

  /* An XCOFF linker always removes C_STAT symbols.  */
  if (isym->n_sclass == C_STAT)
    return 0;

  /* We generate the TOC anchor separately.  */
  if (isym->n_sclass == C_HIDEXT
      && aux->x_csect.x_smclas == XMC_TC0)
    return 0;

  /* If we are stripping all symbols, we want to discard this one.  */
  if (info->strip == strip_all)
    return 0;

  /* Discard symbols that are defined elsewhere.  */
  if (EXTERN_SYM_P (isym->n_sclass))
    {
      if ((h->flags & XCOFF_ALLOCATED) != 0)
	return 0;
      if (!xcoff_final_definition_p (input_bfd, h, csect))
	return 0;
    }

  /* If we're discarding local symbols, check whether ISYM is local.  */
  smtyp = SMTYP_SMTYP (aux->x_csect.x_smtyp);
  if (info->discard == discard_all
      && !EXTERN_SYM_P (isym->n_sclass)
      && (isym->n_sclass != C_HIDEXT || smtyp != XTY_SD))
    return 0;

  /* If we're stripping debugging symbols, check whether ISYM is one.  */
  if (info->strip == strip_debugger
      && isym->n_scnum == N_DEBUG)
    return 0;

  /* If we are stripping symbols based on name, check how ISYM's
     name should be handled.  */
  if (info->strip == strip_some
      || info->discard == discard_l)
    {
      char buf[SYMNMLEN + 1];

      if (name == NULL)
	{
	  name = _bfd_coff_internal_syment_name (input_bfd, isym, buf);
	  if (name == NULL)
	    return -1;
	}

      if (info->strip == strip_some
	  && bfd_hash_lookup (info->keep_hash, name, FALSE, FALSE) == NULL)
	return 0;

      if (info->discard == discard_l
	  && !EXTERN_SYM_P (isym->n_sclass)
	  && (isym->n_sclass != C_HIDEXT || smtyp != XTY_SD)
	  && bfd_is_local_label_name (input_bfd, name))
	return 0;
    }

  return 1;
}

/* Lay out the .loader section, filling in the header and the import paths.
   LIBPATH is as for bfd_xcoff_size_dynamic_sections.  */

static bfd_boolean
xcoff_build_loader_section (struct xcoff_loader_info *ldinfo,
			    const char *libpath)
{
  bfd *output_bfd;
  struct xcoff_link_hash_table *htab;
  struct internal_ldhdr *ldhdr;
  struct xcoff_import_file *fl;
  bfd_size_type stoff;
  size_t impsize, impcount;
  asection *lsec;
  char *out;

  /* Work out the size of the import file names.  Each import file ID
     consists of three null terminated strings: the path, the file
     name, and the archive member name.  The first entry in the list
     of names is the path to use to find objects, which the linker has
     passed in as the libpath argument.  For some reason, the path
     entry in the other import file names appears to always be empty.  */
  output_bfd = ldinfo->output_bfd;
  htab = xcoff_hash_table (ldinfo->info);
  impsize = strlen (libpath) + 3;
  impcount = 1;
  for (fl = htab->imports; fl != NULL; fl = fl->next)
    {
      ++impcount;
      impsize += (strlen (fl->path)
		  + strlen (fl->file)
		  + strlen (fl->member)
		  + 3);
    }

  /* Set up the .loader section header.  */
  ldhdr = &htab->ldhdr;
  ldhdr->l_version = bfd_xcoff_ldhdr_version(output_bfd);
  ldhdr->l_nsyms = ldinfo->ldsym_count;
  ldhdr->l_nreloc = htab->ldrel_count;
  ldhdr->l_istlen = impsize;
  ldhdr->l_nimpid = impcount;
  ldhdr->l_impoff = (bfd_xcoff_ldhdrsz (output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (output_bfd)
		     + ldhdr->l_nreloc * bfd_xcoff_ldrelsz (output_bfd));
  ldhdr->l_stlen = ldinfo->string_size;
  stoff = ldhdr->l_impoff + impsize;
  if (ldinfo->string_size == 0)
    ldhdr->l_stoff = 0;
  else
    ldhdr->l_stoff = stoff;

  /* 64 bit elements to ldhdr
     The swap out routine for 32 bit will ignore them.
     Nothing fancy, symbols come after the header and relocs come
     after symbols.  */
  ldhdr->l_symoff = bfd_xcoff_ldhdrsz (output_bfd);
  ldhdr->l_rldoff = (bfd_xcoff_ldhdrsz (output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (output_bfd));

  /* We now know the final size of the .loader section.  Allocate
     space for it.  */
  lsec = htab->loader_section;
  lsec->size = stoff + ldhdr->l_stlen;
  lsec->contents = bfd_zalloc (output_bfd, lsec->size);
  if (lsec->contents == NULL)
    return FALSE;

  /* Set up the header.  */
  bfd_xcoff_swap_ldhdr_out (output_bfd, ldhdr, lsec->contents);

  /* Set up the import file names.  */
  out = (char *) lsec->contents + ldhdr->l_impoff;
  strcpy (out, libpath);
  out += strlen (libpath) + 1;
  *out++ = '\0';
  *out++ = '\0';
  for (fl = htab->imports; fl != NULL; fl = fl->next)
    {
      const char *s;

      s = fl->path;
      while ((*out++ = *s++) != '\0')
	;
      s = fl->file;
      while ((*out++ = *s++) != '\0')
	;
      s = fl->member;
      while ((*out++ = *s++) != '\0')
	;
    }

  BFD_ASSERT ((bfd_size_type) ((bfd_byte *) out - lsec->contents) == stoff);

  /* Set up the symbol string table.  */
  if (ldinfo->string_size > 0)
    {
      memcpy (out, ldinfo->strings, ldinfo->string_size);
      free (ldinfo->strings);
      ldinfo->strings = NULL;
    }

  /* We can't set up the symbol table or the relocs yet, because we
     don't yet know the final position of the various sections.  The
     .loader symbols are written out when the corresponding normal
     symbols are written out in xcoff_link_input_bfd or
     xcoff_write_global_symbol.  The .loader relocs are written out
     when the corresponding normal relocs are handled in
     xcoff_link_input_bfd.  */

  return TRUE;
}

/* Build the .loader section.  This is called by the XCOFF linker
   emulation before_allocation routine.  We must set the size of the
   .loader section before the linker lays out the output file.
   LIBPATH is the library path to search for shared objects; this is
   normally built from the -L arguments passed to the linker.  ENTRY
   is the name of the entry point symbol (the -e linker option).
   FILE_ALIGN is the alignment to use for sections within the file
   (the -H linker option).  MAXSTACK is the maximum stack size (the
   -bmaxstack linker option).  MAXDATA is the maximum data size (the
   -bmaxdata linker option).  GC is whether to do garbage collection
   (the -bgc linker option).  MODTYPE is the module type (the
   -bmodtype linker option).  TEXTRO is whether the text section must
   be read only (the -btextro linker option).  AUTO_EXPORT_FLAGS
   is a mask of XCOFF_EXPALL and XCOFF_EXPFULL.  SPECIAL_SECTIONS
   is set by this routine to csects with magic names like _end.  */

bfd_boolean
bfd_xcoff_size_dynamic_sections (bfd *output_bfd,
				 struct bfd_link_info *info,
				 const char *libpath,
				 const char *entry,
				 unsigned long file_align,
				 unsigned long maxstack,
				 unsigned long maxdata,
				 bfd_boolean gc,
				 int modtype,
				 bfd_boolean textro,
				 unsigned int auto_export_flags,
				 asection **special_sections,
				 bfd_boolean rtld)
{
  struct xcoff_loader_info ldinfo;
  int i;
  asection *sec;
  bfd *sub;
  struct bfd_strtab_hash *debug_strtab;
  bfd_byte *debug_contents = NULL;
  bfd_size_type amt;

  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    {
      for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
	special_sections[i] = NULL;
      return TRUE;
    }

  ldinfo.failed = FALSE;
  ldinfo.output_bfd = output_bfd;
  ldinfo.info = info;
  ldinfo.auto_export_flags = auto_export_flags;
  ldinfo.ldsym_count = 0;
  ldinfo.string_size = 0;
  ldinfo.strings = NULL;
  ldinfo.string_alc = 0;

  xcoff_data (output_bfd)->maxstack = maxstack;
  xcoff_data (output_bfd)->maxdata = maxdata;
  xcoff_data (output_bfd)->modtype = modtype;

  xcoff_hash_table (info)->file_align = file_align;
  xcoff_hash_table (info)->textro = textro;
  xcoff_hash_table (info)->rtld = rtld;

  /* __rtinit */
  if (xcoff_hash_table (info)->loader_section
      && (info->init_function || info->fini_function || rtld))
    {
      struct xcoff_link_hash_entry *hsym;
      struct internal_ldsym *ldsym;

      hsym = xcoff_link_hash_lookup (xcoff_hash_table (info),
				     "__rtinit", FALSE, FALSE, TRUE);
      if (hsym == NULL)
	{
	  (*_bfd_error_handler)
	    (_("error: undefined symbol __rtinit"));
	  return FALSE;
	}

      xcoff_mark_symbol (info, hsym);
      hsym->flags |= (XCOFF_DEF_REGULAR | XCOFF_RTINIT);

      /* __rtinit initialized.  */
      amt = sizeof (* ldsym);
      ldsym = bfd_malloc (amt);

      ldsym->l_value = 0;		/* Will be filled in later.  */
      ldsym->l_scnum = 2;		/* Data section.  */
      ldsym->l_smtype = XTY_SD;		/* Csect section definition.  */
      ldsym->l_smclas = 5;		/* .rw.  */
      ldsym->l_ifile = 0;		/* Special system loader symbol.  */
      ldsym->l_parm = 0;		/* NA.  */

      /* Force __rtinit to be the first symbol in the loader symbol table
	 See xcoff_build_ldsyms

	 The first 3 symbol table indices are reserved to indicate the data,
	 text and bss sections.  */
      BFD_ASSERT (0 == ldinfo.ldsym_count);

      hsym->ldindx = 3;
      ldinfo.ldsym_count = 1;
      hsym->ldsym = ldsym;

      if (! bfd_xcoff_put_ldsymbol_name (ldinfo.output_bfd, &ldinfo,
					 hsym->ldsym, hsym->root.root.string))
	return FALSE;

      /* This symbol is written out by xcoff_write_global_symbol
	 Set stuff up so xcoff_write_global_symbol logic works.  */
      hsym->flags |= XCOFF_DEF_REGULAR | XCOFF_MARK;
      hsym->root.type = bfd_link_hash_defined;
      hsym->root.u.def.value = 0;
    }

  /* Garbage collect unused sections.  */
  if (info->relocatable || !gc)
    {
      gc = FALSE;
      xcoff_hash_table (info)->gc = FALSE;

      /* We still need to call xcoff_mark, in order to set ldrel_count
	 correctly.  */
      for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
	{
	  asection *o;

	  for (o = sub->sections; o != NULL; o = o->next)
	    {
	      /* We shouldn't unconditionaly mark the TOC section.
		 The output file should only have a TOC if either
		 (a) one of the input files did or (b) we end up
		 creating TOC references as part of the link process.  */
	      if (o != xcoff_hash_table (info)->toc_section
		  && (o->flags & SEC_MARK) == 0)
		{
		  if (! xcoff_mark (info, o))
		    goto error_return;
		}
	    }
	}
    }
  else
    {
      if (entry != NULL
	  && !xcoff_mark_symbol_by_name (info, entry, XCOFF_ENTRY))
	goto error_return;
      if (info->init_function != NULL
	  && !xcoff_mark_symbol_by_name (info, info->init_function, 0))
	goto error_return;
      if (info->fini_function != NULL
	  && !xcoff_mark_symbol_by_name (info, info->fini_function, 0))
	goto error_return;
      if (auto_export_flags != 0)
	{
	  xcoff_link_hash_traverse (xcoff_hash_table (info),
				    xcoff_mark_auto_exports, &ldinfo);
	  if (ldinfo.failed)
	    goto error_return;
	}
      xcoff_sweep (info);
      xcoff_hash_table (info)->gc = TRUE;
    }

  /* Return special sections to the caller.  */
  for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
    {
      sec = xcoff_hash_table (info)->special_sections[i];

      if (sec != NULL
	  && gc
	  && (sec->flags & SEC_MARK) == 0)
	sec = NULL;

      special_sections[i] = sec;
    }

  if (info->input_bfds == NULL)
    /* I'm not sure what to do in this bizarre case.  */
    return TRUE;

  xcoff_link_hash_traverse (xcoff_hash_table (info), xcoff_post_gc_symbol,
			    (void *) &ldinfo);
  if (ldinfo.failed)
    goto error_return;

  if (xcoff_hash_table (info)->loader_section
      && !xcoff_build_loader_section (&ldinfo, libpath))
    goto error_return;

  /* Allocate space for the magic sections.  */
  sec = xcoff_hash_table (info)->linkage_section;
  if (sec->size > 0)
    {
      sec->contents = bfd_zalloc (output_bfd, sec->size);
      if (sec->contents == NULL)
	goto error_return;
    }
  sec = xcoff_hash_table (info)->toc_section;
  if (sec->size > 0)
    {
      sec->contents = bfd_zalloc (output_bfd, sec->size);
      if (sec->contents == NULL)
	goto error_return;
    }
  sec = xcoff_hash_table (info)->descriptor_section;
  if (sec->size > 0)
    {
      sec->contents = bfd_zalloc (output_bfd, sec->size);
      if (sec->contents == NULL)
	goto error_return;
    }

  /* Now that we've done garbage collection, decide which symbols to keep,
     and figure out the contents of the .debug section.  */
  debug_strtab = xcoff_hash_table (info)->debug_strtab;

  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      asection *subdeb;
      bfd_size_type symcount;
      long *debug_index;
      asection **csectpp;
      unsigned int *lineno_counts;
      struct xcoff_link_hash_entry **sym_hash;
      bfd_byte *esym, *esymend;
      bfd_size_type symesz;

      if (sub->xvec != info->output_bfd->xvec)
	continue;

      if ((sub->flags & DYNAMIC) != 0
	  && !info->static_link)
	continue;

      if (! _bfd_coff_get_external_symbols (sub))
	goto error_return;

      symcount = obj_raw_syment_count (sub);
      debug_index = bfd_zalloc (sub, symcount * sizeof (long));
      if (debug_index == NULL)
	goto error_return;
      xcoff_data (sub)->debug_indices = debug_index;

      if (info->strip == strip_all
	  || info->strip == strip_debugger
	  || info->discard == discard_all)
	/* We're stripping all debugging information, so there's no need
	   to read SUB's .debug section.  */
	subdeb = NULL;
      else
	{
	  /* Grab the contents of SUB's .debug section, if any.  */
	  subdeb = bfd_get_section_by_name (sub, ".debug");
	  if (subdeb != NULL && subdeb->size > 0)
	    {
	      /* We use malloc and copy the names into the debug
		 stringtab, rather than bfd_alloc, because I expect
		 that, when linking many files together, many of the
		 strings will be the same.  Storing the strings in the
		 hash table should save space in this case.  */
	      if (!bfd_malloc_and_get_section (sub, subdeb, &debug_contents))
		goto error_return;
	    }
	}

      csectpp = xcoff_data (sub)->csects;
      lineno_counts = xcoff_data (sub)->lineno_counts;
      sym_hash = obj_xcoff_sym_hashes (sub);
      symesz = bfd_coff_symesz (sub);
      esym = (bfd_byte *) obj_coff_external_syms (sub);
      esymend = esym + symcount * symesz;

      while (esym < esymend)
	{
	  struct internal_syment sym;
	  union internal_auxent aux;
	  asection *csect;
	  const char *name;
	  int keep_p;

	  bfd_coff_swap_sym_in (sub, esym, &sym);

	  /* Read in the csect information, if any.  */
	  if (CSECT_SYM_P (sym.n_sclass))
	    {
	      BFD_ASSERT (sym.n_numaux > 0);
	      bfd_coff_swap_aux_in (sub, esym + symesz * sym.n_numaux,
				    sym.n_type, sym.n_sclass,
				    sym.n_numaux - 1, sym.n_numaux, &aux);
	    }

	  /* If this symbol's name is stored in the debug section,
	     get a pointer to it.  */
	  if (debug_contents != NULL
	      && sym._n._n_n._n_zeroes == 0
	      && bfd_coff_symname_in_debug (sub, &sym))
	    name = (const char *) debug_contents + sym._n._n_n._n_offset;
	  else
	    name = NULL;

	  /* Decide whether to copy this symbol to the output file.  */
	  csect = *csectpp;
	  keep_p = xcoff_keep_symbol_p (info, sub, &sym, &aux,
					*sym_hash, csect, name);
	  if (keep_p < 0)
	    return FALSE;

	  if (!keep_p)
	    /* Use a debug_index of -2 to record that a symbol should
	       be stripped.  */
	    *debug_index = -2;
	  else
	    {
	      /* See whether we should store the symbol name in the
		 output .debug section.  */
	      if (name != NULL)
		{
		  bfd_size_type indx;

		  indx = _bfd_stringtab_add (debug_strtab, name, TRUE, TRUE);
		  if (indx == (bfd_size_type) -1)
		    goto error_return;
		  *debug_index = indx;
		}
	      else
		*debug_index = -1;
	      if (*sym_hash != 0)
		(*sym_hash)->flags |= XCOFF_ALLOCATED;
	      if (*lineno_counts > 0)
		csect->output_section->lineno_count += *lineno_counts;
	    }

	  esym += (sym.n_numaux + 1) * symesz;
	  csectpp += sym.n_numaux + 1;
	  sym_hash += sym.n_numaux + 1;
	  lineno_counts += sym.n_numaux + 1;
	  debug_index += sym.n_numaux + 1;
	}

      if (debug_contents)
	{
	  free (debug_contents);
	  debug_contents = NULL;

	  /* Clear the size of subdeb, so that it is not included directly
	     in the output file.  */
	  subdeb->size = 0;
	}

      if (! info->keep_memory)
	{
	  if (! _bfd_coff_free_symbols (sub))
	    goto error_return;
	}
    }

  if (info->strip != strip_all)
    xcoff_hash_table (info)->debug_section->size =
      _bfd_stringtab_size (debug_strtab);

  return TRUE;

 error_return:
  if (ldinfo.strings != NULL)
    free (ldinfo.strings);
  if (debug_contents != NULL)
    free (debug_contents);
  return FALSE;
}

bfd_boolean
bfd_xcoff_link_generate_rtinit (bfd *abfd,
				const char *init,
				const char *fini,
				bfd_boolean rtld)
{
  struct bfd_in_memory *bim;

  bim = bfd_malloc ((bfd_size_type) sizeof (* bim));
  if (bim == NULL)
    return FALSE;

  bim->size = 0;
  bim->buffer = 0;

  abfd->link_next = 0;
  abfd->format = bfd_object;
  abfd->iostream = (void *) bim;
  abfd->flags = BFD_IN_MEMORY;
  abfd->iovec = &_bfd_memory_iovec;
  abfd->direction = write_direction;
  abfd->origin = 0;
  abfd->where = 0;

  if (! bfd_xcoff_generate_rtinit (abfd, init, fini, rtld))
    return FALSE;

  /* need to reset to unknown or it will not be read back in correctly */
  abfd->format = bfd_unknown;
  abfd->direction = read_direction;
  abfd->where = 0;

  return TRUE;
}

/* Return the section that defines H.  Return null if no section does.  */

static asection *
xcoff_symbol_section (struct xcoff_link_hash_entry *h)
{
  switch (h->root.type)
    {
    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      return h->root.u.def.section;

    case bfd_link_hash_common:
      return h->root.u.c.p->section;

    default:
      return NULL;
    }
}

/* Add a .loader relocation for input relocation IREL.  If the loader
   relocation should be against an output section, HSEC points to the
   input section that IREL is against, otherwise HSEC is null.  H is the
   symbol that IREL is against, or null if it isn't against a global symbol.
   REFERENCE_BFD is the bfd to use in error messages about the relocation.  */

static bfd_boolean
xcoff_create_ldrel (bfd *output_bfd, struct xcoff_final_link_info *flinfo,
		    asection *output_section, bfd *reference_bfd,
		    struct internal_reloc *irel, asection *hsec,
		    struct xcoff_link_hash_entry *h)
{
  struct internal_ldrel ldrel;

  ldrel.l_vaddr = irel->r_vaddr;
  if (hsec != NULL)
    {
      const char *secname;

      secname = hsec->output_section->name;
      if (strcmp (secname, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (secname, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (secname, ".bss") == 0)
	ldrel.l_symndx = 2;
      else
	{
	  (*_bfd_error_handler)
	    (_("%B: loader reloc in unrecognized section `%s'"),
	     reference_bfd, secname);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
    }
  else if (h != NULL)
    {
      if (h->ldindx < 0)
	{
	  (*_bfd_error_handler)
	    (_("%B: `%s' in loader reloc but not loader sym"),
	     reference_bfd, h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      ldrel.l_symndx = h->ldindx;
    }
  else
    ldrel.l_symndx = -(bfd_size_type) 1;

  ldrel.l_rtype = (irel->r_size << 8) | irel->r_type;
  ldrel.l_rsecnm = output_section->target_index;
  if (xcoff_hash_table (flinfo->info)->textro
      && strcmp (output_section->name, ".text") == 0)
    {
      (*_bfd_error_handler)
	(_("%B: loader reloc in read-only section %A"),
	 reference_bfd, output_section);
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }
  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, flinfo->ldrel);
  flinfo->ldrel += bfd_xcoff_ldrelsz (output_bfd);
  return TRUE;
}

/* Link an input file into the linker output file.  This function
   handles all the sections and relocations of the input file at once.  */

static bfd_boolean
xcoff_link_input_bfd (struct xcoff_final_link_info *flinfo,
		      bfd *input_bfd)
{
  bfd *output_bfd;
  const char *strings;
  bfd_size_type syment_base;
  unsigned int n_tmask;
  unsigned int n_btshft;
  bfd_boolean copy, hash;
  bfd_size_type isymesz;
  bfd_size_type osymesz;
  bfd_size_type linesz;
  bfd_byte *esym;
  bfd_byte *esym_end;
  struct xcoff_link_hash_entry **sym_hash;
  struct internal_syment *isymp;
  asection **csectpp;
  unsigned int *lineno_counts;
  long *debug_index;
  long *indexp;
  unsigned long output_index;
  bfd_byte *outsym;
  unsigned int incls;
  asection *oline;
  bfd_boolean keep_syms;
  asection *o;

  /* We can just skip DYNAMIC files, unless this is a static link.  */
  if ((input_bfd->flags & DYNAMIC) != 0
      && ! flinfo->info->static_link)
    return TRUE;

  /* Move all the symbols to the output file.  */
  output_bfd = flinfo->output_bfd;
  strings = NULL;
  syment_base = obj_raw_syment_count (output_bfd);
  isymesz = bfd_coff_symesz (input_bfd);
  osymesz = bfd_coff_symesz (output_bfd);
  linesz = bfd_coff_linesz (input_bfd);
  BFD_ASSERT (linesz == bfd_coff_linesz (output_bfd));

  n_tmask = coff_data (input_bfd)->local_n_tmask;
  n_btshft = coff_data (input_bfd)->local_n_btshft;

  /* Define macros so that ISFCN, et. al., macros work correctly.  */
#define N_TMASK n_tmask
#define N_BTSHFT n_btshft

  copy = FALSE;
  if (! flinfo->info->keep_memory)
    copy = TRUE;
  hash = TRUE;
  if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
    hash = FALSE;

  if (! _bfd_coff_get_external_symbols (input_bfd))
    return FALSE;

  /* Make one pass over the symbols and assign indices to symbols that
     we have decided to keep.  Also use create .loader symbol information
     and update information in hash table entries.  */
  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
  sym_hash = obj_xcoff_sym_hashes (input_bfd);
  csectpp = xcoff_data (input_bfd)->csects;
  debug_index = xcoff_data (input_bfd)->debug_indices;
  isymp = flinfo->internal_syms;
  indexp = flinfo->sym_indices;
  output_index = syment_base;
  while (esym < esym_end)
    {
      union internal_auxent aux;
      int smtyp = 0;
      int add;

      bfd_coff_swap_sym_in (input_bfd, (void *) esym, (void *) isymp);

      /* Read in the csect information, if any.  */
      if (CSECT_SYM_P (isymp->n_sclass))
	{
	  BFD_ASSERT (isymp->n_numaux > 0);
	  bfd_coff_swap_aux_in (input_bfd,
				(void *) (esym + isymesz * isymp->n_numaux),
				isymp->n_type, isymp->n_sclass,
				isymp->n_numaux - 1, isymp->n_numaux,
				(void *) &aux);

	  smtyp = SMTYP_SMTYP (aux.x_csect.x_smtyp);
	}

      /* If this symbol is in the .loader section, swap out the
	 .loader symbol information.  If this is an external symbol
	 reference to a defined symbol, though, then wait until we get
	 to the definition.  */
      if (EXTERN_SYM_P (isymp->n_sclass)
	  && *sym_hash != NULL
	  && (*sym_hash)->ldsym != NULL
	  && xcoff_final_definition_p (input_bfd, *sym_hash, *csectpp))
	{
	  struct xcoff_link_hash_entry *h;
	  struct internal_ldsym *ldsym;

	  h = *sym_hash;
	  ldsym = h->ldsym;
	  if (isymp->n_scnum > 0)
	    {
	      ldsym->l_scnum = (*csectpp)->output_section->target_index;
	      ldsym->l_value = (isymp->n_value
				+ (*csectpp)->output_section->vma
				+ (*csectpp)->output_offset
				- (*csectpp)->vma);
	    }
	  else
	    {
	      ldsym->l_scnum = isymp->n_scnum;
	      ldsym->l_value = isymp->n_value;
	    }

	  ldsym->l_smtype = smtyp;
	  if (((h->flags & XCOFF_DEF_REGULAR) == 0
	       && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	      || (h->flags & XCOFF_IMPORT) != 0)
	    ldsym->l_smtype |= L_IMPORT;
	  if (((h->flags & XCOFF_DEF_REGULAR) != 0
	       && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	      || (h->flags & XCOFF_EXPORT) != 0)
	    ldsym->l_smtype |= L_EXPORT;
	  if ((h->flags & XCOFF_ENTRY) != 0)
	    ldsym->l_smtype |= L_ENTRY;
	  if (isymp->n_sclass == C_AIX_WEAKEXT)
	    ldsym->l_smtype |= L_WEAK;

	  ldsym->l_smclas = aux.x_csect.x_smclas;

	  if (ldsym->l_ifile == (bfd_size_type) -1)
	    ldsym->l_ifile = 0;
	  else if (ldsym->l_ifile == 0)
	    {
	      if ((ldsym->l_smtype & L_IMPORT) == 0)
		ldsym->l_ifile = 0;
	      else
		{
		  bfd *impbfd;

		  if (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak)
		    impbfd = h->root.u.def.section->owner;
		  else if (h->root.type == bfd_link_hash_undefined
			   || h->root.type == bfd_link_hash_undefweak)
		    impbfd = h->root.u.undef.abfd;
		  else
		    impbfd = NULL;

		  if (impbfd == NULL)
		    ldsym->l_ifile = 0;
		  else
		    {
		      BFD_ASSERT (impbfd->xvec == flinfo->output_bfd->xvec);
		      ldsym->l_ifile = xcoff_data (impbfd)->import_file_id;
		    }
		}
	    }

	  ldsym->l_parm = 0;

	  BFD_ASSERT (h->ldindx >= 0);
	  bfd_xcoff_swap_ldsym_out (flinfo->output_bfd, ldsym,
				    (flinfo->ldsym
				     + ((h->ldindx - 3)
					* bfd_xcoff_ldsymsz (flinfo->output_bfd))));
	  h->ldsym = NULL;

	  /* Fill in snentry now that we know the target_index.  */
	  if ((h->flags & XCOFF_ENTRY) != 0
	      && (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak))
	    {
	      xcoff_data (output_bfd)->snentry =
		h->root.u.def.section->output_section->target_index;
	    }
	}

      add = 1 + isymp->n_numaux;

      if (*debug_index == -2)
	/* We've decided to strip this symbol.  */
	*indexp = -1;
      else
	{
	  /* Assign the next unused index to this symbol.  */
	  *indexp = output_index;

	  if (EXTERN_SYM_P (isymp->n_sclass))
	    {
	      BFD_ASSERT (*sym_hash != NULL);
	      (*sym_hash)->indx = output_index;
	    }

	  /* If this is a symbol in the TOC which we may have merged
	     (class XMC_TC), remember the symbol index of the TOC
	     symbol.  */
	  if (isymp->n_sclass == C_HIDEXT
	      && aux.x_csect.x_smclas == XMC_TC
	      && *sym_hash != NULL)
	    {
	      BFD_ASSERT (((*sym_hash)->flags & XCOFF_SET_TOC) == 0);
	      BFD_ASSERT ((*sym_hash)->toc_section != NULL);
	      (*sym_hash)->u.toc_indx = output_index;
	    }

	  output_index += add;
	}

      esym += add * isymesz;
      isymp += add;
      csectpp += add;
      sym_hash += add;
      debug_index += add;
      ++indexp;
      for (--add; add > 0; --add)
	*indexp++ = -1;
    }

  /* Now write out the symbols that we decided to keep.  */

  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
  sym_hash = obj_xcoff_sym_hashes (input_bfd);
  isymp = flinfo->internal_syms;
  indexp = flinfo->sym_indices;
  csectpp = xcoff_data (input_bfd)->csects;
  lineno_counts = xcoff_data (input_bfd)->lineno_counts;
  debug_index = xcoff_data (input_bfd)->debug_indices;
  outsym = flinfo->outsyms;
  incls = 0;
  oline = NULL;
  while (esym < esym_end)
    {
      int add;

      add = 1 + isymp->n_numaux;

      if (*indexp < 0)
	esym += add * isymesz;
      else
	{
	  struct internal_syment isym;
	  int i;

	  /* Adjust the symbol in order to output it.  */
	  isym = *isymp;
	  if (isym._n._n_n._n_zeroes == 0
	      && isym._n._n_n._n_offset != 0)
	    {
	      /* This symbol has a long name.  Enter it in the string
		 table we are building.  If *debug_index != -1, the
		 name has already been entered in the .debug section.  */
	      if (*debug_index >= 0)
		isym._n._n_n._n_offset = *debug_index;
	      else
		{
		  const char *name;
		  bfd_size_type indx;

		  name = _bfd_coff_internal_syment_name (input_bfd, &isym, NULL);

		  if (name == NULL)
		    return FALSE;
		  indx = _bfd_stringtab_add (flinfo->strtab, name, hash, copy);
		  if (indx == (bfd_size_type) -1)
		    return FALSE;
		  isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
		}
	    }

	  /* Make __rtinit C_HIDEXT rather than C_EXT.  This avoids
	     multiple definition problems when linking a shared object
	     statically.  (The native linker doesn't enter __rtinit into
	     the normal table at all, but having a local symbol can make
	     the objdump output easier to read.)  */
	  if (isym.n_sclass == C_EXT
	      && *sym_hash
	      && ((*sym_hash)->flags & XCOFF_RTINIT) != 0)
	    isym.n_sclass = C_HIDEXT;

	  /* The value of a C_FILE symbol is the symbol index of the
	     next C_FILE symbol.  The value of the last C_FILE symbol
	     is -1.  We try to get this right, below, just before we
	     write the symbols out, but in the general case we may
	     have to write the symbol out twice.  */
	  if (isym.n_sclass == C_FILE)
	    {
	      if (flinfo->last_file_index != -1
		  && flinfo->last_file.n_value != (bfd_vma) *indexp)
		{
		  /* We must correct the value of the last C_FILE entry.  */
		  flinfo->last_file.n_value = *indexp;
		  if ((bfd_size_type) flinfo->last_file_index >= syment_base)
		    {
		      /* The last C_FILE symbol is in this input file.  */
		      bfd_coff_swap_sym_out (output_bfd,
					     (void *) &flinfo->last_file,
					     (void *) (flinfo->outsyms
						    + ((flinfo->last_file_index
							- syment_base)
						       * osymesz)));
		    }
		  else
		    {
		      /* We have already written out the last C_FILE
			 symbol.  We need to write it out again.  We
			 borrow *outsym temporarily.  */
		      file_ptr pos;

		      bfd_coff_swap_sym_out (output_bfd,
					     (void *) &flinfo->last_file,
					     (void *) outsym);

		      pos = obj_sym_filepos (output_bfd);
		      pos += flinfo->last_file_index * osymesz;
		      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
			  || (bfd_bwrite (outsym, osymesz, output_bfd)
			      != osymesz))
			return FALSE;
		    }
		}

	      flinfo->last_file_index = *indexp;
	      flinfo->last_file = isym;
	    }

	  /* The value of a C_BINCL or C_EINCL symbol is a file offset
	     into the line numbers.  We update the symbol values when
	     we handle the line numbers.  */
	  if (isym.n_sclass == C_BINCL
	      || isym.n_sclass == C_EINCL)
	    {
	      isym.n_value = flinfo->line_filepos;
	      ++incls;
	    }
	  /* The value of a C_BSTAT symbol is the symbol table
	     index of the containing csect.  */
	  else if (isym.n_sclass == C_BSTAT)
	    {
	      bfd_vma indx;

	      indx = isym.n_value;
	      if (indx < obj_raw_syment_count (input_bfd))
		{
		  long symindx;

		  symindx = flinfo->sym_indices[indx];
		  if (symindx < 0)
		    isym.n_value = 0;
		  else
		    isym.n_value = symindx;
		}
	    }
	  else if (isym.n_sclass != C_ESTAT
		   && isym.n_sclass != C_DECL
		   && isym.n_scnum > 0)
	    {
	      isym.n_scnum = (*csectpp)->output_section->target_index;
	      isym.n_value += ((*csectpp)->output_section->vma
			       + (*csectpp)->output_offset
			       - (*csectpp)->vma);
	    }

	  /* Output the symbol.  */
	  bfd_coff_swap_sym_out (output_bfd, (void *) &isym, (void *) outsym);

	  esym += isymesz;
	  outsym += osymesz;

	  for (i = 0; i < isymp->n_numaux && esym < esym_end; i++)
	    {
	      union internal_auxent aux;

	      bfd_coff_swap_aux_in (input_bfd, (void *) esym, isymp->n_type,
				    isymp->n_sclass, i, isymp->n_numaux,
				    (void *) &aux);

	      if (isymp->n_sclass == C_FILE)
		{
		  /* This is the file name (or some comment put in by
		     the compiler).  If it is long, we must put it in
		     the string table.  */
		  if (aux.x_file.x_n.x_zeroes == 0
		      && aux.x_file.x_n.x_offset != 0)
		    {
		      const char *filename;
		      bfd_size_type indx;

		      BFD_ASSERT (aux.x_file.x_n.x_offset
				  >= STRING_SIZE_SIZE);
		      if (strings == NULL)
			{
			  strings = _bfd_coff_read_string_table (input_bfd);
			  if (strings == NULL)
			    return FALSE;
			}
		      filename = strings + aux.x_file.x_n.x_offset;
		      indx = _bfd_stringtab_add (flinfo->strtab, filename,
						 hash, copy);
		      if (indx == (bfd_size_type) -1)
			return FALSE;
		      aux.x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;
		    }
		}
	      else if (CSECT_SYM_P (isymp->n_sclass)
		       && i + 1 == isymp->n_numaux)
		{

		  /* We don't support type checking.  I don't know if
		     anybody does.  */
		  aux.x_csect.x_parmhash = 0;
		  /* I don't think anybody uses these fields, but we'd
		     better clobber them just in case.  */
		  aux.x_csect.x_stab = 0;
		  aux.x_csect.x_snstab = 0;

		  if (SMTYP_SMTYP (aux.x_csect.x_smtyp) == XTY_LD)
		    {
		      unsigned long indx;

		      indx = aux.x_csect.x_scnlen.l;
		      if (indx < obj_raw_syment_count (input_bfd))
			{
			  long symindx;

			  symindx = flinfo->sym_indices[indx];
			  if (symindx < 0)
			    {
			      aux.x_csect.x_scnlen.l = 0;
			    }
			  else
			    {
			      aux.x_csect.x_scnlen.l = symindx;
			    }
			}
		    }
		}
	      else if (isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
		{
		  unsigned long indx;

		  if (ISFCN (isymp->n_type)
		      || ISTAG (isymp->n_sclass)
		      || isymp->n_sclass == C_BLOCK
		      || isymp->n_sclass == C_FCN)
		    {
		      indx = aux.x_sym.x_fcnary.x_fcn.x_endndx.l;
		      if (indx > 0
			  && indx < obj_raw_syment_count (input_bfd))
			{
			  /* We look forward through the symbol for
			     the index of the next symbol we are going
			     to include.  I don't know if this is
			     entirely right.  */
			  while (flinfo->sym_indices[indx] < 0
				 && indx < obj_raw_syment_count (input_bfd))
			    ++indx;
			  if (indx >= obj_raw_syment_count (input_bfd))
			    indx = output_index;
			  else
			    indx = flinfo->sym_indices[indx];
			  aux.x_sym.x_fcnary.x_fcn.x_endndx.l = indx;

			}
		    }

		  indx = aux.x_sym.x_tagndx.l;
		  if (indx > 0 && indx < obj_raw_syment_count (input_bfd))
		    {
		      long symindx;

		      symindx = flinfo->sym_indices[indx];
		      if (symindx < 0)
			aux.x_sym.x_tagndx.l = 0;
		      else
			aux.x_sym.x_tagndx.l = symindx;
		    }

		}

	      /* Copy over the line numbers, unless we are stripping
		 them.  We do this on a symbol by symbol basis in
		 order to more easily handle garbage collection.  */
	      if (CSECT_SYM_P (isymp->n_sclass)
		  && i == 0
		  && isymp->n_numaux > 1
		  && ISFCN (isymp->n_type)
		  && aux.x_sym.x_fcnary.x_fcn.x_lnnoptr != 0)
		{
		  if (*lineno_counts == 0)
		    aux.x_sym.x_fcnary.x_fcn.x_lnnoptr = 0;
		  else
		    {
		      asection *enclosing;
		      unsigned int enc_count;
		      bfd_signed_vma linoff;
		      struct internal_lineno lin;
		      bfd_byte *linp;
		      bfd_byte *linpend;
		      bfd_vma offset;
		      file_ptr pos;
		      bfd_size_type amt;

		      /* Read in the enclosing section's line-number
			 information, if we haven't already.  */
		      o = *csectpp;
		      enclosing = xcoff_section_data (abfd, o)->enclosing;
		      enc_count = xcoff_section_data (abfd, o)->lineno_count;
		      if (oline != enclosing)
			{
			  pos = enclosing->line_filepos;
			  amt = linesz * enc_count;
			  if (bfd_seek (input_bfd, pos, SEEK_SET) != 0
			      || (bfd_bread (flinfo->linenos, amt, input_bfd)
				  != amt))
			    return FALSE;
			  oline = enclosing;
			}

		      /* Copy across the first entry, adjusting its
			 symbol index.  */
		      linoff = (aux.x_sym.x_fcnary.x_fcn.x_lnnoptr
				- enclosing->line_filepos);
		      linp = flinfo->linenos + linoff;
		      bfd_coff_swap_lineno_in (input_bfd, linp, &lin);
		      lin.l_addr.l_symndx = *indexp;
		      bfd_coff_swap_lineno_out (output_bfd, &lin, linp);

		      /* Copy the other entries, adjusting their addresses.  */
		      linpend = linp + *lineno_counts * linesz;
		      offset = (o->output_section->vma
				+ o->output_offset
				- o->vma);
		      for (linp += linesz; linp < linpend; linp += linesz)
			{
			  bfd_coff_swap_lineno_in (input_bfd, linp, &lin);
			  lin.l_addr.l_paddr += offset;
			  bfd_coff_swap_lineno_out (output_bfd, &lin, linp);
			}

		      /* Write out the entries we've just processed.  */
		      pos = (o->output_section->line_filepos
			     + o->output_section->lineno_count * linesz);
		      amt = linesz * *lineno_counts;
		      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
			  || bfd_bwrite (flinfo->linenos + linoff,
					 amt, output_bfd) != amt)
			return FALSE;
		      o->output_section->lineno_count += *lineno_counts;

		      /* Record the offset of the symbol's line numbers
			 in the output file.  */
		      aux.x_sym.x_fcnary.x_fcn.x_lnnoptr = pos;

		      if (incls > 0)
			{
			  struct internal_syment *iisp, *iispend;
			  long *iindp;
			  bfd_byte *oos;
			  bfd_vma range_start, range_end;
			  int iiadd;

			  /* Update any C_BINCL or C_EINCL symbols
			     that refer to a line number in the
			     range we just output.  */
			  iisp = flinfo->internal_syms;
			  iispend = iisp + obj_raw_syment_count (input_bfd);
			  iindp = flinfo->sym_indices;
			  oos = flinfo->outsyms;
			  range_start = enclosing->line_filepos + linoff;
			  range_end = range_start + *lineno_counts * linesz;
			  while (iisp < iispend)
			    {
			      if (*iindp >= 0
				  && (iisp->n_sclass == C_BINCL
				      || iisp->n_sclass == C_EINCL)
				  && iisp->n_value >= range_start
				  && iisp->n_value < range_end)
				{
				  struct internal_syment iis;

				  bfd_coff_swap_sym_in (output_bfd, oos, &iis);
				  iis.n_value = (iisp->n_value
						 - range_start
						 + pos);
				  bfd_coff_swap_sym_out (output_bfd,
							 &iis, oos);
				  --incls;
				}

			      iiadd = 1 + iisp->n_numaux;
			      if (*iindp >= 0)
				oos += iiadd * osymesz;
			      iisp += iiadd;
			      iindp += iiadd;
			    }
			}
		    }
		}

	      bfd_coff_swap_aux_out (output_bfd, (void *) &aux, isymp->n_type,
				     isymp->n_sclass, i, isymp->n_numaux,
				     (void *) outsym);
	      outsym += osymesz;
	      esym += isymesz;
	    }
	}

      sym_hash += add;
      indexp += add;
      isymp += add;
      csectpp += add;
      lineno_counts += add;
      debug_index += add;
    }

  /* If we swapped out a C_FILE symbol, guess that the next C_FILE
     symbol will be the first symbol in the next input file.  In the
     normal case, this will save us from writing out the C_FILE symbol
     again.  */
  if (flinfo->last_file_index != -1
      && (bfd_size_type) flinfo->last_file_index >= syment_base)
    {
      flinfo->last_file.n_value = output_index;
      bfd_coff_swap_sym_out (output_bfd, (void *) &flinfo->last_file,
			     (void *) (flinfo->outsyms
 				    + ((flinfo->last_file_index - syment_base)
 				       * osymesz)));
    }

  /* Write the modified symbols to the output file.  */
  if (outsym > flinfo->outsyms)
    {
      file_ptr pos = obj_sym_filepos (output_bfd) + syment_base * osymesz;
      bfd_size_type amt = outsym - flinfo->outsyms;
      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (flinfo->outsyms, amt, output_bfd) != amt)
	return FALSE;

      BFD_ASSERT ((obj_raw_syment_count (output_bfd)
		   + (outsym - flinfo->outsyms) / osymesz)
		  == output_index);

      obj_raw_syment_count (output_bfd) = output_index;
    }

  /* Don't let the linker relocation routines discard the symbols.  */
  keep_syms = obj_coff_keep_syms (input_bfd);
  obj_coff_keep_syms (input_bfd) = TRUE;

  /* Relocate the contents of each section.  */
  for (o = input_bfd->sections; o != NULL; o = o->next)
    {
      bfd_byte *contents;

      if (! o->linker_mark)
	/* This section was omitted from the link.  */
	continue;

      if ((o->flags & SEC_HAS_CONTENTS) == 0
	  || o->size == 0
	  || (o->flags & SEC_IN_MEMORY) != 0)
	continue;

      /* We have set filepos correctly for the sections we created to
	 represent csects, so bfd_get_section_contents should work.  */
      if (coff_section_data (input_bfd, o) != NULL
	  && coff_section_data (input_bfd, o)->contents != NULL)
	contents = coff_section_data (input_bfd, o)->contents;
      else
	{
	  bfd_size_type sz = o->rawsize ? o->rawsize : o->size;
	  if (!bfd_get_section_contents (input_bfd, o, flinfo->contents, 0, sz))
	    return FALSE;
	  contents = flinfo->contents;
	}

      if ((o->flags & SEC_RELOC) != 0)
	{
	  int target_index;
	  struct internal_reloc *internal_relocs;
	  struct internal_reloc *irel;
	  bfd_vma offset;
	  struct internal_reloc *irelend;
	  struct xcoff_link_hash_entry **rel_hash;
	  long r_symndx;

	  /* Read in the relocs.  */
	  target_index = o->output_section->target_index;
	  internal_relocs = (xcoff_read_internal_relocs
			     (input_bfd, o, FALSE, flinfo->external_relocs,
			      TRUE,
			      (flinfo->section_info[target_index].relocs
			       + o->output_section->reloc_count)));
	  if (internal_relocs == NULL)
	    return FALSE;

	  /* Call processor specific code to relocate the section
	     contents.  */
	  if (! bfd_coff_relocate_section (output_bfd, flinfo->info,
					   input_bfd, o,
					   contents,
					   internal_relocs,
					   flinfo->internal_syms,
					   xcoff_data (input_bfd)->csects))
	    return FALSE;

	  offset = o->output_section->vma + o->output_offset - o->vma;
	  irel = internal_relocs;
	  irelend = irel + o->reloc_count;
	  rel_hash = (flinfo->section_info[target_index].rel_hashes
		      + o->output_section->reloc_count);
	  for (; irel < irelend; irel++, rel_hash++)
	    {
	      struct xcoff_link_hash_entry *h = NULL;

	      *rel_hash = NULL;

	      /* Adjust the reloc address and symbol index.  */

	      irel->r_vaddr += offset;

	      r_symndx = irel->r_symndx;

	      if (r_symndx == -1)
		h = NULL;
	      else
		h = obj_xcoff_sym_hashes (input_bfd)[r_symndx];

	      if (r_symndx != -1 && flinfo->info->strip != strip_all)
		{
		  if (h != NULL
		      && h->smclas != XMC_TD
		      && (irel->r_type == R_TOC
			  || irel->r_type == R_GL
			  || irel->r_type == R_TCL
			  || irel->r_type == R_TRL
			  || irel->r_type == R_TRLA))
		    {
		      /* This is a TOC relative reloc with a symbol
			 attached.  The symbol should be the one which
			 this reloc is for.  We want to make this
			 reloc against the TOC address of the symbol,
			 not the symbol itself.  */
		      BFD_ASSERT (h->toc_section != NULL);
		      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
		      if (h->u.toc_indx != -1)
			irel->r_symndx = h->u.toc_indx;
		      else
			{
			  struct xcoff_toc_rel_hash *n;
			  struct xcoff_link_section_info *si;
			  bfd_size_type amt;

			  amt = sizeof (* n);
			  n = bfd_alloc (flinfo->output_bfd, amt);
			  if (n == NULL)
			    return FALSE;
			  si = flinfo->section_info + target_index;
			  n->next = si->toc_rel_hashes;
			  n->h = h;
			  n->rel = irel;
			  si->toc_rel_hashes = n;
			}
		    }
		  else if (h != NULL)
		    {
		      /* This is a global symbol.  */
		      if (h->indx >= 0)
			irel->r_symndx = h->indx;
		      else
			{
			  /* This symbol is being written at the end
			     of the file, and we do not yet know the
			     symbol index.  We save the pointer to the
			     hash table entry in the rel_hash list.
			     We set the indx field to -2 to indicate
			     that this symbol must not be stripped.  */
			  *rel_hash = h;
			  h->indx = -2;
			}
		    }
		  else
		    {
		      long indx;

		      indx = flinfo->sym_indices[r_symndx];

		      if (indx == -1)
			{
			  struct internal_syment *is;

			  /* Relocations against a TC0 TOC anchor are
			     automatically transformed to be against
			     the TOC anchor in the output file.  */
			  is = flinfo->internal_syms + r_symndx;
			  if (is->n_sclass == C_HIDEXT
			      && is->n_numaux > 0)
			    {
			      void * auxptr;
			      union internal_auxent aux;

			      auxptr = ((void *)
					(((bfd_byte *)
					  obj_coff_external_syms (input_bfd))
					 + ((r_symndx + is->n_numaux)
					    * isymesz)));
			      bfd_coff_swap_aux_in (input_bfd, auxptr,
						    is->n_type, is->n_sclass,
						    is->n_numaux - 1,
						    is->n_numaux,
						    (void *) &aux);
			      if (SMTYP_SMTYP (aux.x_csect.x_smtyp) == XTY_SD
				  && aux.x_csect.x_smclas == XMC_TC0)
				indx = flinfo->toc_symindx;
			    }
			}

		      if (indx != -1)
			irel->r_symndx = indx;
		      else
			{

			  struct internal_syment *is;

			  const char *name;
			  char buf[SYMNMLEN + 1];

			  /* This reloc is against a symbol we are
			     stripping.  It would be possible to handle
			     this case, but I don't think it's worth it.  */
			  is = flinfo->internal_syms + r_symndx;

                          if (is->n_sclass != C_DWARF)
                            {
                              name = (_bfd_coff_internal_syment_name
                                      (input_bfd, is, buf));

                              if (name == NULL)
                                return FALSE;

                              if (!(*flinfo->info->callbacks->unattached_reloc)
                                  (flinfo->info, name, input_bfd, o,
                                   irel->r_vaddr))
                                return FALSE;
                            }
			}
		    }
		}

	      if ((o->flags & SEC_DEBUGGING) == 0
                  && xcoff_need_ldrel_p (flinfo->info, irel, h))
		{
		  asection *sec;

		  if (r_symndx == -1)
		    sec = NULL;
		  else if (h == NULL)
		    sec = xcoff_data (input_bfd)->csects[r_symndx];
		  else
		    sec = xcoff_symbol_section (h);
		  if (!xcoff_create_ldrel (output_bfd, flinfo,
					   o->output_section, input_bfd,
					   irel, sec, h))
		    return FALSE;
		}
	    }

	  o->output_section->reloc_count += o->reloc_count;
	}

      /* Write out the modified section contents.  */
      if (! bfd_set_section_contents (output_bfd, o->output_section,
				      contents, (file_ptr) o->output_offset,
				      o->size))
	return FALSE;
    }

  obj_coff_keep_syms (input_bfd) = keep_syms;

  if (! flinfo->info->keep_memory)
    {
      if (! _bfd_coff_free_symbols (input_bfd))
	return FALSE;
    }

  return TRUE;
}

#undef N_TMASK
#undef N_BTSHFT

/* Sort relocs by VMA.  This is called via qsort.  */

static int
xcoff_sort_relocs (const void * p1, const void * p2)
{
  const struct internal_reloc *r1 = (const struct internal_reloc *) p1;
  const struct internal_reloc *r2 = (const struct internal_reloc *) p2;

  if (r1->r_vaddr > r2->r_vaddr)
    return 1;
  else if (r1->r_vaddr < r2->r_vaddr)
    return -1;
  else
    return 0;
}

/* Return true if section SEC is a TOC section.  */

static inline bfd_boolean
xcoff_toc_section_p (asection *sec)
{
  const char *name;

  name = sec->name;
  if (name[0] == '.' && name[1] == 't')
    {
      if (name[2] == 'c')
	{
	  if (name[3] == '0' && name[4] == 0)
	    return TRUE;
	  if (name[3] == 0)
	    return TRUE;
	}
      if (name[2] == 'd' && name[3] == 0)
	return TRUE;
    }
  return FALSE;
}

/* See if the link requires a TOC (it usually does!).  If so, find a
   good place to put the TOC anchor csect, and write out the associated
   symbol.  */

static bfd_boolean
xcoff_find_tc0 (bfd *output_bfd, struct xcoff_final_link_info *flinfo)
{
  bfd_vma toc_start, toc_end, start, end, best_address;
  asection *sec;
  bfd *input_bfd;
  int section_index;
  struct internal_syment irsym;
  union internal_auxent iraux;
  file_ptr pos;
  size_t size;

  /* Set [TOC_START, TOC_END) to the range of the TOC.  Record the
     index of a csect at the beginning of the TOC.  */
  toc_start = ~(bfd_vma) 0;
  toc_end = 0;
  section_index = -1;
  for (input_bfd = flinfo->info->input_bfds;
       input_bfd != NULL;
       input_bfd = input_bfd->link_next)
    for (sec = input_bfd->sections; sec != NULL; sec = sec->next)
      if ((sec->flags & SEC_MARK) != 0 && xcoff_toc_section_p (sec))
	{
	  start = sec->output_section->vma + sec->output_offset;
	  if (toc_start > start)
	    {
	      toc_start = start;
	      section_index = sec->output_section->target_index;
	    }

	  end = start + sec->size;
	  if (toc_end < end)
	    toc_end = end;
	}

  /* There's no need for a TC0 symbol if we don't have a TOC.  */
  if (toc_end < toc_start)
    {
      xcoff_data (output_bfd)->toc = toc_start;
      return TRUE;
    }

  if (toc_end - toc_start < 0x8000)
    /* Every TOC csect can be accessed from TOC_START.  */
    best_address = toc_start;
  else
    {
      /* Find the lowest TOC csect that is still within range of TOC_END.  */
      best_address = toc_end;
      for (input_bfd = flinfo->info->input_bfds;
	   input_bfd != NULL;
	   input_bfd = input_bfd->link_next)
	for (sec = input_bfd->sections; sec != NULL; sec = sec->next)
	  if ((sec->flags & SEC_MARK) != 0 && xcoff_toc_section_p (sec))
	    {
	      start = sec->output_section->vma + sec->output_offset;
	      if (start < best_address
		  && start + 0x8000 >= toc_end)
		{
		  best_address = start;
		  section_index = sec->output_section->target_index;
		}
	    }

      /* Make sure that the start of the TOC is also within range.  */
      if (best_address > toc_start + 0x8000)
	{
	  (*_bfd_error_handler)
	    (_("TOC overflow: 0x%lx > 0x10000; try -mminimal-toc "
	       "when compiling"),
	     (unsigned long) (toc_end - toc_start));
	  bfd_set_error (bfd_error_file_too_big);
	  return FALSE;
	}
    }

  /* Record the chosen TOC value.  */
  flinfo->toc_symindx = obj_raw_syment_count (output_bfd);
  xcoff_data (output_bfd)->toc = best_address;
  xcoff_data (output_bfd)->sntoc = section_index;

  /* Fill out the TC0 symbol.  */
  if (!bfd_xcoff_put_symbol_name (output_bfd, flinfo->strtab, &irsym, "TOC"))
    return FALSE;
  irsym.n_value = best_address;
  irsym.n_scnum = section_index;
  irsym.n_sclass = C_HIDEXT;
  irsym.n_type = T_NULL;
  irsym.n_numaux = 1;
  bfd_coff_swap_sym_out (output_bfd, &irsym, flinfo->outsyms);

  /* Fill out the auxillary csect information.  */
  memset (&iraux, 0, sizeof iraux);
  iraux.x_csect.x_smtyp = XTY_SD;
  iraux.x_csect.x_smclas = XMC_TC0;
  iraux.x_csect.x_scnlen.l = 0;
  bfd_coff_swap_aux_out (output_bfd, &iraux, T_NULL, C_HIDEXT, 0, 1,
			 flinfo->outsyms + bfd_coff_symesz (output_bfd));

  /* Write the contents to the file.  */
  pos = obj_sym_filepos (output_bfd);
  pos += obj_raw_syment_count (output_bfd) * bfd_coff_symesz (output_bfd);
  size = 2 * bfd_coff_symesz (output_bfd);
  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
      || bfd_bwrite (flinfo->outsyms, size, output_bfd) != size)
    return FALSE;
  obj_raw_syment_count (output_bfd) += 2;

  return TRUE;
}

/* Write out a non-XCOFF global symbol.  */

static bfd_boolean
xcoff_write_global_symbol (struct bfd_hash_entry *bh, void * inf)
{
  struct xcoff_link_hash_entry *h = (struct xcoff_link_hash_entry *) bh;
  struct xcoff_final_link_info *flinfo = (struct xcoff_final_link_info *) inf;
  bfd *output_bfd;
  bfd_byte *outsym;
  struct internal_syment isym;
  union internal_auxent aux;
  bfd_boolean result;
  file_ptr pos;
  bfd_size_type amt;

  output_bfd = flinfo->output_bfd;
  outsym = flinfo->outsyms;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct xcoff_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

  /* If this symbol was garbage collected, just skip it.  */
  if (xcoff_hash_table (flinfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0)
    return TRUE;

  /* If we need a .loader section entry, write it out.  */
  if (h->ldsym != NULL)
    {
      struct internal_ldsym *ldsym;
      bfd *impbfd;

      ldsym = h->ldsym;

      if (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	{

	  ldsym->l_value = 0;
	  ldsym->l_scnum = N_UNDEF;
	  ldsym->l_smtype = XTY_ER;
	  impbfd = h->root.u.undef.abfd;

	}
      else if (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	{
	  asection *sec;

	  sec = h->root.u.def.section;
	  ldsym->l_value = (sec->output_section->vma
			    + sec->output_offset
			    + h->root.u.def.value);
	  ldsym->l_scnum = sec->output_section->target_index;
	  ldsym->l_smtype = XTY_SD;
	  impbfd = sec->owner;

	}
      else
	abort ();

      if (((h->flags & XCOFF_DEF_REGULAR) == 0
	   && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	  || (h->flags & XCOFF_IMPORT) != 0)
	/* Clear l_smtype
	   Import symbols are defined so the check above will make
	   the l_smtype XTY_SD.  But this is not correct, it should
	   be cleared.  */
	ldsym->l_smtype |= L_IMPORT;

      if (((h->flags & XCOFF_DEF_REGULAR) != 0
	   && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	  || (h->flags & XCOFF_EXPORT) != 0)
	ldsym->l_smtype |= L_EXPORT;

      if ((h->flags & XCOFF_ENTRY) != 0)
	ldsym->l_smtype |= L_ENTRY;

      if ((h->flags & XCOFF_RTINIT) != 0)
	ldsym->l_smtype = XTY_SD;

      ldsym->l_smclas = h->smclas;

      if (ldsym->l_smtype & L_IMPORT)
	{
	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && (h->root.u.def.value != 0))
	    ldsym->l_smclas = XMC_XO;

	  else if ((h->flags & (XCOFF_SYSCALL32 | XCOFF_SYSCALL64)) ==
		   (XCOFF_SYSCALL32 | XCOFF_SYSCALL64))
	    ldsym->l_smclas = XMC_SV3264;

	  else if (h->flags & XCOFF_SYSCALL32)
	    ldsym->l_smclas = XMC_SV;

	  else if (h->flags & XCOFF_SYSCALL64)
	    ldsym->l_smclas = XMC_SV64;
	}

      if (ldsym->l_ifile == -(bfd_size_type) 1)
	{
	  ldsym->l_ifile = 0;
	}
      else if (ldsym->l_ifile == 0)
	{
	  if ((ldsym->l_smtype & L_IMPORT) == 0)
	    ldsym->l_ifile = 0;
	  else if (impbfd == NULL)
	    ldsym->l_ifile = 0;
	  else
	    {
	      BFD_ASSERT (impbfd->xvec == output_bfd->xvec);
	      ldsym->l_ifile = xcoff_data (impbfd)->import_file_id;
	    }
	}

      ldsym->l_parm = 0;

      BFD_ASSERT (h->ldindx >= 0);

      bfd_xcoff_swap_ldsym_out (output_bfd, ldsym,
				(flinfo->ldsym +
				 (h->ldindx - 3)
				 * bfd_xcoff_ldsymsz(flinfo->output_bfd)));
      h->ldsym = NULL;
    }

  /* If this symbol needs global linkage code, write it out.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->root.u.def.section
	  == xcoff_hash_table (flinfo->info)->linkage_section))
    {
      bfd_byte *p;
      bfd_vma tocoff;
      unsigned int i;

      p = h->root.u.def.section->contents + h->root.u.def.value;

      /* The first instruction in the global linkage code loads a
	 specific TOC element.  */
      tocoff = (h->descriptor->toc_section->output_section->vma
		+ h->descriptor->toc_section->output_offset
		- xcoff_data (output_bfd)->toc);

      if ((h->descriptor->flags & XCOFF_SET_TOC) != 0)
	tocoff += h->descriptor->u.toc_offset;

      /* The first instruction in the glink code needs to be
	 cooked to to hold the correct offset in the toc.  The
	 rest are just output raw.  */
      bfd_put_32 (output_bfd,
		  bfd_xcoff_glink_code(output_bfd, 0) | (tocoff & 0xffff), p);

      /* Start with i == 1 to get past the first instruction done above
	 The /4 is because the glink code is in bytes and we are going
	 4 at a pop.  */
      for (i = 1; i < bfd_xcoff_glink_code_size(output_bfd) / 4; i++)
	bfd_put_32 (output_bfd,
		    (bfd_vma) bfd_xcoff_glink_code(output_bfd, i),
		    &p[4 * i]);
    }

  /* If we created a TOC entry for this symbol, write out the required
     relocs.  */
  if ((h->flags & XCOFF_SET_TOC) != 0)
    {
      asection *tocsec;
      asection *osec;
      int oindx;
      struct internal_reloc *irel;
      struct internal_syment irsym;
      union internal_auxent iraux;

      tocsec = h->toc_section;
      osec = tocsec->output_section;
      oindx = osec->target_index;
      irel = flinfo->section_info[oindx].relocs + osec->reloc_count;
      irel->r_vaddr = (osec->vma
		       + tocsec->output_offset
		       + h->u.toc_offset);

      if (h->indx >= 0)
	irel->r_symndx = h->indx;
      else
	{
	  h->indx = -2;
	  irel->r_symndx = obj_raw_syment_count (output_bfd);
	}

      BFD_ASSERT (h->ldindx >= 0);

      /* Initialize the aux union here instead of closer to when it is
	 written out below because the length of the csect depends on
	 whether the output is 32 or 64 bit.  */
      memset (&iraux, 0, sizeof iraux);
      iraux.x_csect.x_smtyp = XTY_SD;
      /* iraux.x_csect.x_scnlen.l = 4 or 8, see below.  */
      iraux.x_csect.x_smclas = XMC_TC;

      /* 32 bit uses a 32 bit R_POS to do the relocations
	 64 bit uses a 64 bit R_POS to do the relocations

	 Also needs to change the csect size : 4 for 32 bit, 8 for 64 bit

	 Which one is determined by the backend.  */
      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  irel->r_size = 63;
	  iraux.x_csect.x_scnlen.l = 8;
	}
      else if (bfd_xcoff_is_xcoff32 (output_bfd))
	{
	  irel->r_size = 31;
	  iraux.x_csect.x_scnlen.l = 4;
	}
      else
	return FALSE;

      irel->r_type = R_POS;
      flinfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
      ++osec->reloc_count;

      if (!xcoff_create_ldrel (output_bfd, flinfo, osec,
			       output_bfd, irel, NULL, h))
	return FALSE;

      /* We need to emit a symbol to define a csect which holds
	 the reloc.  */
      if (flinfo->info->strip != strip_all)
	{
	  result = bfd_xcoff_put_symbol_name (output_bfd, flinfo->strtab,
					      &irsym, h->root.root.string);
	  if (!result)
	    return FALSE;

	  irsym.n_value = irel->r_vaddr;
	  irsym.n_scnum = osec->target_index;
	  irsym.n_sclass = C_HIDEXT;
	  irsym.n_type = T_NULL;
	  irsym.n_numaux = 1;

	  bfd_coff_swap_sym_out (output_bfd, (void *) &irsym, (void *) outsym);
	  outsym += bfd_coff_symesz (output_bfd);

	  /* Note : iraux is initialized above.  */
	  bfd_coff_swap_aux_out (output_bfd, (void *) &iraux, T_NULL, C_HIDEXT,
				 0, 1, (void *) outsym);
	  outsym += bfd_coff_auxesz (output_bfd);

	  if (h->indx >= 0)
	    {
	      /* We aren't going to write out the symbols below, so we
		 need to write them out now.  */
	      pos = obj_sym_filepos (output_bfd);
	      pos += (obj_raw_syment_count (output_bfd)
		      * bfd_coff_symesz (output_bfd));
	      amt = outsym - flinfo->outsyms;
	      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
		  || bfd_bwrite (flinfo->outsyms, amt, output_bfd) != amt)
		return FALSE;
	      obj_raw_syment_count (output_bfd) +=
		(outsym - flinfo->outsyms) / bfd_coff_symesz (output_bfd);

	      outsym = flinfo->outsyms;
	    }
	}
    }

  /* If this symbol is a specially defined function descriptor, write
     it out.  The first word is the address of the function code
     itself, the second word is the address of the TOC, and the third
     word is zero.

     32 bit vs 64 bit
     The addresses for the 32 bit will take 4 bytes and the addresses
     for 64 bit will take 8 bytes.  Similar for the relocs.  This type
     of logic was also done above to create a TOC entry in
     xcoff_write_global_symbol.  */
  if ((h->flags & XCOFF_DESCRIPTOR) != 0
      && h->root.type == bfd_link_hash_defined
      && (h->root.u.def.section
	  == xcoff_hash_table (flinfo->info)->descriptor_section))
    {
      asection *sec;
      asection *osec;
      int oindx;
      bfd_byte *p;
      struct xcoff_link_hash_entry *hentry;
      asection *esec;
      struct internal_reloc *irel;
      asection *tsec;
      unsigned int reloc_size, byte_size;

      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  reloc_size = 63;
	  byte_size = 8;
	}
      else if (bfd_xcoff_is_xcoff32 (output_bfd))
	{
	  reloc_size = 31;
	  byte_size = 4;
	}
      else
	return FALSE;

      sec = h->root.u.def.section;
      osec = sec->output_section;
      oindx = osec->target_index;
      p = sec->contents + h->root.u.def.value;

      hentry = h->descriptor;
      BFD_ASSERT (hentry != NULL
		  && (hentry->root.type == bfd_link_hash_defined
		      || hentry->root.type == bfd_link_hash_defweak));
      esec = hentry->root.u.def.section;

      irel = flinfo->section_info[oindx].relocs + osec->reloc_count;
      irel->r_vaddr = (osec->vma
		       + sec->output_offset
		       + h->root.u.def.value);
      irel->r_symndx = esec->output_section->target_index;
      irel->r_type = R_POS;
      irel->r_size = reloc_size;
      flinfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
      ++osec->reloc_count;

      if (!xcoff_create_ldrel (output_bfd, flinfo, osec,
			       output_bfd, irel, esec, NULL))
	return FALSE;

      /* There are three items to write out,
	 the address of the code
	 the address of the toc anchor
	 the environment pointer.
	 We are ignoring the environment pointer.  So set it to zero.  */
      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  bfd_put_64 (output_bfd,
		      (esec->output_section->vma + esec->output_offset
		       + hentry->root.u.def.value),
		      p);
	  bfd_put_64 (output_bfd, xcoff_data (output_bfd)->toc, p + 8);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, p + 16);
	}
      else
	{
	  /* 32 bit backend
	     This logic was already called above so the error case where
	     the backend is neither has already been checked.  */
	  bfd_put_32 (output_bfd,
		      (esec->output_section->vma + esec->output_offset
		       + hentry->root.u.def.value),
		      p);
	  bfd_put_32 (output_bfd, xcoff_data (output_bfd)->toc, p + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, p + 8);
	}

      tsec = coff_section_from_bfd_index (output_bfd,
					  xcoff_data (output_bfd)->sntoc);

      ++irel;
      irel->r_vaddr = (osec->vma
		       + sec->output_offset
		       + h->root.u.def.value
		       + byte_size);
      irel->r_symndx = tsec->output_section->target_index;
      irel->r_type = R_POS;
      irel->r_size = reloc_size;
      flinfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
      ++osec->reloc_count;

      if (!xcoff_create_ldrel (output_bfd, flinfo, osec,
			       output_bfd, irel, tsec, NULL))
	return FALSE;
    }

  if (h->indx >= 0 || flinfo->info->strip == strip_all)
    {
      BFD_ASSERT (outsym == flinfo->outsyms);
      return TRUE;
    }

  if (h->indx != -2
      && (flinfo->info->strip == strip_all
	  || (flinfo->info->strip == strip_some
	      && bfd_hash_lookup (flinfo->info->keep_hash, h->root.root.string,
				  FALSE, FALSE) == NULL)))
    {
      BFD_ASSERT (outsym == flinfo->outsyms);
      return TRUE;
    }

  if (h->indx != -2
      && (h->flags & (XCOFF_REF_REGULAR | XCOFF_DEF_REGULAR)) == 0)
    {
      BFD_ASSERT (outsym == flinfo->outsyms);
      return TRUE;
    }

  memset (&aux, 0, sizeof aux);

  h->indx = obj_raw_syment_count (output_bfd);

  result = bfd_xcoff_put_symbol_name (output_bfd, flinfo->strtab, &isym,
				      h->root.root.string);
  if (!result)
    return FALSE;

  if (h->root.type == bfd_link_hash_undefined
      || h->root.type == bfd_link_hash_undefweak)
    {
      isym.n_value = 0;
      isym.n_scnum = N_UNDEF;
      if (h->root.type == bfd_link_hash_undefweak
	  && C_WEAKEXT == C_AIX_WEAKEXT)
	isym.n_sclass = C_WEAKEXT;
      else
	isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_ER;
    }
  else if ((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && h->smclas == XMC_XO)
    {
      BFD_ASSERT (bfd_is_abs_section (h->root.u.def.section));
      isym.n_value = h->root.u.def.value;
      isym.n_scnum = N_UNDEF;
      if (h->root.type == bfd_link_hash_undefweak
	  && C_WEAKEXT == C_AIX_WEAKEXT)
	isym.n_sclass = C_WEAKEXT;
      else
	isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_ER;
    }
  else if (h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
    {
      struct xcoff_link_size_list *l;

      isym.n_value = (h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset
		      + h->root.u.def.value);
      if (bfd_is_abs_section (h->root.u.def.section->output_section))
	isym.n_scnum = N_ABS;
      else
	isym.n_scnum = h->root.u.def.section->output_section->target_index;
      isym.n_sclass = C_HIDEXT;
      aux.x_csect.x_smtyp = XTY_SD;

      if ((h->flags & XCOFF_HAS_SIZE) != 0)
	{
	  for (l = xcoff_hash_table (flinfo->info)->size_list;
	       l != NULL;
	       l = l->next)
	    {
	      if (l->h == h)
		{
		  aux.x_csect.x_scnlen.l = l->size;
		  break;
		}
	    }
	}
    }
  else if (h->root.type == bfd_link_hash_common)
    {
      isym.n_value = (h->root.u.c.p->section->output_section->vma
		      + h->root.u.c.p->section->output_offset);
      isym.n_scnum = h->root.u.c.p->section->output_section->target_index;
      isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_CM;
      aux.x_csect.x_scnlen.l = h->root.u.c.size;
    }
  else
    abort ();

  isym.n_type = T_NULL;
  isym.n_numaux = 1;

  bfd_coff_swap_sym_out (output_bfd, (void *) &isym, (void *) outsym);
  outsym += bfd_coff_symesz (output_bfd);

  aux.x_csect.x_smclas = h->smclas;
  bfd_coff_swap_aux_out (output_bfd, (void *) &aux, T_NULL, isym.n_sclass, 0, 1,
			 (void *) outsym);
  outsym += bfd_coff_auxesz (output_bfd);

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && h->smclas != XMC_XO)
    {
      /* We just output an SD symbol.  Now output an LD symbol.  */
      h->indx += 2;

      if (h->root.type == bfd_link_hash_undefweak
	  && C_WEAKEXT == C_AIX_WEAKEXT)
	isym.n_sclass = C_WEAKEXT;
      else
	isym.n_sclass = C_EXT;
      bfd_coff_swap_sym_out (output_bfd, (void *) &isym, (void *) outsym);
      outsym += bfd_coff_symesz (output_bfd);

      aux.x_csect.x_smtyp = XTY_LD;
      aux.x_csect.x_scnlen.l = obj_raw_syment_count (output_bfd);
      bfd_coff_swap_aux_out (output_bfd, (void *) &aux, T_NULL, C_EXT, 0, 1,
			     (void *) outsym);
      outsym += bfd_coff_auxesz (output_bfd);
    }

  pos = obj_sym_filepos (output_bfd);
  pos += obj_raw_syment_count (output_bfd) * bfd_coff_symesz (output_bfd);
  amt = outsym - flinfo->outsyms;
  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
      || bfd_bwrite (flinfo->outsyms, amt, output_bfd) != amt)
    return FALSE;
  obj_raw_syment_count (output_bfd) +=
    (outsym - flinfo->outsyms) / bfd_coff_symesz (output_bfd);

  return TRUE;
}

/* Handle a link order which is supposed to generate a reloc.  */

static bfd_boolean
xcoff_reloc_link_order (bfd *output_bfd,
			struct xcoff_final_link_info *flinfo,
			asection *output_section,
			struct bfd_link_order *link_order)
{
  reloc_howto_type *howto;
  struct xcoff_link_hash_entry *h;
  asection *hsec;
  bfd_vma hval;
  bfd_vma addend;
  struct internal_reloc *irel;
  struct xcoff_link_hash_entry **rel_hash_ptr;

  if (link_order->type == bfd_section_reloc_link_order)
    /* We need to somehow locate a symbol in the right section.  The
       symbol must either have a value of zero, or we must adjust
       the addend by the value of the symbol.  FIXME: Write this
       when we need it.  The old linker couldn't handle this anyhow.  */
    abort ();

  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (howto == NULL)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  h = ((struct xcoff_link_hash_entry *)
       bfd_wrapped_link_hash_lookup (output_bfd, flinfo->info,
				     link_order->u.reloc.p->u.name,
				     FALSE, FALSE, TRUE));
  if (h == NULL)
    {
      if (! ((*flinfo->info->callbacks->unattached_reloc)
	     (flinfo->info, link_order->u.reloc.p->u.name, NULL, NULL, (bfd_vma) 0)))
	return FALSE;
      return TRUE;
    }

  hsec = xcoff_symbol_section (h);
  if (h->root.type == bfd_link_hash_defined
      || h->root.type == bfd_link_hash_defweak)
    hval = h->root.u.def.value;
  else
    hval = 0;

  addend = link_order->u.reloc.p->addend;
  if (hsec != NULL)
    addend += (hsec->output_section->vma
	       + hsec->output_offset
	       + hval);

  if (addend != 0)
    {
      bfd_size_type size;
      bfd_byte *buf;
      bfd_reloc_status_type rstat;
      bfd_boolean ok;

      size = bfd_get_reloc_size (howto);
      buf = bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;

      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
      switch (rstat)
	{
	case bfd_reloc_ok:
	  break;
	default:
	case bfd_reloc_outofrange:
	  abort ();
	case bfd_reloc_overflow:
	  if (! ((*flinfo->info->callbacks->reloc_overflow)
		 (flinfo->info, NULL, link_order->u.reloc.p->u.name,
		  howto->name, addend, NULL, NULL, (bfd_vma) 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
	}
      ok = bfd_set_section_contents (output_bfd, output_section, (void *) buf,
				     (file_ptr) link_order->offset, size);
      free (buf);
      if (! ok)
	return FALSE;
    }

  /* Store the reloc information in the right place.  It will get
     swapped and written out at the end of the final_link routine.  */
  irel = (flinfo->section_info[output_section->target_index].relocs
	  + output_section->reloc_count);
  rel_hash_ptr = (flinfo->section_info[output_section->target_index].rel_hashes
		  + output_section->reloc_count);

  memset (irel, 0, sizeof (struct internal_reloc));
  *rel_hash_ptr = NULL;

  irel->r_vaddr = output_section->vma + link_order->offset;

  if (h->indx >= 0)
    irel->r_symndx = h->indx;
  else
    {
      /* Set the index to -2 to force this symbol to get written out.  */
      h->indx = -2;
      *rel_hash_ptr = h;
      irel->r_symndx = 0;
    }

  irel->r_type = howto->type;
  irel->r_size = howto->bitsize - 1;
  if (howto->complain_on_overflow == complain_overflow_signed)
    irel->r_size |= 0x80;

  ++output_section->reloc_count;

  /* Now output the reloc to the .loader section.  */
  if (xcoff_hash_table (flinfo->info)->loader_section)
    {
      if (!xcoff_create_ldrel (output_bfd, flinfo, output_section,
			       output_bfd, irel, hsec, h))
	return FALSE;
    }

  return TRUE;
}

/* Do the final link step.  */

bfd_boolean
_bfd_xcoff_bfd_final_link (bfd *abfd, struct bfd_link_info *info)
{
  bfd_size_type symesz;
  struct xcoff_final_link_info flinfo;
  asection *o;
  struct bfd_link_order *p;
  bfd_size_type max_contents_size;
  bfd_size_type max_sym_count;
  bfd_size_type max_lineno_count;
  bfd_size_type max_reloc_count;
  bfd_size_type max_output_reloc_count;
  file_ptr rel_filepos;
  unsigned int relsz;
  file_ptr line_filepos;
  unsigned int linesz;
  bfd *sub;
  bfd_byte *external_relocs = NULL;
  char strbuf[STRING_SIZE_SIZE];
  file_ptr pos;
  bfd_size_type amt;

  if (info->shared)
    abfd->flags |= DYNAMIC;

  symesz = bfd_coff_symesz (abfd);

  flinfo.info = info;
  flinfo.output_bfd = abfd;
  flinfo.strtab = NULL;
  flinfo.section_info = NULL;
  flinfo.last_file_index = -1;
  flinfo.toc_symindx = -1;
  flinfo.internal_syms = NULL;
  flinfo.sym_indices = NULL;
  flinfo.outsyms = NULL;
  flinfo.linenos = NULL;
  flinfo.contents = NULL;
  flinfo.external_relocs = NULL;

  if (xcoff_hash_table (info)->loader_section)
    {
      flinfo.ldsym = (xcoff_hash_table (info)->loader_section->contents
		     + bfd_xcoff_ldhdrsz (abfd));
      flinfo.ldrel = (xcoff_hash_table (info)->loader_section->contents
		     + bfd_xcoff_ldhdrsz (abfd)
		     + (xcoff_hash_table (info)->ldhdr.l_nsyms
			* bfd_xcoff_ldsymsz (abfd)));
    }
  else
    {
      flinfo.ldsym = NULL;
      flinfo.ldrel = NULL;
    }

  xcoff_data (abfd)->coff.link_info = info;

  flinfo.strtab = _bfd_stringtab_init ();
  if (flinfo.strtab == NULL)
    goto error_return;

  /* Count the relocation entries required for the output file.
     (We've already counted the line numbers.)  Determine a few
     maximum sizes.  */
  max_contents_size = 0;
  max_lineno_count = 0;
  max_reloc_count = 0;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      o->reloc_count = 0;
      for (p = o->map_head.link_order; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;

	      o->reloc_count += sec->reloc_count;

	      if ((sec->flags & SEC_IN_MEMORY) == 0)
		{
		  if (sec->rawsize > max_contents_size)
		    max_contents_size = sec->rawsize;
		  if (sec->size > max_contents_size)
		    max_contents_size = sec->size;
		}
	      if (coff_section_data (sec->owner, sec) != NULL
		  && xcoff_section_data (sec->owner, sec) != NULL
		  && (xcoff_section_data (sec->owner, sec)->lineno_count
		      > max_lineno_count))
		max_lineno_count =
		  xcoff_section_data (sec->owner, sec)->lineno_count;
	      if (sec->reloc_count > max_reloc_count)
		max_reloc_count = sec->reloc_count;
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    ++o->reloc_count;
	}
    }

  /* Compute the file positions for all the sections.  */
  if (abfd->output_has_begun)
    {
      if (xcoff_hash_table (info)->file_align != 0)
	abort ();
    }
  else
    {
      bfd_vma file_align;

      file_align = xcoff_hash_table (info)->file_align;
      if (file_align != 0)
	{
	  bfd_boolean saw_contents;
	  int indx;
	  file_ptr sofar;

	  /* Insert .pad sections before every section which has
	     contents and is loaded, if it is preceded by some other
	     section which has contents and is loaded.  */
	  saw_contents = TRUE;
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      if (strcmp (o->name, ".pad") == 0)
		saw_contents = FALSE;
	      else if ((o->flags & SEC_HAS_CONTENTS) != 0
		       && (o->flags & SEC_LOAD) != 0)
		{
		  if (! saw_contents)
		    saw_contents = TRUE;
		  else
		    {
		      asection *n;

		      /* Create a pad section and place it before the section
			 that needs padding.  This requires unlinking and
			 relinking the bfd's section list.  */

		      n = bfd_make_section_anyway_with_flags (abfd, ".pad",
							      SEC_HAS_CONTENTS);
		      n->alignment_power = 0;

		      bfd_section_list_remove (abfd, n);
		      bfd_section_list_insert_before (abfd, o, n);
		      saw_contents = FALSE;
		    }
		}
	    }

	  /* Reset the section indices after inserting the new
	     sections.  */
	  indx = 0;
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      ++indx;
	      o->target_index = indx;
	    }
	  BFD_ASSERT ((unsigned int) indx == abfd->section_count);

	  /* Work out appropriate sizes for the .pad sections to force
	     each section to land on a page boundary.  This bit of
	     code knows what compute_section_file_positions is going
	     to do.  */
	  sofar = bfd_coff_filhsz (abfd);
	  sofar += bfd_coff_aoutsz (abfd);
	  sofar += abfd->section_count * bfd_coff_scnhsz (abfd);
	  for (o = abfd->sections; o != NULL; o = o->next)
	    if ((bfd_xcoff_is_reloc_count_overflow
		 (abfd, (bfd_vma) o->reloc_count))
		|| (bfd_xcoff_is_lineno_count_overflow
		    (abfd, (bfd_vma) o->lineno_count)))
	      /* 64 does not overflow, need to check if 32 does */
	      sofar += bfd_coff_scnhsz (abfd);

	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      if (strcmp (o->name, ".pad") == 0)
		{
		  bfd_vma pageoff;

		  BFD_ASSERT (o->size == 0);
		  pageoff = sofar & (file_align - 1);
		  if (pageoff != 0)
		    {
		      o->size = file_align - pageoff;
		      sofar += file_align - pageoff;
		      o->flags |= SEC_HAS_CONTENTS;
		    }
		}
	      else
		{
		  if ((o->flags & SEC_HAS_CONTENTS) != 0)
		    sofar += BFD_ALIGN (o->size,
					1 << o->alignment_power);
		}
	    }
	}

      if (! bfd_coff_compute_section_file_positions (abfd))
	goto error_return;
    }

  /* Allocate space for the pointers we need to keep for the relocs.  */
  {
    unsigned int i;

    /* We use section_count + 1, rather than section_count, because
       the target_index fields are 1 based.  */
    amt = abfd->section_count + 1;
    amt *= sizeof (struct xcoff_link_section_info);
    flinfo.section_info = bfd_malloc (amt);
    if (flinfo.section_info == NULL)
      goto error_return;
    for (i = 0; i <= abfd->section_count; i++)
      {
	flinfo.section_info[i].relocs = NULL;
	flinfo.section_info[i].rel_hashes = NULL;
	flinfo.section_info[i].toc_rel_hashes = NULL;
      }
  }

  /* Set the file positions for the relocs.  */
  rel_filepos = obj_relocbase (abfd);
  relsz = bfd_coff_relsz (abfd);
  max_output_reloc_count = 0;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->reloc_count == 0)
	o->rel_filepos = 0;
      else
	{
	  /* A stripped file has no relocs.  However, we still
	     allocate the buffers, so that later code doesn't have to
	     worry about whether we are stripping or not.  */
	  if (info->strip == strip_all)
	    o->rel_filepos = 0;
	  else
	    {
	      o->flags |= SEC_RELOC;
	      o->rel_filepos = rel_filepos;
	      rel_filepos += o->reloc_count * relsz;
	    }

	  /* We don't know the indices of global symbols until we have
	     written out all the local symbols.  For each section in
	     the output file, we keep an array of pointers to hash
	     table entries.  Each entry in the array corresponds to a
	     reloc.  When we find a reloc against a global symbol, we
	     set the corresponding entry in this array so that we can
	     fix up the symbol index after we have written out all the
	     local symbols.

	     Because of this problem, we also keep the relocs in
	     memory until the end of the link.  This wastes memory.
	     We could backpatch the file later, I suppose, although it
	     would be slow.  */
	  amt = o->reloc_count;
	  amt *= sizeof (struct internal_reloc);
	  flinfo.section_info[o->target_index].relocs = bfd_malloc (amt);

	  amt = o->reloc_count;
	  amt *= sizeof (struct xcoff_link_hash_entry *);
	  flinfo.section_info[o->target_index].rel_hashes = bfd_malloc (amt);

	  if (flinfo.section_info[o->target_index].relocs == NULL
	      || flinfo.section_info[o->target_index].rel_hashes == NULL)
	    goto error_return;

	  if (o->reloc_count > max_output_reloc_count)
	    max_output_reloc_count = o->reloc_count;
	}
    }

  /* We now know the size of the relocs, so we can determine the file
     positions of the line numbers.  */
  line_filepos = rel_filepos;
  flinfo.line_filepos = line_filepos;
  linesz = bfd_coff_linesz (abfd);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->lineno_count == 0)
	o->line_filepos = 0;
      else
	{
	  o->line_filepos = line_filepos;
	  line_filepos += o->lineno_count * linesz;
	}

      /* Reset the reloc and lineno counts, so that we can use them to
	 count the number of entries we have output so far.  */
      o->reloc_count = 0;
      o->lineno_count = 0;
    }

  obj_sym_filepos (abfd) = line_filepos;

  /* Figure out the largest number of symbols in an input BFD.  Take
     the opportunity to clear the output_has_begun fields of all the
     input BFD's.  We want at least 6 symbols, since that is the
     number which xcoff_write_global_symbol may need.  */
  max_sym_count = 6;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      bfd_size_type sz;

      sub->output_has_begun = FALSE;
      sz = obj_raw_syment_count (sub);
      if (sz > max_sym_count)
	max_sym_count = sz;
    }

  /* Allocate some buffers used while linking.  */
  amt = max_sym_count * sizeof (struct internal_syment);
  flinfo.internal_syms = bfd_malloc (amt);

  amt = max_sym_count * sizeof (long);
  flinfo.sym_indices = bfd_malloc (amt);

  amt = (max_sym_count + 1) * symesz;
  flinfo.outsyms = bfd_malloc (amt);

  amt = max_lineno_count * bfd_coff_linesz (abfd);
  flinfo.linenos = bfd_malloc (amt);

  amt = max_contents_size;
  flinfo.contents = bfd_malloc (amt);

  amt = max_reloc_count * relsz;
  flinfo.external_relocs = bfd_malloc (amt);

  if ((flinfo.internal_syms == NULL && max_sym_count > 0)
      || (flinfo.sym_indices == NULL && max_sym_count > 0)
      || flinfo.outsyms == NULL
      || (flinfo.linenos == NULL && max_lineno_count > 0)
      || (flinfo.contents == NULL && max_contents_size > 0)
      || (flinfo.external_relocs == NULL && max_reloc_count > 0))
    goto error_return;

  obj_raw_syment_count (abfd) = 0;

  /* Find a TOC symbol, if we need one.  */
  if (!xcoff_find_tc0 (abfd, &flinfo))
    goto error_return;

  /* We now know the position of everything in the file, except that
     we don't know the size of the symbol table and therefore we don't
     know where the string table starts.  We just build the string
     table in memory as we go along.  We process all the relocations
     for a single input file at once.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->map_head.link_order; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && p->u.indirect.section->owner->xvec == abfd->xvec)
	    {
	      sub = p->u.indirect.section->owner;
	      if (! sub->output_has_begun)
		{
		  if (! xcoff_link_input_bfd (&flinfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! xcoff_reloc_link_order (abfd, &flinfo, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }

  /* Free up the buffers used by xcoff_link_input_bfd.  */
  if (flinfo.internal_syms != NULL)
    {
      free (flinfo.internal_syms);
      flinfo.internal_syms = NULL;
    }
  if (flinfo.sym_indices != NULL)
    {
      free (flinfo.sym_indices);
      flinfo.sym_indices = NULL;
    }
  if (flinfo.linenos != NULL)
    {
      free (flinfo.linenos);
      flinfo.linenos = NULL;
    }
  if (flinfo.contents != NULL)
    {
      free (flinfo.contents);
      flinfo.contents = NULL;
    }
  if (flinfo.external_relocs != NULL)
    {
      free (flinfo.external_relocs);
      flinfo.external_relocs = NULL;
    }

  /* The value of the last C_FILE symbol is supposed to be -1.  Write
     it out again.  */
  if (flinfo.last_file_index != -1)
    {
      flinfo.last_file.n_value = -(bfd_vma) 1;
      bfd_coff_swap_sym_out (abfd, (void *) &flinfo.last_file,
			     (void *) flinfo.outsyms);
      pos = obj_sym_filepos (abfd) + flinfo.last_file_index * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (flinfo.outsyms, symesz, abfd) != symesz)
	goto error_return;
    }

  /* Write out all the global symbols which do not come from XCOFF
     input files.  */
  bfd_hash_traverse (&info->hash->table, xcoff_write_global_symbol, &flinfo);

  if (flinfo.outsyms != NULL)
    {
      free (flinfo.outsyms);
      flinfo.outsyms = NULL;
    }

  /* Now that we have written out all the global symbols, we know the
     symbol indices to use for relocs against them, and we can finally
     write out the relocs.  */
  amt = max_output_reloc_count * relsz;
  external_relocs = bfd_malloc (amt);
  if (external_relocs == NULL && max_output_reloc_count != 0)
    goto error_return;

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct internal_reloc *irel;
      struct internal_reloc *irelend;
      struct xcoff_link_hash_entry **rel_hash;
      struct xcoff_toc_rel_hash *toc_rel_hash;
      bfd_byte *erel;
      bfd_size_type rel_size;

      /* A stripped file has no relocs.  */
      if (info->strip == strip_all)
	{
	  o->reloc_count = 0;
	  continue;
	}

      if (o->reloc_count == 0)
	continue;

      irel = flinfo.section_info[o->target_index].relocs;
      irelend = irel + o->reloc_count;
      rel_hash = flinfo.section_info[o->target_index].rel_hashes;
      for (; irel < irelend; irel++, rel_hash++)
	{
	  if (*rel_hash != NULL)
	    {
	      if ((*rel_hash)->indx < 0)
		{
		  if (! ((*info->callbacks->unattached_reloc)
			 (info, (*rel_hash)->root.root.string,
			  NULL, o, irel->r_vaddr)))
		    goto error_return;
		  (*rel_hash)->indx = 0;
		}
	      irel->r_symndx = (*rel_hash)->indx;
	    }
	}

      for (toc_rel_hash = flinfo.section_info[o->target_index].toc_rel_hashes;
	   toc_rel_hash != NULL;
	   toc_rel_hash = toc_rel_hash->next)
	{
	  if (toc_rel_hash->h->u.toc_indx < 0)
	    {
	      if (! ((*info->callbacks->unattached_reloc)
		     (info, toc_rel_hash->h->root.root.string,
		      NULL, o, toc_rel_hash->rel->r_vaddr)))
		goto error_return;
	      toc_rel_hash->h->u.toc_indx = 0;
	    }
	  toc_rel_hash->rel->r_symndx = toc_rel_hash->h->u.toc_indx;
	}

      /* XCOFF requires that the relocs be sorted by address.  We tend
	 to produce them in the order in which their containing csects
	 appear in the symbol table, which is not necessarily by
	 address.  So we sort them here.  There may be a better way to
	 do this.  */
      qsort ((void *) flinfo.section_info[o->target_index].relocs,
	     o->reloc_count, sizeof (struct internal_reloc),
	     xcoff_sort_relocs);

      irel = flinfo.section_info[o->target_index].relocs;
      irelend = irel + o->reloc_count;
      erel = external_relocs;
      for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	bfd_coff_swap_reloc_out (abfd, (void *) irel, (void *) erel);

      rel_size = relsz * o->reloc_count;
      if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0
	  || bfd_bwrite ((void *) external_relocs, rel_size, abfd) != rel_size)
	goto error_return;
    }

  if (external_relocs != NULL)
    {
      free (external_relocs);
      external_relocs = NULL;
    }

  /* Free up the section information.  */
  if (flinfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (flinfo.section_info[i].relocs != NULL)
	    free (flinfo.section_info[i].relocs);
	  if (flinfo.section_info[i].rel_hashes != NULL)
	    free (flinfo.section_info[i].rel_hashes);
	}
      free (flinfo.section_info);
      flinfo.section_info = NULL;
    }

  /* Write out the loader section contents.  */
  o = xcoff_hash_table (info)->loader_section;
  if (o)
    {
      BFD_ASSERT ((bfd_byte *) flinfo.ldrel
		  == (xcoff_hash_table (info)->loader_section->contents
		      + xcoff_hash_table (info)->ldhdr.l_impoff));
      if (!bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset, o->size))
	goto error_return;
    }

  /* Write out the magic sections.  */
  o = xcoff_hash_table (info)->linkage_section;
  if (o->size > 0
      && ! bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset,
				     o->size))
    goto error_return;
  o = xcoff_hash_table (info)->toc_section;
  if (o->size > 0
      && ! bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset,
				     o->size))
    goto error_return;
  o = xcoff_hash_table (info)->descriptor_section;
  if (o->size > 0
      && ! bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset,
				     o->size))
    goto error_return;

  /* Write out the string table.  */
  pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0)
    goto error_return;
  H_PUT_32 (abfd,
	    _bfd_stringtab_size (flinfo.strtab) + STRING_SIZE_SIZE,
	    strbuf);
  amt = STRING_SIZE_SIZE;
  if (bfd_bwrite (strbuf, amt, abfd) != amt)
    goto error_return;
  if (! _bfd_stringtab_emit (abfd, flinfo.strtab))
    goto error_return;

  _bfd_stringtab_free (flinfo.strtab);

  /* Write out the debugging string table.  */
  o = xcoff_hash_table (info)->debug_section;
  if (o != NULL)
    {
      struct bfd_strtab_hash *debug_strtab;

      debug_strtab = xcoff_hash_table (info)->debug_strtab;
      BFD_ASSERT (o->output_section->size - o->output_offset
		  >= _bfd_stringtab_size (debug_strtab));
      pos = o->output_section->filepos + o->output_offset;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
	goto error_return;
      if (! _bfd_stringtab_emit (abfd, debug_strtab))
	goto error_return;
    }

  /* Setting bfd_get_symcount to 0 will cause write_object_contents to
     not try to write out the symbols.  */
  bfd_get_symcount (abfd) = 0;

  return TRUE;

 error_return:
  if (flinfo.strtab != NULL)
    _bfd_stringtab_free (flinfo.strtab);

  if (flinfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (flinfo.section_info[i].relocs != NULL)
	    free (flinfo.section_info[i].relocs);
	  if (flinfo.section_info[i].rel_hashes != NULL)
	    free (flinfo.section_info[i].rel_hashes);
	}
      free (flinfo.section_info);
    }

  if (flinfo.internal_syms != NULL)
    free (flinfo.internal_syms);
  if (flinfo.sym_indices != NULL)
    free (flinfo.sym_indices);
  if (flinfo.outsyms != NULL)
    free (flinfo.outsyms);
  if (flinfo.linenos != NULL)
    free (flinfo.linenos);
  if (flinfo.contents != NULL)
    free (flinfo.contents);
  if (flinfo.external_relocs != NULL)
    free (flinfo.external_relocs);
  if (external_relocs != NULL)
    free (external_relocs);
  return FALSE;
}
@


1.83
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
d6264 1
a6264 1
      for (; irel < irelend; irel++, rel_hash++, erel += relsz)
@


1.83.4.1
log
@bfd/
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Don't touch EREL in
	loop that doesn't use (or initialize) it.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2013 Free Software Foundation, Inc.
d6264 1
a6264 1
      for (; irel < irelend; irel++, rel_hash++)
@


1.82
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d583 1
a583 1
  ret = bfd_malloc (amt);
a593 11
  ret->debug_section = NULL;
  ret->loader_section = NULL;
  ret->ldrel_count = 0;
  memset (&ret->ldhdr, 0, sizeof (struct internal_ldhdr));
  ret->linkage_section = NULL;
  ret->toc_section = NULL;
  ret->descriptor_section = NULL;
  ret->imports = NULL;
  ret->file_align = 0;
  ret->textro = FALSE;
  ret->gc = FALSE;
a595 1
  memset (ret->special_sections, 0, sizeof ret->special_sections);
@


1.81
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d151 1
a151 1
  } 
@


1.80
log
@2011-05-18  Tristan Gingold  <gingold@@adacore.com>

	* xcofflink.c (xcoff_link_add_symbols): Handle C_DWARF symbols.
	(xcoff_sweep): Always keep dwarf sections.
	(xcoff_link_input_bfd): Handle dwarf symbols and sections.
@
text
@a3356 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct xcoff_link_hash_entry *) h->root.u.i.link;

d5152 1
a5152 1
xcoff_write_global_symbol (struct xcoff_link_hash_entry *h, void * inf)
d5154 1
d6238 1
a6238 3
  xcoff_link_hash_traverse (xcoff_hash_table (info),
			    xcoff_write_global_symbol,
			    (void *) &flinfo);
@


1.79
log
@	PR ld/12365
include/
	* bfdlink.h (struct bfd_link_callbacks): Modify multiple_definition
	and multiple_common parameters to pass in a bfd_link_hash_entry
	pointer rather than name,bfd etc. found in the hash entry.
bfd/
	* elflink.c (_bfd_elf_merge_symbol): Update multiple_common calls.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.  Call
	multiple_definition regardless of allow_multiple_definition.
	* simple.c (simple_dummy_multiple_definition): Update.
	* xcofflink.c (xcoff_link_add_symbols): Update multiple_definition
	calls.
ld/
	* ldmain.c (multiple_definition): Take a bfd_link_hash_entry
	pointer arg rather than "name", "obfd", "osec", "oval".  Add code
	removed from linker.c.  Hack around xcofflink.c oddity in
	passing NULL nbfd.
	(multiple_common): Similarly.
	* plugin.c (orig_allow_multiple_defs): Delete.
	(plugin_call_all_symbols_read): Don't twiddle allow_multiple_definition.
	(plugin_multiple_definition): Update.
@
text
@d1368 1
a1368 1
	  if (sym.n_sclass == C_FILE)
d1372 2
a1373 1
	  else if (first_csect == NULL || sym.n_sclass == C_FILE)
d2077 4
d3017 1
d4939 13
a4951 10
			  name = (_bfd_coff_internal_syment_name
				  (input_bfd, is, buf));

			  if (name == NULL)
			    return FALSE;

			  if (! ((*flinfo->info->callbacks->unattached_reloc)
				 (flinfo->info, name, input_bfd, o,
				  irel->r_vaddr)))
			    return FALSE;
d4956 2
a4957 1
	      if (xcoff_need_ldrel_p (flinfo->info, irel, h))
@


1.78
log
@ChangeLog libiberty/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filename_cmp.c (filename_ncmp): New function.
	* functions.texi: Regenerated.

ChangeLog include/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* filenames.h (filename_ncmp): New prototype.

ChangeLog bfd/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* archive.c (_bfd_find_nested_archive): Use filename_(n)cmp.
	(adjust_relative_path): Likewise.
	(_bfd_construct_extended_name_table): Likewise.
	* corefile.c (generic_core_file_matches_executable_p): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-spu.c (sort_bfds): Likewise.
	(spu_elf_auto_overlay): Likewise.
	* syms.c (_bfd_stab_section_find_nearest_line): Likewise.
	* xcofflink.c (xcoff_set_import_path): Likewise.
	* xtensa-isa.c (xtensa_regfile_lookup): Likewise.
	(xtensa_regfile_lookup_shortname): Likewise.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d1999 1
a1999 5
			 (info, (*sym_hash)->root.root.string,
			  NULL, NULL, (bfd_vma) 0,
			  (*sym_hash)->root.u.def.section->owner,
			  (*sym_hash)->root.u.def.section,
			  (*sym_hash)->root.u.def.value)))
d3118 1
a3118 3
		 (info, h->root.root.string, h->root.u.def.section->owner,
		  h->root.u.def.section, h->root.u.def.value,
		  output_bfd, bfd_abs_section_ptr, val)))
@


1.77
log
@	* aoutx.h (aout_link_check_ar_symbols): Formatting.
	* cofflink.c (coff_link_check_ar_symbols): Likewise.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols,
	xcoff_link_check_dynamic_ar_symbols): Likewise.

	* aoutx.h (aout_link_check_archive_element): Simplify code dealing
	with add_archive_element substitute BFD.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* ecoff.c (ecoff_link_check_archive_element): Likewise.
	(ecoff_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.

	* aoutx.h (aout_link_check_archive_element): Free symbols from old
	bfd if !keep_memory.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.
@
text
@d761 3
a763 3
	  if (strcmp ((*pp)->path, imppath) == 0
	      && strcmp ((*pp)->file, impfile) == 0
	      && strcmp ((*pp)->member, impmember) == 0)
@


1.76
log
@Applied patch series for LD plugin interface (six parts).

[PATCH] Add infrastructure for plugin API; functionality to follow.

    include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* plugin-api.h (LDPT_GNU_LD_VERSION): New ld_plugin_tag enum member.

    ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* configure.in: Add AC_CHECKs for file io and dlfcn headers and
	functions and AC_SEARCH for -ldl.
	(enable_plugins): New shell variable set if above tests find dlopen
	functionality.
	(ENABLE_PLUGINS): Add related automake conditional.
	* configure: Regenerate.
	* config.in: Likewise.
	* Makefile.am (PLUGIN_C): Declare plugin C source file, conditional
	on ENABLE_PLUGINS being defined.
	(PLUGIN_H): Likewise for header file.
	(PLUGIN_OBJECT): Likewise for object file.
	(PLUGIN_CFLAGS): Likewise -D flag required to compile plugin support.
	(AM_CPPFLAGS): Use PLUGIN_CFLAGS.
	(CFILES): Use PLUGIN_C.
	(HFILES): Use PLUGIN_H.
	(OFILES): Use PLUGIN_OBJECT.
	(ld_new_SOURCES): Use PLUGIN_C.
	(noinst_LTLIBRARIES)[ENABLE_PLUGINS]: Declare test plugin.
	(libldtestplug_la_SOURCES)[ENABLE_PLUGINS]: Add automake definition
	for test plugin.
	(libldtestplug_la_CFLAGS)[ENABLE_PLUGINS]: Likewise.
	(libldtestplug_la_LDFLAGS)[ENABLE_PLUGINS]: Likewise.
	* Makefile.in: Regenerate.
	* sysdep.h: Include stdarg.h, unistd.h and one of fcntl.h or
	sys/file.h where available.  Include dlfcn.h when ENABLE_PLUGINS.
	(O_RDONLY): Supply default definition likewise to bfd's sysdep.h
	(O_WRONLY): Likewise.
	(O_RDWR): Likewise.
	(O_ACCMODE): Likewise.
	(O_BINARY): Likewise.
	(SEEK_SET): Likewise.
	(SEEK_CUR): Likewise.
	(SEEK_END): Likewise.
	* ldmisc.c (vfinfo): Make non-static.  Add %p format char.
	* ldmisc.h (vfinfo): Declare extern prototype.
	* lexsup.c (enum option_values)[ENABLE_PLUGINS]: Add new entries for
	OPTION_PLUGIN and OPTION_PLUGIN_OPT.
	(ld_options[])[ENABLE_PLUGINS]: Add option data for the above two.
	(parse_args)[ENABLE_PLUGINS]: Handle them, and load all plugins once
	option parsing is complete.
	* ldmain.c (main)[ENABLE_PLUGINS]: Call plugin cleanup hooks just
	after lang_finish.
	* plugin.c: New source file.
	* plugin.h: Likewise new header.
	* testplug.c: New source file.

    ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* ld-bootstrap/bootstrap.exp: Skip static tests also if LD plugins
	are enabled.
	* lib/ld-lib.exp (proc regexp_diff): Extend verbose debug output.
	(proc set_file_contents): Write a file with the supplied content.
	(run_ld_link_tests): Add new 'ld' action to test linker output.
	(proc check_plugin_api_available): Return true if linker under test
	supports the plugin API.
	* ld-plugin/func.c: New test source file.
	* ld-plugin/main.c: Likewise.
	* ld-plugin/text.c: Likewise.
	* ld-plugin/plugin-1.d: New dump test output pattern script.
	* ld-plugin/plugin-2.d: Likewise.
	* ld-plugin/plugin-3.d: Likewise.
	* ld-plugin/plugin-4.d: Likewise.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin.exp: New test control script.
---
[PATCH] Implement claim file and all symbols read hooks and add symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ldfile.c (ldfile_try_open_bfd)[ENABLE_PLUGINS]: Don't return early
	during compat checks if they pass, instead offer any successfully
	opened and accepted file to the plugin claim file hooks chain.  Create
	a dummy bfd to accept symbols added by the plugin, if the plugin
	claims the file.
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Call plugin all symbols
	read hook chain before ldemul_after_open.
	* ldlang.h (struct lang_input_statement_struct): Add new single-bit
	'claimed' flag.
	* plugin.c (IRONLY_SUFFIX): New macro for dummy bfd file suffix.
	(IRONLY_SUFFIX_LEN): Length of the above string.
	(plugin_get_ir_dummy_bfd): New function to create the dummy bfd used
	to store symbols for ir-only files.
	(is_ir_dummy_bfd): New function to check if a bfd is ir-only.
	(asymbol_from_plugin_symbol): New function converts symbol formats.
	(add_symbols): Call it to convert plugin syms to bfd syms and add
	them to the dummy bfd.
	* plugin.h: Add missing include guards.
	(plugin_get_ir_dummy_bfd): Add prototype.
	(is_ir_dummy_bfd): Likewise.
	* testplug.c (TV_MESSAGE): New helper macro.
	(struct claim_file): New struct.
	(claim_file_t): New typedef.
	(tag_names[]): Make static and const.
	(claimfiles_list): New variable.
	(claimfiles_tail_chain_ptr): Likewise.
	(last_claimfile): Likewise.
	(record_claim_file): Record a file to claim on a singly-linked list.
	(parse_symdefstr): Parse an ASCII representation of a symbol from a
	plugin option into the fields of a struct ld_plugin_symbol.
	(record_claimed_file_symbol):  Use it to parse plugin option for
	adding a symbol.
	(parse_option): Parse claim file and add symbol options.
	(dump_tv_tag): Use TV_MESSAGE.
	(onload): Likewise.
	(onclaim_file): Make static.  Use TV_MESSAGE.  Scan list of files to
	claim and claim this file if required, adding any symbols specified.
	(onall_symbols_read): Make static and use TV_MESSAGE.
	(oncleanup): Likewise.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ld-plugin/plugin-3.d: Enable regexes for new functionality.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin-6.d: New testcase.
	* ld-plugin/plugin-7.d: Likewise.
	* ld-plugin/plugin.exp: Use 'nm' on compiled test objects to determine
	whether symbols in plugin arguments need an underscore prefix.  Add
	new plugin-6.d and plugin-7.d testcases.
---
[PATCH] Implement get symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ldmain.c (notice)[ENABLE_PLUGINS]: Call plugin_notice.
	* plugin.c (non_ironly_hash): Add new bfd hash table.
	(plugin_load_plugins): Exit early if no plugins to load.  If plugins
	do load successfully, set notice_all flag in link info.
	(get_symbols): Implement.
	(plugin_load_plugins): Exit early if no plugins to load, else after
	loading plugins successfully enable notice_all mode.
	(init_non_ironly_hash): Lazily init non_ironly_hash table.
	(plugin_notice): Record symbols referenced from non-IR files in the
	non_ironly_hash.  Suppress tracing, cref generation and nocrossrefs
	tracking for symbols from dummy IR bfds.
	* plugin.h: Fix formatting.
	(plugin_notice): Add prototype.
	* testplug.c (dumpresolutions): New global var.
	(parse_options): Accept "dumpresolutions".
	(onall_symbols_read): Get syms and dump resolutions if it was given.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ld-plugin/plugin-8.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Implement add input file, add input lib and set extra lib path callbacks.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Move invocation of
	plugin_call_all_symbols_read to before setting of gc_sym_list, and
	open any new input files that may have been added during it.
	* ldmain.c (multiple_definition)[ENABLE_PLUGINS]: Call out to
	plugin_multiple_definition and let it have first say over what to do
	with the clashing definitions.
	* plugin.c (no_more_claiming): New boolean variable.
	(plugin_cached_allow_multiple_defs): Likewise.
	(add_input_file): Implement.
	(add_input_library): Likewise.
	(set_extra_library_path): Likewise.
	(plugin_call_claim_file): Don't do anything when no_more_claiming set.
	(plugin_call_all_symbols_read): Set it.  Disable link info
	"allow_multiple_definition" flag, but cache its value.
	(plugin_multiple_definition): New function.
	* plugin.h (plugin_multiple_definition): Add prototype.
	* testplug.c (addfile_enum_t): New enumerated typedef.
	(add_file_t): New struct typedef.
	(addfiles_list): New variable.
	(addfiles_tail_chain_ptr): Likewise.
	(record_add_file): New function.
	(parse_option): Parse "add:", "lib:" and "dir:" options and call it.
	(onall_symbols_read): Iterate the list of new files, libs and dirs,
	adding them.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ld-plugin/plugin-9.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Add ELF symbol visibility support to plugin interface.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* plugin.c (asymbol_from_plugin_symbol): If the bfd is an ELF bfd,
	find the elf symbol data and set the visibility in the st_other field.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* ld-plugin/plugin-ignore.d: New dump test control script.
	* ld-plugin/plugin-vis-1.d: Likewise.
	* ld-plugin/plugin.exp: Add list of ELF-only tests and run them if
	testing on an ELF target.
---
[PATCH] Add archive support to plugin interface.

  bfd/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* aoutx.h (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* cofflink.c (coff_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(coff_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* ecoff.c (read_ext_syms_and_strs): New function holds symbol-reading
	code factored-out from ecoff_link_check_archive_element.
	(reread_ext_syms_and_strs): Clear old symbols and call it.
	(ecoff_link_check_archive_element):  Use the above.  Handle substitute
	BFD if one is set by add_archive_element callback.
	(ecoff_link_add_archive_symbols): Likewise allow bfd substitution.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it was
	set during add_archive_element callback in the above.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Handle substitute
	BFD if one is set by add_archive_element callback.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols): Take new "subsbfd"
	reference parameter and pass it when invoking add_archive_element
	callback.
	(xcoff_link_check_ar_symbols): Likewise.
	(xcoff_link_check_archive_element): Handle bfd substitution if it was
	set by callback in the above.

  include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* bfdlink.h (struct_bfd_link_callbacks): Document new argument
	to add_archive_element callback used to return a replacement bfd which
	is to be added to the hash table in place of the original element.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ldlang.c (load_symbols): Handle bfd subsitution when calling the
	add_archive_element callback.
	* ldmain.c (add_archive_element)[ENABLE_PLUGINS]: Offer the archive
	member to the plugins and if claimed set "subsbfd" output parameter to
	point to the dummy IR-only BFD.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ld-plugin/plugin-10.d: New dump test control script.
	* ld-plugin/plugin-11.d: Likewise.
	* ld-plugin/plugin.exp: Run them.
---
@
text
@d2295 2
a2296 2
	  if (! (*info->callbacks->add_archive_element)
					(info, abfd, name, subsbfd))
d2367 2
a2368 2
	      if (! (*info->callbacks->add_archive_element)
					(info, abfd, name, subsbfd))
d2393 1
a2393 1
  bfd *subsbfd = NULL;
d2396 1
a2396 1
  if (! _bfd_coff_get_external_symbols (abfd))
d2399 2
a2400 1
  if (! xcoff_link_check_ar_symbols (abfd, info, pneeded, &subsbfd))
d2407 10
a2416 3
      if (subsbfd && !_bfd_coff_get_external_symbols (subsbfd))
	return FALSE;
      if (! xcoff_link_add_symbols (subsbfd ? subsbfd : abfd, info))
d2424 1
a2424 1
      if (! _bfd_coff_free_symbols (abfd))
@


1.76.2.1
log
@backport from mainline
@
text
@d2295 2
a2296 2
	  if (!(*info->callbacks
		->add_archive_element) (info, abfd, name, subsbfd))
d2367 2
a2368 2
	      if (!(*info->callbacks
		    ->add_archive_element) (info, abfd, name, subsbfd))
d2393 1
a2393 1
  bfd *oldbfd;
d2396 1
a2396 1
  if (!_bfd_coff_get_external_symbols (abfd))
d2399 1
a2399 2
  oldbfd = abfd;
  if (!xcoff_link_check_ar_symbols (abfd, info, pneeded, &abfd))
d2406 3
a2408 10
      if (abfd != oldbfd)
	{
	  if (!keep_syms_p
	      && !_bfd_coff_free_symbols (oldbfd))
	    return FALSE;
	  keep_syms_p = (obj_coff_external_syms (abfd) != NULL);
	  if (!_bfd_coff_get_external_symbols (abfd))
	    return FALSE;
	}
      if (!xcoff_link_add_symbols (abfd, info))
d2416 1
a2416 1
      if (!_bfd_coff_free_symbols (abfd))
@


1.76.2.2
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@d1999 5
a2003 1
			 (info, &(*sym_hash)->root, NULL, NULL, (bfd_vma) 0)))
d3122 3
a3124 1
		 (info, &h->root, output_bfd, bfd_abs_section_ptr, val)))
@


1.75
log
@2010-05-25  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c: Declare and define _bfd_memory_iovec.
	(bfd_bread): Move code for BFD_IN_MEMORY...
	(bfd_bwrite): ... Ditto ...
	(bfd_tell): ... Ditto ...
	(bfd_flush): ... Ditto ...
	(bfd_stat): ... Ditto ...
	(bfd_seek): ... Ditto ...
	(bfd_get_size): ... Ditto ...
	(bfd_mmap): ... Ditto ...
	(memory_bread): ... to these new functions.
	(memory_bwrite): Ditto.
	(memory_btell): Ditto.
	(memory_bseek): Ditto.
	(memory_bflush): Ditto.
	(memory_bstat): Ditto.
	(memory_bmmap): Ditto.
	(memory_bclose): New function.
	* peicode.h (pe_ILF_build_a_bfd): Use BFD_IN_MEMORY.
	* xcofflink.c (bfd_xcoff_link_generate_rtinit): Ditto.
	* opncls.c (bfd_close): Do not handle BFD_IN_MEMORY case.
	(bfd_make_writable): Use _bfd_memory_iovec.
	* elfcode.h (bfd_from_remote_memory): Use _bfd_memory_iovec.
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Use
	_bfd_memory_iovec.
	(alpha_ecoff_openr_next_archived_file): Use proxy_origin
	instead of origin.
	* libbfd.h: Regenerate.
@
text
@d2236 2
a2237 1
				     bfd_boolean *pneeded)
d2295 2
a2296 1
	  if (! (*info->callbacks->add_archive_element) (info, abfd, name))
d2319 2
a2320 1
			     bfd_boolean *pneeded)
d2331 1
a2331 1
    return xcoff_link_check_dynamic_ar_symbols (abfd, info, pneeded);
d2367 2
a2368 1
	      if (! (*info->callbacks->add_archive_element) (info, abfd, name))
d2393 1
d2399 1
a2399 1
  if (! xcoff_link_check_ar_symbols (abfd, info, pneeded))
d2404 5
a2408 1
      if (! xcoff_link_add_symbols (abfd, info))
@


1.74
log
@bfd/
	* xcofflink.c (_bfd_xcoff_bfd_final_link): When calculating
	max_contents_size, only consider sections whose contents must
	be swapped in.
@
text
@d3979 1
d3981 1
@


1.73
log
@Move 2009 binutils ChangeLog to ChangeLog-2009.
@
text
@d5875 7
a5881 4
	      if (sec->rawsize > max_contents_size)
		max_contents_size = sec->rawsize;
	      if (sec->size > max_contents_size)
		max_contents_size = sec->size;
@


1.72
log
@Fix -Wshadow warnings (seen on ppc-aix)

        * xcofflink.c: Replace finfo by flinfo throughout.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.71
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d4019 1
a4019 1
xcoff_create_ldrel (bfd *output_bfd, struct xcoff_final_link_info *finfo,
d4064 1
a4064 1
  if (xcoff_hash_table (finfo->info)->textro
d4073 2
a4074 2
  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
  finfo->ldrel += bfd_xcoff_ldrelsz (output_bfd);
d4082 1
a4082 1
xcoff_link_input_bfd (struct xcoff_final_link_info *finfo,
d4111 1
a4111 1
      && ! finfo->info->static_link)
d4115 1
a4115 1
  output_bfd = finfo->output_bfd;
d4131 1
a4131 1
  if (! finfo->info->keep_memory)
d4148 2
a4149 2
  isymp = finfo->internal_syms;
  indexp = finfo->sym_indices;
d4239 1
a4239 1
		      BFD_ASSERT (impbfd->xvec == finfo->output_bfd->xvec);
d4248 2
a4249 2
	  bfd_xcoff_swap_ldsym_out (finfo->output_bfd, ldsym,
				    (finfo->ldsym
d4251 1
a4251 1
					* bfd_xcoff_ldsymsz (finfo->output_bfd))));
d4310 2
a4311 2
  isymp = finfo->internal_syms;
  indexp = finfo->sym_indices;
d4315 1
a4315 1
  outsym = finfo->outsyms;
d4350 1
a4350 1
		  indx = _bfd_stringtab_add (finfo->strtab, name, hash, copy);
d4374 2
a4375 2
	      if (finfo->last_file_index != -1
		  && finfo->last_file.n_value != (bfd_vma) *indexp)
d4378 2
a4379 2
		  finfo->last_file.n_value = *indexp;
		  if ((bfd_size_type) finfo->last_file_index >= syment_base)
d4383 3
a4385 3
					     (void *) &finfo->last_file,
					     (void *) (finfo->outsyms
						    + ((finfo->last_file_index
d4397 1
a4397 1
					     (void *) &finfo->last_file,
d4401 1
a4401 1
		      pos += finfo->last_file_index * osymesz;
d4409 2
a4410 2
	      finfo->last_file_index = *indexp;
	      finfo->last_file = isym;
d4419 1
a4419 1
	      isym.n_value = finfo->line_filepos;
d4433 1
a4433 1
		  symindx = finfo->sym_indices[indx];
d4484 1
a4484 1
		      indx = _bfd_stringtab_add (finfo->strtab, filename,
d4512 1
a4512 1
			  symindx = finfo->sym_indices[indx];
d4541 1
a4541 1
			  while (finfo->sym_indices[indx] < 0
d4547 1
a4547 1
			    indx = finfo->sym_indices[indx];
d4558 1
a4558 1
		      symindx = finfo->sym_indices[indx];
d4600 1
a4600 1
			      || (bfd_bread (finfo->linenos, amt, input_bfd)
d4610 1
a4610 1
		      linp = finfo->linenos + linoff;
d4632 1
a4632 1
			  || bfd_bwrite (finfo->linenos + linoff,
d4652 1
a4652 1
			  iisp = finfo->internal_syms;
d4654 2
a4655 2
			  iindp = finfo->sym_indices;
			  oos = finfo->outsyms;
d4707 2
a4708 2
  if (finfo->last_file_index != -1
      && (bfd_size_type) finfo->last_file_index >= syment_base)
d4710 4
a4713 4
      finfo->last_file.n_value = output_index;
      bfd_coff_swap_sym_out (output_bfd, (void *) &finfo->last_file,
			     (void *) (finfo->outsyms
 				    + ((finfo->last_file_index - syment_base)
d4718 1
a4718 1
  if (outsym > finfo->outsyms)
d4721 1
a4721 1
      bfd_size_type amt = outsym - finfo->outsyms;
d4723 1
a4723 1
	  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
d4727 1
a4727 1
		   + (outsym - finfo->outsyms) / osymesz)
d4759 1
a4759 1
	  if (!bfd_get_section_contents (input_bfd, o, finfo->contents, 0, sz))
d4761 1
a4761 1
	  contents = finfo->contents;
d4777 1
a4777 1
			     (input_bfd, o, FALSE, finfo->external_relocs,
d4779 1
a4779 1
			      (finfo->section_info[target_index].relocs
d4786 1
a4786 1
	  if (! bfd_coff_relocate_section (output_bfd, finfo->info,
d4790 1
a4790 1
					   finfo->internal_syms,
d4797 1
a4797 1
	  rel_hash = (finfo->section_info[target_index].rel_hashes
d4816 1
a4816 1
	      if (r_symndx != -1 && finfo->info->strip != strip_all)
d4842 1
a4842 1
			  n = bfd_alloc (finfo->output_bfd, amt);
d4845 1
a4845 1
			  si = finfo->section_info + target_index;
d4873 1
a4873 1
		      indx = finfo->sym_indices[r_symndx];
d4882 1
a4882 1
			  is = finfo->internal_syms + r_symndx;
d4901 1
a4901 1
				indx = finfo->toc_symindx;
d4918 1
a4918 1
			  is = finfo->internal_syms + r_symndx;
d4926 2
a4927 2
			  if (! ((*finfo->info->callbacks->unattached_reloc)
				 (finfo->info, name, input_bfd, o,
d4934 1
a4934 1
	      if (xcoff_need_ldrel_p (finfo->info, irel, h))
d4944 1
a4944 1
		  if (!xcoff_create_ldrel (output_bfd, finfo,
d4963 1
a4963 1
  if (! finfo->info->keep_memory)
d5019 1
a5019 1
xcoff_find_tc0 (bfd *output_bfd, struct xcoff_final_link_info *finfo)
d5035 1
a5035 1
  for (input_bfd = finfo->info->input_bfds;
d5067 1
a5067 1
      for (input_bfd = finfo->info->input_bfds;
d5095 1
a5095 1
  finfo->toc_symindx = obj_raw_syment_count (output_bfd);
d5100 1
a5100 1
  if (!bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab, &irsym, "TOC"))
d5107 1
a5107 1
  bfd_coff_swap_sym_out (output_bfd, &irsym, finfo->outsyms);
d5115 1
a5115 1
			 finfo->outsyms + bfd_coff_symesz (output_bfd));
d5122 1
a5122 1
      || bfd_bwrite (finfo->outsyms, size, output_bfd) != size)
d5134 1
a5134 1
  struct xcoff_final_link_info *finfo = (struct xcoff_final_link_info *) inf;
d5143 2
a5144 2
  output_bfd = finfo->output_bfd;
  outsym = finfo->outsyms;
d5154 1
a5154 1
  if (xcoff_hash_table (finfo->info)->gc
d5255 1
a5255 1
				(finfo->ldsym +
d5257 1
a5257 1
				 * bfd_xcoff_ldsymsz(finfo->output_bfd)));
d5264 1
a5264 1
	  == xcoff_hash_table (finfo->info)->linkage_section))
d5310 1
a5310 1
      irel = finfo->section_info[oindx].relocs + osec->reloc_count;
d5353 1
a5353 1
      finfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
d5356 1
a5356 1
      if (!xcoff_create_ldrel (output_bfd, finfo, osec,
d5362 1
a5362 1
      if (finfo->info->strip != strip_all)
d5364 1
a5364 1
	  result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab,
d5390 1
a5390 1
	      amt = outsym - finfo->outsyms;
d5392 1
a5392 1
		  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
d5395 1
a5395 1
		(outsym - finfo->outsyms) / bfd_coff_symesz (output_bfd);
d5397 1
a5397 1
	      outsym = finfo->outsyms;
d5415 1
a5415 1
	  == xcoff_hash_table (finfo->info)->descriptor_section))
d5451 1
a5451 1
      irel = finfo->section_info[oindx].relocs + osec->reloc_count;
d5458 1
a5458 1
      finfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
d5461 1
a5461 1
      if (!xcoff_create_ldrel (output_bfd, finfo, osec,
d5503 1
a5503 1
      finfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
d5506 1
a5506 1
      if (!xcoff_create_ldrel (output_bfd, finfo, osec,
d5511 1
a5511 1
  if (h->indx >= 0 || finfo->info->strip == strip_all)
d5513 1
a5513 1
      BFD_ASSERT (outsym == finfo->outsyms);
d5518 3
a5520 3
      && (finfo->info->strip == strip_all
	  || (finfo->info->strip == strip_some
	      && bfd_hash_lookup (finfo->info->keep_hash, h->root.root.string,
d5523 1
a5523 1
      BFD_ASSERT (outsym == finfo->outsyms);
d5530 1
a5530 1
      BFD_ASSERT (outsym == finfo->outsyms);
d5538 1
a5538 1
  result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab, &isym,
d5586 1
a5586 1
	  for (l = xcoff_hash_table (finfo->info)->size_list;
d5645 1
a5645 1
  amt = outsym - finfo->outsyms;
d5647 1
a5647 1
      || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
d5650 1
a5650 1
    (outsym - finfo->outsyms) / bfd_coff_symesz (output_bfd);
d5659 1
a5659 1
			struct xcoff_final_link_info *finfo,
d5686 1
a5686 1
       bfd_wrapped_link_hash_lookup (output_bfd, finfo->info,
d5691 2
a5692 2
      if (! ((*finfo->info->callbacks->unattached_reloc)
	     (finfo->info, link_order->u.reloc.p->u.name, NULL, NULL, (bfd_vma) 0)))
d5731 2
a5732 2
	  if (! ((*finfo->info->callbacks->reloc_overflow)
		 (finfo->info, NULL, link_order->u.reloc.p->u.name,
d5749 1
a5749 1
  irel = (finfo->section_info[output_section->target_index].relocs
d5751 1
a5751 1
  rel_hash_ptr = (finfo->section_info[output_section->target_index].rel_hashes
d5777 1
a5777 1
  if (xcoff_hash_table (finfo->info)->loader_section)
d5779 1
a5779 1
      if (!xcoff_create_ldrel (output_bfd, finfo, output_section,
d5793 1
a5793 1
  struct xcoff_final_link_info finfo;
d5816 12
a5827 12
  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.strtab = NULL;
  finfo.section_info = NULL;
  finfo.last_file_index = -1;
  finfo.toc_symindx = -1;
  finfo.internal_syms = NULL;
  finfo.sym_indices = NULL;
  finfo.outsyms = NULL;
  finfo.linenos = NULL;
  finfo.contents = NULL;
  finfo.external_relocs = NULL;
d5831 1
a5831 1
      finfo.ldsym = (xcoff_hash_table (info)->loader_section->contents
d5833 1
a5833 1
      finfo.ldrel = (xcoff_hash_table (info)->loader_section->contents
d5840 2
a5841 2
      finfo.ldsym = NULL;
      finfo.ldrel = NULL;
d5846 2
a5847 2
  finfo.strtab = _bfd_stringtab_init ();
  if (finfo.strtab == NULL)
d6004 2
a6005 2
    finfo.section_info = bfd_malloc (amt);
    if (finfo.section_info == NULL)
d6009 3
a6011 3
	finfo.section_info[i].relocs = NULL;
	finfo.section_info[i].rel_hashes = NULL;
	finfo.section_info[i].toc_rel_hashes = NULL;
d6052 1
a6052 1
	  finfo.section_info[o->target_index].relocs = bfd_malloc (amt);
d6056 1
a6056 1
	  finfo.section_info[o->target_index].rel_hashes = bfd_malloc (amt);
d6058 2
a6059 2
	  if (finfo.section_info[o->target_index].relocs == NULL
	      || finfo.section_info[o->target_index].rel_hashes == NULL)
d6070 1
a6070 1
  finfo.line_filepos = line_filepos;
d6107 1
a6107 1
  finfo.internal_syms = bfd_malloc (amt);
d6110 1
a6110 1
  finfo.sym_indices = bfd_malloc (amt);
d6113 1
a6113 1
  finfo.outsyms = bfd_malloc (amt);
d6116 1
a6116 1
  finfo.linenos = bfd_malloc (amt);
d6119 1
a6119 1
  finfo.contents = bfd_malloc (amt);
d6122 1
a6122 1
  finfo.external_relocs = bfd_malloc (amt);
d6124 6
a6129 6
  if ((finfo.internal_syms == NULL && max_sym_count > 0)
      || (finfo.sym_indices == NULL && max_sym_count > 0)
      || finfo.outsyms == NULL
      || (finfo.linenos == NULL && max_lineno_count > 0)
      || (finfo.contents == NULL && max_contents_size > 0)
      || (finfo.external_relocs == NULL && max_reloc_count > 0))
d6135 1
a6135 1
  if (!xcoff_find_tc0 (abfd, &finfo))
d6153 1
a6153 1
		  if (! xcoff_link_input_bfd (&finfo, sub))
d6161 1
a6161 1
	      if (! xcoff_reloc_link_order (abfd, &finfo, o, p))
d6173 1
a6173 1
  if (finfo.internal_syms != NULL)
d6175 2
a6176 2
      free (finfo.internal_syms);
      finfo.internal_syms = NULL;
d6178 1
a6178 1
  if (finfo.sym_indices != NULL)
d6180 2
a6181 2
      free (finfo.sym_indices);
      finfo.sym_indices = NULL;
d6183 1
a6183 1
  if (finfo.linenos != NULL)
d6185 2
a6186 2
      free (finfo.linenos);
      finfo.linenos = NULL;
d6188 1
a6188 1
  if (finfo.contents != NULL)
d6190 2
a6191 2
      free (finfo.contents);
      finfo.contents = NULL;
d6193 1
a6193 1
  if (finfo.external_relocs != NULL)
d6195 2
a6196 2
      free (finfo.external_relocs);
      finfo.external_relocs = NULL;
d6201 1
a6201 1
  if (finfo.last_file_index != -1)
d6203 4
a6206 4
      finfo.last_file.n_value = -(bfd_vma) 1;
      bfd_coff_swap_sym_out (abfd, (void *) &finfo.last_file,
			     (void *) finfo.outsyms);
      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
d6208 1
a6208 1
	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
d6216 1
a6216 1
			    (void *) &finfo);
d6218 1
a6218 1
  if (finfo.outsyms != NULL)
d6220 2
a6221 2
      free (finfo.outsyms);
      finfo.outsyms = NULL;
d6251 1
a6251 1
      irel = finfo.section_info[o->target_index].relocs;
d6253 1
a6253 1
      rel_hash = finfo.section_info[o->target_index].rel_hashes;
d6270 1
a6270 1
      for (toc_rel_hash = finfo.section_info[o->target_index].toc_rel_hashes;
d6290 1
a6290 1
      qsort ((void *) finfo.section_info[o->target_index].relocs,
d6294 1
a6294 1
      irel = finfo.section_info[o->target_index].relocs;
d6313 1
a6313 1
  if (finfo.section_info != NULL)
d6319 4
a6322 4
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
d6324 2
a6325 2
      free (finfo.section_info);
      finfo.section_info = NULL;
d6332 1
a6332 1
      BFD_ASSERT ((bfd_byte *) finfo.ldrel
d6365 1
a6365 1
	    _bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
d6370 1
a6370 1
  if (! _bfd_stringtab_emit (abfd, finfo.strtab))
d6373 1
a6373 1
  _bfd_stringtab_free (finfo.strtab);
d6398 2
a6399 2
  if (finfo.strtab != NULL)
    _bfd_stringtab_free (finfo.strtab);
d6401 1
a6401 1
  if (finfo.section_info != NULL)
d6407 20
a6426 20
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
    }

  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.sym_indices != NULL)
    free (finfo.sym_indices);
  if (finfo.outsyms != NULL)
    free (finfo.outsyms);
  if (finfo.linenos != NULL)
    free (finfo.linenos);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
@


1.70
log
@update copyright dates
@
text
@d690 1
a690 1
  const char *basename;
d694 2
a695 2
  basename = lbasename (filename);
  length = basename - filename;
d714 1
a714 1
  *impfile = basename;
@


1.69
log
@bfd/
	* coff-rs6000.c (xcoff_ppc_relocate_section): Allow undefined
	symbols to be left unimported when linking statically.
	* xcofflink.c (xcoff_link_add_symbols): Ignore global linkage
	code when linking statically.

ld/testsuite/
	* ld-powerpc/aix-glink-3.s, ld-powerpc/aix-glink-3a.s,
	ld-powerpc/aix-glink-3b.s, ld-powerpc/aix-glink-3.dd,
	ld-powerpc/aix-glink-3-32.d, ld-powerpc/aix-glink-3-64.d: New tests.
	* ld-powerpc/aix52.exp: Run them.  Move the lineno tests to maintain
	alphabetical order.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.68
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d1892 9
d1925 1
a1925 2

 	  if (info->output_bfd->xvec == abfd->xvec)
d1945 2
a1946 17
		  if ((abfd->flags & DYNAMIC) != 0
		      && ((*sym_hash)->smclas != XMC_GL
			  || aux.x_csect.x_smclas == XMC_GL
			  || ((*sym_hash)->root.u.def.section->owner->flags
			      & DYNAMIC) == 0))
		    {
		      /* The new symbol is from a shared library, and
			 either the existing symbol is not global
			 linkage code or this symbol is global linkage
			 code.  If the existing symbol is global
			 linkage code and the new symbol is not, then
			 we want to use the new symbol.  */
		      section = bfd_und_section_ptr;
		      value = 0;
		    }
		  else if (((*sym_hash)->flags & XCOFF_DEF_REGULAR) == 0
			   && ((*sym_hash)->flags & XCOFF_DEF_DYNAMIC) != 0)
d2045 3
a2047 1
	      if (smtyp == XTY_ER || smtyp == XTY_CM)
d2739 4
@


1.67
log
@bfd/
	* xcofflink.c (xcoff_archive_info): Add contains_shared_object_p
	and know_contains_shared_object_p.
	(xcoff_archive_contains_shared_object_p): Add an "info" parameter.
	Cache the result in the archive_info table.
	(xcoff_auto_export_p): Add an "info" parameter and update the
	call to xcoff_archive_contains_shared_object_p.
	(xcoff_mark_auto_exports): Update accordingly.
	(xcoff_post_gc_symbol): Likewise.
@
text
@d2474 15
a3347 13
  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the XCOFF_DEF_REGULAR flag
     will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->flags & XCOFF_REF_REGULAR) != 0
      && (h->flags & XCOFF_DEF_DYNAMIC) == 0
      && (bfd_is_abs_section (h->root.u.def.section)
	  || (h->root.u.def.section->owner->flags & DYNAMIC) == 0))
    h->flags |= XCOFF_DEF_REGULAR;

@


1.66
log
@bfd/
	* xcofflink.c (bfd_link_input_bfd): Treat __rtinit as C_HIDEXT
	rather than C_EXT.

ld/testsuite/
	* ld-powerpc/aix-gc-1.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d89 6
d2513 2
a2514 1
xcoff_archive_contains_shared_object_p (bfd *archive)
d2516 1
d2519 11
a2529 4
  member = bfd_openr_next_archived_file (archive, NULL);
  while (member != NULL && (member->flags & DYNAMIC) == 0)
    member = bfd_openr_next_archived_file (archive, member);
  return member != NULL;
d2557 2
a2558 1
xcoff_auto_export_p (struct xcoff_link_hash_entry *h,
d2595 1
a2595 1
	  && xcoff_archive_contains_shared_object_p (owner->my_archive))
d3215 1
a3215 1
  if (xcoff_auto_export_p (h, ldinfo->auto_export_flags))
d3374 1
a3374 1
      if (xcoff_auto_export_p (h, ldinfo->auto_export_flags))
@


1.65
log
@bfd/
	* bfd-in.h (bfd_xcoff_split_import_path): Declare.
	(bfd_xcoff_set_archive_import_path): Likewise.
	* bfd-in2.h: Regenerate.
	* xcofflink.c: Include libiberty.h.
	(xcoff_archive_info): New structure.
	(xcoff_archive_info_hash): New function.
	(xcoff_archive_info_eq): Likewise.
	(xcoff_get_archive_info): Likewise.
	(_bfd_xcoff_bfd_link_hash_table_create): Initialize archive_info.
	(bfd_xcoff_split_import_path): New function.
	(bfd_xcoff_set_archive_import_path): Likewise.
	(xcoff_set_import_path): Move earlier in file.
	(xcoff_link_add_dynamic_symbols): Set the import path of a non-archive
	object to the the directory part of the bfd's filename.  Get the
	import path and filename of an archive object from the archive's
	xcoff_tdata, initializing it if necessary.  Update use of
	import_file_id.
	(bfd_link_input_bfd): Update use of import_file_id.
	(xcoff_write_global_symbol): Likewise.

ld/
	* emultempl/aix.em (gld${EMULATION_NAME}_open_dynamic_archive): New
	function.
	(ld_${EMULATION_NAME}_emulation): Use it.
@
text
@d4292 1
d4340 10
d4678 1
@


1.64
log
@include/coff/
	* xcoff.h (xcoff_link_hash_table): Move to bfd/xcofflink.c.

bfd/
	* xcofflink.c (xcoff_link_hash_table): Moved from include/coff/xcoff.h.
@
text
@d31 1
d79 12
d148 3
d483 50
d599 2
d677 103
a821 3
  const char *bname;
  const char *mname;
  const char *s;
a997 4
  /* For some reason, the path entry in the import file list for a
     shared object appears to always be empty.  The file name is the
     base name.  */
  n->path = "";
d1000 4
a1003 2
      bname = bfd_get_filename (abfd);
      mname = "";
d1007 14
a1020 2
      bname = bfd_get_filename (abfd->my_archive);
      mname = bfd_get_filename (abfd);
a1021 5
  s = strrchr (bname, '/');
  if (s != NULL)
    bname = s + 1;
  n->file = bname;
  n->member = mname;
a2502 52

/* H is an imported symbol.  Set the import module's path, file and member
   to IMPATH, IMPFILE and IMPMEMBER respectively.  All three are null if
   no specific import module is specified.  */

static bfd_boolean
xcoff_set_import_path (struct bfd_link_info *info,
		       struct xcoff_link_hash_entry *h,
		       const char *imppath, const char *impfile,
		       const char *impmember)
{
  unsigned int c;
  struct xcoff_import_file **pp;

  /* We overload the ldindx field to hold the l_ifile value for this
     symbol.  */
  BFD_ASSERT (h->ldsym == NULL);
  BFD_ASSERT ((h->flags & XCOFF_BUILT_LDSYM) == 0);
  if (imppath == NULL)
    h->ldindx = -1;
  else
    {
      /* We start c at 1 because the first entry in the import list is
	 reserved for the library search path.  */
      for (pp = &xcoff_hash_table (info)->imports, c = 1;
	   *pp != NULL;
	   pp = &(*pp)->next, ++c)
	{
	  if (strcmp ((*pp)->path, imppath) == 0
	      && strcmp ((*pp)->file, impfile) == 0
	      && strcmp ((*pp)->member, impmember) == 0)
	    break;
	}

      if (*pp == NULL)
	{
	  struct xcoff_import_file *n;
	  bfd_size_type amt = sizeof (* n);

	  n = bfd_alloc (info->output_bfd, amt);
	  if (n == NULL)
	    return FALSE;
	  n->next = NULL;
	  n->path = imppath;
	  n->file = impfile;
	  n->member = impmember;
	  *pp = n;
	}
      h->ldindx = c;
    }
  return TRUE;
}
@


1.63
log
@bfd/
	* xcofflink.c (xcoff_link_create_extra_sections): Don't create
	a .loader section for relocatable links.
	(xcoff_need_ldrel_p): New function.
	(xcoff_mark): Use it.
	(bfd_xcoff_link_count_reloc): Only count loader relocs if there's
	a loader section.
	(xcoff_build_ldsym): New function, split out from...
	(xcoff_build_ldsyms): ...here.  Rename to...
	(xcoff_post_gc_symbol): ...this.  Only export symbols, and only
	call xcoff_build_ldsym, if there's a loader section.
	(xcoff_build_loader_section): New function, extracted verbatim from...
	(bfd_xcoff_size_dynamic_sections): ...here.  Only call it if
	there's a loader section.  Only add an __rtinit loader symbol
	if there's a loader section.  Update after above name change.
	(xcoff_symbol_section, xcoff_create_ldrel): New functions.
	(bfd_link_input_bfd): Use xcoff_need_ldrel_p, xcoff_symbol_section
	and xcoff_create_ldrel.
	(xcoff_write_global_symbol): Use xcoff_create_ldrel.
	(xcoff_reloc_link_order): Likewise, but only call it if there's
	a loader section.  Use xcoff_symbol_section.
	(_bfd_xcoff_bfd_final_link): Only use fdinfo.ldrel and fdinfo.ldsym
	if there's a loader section.

ld/testsuite/
	* ld-powerpc/aix-rel-1.s, ld-powerpc/aix-rel-1.od: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d78 61
@


1.62
log
@bfd/
	* xcofflink.c (bfd_link_input_bfd): Fix buffer overrun.
@
text
@d817 2
a818 1
      if (xcoff_hash_table (info)->loader_section == NULL)
d2413 53
d2738 1
a2738 1
	      switch (rel->r_type)
a2739 19
		default:
		  if (h == NULL
		      || h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak
		      || h->root.type == bfd_link_hash_common
		      /* We will always provide a local definition of
			 function symbols.  */
		      || (h->flags & XCOFF_CALLED) != 0)
		    break;
		  /* Fall through.  */
		case R_POS:
		case R_NEG:
		case R_RL:
		case R_RLA:
		  if (h != NULL
		      && (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak)
		      && bfd_is_abs_section (h->root.u.def.section))
		    break;
a2742 9
		  break;
		case R_TOC:
		case R_GL:
		case R_TCL:
		case R_TRL:
		case R_TRLA:
		  /* We should never need a .loader reloc for a TOC
		     relative reloc.  */
		  break;
d2970 6
a2975 2
  h->flags |= XCOFF_REF_REGULAR | XCOFF_LDREL;
  ++xcoff_hash_table (info)->ldrel_count;
d3057 2
d3060 2
a3061 1
xcoff_build_ldsyms (struct xcoff_link_hash_entry *h, void * p)
a3062 1
  struct xcoff_loader_info *ldinfo = (struct xcoff_loader_info *) p;
d3065 1
a3065 39
  if (h->root.type == bfd_link_hash_warning)
    h = (struct xcoff_link_hash_entry *) h->root.u.i.link;

  /* __rtinit, this symbol has special handling. */
  if (h->flags & XCOFF_RTINIT)
      return TRUE;

  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the XCOFF_DEF_REGULAR flag
     will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->flags & XCOFF_REF_REGULAR) != 0
      && (h->flags & XCOFF_DEF_DYNAMIC) == 0
      && (bfd_is_abs_section (h->root.u.def.section)
	  || (h->root.u.def.section->owner->flags & DYNAMIC) == 0))
    h->flags |= XCOFF_DEF_REGULAR;

  /* If all defined symbols should be exported, mark them now.  We
     don't want to export the actual functions, just the function
     descriptors.  */
  if (xcoff_auto_export_p (h, ldinfo->auto_export_flags))
    h->flags |= XCOFF_EXPORT;

  /* We don't want to garbage collect symbols which are not defined in
     XCOFF files.  This is a convenient place to mark them.  */
  if (xcoff_hash_table (ldinfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
      && (h->root.u.def.section->owner == NULL
	  || (h->root.u.def.section->owner->xvec
	      != ldinfo->info->output_bfd->xvec)))
    h->flags |= XCOFF_MARK;

  /* If this symbol is exported, but not defined, we need to try to
     define it.  */
a3071 1
      h->ldsym = NULL;
a3074 12
  /* If this is still a common symbol, and it wasn't garbage
     collected, we need to actually allocate space for it in the .bss
     section.  */
  if (h->root.type == bfd_link_hash_common
      && (! xcoff_hash_table (ldinfo->info)->gc
	  || (h->flags & XCOFF_MARK) != 0)
      && h->root.u.c.p->section->size == 0)
    {
      BFD_ASSERT (bfd_is_com_section (h->root.u.c.p->section));
      h->root.u.c.p->section->size = h->root.u.c.size;
    }

a3078 1

a3084 17
    {
      h->ldsym = NULL;
      return TRUE;
    }

  /* We don't need to add this symbol if we did garbage collection and
     we did not mark this symbol.  */
  if (xcoff_hash_table (ldinfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0)
    {
      h->ldsym = NULL;
      return TRUE;
    }

  /* We may have already processed this symbol due to the recursive
     call above.  */
  if ((h->flags & XCOFF_BUILT_LDSYM) != 0)
d3117 65
d3277 113
a3420 1
  asection *lsec;
a3422 5
  size_t impsize, impcount;
  struct xcoff_import_file *fl;
  struct internal_ldhdr *ldhdr;
  bfd_size_type stoff;
  char *out;
d3454 2
a3455 1
  if (info->init_function || info->fini_function || rtld)
d3571 1
a3571 1
  xcoff_link_hash_traverse (xcoff_hash_table (info), xcoff_build_ldsyms,
d3576 2
a3577 48
  /* Work out the size of the import file names.  Each import file ID
     consists of three null terminated strings: the path, the file
     name, and the archive member name.  The first entry in the list
     of names is the path to use to find objects, which the linker has
     passed in as the libpath argument.  For some reason, the path
     entry in the other import file names appears to always be empty.  */
  impsize = strlen (libpath) + 3;
  impcount = 1;
  for (fl = xcoff_hash_table (info)->imports; fl != NULL; fl = fl->next)
    {
      ++impcount;
      impsize += (strlen (fl->path)
		  + strlen (fl->file)
		  + strlen (fl->member)
		  + 3);
    }

  /* Set up the .loader section header.  */
  ldhdr = &xcoff_hash_table (info)->ldhdr;
  ldhdr->l_version = bfd_xcoff_ldhdr_version(output_bfd);
  ldhdr->l_nsyms = ldinfo.ldsym_count;
  ldhdr->l_nreloc = xcoff_hash_table (info)->ldrel_count;
  ldhdr->l_istlen = impsize;
  ldhdr->l_nimpid = impcount;
  ldhdr->l_impoff = (bfd_xcoff_ldhdrsz(output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz(output_bfd)
		     + ldhdr->l_nreloc * bfd_xcoff_ldrelsz(output_bfd));
  ldhdr->l_stlen = ldinfo.string_size;
  stoff = ldhdr->l_impoff + impsize;
  if (ldinfo.string_size == 0)
    ldhdr->l_stoff = 0;
  else
    ldhdr->l_stoff = stoff;

  /* 64 bit elements to ldhdr
     The swap out routine for 32 bit will ignore them.
     Nothing fancy, symbols come after the header and relocs come
     after symbols.  */
  ldhdr->l_symoff = bfd_xcoff_ldhdrsz (output_bfd);
  ldhdr->l_rldoff = (bfd_xcoff_ldhdrsz (output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (output_bfd));

  /* We now know the final size of the .loader section.  Allocate
     space for it.  */
  lsec = xcoff_hash_table (info)->loader_section;
  lsec->size = stoff + ldhdr->l_stlen;
  lsec->contents = bfd_zalloc (output_bfd, lsec->size);
  if (lsec->contents == NULL)
a3579 42
  /* Set up the header.  */
  bfd_xcoff_swap_ldhdr_out (output_bfd, ldhdr, lsec->contents);

  /* Set up the import file names.  */
  out = (char *) lsec->contents + ldhdr->l_impoff;
  strcpy (out, libpath);
  out += strlen (libpath) + 1;
  *out++ = '\0';
  *out++ = '\0';
  for (fl = xcoff_hash_table (info)->imports; fl != NULL; fl = fl->next)
    {
      const char *s;

      s = fl->path;
      while ((*out++ = *s++) != '\0')
	;
      s = fl->file;
      while ((*out++ = *s++) != '\0')
	;
      s = fl->member;
      while ((*out++ = *s++) != '\0')
	;
    }

  BFD_ASSERT ((bfd_size_type) ((bfd_byte *) out - lsec->contents) == stoff);

  /* Set up the symbol string table.  */
  if (ldinfo.string_size > 0)
    {
      memcpy (out, ldinfo.strings, ldinfo.string_size);
      free (ldinfo.strings);
      ldinfo.strings = NULL;
    }

  /* We can't set up the symbol table or the relocs yet, because we
     don't yet know the final position of the various sections.  The
     .loader symbols are written out when the corresponding normal
     symbols are written out in xcoff_link_input_bfd or
     xcoff_write_global_symbol.  The .loader relocs are written out
     when the corresponding normal relocs are handled in
     xcoff_link_input_bfd.  */

d3794 85
a4590 1
	      struct internal_ldrel ldrel;
d4723 1
a4723 1
	      switch (irel->r_type)
d4725 2
a4726 19
		default:
		  if (h == NULL
		      || h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak
		      || h->root.type == bfd_link_hash_common)
		    break;
		  /* Fall through.  */
		case R_POS:
		case R_NEG:
		case R_RL:
		case R_RLA:
		  if (h != NULL
		      && (h->root.type == bfd_link_hash_defined
			  || h->root.type == bfd_link_hash_defweak)
		      && bfd_is_abs_section (h->root.u.def.section))
		    break;
		  /* This reloc needs to be copied into the .loader
		     section.  */
		  ldrel.l_vaddr = irel->r_vaddr;
d4728 3
a4730 31
		    ldrel.l_symndx = -(bfd_size_type ) 1;
		  else if (h == NULL
			   || (h->root.type == bfd_link_hash_defined
			       || h->root.type == bfd_link_hash_defweak
			       || h->root.type == bfd_link_hash_common))
		    {
		      asection *sec;

		      if (h == NULL)
			sec = xcoff_data (input_bfd)->csects[r_symndx];
		      else if (h->root.type == bfd_link_hash_common)
			sec = h->root.u.c.p->section;
		      else
			sec = h->root.u.def.section;
		      sec = sec->output_section;

		      if (strcmp (sec->name, ".text") == 0)
			ldrel.l_symndx = 0;
		      else if (strcmp (sec->name, ".data") == 0)
			ldrel.l_symndx = 1;
		      else if (strcmp (sec->name, ".bss") == 0)
			ldrel.l_symndx = 2;
		      else
			{
			  (*_bfd_error_handler)
			    (_("%B: loader reloc in unrecognized section `%A'"),
			     input_bfd, sec);
			  bfd_set_error (bfd_error_nonrepresentable_section);
			  return FALSE;
			}
		    }
d4732 5
a4736 37
		    {
		      if (h->ldindx < 0)
			{
			  (*_bfd_error_handler)
			    (_("%B: `%s' in loader reloc but not loader sym"),
			     input_bfd,
			     h->root.root.string);
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      ldrel.l_symndx = h->ldindx;
		    }
		  ldrel.l_rtype = (irel->r_size << 8) | irel->r_type;
		  ldrel.l_rsecnm = o->output_section->target_index;
		  if (xcoff_hash_table (finfo->info)->textro
		      && strcmp (o->output_section->name, ".text") == 0)
		    {
		      (*_bfd_error_handler)
			(_("%B: loader reloc in read-only section %A"),
			 input_bfd, o->output_section);
		      bfd_set_error (bfd_error_invalid_operation);
		      return FALSE;
		    }
		  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel,
					    finfo->ldrel);

		  finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
		  break;

		case R_TOC:
		case R_GL:
		case R_TCL:
		case R_TRL:
		case R_TRLA:
		  /* We should never need a .loader reloc for a TOC
		     relative reloc.  */
		  break;
a5092 1
      struct internal_ldrel ldrel;
d5145 3
a5147 6
      ldrel.l_vaddr = irel->r_vaddr;
      ldrel.l_symndx = h->ldindx;
      ldrel.l_rtype = (irel->r_size << 8) | R_POS;
      ldrel.l_rsecnm = oindx;
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
a5212 1
      struct internal_ldrel ldrel;
d5250 3
a5252 20
      ldrel.l_vaddr = irel->r_vaddr;
      if (strcmp (esec->output_section->name, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (esec->output_section->name, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (esec->output_section->name, ".bss") == 0)
	ldrel.l_symndx = 2;
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: loader reloc in unrecognized section `%s'"),
	     bfd_get_filename (output_bfd),
	     esec->output_section->name);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
      ldrel.l_rtype = (reloc_size << 8) | R_POS;
      ldrel.l_rsecnm = oindx;
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
d5295 3
a5297 20
      ldrel.l_vaddr = irel->r_vaddr;
      if (strcmp (tsec->output_section->name, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (tsec->output_section->name, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (tsec->output_section->name, ".bss") == 0)
	ldrel.l_symndx = 2;
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: loader reloc in unrecognized section `%s'"),
	     bfd_get_filename (output_bfd),
	     tsec->output_section->name);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
      ldrel.l_rtype = (reloc_size << 8) | R_POS;
      ldrel.l_rsecnm = oindx;
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
a5458 1
  struct internal_ldrel ldrel;
d5486 4
a5489 11
  if (h->root.type == bfd_link_hash_common)
    {
      hsec = h->root.u.c.p->section;
      hval = 0;
    }
  else if (h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
    {
      hsec = h->root.u.def.section;
      hval = h->root.u.def.value;
    }
d5491 1
a5491 4
    {
      hsec = NULL;
      hval = 0;
    }
d5566 1
a5566 4

  ldrel.l_vaddr = irel->r_vaddr;

  if (hsec != NULL)
d5568 3
a5570 31
      const char *secname;

      secname = hsec->output_section->name;

      if (strcmp (secname, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (secname, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (secname, ".bss") == 0)
	ldrel.l_symndx = 2;
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: loader reloc in unrecognized section `%s'"),
	     bfd_get_filename (output_bfd), secname);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
    }
  else
    {
      if (h->ldindx < 0)
	{
	  (*_bfd_error_handler)
	    (_("%s: `%s' in loader reloc but not loader sym"),
	     bfd_get_filename (output_bfd),
	     h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      ldrel.l_symndx = h->ldindx;
a5572 5
  ldrel.l_rtype = (irel->r_size << 8) | irel->r_type;
  ldrel.l_rsecnm = output_section->target_index;
  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
  finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);

d5618 14
a5631 6
  finfo.ldsym = (xcoff_hash_table (info)->loader_section->contents
		 + bfd_xcoff_ldhdrsz (abfd));
  finfo.ldrel = (xcoff_hash_table (info)->loader_section->contents
		 + bfd_xcoff_ldhdrsz(abfd)
		 + (xcoff_hash_table (info)->ldhdr.l_nsyms
		    * bfd_xcoff_ldsymsz(abfd)));
a6117 3
  BFD_ASSERT ((bfd_byte *) finfo.ldrel
	      == (xcoff_hash_table (info)->loader_section->contents
		  + xcoff_hash_table (info)->ldhdr.l_impoff));
d6119 9
a6127 3
  if (! bfd_set_section_contents (abfd, o->output_section, o->contents,
				  (file_ptr) o->output_offset, o->size))
    goto error_return;
@


1.61
log
@bfd/
	* xcofflink.c (xcoff_link_check_archive_element): Only free the
	symbol table if it was created by the current call.
@
text
@a4270 1
		      linp += linesz;
d4277 1
a4277 1
		      for (; linp < linpend; linp += linesz)
@


1.60
log
@bfd/
	* xcofflink.c (xcoff_build_ldsyms): Give imported descriptors
	class XMC_DS rather than XMC_UA.
@
text
@d2152 3
d2165 2
d2169 1
a2169 1
  if (! info->keep_memory || ! *pneeded)
@


1.59
log
@include/coff/
	* xcoff.h (XCOFF_EXPALL, XCOFF_EXPFULL): New flags.
	(xcoff_loader_info): Add auto_export_flags.

bfd/
	* bfd-in.h (bfd_xcoff_size_dynamic_sections): Replace the
	bfd_boolean export_defineds parameter with an unsigned int
	auto_export_flags parameter.
	* bfd-in2.h: Regenerate.
	* xcofflink.c (xcoff_archive_contains_shared_object_p): New function,
	split out from xcoff_build_ldsyms.
	(xcoff_covered_by_expall_p): New function.
	(xcoff_auto_export_p): New function, split out from xcoff_build_ldsyms
	but with extra code to handle -bexpfull and -bexpall.
	(xcoff_mark_auto_exports): New function.
	(xcoff_build_ldsyms): Use xcoff_auto_export_p to decide whether
	a function should be automatically exported.
	(bfd_xcoff_size_dynamic_sections): Replace the export_defineds
	parameter with an auto_export_flags parameter.  Update ldinfo
	accordingly.  Use xcoff_mark_auto_exports to mark all automatically-
	exported symbols.

ld/
	* emultempl/aix.em (auto_export_flags): New variable.
	(explicit_auto_export_flags): Likewise.
	(OPTION_EXPALL, OPTION_EXPFULL): New enum values.
	(OPTION_NOEXPALL, OPTION_NOEXPFULL): Likewise.
	(gld${EMULATION_NAME}_add_options): Add -bexpall, -bexpfull,
	-bnoexpall and -bnoexpfull.
	(gld${EMULATION_NAME}_handle_option): Handle them.
	(gld${EMULATION_NAME}_before_allocation): Update the call to
	bfd_size_dynamic_sections.

ld/testsuite/
	* ld-powerpc/aix-export-1-all.dd, ld-powerpc/aix-export-1-full.dd,
	ld-powerpc/aix-export-1a.s, ld-powerpc/aix-export-1b.s: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d3131 6
a3136 1
    h->ldsym->l_ifile = h->ldindx;
@


1.58
log
@bfd/
	* xcofflink.c (xcoff_mark_symbol_by_name): New function.
	(bfd_xcoff_size_dynamic_sections): Use it to mark the entry,
	init and fini functions.  Do garbage collection for objects
	without an entry point too.

ld/testsuite/
	* ld-powerpc/aix-gc-1.s, ld-powerpc/aix-gc-1.ex,
	ld-powerpc/aix-gc-1-32.dd, ld-powerpc/aix-gc-1-64.dd,
	ld-powerpc/aix-weak-1-gcdso.dnd, ld-powerpc/aix-weak-1-gcdso.hd,
	ld-powerpc/aix-weak-1-gcdso.nd: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d2316 91
d2972 18
d3051 2
a3052 44
  if (ldinfo->export_defineds
      && (h->flags & XCOFF_DEF_REGULAR) != 0
      && h->root.root.string[0] != '.')
    {
      bfd_boolean export;

      /* We don't export a symbol which is being defined by an object
	 included from an archive which contains a shared object.  The
	 rationale is that if an archive contains both an unshared and
	 a shared object, then there must be some reason that the
	 unshared object is unshared, and we don't want to start
	 providing a shared version of it.  In particular, this solves
	 a bug involving the _savefNN set of functions.  gcc will call
	 those functions without providing a slot to restore the TOC,
	 so it is essential that these functions be linked in directly
	 and not from a shared object, which means that a shared
	 object which also happens to link them in must not export
	 them.  This is confusing, but I haven't been able to think of
	 a different approach.  Note that the symbols can, of course,
	 be exported explicitly.  */
      export = TRUE;
      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section->owner != NULL
	  && h->root.u.def.section->owner->my_archive != NULL)
	{
	  bfd *arbfd, *member;

	  arbfd = h->root.u.def.section->owner->my_archive;
	  member = bfd_openr_next_archived_file (arbfd, NULL);
	  while (member != NULL)
	    {
	      if ((member->flags & DYNAMIC) != 0)
		{
		  export = FALSE;
		  break;
		}
	      member = bfd_openr_next_archived_file (arbfd, member);
	    }
	}

      if (export)
	h->flags |= XCOFF_EXPORT;
    }
d3251 3
a3253 4
   be read only (the -btextro linker option).  EXPORT_DEFINEDS is
   whether all defined symbols should be exported (the -unix linker
   option).  SPECIAL_SECTIONS is set by this routine to csects with
   magic names like _end.  */
d3266 1
a3266 1
				 bfd_boolean export_defineds,
d3294 1
a3294 1
  ldinfo.export_defineds = export_defineds;
d3397 7
@


1.57
log
@include/coff/
	* internal.h (C_AIX_WEAKEXT): New macro.
	(C_WEAKEXT): Use the GNU definition in the generic part of the file,
	and conditionally reset it to C_AIX_WEAKEXT in the XCOFF part of
	the file.
	(CSECT_SYM_P): New macro.
	* xcoff.h (L_WEAK): Define.
	(EXTERN_SYM_P): New macro.

bfd/
	* coffcode.h (coff_pointerize_aux_hook): Update CSECT_SYM_P to
	check whether a symbol has csect information.
	(coff_print_aux): Likewise.
	* coff-rs6000.c (_bfd_xcoff_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff_swap_aux_out): Likewise.
	(xcoff_reloc_type_br): Handle defweak symbols too.
	* coff64-rs6000.c (_bfd_xcoff64_swap_aux_in): Handle auxillary csect
	information for C_AIX_WEAKEXT too.
	(_bfd_xcoff64_swap_aux_out): Likewise.
	(xcoff64_reloc_type_br): Handle defweak symbols too.
	* coffgen.c (coff_print_symbol): Handle auxillary function
	information for C_AIX_WEAKEXT too.
	* xcofflink.c (_bfd_xcoff_canonicalize_dynamic_symtab): Set BSF_WEAK
	instead of BSF_GLOBAL if the L_WEAK flag is set.
	(xcoff_dynamic_definition_p): New function.
	(xcoff_link_add_dynamic_symbols): Use it to decide whether ldsym
	defines h.  Don't change h if ldsym isn't the definition.  Otherwise,
	always take the symbol class from the ldsym.  Use weak bfd symbol
	types for weak ldsyms.
	(xcoff_link_add_symbols): Use CSECT_SYM_P and EXTERN_SYM_P.
	Fix the check for whether a definition is from a shared object.
	Allow redefinitions of weak symbols.
	(xcoff_link_check_ar_symbols): Use EXTERN_SYM_P.
	(xcoff_keep_symbol_p): Likewise.
	(bfd_xcoff_size_dynamic_sections): Use CSECT_SYM_P.
	(xcoff_link_input_bfd): Use CSECT_SYM_P and EXTERN_SYM_P.
	Add .loader entries for C_AIX_WEAKEXT as well as C_EXT symbols,
	but mark them as L_WEAK.
	(xcoff_write_global_symbol): Treat weak symbols as C_AIX_WEAKEXT
	instead of C_EXT if C_AIX_WEAKEXT == C_WEAKEXT.

gas/
	* config/tc-ppc.c (ppc_frob_symbol): Add csect information for
	C_AIX_WEAKEXT too.

ld/testsuite/
	* ld-powerpc/aix-glink-2a.s, ld-powerpc/aix-glink-2a.ex,
	ld-powerpc/aix-glink-2b.s, ld-powerpc/aix-glink-2c.s,
	ld-powerpc/aix-glink-2c.ex, ld-powerpc/aix-glink-2d.s,
	ld-powerpc/aix-glink-2-32.dd, ld-powerpc/aix-glink-2-64.dd,
	ld-powerpc/aix-weak-1a.s, ld-powerpc/aix-weak-1b.s,
	ld-powerpc/aix-weak-1-rel.hd, ld-powerpc/aix-weak-1-rel.nd,
	ld-powerpc/aix-weak-1-dso.hd, ld-powerpc/aix-weak-1-dso.nd,
	ld-powerpc/aix-weak-1-dso.dnd, ld-powerpc/aix-weak-1.ex,
	ld-powerpc/aix-weak-2a.s, ld-powerpc/aix-weak-2a.ex,
	ld-powerpc/aix-weak-2a.nd, ld-powerpc/aix-weak-2b.s,
	ld-powerpc/aix-weak-2b.nd, ld-powerpc/aix-weak-2c.s,
	ld-powerpc/aix-weak-2c.ex, ld-powerpc/aix-weak-2c.nd,
	ld-powerpc/aix-weak-2c.od, ld-powerpc/aix-weak-3a.s,
	ld-powerpc/aix-weak-3a.ex, ld-powerpc/aix-weak-3b.s,
	ld-powerpc/aix-weak-3b.ex, ld-powerpc/aix-weak-3-32.d,
	ld-powerpc/aix-weak-3-32.dd, ld-powerpc/aix-weak-3-64.d,
	ld-powerpc/aix-weak-3-64.dd: New tests.
	* ld-powerpc/aix52.exp: Run them.  Replace tmp/aix-* with
	tmp/aix64-* in 64-bit ld options.
@
text
@d2485 24
a3203 1
  struct xcoff_link_hash_entry *hentry;
a3241 9
  hentry = NULL;
  if (entry != NULL)
    {
      hentry = xcoff_link_hash_lookup (xcoff_hash_table (info), entry,
				       FALSE, FALSE, TRUE);
      if (hentry != NULL)
	hentry->flags |= XCOFF_ENTRY;
    }

d3294 1
a3294 5
  if (info->relocatable
      || ! gc
      || hentry == NULL
      || (hentry->root.type != bfd_link_hash_defined
	  && hentry->root.type != bfd_link_hash_defweak))
d3322 8
a3329 1
      if (! xcoff_mark (info, hentry->root.u.def.section))
@


1.56
log
@include/coff/
	* xcoff.h (XCOFF_ALLOCATED): New flag.

bfd/
	* xcofflink.c (xcoff_mark): When walking the relocations,
	only mark the target symbol or the target section, not both.
	(xcoff_final_definition_p): New function.
	(xcoff_keep_symbol_p): Use it to check whether an external XCOFF
	symbol is a valid definition of the associated output symbol.
	Use XCOFF_ALLOCATED to stop the same hash table entry having
	two output symbols.
	(bfd_xcoff_size_dynamic_sections): Set XCOFF_ALLOCATED when
	keeping a symbol.
	(xcoff_link_input_bfd): Use xcoff_final_definition_p.

ld/testsuite/
	* ld-powerpc/aix-no-dup-syms-1a.s, ld-powerpc/aix-no-dup-syms-1b.s,
	ld-powerpc/aix-no-dup-syms-1.ex, ld-powerpc/aix-no-dup-syms-1.im,
	ld-powerpc/aix-no-dup-syms-1-dso.dnd,
	ld-powerpc/aix-no-dup-syms-1-dso.drd,
	ld-powerpc/aix-no-dup-syms-1-dso.nd,
	ld-powerpc/aix-no-dup-syms-1-dso.rd,
	ld-powerpc/aix-no-dup-syms-1-rel.nd,
	ld-powerpc/aix-no-dup-syms-1-rel.rd: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d261 6
a266 1
	symbuf->symbol.flags |= BSF_GLOBAL;
d548 30
d676 3
d680 2
a681 30

      /* If the symbol is undefined, and the BFD it was found in is
	 not a dynamic object, change the BFD to this dynamic object,
	 so that we can get the correct import file ID.  */
      if ((h->root.type == bfd_link_hash_undefined
	   || h->root.type == bfd_link_hash_undefweak)
	  && (h->root.u.undef.abfd == NULL
	      || (h->root.u.undef.abfd->flags & DYNAMIC) == 0))
	h->root.u.undef.abfd = abfd;

      if (h->root.type == bfd_link_hash_new)
	{
	  h->root.type = bfd_link_hash_undefined;
	  h->root.u.undef.abfd = abfd;
	  /* We do not want to add this to the undefined symbol list.  */
	}

      if (h->smclas == XMC_UA
	  || h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	h->smclas = ldsym.l_smclas;

      /* Unless this is an XMC_XO symbol, we don't bother to actually
	 define it, since we don't have a section to put it in anyhow.
	 Instead, the relocation routines handle the DEF_DYNAMIC flag
	 correctly.  */

      if (h->smclas == XMC_XO
	  && (h->root.type == bfd_link_hash_undefined
	      || h->root.type == bfd_link_hash_undefweak))
d684 4
a687 1
	  h->root.type = bfd_link_hash_defined;
d691 12
d729 9
a737 1
	      if (hds->root.type == bfd_link_hash_new)
d739 10
a748 1
		  hds->root.type = bfd_link_hash_undefined;
a752 20

	      hds->descriptor = h;
	      h->descriptor = hds;
	    }

	  hds->flags |= XCOFF_DEF_DYNAMIC;
	  if (hds->smclas == XMC_UA)
	    hds->smclas = XMC_PR;

	  /* An absolute symbol appears to actually define code, not a
	     function descriptor.  This is how some math functions are
	     implemented on AIX 4.1.  */
	  if (h->smclas == XMC_XO
	      && (hds->root.type == bfd_link_hash_undefined
		  || hds->root.type == bfd_link_hash_undefweak))
	    {
	      hds->smclas = XMC_XO;
	      hds->root.type = bfd_link_hash_defined;
	      hds->root.u.def.section = bfd_abs_section_ptr;
	      hds->root.u.def.value = ldsym.l_value;
a1111 1
      flagword flags;
d1120 1
a1120 1
      if (sym.n_sclass != C_EXT && sym.n_sclass != C_HIDEXT)
a1239 1
      flags = BSF_GLOBAL;
d1350 1
a1350 1
		  if (relsym.n_sclass == C_EXT)
d1505 1
a1505 1
	    /* If this symbol is C_EXT, we treat it as starting at the
d1507 1
a1507 1
	    if (sym.n_sclass == C_EXT)
d1596 1
a1596 1
	  if (sym.n_sclass == C_EXT)
d1637 1
a1637 1
      if (sym.n_sclass == C_EXT)
d1640 1
d1711 2
a1712 2
		  else if (((*sym_hash)->root.u.def.section->owner->flags
			    & DYNAMIC) != 0)
d1728 6
d1753 1
a1753 2
		       && ((*sym_hash)->root.type == bfd_link_hash_defined
			   || (*sym_hash)->root.type == bfd_link_hash_defweak)
d1788 1
d2103 1
a2103 1
      if (sym.n_sclass == C_EXT && sym.n_scnum != N_UNDEF)
d3100 1
a3100 1
  if (isym->n_sclass == C_EXT)
d3111 1
a3111 1
      && isym->n_sclass != C_EXT
d3139 1
a3139 1
	  && isym->n_sclass != C_EXT
d3525 2
a3526 3
	  /* If this is a C_EXT or C_HIDEXT symbol, we need the csect
	     information too.  */
	  if (sym.n_sclass == C_EXT || sym.n_sclass == C_HIDEXT)
d3727 2
a3728 3
      /* If this is a C_EXT or C_HIDEXT symbol, we need the csect
	 information.  */
      if (isymp->n_sclass == C_EXT || isymp->n_sclass == C_HIDEXT)
d3744 1
a3744 1
      if (isymp->n_sclass == C_EXT
d3779 2
d3842 1
a3842 1
	  if (isymp->n_sclass == C_EXT)
d4048 1
a4048 2
	      else if ((isymp->n_sclass == C_EXT
			|| isymp->n_sclass == C_HIDEXT)
d4127 1
a4127 2
	      if ((isymp->n_sclass == C_EXT
		   || isymp->n_sclass == C_HIDEXT)
d5222 5
a5226 1
      isym.n_sclass = C_EXT;
d5236 5
a5240 1
      isym.n_sclass = C_EXT;
d5302 5
a5306 1
      isym.n_sclass = C_EXT;
@


1.55
log
@bfd/
	* xcofflink.c (bfd_xcoff_import_symbol): Treat imported absolute
	symbols as XMC_XO.

ld/testsuite/
	* ld-powerpc/aix-abs-branch-1.nd,
	ld-powerpc/aix-abs-reloc-1.nd: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@a2506 1
	      asection *rsec;
d2514 1
a2514 2
	      if (h != NULL
		  && (h->flags & XCOFF_MARK) == 0)
d2516 5
a2520 2
		  if (! xcoff_mark_symbol (info, h))
		    return FALSE;
d2522 3
d2526 7
a2532 8
	      rsec = xcoff_data (sec->owner)->csects[rel->r_symndx];
	      if (rsec != NULL
		  && !bfd_is_und_section (rsec)
		  && !bfd_is_abs_section (rsec)
		  && (rsec->flags & SEC_MARK) == 0)
		{
		  if (! xcoff_mark (info, rsec))
		    return FALSE;
d2832 30
d3072 8
a3079 15
  /* We can ignore external references that were resolved by the link.  */
  smtyp = SMTYP_SMTYP (aux->x_csect.x_smtyp);
  if (isym->n_sclass == C_EXT
      && smtyp == XTY_ER
      && h->root.type != bfd_link_hash_undefined)
    return 0;

  /* We can ignore common symbols if they got defined somewhere else.  */
  if (isym->n_sclass == C_EXT
      && smtyp == XTY_CM
      && (h->root.type != bfd_link_hash_common
	  || h->root.u.c.p->section != csect)
      && (h->root.type != bfd_link_hash_defined
	  || h->root.u.def.section != csect))
    return 0;
d3082 1
d3543 2
d3722 1
a3722 2
	  && (smtyp != XTY_ER
	      || (*sym_hash)->root.type == bfd_link_hash_undefined))
@


1.54
log
@bfd/
	* libcoff-in.h (xcoff_tdata): Add a lineno_counts field.
	* libcoff.h: Regenerate.
	* xcofflink.c (xcoff_link_add_symbols): Record per-symbol
	line-number counts in the bfd's lineno_counts field.
	Don't keep per-csect line-number counts.
	(xcoff_sweep): Don't update per-csect line-number counts.
	(bfd_xcoff_size_dynamic_sections): Count the number of line-number
	entries in each output section.
	(xcoff_link_input_bfd): Get the number of line numbers from
	the bfd's lineno_counts field, rather than recalculating it
	from scratch.  Fix the range check when updating C_BINCL and
	C_EINCL symbols.
	(_bfd_xcoff_bfd_final_link): Don't count the output line numbers
	here.  Don't expect csects to have line-number counts.

ld/testsuite/
	* ld-powerpc/aix-lineno-1.s, ld-powerpc/aix-lineno-1.txt,
	ld-powerpc/aix-lineno-1a.dd, ld-powerpc/aix-lineno-1a.nd,
	ld-powerpc/aix-lineno-1b.dd, ld-powerpc/aix-lineno-1b.nd: New tests.
	* ld-powerpc/aix52.exp: Run them.  Copy aix-lineno-1.txt to tmpdir.
@
text
@d2726 1
@


1.53
log
@bfd/
	* libcoff-in.h (xcoff_tdata): Change debug_indices to a signed long.
	* libcoff.h: Regenerate.
	* xcofflink.c (xcoff_keep_symbol_p): New function, using the
	"skip" logic from xcoff_link_input_bfd.
	(bfd_xcoff_size_dynamic_sections): Explicitly skip dynamic
	objects in a dynamic link, rather than checking whether csectpp
	is null.  Always allocate debug_index for other objects,
	and always go through the loop.  Update the type of debug_index
	after the change above.  Read the auxillary csect information
	and use xcoff_keep_symbol_p to decide whether a symbol should
	be kept.  Set its debug_index to -2 if not.
	(xcoff_link_input_bfd): Update the type of debug_index after
	the change above and always expect it to be nonnull.  Use it to
	test whether a symbol should be stripped, rather than making the
	decision here.  Postpone all symbol creation to the second pass.
@
text
@d950 1
d1017 9
d1117 1
d1188 1
a1188 1
		      csect->lineno_count += (linp - linpstart) / linesz;
d1809 1
a2616 1
		  o->lineno_count = 0;
d3410 1
d3454 1
d3464 1
d3490 1
d3492 1
a3492 1
					*sym_hash, *csectpp, name);
d3515 2
d3522 1
d3611 1
d3824 1
d4079 1
a4079 2
		  if (finfo->info->strip != strip_none
		      && finfo->info->strip != strip_some)
d4087 5
d4093 2
d4100 2
a4101 2
			  file_ptr pos = enclosing->line_filepos;
			  bfd_size_type amt = linesz * enc_count;
d4109 2
d4113 12
a4124 13

		      bfd_coff_swap_lineno_in (input_bfd,
					       (void *) (finfo->linenos + linoff),
					       (void *) &lin);
		      if (lin.l_lnno != 0
			  || ((bfd_size_type) lin.l_addr.l_symndx
			      != ((esym
				   - isymesz
				   - ((bfd_byte *)
				      obj_coff_external_syms (input_bfd)))
				  / isymesz)))
			aux.x_sym.x_fcnary.x_fcn.x_lnnoptr = 0;
		      else
d4126 4
a4129 29
			  bfd_byte *linpend, *linp;
			  bfd_vma offset;
			  bfd_size_type count;

			  lin.l_addr.l_symndx = *indexp;
			  bfd_coff_swap_lineno_out (output_bfd, (void *) &lin,
						    (void *) (finfo->linenos
							   + linoff));

			  linpend = (finfo->linenos
				     + enc_count * linesz);
			  offset = (o->output_section->vma
				    + o->output_offset
				    - o->vma);
			  for (linp = finfo->linenos + linoff + linesz;
			       linp < linpend;
			       linp += linesz)
			    {
			      bfd_coff_swap_lineno_in (input_bfd, (void *) linp,
						       (void *) &lin);
			      if (lin.l_lnno == 0)
				break;
			      lin.l_addr.l_paddr += offset;
			      bfd_coff_swap_lineno_out (output_bfd,
							(void *) &lin,
							(void *) linp);
			    }

			  count = (linp - (finfo->linenos + linoff)) / linesz;
d4131 2
a4132 2
			  aux.x_sym.x_fcnary.x_fcn.x_lnnoptr =
			    (o->output_section->line_filepos
d4134 6
d4141 3
a4143 7
			  if (bfd_seek (output_bfd,
					aux.x_sym.x_fcnary.x_fcn.x_lnnoptr,
					SEEK_SET) != 0
			      || (bfd_bwrite (finfo->linenos + linoff,
					     linesz * count, output_bfd)
				  != linesz * count))
			    return FALSE;
d4145 18
a4162 3
			  o->output_section->lineno_count += count;

			  if (incls > 0)
d4164 5
a4168 14
			      struct internal_syment *iisp, *iispend;
			      long *iindp;
			      bfd_byte *oos;
			      int iiadd;

			      /* Update any C_BINCL or C_EINCL symbols
				 that refer to a line number in the
				 range we just output.  */
			      iisp = finfo->internal_syms;
			      iispend = (iisp
					 + obj_raw_syment_count (input_bfd));
			      iindp = finfo->sym_indices;
			      oos = finfo->outsyms;
			      while (iisp < iispend)
d4170 9
a4178 30
				  if (*iindp >= 0
				      && (iisp->n_sclass == C_BINCL
					  || iisp->n_sclass == C_EINCL)
				      && ((bfd_size_type) iisp->n_value
					  >= (bfd_size_type)(enclosing->line_filepos + linoff))
				      && ((bfd_size_type) iisp->n_value
					  < (enclosing->line_filepos
					     + enc_count * linesz)))
				    {
				      struct internal_syment iis;

				      bfd_coff_swap_sym_in (output_bfd,
							    (void *) oos,
							    (void *) &iis);
				      iis.n_value =
					(iisp->n_value
					 - enclosing->line_filepos
					 - linoff
					 + aux.x_sym.x_fcnary.x_fcn.x_lnnoptr);
				      bfd_coff_swap_sym_out (output_bfd,
							     (void *) &iis,
							     (void *) oos);
				      --incls;
				    }

				  iiadd = 1 + iisp->n_numaux;
				  if (*iindp >= 0)
				    oos += iiadd * osymesz;
				  iisp += iiadd;
				  iindp += iiadd;
d4180 6
d4202 1
d5497 3
a5499 2
  /* Count the line number and relocation entries required for the
     output file.  Determine a few maximum sizes.  */
a5505 1
      o->lineno_count = 0;
a5519 4
	      if (info->strip == strip_none
		  || info->strip == strip_some)
		o->lineno_count += sec->lineno_count;

a5525 2
	      if (sec->lineno_count > max_lineno_count)
		max_lineno_count = sec->lineno_count;
@


1.52
log
@bfd/
	* xcofflink.c: (xcoff_mark_symbol): Mark the TOC section when
	creating a descriptor.
	(xcoff_sweep): Don't mark toc_section unless it's needed.
	(bfd_xcoff_size_dynamic_sections): Skip the toc_section
	when marking every bfd.
	(xcoff_link_input_bfd): Skip all TOC anchors.
	(xcoff_toc_section_p, xcoff_find_tc0): New functions.
	(_bfd_xcoff_bfd_final_link): Don't set the output bfd's TOC anchor
	to -1; call xcoff_find_tc0 instead.

ld/testsuite/
	* ld-powerpc/aix-toc-1.ex, ld-powerpc/aix-toc-1a.s,
	ld-powerpc/aix-toc-1b.s, ld-powerpc/aix-toc-1-32.dd,
	ld-powerpc/aix-toc-1-64.dd: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d2984 98
d3389 2
a3390 2
  /* Now that we've done garbage collection, figure out the contents
     of the .debug section.  */
d3397 1
a3397 1
      unsigned long *debug_index;
d3399 1
d3405 3
a3407 2
      subdeb = bfd_get_section_by_name (sub, ".debug");
      if (subdeb == NULL || subdeb->size == 0)
a3409 8
      if (info->strip == strip_all
	  || info->strip == strip_debugger
	  || info->discard == discard_all)
	{
	  subdeb->size = 0;
	  continue;
	}

d3414 1
a3414 1
      debug_index = bfd_zalloc (sub, symcount * sizeof (unsigned long));
d3419 21
a3439 7
      /* Grab the contents of the .debug section.  We use malloc and
	 copy the names into the debug stringtab, rather than
	 bfd_alloc, because I expect that, when linking many files
	 together, many of the strings will be the same.  Storing the
	 strings in the hash table should save space in this case.  */
      if (! bfd_malloc_and_get_section (sub, subdeb, &debug_contents))
	goto error_return;
d3442 4
d3447 1
a3447 2
      /* Dynamic object do not have csectpp's.  */
      if (NULL != csectpp)
d3449 4
a3452 3
	  symesz = bfd_coff_symesz (sub);
	  esym = (bfd_byte *) obj_coff_external_syms (sub);
	  esymend = esym + symcount * symesz;
d3454 1
a3454 3
	  while (esym < esymend)
	    {
	      struct internal_syment sym;
d3456 18
a3473 1
	      bfd_coff_swap_sym_in (sub, (void *) esym, (void *) &sym);
d3475 5
a3479 1
	      *debug_index = (unsigned long) -1;
d3481 9
a3489 7
	      if (sym._n._n_n._n_zeroes == 0
		  && *csectpp != NULL
		  && (! gc
		      || bfd_is_abs_section (*csectpp)
		      || bfd_is_und_section (*csectpp)
		      || ((*csectpp)->flags & SEC_MARK) != 0)
		  && bfd_coff_symname_in_debug (sub, &sym))
a3490 1
		  char *name;
a3492 1
		  name = (char *) debug_contents + sym._n._n_n._n_offset;
d3498 3
d3502 4
a3505 4
	      esym += (sym.n_numaux + 1) * symesz;
	      csectpp += sym.n_numaux + 1;
	      debug_index += sym.n_numaux + 1;
	    }
d3508 4
a3511 2
      free (debug_contents);
      debug_contents = NULL;
d3513 4
a3516 3
      /* Clear the size of subdeb, so that it is not included directly
	 in the output file.  */
      subdeb->size = 0;
d3593 1
a3593 1
  unsigned long *debug_index;
d3633 3
a3643 4
  outsym = finfo->outsyms;
  incls = 0;
  oline = NULL;

a3645 1
      struct internal_syment isym;
a3647 1
      bfd_boolean skip;
a3665 6
      /* Make a copy of *isymp so that the relocate_section function
	 always sees the original values.  This is more reliable than
	 always recomputing the symbol value even if we are stripping
	 the symbol.  */
      isym = *isymp;

d3670 1
a3670 1
      if (isym.n_sclass == C_EXT
d3681 1
a3681 1
	  if (isym.n_scnum > 0)
d3684 1
a3684 1
	      ldsym->l_value = (isym.n_value
d3691 2
a3692 2
	      ldsym->l_scnum = isym.n_scnum;
	      ldsym->l_value = isym.n_value;
d3757 1
a3757 1
      *indexp = -1;
d3759 4
a3762 74
      skip = FALSE;
      add = 1 + isym.n_numaux;

      /* If we are skipping this csect, we want to skip this symbol.  */
      if (*csectpp == NULL)
	skip = TRUE;

      /* If we garbage collected this csect, we want to skip this
	 symbol.  */
      if (! skip
	  && xcoff_hash_table (finfo->info)->gc
	  && !bfd_is_abs_section (*csectpp)
	  && !bfd_is_und_section (*csectpp)
	  && ((*csectpp)->flags & SEC_MARK) == 0)
	skip = TRUE;

      /* An XCOFF linker always skips C_STAT symbols.  */
      if (! skip
	  && isymp->n_sclass == C_STAT)
	skip = TRUE;

      /* We generate the TOC anchor separately.  */
      if (! skip
	  && isymp->n_sclass == C_HIDEXT
	  && aux.x_csect.x_smclas == XMC_TC0)
	skip = TRUE;

      /* If we are stripping all symbols, we want to skip this one.  */
      if (! skip
	  && finfo->info->strip == strip_all)
	skip = TRUE;

      /* We can skip resolved external references.  */
      if (! skip
	  && isym.n_sclass == C_EXT
	  && smtyp == XTY_ER
	  && (*sym_hash)->root.type != bfd_link_hash_undefined)
	skip = TRUE;

      /* We can skip common symbols if they got defined somewhere
	 else.  */
      if (! skip
	  && isym.n_sclass == C_EXT
	  && smtyp == XTY_CM
	  && ((*sym_hash)->root.type != bfd_link_hash_common
	      || (*sym_hash)->root.u.c.p->section != *csectpp)
	  && ((*sym_hash)->root.type != bfd_link_hash_defined
	      || (*sym_hash)->root.u.def.section != *csectpp))
	skip = TRUE;

      /* Skip local symbols if we are discarding them.  */
      if (! skip
	  && finfo->info->discard == discard_all
	  && isym.n_sclass != C_EXT
	  && (isym.n_sclass != C_HIDEXT
	      || smtyp != XTY_SD))
	skip = TRUE;

      /* If we stripping debugging symbols, and this is a debugging
	 symbol, then skip it.  */
      if (! skip
	  && finfo->info->strip == strip_debugger
	  && isym.n_scnum == N_DEBUG)
	skip = TRUE;

      /* If some symbols are stripped based on the name, work out the
	 name and decide whether to skip this symbol.  We don't handle
	 this correctly for symbols whose names are in the .debug
	 section; to get it right we would need a new bfd_strtab_hash
	 function to return the string given the index.  */
      if (! skip
	  && (finfo->info->strip == strip_some
	      || finfo->info->discard == discard_l)
	  && (debug_index == NULL || *debug_index == (unsigned long) -1))
d3764 2
a3765 2
	  const char *name;
	  char buf[SYMNMLEN + 1];
d3767 5
a3771 1
	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
d3773 11
a3783 2
	  if (name == NULL)
	    return FALSE;
d3785 1
a3785 9
	  if ((finfo->info->strip == strip_some
	       && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
				    FALSE) == NULL))
	      || (finfo->info->discard == discard_l
		  && (isym.n_sclass != C_EXT
		      && (isym.n_sclass != C_HIDEXT
			  || smtyp != XTY_SD))
		  && bfd_is_local_label_name (input_bfd, name)))
	    skip = TRUE;
d3788 30
a3817 2
      /* We now know whether we are to skip this symbol or not.  */
      if (! skip)
d3819 3
d3823 1
a3823 1

d3830 1
a3830 1
	      if (debug_index != NULL && *debug_index != (unsigned long) -1)
a3847 11
	  if (isym.n_sclass != C_BSTAT
	      && isym.n_sclass != C_ESTAT
	      && isym.n_sclass != C_DECL
	      && isym.n_scnum > 0)
	    {
	      isym.n_scnum = (*csectpp)->output_section->target_index;
	      isym.n_value += ((*csectpp)->output_section->vma
			       + (*csectpp)->output_offset
			       - (*csectpp)->vma);
	    }

d3856 1
a3856 1
		  && finfo->last_file.n_value != (bfd_vma) output_index)
d3859 1
a3859 1
		  finfo->last_file.n_value = output_index;
d3890 1
a3890 1
	      finfo->last_file_index = output_index;
d3903 3
a3905 25

	  /* Output the symbol.  */

	  bfd_coff_swap_sym_out (output_bfd, (void *) &isym, (void *) outsym);

	  *indexp = output_index;

	  if (isym.n_sclass == C_EXT)
	    {
	      long indx;
	      struct xcoff_link_hash_entry *h;

	      indx = ((esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
		      / isymesz);
	      h = obj_xcoff_sym_hashes (input_bfd)[indx];
	      BFD_ASSERT (h != NULL);
	      h->indx = output_index;
	    }

	  /* If this is a symbol in the TOC which we may have merged
	     (class XMC_TC), remember the symbol index of the TOC
	     symbol.  */
	  if (isym.n_sclass == C_HIDEXT
	      && aux.x_csect.x_smclas == XMC_TC
	      && *sym_hash != NULL)
a3906 47
	      BFD_ASSERT (((*sym_hash)->flags & XCOFF_SET_TOC) == 0);
	      BFD_ASSERT ((*sym_hash)->toc_section != NULL);
	      (*sym_hash)->u.toc_indx = output_index;
	    }

	  output_index += add;
	  outsym += add * osymesz;
	}

      esym += add * isymesz;
      isymp += add;
      csectpp += add;
      sym_hash += add;
      if (debug_index != NULL)
	debug_index += add;
      ++indexp;
      for (--add; add > 0; --add)
	*indexp++ = -1;
    }

  /* Fix up the aux entries and the C_BSTAT symbols.  This must be
     done in a separate pass, because we don't know the correct symbol
     indices until we have already decided which symbols we are going
     to keep.  */

  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
  isymp = finfo->internal_syms;
  indexp = finfo->sym_indices;
  csectpp = xcoff_data (input_bfd)->csects;
  outsym = finfo->outsyms;
  while (esym < esym_end)
    {
      int add;

      add = 1 + isymp->n_numaux;

      if (*indexp < 0)
	esym += add * isymesz;
      else
	{
	  int i;

	  if (isymp->n_sclass == C_BSTAT)
	    {
	      struct internal_syment isym;

a3908 3
	      /* The value of a C_BSTAT symbol is the symbol table
		 index of the containing csect.  */
	      bfd_coff_swap_sym_in (output_bfd, (void *) outsym, (void *) &isym);
a3918 2
		  bfd_coff_swap_sym_out (output_bfd, (void *) &isym,
					 (void *) outsym);
d3921 12
d4207 1
@


1.51
log
@bfd/
	* libcoff-in.h (xcoff_section_tdata): Update commentary.
	* libcoff.h: Regenerate.
	* xcofflink.c (xcoff_link_add_symbols): Set the csect of XTY_ER
	symbols to bfd_und_section_ptr or bfd_abs_section_ptr, rather than
	the previous symbol's csect.  Treat last_symndx as an inclusive value
	and simplify its handling.
	(xcoff_mark): Treat last_symndx as an inclusive value.  Only mark
	symbols with the right csect.  Don't mark rsec when processing
	relocations against undefined or absolute sections.
	(bfd_xcoff_size_dynamic_sections): Don't check the SEC_MARK flag
	of bfd_und_section_ptr.
	(xcoff_link_input_bfd): Likewise.
@
text
@d2334 5
a2597 1
		  || o == xcoff_hash_table (info)->toc_section
d3133 6
a3138 1
	      if ((o->flags & SEC_MARK) == 0)
a3515 1
      bfd_boolean require;
a3633 1
      require = FALSE;
d3654 1
a3654 1
      /* We skip all but the first TOC anchor.  */
d3658 1
a3658 65
	{
	  if (finfo->toc_symindx != -1)
	    skip = TRUE;
	  else
	    {
	      bfd_vma tocval, tocend;
	      bfd *inp;

	      tocval = ((*csectpp)->output_section->vma
			+ (*csectpp)->output_offset
			+ isym.n_value
			- (*csectpp)->vma);

	      /* We want to find out if tocval is a good value to use
		 as the TOC anchor--that is, whether we can access all
		 of the TOC using a 16 bit offset from tocval.  This
		 test assumes that the TOC comes at the end of the
		 output section, as it does in the default linker
		 script.  */
	      tocend = ((*csectpp)->output_section->vma
			+ (*csectpp)->output_section->size);
	      for (inp = finfo->info->input_bfds;
		   inp != NULL;
		   inp = inp->link_next)
		{

		  for (o = inp->sections; o != NULL; o = o->next)
		    if (strcmp (o->name, ".tocbss") == 0)
		      {
			bfd_vma new_toc_end;
			new_toc_end = (o->output_section->vma
				       + o->output_offset
				       + o->size);
			if (new_toc_end > tocend)
			  tocend = new_toc_end;
		      }

		}

	      if (tocval + 0x10000 < tocend)
		{
		  (*_bfd_error_handler)
		    (_("TOC overflow: 0x%lx > 0x10000; try -mminimal-toc when compiling"),
		     (unsigned long) (tocend - tocval));
		  bfd_set_error (bfd_error_file_too_big);
		  return FALSE;
		}

	      if (tocval + 0x8000 < tocend)
		{
		  bfd_vma tocadd;

		  tocadd = tocend - (tocval + 0x8000);
		  tocval += tocadd;
		  isym.n_value += tocadd;
		}

	      finfo->toc_symindx = output_index;
	      xcoff_data (finfo->output_bfd)->toc = tocval;
	      xcoff_data (finfo->output_bfd)->sntoc =
		(*csectpp)->output_section->target_index;
	      require = TRUE;

	    }
	}
a3726 6
      /* We can not skip the first TOC anchor.  */
      if (skip
	  && require
	  && finfo->info->strip != strip_all)
	skip = FALSE;

d4556 138
d5770 4
a5773 1
  xcoff_data (abfd)->toc = (bfd_vma) -1;
@


1.50
log
@include/coff/
	* xcoff.h (XCOFF_CALLED, XCOFF_IMPORT): Update comments.
	(XCOFF_WAS_UNDEFINED): New flag.
	(xcoff_link_hash_table): Add an "rtld" field.

bfd/
	* coff-rs6000.c (xcoff_ppc_relocate_section): Report relocations
	against undefined symbols if the symbol's XCOFF_WAS_UNDEFINED
	flag is set.  Assert that all undefined symbols are either
	imported or defined by a dynamic object.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* xcofflink.c (xcoff_link_add_symbols): Extend function-symbol
	handling to all relocations.  Only set XCOFF_CALLED for function
	symbols.
	(xcoff_find_function): New function, split out from...
	(bfd_xcoff_export_symbol) ...here.
	(xcoff_set_import_path): New function, split out from...
	(bfd_xcoff_import_symbol): ...here.  Remove assertion for old
	meaning of XCOFF_CALLED.
	(xcoff_mark_symbol): If we mark an undefined and unimported
	symbol, find some way of defining it.  If the symbol is a function
	descriptor, fill in its definition automatically.  If the symbol
	is a function, mark its descriptor and allocate room for global
	linkage code.  Otherwise mark the symbol as implicitly imported.
	Move the code for creating function descriptors from...
	(xcoff_build_ldsyms): ...here.  Use XCOFF_WAS_UNDEFINED to
	check for symbols that were implicitly defined.
	(xcoff_mark): Don't count any dynamic relocations against
	function symbols.
	(bfd_xcoff_size_dynamic_sections): Save the rtld parameter
	in the xcoff link info.
	(xcoff_link_input_bfd): Remove handling of undefined and
	unexported symbols.

ld/
	* emultempl/aix.em (gld${EMULATION_NAME}_handle_option): Make
	-berok and -bernotok control link_info.unresolved_syms_in_objects
	and link_info.unresolved_syms_in_shared_libs instead of
	force_make_executable.

ld/testsuite/
	* ld-powerpc/aix-glink-1.ex, ld-powerpc/aix-glink-1.s,
	ld-powerpc/aix-glink-1-32.dd, ld-powerpc/aix-glink-1-64.dd,
	ld-powerpc/aix-glink-1-32.d, ld-powerpc/aix-glink-1-64.d: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d1095 3
a1097 11
	     Advance esym, sym_hash, csect_hash ptr's
	     Keep track of the last_symndx for the current file.  */
	  if (sym.n_sclass == C_FILE && csect != NULL)
	    {
	      xcoff_section_data (abfd, csect)->last_symndx =
		((esym
		  - (bfd_byte *) obj_coff_external_syms (abfd))
		 / symesz);
	      csect = NULL;
	    }

a1247 7
	  /* This is a csect definition.  */
	  if (csect != NULL)
	    {
	      xcoff_section_data (abfd, csect)->last_symndx =
		((esym - (bfd_byte *) obj_coff_external_syms (abfd)) / symesz);
	    }

a1528 8
	  if (csect != NULL)
	    {
	      xcoff_section_data (abfd, csect)->last_symndx =
		((esym
		  - (bfd_byte *) obj_coff_external_syms (abfd))
		 / symesz);
	    }

d1785 9
a1793 1
      *csect_cache = csect;
d2460 1
a2460 1
      struct xcoff_link_hash_entry **hp, **hpend;
d2462 2
d2466 12
a2477 16
      hp = (obj_xcoff_sym_hashes (sec->owner)
	    + xcoff_section_data (sec->owner, sec)->first_symndx);
      hpend = (obj_xcoff_sym_hashes (sec->owner)
	       + xcoff_section_data (sec->owner, sec)->last_symndx);
      for (; hp < hpend; hp++)
	{
	  struct xcoff_link_hash_entry *h;

	  h = *hp;
	  if (h != NULL
	      && (h->flags & XCOFF_MARK) == 0)
	    {
	      if (! xcoff_mark_symbol (info, h))
		return FALSE;
	    }
	}
d2507 2
d3346 3
a3348 2
		      || ((*csectpp)->flags & SEC_MARK) != 0
		      || *csectpp == bfd_abs_section_ptr)
d3637 3
a3639 2
	  && ((*csectpp)->flags & SEC_MARK) == 0
	  && *csectpp != bfd_abs_section_ptr)
@


1.49
log
@bfd/
	* xcofflink.c (xcoff_mark, xcoff_link_input_bfd): Don't copy
	R_POS and R_NEG relocations against absolute symbols to the
	.loader section.

ld/testsuite/
	* ld-powerpc/aix-abs-reloc-1.ex, ld-powerpc/aix-abs-reloc-1.im,
	ld-powerpc/aix-abs-reloc-1.od, ld-powerpc/aix-abs-reloc-1.s: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d1848 3
a1850 3
	      /* We identify all symbols which are called, so that we
		 can create glue code for calls to functions imported
		 from dynamic objects.  */
a1852 2
		  && (rel->r_type == R_BR
		      || rel->r_type == R_RBR)
a1857 1
		  h->flags |= XCOFF_CALLED;
d1890 1
a1890 2
		      BFD_ASSERT ((hds->flags & XCOFF_CALLED) == 0
				  && (h->flags & XCOFF_DESCRIPTOR) == 0);
d1894 2
d2204 88
d2302 130
d2539 3
a2541 9
		      || ((h->flags & XCOFF_CALLED) != 0
			  && (h->root.type == bfd_link_hash_undefined
			      || h->root.type == bfd_link_hash_undefweak)
			  && h->root.root.string[0] == '.'
			  && h->descriptor != NULL
			  && ((h->descriptor->flags & XCOFF_DEF_DYNAMIC) != 0
			      || ((h->descriptor->flags & XCOFF_IMPORT) != 0
				  && (h->descriptor->flags
				      & XCOFF_DEF_REGULAR) == 0))))
d2696 1
a2696 2
	  BFD_ASSERT ((hds->flags & XCOFF_CALLED) == 0
		      && (h->flags & XCOFF_DESCRIPTOR) == 0);
d2728 2
a2729 40
  /* We overload the ldindx field to hold the l_ifile value for this
     symbol.  */
  BFD_ASSERT (h->ldsym == NULL);
  BFD_ASSERT ((h->flags & XCOFF_BUILT_LDSYM) == 0);
  if (imppath == NULL)
    h->ldindx = -1;
  else
    {
      unsigned int c;
      struct xcoff_import_file **pp;

      /* We start c at 1 because the first entry in the import list is
	 reserved for the library search path.  */
      for (pp = &xcoff_hash_table (info)->imports, c = 1;
	   *pp != NULL;
	   pp = &(*pp)->next, ++c)
	{
	  if (strcmp ((*pp)->path, imppath) == 0
	      && strcmp ((*pp)->file, impfile) == 0
	      && strcmp ((*pp)->member, impmember) == 0)
	    break;
	}

      if (*pp == NULL)
	{
	  struct xcoff_import_file *n;
	  bfd_size_type amt = sizeof (* n);

	  n = bfd_alloc (output_bfd, amt);
	  if (n == NULL)
	    return FALSE;
	  n->next = NULL;
	  n->path = imppath;
	  n->file = impfile;
	  n->member = impmember;
	  *pp = n;
	}

      h->ldindx = c;
    }
a2750 28
  /* See if this is a function descriptor.  It may be one even though
     it is not so marked.  */
  if ((h->flags & XCOFF_DESCRIPTOR) == 0
      && h->root.root.string[0] != '.')
    {
      char *fnname;
      struct xcoff_link_hash_entry *hfn;
      bfd_size_type amt = strlen (h->root.root.string) + 2;

      fnname = bfd_malloc (amt);
      if (fnname == NULL)
	return FALSE;
      fnname[0] = '.';
      strcpy (fnname + 1, h->root.root.string);
      hfn = xcoff_link_hash_lookup (xcoff_hash_table (info),
				    fnname, FALSE, FALSE, TRUE);
      free (fnname);
      if (hfn != NULL
	  && hfn->smclas == XMC_PR
	  && (hfn->root.type == bfd_link_hash_defined
	      || hfn->root.type == bfd_link_hash_defweak))
	{
	  h->flags |= XCOFF_DESCRIPTOR;
	  h->descriptor = hfn;
	  hfn->descriptor = h;
	}
    }

a2912 61
  /* If this symbol is called and defined in a dynamic object, or it
     is imported, then we need to set up global linkage code for it.
     (Unless we did garbage collection and we didn't need this
     symbol.)  */
  if ((h->flags & XCOFF_CALLED) != 0
      && (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
      && h->root.root.string[0] == '.'
      && h->descriptor != NULL
      && ((h->descriptor->flags & XCOFF_DEF_DYNAMIC) != 0
	  || ((h->descriptor->flags & XCOFF_IMPORT) != 0
	      && (h->descriptor->flags & XCOFF_DEF_REGULAR) == 0))
      && (! xcoff_hash_table (ldinfo->info)->gc
	  || (h->flags & XCOFF_MARK) != 0))
    {
      asection *sec;
      struct xcoff_link_hash_entry *hds;

      sec = xcoff_hash_table (ldinfo->info)->linkage_section;
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = sec;
      h->root.u.def.value = sec->size;
      h->smclas = XMC_GL;
      h->flags |= XCOFF_DEF_REGULAR;
      sec->size += bfd_xcoff_glink_code_size(ldinfo->output_bfd);

      /* The global linkage code requires a TOC entry for the
	 descriptor.  */
      hds = h->descriptor;
      BFD_ASSERT ((hds->root.type == bfd_link_hash_undefined
		   || hds->root.type == bfd_link_hash_undefweak)
		  && (hds->flags & XCOFF_DEF_REGULAR) == 0);
      hds->flags |= XCOFF_MARK;
      if (hds->toc_section == NULL)
	{
	  int byte_size;

	  /* 32 vs 64
	     xcoff32 uses 4 bytes in the toc.
	     xcoff64 uses 8 bytes in the toc.  */
	  if (bfd_xcoff_is_xcoff64 (ldinfo->output_bfd))
	    byte_size = 8;
	  else if (bfd_xcoff_is_xcoff32 (ldinfo->output_bfd))
	    byte_size = 4;
	  else
	    return FALSE;

	  hds->toc_section = xcoff_hash_table (ldinfo->info)->toc_section;
	  hds->u.toc_offset = hds->toc_section->size;
	  hds->toc_section->size += byte_size;
	  ++xcoff_hash_table (ldinfo->info)->ldrel_count;
	  ++hds->toc_section->reloc_count;
	  hds->indx = -2;
	  hds->flags |= XCOFF_SET_TOC | XCOFF_LDREL;

	  /* We need to call xcoff_build_ldsyms recursively here,
	     because we may already have passed hds on the traversal.  */
	  xcoff_build_ldsyms (hds, p);
	}
    }

d2916 1
a2916 5
      && (h->flags & XCOFF_IMPORT) == 0
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->flags & XCOFF_DEF_DYNAMIC) == 0
      && (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak))
d2918 5
a2922 39
      if ((h->flags & XCOFF_DESCRIPTOR) != 0
	  && (h->descriptor->root.type == bfd_link_hash_defined
	      || h->descriptor->root.type == bfd_link_hash_defweak))
	{
	  asection *sec;

	  /* This is an undefined function descriptor associated with
	     a defined entry point.  We can build up a function
	     descriptor ourselves.  Believe it or not, the AIX linker
	     actually does this, and there are cases where we need to
	     do it as well.  */
	  sec = xcoff_hash_table (ldinfo->info)->descriptor_section;
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = sec;
	  h->root.u.def.value = sec->size;
	  h->smclas = XMC_DS;
	  h->flags |= XCOFF_DEF_REGULAR;

	  /* The size of the function descriptor depends if this is an
	     xcoff32 (12) or xcoff64 (24).  */
	  sec->size +=
	    bfd_xcoff_function_descriptor_size(ldinfo->output_bfd);

	  /* A function descriptor uses two relocs: one for the
	     associated code, and one for the TOC address.  */
	  xcoff_hash_table (ldinfo->info)->ldrel_count += 2;
	  sec->reloc_count += 2;

	  /* We handle writing out the contents of the descriptor in
	     xcoff_write_global_symbol.  */
	}
      else
	{
	  (*_bfd_error_handler)
	    (_("warning: attempt to export undefined symbol `%s'"),
	     h->root.root.string);
	  h->ldsym = NULL;
	  return TRUE;
	}
d3064 1
a4365 1
	      bfd_boolean quiet;
a4497 1
	      quiet = FALSE;
d4553 1
a4553 11
		      if (! finfo->info->relocatable
			  && (h->flags & XCOFF_DEF_DYNAMIC) == 0
			  && (h->flags & XCOFF_IMPORT) == 0)
			{
			  /* We already called the undefined_symbol
			     callback for this relocation, in
			     _bfd_ppc_xcoff_relocate_section.  Don't
			     issue any more warnings.  */
			  quiet = TRUE;
			}
		      if (h->ldindx < 0 && ! quiet)
d4567 1
a4567 2
		      && strcmp (o->output_section->name, ".text") == 0
		      && ! quiet)
@


1.48
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d2338 5
d4468 5
@


1.47
log
@Switch sources over to use the GPL version 3
@
text
@d3 1
a3 1
   2005, 2006, 2007 Free Software Foundation, Inc.
d563 1
a563 1
   if (info->hash->creator != abfd->xvec)
d789 1
a789 1
  if (info->hash->creator == abfd->xvec)
d1297 1
a1297 1
	      && info->hash->creator == abfd->xvec
d1667 1
a1667 1
 	  if (info->hash->creator == abfd->xvec)
d1792 1
a1792 1
 	  if (info->hash->creator == abfd->xvec)
d1851 1
a1851 1
 	      if (info->hash->creator == abfd->xvec
d2069 1
a2069 1
      && info->hash->creator == abfd->xvec)
d2102 1
a2102 1
 	      && (info->hash->creator != abfd->xvec
d2183 1
a2183 1
		&& (info->hash->creator == member->xvec)
d2255 1
a2255 1
  if (sec->owner->xvec == info->hash->creator
d2389 1
a2389 1
	      if (sub->xvec != info->hash->creator
d2762 1
a2762 1
	      != ldinfo->info->hash->creator)))
d3260 1
a3260 1
      if (sub->xvec != info->hash->creator)
@


1.46
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.45
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d3 1
a3 1
   2005, 2006 Free Software Foundation, Inc.
d22 1
a23 1
#include "sysdep.h"
@


1.44
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d797 1
d799 1
a799 1
	  lsec = bfd_make_section_anyway (abfd, ".loader");
a803 1
	  lsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d810 2
d813 1
a813 1
	  lsec = bfd_make_section_anyway (abfd, ".gl");
a817 2
	  lsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
d825 2
d828 1
a828 1
	  tsec = bfd_make_section_anyway (abfd, ".tc");
a832 2
	  tsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
d840 2
d843 1
a843 1
	  dsec = bfd_make_section_anyway (abfd, ".ds");
a847 2
	  dsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
d856 1
d858 1
a858 1
	  dsec = bfd_make_section_anyway (abfd, ".debug");
a862 1
	  dsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d1555 2
a1556 1
	      csect = bfd_make_section_anyway (abfd, ".td");
d1559 2
a1560 1
	    csect = bfd_make_section_anyway (abfd, ".bss");
a1565 1
	  csect->flags |= SEC_ALLOC;
d5464 2
a5465 2
		      n = bfd_make_section_anyway (abfd, ".pad");
		      n->flags = SEC_HAS_CONTENTS;
@


1.43
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d447 2
a448 1
  if (! _bfd_link_hash_table_init (&ret->root, abfd, xcoff_link_hash_newfunc))
@


1.42
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.41
log
@Update the FSF address in the copyright/GPL notice
@
text
@d5383 1
a5383 1
      for (p = o->link_order_head; p != NULL; p = p->next)
d5672 1
a5672 1
      for (p = o->link_order_head; p != NULL; p = p->next)
@


1.40
log
@	* section.c (bfd_section_list_remove): Don't clear s->next.
	(bfd_section_list_append): Always init s->prev.
	(bfd_section_list_prepend): Define.
	(bfd_section_list_insert_after): Minor optimization.
	(bfd_section_removed_from_list): Rewrite.
	* elf.c (assign_section_numbers): Simplify list traversal now that
	bfd_section_list_remove doesn't destroy removed section next ptr.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Use bfd_section_list_prepend.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Simplify list traversal.
	* bfd-in2.h: Regenerate.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.39
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@a5438 1
	  asection **op;
d5445 1
a5445 1
	  for (op = &abfd->sections; *op != NULL; op = &(*op)->next)
d5447 1
a5447 1
	      if (strcmp ((*op)->name, ".pad") == 0)
d5449 2
a5450 2
	      else if (((*op)->flags & SEC_HAS_CONTENTS) != 0
		       && ((*op)->flags & SEC_LOAD) != 0)
d5467 1
a5467 3
		      bfd_section_list_insert_before (abfd, *op, n);

		      op = &n->next;
@


1.38
log
@Convert to ISO C90 formatting
@
text
@d5457 1
a5457 1
		      asection *n, **st;
a5462 1
		      st = abfd->section_tail;
d5467 2
a5468 3
		      BFD_ASSERT (*st == n);
		      bfd_section_list_remove (abfd, st);
		      bfd_section_list_insert (abfd, op, n);
@


1.37
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d33 2
a34 1
#define STRING_SIZE_SIZE (4)
d69 2
a70 1
  struct xcoff_toc_rel_hash {
d118 2
a119 34
static struct bfd_hash_entry *xcoff_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static bfd_boolean xcoff_get_section_contents PARAMS ((bfd *, asection *));
static struct internal_reloc *xcoff_read_internal_relocs
  PARAMS ((bfd *, asection *, bfd_boolean, bfd_byte *, bfd_boolean,
	   struct internal_reloc *));
static bfd_boolean xcoff_link_add_object_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean xcoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_dynamic_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_size_type xcoff_find_reloc
  PARAMS ((struct internal_reloc *, bfd_size_type, bfd_vma));
static bfd_boolean xcoff_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean xcoff_link_add_dynamic_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean xcoff_mark_symbol
  PARAMS ((struct bfd_link_info *, struct xcoff_link_hash_entry *));
static bfd_boolean xcoff_mark PARAMS ((struct bfd_link_info *, asection *));
static void xcoff_sweep PARAMS ((struct bfd_link_info *));
static bfd_boolean xcoff_build_ldsyms
  PARAMS ((struct xcoff_link_hash_entry *, PTR));
static bfd_boolean xcoff_link_input_bfd
  PARAMS ((struct xcoff_final_link_info *, bfd *));
static bfd_boolean xcoff_write_global_symbol
  PARAMS ((struct xcoff_link_hash_entry *, PTR));
static bfd_boolean xcoff_reloc_link_order
  PARAMS ((bfd *, struct xcoff_final_link_info *, asection *,
	   struct bfd_link_order *));
static int xcoff_sort_relocs PARAMS ((const PTR, const PTR));
d129 1
a129 3
xcoff_get_section_contents (abfd, sec)
     bfd *abfd;
     asection *sec;
a130 1

d134 1
d143 2
a144 1
      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
d159 1
a159 2
_bfd_xcoff_get_dynamic_symtab_upper_bound (abfd)
     bfd *abfd;
d182 1
a182 1
  bfd_xcoff_swap_ldhdr_in (abfd, (PTR) contents, &ldhdr);
d190 1
a190 3
_bfd_xcoff_canonicalize_dynamic_symtab (abfd, psyms)
     bfd *abfd;
     asymbol **psyms;
d222 1
a222 2
  symbuf = ((coff_symbol_type *)
	    bfd_zalloc (abfd, ldhdr.l_nsyms * sizeof (coff_symbol_type)));
a263 1

d275 1
a275 2
_bfd_xcoff_get_dynamic_reloc_upper_bound (abfd)
     bfd *abfd;
d306 3
a308 4
_bfd_xcoff_canonicalize_dynamic_reloc (abfd, prelocs, syms)
     bfd *abfd;
     arelent **prelocs;
     asymbol **syms;
d335 1
a335 1
  relbuf = (arelent *) bfd_alloc (abfd, ldhdr.l_nreloc * sizeof (arelent));
d403 3
a405 4
xcoff_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d411 4
a414 5
  if (ret == (struct xcoff_link_hash_entry *) NULL)
    ret = ((struct xcoff_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct xcoff_link_hash_entry)));
  if (ret == (struct xcoff_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d439 1
a439 2
_bfd_xcoff_bfd_link_hash_table_create (abfd)
     bfd *abfd;
d442 1
a442 1
  bfd_size_type amt = sizeof (struct xcoff_link_hash_table);
d444 3
a446 3
  ret = (struct xcoff_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct xcoff_link_hash_table *) NULL)
    return (struct bfd_link_hash_table *) NULL;
d450 1
a450 1
      return (struct bfd_link_hash_table *) NULL;
d478 1
a478 2
_bfd_xcoff_bfd_link_hash_table_free (hash)
     struct bfd_link_hash_table *hash;
d492 6
a497 8
xcoff_read_internal_relocs (abfd, sec, cache, external_relocs,
			    require_internal, internal_relocs)
     bfd *abfd;
     asection *sec;
     bfd_boolean cache;
     bfd_byte *external_relocs;
     bfd_boolean require_internal;
     struct internal_reloc *internal_relocs;
a498 1

d514 1
a514 2
					      external_relocs, FALSE,
					      (struct internal_reloc *) NULL)
d541 2
a542 183
/* Given an XCOFF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
_bfd_xcoff_bfd_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{

  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return xcoff_link_add_object_symbols (abfd, info);

    case bfd_archive:
      /* If the archive has a map, do the usual search.  We then need
	 to check the archive for dynamic objects, because they may not
	 appear in the archive map even though they should, perhaps, be
	 included.  If the archive has no map, we just consider each object
	 file in turn, since that apparently is what the AIX native linker
	 does.  */
      if (bfd_has_map (abfd))
	{
	  if (! (_bfd_generic_link_add_archive_symbols
		 (abfd, info, xcoff_link_check_archive_element)))
	    return FALSE;
	}

      {
	bfd *member;

	member = bfd_openr_next_archived_file (abfd, (bfd *) NULL);
	while (member != NULL)
	  {
	    if (bfd_check_format (member, bfd_object)
		&& (info->hash->creator == member->xvec)
		&& (! bfd_has_map (abfd) || (member->flags & DYNAMIC) != 0))
	      {
		bfd_boolean needed;

		if (! xcoff_link_check_archive_element (member, info,
							&needed))
		  return FALSE;
		if (needed)
		  member->archive_pass = -1;
	      }
	    member = bfd_openr_next_archived_file (abfd, member);
	  }
      }

      return TRUE;

    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

/* Add symbols from an XCOFF object file.  */

static bfd_boolean
xcoff_link_add_object_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{

  if (! _bfd_coff_get_external_symbols (abfd))
    return FALSE;
  if (! xcoff_link_add_symbols (abfd, info))
    return FALSE;
  if (! info->keep_memory)
    {
      if (! _bfd_coff_free_symbols (abfd))
	return FALSE;
    }
  return TRUE;
}

/* Check a single archive element to see if we need to include it in
   the link.  *PNEEDED is set according to whether this element is
   needed in the link or not.  This is called via
   _bfd_generic_link_add_archive_symbols.  */

static bfd_boolean
xcoff_link_check_archive_element (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
{

  if (! _bfd_coff_get_external_symbols (abfd))
    return FALSE;

  if (! xcoff_link_check_ar_symbols (abfd, info, pneeded))
    return FALSE;

  if (*pneeded)
    {
      if (! xcoff_link_add_symbols (abfd, info))
	return FALSE;
    }

  if (! info->keep_memory || ! *pneeded)
    {
      if (! _bfd_coff_free_symbols (abfd))
	return FALSE;
    }

  return TRUE;
}

/* Look through the symbols to see if this object file should be
   included in the link.  */

static bfd_boolean
xcoff_link_check_ar_symbols (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
{
  bfd_size_type symesz;
  bfd_byte *esym;
  bfd_byte *esym_end;

  *pneeded = FALSE;

  if ((abfd->flags & DYNAMIC) != 0
      && ! info->static_link
      && info->hash->creator == abfd->xvec)
    return xcoff_link_check_dynamic_ar_symbols (abfd, info, pneeded);

  symesz = bfd_coff_symesz (abfd);
  esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esym_end = esym + obj_raw_syment_count (abfd) * symesz;
  while (esym < esym_end)
    {
      struct internal_syment sym;

      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &sym);

      if (sym.n_sclass == C_EXT && sym.n_scnum != N_UNDEF)
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];
	  struct bfd_link_hash_entry *h;

	  /* This symbol is externally visible, and is defined by this
	     object file.  */

	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);

	  if (name == NULL)
	    return FALSE;
	  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

	  /* We are only interested in symbols that are currently
	     undefined.  If a symbol is currently known to be common,
	     XCOFF linkers do not bring in an object file which
	     defines it.  We also don't bring in symbols to satisfy
	     undefined references in shared objects.  */
	  if (h != (struct bfd_link_hash_entry *) NULL
	      && h->type == bfd_link_hash_undefined
 	      && (info->hash->creator != abfd->xvec
		  || (((struct xcoff_link_hash_entry *) h)->flags
		      & XCOFF_DEF_DYNAMIC) == 0))
	    {
	      if (! (*info->callbacks->add_archive_element) (info, abfd, name))
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
	    }
	}

      esym += (sym.n_numaux + 1) * symesz;
    }

  /* We do not need this object file.  */
  return TRUE;
}

/* Look through the loader symbols to see if this dynamic object
   should be included in the link.  The native linker uses the loader
   symbols, not the normal symbol table, so we do too.  */
d545 1
a545 4
xcoff_link_check_dynamic_ar_symbols (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
d552 17
d570 7
a576 1
  *pneeded = FALSE;
d578 3
d584 5
a588 2
      /* There are no symbols, so don't try to include it.  */
      return TRUE;
d595 4
d606 1
d612 1
a612 1
      struct bfd_link_hash_entry *h;
d629 3
a631 4
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

      /* We are only interested in symbols that are currently
	 undefined.  At this point we know that we are using an XCOFF
a632 11
      if (h != NULL
	  && h->type == bfd_link_hash_undefined
	  && (((struct xcoff_link_hash_entry *) h)->flags
	      & XCOFF_DEF_DYNAMIC) == 0)
	{
	  if (! (*info->callbacks->add_archive_element) (info, abfd, name))
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
	}
    }
d634 4
a637 1
  /* We do not need this shared object.  */
d639 1
a639 5
  if (contents != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
    {
      free (coff_section_data (abfd, lsec)->contents);
      coff_section_data (abfd, lsec)->contents = NULL;
    }
d641 8
a648 2
  return TRUE;
}
d650 67
a716 2
/* Returns the index of reloc in RELOCS with the least address greater
   than or equal to ADDRESS.  The relocs are sorted by address.  */
d718 14
a731 7
static bfd_size_type
xcoff_find_reloc (relocs, count, address)
     struct internal_reloc *relocs;
     bfd_size_type count;
     bfd_vma address;
{
  bfd_size_type min, max, this;
d733 1
a733 1
  if (count < 2)
d735 2
a736 4
      if (count == 1 && relocs[0].r_vaddr < address)
	return 1;
      else
	return 0;
d739 5
a743 2
  min = 0;
  max = count;
d745 10
a754 2
  /* Do a binary search over (min,max].  */
  while (min + 1 < max)
d756 2
a757 13
      bfd_vma raddr;

      this = (max + min) / 2;
      raddr = relocs[this].r_vaddr;
      if (raddr > address)
	max = this;
      else if (raddr < address)
	min = this;
      else
	{
	  min = this;
	  break;
	}
d759 5
d765 7
a771 2
  if (relocs[min].r_vaddr < address)
    return min + 1;
d773 1
a773 3
  while (min > 0
	 && relocs[min - 1].r_vaddr == address)
    --min;
d775 1
a775 1
  return min;
a777 1

d783 1
a783 1
xcoff_link_create_extra_sections(bfd * abfd, struct bfd_link_info *info)
a784 1

a788 1

d799 2
a800 3
	    {
	      goto end_return;
	    }
d812 1
a812 3
	    {
	      goto end_return;
	    }
d827 1
a827 3
	    {
	      goto end_return;
	    }
d842 1
a842 3
	    {
	      goto end_return;
	    }
d858 2
a859 3
	    {
	      goto end_return;
	    }
d872 49
d940 1
a940 3
xcoff_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d975 1
a975 1
  /* create the loader, toc, gl, ds and debug sections, if needed */
d1000 1
a1000 1
  sym_hash = (struct xcoff_link_hash_entry **) bfd_zalloc (abfd, amt);
d1009 1
a1009 1
  csect_cache = (asection **) bfd_zalloc (abfd, amt);
d1021 1
a1021 1
  reloc_info = (struct reloc_info_struct *) bfd_zmalloc (amt);
d1030 1
a1031 1
      last_real = o;
a1033 1

d1035 1
a1035 2
	    xcoff_read_internal_relocs (abfd, o, TRUE, (bfd_byte *) NULL,
					FALSE, (struct internal_reloc *) NULL);
d1038 1
a1038 1
	  reloc_info[o->target_index].csects = (asection **) bfd_zmalloc (amt);
a1045 1

d1049 1
a1049 1
	  linenos = (bfd_byte *) bfd_malloc (amt);
a1055 1

d1083 1
a1083 1
      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &sym);
a1088 1

a1132 1

d1135 1
a1135 1
	  bfd_coff_swap_aux_in (abfd, (PTR) (esym + symesz),
d1137 1
a1137 1
				0, sym.n_numaux, (PTR) &auxlin);
d1155 1
a1155 1
	      /* explicit cast to bfd_signed_vma for compiler */
d1163 1
a1163 1
		  bfd_coff_swap_lineno_in (abfd, (PTR) linpstart, (PTR) &lin);
d1178 2
a1179 2
			  bfd_coff_swap_lineno_in (abfd, (PTR) linp,
						   (PTR) &lin);
a1196 1

d1207 1
a1207 1
			    (PTR) (esym + symesz * sym.n_numaux),
d1210 1
a1210 1
			    (PTR) &aux);
d1331 1
a1331 1
		  bfd_coff_swap_sym_in (abfd, (PTR) erelsym, (PTR) &relsym);
a1340 1

a1350 1

d1389 4
a1392 4
			} /* merge toc reloc */
		    } /* c_ext */
		} /* reloc */
	    } /* merge toc */
a1394 1

d1403 1
a1403 3
	      {
		goto error_return;
	      }
d1433 1
a1433 1
	    csect->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
a1554 1

d1557 2
a1558 3
	    {
	      csect = bfd_make_section_anyway (abfd, ".bss");
	    }
d1573 1
a1573 1
	  csect->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
a1600 1

d1617 1
a1617 3
	    {
	      i = XCOFF_SPECIAL_SECTION_END2;
	    }
d1620 1
a1620 3
	    {
	      xcoff_hash_table (info)->special_sections[i] = csect;
	    }
d1667 2
a1668 4
		{
		  *sym_hash = xcoff_link_hash_lookup (xcoff_hash_table (info),
						      name, TRUE, copy, FALSE);
		}
d1670 6
a1675 8
		{
		  /* Make a copy of the symbol name to prevent problems with
		     merging symbols.  */
		  *sym_hash = ((struct xcoff_link_hash_entry *)
			       bfd_wrapped_link_hash_lookup (abfd, info, name,
							     TRUE, TRUE,
							     FALSE));
		}
d1749 1
a1749 1
			  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0,
d1773 1
a1773 1
		  (const char *) NULL, copy, TRUE,
d1782 2
a1783 4
		{
		  /* We don't need the common csect we just created.  */
		  csect->size = 0;
		}
d1785 2
a1786 4
		{
		  (*sym_hash)->root.u.c.p->alignment_power
		    = csect->alignment_power;
		}
a1835 1

d1884 1
a1884 1
				  (bfd_vma) 0, (const char *) NULL, FALSE,
d1951 1
a1951 2
/* This function is used to add symbols from a dynamic object to the
   global symbol table.  */
d1954 22
a1975 3
xcoff_link_add_dynamic_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
a1981 6
  struct xcoff_import_file *n;
  const char *bname;
  const char *mname;
  const char *s;
  unsigned int c;
  struct xcoff_import_file **pp;
d1983 1
a1983 18
  /* We can only handle a dynamic object if we are generating an XCOFF
     output file.  */
   if (info->hash->creator != abfd->xvec)
    {
      (*_bfd_error_handler)
	(_("%s: XCOFF shared object when not producing XCOFF output"),
	 bfd_get_filename (abfd));
      bfd_set_error (bfd_error_invalid_operation);
      return FALSE;
    }

  /* The symbols we use from a dynamic object are not the symbols in
     the normal symbol table, but, rather, the symbols in the export
     table.  If there is a global symbol in a dynamic object which is
     not in the export table, the loader will not be able to find it,
     so we don't want to find it either.  Also, on AIX 4.1.3, shr.o in
     libc.a has symbols in the export table which are not in the
     symbol table.  */
a1984 3
  /* Read in the .loader section.  FIXME: We should really use the
     o_snloader field in the a.out header, rather than grabbing the
     section by name.  */
d1987 2
a1988 8
    {
      (*_bfd_error_handler)
	(_("%s: dynamic object with no .loader section"),
	 bfd_get_filename (abfd));
      bfd_set_error (bfd_error_no_symbols);
      return FALSE;
    }

a1993 4
  /* Remove the sections from this object, so that they do not get
     included in the link.  */
  bfd_section_list_clear (abfd);

d1998 1
a1998 3
  elsym = contents + bfd_xcoff_loader_symbol_offset(abfd, &ldhdr);

  elsymend = elsym + ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);
d2000 2
a2001 1
  for (; elsym < elsymend; elsym += bfd_xcoff_ldsymsz(abfd))
d2006 1
a2006 1
      struct xcoff_link_hash_entry *h;
d2023 4
a2026 3
      /* Normally we could not call xcoff_link_hash_lookup in an add
	 symbols routine, since we might not be using an XCOFF hash
	 table.  However, we verified above that we are using an XCOFF
d2028 18
d2047 2
a2048 4
      h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE,
				  TRUE, TRUE);
      if (h == NULL)
	return FALSE;
d2050 2
a2051 1
      h->flags |= XCOFF_DEF_DYNAMIC;
d2053 8
a2060 8
      /* If the symbol is undefined, and the BFD it was found in is
	 not a dynamic object, change the BFD to this dynamic object,
	 so that we can get the correct import file ID.  */
      if ((h->root.type == bfd_link_hash_undefined
	   || h->root.type == bfd_link_hash_undefweak)
	  && (h->root.u.undef.abfd == NULL
	      || (h->root.u.undef.abfd->flags & DYNAMIC) == 0))
	h->root.u.undef.abfd = abfd;
d2062 1
a2062 6
      if (h->root.type == bfd_link_hash_new)
	{
	  h->root.type = bfd_link_hash_undefined;
	  h->root.u.undef.abfd = abfd;
	  /* We do not want to add this to the undefined symbol list.  */
	}
d2064 4
a2067 4
      if (h->smclas == XMC_UA
	  || h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	h->smclas = ldsym.l_smclas;
d2069 6
a2074 4
      /* Unless this is an XMC_XO symbol, we don't bother to actually
	 define it, since we don't have a section to put it in anyhow.
	 Instead, the relocation routines handle the DEF_DYNAMIC flag
	 correctly.  */
d2076 1
a2076 9
      if (h->smclas == XMC_XO
	  && (h->root.type == bfd_link_hash_undefined
	      || h->root.type == bfd_link_hash_undefweak))
	{
	  /* This symbol has an absolute value.  */
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = bfd_abs_section_ptr;
	  h->root.u.def.value = ldsym.l_value;
	}
d2078 1
a2078 6
      /* If this symbol defines a function descriptor, then it
	 implicitly defines the function code as well.  */
      if (h->smclas == XMC_DS
	  || (h->smclas == XMC_XO && name[0] != '.'))
	h->flags |= XCOFF_DESCRIPTOR;
      if ((h->flags & XCOFF_DESCRIPTOR) != 0)
d2080 3
a2082 1
	  struct xcoff_link_hash_entry *hds;
d2084 3
a2086 4
	  hds = h->descriptor;
	  if (hds == NULL)
	    {
	      char *dsnm;
d2088 3
a2090 10
	      dsnm = bfd_malloc ((bfd_size_type) strlen (name) + 2);
	      if (dsnm == NULL)
		return FALSE;
	      dsnm[0] = '.';
	      strcpy (dsnm + 1, name);
	      hds = xcoff_link_hash_lookup (xcoff_hash_table (info), dsnm,
					    TRUE, TRUE, TRUE);
	      free (dsnm);
	      if (hds == NULL)
		return FALSE;
d2092 10
a2101 22
	      if (hds->root.type == bfd_link_hash_new)
		{
		  hds->root.type = bfd_link_hash_undefined;
		  hds->root.u.undef.abfd = abfd;
		  /* We do not want to add this to the undefined
		     symbol list.  */
		}

	      hds->descriptor = h;
	      h->descriptor = hds;
	    }

	  hds->flags |= XCOFF_DEF_DYNAMIC;
	  if (hds->smclas == XMC_UA)
	    hds->smclas = XMC_PR;

	  /* An absolute symbol appears to actually define code, not a
	     function descriptor.  This is how some math functions are
	     implemented on AIX 4.1.  */
	  if (h->smclas == XMC_XO
	      && (hds->root.type == bfd_link_hash_undefined
		  || hds->root.type == bfd_link_hash_undefweak))
d2103 4
a2106 4
	      hds->smclas = XMC_XO;
	      hds->root.type = bfd_link_hash_defined;
	      hds->root.u.def.section = bfd_abs_section_ptr;
	      hds->root.u.def.value = ldsym.l_value;
d2109 2
d2113 8
a2120 5
  if (contents != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
    {
      free (coff_section_data (abfd, lsec)->contents);
      coff_section_data (abfd, lsec)->contents = NULL;
    }
d2122 7
a2128 1
  /* Record this file in the import files.  */
d2130 1
a2130 3
  n = ((struct xcoff_import_file *)
       bfd_alloc (abfd, (bfd_size_type) sizeof (struct xcoff_import_file)));
  if (n == NULL)
a2131 1
  n->next = NULL;
d2133 1
a2133 5
  /* For some reason, the path entry in the import file list for a
     shared object appears to always be empty.  The file name is the
     base name.  */
  n->path = "";
  if (abfd->my_archive == NULL)
d2135 2
a2136 2
      bname = bfd_get_filename (abfd);
      mname = "";
d2138 2
a2139 1
  else
d2141 2
a2142 2
      bname = bfd_get_filename (abfd->my_archive);
      mname = bfd_get_filename (abfd);
a2143 5
  s = strrchr (bname, '/');
  if (s != NULL)
    bname = s + 1;
  n->file = bname;
  n->member = mname;
d2145 49
a2193 7
  /* We start c at 1 because the first import file number is reserved
     for LIBPATH.  */
  for (pp = &xcoff_hash_table (info)->imports, c = 1;
       *pp != NULL;
       pp = &(*pp)->next, ++c)
    ;
  *pp = n;
d2195 1
a2195 1
  xcoff_data (abfd)->import_file_id = c;
d2197 4
a2200 1
  return TRUE;
a2202 3
/* Routines that are called after all the input files have been
   handled, but before the sections are laid out in memory.  */

d2206 2
a2207 4
static INLINE bfd_boolean
xcoff_mark_symbol (info, h)
     struct bfd_link_info *info;
     struct xcoff_link_hash_entry *h;
a2208 1

d2244 1
a2244 3
xcoff_mark (info, sec)
     struct bfd_link_info *info;
     asection *sec;
d2256 1
a2256 1
      register struct xcoff_link_hash_entry **hp, **hpend;
a2259 1

d2266 1
a2266 1
	  register struct xcoff_link_hash_entry *h;
a2277 1

d2282 1
a2282 2
					    (bfd_byte *) NULL, FALSE,
					    (struct internal_reloc *) NULL);
d2364 3
d2371 1
a2371 2
xcoff_sweep (info)
     struct bfd_link_info *info;
d2409 4
a2412 5
bfd_xcoff_link_record_set (output_bfd, info, harg, size)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct bfd_link_hash_entry *harg;
     bfd_size_type size;
d2424 2
a2425 3

  amt = sizeof (struct xcoff_link_size_list);
  n = (struct xcoff_link_size_list *) bfd_alloc (output_bfd, amt);
d2441 8
a2448 10
bfd_xcoff_import_symbol (output_bfd, info, harg, val, imppath, impfile,
			 impmember, syscall_flag)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct bfd_link_hash_entry *harg;
     bfd_vma val;
     const char *imppath;
     const char *impfile;
     const char *impmember;
     unsigned int syscall_flag;
d2537 1
a2537 1
	  bfd_size_type amt = sizeof (struct xcoff_import_file);
d2539 1
a2539 1
	  n = (struct xcoff_import_file *) bfd_alloc (output_bfd, amt);
d2558 3
a2560 4
bfd_xcoff_export_symbol (output_bfd, info, harg)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct bfd_link_hash_entry *harg;
d2581 1
a2581 1
      fnname = (char *) bfd_malloc (amt);
d2623 3
a2625 4
bfd_xcoff_link_count_reloc (output_bfd, info, name)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char *name;
d2656 3
a2658 4
bfd_xcoff_record_link_assignment (output_bfd, info, name)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char *name;
d2675 1
a2675 16
/* Build the .loader section.  This is called by the XCOFF linker
   emulation before_allocation routine.  We must set the size of the
   .loader section before the linker lays out the output file.
   LIBPATH is the library path to search for shared objects; this is
   normally built from the -L arguments passed to the linker.  ENTRY
   is the name of the entry point symbol (the -e linker option).
   FILE_ALIGN is the alignment to use for sections within the file
   (the -H linker option).  MAXSTACK is the maximum stack size (the
   -bmaxstack linker option).  MAXDATA is the maximum data size (the
   -bmaxdata linker option).  GC is whether to do garbage collection
   (the -bgc linker option).  MODTYPE is the module type (the
   -bmodtype linker option).  TEXTRO is whether the text section must
   be read only (the -btextro linker option).  EXPORT_DEFINEDS is
   whether all defined symbols should be exported (the -unix linker
   option).  SPECIAL_SECTIONS is set by this routine to csects with
   magic names like _end.  */
d2677 2
a2678 18
bfd_boolean
bfd_xcoff_size_dynamic_sections (output_bfd, info, libpath, entry,
				 file_align, maxstack, maxdata, gc,
				 modtype, textro, export_defineds,
				 special_sections, rtld)
     bfd *output_bfd;
     struct bfd_link_info *info;
     const char *libpath;
     const char *entry;
     unsigned long file_align;
     unsigned long maxstack;
     unsigned long maxdata;
     bfd_boolean gc;
     int modtype;
     bfd_boolean textro;
     bfd_boolean export_defineds;
     asection **special_sections;
     bfd_boolean rtld;
d2680 1
a2680 13
  struct xcoff_link_hash_entry *hentry;
  asection *lsec;
  struct xcoff_loader_info ldinfo;
  int i;
  size_t impsize, impcount;
  struct xcoff_import_file *fl;
  struct internal_ldhdr *ldhdr;
  bfd_size_type stoff;
  register char *out;
  asection *sec;
  bfd *sub;
  struct bfd_strtab_hash *debug_strtab;
  bfd_byte *debug_contents = NULL;
d2683 5
a2687 4
  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    {
      for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
	special_sections[i] = NULL;
a2688 1
    }
d2690 12
a2701 8
  ldinfo.failed = FALSE;
  ldinfo.output_bfd = output_bfd;
  ldinfo.info = info;
  ldinfo.export_defineds = export_defineds;
  ldinfo.ldsym_count = 0;
  ldinfo.string_size = 0;
  ldinfo.strings = NULL;
  ldinfo.string_alc = 0;
d2703 6
a2708 9
  xcoff_data (output_bfd)->maxstack = maxstack;
  xcoff_data (output_bfd)->maxdata = maxdata;
  xcoff_data (output_bfd)->modtype = modtype;

  xcoff_hash_table (info)->file_align = file_align;
  xcoff_hash_table (info)->textro = textro;

  hentry = NULL;
  if (entry != NULL)
d2710 1
a2710 5
      hentry = xcoff_link_hash_lookup (xcoff_hash_table (info), entry,
				       FALSE, FALSE, TRUE);
      if (hentry != NULL)
	hentry->flags |= XCOFF_ENTRY;
    }
d2712 19
a2730 9
  /* __rtinit */
  if (info->init_function || info->fini_function || rtld)
    {
      struct xcoff_link_hash_entry *hsym;
      struct internal_ldsym *ldsym;

      hsym = xcoff_link_hash_lookup (xcoff_hash_table (info),
				     "__rtinit", FALSE, FALSE, TRUE);
      if (hsym == NULL)
d2732 1
a2732 4
	  (*_bfd_error_handler)
	    (_("error: undefined symbol __rtinit"));
	  return FALSE;
	}
d2734 3
a2736 53
      xcoff_mark_symbol (info, hsym);
      hsym->flags |= (XCOFF_DEF_REGULAR | XCOFF_RTINIT);

      /* __rtinit initialized */
      amt = sizeof (struct internal_ldsym);
      ldsym = (struct internal_ldsym *) bfd_malloc (amt);

      ldsym->l_value = 0;		/* will be filled in later */
      ldsym->l_scnum = 2;		/* data section */
      ldsym->l_smtype = XTY_SD;		/* csect section definition */
      ldsym->l_smclas = 5;		/* .rw */
      ldsym->l_ifile = 0;		/* special system loader symbol */
      ldsym->l_parm = 0;		/* NA */

      /* Force __rtinit to be the first symbol in the loader symbol table
	 See xcoff_build_ldsyms

	 The first 3 symbol table indices are reserved to indicate the data,
	 text and bss sections.  */
      BFD_ASSERT (0 == ldinfo.ldsym_count);

      hsym->ldindx = 3;
      ldinfo.ldsym_count = 1;
      hsym->ldsym = ldsym;

      if (! bfd_xcoff_put_ldsymbol_name (ldinfo.output_bfd, &ldinfo,
					 hsym->ldsym, hsym->root.root.string))
	return FALSE;

      /* This symbol is written out by xcoff_write_global_symbol
	 Set stuff up so xcoff_write_global_symbol logic works.  */
      hsym->flags |= XCOFF_DEF_REGULAR | XCOFF_MARK;
      hsym->root.type = bfd_link_hash_defined;
      hsym->root.u.def.value = 0;
    }

  /* Garbage collect unused sections.  */
  if (info->relocatable
      || ! gc
      || hentry == NULL
      || (hentry->root.type != bfd_link_hash_defined
	  && hentry->root.type != bfd_link_hash_defweak))
    {
      gc = FALSE;
      xcoff_hash_table (info)->gc = FALSE;

      /* We still need to call xcoff_mark, in order to set ldrel_count
	 correctly.  */
      for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
	{
	  asection *o;

	  for (o = sub->sections; o != NULL; o = o->next)
d2738 1
a2738 1
	      if ((o->flags & SEC_MARK) == 0)
d2740 2
a2741 2
		  if (! xcoff_mark (info, o))
		    goto error_return;
d2743 1
d2746 3
a2748 7
    }
  else
    {
      if (! xcoff_mark (info, hentry->root.u.def.section))
	goto error_return;
      xcoff_sweep (info);
      xcoff_hash_table (info)->gc = TRUE;
d2751 25
a2775 2
  /* Return special sections to the caller.  */
  for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
d2777 10
a2786 1
      sec = xcoff_hash_table (info)->special_sections[i];
d2788 8
a2795 3
      if (sec != NULL
	  && gc
	  && (sec->flags & SEC_MARK) == 0)
d2797 1
a2797 4
	  sec = NULL;
	}
      special_sections[i] = sec;
    }
d2799 9
a2807 5
  if (info->input_bfds == NULL)
    {
      /* I'm not sure what to do in this bizarre case.  */
      return TRUE;
    }
d2809 7
a2815 4
  xcoff_link_hash_traverse (xcoff_hash_table (info), xcoff_build_ldsyms,
			    (PTR) &ldinfo);
  if (ldinfo.failed)
    goto error_return;
d2817 4
a2820 15
  /* Work out the size of the import file names.  Each import file ID
     consists of three null terminated strings: the path, the file
     name, and the archive member name.  The first entry in the list
     of names is the path to use to find objects, which the linker has
     passed in as the libpath argument.  For some reason, the path
     entry in the other import file names appears to always be empty.  */
  impsize = strlen (libpath) + 3;
  impcount = 1;
  for (fl = xcoff_hash_table (info)->imports; fl != NULL; fl = fl->next)
    {
      ++impcount;
      impsize += (strlen (fl->path)
		  + strlen (fl->file)
		  + strlen (fl->member)
		  + 3);
d2823 14
a2836 16
  /* Set up the .loader section header.  */
  ldhdr = &xcoff_hash_table (info)->ldhdr;
  ldhdr->l_version = bfd_xcoff_ldhdr_version(output_bfd);
  ldhdr->l_nsyms = ldinfo.ldsym_count;
  ldhdr->l_nreloc = xcoff_hash_table (info)->ldrel_count;
  ldhdr->l_istlen = impsize;
  ldhdr->l_nimpid = impcount;
  ldhdr->l_impoff = (bfd_xcoff_ldhdrsz(output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz(output_bfd)
		     + ldhdr->l_nreloc * bfd_xcoff_ldrelsz(output_bfd));
  ldhdr->l_stlen = ldinfo.string_size;
  stoff = ldhdr->l_impoff + impsize;
  if (ldinfo.string_size == 0)
    ldhdr->l_stoff = 0;
  else
    ldhdr->l_stoff = stoff;
d2838 11
a2848 7
  /* 64 bit elements to ldhdr
     The swap out routine for 32 bit will ignore them.
     Nothing fancy, symbols come after the header and relocs come
     after symbols.  */
  ldhdr->l_symoff = bfd_xcoff_ldhdrsz (output_bfd);
  ldhdr->l_rldoff = (bfd_xcoff_ldhdrsz (output_bfd)
		     + ldhdr->l_nsyms * bfd_xcoff_ldsymsz (output_bfd));
d2850 4
a2853 7
  /* We now know the final size of the .loader section.  Allocate
     space for it.  */
  lsec = xcoff_hash_table (info)->loader_section;
  lsec->size = stoff + ldhdr->l_stlen;
  lsec->contents = (bfd_byte *) bfd_zalloc (output_bfd, lsec->size);
  if (lsec->contents == NULL)
    goto error_return;
d2855 4
a2858 2
  /* Set up the header.  */
  bfd_xcoff_swap_ldhdr_out (output_bfd, ldhdr, lsec->contents);
d2860 11
a2870 19
  /* Set up the import file names.  */
  out = (char *) lsec->contents + ldhdr->l_impoff;
  strcpy (out, libpath);
  out += strlen (libpath) + 1;
  *out++ = '\0';
  *out++ = '\0';
  for (fl = xcoff_hash_table (info)->imports; fl != NULL; fl = fl->next)
    {
      register const char *s;

      s = fl->path;
      while ((*out++ = *s++) != '\0')
	;
      s = fl->file;
      while ((*out++ = *s++) != '\0')
	;
      s = fl->member;
      while ((*out++ = *s++) != '\0')
	;
d2873 7
a2879 4
  BFD_ASSERT ((bfd_size_type) ((bfd_byte *) out - lsec->contents) == stoff);

  /* Set up the symbol string table.  */
  if (ldinfo.string_size > 0)
d2881 2
a2882 3
      memcpy (out, ldinfo.strings, ldinfo.string_size);
      free (ldinfo.strings);
      ldinfo.strings = NULL;
d2885 4
a2888 8
  /* We can't set up the symbol table or the relocs yet, because we
     don't yet know the final position of the various sections.  The
     .loader symbols are written out when the corresponding normal
     symbols are written out in xcoff_link_input_bfd or
     xcoff_write_global_symbol.  The .loader relocs are written out
     when the corresponding normal relocs are handled in
     xcoff_link_input_bfd.
  */
d2890 6
a2895 3
  /* Allocate space for the magic sections.  */
  sec = xcoff_hash_table (info)->linkage_section;
  if (sec->size > 0)
d2897 2
a2898 3
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->size);
      if (sec->contents == NULL)
	goto error_return;
d2900 5
a2904 2
  sec = xcoff_hash_table (info)->toc_section;
  if (sec->size > 0)
d2906 2
a2907 3
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->size);
      if (sec->contents == NULL)
	goto error_return;
d2909 12
a2920 2
  sec = xcoff_hash_table (info)->descriptor_section;
  if (sec->size > 0)
d2922 2
a2923 3
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->size);
      if (sec->contents == NULL)
	goto error_return;
d2926 6
a2931 3
  /* Now that we've done garbage collection, figure out the contents
     of the .debug section.  */
  debug_strtab = xcoff_hash_table (info)->debug_strtab;
d2933 82
a3014 1
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
d3016 5
a3020 6
      asection *subdeb;
      bfd_size_type symcount;
      unsigned long *debug_index;
      asection **csectpp;
      bfd_byte *esym, *esymend;
      bfd_size_type symesz;
d3022 5
a3026 5
      if (sub->xvec != info->hash->creator)
	continue;
      subdeb = bfd_get_section_by_name (sub, ".debug");
      if (subdeb == NULL || subdeb->size == 0)
	continue;
d3028 3
a3030 3
      if (info->strip == strip_all
	  || info->strip == strip_debugger
	  || info->discard == discard_all)
d3032 3
a3034 2
	  subdeb->size = 0;
	  continue;
d3037 13
a3049 2
      if (! _bfd_coff_get_external_symbols (sub))
	goto error_return;
d3051 2
a3052 6
      symcount = obj_raw_syment_count (sub);
      debug_index = ((unsigned long *)
		     bfd_zalloc (sub, symcount * sizeof (unsigned long)));
      if (debug_index == NULL)
	goto error_return;
      xcoff_data (sub)->debug_indices = debug_index;
d3054 3
a3056 7
      /* Grab the contents of the .debug section.  We use malloc and
	 copy the names into the debug stringtab, rather than
	 bfd_alloc, because I expect that, when linking many files
	 together, many of the strings will be the same.  Storing the
	 strings in the hash table should save space in this case.  */
      if (!bfd_malloc_and_get_section (sub, subdeb, &debug_contents))
	goto error_return;
d3058 3
a3060 1
      csectpp = xcoff_data (sub)->csects;
d3062 3
a3064 6
      /* Dynamic object do not have csectpp's.  */
      if (NULL != csectpp)
	{
	  symesz = bfd_coff_symesz (sub);
	  esym = (bfd_byte *) obj_coff_external_syms (sub);
	  esymend = esym + symcount * symesz;
d3066 6
a3071 3
	  while (esym < esymend)
	    {
	      struct internal_syment sym;
d3073 9
a3081 1
	      bfd_coff_swap_sym_in (sub, (PTR) esym, (PTR) &sym);
d3083 5
a3087 1
	      *debug_index = (unsigned long) -1;
d3089 3
a3091 6
	      if (sym._n._n_n._n_zeroes == 0
		  && *csectpp != NULL
		  && (! gc
		      || ((*csectpp)->flags & SEC_MARK) != 0
		      || *csectpp == bfd_abs_section_ptr)
		  && bfd_coff_symname_in_debug (sub, &sym))
d3093 1
a3093 6
		  char *name;
		  bfd_size_type indx;

		  name = (char *) debug_contents + sym._n._n_n._n_offset;
		  indx = _bfd_stringtab_add (debug_strtab, name, TRUE, TRUE);
		  if (indx == (bfd_size_type) -1)
a3094 1
		  *debug_index = indx;
a3095 4

	      esym += (sym.n_numaux + 1) * symesz;
	      csectpp += sym.n_numaux + 1;
	      debug_index += sym.n_numaux + 1;
d3098 8
d3107 4
a3110 2
      free (debug_contents);
      debug_contents = NULL;
d3112 4
a3115 3
      /* Clear the size of subdeb, so that it is not included directly
	 in the output file.  */
      subdeb->size = 0;
d3117 1
a3117 5
      if (! info->keep_memory)
	{
	  if (! _bfd_coff_free_symbols (sub))
	    goto error_return;
	}
d3120 3
a3122 3
  if (info->strip != strip_all)
    xcoff_hash_table (info)->debug_section->size =
      _bfd_stringtab_size (debug_strtab);
d3124 4
a3127 1
  return TRUE;
d3129 16
a3144 7
 error_return:
  if (ldinfo.strings != NULL)
    free (ldinfo.strings);
  if (debug_contents != NULL)
    free (debug_contents);
  return FALSE;
}
d3146 16
a3161 8
bfd_boolean
bfd_xcoff_link_generate_rtinit (abfd, init, fini, rtld)
     bfd *abfd;
     const char *init;
     const char *fini;
     bfd_boolean rtld;
{
  struct bfd_in_memory *bim;
d3163 202
a3364 2
  bim = ((struct bfd_in_memory *)
	 bfd_malloc ((bfd_size_type) sizeof (struct bfd_in_memory)));
d3373 1
a3373 1
  abfd->iostream = (PTR) bim;
d3388 3
a3390 3


/* Add a symbol to the .loader symbols, if necessary.  */
d3393 2
a3394 3
xcoff_build_ldsyms (h, p)
     struct xcoff_link_hash_entry *h;
     PTR p;
d3396 27
a3422 2
  struct xcoff_loader_info *ldinfo = (struct xcoff_loader_info *) p;
  bfd_size_type amt;
d3424 8
a3431 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct xcoff_link_hash_entry *) h->root.u.i.link;
d3433 2
a3434 3
  /* __rtinit, this symbol has special handling. */
  if (h->flags & XCOFF_RTINIT)
      return TRUE;
d3436 3
a3438 12
  /* If this is a final link, and the symbol was defined as a common
     symbol in a regular object file, and there was no definition in
     any dynamic object, then the linker will have allocated space for
     the symbol in a common section but the XCOFF_DEF_REGULAR flag
     will not have been set.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->flags & XCOFF_REF_REGULAR) != 0
      && (h->flags & XCOFF_DEF_DYNAMIC) == 0
      && (bfd_is_abs_section (h->root.u.def.section)
	  || (h->root.u.def.section->owner->flags & DYNAMIC) == 0))
    h->flags |= XCOFF_DEF_REGULAR;
d3440 23
a3462 6
  /* If all defined symbols should be exported, mark them now.  We
     don't want to export the actual functions, just the function
     descriptors.  */
  if (ldinfo->export_defineds
      && (h->flags & XCOFF_DEF_REGULAR) != 0
      && h->root.root.string[0] != '.')
d3464 28
a3491 1
      bfd_boolean export;
d3493 9
a3501 19
      /* We don't export a symbol which is being defined by an object
	 included from an archive which contains a shared object.  The
	 rationale is that if an archive contains both an unshared and
	 a shared object, then there must be some reason that the
	 unshared object is unshared, and we don't want to start
	 providing a shared version of it.  In particular, this solves
	 a bug involving the _savefNN set of functions.  gcc will call
	 those functions without providing a slot to restore the TOC,
	 so it is essential that these functions be linked in directly
	 and not from a shared object, which means that a shared
	 object which also happens to link them in must not export
	 them.  This is confusing, but I haven't been able to think of
	 a different approach.  Note that the symbols can, of course,
	 be exported explicitly.  */
      export = TRUE;
      if ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section->owner != NULL
	  && h->root.u.def.section->owner->my_archive != NULL)
d3503 32
a3534 1
	  bfd *arbfd, *member;
d3536 3
a3538 3
	  arbfd = h->root.u.def.section->owner->my_archive;
	  member = bfd_openr_next_archived_file (arbfd, (bfd *) NULL);
	  while (member != NULL)
d3540 3
a3542 1
	      if ((member->flags & DYNAMIC) != 0)
d3544 18
a3561 2
		  export = FALSE;
		  break;
d3563 18
a3580 1
	      member = bfd_openr_next_archived_file (arbfd, member);
d3584 5
a3588 3
      if (export)
	h->flags |= XCOFF_EXPORT;
    }
d3590 3
a3592 10
  /* We don't want to garbage collect symbols which are not defined in
     XCOFF files.  This is a convenient place to mark them.  */
  if (xcoff_hash_table (ldinfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0
      && (h->root.type == bfd_link_hash_defined
	  || h->root.type == bfd_link_hash_defweak)
      && (h->root.u.def.section->owner == NULL
	  || (h->root.u.def.section->owner->xvec
	      != ldinfo->info->hash->creator)))
    h->flags |= XCOFF_MARK;
d3594 7
a3600 17
  /* If this symbol is called and defined in a dynamic object, or it
     is imported, then we need to set up global linkage code for it.
     (Unless we did garbage collection and we didn't need this
     symbol.)  */
  if ((h->flags & XCOFF_CALLED) != 0
      && (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
      && h->root.root.string[0] == '.'
      && h->descriptor != NULL
      && ((h->descriptor->flags & XCOFF_DEF_DYNAMIC) != 0
	  || ((h->descriptor->flags & XCOFF_IMPORT) != 0
	      && (h->descriptor->flags & XCOFF_DEF_REGULAR) == 0))
      && (! xcoff_hash_table (ldinfo->info)->gc
	  || (h->flags & XCOFF_MARK) != 0))
    {
      asection *sec;
      struct xcoff_link_hash_entry *hds;
d3602 4
a3605 7
      sec = xcoff_hash_table (ldinfo->info)->linkage_section;
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = sec;
      h->root.u.def.value = sec->size;
      h->smclas = XMC_GL;
      h->flags |= XCOFF_DEF_REGULAR;
      sec->size += bfd_xcoff_glink_code_size(ldinfo->output_bfd);
d3607 4
a3610 8
      /* The global linkage code requires a TOC entry for the
	 descriptor.  */
      hds = h->descriptor;
      BFD_ASSERT ((hds->root.type == bfd_link_hash_undefined
		   || hds->root.type == bfd_link_hash_undefweak)
		  && (hds->flags & XCOFF_DEF_REGULAR) == 0);
      hds->flags |= XCOFF_MARK;
      if (hds->toc_section == NULL)
d3612 2
a3613 9
	  int byte_size;

	  /* 32 vs 64
	     xcoff32 uses 4 bytes in the toc.
	     xcoff64 uses 8 bytes in the toc.  */
	  if (bfd_xcoff_is_xcoff64 (ldinfo->output_bfd))
	    byte_size = 8;
	  else if (bfd_xcoff_is_xcoff32 (ldinfo->output_bfd))
	    byte_size = 4;
d3615 3
a3617 1
	    return FALSE;
d3619 4
a3622 7
	  hds->toc_section = xcoff_hash_table (ldinfo->info)->toc_section;
	  hds->u.toc_offset = hds->toc_section->size;
	  hds->toc_section->size += byte_size;
	  ++xcoff_hash_table (ldinfo->info)->ldrel_count;
	  ++hds->toc_section->reloc_count;
	  hds->indx = -2;
	  hds->flags |= XCOFF_SET_TOC | XCOFF_LDREL;
d3624 12
a3635 5
	  /* We need to call xcoff_build_ldsyms recursively here,
	     because we may already have passed hds on the traversal.  */
	  xcoff_build_ldsyms (hds, p);
	}
    }
d3637 10
a3646 14
  /* If this symbol is exported, but not defined, we need to try to
     define it.  */
  if ((h->flags & XCOFF_EXPORT) != 0
      && (h->flags & XCOFF_IMPORT) == 0
      && (h->flags & XCOFF_DEF_REGULAR) == 0
      && (h->flags & XCOFF_DEF_DYNAMIC) == 0
      && (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak))
    {
      if ((h->flags & XCOFF_DESCRIPTOR) != 0
	  && (h->descriptor->root.type == bfd_link_hash_defined
	      || h->descriptor->root.type == bfd_link_hash_defweak))
	{
	  asection *sec;
d3648 1
a3648 11
	  /* This is an undefined function descriptor associated with
	     a defined entry point.  We can build up a function
	     descriptor ourselves.  Believe it or not, the AIX linker
	     actually does this, and there are cases where we need to
	     do it as well.  */
	  sec = xcoff_hash_table (ldinfo->info)->descriptor_section;
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = sec;
	  h->root.u.def.value = sec->size;
	  h->smclas = XMC_DS;
	  h->flags |= XCOFF_DEF_REGULAR;
d3650 8
a3657 4
	  /* The size of the function descriptor depends if this is an
	     xcoff32 (12) or xcoff64 (24).  */
	  sec->size +=
	    bfd_xcoff_function_descriptor_size(ldinfo->output_bfd);
d3659 3
a3661 4
	  /* A function descriptor uses two relocs: one for the
	     associated code, and one for the TOC address.  */
	  xcoff_hash_table (ldinfo->info)->ldrel_count += 2;
	  sec->reloc_count += 2;
d3663 4
a3666 12
	  /* We handle writing out the contents of the descriptor in
	     xcoff_write_global_symbol.  */
	}
      else
	{
	  (*_bfd_error_handler)
	    (_("warning: attempt to export undefined symbol `%s'"),
	     h->root.root.string);
	  h->ldsym = NULL;
	  return TRUE;
	}
    }
d3668 5
a3672 11
  /* If this is still a common symbol, and it wasn't garbage
     collected, we need to actually allocate space for it in the .bss
     section.  */
  if (h->root.type == bfd_link_hash_common
      && (! xcoff_hash_table (ldinfo->info)->gc
	  || (h->flags & XCOFF_MARK) != 0)
      && h->root.u.c.p->section->size == 0)
    {
      BFD_ASSERT (bfd_is_com_section (h->root.u.c.p->section));
      h->root.u.c.p->section->size = h->root.u.c.size;
    }
d3674 2
a3675 4
  /* We need to add a symbol to the .loader section if it is mentioned
     in a reloc which we are copying to the .loader section and it was
     not defined or common, or if it is the entry point, or if it is
     being exported.  */
d3677 4
a3680 10
  if (((h->flags & XCOFF_LDREL) == 0
       || h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak
       || h->root.type == bfd_link_hash_common)
      && (h->flags & XCOFF_ENTRY) == 0
      && (h->flags & XCOFF_EXPORT) == 0)
    {
      h->ldsym = NULL;
      return TRUE;
    }
d3682 6
a3687 8
  /* We don't need to add this symbol if we did garbage collection and
     we did not mark this symbol.  */
  if (xcoff_hash_table (ldinfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0)
    {
      h->ldsym = NULL;
      return TRUE;
    }
d3689 10
a3698 4
  /* We may have already processed this symbol due to the recursive
     call above.  */
  if ((h->flags & XCOFF_BUILT_LDSYM) != 0)
    return TRUE;
d3700 7
a3706 1
  /* We need to add this symbol to the .loader symbols.  */
d3708 6
a3713 8
  BFD_ASSERT (h->ldsym == NULL);
  amt = sizeof (struct internal_ldsym);
  h->ldsym = (struct internal_ldsym *) bfd_zalloc (ldinfo->output_bfd, amt);
  if (h->ldsym == NULL)
    {
      ldinfo->failed = TRUE;
      return FALSE;
    }
d3715 12
a3726 2
  if ((h->flags & XCOFF_IMPORT) != 0)
    h->ldsym->l_ifile = h->ldindx;
d3728 1
a3728 3
  /* The first 3 symbol table indices are reserved to indicate the
     data, text and bss sections.  */
  h->ldindx = ldinfo->ldsym_count + 3;
d3730 2
a3731 1
  ++ldinfo->ldsym_count;
d3733 10
a3742 5
  if (! bfd_xcoff_put_ldsymbol_name (ldinfo->output_bfd, ldinfo,
				     h->ldsym, h->root.root.string))
    {
      return FALSE;
    }
d3744 5
a3748 1
  h->flags |= XCOFF_BUILT_LDSYM;
d3750 4
a3753 4
  return TRUE;
}

/* Do the final link step.  */
d3755 12
a3766 23
bfd_boolean
_bfd_xcoff_bfd_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  bfd_size_type symesz;
  struct xcoff_final_link_info finfo;
  asection *o;
  struct bfd_link_order *p;
  bfd_size_type max_contents_size;
  bfd_size_type max_sym_count;
  bfd_size_type max_lineno_count;
  bfd_size_type max_reloc_count;
  bfd_size_type max_output_reloc_count;
  file_ptr rel_filepos;
  unsigned int relsz;
  file_ptr line_filepos;
  unsigned int linesz;
  bfd *sub;
  bfd_byte *external_relocs = NULL;
  char strbuf[STRING_SIZE_SIZE];
  file_ptr pos;
  bfd_size_type amt;
d3768 1
a3768 2
  if (info->shared)
    abfd->flags |= DYNAMIC;
d3770 19
a3788 1
  symesz = bfd_coff_symesz (abfd);
d3790 28
a3817 12
  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.strtab = NULL;
  finfo.section_info = NULL;
  finfo.last_file_index = -1;
  finfo.toc_symindx = -1;
  finfo.internal_syms = NULL;
  finfo.sym_indices = NULL;
  finfo.outsyms = NULL;
  finfo.linenos = NULL;
  finfo.contents = NULL;
  finfo.external_relocs = NULL;
d3819 3
a3821 6
  finfo.ldsym = (xcoff_hash_table (info)->loader_section->contents
		 + bfd_xcoff_ldhdrsz (abfd));
  finfo.ldrel = (xcoff_hash_table (info)->loader_section->contents
		 + bfd_xcoff_ldhdrsz(abfd)
		 + (xcoff_hash_table (info)->ldhdr.l_nsyms
		    * bfd_xcoff_ldsymsz(abfd)));
d3823 8
a3830 1
  xcoff_data (abfd)->coff.link_info = info;
d3832 3
a3834 3
  finfo.strtab = _bfd_stringtab_init ();
  if (finfo.strtab == NULL)
    goto error_return;
d3836 5
a3840 12
  /* Count the line number and relocation entries required for the
     output file.  Determine a few maximum sizes.  */
  max_contents_size = 0;
  max_lineno_count = 0;
  max_reloc_count = 0;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      o->reloc_count = 0;
      o->lineno_count = 0;
      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order)
d3842 5
a3846 1
	      asection *sec;
d3848 1
a3848 1
	      sec = p->u.indirect.section;
d3850 1
a3850 5
	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;
d3852 4
a3855 3
	      if (info->strip == strip_none
		  || info->strip == strip_some)
		o->lineno_count += sec->lineno_count;
d3857 6
a3862 1
	      o->reloc_count += sec->reloc_count;
d3864 10
a3873 14
	      if (sec->rawsize > max_contents_size)
		max_contents_size = sec->rawsize;
	      if (sec->size > max_contents_size)
		max_contents_size = sec->size;
	      if (sec->lineno_count > max_lineno_count)
		max_lineno_count = sec->lineno_count;
	      if (coff_section_data (sec->owner, sec) != NULL
		  && xcoff_section_data (sec->owner, sec) != NULL
		  && (xcoff_section_data (sec->owner, sec)->lineno_count
		      > max_lineno_count))
		max_lineno_count =
		  xcoff_section_data (sec->owner, sec)->lineno_count;
	      if (sec->reloc_count > max_reloc_count)
		max_reloc_count = sec->reloc_count;
d3875 3
a3877 3
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    ++o->reloc_count;
d3879 10
d3891 12
a3902 2
  /* Compute the file positions for all the sections.  */
  if (abfd->output_has_begun)
d3904 3
a3906 6
      if (xcoff_hash_table (info)->file_align != 0)
	abort ();
    }
  else
    {
      bfd_vma file_align;
d3908 3
a3910 2
      file_align = xcoff_hash_table (info)->file_align;
      if (file_align != 0)
d3912 1
a3912 4
	  bfd_boolean saw_contents;
	  int indx;
	  asection **op;
	  file_ptr sofar;
d3914 1
a3914 5
	  /* Insert .pad sections before every section which has
	     contents and is loaded, if it is preceded by some other
	     section which has contents and is loaded.  */
	  saw_contents = TRUE;
	  for (op = &abfd->sections; *op != NULL; op = &(*op)->next)
d3916 1
a3916 10
	      if (strcmp ((*op)->name, ".pad") == 0)
		saw_contents = FALSE;
	      else if (((*op)->flags & SEC_HAS_CONTENTS) != 0
		       && ((*op)->flags & SEC_LOAD) != 0)
		{
		  if (! saw_contents)
		    saw_contents = TRUE;
		  else
		    {
		      asection *n, **st;
d3918 1
a3918 3
		      /* Create a pad section and place it before the section
			 that needs padding.  This requires unlinking and
			 relinking the bfd's section list.  */
d3920 7
a3926 4
		      st = abfd->section_tail;
		      n = bfd_make_section_anyway (abfd, ".pad");
		      n->flags = SEC_HAS_CONTENTS;
		      n->alignment_power = 0;
d3928 7
a3934 7
		      BFD_ASSERT (*st == n);
		      bfd_section_list_remove (abfd, st);
		      bfd_section_list_insert (abfd, op, n);

		      op = &n->next;
		      saw_contents = FALSE;
		    }
d3938 4
a3941 4
	  /* Reset the section indices after inserting the new
	     sections.  */
	  indx = 0;
	  for (o = abfd->sections; o != NULL; o = o->next)
d3943 5
a3947 4
	      ++indx;
	      o->target_index = indx;
	    }
	  BFD_ASSERT ((unsigned int) indx == abfd->section_count);
d3949 10
a3958 14
	  /* Work out appropriate sizes for the .pad sections to force
	     each section to land on a page boundary.  This bit of
	     code knows what compute_section_file_positions is going
	     to do.  */
	  sofar = bfd_coff_filhsz (abfd);
	  sofar += bfd_coff_aoutsz (abfd);
	  sofar += abfd->section_count * bfd_coff_scnhsz (abfd);
	  for (o = abfd->sections; o != NULL; o = o->next)
	    if ((bfd_xcoff_is_reloc_count_overflow
		 (abfd, (bfd_vma) o->reloc_count))
		|| (bfd_xcoff_is_lineno_count_overflow
		    (abfd, (bfd_vma) o->lineno_count)))
	      /* 64 does not overflow, need to check if 32 does */
	      sofar += bfd_coff_scnhsz (abfd);
d3960 19
a3978 3
	  for (o = abfd->sections; o != NULL; o = o->next)
	    {
	      if (strcmp (o->name, ".pad") == 0)
a3979 1
		  bfd_vma pageoff;
d3981 9
a3989 3
		  BFD_ASSERT (o->size == 0);
		  pageoff = sofar & (file_align - 1);
		  if (pageoff != 0)
d3991 17
a4007 3
		      o->size = file_align - pageoff;
		      sofar += file_align - pageoff;
		      o->flags |= SEC_HAS_CONTENTS;
d4010 1
a4010 1
	      else
d4012 1
a4012 6
		  if ((o->flags & SEC_HAS_CONTENTS) != 0)
		    sofar += BFD_ALIGN (o->size,
					1 << o->alignment_power);
		}
	    }
	}
d4014 21
a4034 3
      if (! bfd_coff_compute_section_file_positions (abfd))
	goto error_return;
    }
d4036 2
a4037 3
  /* Allocate space for the pointers we need to keep for the relocs.  */
  {
    unsigned int i;
d4039 4
a4042 14
    /* We use section_count + 1, rather than section_count, because
       the target_index fields are 1 based.  */
    amt = abfd->section_count + 1;
    amt *= sizeof (struct xcoff_link_section_info);
    finfo.section_info = (struct xcoff_link_section_info *) bfd_malloc (amt);
    if (finfo.section_info == NULL)
      goto error_return;
    for (i = 0; i <= abfd->section_count; i++)
      {
	finfo.section_info[i].relocs = NULL;
	finfo.section_info[i].rel_hashes = NULL;
	finfo.section_info[i].toc_rel_hashes = NULL;
      }
  }
d4044 6
a4049 21
  /* Set the file positions for the relocs.  */
  rel_filepos = obj_relocbase (abfd);
  relsz = bfd_coff_relsz (abfd);
  max_output_reloc_count = 0;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->reloc_count == 0)
	o->rel_filepos = 0;
      else
	{
	  /* A stripped file has no relocs.  However, we still
	     allocate the buffers, so that later code doesn't have to
	     worry about whether we are stripping or not.  */
	  if (info->strip == strip_all)
	    o->rel_filepos = 0;
	  else
	    {
	      o->flags |= SEC_RELOC;
	      o->rel_filepos = rel_filepos;
	      rel_filepos += o->reloc_count * relsz;
	    }
d4051 1
a4051 8
	  /* We don't know the indices of global symbols until we have
	     written out all the local symbols.  For each section in
	     the output file, we keep an array of pointers to hash
	     table entries.  Each entry in the array corresponds to a
	     reloc.  When we find a reloc against a global symbol, we
	     set the corresponding entry in this array so that we can
	     fix up the symbol index after we have written out all the
	     local symbols.
d4053 19
a4071 8
	     Because of this problem, we also keep the relocs in
	     memory until the end of the link.  This wastes memory.
	     We could backpatch the file later, I suppose, although it
	     would be slow.  */
	  amt = o->reloc_count;
	  amt *= sizeof (struct internal_reloc);
	  finfo.section_info[o->target_index].relocs =
	    (struct internal_reloc *) bfd_malloc (amt);
d4073 13
a4085 4
	  amt = o->reloc_count;
	  amt *= sizeof (struct xcoff_link_hash_entry *);
	  finfo.section_info[o->target_index].rel_hashes =
	    (struct xcoff_link_hash_entry **) bfd_malloc (amt);
d4087 2
a4088 3
	  if (finfo.section_info[o->target_index].relocs == NULL
	      || finfo.section_info[o->target_index].rel_hashes == NULL)
	    goto error_return;
d4090 16
a4105 4
	  if (o->reloc_count > max_output_reloc_count)
	    max_output_reloc_count = o->reloc_count;
	}
    }
d4107 4
a4110 14
  /* We now know the size of the relocs, so we can determine the file
     positions of the line numbers.  */
  line_filepos = rel_filepos;
  finfo.line_filepos = line_filepos;
  linesz = bfd_coff_linesz (abfd);
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->lineno_count == 0)
	o->line_filepos = 0;
      else
	{
	  o->line_filepos = line_filepos;
	  line_filepos += o->lineno_count * linesz;
	}
d4112 18
a4129 5
      /* Reset the reloc and lineno counts, so that we can use them to
	 count the number of entries we have output so far.  */
      o->reloc_count = 0;
      o->lineno_count = 0;
    }
d4131 1
a4131 1
  obj_sym_filepos (abfd) = line_filepos;
d4133 3
a4135 8
  /* Figure out the largest number of symbols in an input BFD.  Take
     the opportunity to clear the output_has_begun fields of all the
     input BFD's.  We want at least 6 symbols, since that is the
     number which xcoff_write_global_symbol may need.  */
  max_sym_count = 6;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      bfd_size_type sz;
d4137 7
a4143 5
      sub->output_has_begun = FALSE;
      sz = obj_raw_syment_count (sub);
      if (sz > max_sym_count)
	max_sym_count = sz;
    }
d4145 1
a4145 3
  /* Allocate some buffers used while linking.  */
  amt = max_sym_count * sizeof (struct internal_syment);
  finfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
d4147 6
a4152 2
  amt = max_sym_count * sizeof (long);
  finfo.sym_indices = (long *) bfd_malloc (amt);
d4154 20
a4173 2
  amt = (max_sym_count + 1) * symesz;
  finfo.outsyms = (bfd_byte *) bfd_malloc (amt);
d4175 13
a4187 2
  amt = max_lineno_count * bfd_coff_linesz (abfd);
  finfo.linenos = (bfd_byte *) bfd_malloc (amt);
d4189 10
a4198 2
  amt = max_contents_size;
  finfo.contents = (bfd_byte *) bfd_malloc (amt);
d4200 5
a4204 44
  amt = max_reloc_count * relsz;
  finfo.external_relocs = (bfd_byte *) bfd_malloc (amt);

  if ((finfo.internal_syms == NULL && max_sym_count > 0)
      || (finfo.sym_indices == NULL && max_sym_count > 0)
      || finfo.outsyms == NULL
      || (finfo.linenos == NULL && max_lineno_count > 0)
      || (finfo.contents == NULL && max_contents_size > 0)
      || (finfo.external_relocs == NULL && max_reloc_count > 0))
    goto error_return;

  obj_raw_syment_count (abfd) = 0;
  xcoff_data (abfd)->toc = (bfd_vma) -1;

  /* We now know the position of everything in the file, except that
     we don't know the size of the symbol table and therefore we don't
     know where the string table starts.  We just build the string
     table in memory as we go along.  We process all the relocations
     for a single input file at once.  */
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->link_order_head; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && p->u.indirect.section->owner->xvec == abfd->xvec)
	    {
	      sub = p->u.indirect.section->owner;
	      if (! sub->output_has_begun)
		{
		  if (! xcoff_link_input_bfd (&finfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! xcoff_reloc_link_order (abfd, &finfo, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
d4207 4
d4213 6
a4218 4

  /* Free up the buffers used by xcoff_link_input_bfd.  */

  if (finfo.internal_syms != NULL)
d4220 5
a4224 2
      free (finfo.internal_syms);
      finfo.internal_syms = NULL;
d4226 3
a4228 1
  if (finfo.sym_indices != NULL)
d4230 9
a4238 18
      free (finfo.sym_indices);
      finfo.sym_indices = NULL;
    }
  if (finfo.linenos != NULL)
    {
      free (finfo.linenos);
      finfo.linenos = NULL;
    }
  if (finfo.contents != NULL)
    {
      free (finfo.contents);
      finfo.contents = NULL;
    }
  if (finfo.external_relocs != NULL)
    {
      free (finfo.external_relocs);
      finfo.external_relocs = NULL;
    }
d4240 1
a4240 11
  /* The value of the last C_FILE symbol is supposed to be -1.  Write
     it out again.  */
  if (finfo.last_file_index != -1)
    {
      finfo.last_file.n_value = -(bfd_vma) 1;
      bfd_coff_swap_sym_out (abfd, (PTR) &finfo.last_file,
			     (PTR) finfo.outsyms);
      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
	goto error_return;
d4243 3
a4245 5
  /* Write out all the global symbols which do not come from XCOFF
     input files.  */
  xcoff_link_hash_traverse (xcoff_hash_table (info),
			    xcoff_write_global_symbol,
			    (PTR) &finfo);
d4247 2
a4248 1
  if (finfo.outsyms != NULL)
d4250 1
a4250 3
      free (finfo.outsyms);
      finfo.outsyms = NULL;
    }
d4252 3
a4254 7
  /* Now that we have written out all the global symbols, we know the
     symbol indices to use for relocs against them, and we can finally
     write out the relocs.  */
  amt = max_output_reloc_count * relsz;
  external_relocs = (bfd_byte *) bfd_malloc (amt);
  if (external_relocs == NULL && max_output_reloc_count != 0)
    goto error_return;
d4256 4
a4259 8
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct internal_reloc *irel;
      struct internal_reloc *irelend;
      struct xcoff_link_hash_entry **rel_hash;
      struct xcoff_toc_rel_hash *toc_rel_hash;
      bfd_byte *erel;
      bfd_size_type rel_size;
d4261 6
a4266 2
      /* A stripped file has no relocs.  */
      if (info->strip == strip_all)
d4268 4
a4271 2
	  o->reloc_count = 0;
	  continue;
d4274 9
a4282 2
      if (o->reloc_count == 0)
	continue;
d4284 26
a4309 6
      irel = finfo.section_info[o->target_index].relocs;
      irelend = irel + o->reloc_count;
      rel_hash = finfo.section_info[o->target_index].rel_hashes;
      for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	{
	  if (*rel_hash != NULL)
d4311 3
a4313 11
	      if ((*rel_hash)->indx < 0)
		{
		  if (! ((*info->callbacks->unattached_reloc)
			 (info, (*rel_hash)->root.root.string,
			  (bfd *) NULL, o, irel->r_vaddr)))
		    goto error_return;
		  (*rel_hash)->indx = 0;
		}
	      irel->r_symndx = (*rel_hash)->indx;
	    }
	}
d4315 1
a4315 14
      for (toc_rel_hash = finfo.section_info[o->target_index].toc_rel_hashes;
	   toc_rel_hash != NULL;
	   toc_rel_hash = toc_rel_hash->next)
	{
	  if (toc_rel_hash->h->u.toc_indx < 0)
	    {
	      if (! ((*info->callbacks->unattached_reloc)
		     (info, toc_rel_hash->h->root.root.string,
		      (bfd *) NULL, o, toc_rel_hash->rel->r_vaddr)))
		goto error_return;
	      toc_rel_hash->h->u.toc_indx = 0;
	    }
	  toc_rel_hash->rel->r_symndx = toc_rel_hash->h->u.toc_indx;
	}
d4317 1
a4317 8
      /* XCOFF requires that the relocs be sorted by address.  We tend
	 to produce them in the order in which their containing csects
	 appear in the symbol table, which is not necessarily by
	 address.  So we sort them here.  There may be a better way to
	 do this.  */
      qsort ((PTR) finfo.section_info[o->target_index].relocs,
	     o->reloc_count, sizeof (struct internal_reloc),
	     xcoff_sort_relocs);
d4319 1
a4319 5
      irel = finfo.section_info[o->target_index].relocs;
      irelend = irel + o->reloc_count;
      erel = external_relocs;
      for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	bfd_coff_swap_reloc_out (abfd, (PTR) irel, (PTR) erel);
d4321 1
a4321 5
      rel_size = relsz * o->reloc_count;
      if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0
	  || bfd_bwrite ((PTR) external_relocs, rel_size, abfd) != rel_size)
	goto error_return;
    }
d4323 4
a4326 5
  if (external_relocs != NULL)
    {
      free (external_relocs);
      external_relocs = NULL;
    }
d4328 24
a4351 4
  /* Free up the section information.  */
  if (finfo.section_info != NULL)
    {
      unsigned int i;
d4353 31
a4383 10
      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
      finfo.section_info = NULL;
    }
d4385 1
a4385 8
  /* Write out the loader section contents.  */
  BFD_ASSERT ((bfd_byte *) finfo.ldrel
	      == (xcoff_hash_table (info)->loader_section->contents
		  + xcoff_hash_table (info)->ldhdr.l_impoff));
  o = xcoff_hash_table (info)->loader_section;
  if (! bfd_set_section_contents (abfd, o->output_section, o->contents,
				  (file_ptr) o->output_offset, o->size))
    goto error_return;
d4387 3
a4389 19
  /* Write out the magic sections.  */
  o = xcoff_hash_table (info)->linkage_section;
  if (o->size > 0
      && ! bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset,
				     o->size))
    goto error_return;
  o = xcoff_hash_table (info)->toc_section;
  if (o->size > 0
      && ! bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset,
				     o->size))
    goto error_return;
  o = xcoff_hash_table (info)->descriptor_section;
  if (o->size > 0
      && ! bfd_set_section_contents (abfd, o->output_section, o->contents,
				     (file_ptr) o->output_offset,
				     o->size))
    goto error_return;
d4391 9
a4399 12
  /* Write out the string table.  */
  pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0)
    goto error_return;
  H_PUT_32 (abfd,
	    _bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
	    strbuf);
  amt = STRING_SIZE_SIZE;
  if (bfd_bwrite (strbuf, amt, abfd) != amt)
    goto error_return;
  if (! _bfd_stringtab_emit (abfd, finfo.strtab))
    goto error_return;
d4401 15
a4415 1
  _bfd_stringtab_free (finfo.strtab);
d4417 4
a4420 5
  /* Write out the debugging string table.  */
  o = xcoff_hash_table (info)->debug_section;
  if (o != NULL)
    {
      struct bfd_strtab_hash *debug_strtab;
d4422 1
a4422 9
      debug_strtab = xcoff_hash_table (info)->debug_strtab;
      BFD_ASSERT (o->output_section->size - o->output_offset
		  >= _bfd_stringtab_size (debug_strtab));
      pos = o->output_section->filepos + o->output_offset;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
	goto error_return;
      if (! _bfd_stringtab_emit (abfd, debug_strtab))
	goto error_return;
    }
d4424 2
a4425 3
  /* Setting bfd_get_symcount to 0 will cause write_object_contents to
     not try to write out the symbols.  */
  bfd_get_symcount (abfd) = 0;
d4427 4
a4430 1
  return TRUE;
d4432 2
a4433 3
 error_return:
  if (finfo.strtab != NULL)
    _bfd_stringtab_free (finfo.strtab);
d4435 2
a4436 3
  if (finfo.section_info != NULL)
    {
      unsigned int i;
d4438 110
a4547 6
      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
d4549 14
a4562 1
      free (finfo.section_info);
d4565 20
a4584 15
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.sym_indices != NULL)
    free (finfo.sym_indices);
  if (finfo.outsyms != NULL)
    free (finfo.outsyms);
  if (finfo.linenos != NULL)
    free (finfo.linenos);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (external_relocs != NULL)
    free (external_relocs);
  return FALSE;
d4587 1
a4587 2
/* Link an input file into the linker output file.  This function
   handles all the sections and relocations of the input file at once.  */
d4590 1
a4590 3
xcoff_link_input_bfd (finfo, input_bfd)
     struct xcoff_final_link_info *finfo;
     bfd *input_bfd;
d4592 1
a4593 16
  const char *strings;
  bfd_size_type syment_base;
  unsigned int n_tmask;
  unsigned int n_btshft;
  bfd_boolean copy, hash;
  bfd_size_type isymesz;
  bfd_size_type osymesz;
  bfd_size_type linesz;
  bfd_byte *esym;
  bfd_byte *esym_end;
  struct xcoff_link_hash_entry **sym_hash;
  struct internal_syment *isymp;
  asection **csectpp;
  unsigned long *debug_index;
  long *indexp;
  unsigned long output_index;
d4595 15
a4609 4
  unsigned int incls;
  asection *oline;
  bfd_boolean keep_syms;
  asection *o;
d4611 3
a4613 3
  /* We can just skip DYNAMIC files, unless this is a static link.  */
  if ((input_bfd->flags & DYNAMIC) != 0
      && ! finfo->info->static_link)
d4616 5
a4620 1
  /* Move all the symbols to the output file.  */
d4622 1
a4622 7
  output_bfd = finfo->output_bfd;
  strings = NULL;
  syment_base = obj_raw_syment_count (output_bfd);
  isymesz = bfd_coff_symesz (input_bfd);
  osymesz = bfd_coff_symesz (output_bfd);
  linesz = bfd_coff_linesz (input_bfd);
  BFD_ASSERT (linesz == bfd_coff_linesz (output_bfd));
d4624 3
a4626 2
  n_tmask = coff_data (input_bfd)->local_n_tmask;
  n_btshft = coff_data (input_bfd)->local_n_btshft;
d4628 4
a4631 3
  /* Define macros so that ISFCN, et. al., macros work correctly.  */
#define N_TMASK n_tmask
#define N_BTSHFT n_btshft
d4633 5
a4637 6
  copy = FALSE;
  if (! finfo->info->keep_memory)
    copy = TRUE;
  hash = TRUE;
  if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
    hash = FALSE;
d4639 7
a4645 2
  if (! _bfd_coff_get_external_symbols (input_bfd))
    return FALSE;
d4647 17
a4663 11
  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
  sym_hash = obj_xcoff_sym_hashes (input_bfd);
  csectpp = xcoff_data (input_bfd)->csects;
  debug_index = xcoff_data (input_bfd)->debug_indices;
  isymp = finfo->internal_syms;
  indexp = finfo->sym_indices;
  output_index = syment_base;
  outsym = finfo->outsyms;
  incls = 0;
  oline = NULL;
d4665 2
a4666 2
  while (esym < esym_end)
    {
d4668 2
a4669 6
      struct internal_syment isym;
      union internal_auxent aux;
      int smtyp = 0;
      bfd_boolean skip;
      bfd_boolean require;
      int add;
d4671 1
a4671 1
      bfd_coff_swap_sym_in (input_bfd, (PTR) esym, (PTR) isymp);
d4673 1
a4673 3
      /* If this is a C_EXT or C_HIDEXT symbol, we need the csect
	 information.  */
      if (isymp->n_sclass == C_EXT || isymp->n_sclass == C_HIDEXT)
d4675 11
a4685 6
	  BFD_ASSERT (isymp->n_numaux > 0);
	  bfd_coff_swap_aux_in (input_bfd,
				(PTR) (esym + isymesz * isymp->n_numaux),
				isymp->n_type, isymp->n_sclass,
				isymp->n_numaux - 1, isymp->n_numaux,
				(PTR) &aux);
d4687 2
a4688 1
	  smtyp = SMTYP_SMTYP (aux.x_csect.x_smtyp);
d4691 5
a4695 15
      /* Make a copy of *isymp so that the relocate_section function
	 always sees the original values.  This is more reliable than
	 always recomputing the symbol value even if we are stripping
	 the symbol.  */
      isym = *isymp;

      /* If this symbol is in the .loader section, swap out the
	 .loader symbol information.  If this is an external symbol
	 reference to a defined symbol, though, then wait until we get
	 to the definition.  */
      if (isym.n_sclass == C_EXT
	  && *sym_hash != NULL
	  && (*sym_hash)->ldsym != NULL
	  && (smtyp != XTY_ER
	      || (*sym_hash)->root.type == bfd_link_hash_undefined))
d4697 4
a4700 13
	  struct xcoff_link_hash_entry *h;
	  struct internal_ldsym *ldsym;

	  h = *sym_hash;
	  ldsym = h->ldsym;
	  if (isym.n_scnum > 0)
	    {
	      ldsym->l_scnum = (*csectpp)->output_section->target_index;
	      ldsym->l_value = (isym.n_value
				+ (*csectpp)->output_section->vma
				+ (*csectpp)->output_offset
				- (*csectpp)->vma);
	    }
d4703 2
a4704 2
	      ldsym->l_scnum = isym.n_scnum;
	      ldsym->l_value = isym.n_value;
d4706 21
d4728 1
a4728 11
	  ldsym->l_smtype = smtyp;
	  if (((h->flags & XCOFF_DEF_REGULAR) == 0
	       && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	      || (h->flags & XCOFF_IMPORT) != 0)
	    ldsym->l_smtype |= L_IMPORT;
	  if (((h->flags & XCOFF_DEF_REGULAR) != 0
	       && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	      || (h->flags & XCOFF_EXPORT) != 0)
	    ldsym->l_smtype |= L_EXPORT;
	  if ((h->flags & XCOFF_ENTRY) != 0)
	    ldsym->l_smtype |= L_ENTRY;
d4730 5
a4734 1
	  ldsym->l_smclas = aux.x_csect.x_smclas;
d4736 2
a4737 9
	  if (ldsym->l_ifile == (bfd_size_type) -1)
	    ldsym->l_ifile = 0;
	  else if (ldsym->l_ifile == 0)
	    {
	      if ((ldsym->l_smtype & L_IMPORT) == 0)
		ldsym->l_ifile = 0;
	      else
		{
		  bfd *impbfd;
d4739 5
a4743 8
		  if (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak)
		    impbfd = h->root.u.def.section->owner;
		  else if (h->root.type == bfd_link_hash_undefined
			   || h->root.type == bfd_link_hash_undefweak)
		    impbfd = h->root.u.undef.abfd;
		  else
		    impbfd = NULL;
d4745 8
a4752 9
		  if (impbfd == NULL)
		    ldsym->l_ifile = 0;
		  else
		    {
		      BFD_ASSERT (impbfd->xvec == finfo->output_bfd->xvec);
		      ldsym->l_ifile = xcoff_data (impbfd)->import_file_id;
		    }
		}
	    }
d4754 11
a4764 1
	  ldsym->l_parm = 0;
d4766 7
a4772 6
	  BFD_ASSERT (h->ldindx >= 0);
	  bfd_xcoff_swap_ldsym_out (finfo->output_bfd, ldsym,
				    (finfo->ldsym
				     + ((h->ldindx - 3)
					* bfd_xcoff_ldsymsz (finfo->output_bfd))));
	  h->ldsym = NULL;
d4774 6
a4779 8
	  /* Fill in snentry now that we know the target_index.  */
	  if ((h->flags & XCOFF_ENTRY) != 0
	      && (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak))
	    {
	      xcoff_data (output_bfd)->snentry =
		h->root.u.def.section->output_section->target_index;
	    }
d4782 1
a4782 1
      *indexp = -1;
d4784 7
a4790 3
      skip = FALSE;
      require = FALSE;
      add = 1 + isym.n_numaux;
d4792 2
a4793 3
      /* If we are skipping this csect, we want to skip this symbol.  */
      if (*csectpp == NULL)
	skip = TRUE;
d4795 1
a4795 7
      /* If we garbage collected this csect, we want to skip this
	 symbol.  */
      if (! skip
	  && xcoff_hash_table (finfo->info)->gc
	  && ((*csectpp)->flags & SEC_MARK) == 0
	  && *csectpp != bfd_abs_section_ptr)
	skip = TRUE;
d4797 7
a4803 9
      /* An XCOFF linker always skips C_STAT symbols.  */
      if (! skip
	  && isymp->n_sclass == C_STAT)
	skip = TRUE;

      /* We skip all but the first TOC anchor.  */
      if (! skip
	  && isymp->n_sclass == C_HIDEXT
	  && aux.x_csect.x_smclas == XMC_TC0)
d4805 5
a4809 6
	  if (finfo->toc_symindx != -1)
	    skip = TRUE;
	  else
	    {
	      bfd_vma tocval, tocend;
	      bfd *inp;
d4811 3
a4813 4
	      tocval = ((*csectpp)->output_section->vma
			+ (*csectpp)->output_offset
			+ isym.n_value
			- (*csectpp)->vma);
d4815 6
a4820 12
	      /* We want to find out if tocval is a good value to use
		 as the TOC anchor--that is, whether we can access all
		 of the TOC using a 16 bit offset from tocval.  This
		 test assumes that the TOC comes at the end of the
		 output section, as it does in the default linker
		 script.  */
	      tocend = ((*csectpp)->output_section->vma
			+ (*csectpp)->output_section->size);
	      for (inp = finfo->info->input_bfds;
		   inp != NULL;
		   inp = inp->link_next)
		{
d4822 8
a4829 10
		  for (o = inp->sections; o != NULL; o = o->next)
		    if (strcmp (o->name, ".tocbss") == 0)
		      {
			bfd_vma new_toc_end;
			new_toc_end = (o->output_section->vma
				       + o->output_offset
				       + o->size);
			if (new_toc_end > tocend)
			  tocend = new_toc_end;
		      }
d4831 5
a4835 1
		}
d4837 2
a4838 8
	      if (tocval + 0x10000 < tocend)
		{
		  (*_bfd_error_handler)
		    (_("TOC overflow: 0x%lx > 0x10000; try -mminimal-toc when compiling"),
		     (unsigned long) (tocend - tocval));
		  bfd_set_error (bfd_error_file_too_big);
		  return FALSE;
		}
d4840 4
a4843 3
	      if (tocval + 0x8000 < tocend)
		{
		  bfd_vma tocadd;
d4845 13
a4857 10
		  tocadd = tocend - (tocval + 0x8000);
		  tocval += tocadd;
		  isym.n_value += tocadd;
		}

	      finfo->toc_symindx = output_index;
	      xcoff_data (finfo->output_bfd)->toc = tocval;
	      xcoff_data (finfo->output_bfd)->sntoc =
		(*csectpp)->output_section->target_index;
	      require = TRUE;
d4859 1
d4862 6
d4869 20
a4888 4
      /* If we are stripping all symbols, we want to skip this one.  */
      if (! skip
	  && finfo->info->strip == strip_all)
	skip = TRUE;
d4890 12
a4901 6
      /* We can skip resolved external references.  */
      if (! skip
	  && isym.n_sclass == C_EXT
	  && smtyp == XTY_ER
	  && (*sym_hash)->root.type != bfd_link_hash_undefined)
	skip = TRUE;
d4903 4
a4906 10
      /* We can skip common symbols if they got defined somewhere
	 else.  */
      if (! skip
	  && isym.n_sclass == C_EXT
	  && smtyp == XTY_CM
	  && ((*sym_hash)->root.type != bfd_link_hash_common
	      || (*sym_hash)->root.u.c.p->section != *csectpp)
	  && ((*sym_hash)->root.type != bfd_link_hash_defined
	      || (*sym_hash)->root.u.def.section != *csectpp))
	skip = TRUE;
d4908 5
a4912 7
      /* Skip local symbols if we are discarding them.  */
      if (! skip
	  && finfo->info->discard == discard_all
	  && isym.n_sclass != C_EXT
	  && (isym.n_sclass != C_HIDEXT
	      || smtyp != XTY_SD))
	skip = TRUE;
d4914 9
a4922 6
      /* If we stripping debugging symbols, and this is a debugging
	 symbol, then skip it.  */
      if (! skip
	  && finfo->info->strip == strip_debugger
	  && isym.n_scnum == N_DEBUG)
	skip = TRUE;
d4924 8
a4931 9
      /* If some symbols are stripped based on the name, work out the
	 name and decide whether to skip this symbol.  We don't handle
	 this correctly for symbols whose names are in the .debug
	 section; to get it right we would need a new bfd_strtab_hash
	 function to return the string given the index.  */
      if (! skip
	  && (finfo->info->strip == strip_some
	      || finfo->info->discard == discard_l)
	  && (debug_index == NULL || *debug_index == (unsigned long) -1))
d4933 11
a4943 2
	  const char *name;
	  char buf[SYMNMLEN + 1];
d4945 26
a4970 1
	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
d4972 2
a4973 2
	  if (name == NULL)
	    return FALSE;
d4975 10
a4984 10
	  if ((finfo->info->strip == strip_some
	       && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
				    FALSE) == NULL))
	      || (finfo->info->discard == discard_l
		  && (isym.n_sclass != C_EXT
		      && (isym.n_sclass != C_HIDEXT
			  || smtyp != XTY_SD))
		  && bfd_is_local_label_name (input_bfd, name)))
	    skip = TRUE;
	}
d4986 8
a4993 8
      /* We can not skip the first TOC anchor.  */
      if (skip
	  && require
	  && finfo->info->strip != strip_all)
	skip = FALSE;

      /* We now know whether we are to skip this symbol or not.  */
      if (! skip)
d4995 12
a5006 1
	  /* Adjust the symbol in order to output it.  */
d5008 5
a5012 12
	  if (isym._n._n_n._n_zeroes == 0
	      && isym._n._n_n._n_offset != 0)
	    {
	      /* This symbol has a long name.  Enter it in the string
		 table we are building.  If *debug_index != -1, the
		 name has already been entered in the .debug section.  */
	      if (debug_index != NULL && *debug_index != (unsigned long) -1)
		isym._n._n_n._n_offset = *debug_index;
	      else
		{
		  const char *name;
		  bfd_size_type indx;
d5014 9
a5022 2
		  name = _bfd_coff_internal_syment_name (input_bfd, &isym,
							 (char *) NULL);
d5024 6
a5029 8
		  if (name == NULL)
		    return FALSE;
		  indx = _bfd_stringtab_add (finfo->strtab, name, hash, copy);
		  if (indx == (bfd_size_type) -1)
		    return FALSE;
		  isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
		}
	    }
d5031 1
a5031 10
	  if (isym.n_sclass != C_BSTAT
	      && isym.n_sclass != C_ESTAT
	      && isym.n_sclass != C_DECL
	      && isym.n_scnum > 0)
	    {
	      isym.n_scnum = (*csectpp)->output_section->target_index;
	      isym.n_value += ((*csectpp)->output_section->vma
			       + (*csectpp)->output_offset
			       - (*csectpp)->vma);
	    }
d5033 1
a5033 28
	  /* The value of a C_FILE symbol is the symbol index of the
	     next C_FILE symbol.  The value of the last C_FILE symbol
	     is -1.  We try to get this right, below, just before we
	     write the symbols out, but in the general case we may
	     have to write the symbol out twice.  */
	  if (isym.n_sclass == C_FILE)
	    {
	      if (finfo->last_file_index != -1
		  && finfo->last_file.n_value != (bfd_vma) output_index)
		{
		  /* We must correct the value of the last C_FILE entry.  */
		  finfo->last_file.n_value = output_index;
		  if ((bfd_size_type) finfo->last_file_index >= syment_base)
		    {
		      /* The last C_FILE symbol is in this input file.  */
		      bfd_coff_swap_sym_out (output_bfd,
					     (PTR) &finfo->last_file,
					     (PTR) (finfo->outsyms
						    + ((finfo->last_file_index
							- syment_base)
						       * osymesz)));
		    }
		  else
		    {
		      /* We have already written out the last C_FILE
			 symbol.  We need to write it out again.  We
			 borrow *outsym temporarily.  */
		      file_ptr pos;
d5035 4
a5038 3
		      bfd_coff_swap_sym_out (output_bfd,
					     (PTR) &finfo->last_file,
					     (PTR) outsym);
d5040 22
a5061 8
		      pos = obj_sym_filepos (output_bfd);
		      pos += finfo->last_file_index * osymesz;
		      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
			  || (bfd_bwrite (outsym, osymesz, output_bfd)
			      != osymesz))
			return FALSE;
		    }
		}
d5063 9
a5071 3
	      finfo->last_file_index = output_index;
	      finfo->last_file = isym;
	    }
d5073 5
a5077 5
	  /* The value of a C_BINCL or C_EINCL symbol is a file offset
	     into the line numbers.  We update the symbol values when
	     we handle the line numbers.  */
	  if (isym.n_sclass == C_BINCL
	      || isym.n_sclass == C_EINCL)
d5079 5
a5083 2
	      isym.n_value = finfo->line_filepos;
	      ++incls;
d5085 13
d5099 2
a5100 1
	  /* Output the symbol.  */
d5102 2
a5103 1
	  bfd_coff_swap_sym_out (output_bfd, (PTR) &isym, (PTR) outsym);
d5105 4
a5108 1
	  *indexp = output_index;
d5110 6
a5115 4
	  if (isym.n_sclass == C_EXT)
	    {
	      long indx;
	      struct xcoff_link_hash_entry *h;
d5117 3
a5119 6
	      indx = ((esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
		      / isymesz);
	      h = obj_xcoff_sym_hashes (input_bfd)[indx];
	      BFD_ASSERT (h != NULL);
	      h->indx = output_index;
	    }
d5121 6
a5126 11
	  /* If this is a symbol in the TOC which we may have merged
	     (class XMC_TC), remember the symbol index of the TOC
	     symbol.  */
	  if (isym.n_sclass == C_HIDEXT
	      && aux.x_csect.x_smclas == XMC_TC
	      && *sym_hash != NULL)
	    {
	      BFD_ASSERT (((*sym_hash)->flags & XCOFF_SET_TOC) == 0);
	      BFD_ASSERT ((*sym_hash)->toc_section != NULL);
	      (*sym_hash)->u.toc_indx = output_index;
	    }
d5128 8
a5135 3
	  output_index += add;
	  outsym += add * osymesz;
	}
d5137 2
a5138 10
      esym += add * isymesz;
      isymp += add;
      csectpp += add;
      sym_hash += add;
      if (debug_index != NULL)
	debug_index += add;
      ++indexp;
      for (--add; add > 0; --add)
	*indexp++ = -1;
    }
d5140 1
a5140 4
  /* Fix up the aux entries and the C_BSTAT symbols.  This must be
     done in a separate pass, because we don't know the correct symbol
     indices until we have already decided which symbols we are going
     to keep.  */
d5142 14
a5155 640
  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
  isymp = finfo->internal_syms;
  indexp = finfo->sym_indices;
  csectpp = xcoff_data (input_bfd)->csects;
  outsym = finfo->outsyms;
  while (esym < esym_end)
    {
      int add;

      add = 1 + isymp->n_numaux;

      if (*indexp < 0)
	esym += add * isymesz;
      else
	{
	  int i;

	  if (isymp->n_sclass == C_BSTAT)
	    {
	      struct internal_syment isym;

	      bfd_vma indx;

	      /* The value of a C_BSTAT symbol is the symbol table
		 index of the containing csect.  */
	      bfd_coff_swap_sym_in (output_bfd, (PTR) outsym, (PTR) &isym);
	      indx = isym.n_value;
	      if (indx < obj_raw_syment_count (input_bfd))
		{
		  long symindx;

		  symindx = finfo->sym_indices[indx];
		  if (symindx < 0)
		    isym.n_value = 0;
		  else
		    isym.n_value = symindx;
		  bfd_coff_swap_sym_out (output_bfd, (PTR) &isym,
					 (PTR) outsym);
		}
	    }

	  esym += isymesz;
	  outsym += osymesz;

	  for (i = 0; i < isymp->n_numaux && esym < esym_end; i++)
	    {
	      union internal_auxent aux;

	      bfd_coff_swap_aux_in (input_bfd, (PTR) esym, isymp->n_type,
				    isymp->n_sclass, i, isymp->n_numaux,
				    (PTR) &aux);

	      if (isymp->n_sclass == C_FILE)
		{
		  /* This is the file name (or some comment put in by
		     the compiler).  If it is long, we must put it in
		     the string table.  */
		  if (aux.x_file.x_n.x_zeroes == 0
		      && aux.x_file.x_n.x_offset != 0)
		    {
		      const char *filename;
		      bfd_size_type indx;

		      BFD_ASSERT (aux.x_file.x_n.x_offset
				  >= STRING_SIZE_SIZE);
		      if (strings == NULL)
			{
			  strings = _bfd_coff_read_string_table (input_bfd);
			  if (strings == NULL)
			    return FALSE;
			}
		      filename = strings + aux.x_file.x_n.x_offset;
		      indx = _bfd_stringtab_add (finfo->strtab, filename,
						 hash, copy);
		      if (indx == (bfd_size_type) -1)
			return FALSE;
		      aux.x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;
		    }
		}
	      else if ((isymp->n_sclass == C_EXT
			|| isymp->n_sclass == C_HIDEXT)
		       && i + 1 == isymp->n_numaux)
		{

		  /* We don't support type checking.  I don't know if
		     anybody does.  */
		  aux.x_csect.x_parmhash = 0;
		  /* I don't think anybody uses these fields, but we'd
		     better clobber them just in case.  */
		  aux.x_csect.x_stab = 0;
		  aux.x_csect.x_snstab = 0;

		  if (SMTYP_SMTYP (aux.x_csect.x_smtyp) == XTY_LD)
		    {
		      unsigned long indx;

		      indx = aux.x_csect.x_scnlen.l;
		      if (indx < obj_raw_syment_count (input_bfd))
			{
			  long symindx;

			  symindx = finfo->sym_indices[indx];
			  if (symindx < 0)
			    {
			      aux.x_csect.x_scnlen.l = 0;
			    }
			  else
			    {
			      aux.x_csect.x_scnlen.l = symindx;
			    }
			}
		    }
		}
	      else if (isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
		{
		  unsigned long indx;

		  if (ISFCN (isymp->n_type)
		      || ISTAG (isymp->n_sclass)
		      || isymp->n_sclass == C_BLOCK
		      || isymp->n_sclass == C_FCN)
		    {
		      indx = aux.x_sym.x_fcnary.x_fcn.x_endndx.l;
		      if (indx > 0
			  && indx < obj_raw_syment_count (input_bfd))
			{
			  /* We look forward through the symbol for
			     the index of the next symbol we are going
			     to include.  I don't know if this is
			     entirely right.  */
			  while (finfo->sym_indices[indx] < 0
				 && indx < obj_raw_syment_count (input_bfd))
			    ++indx;
			  if (indx >= obj_raw_syment_count (input_bfd))
			    indx = output_index;
			  else
			    indx = finfo->sym_indices[indx];
			  aux.x_sym.x_fcnary.x_fcn.x_endndx.l = indx;

			}
		    }

		  indx = aux.x_sym.x_tagndx.l;
		  if (indx > 0 && indx < obj_raw_syment_count (input_bfd))
		    {
		      long symindx;

		      symindx = finfo->sym_indices[indx];
		      if (symindx < 0)
			aux.x_sym.x_tagndx.l = 0;
		      else
			aux.x_sym.x_tagndx.l = symindx;
		    }

		}

	      /* Copy over the line numbers, unless we are stripping
		 them.  We do this on a symbol by symbol basis in
		 order to more easily handle garbage collection.  */
	      if ((isymp->n_sclass == C_EXT
		   || isymp->n_sclass == C_HIDEXT)
		  && i == 0
		  && isymp->n_numaux > 1
		  && ISFCN (isymp->n_type)
		  && aux.x_sym.x_fcnary.x_fcn.x_lnnoptr != 0)
		{
		  if (finfo->info->strip != strip_none
		      && finfo->info->strip != strip_some)
		    aux.x_sym.x_fcnary.x_fcn.x_lnnoptr = 0;
		  else
		    {
		      asection *enclosing;
		      unsigned int enc_count;
		      bfd_signed_vma linoff;
		      struct internal_lineno lin;

		      o = *csectpp;
		      enclosing = xcoff_section_data (abfd, o)->enclosing;
		      enc_count = xcoff_section_data (abfd, o)->lineno_count;
		      if (oline != enclosing)
			{
			  file_ptr pos = enclosing->line_filepos;
			  bfd_size_type amt = linesz * enc_count;
			  if (bfd_seek (input_bfd, pos, SEEK_SET) != 0
			      || (bfd_bread (finfo->linenos, amt, input_bfd)
				  != amt))
			    return FALSE;
			  oline = enclosing;
			}

		      linoff = (aux.x_sym.x_fcnary.x_fcn.x_lnnoptr
				- enclosing->line_filepos);

		      bfd_coff_swap_lineno_in (input_bfd,
					       (PTR) (finfo->linenos + linoff),
					       (PTR) &lin);
		      if (lin.l_lnno != 0
			  || ((bfd_size_type) lin.l_addr.l_symndx
			      != ((esym
				   - isymesz
				   - ((bfd_byte *)
				      obj_coff_external_syms (input_bfd)))
				  / isymesz)))
			aux.x_sym.x_fcnary.x_fcn.x_lnnoptr = 0;
		      else
			{
			  bfd_byte *linpend, *linp;
			  bfd_vma offset;
			  bfd_size_type count;

			  lin.l_addr.l_symndx = *indexp;
			  bfd_coff_swap_lineno_out (output_bfd, (PTR) &lin,
						    (PTR) (finfo->linenos
							   + linoff));

			  linpend = (finfo->linenos
				     + enc_count * linesz);
			  offset = (o->output_section->vma
				    + o->output_offset
				    - o->vma);
			  for (linp = finfo->linenos + linoff + linesz;
			       linp < linpend;
			       linp += linesz)
			    {
			      bfd_coff_swap_lineno_in (input_bfd, (PTR) linp,
						       (PTR) &lin);
			      if (lin.l_lnno == 0)
				break;
			      lin.l_addr.l_paddr += offset;
			      bfd_coff_swap_lineno_out (output_bfd,
							(PTR) &lin,
							(PTR) linp);
			    }

			  count = (linp - (finfo->linenos + linoff)) / linesz;

			  aux.x_sym.x_fcnary.x_fcn.x_lnnoptr =
			    (o->output_section->line_filepos
			     + o->output_section->lineno_count * linesz);

			  if (bfd_seek (output_bfd,
					aux.x_sym.x_fcnary.x_fcn.x_lnnoptr,
					SEEK_SET) != 0
			      || (bfd_bwrite (finfo->linenos + linoff,
					     linesz * count, output_bfd)
				  != linesz * count))
			    return FALSE;

			  o->output_section->lineno_count += count;

			  if (incls > 0)
			    {
			      struct internal_syment *iisp, *iispend;
			      long *iindp;
			      bfd_byte *oos;
			      int iiadd;

			      /* Update any C_BINCL or C_EINCL symbols
				 that refer to a line number in the
				 range we just output.  */
			      iisp = finfo->internal_syms;
			      iispend = (iisp
					 + obj_raw_syment_count (input_bfd));
			      iindp = finfo->sym_indices;
			      oos = finfo->outsyms;
			      while (iisp < iispend)
				{
				  if (*iindp >= 0
				      && (iisp->n_sclass == C_BINCL
					  || iisp->n_sclass == C_EINCL)
				      && ((bfd_size_type) iisp->n_value
					  >= (bfd_size_type)(enclosing->line_filepos + linoff))
				      && ((bfd_size_type) iisp->n_value
					  < (enclosing->line_filepos
					     + enc_count * linesz)))
				    {
				      struct internal_syment iis;

				      bfd_coff_swap_sym_in (output_bfd,
							    (PTR) oos,
							    (PTR) &iis);
				      iis.n_value =
					(iisp->n_value
					 - enclosing->line_filepos
					 - linoff
					 + aux.x_sym.x_fcnary.x_fcn.x_lnnoptr);
				      bfd_coff_swap_sym_out (output_bfd,
							     (PTR) &iis,
							     (PTR) oos);
				      --incls;
				    }

				  iiadd = 1 + iisp->n_numaux;
				  if (*iindp >= 0)
				    oos += iiadd * osymesz;
				  iisp += iiadd;
				  iindp += iiadd;
				}
			    }
			}
		    }
		}

	      bfd_coff_swap_aux_out (output_bfd, (PTR) &aux, isymp->n_type,
				     isymp->n_sclass, i, isymp->n_numaux,
				     (PTR) outsym);
	      outsym += osymesz;
	      esym += isymesz;
	    }
	}

      indexp += add;
      isymp += add;
      csectpp += add;
    }

  /* If we swapped out a C_FILE symbol, guess that the next C_FILE
     symbol will be the first symbol in the next input file.  In the
     normal case, this will save us from writing out the C_FILE symbol
     again.  */
  if (finfo->last_file_index != -1
      && (bfd_size_type) finfo->last_file_index >= syment_base)
    {
      finfo->last_file.n_value = output_index;
      bfd_coff_swap_sym_out (output_bfd, (PTR) &finfo->last_file,
			     (PTR) (finfo->outsyms
 				    + ((finfo->last_file_index - syment_base)
 				       * osymesz)));
    }

  /* Write the modified symbols to the output file.  */
  if (outsym > finfo->outsyms)
    {
      file_ptr pos = obj_sym_filepos (output_bfd) + syment_base * osymesz;
      bfd_size_type amt = outsym - finfo->outsyms;
      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
	return FALSE;

      BFD_ASSERT ((obj_raw_syment_count (output_bfd)
		   + (outsym - finfo->outsyms) / osymesz)
		  == output_index);

      obj_raw_syment_count (output_bfd) = output_index;
    }

  /* Don't let the linker relocation routines discard the symbols.  */
  keep_syms = obj_coff_keep_syms (input_bfd);
  obj_coff_keep_syms (input_bfd) = TRUE;

  /* Relocate the contents of each section.  */
  for (o = input_bfd->sections; o != NULL; o = o->next)
    {

      bfd_byte *contents;

      if (! o->linker_mark)
	{
	  /* This section was omitted from the link.  */
	  continue;
	}

      if ((o->flags & SEC_HAS_CONTENTS) == 0
	  || o->size == 0
	  || (o->flags & SEC_IN_MEMORY) != 0)
	continue;

      /* We have set filepos correctly for the sections we created to
	 represent csects, so bfd_get_section_contents should work.  */
      if (coff_section_data (input_bfd, o) != NULL
	  && coff_section_data (input_bfd, o)->contents != NULL)
	contents = coff_section_data (input_bfd, o)->contents;
      else
	{
	  bfd_size_type sz = o->rawsize ? o->rawsize : o->size;
	  if (!bfd_get_section_contents (input_bfd, o, finfo->contents, 0, sz))
	    return FALSE;
	  contents = finfo->contents;
	}

      if ((o->flags & SEC_RELOC) != 0)
	{
	  int target_index;
	  struct internal_reloc *internal_relocs;
	  struct internal_reloc *irel;
	  bfd_vma offset;
	  struct internal_reloc *irelend;
	  struct xcoff_link_hash_entry **rel_hash;
	  long r_symndx;

	  /* Read in the relocs.  */
	  target_index = o->output_section->target_index;
	  internal_relocs = (xcoff_read_internal_relocs
			     (input_bfd, o, FALSE, finfo->external_relocs,
			      TRUE,
			      (finfo->section_info[target_index].relocs
			       + o->output_section->reloc_count)));
	  if (internal_relocs == NULL)
	    return FALSE;

	  /* Call processor specific code to relocate the section
	     contents.  */
	  if (! bfd_coff_relocate_section (output_bfd, finfo->info,
					   input_bfd, o,
					   contents,
					   internal_relocs,
					   finfo->internal_syms,
					   xcoff_data (input_bfd)->csects))
	    return FALSE;

	  offset = o->output_section->vma + o->output_offset - o->vma;
	  irel = internal_relocs;
	  irelend = irel + o->reloc_count;
	  rel_hash = (finfo->section_info[target_index].rel_hashes
		      + o->output_section->reloc_count);
	  for (; irel < irelend; irel++, rel_hash++)
	    {
	      struct xcoff_link_hash_entry *h = NULL;
	      struct internal_ldrel ldrel;
	      bfd_boolean quiet;

	      *rel_hash = NULL;

	      /* Adjust the reloc address and symbol index.  */

	      irel->r_vaddr += offset;

	      r_symndx = irel->r_symndx;

	      if (r_symndx == -1)
		h = NULL;
	      else
		h = obj_xcoff_sym_hashes (input_bfd)[r_symndx];

	      if (r_symndx != -1 && finfo->info->strip != strip_all)
		{
		  if (h != NULL
		      && h->smclas != XMC_TD
		      && (irel->r_type == R_TOC
			  || irel->r_type == R_GL
			  || irel->r_type == R_TCL
			  || irel->r_type == R_TRL
			  || irel->r_type == R_TRLA))
		    {
		      /* This is a TOC relative reloc with a symbol
			 attached.  The symbol should be the one which
			 this reloc is for.  We want to make this
			 reloc against the TOC address of the symbol,
			 not the symbol itself.  */
		      BFD_ASSERT (h->toc_section != NULL);
		      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
		      if (h->u.toc_indx != -1)
			irel->r_symndx = h->u.toc_indx;
		      else
			{
			  struct xcoff_toc_rel_hash *n;
			  struct xcoff_link_section_info *si;
			  bfd_size_type amt;

			  amt = sizeof (struct xcoff_toc_rel_hash);
			  n = ((struct xcoff_toc_rel_hash *)
			       bfd_alloc (finfo->output_bfd, amt));
			  if (n == NULL)
			    return FALSE;
			  si = finfo->section_info + target_index;
			  n->next = si->toc_rel_hashes;
			  n->h = h;
			  n->rel = irel;
			  si->toc_rel_hashes = n;
			}
		    }
		  else if (h != NULL)
		    {
		      /* This is a global symbol.  */
		      if (h->indx >= 0)
			irel->r_symndx = h->indx;
		      else
			{
			  /* This symbol is being written at the end
			     of the file, and we do not yet know the
			     symbol index.  We save the pointer to the
			     hash table entry in the rel_hash list.
			     We set the indx field to -2 to indicate
			     that this symbol must not be stripped.  */
			  *rel_hash = h;
			  h->indx = -2;
			}
		    }
		  else
		    {
		      long indx;

		      indx = finfo->sym_indices[r_symndx];

		      if (indx == -1)
			{
			  struct internal_syment *is;

			  /* Relocations against a TC0 TOC anchor are
			     automatically transformed to be against
			     the TOC anchor in the output file.  */
			  is = finfo->internal_syms + r_symndx;
			  if (is->n_sclass == C_HIDEXT
			      && is->n_numaux > 0)
			    {
			      PTR auxptr;
			      union internal_auxent aux;

			      auxptr = ((PTR)
					(((bfd_byte *)
					  obj_coff_external_syms (input_bfd))
					 + ((r_symndx + is->n_numaux)
					    * isymesz)));
			      bfd_coff_swap_aux_in (input_bfd, auxptr,
						    is->n_type, is->n_sclass,
						    is->n_numaux - 1,
						    is->n_numaux,
						    (PTR) &aux);
			      if (SMTYP_SMTYP (aux.x_csect.x_smtyp) == XTY_SD
				  && aux.x_csect.x_smclas == XMC_TC0)
				indx = finfo->toc_symindx;
			    }
			}

		      if (indx != -1)
			irel->r_symndx = indx;
		      else
			{

			  struct internal_syment *is;

			  const char *name;
			  char buf[SYMNMLEN + 1];

			  /* This reloc is against a symbol we are
			     stripping.  It would be possible to handle
			     this case, but I don't think it's worth it.  */
			  is = finfo->internal_syms + r_symndx;

			  name = (_bfd_coff_internal_syment_name
				  (input_bfd, is, buf));

			  if (name == NULL)
			    return FALSE;

			  if (! ((*finfo->info->callbacks->unattached_reloc)
				 (finfo->info, name, input_bfd, o,
				  irel->r_vaddr)))
			    return FALSE;
			}
		    }
		}

	      quiet = FALSE;
	      switch (irel->r_type)
		{
		default:
		  if (h == NULL
		      || h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak
		      || h->root.type == bfd_link_hash_common)
		    break;
		  /* Fall through.  */
		case R_POS:
		case R_NEG:
		case R_RL:
		case R_RLA:
		  /* This reloc needs to be copied into the .loader
		     section.  */
		  ldrel.l_vaddr = irel->r_vaddr;
		  if (r_symndx == -1)
		    ldrel.l_symndx = -(bfd_size_type ) 1;
		  else if (h == NULL
			   || (h->root.type == bfd_link_hash_defined
			       || h->root.type == bfd_link_hash_defweak
			       || h->root.type == bfd_link_hash_common))
		    {
		      asection *sec;

		      if (h == NULL)
			sec = xcoff_data (input_bfd)->csects[r_symndx];
		      else if (h->root.type == bfd_link_hash_common)
			sec = h->root.u.c.p->section;
		      else
			sec = h->root.u.def.section;
		      sec = sec->output_section;

		      if (strcmp (sec->name, ".text") == 0)
			ldrel.l_symndx = 0;
		      else if (strcmp (sec->name, ".data") == 0)
			ldrel.l_symndx = 1;
		      else if (strcmp (sec->name, ".bss") == 0)
			ldrel.l_symndx = 2;
		      else
			{
			  (*_bfd_error_handler)
			    (_("%B: loader reloc in unrecognized section `%A'"),
			     input_bfd, sec);
			  bfd_set_error (bfd_error_nonrepresentable_section);
			  return FALSE;
			}
		    }
		  else
		    {
		      if (! finfo->info->relocatable
			  && (h->flags & XCOFF_DEF_DYNAMIC) == 0
			  && (h->flags & XCOFF_IMPORT) == 0)
			{
			  /* We already called the undefined_symbol
			     callback for this relocation, in
			     _bfd_ppc_xcoff_relocate_section.  Don't
			     issue any more warnings.  */
			  quiet = TRUE;
			}
		      if (h->ldindx < 0 && ! quiet)
			{
			  (*_bfd_error_handler)
			    (_("%B: `%s' in loader reloc but not loader sym"),
			     input_bfd,
			     h->root.root.string);
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      ldrel.l_symndx = h->ldindx;
		    }
		  ldrel.l_rtype = (irel->r_size << 8) | irel->r_type;
		  ldrel.l_rsecnm = o->output_section->target_index;
		  if (xcoff_hash_table (finfo->info)->textro
		      && strcmp (o->output_section->name, ".text") == 0
		      && ! quiet)
		    {
		      (*_bfd_error_handler)
			(_("%B: loader reloc in read-only section %A"),
			 input_bfd, o->output_section);
		      bfd_set_error (bfd_error_invalid_operation);
		      return FALSE;
		    }
		  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel,
					    finfo->ldrel);
d5157 6
a5162 2
		  finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
		  break;
d5164 6
a5169 10
		case R_TOC:
		case R_GL:
		case R_TCL:
		case R_TRL:
		case R_TRLA:
		  /* We should never need a .loader reloc for a TOC
		     relative reloc.  */
		  break;
		}
	    }
d5171 8
a5178 7
	  o->output_section->reloc_count += o->reloc_count;
	}

      /* Write out the modified section contents.  */
      if (! bfd_set_section_contents (output_bfd, o->output_section,
				      contents, (file_ptr) o->output_offset,
				      o->size))
d5180 1
d5183 12
a5194 3
  obj_coff_keep_syms (input_bfd) = keep_syms;

  if (! finfo->info->keep_memory)
d5196 2
a5197 2
      if (! _bfd_coff_free_symbols (input_bfd))
	return FALSE;
d5200 12
a5211 2
  return TRUE;
}
d5213 4
a5216 2
#undef N_TMASK
#undef N_BTSHFT
d5218 24
a5241 1
/* Write out a non-XCOFF global symbol.  */
d5243 6
d5250 2
a5251 13
static bfd_boolean
xcoff_write_global_symbol (h, inf)
     struct xcoff_link_hash_entry *h;
     PTR inf;
{
  struct xcoff_final_link_info *finfo = (struct xcoff_final_link_info *) inf;
  bfd *output_bfd;
  bfd_byte *outsym;
  struct internal_syment isym;
  union internal_auxent aux;
  bfd_boolean result;
  file_ptr pos;
  bfd_size_type amt;
d5253 1
a5253 2
  output_bfd = finfo->output_bfd;
  outsym = finfo->outsyms;
d5255 3
a5257 1
  if (h->root.type == bfd_link_hash_warning)
d5259 4
a5262 3
      h = (struct xcoff_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
d5265 4
a5268 4
  /* If this symbol was garbage collected, just skip it.  */
  if (xcoff_hash_table (finfo->info)->gc
      && (h->flags & XCOFF_MARK) == 0)
    return TRUE;
d5270 1
a5270 5
  /* If we need a .loader section entry, write it out.  */
  if (h->ldsym != NULL)
    {
      struct internal_ldsym *ldsym;
      bfd *impbfd;
d5272 1
a5272 1
      ldsym = h->ldsym;
d5274 1
a5274 3
      if (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	{
d5276 3
a5278 4
	  ldsym->l_value = 0;
	  ldsym->l_scnum = N_UNDEF;
	  ldsym->l_smtype = XTY_ER;
	  impbfd = h->root.u.undef.abfd;
d5280 1
a5280 4
	}
      else if (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	{
d5282 6
a5287 11
	  asection *sec;

	  sec = h->root.u.def.section;
	  ldsym->l_value = (sec->output_section->vma
			    + sec->output_offset
			    + h->root.u.def.value);
	  ldsym->l_scnum = sec->output_section->target_index;
	  ldsym->l_smtype = XTY_SD;
	  impbfd = sec->owner;

	}
a5288 5
	abort ();

      if (((h->flags & XCOFF_DEF_REGULAR) == 0
	   && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	  || (h->flags & XCOFF_IMPORT) != 0)
d5290 5
a5294 5
	  /* Clear l_smtype
	     Import symbols are defined so the check above will make
	     the l_smtype XTY_SD.  But this is not correct, it should
	     be cleared.  */
	  ldsym->l_smtype |= L_IMPORT;
d5296 4
a5299 4

      if (((h->flags & XCOFF_DEF_REGULAR) != 0
	   && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	  || (h->flags & XCOFF_EXPORT) != 0)
d5301 6
a5306 1
	  ldsym->l_smtype |= L_EXPORT;
d5308 10
d5319 1
a5319 4
      if ((h->flags & XCOFF_ENTRY) != 0)
	{
	  ldsym->l_smtype |= L_ENTRY;
	}
d5321 21
a5341 4
      if ((h->flags & XCOFF_RTINIT) != 0)
	{
	  ldsym->l_smtype = XTY_SD;
	}
d5343 2
a5344 1
      ldsym->l_smclas = h->smclas;
d5346 1
a5346 22
      if (ldsym->l_smtype & L_IMPORT)
	{
	  if ((h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	      && (h->root.u.def.value != 0))
	    {
	      ldsym->l_smclas = XMC_XO;
	    }
	  else if ((h->flags & (XCOFF_SYSCALL32 | XCOFF_SYSCALL64)) ==
		   (XCOFF_SYSCALL32 | XCOFF_SYSCALL64))
	    {
	      ldsym->l_smclas = XMC_SV3264;
	    }
	  else if (h->flags & XCOFF_SYSCALL32)
	    {
	      ldsym->l_smclas = XMC_SV;
	    }
	  else if (h->flags & XCOFF_SYSCALL64)
	    {
	      ldsym->l_smclas = XMC_SV64;
	    }
	}
d5348 12
a5359 20
      if (ldsym->l_ifile == -(bfd_size_type) 1)
	{
	  ldsym->l_ifile = 0;
	}
      else if (ldsym->l_ifile == 0)
	{
	  if ((ldsym->l_smtype & L_IMPORT) == 0)
	    {
	      ldsym->l_ifile = 0;
	    }
	  else if (impbfd == NULL)
	    {
	      ldsym->l_ifile = 0;
	    }
	  else
	    {
	      BFD_ASSERT (impbfd->xvec == output_bfd->xvec);
	      ldsym->l_ifile = xcoff_data (impbfd)->import_file_id;
	    }
	}
d5361 6
a5366 1
      ldsym->l_parm = 0;
d5368 1
a5368 1
      BFD_ASSERT (h->ldindx >= 0);
d5370 3
a5372 6
      bfd_xcoff_swap_ldsym_out (output_bfd, ldsym,
				(finfo->ldsym +
				 (h->ldindx - 3)
				 * bfd_xcoff_ldsymsz(finfo->output_bfd)));
      h->ldsym = NULL;
    }
d5374 6
a5379 4
  /* If this symbol needs global linkage code, write it out.  */
  if (h->root.type == bfd_link_hash_defined
      && (h->root.u.def.section
	  == xcoff_hash_table (finfo->info)->linkage_section))
d5381 7
a5387 3
      bfd_byte *p;
      bfd_vma tocoff;
      unsigned int i;
d5389 1
a5389 1
      p = h->root.u.def.section->contents + h->root.u.def.value;
d5391 5
a5395 5
      /* The first instruction in the global linkage code loads a
	 specific TOC element.  */
      tocoff = (h->descriptor->toc_section->output_section->vma
		+ h->descriptor->toc_section->output_offset
		- xcoff_data (output_bfd)->toc);
d5397 3
a5399 4
      if ((h->descriptor->flags & XCOFF_SET_TOC) != 0)
	{
	  tocoff += h->descriptor->u.toc_offset;
	}
d5401 1
d5403 18
a5420 14
      /* The first instruction in the glink code needs to be
	 cooked to to hold the correct offset in the toc.  The
	 rest are just output raw.  */
      bfd_put_32 (output_bfd,
		  bfd_xcoff_glink_code(output_bfd, 0) | (tocoff & 0xffff), p);

      /* Start with i == 1 to get past the first instruction done above
	 The /4 is because the glink code is in bytes and we are going
	 4 at a pop.  */
      for (i = 1; i < bfd_xcoff_glink_code_size(output_bfd) / 4; i++)
	{
	  bfd_put_32 (output_bfd,
		      (bfd_vma) bfd_xcoff_glink_code(output_bfd, i),
		      &p[4 * i]);
d5424 7
a5430 3
  /* If we created a TOC entry for this symbol, write out the required
     relocs.  */
  if ((h->flags & XCOFF_SET_TOC) != 0)
d5432 1
a5432 7
      asection *tocsec;
      asection *osec;
      int oindx;
      struct internal_reloc *irel;
      struct internal_ldrel ldrel;
      struct internal_syment irsym;
      union internal_auxent iraux;
d5434 2
a5435 10
      tocsec = h->toc_section;
      osec = tocsec->output_section;
      oindx = osec->target_index;
      irel = finfo->section_info[oindx].relocs + osec->reloc_count;
      irel->r_vaddr = (osec->vma
		       + tocsec->output_offset
		       + h->u.toc_offset);


      if (h->indx >= 0)
d5437 4
a5440 7
	  irel->r_symndx = h->indx;
	}
      else
	{
	  h->indx = -2;
	  irel->r_symndx = obj_raw_syment_count (output_bfd);
	}
d5442 16
a5457 1
      BFD_ASSERT (h->ldindx >= 0);
d5459 3
a5461 7
      /* Initialize the aux union here instead of closer to when it is
	 written out below because the length of the csect depends on
	 whether the output is 32 or 64 bit.  */
      memset (&iraux, 0, sizeof iraux);
      iraux.x_csect.x_smtyp = XTY_SD;
      /* iraux.x_csect.x_scnlen.l = 4 or 8, see below */
      iraux.x_csect.x_smclas = XMC_TC;
d5463 4
a5466 2
      /* 32 bit uses a 32 bit R_POS to do the relocations
	 64 bit uses a 64 bit R_POS to do the relocations
d5468 3
a5470 1
	 Also needs to change the csect size : 4 for 32 bit, 8 for 64 bit
d5472 5
a5476 18
	 Which one is determined by the backend.  */
      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  irel->r_size = 63;
	  iraux.x_csect.x_scnlen.l = 8;
	}
      else if (bfd_xcoff_is_xcoff32 (output_bfd))
	{
	  irel->r_size = 31;
	  iraux.x_csect.x_scnlen.l = 4;
	}
      else
	{
	  return FALSE;
	}
      irel->r_type = R_POS;
      finfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
      ++osec->reloc_count;
d5478 9
a5486 6
      ldrel.l_vaddr = irel->r_vaddr;
      ldrel.l_symndx = h->ldindx;
      ldrel.l_rtype = (irel->r_size << 8) | R_POS;
      ldrel.l_rsecnm = oindx;
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
d5488 14
a5501 9
      /* We need to emit a symbol to define a csect which holds
	 the reloc.  */
      if (finfo->info->strip != strip_all)
	{

	  result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab,
					      &irsym, h->root.root.string);
	  if (!result)
	    return FALSE;
d5503 1
a5503 15
	  irsym.n_value = irel->r_vaddr;
	  irsym.n_scnum = osec->target_index;
	  irsym.n_sclass = C_HIDEXT;
	  irsym.n_type = T_NULL;
	  irsym.n_numaux = 1;

	  bfd_coff_swap_sym_out (output_bfd, (PTR) &irsym, (PTR) outsym);
	  outsym += bfd_coff_symesz (output_bfd);

	  /* note : iraux is initialized above */
	  bfd_coff_swap_aux_out (output_bfd, (PTR) &iraux, T_NULL, C_HIDEXT,
				 0, 1, (PTR) outsym);
	  outsym += bfd_coff_auxesz (output_bfd);

	  if (h->indx >= 0)
d5505 3
a5507 11
	      /* We aren't going to write out the symbols below, so we
		 need to write them out now.  */
	      pos = obj_sym_filepos (output_bfd);
	      pos += (obj_raw_syment_count (output_bfd)
		      * bfd_coff_symesz (output_bfd));
	      amt = outsym - finfo->outsyms;
	      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
		  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
		return FALSE;
	      obj_raw_syment_count (output_bfd) +=
		(outsym - finfo->outsyms) / bfd_coff_symesz (output_bfd);
d5509 15
a5523 1
	      outsym = finfo->outsyms;
d5526 3
d5531 18
a5548 4
  /* If this symbol is a specially defined function descriptor, write
     it out.  The first word is the address of the function code
     itself, the second word is the address of the TOC, and the third
     word is zero.
d5550 5
a5554 9
     32 bit vs 64 bit
     The addresses for the 32 bit will take 4 bytes and the addresses
     for 64 bit will take 8 bytes.  Similar for the relocs.  This type
     of logic was also done above to create a TOC entry in
     xcoff_write_global_symbol.  */
  if ((h->flags & XCOFF_DESCRIPTOR) != 0
      && h->root.type == bfd_link_hash_defined
      && (h->root.u.def.section
	  == xcoff_hash_table (finfo->info)->descriptor_section))
d5556 2
a5557 21
      asection *sec;
      asection *osec;
      int oindx;
      bfd_byte *p;
      struct xcoff_link_hash_entry *hentry;
      asection *esec;
      struct internal_reloc *irel;
      struct internal_ldrel ldrel;
      asection *tsec;
      unsigned int reloc_size, byte_size;

      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  reloc_size = 63;
	  byte_size = 8;
	}
      else if (bfd_xcoff_is_xcoff32 (output_bfd))
	{
	  reloc_size = 31;
	  byte_size = 4;
	}
d5560 11
a5570 2
	  return FALSE;
	}
d5572 8
a5579 4
      sec = h->root.u.def.section;
      osec = sec->output_section;
      oindx = osec->target_index;
      p = sec->contents + h->root.u.def.value;
d5581 7
a5587 5
      hentry = h->descriptor;
      BFD_ASSERT (hentry != NULL
		  && (hentry->root.type == bfd_link_hash_defined
		      || hentry->root.type == bfd_link_hash_defweak));
      esec = hentry->root.u.def.section;
d5589 3
a5591 9
      irel = finfo->section_info[oindx].relocs + osec->reloc_count;
      irel->r_vaddr = (osec->vma
		       + sec->output_offset
		       + h->root.u.def.value);
      irel->r_symndx = esec->output_section->target_index;
      irel->r_type = R_POS;
      irel->r_size = reloc_size;
      finfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
      ++osec->reloc_count;
d5593 3
a5595 20
      ldrel.l_vaddr = irel->r_vaddr;
      if (strcmp (esec->output_section->name, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (esec->output_section->name, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (esec->output_section->name, ".bss") == 0)
	ldrel.l_symndx = 2;
      else
	{
	  (*_bfd_error_handler)
	    (_("%s: loader reloc in unrecognized section `%s'"),
	     bfd_get_filename (output_bfd),
	     esec->output_section->name);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
	}
      ldrel.l_rtype = (reloc_size << 8) | R_POS;
      ldrel.l_rsecnm = oindx;
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
d5597 2
a5598 25
      /* There are three items to write out,
	 the address of the code
	 the address of the toc anchor
	 the environment pointer.
	 We are ignoring the environment pointer.  So set it to zero.  */
      if (bfd_xcoff_is_xcoff64 (output_bfd))
	{
	  bfd_put_64 (output_bfd,
		      (esec->output_section->vma + esec->output_offset
		       + hentry->root.u.def.value),
		      p);
	  bfd_put_64 (output_bfd, xcoff_data (output_bfd)->toc, p + 8);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, p + 16);
	}
      else
	{
	  /* 32 bit backend
	     This logic was already called above so the error case where
	     the backend is neither has already been checked.  */
	  bfd_put_32 (output_bfd,
		      (esec->output_section->vma + esec->output_offset
		       + hentry->root.u.def.value),
		      p);
	  bfd_put_32 (output_bfd, xcoff_data (output_bfd)->toc, p + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) 0, p + 8);
d5600 1
d5602 9
a5610 21
      tsec = coff_section_from_bfd_index (output_bfd,
					  xcoff_data (output_bfd)->sntoc);

      ++irel;
      irel->r_vaddr = (osec->vma
		       + sec->output_offset
		       + h->root.u.def.value
		       + byte_size);
      irel->r_symndx = tsec->output_section->target_index;
      irel->r_type = R_POS;
      irel->r_size = reloc_size;
      finfo->section_info[oindx].rel_hashes[osec->reloc_count] = NULL;
      ++osec->reloc_count;

      ldrel.l_vaddr = irel->r_vaddr;
      if (strcmp (tsec->output_section->name, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (tsec->output_section->name, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (tsec->output_section->name, ".bss") == 0)
	ldrel.l_symndx = 2;
d5613 2
a5614 6
	  (*_bfd_error_handler)
	    (_("%s: loader reloc in unrecognized section `%s'"),
	     bfd_get_filename (output_bfd),
	     tsec->output_section->name);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
a5615 5
      ldrel.l_rtype = (reloc_size << 8) | R_POS;
      ldrel.l_rsecnm = oindx;
      bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
    }
d5617 4
a5620 4
  if (h->indx >= 0 || finfo->info->strip == strip_all)
    {
      BFD_ASSERT (outsym == finfo->outsyms);
      return TRUE;
d5623 8
a5630 5
  if (h->indx != -2
      && (finfo->info->strip == strip_all
	  || (finfo->info->strip == strip_some
	      && bfd_hash_lookup (finfo->info->keep_hash, h->root.root.string,
				  FALSE, FALSE) == NULL)))
d5632 6
a5637 2
      BFD_ASSERT (outsym == finfo->outsyms);
      return TRUE;
d5640 9
a5648 6
  if (h->indx != -2
      && (h->flags & (XCOFF_REF_REGULAR | XCOFF_DEF_REGULAR)) == 0)
    {
      BFD_ASSERT (outsym == finfo->outsyms);
      return TRUE;
    }
d5650 2
a5651 1
  memset (&aux, 0, sizeof aux);
d5653 2
a5654 1
  h->indx = obj_raw_syment_count (output_bfd);
d5656 2
a5657 4
  result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab, &isym,
				      h->root.root.string);
  if (!result)
    return FALSE;
d5659 7
a5665 22
  if (h->root.type == bfd_link_hash_undefined
      || h->root.type == bfd_link_hash_undefweak)
    {
      isym.n_value = 0;
      isym.n_scnum = N_UNDEF;
      isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_ER;
    }
  else if ((h->root.type == bfd_link_hash_defined
	    || h->root.type == bfd_link_hash_defweak)
	   && h->smclas == XMC_XO)
    {
      BFD_ASSERT (bfd_is_abs_section (h->root.u.def.section));
      isym.n_value = h->root.u.def.value;
      isym.n_scnum = N_UNDEF;
      isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_ER;
    }
  else if (h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
    {
      struct xcoff_link_size_list *l;
d5667 2
a5668 9
      isym.n_value = (h->root.u.def.section->output_section->vma
		      + h->root.u.def.section->output_offset
		      + h->root.u.def.value);
      if (bfd_is_abs_section (h->root.u.def.section->output_section))
	isym.n_scnum = N_ABS;
      else
	isym.n_scnum = h->root.u.def.section->output_section->target_index;
      isym.n_sclass = C_HIDEXT;
      aux.x_csect.x_smtyp = XTY_SD;
d5670 8
a5677 1
      if ((h->flags & XCOFF_HAS_SIZE) != 0)
d5679 2
a5680 3
	  for (l = xcoff_hash_table (finfo->info)->size_list;
	       l != NULL;
	       l = l->next)
d5682 2
a5683 1
	      if (l->h == h)
d5685 3
a5687 2
		  aux.x_csect.x_scnlen.l = l->size;
		  break;
d5690 11
d5703 23
a5725 1
  else if (h->root.type == bfd_link_hash_common)
d5727 2
a5728 6
      isym.n_value = (h->root.u.c.p->section->output_section->vma
		      + h->root.u.c.p->section->output_offset);
      isym.n_scnum = h->root.u.c.p->section->output_section->target_index;
      isym.n_sclass = C_EXT;
      aux.x_csect.x_smtyp = XTY_CM;
      aux.x_csect.x_scnlen.l = h->root.u.c.size;
a5729 2
  else
    abort ();
d5731 12
a5742 2
  isym.n_type = T_NULL;
  isym.n_numaux = 1;
d5744 5
a5748 2
  bfd_coff_swap_sym_out (output_bfd, (PTR) &isym, (PTR) outsym);
  outsym += bfd_coff_symesz (output_bfd);
d5750 1
a5750 8
  aux.x_csect.x_smclas = h->smclas;
  bfd_coff_swap_aux_out (output_bfd, (PTR) &aux, T_NULL, isym.n_sclass, 0, 1,
			 (PTR) outsym);
  outsym += bfd_coff_auxesz (output_bfd);

  if ((h->root.type == bfd_link_hash_defined
       || h->root.type == bfd_link_hash_defweak)
      && h->smclas != XMC_XO)
d5752 3
a5754 1
      /* We just output an SD symbol.  Now output an LD symbol.  */
d5756 7
a5762 1
      h->indx += 2;
d5764 8
a5771 3
      isym.n_sclass = C_EXT;
      bfd_coff_swap_sym_out (output_bfd, (PTR) &isym, (PTR) outsym);
      outsym += bfd_coff_symesz (output_bfd);
d5773 6
a5778 6
      aux.x_csect.x_smtyp = XTY_LD;
      aux.x_csect.x_scnlen.l = obj_raw_syment_count (output_bfd);
      bfd_coff_swap_aux_out (output_bfd, (PTR) &aux, T_NULL, C_EXT, 0, 1,
			     (PTR) outsym);
      outsym += bfd_coff_auxesz (output_bfd);
    }
d5780 2
a5781 8
  pos = obj_sym_filepos (output_bfd);
  pos += obj_raw_syment_count (output_bfd) * bfd_coff_symesz (output_bfd);
  amt = outsym - finfo->outsyms;
  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
      || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
    return FALSE;
  obj_raw_syment_count (output_bfd) +=
    (outsym - finfo->outsyms) / bfd_coff_symesz (output_bfd);
d5783 18
a5800 2
  return TRUE;
}
d5802 14
a5815 17
/* Handle a link order which is supposed to generate a reloc.  */

static bfd_boolean
xcoff_reloc_link_order (output_bfd, finfo, output_section, link_order)
     bfd *output_bfd;
     struct xcoff_final_link_info *finfo;
     asection *output_section;
     struct bfd_link_order *link_order;
{
  reloc_howto_type *howto;
  struct xcoff_link_hash_entry *h;
  asection *hsec;
  bfd_vma hval;
  bfd_vma addend;
  struct internal_reloc *irel;
  struct xcoff_link_hash_entry **rel_hash_ptr;
  struct internal_ldrel ldrel;
d5817 8
a5824 8
  if (link_order->type == bfd_section_reloc_link_order)
    {
      /* We need to somehow locate a symbol in the right section.  The
	 symbol must either have a value of zero, or we must adjust
	 the addend by the value of the symbol.  FIXME: Write this
	 when we need it.  The old linker couldn't handle this anyhow.  */
      abort ();
    }
d5826 5
a5830 6
  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (howto == NULL)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }
d5832 4
a5835 11
  h = ((struct xcoff_link_hash_entry *)
       bfd_wrapped_link_hash_lookup (output_bfd, finfo->info,
				     link_order->u.reloc.p->u.name,
				     FALSE, FALSE, TRUE));
  if (h == NULL)
    {
      if (! ((*finfo->info->callbacks->unattached_reloc)
	     (finfo->info, link_order->u.reloc.p->u.name, (bfd *) NULL,
	      (asection *) NULL, (bfd_vma) 0)))
	return FALSE;
      return TRUE;
d5838 1
a5838 1
  if (h->root.type == bfd_link_hash_common)
d5840 2
a5841 13
      hsec = h->root.u.c.p->section;
      hval = 0;
    }
  else if (h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
    {
      hsec = h->root.u.def.section;
      hval = h->root.u.def.value;
    }
  else
    {
      hsec = NULL;
      hval = 0;
d5844 2
a5845 7
  addend = link_order->u.reloc.p->addend;
  if (hsec != NULL)
    addend += (hsec->output_section->vma
	       + hsec->output_offset
	       + hval);

  if (addend != 0)
d5847 1
a5847 4
      bfd_size_type size;
      bfd_byte *buf;
      bfd_reloc_status_type rstat;
      bfd_boolean ok;
d5849 1
a5849 7
      size = bfd_get_reloc_size (howto);
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;

      rstat = _bfd_relocate_contents (howto, output_bfd, addend, buf);
      switch (rstat)
d5851 4
a5854 15
	case bfd_reloc_ok:
	  break;
	default:
	case bfd_reloc_outofrange:
	  abort ();
	case bfd_reloc_overflow:
	  if (! ((*finfo->info->callbacks->reloc_overflow)
		 (finfo->info, NULL, link_order->u.reloc.p->u.name,
		  howto->name, addend, (bfd *) NULL, (asection *) NULL,
		  (bfd_vma) 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
d5856 2
a5857 5
      ok = bfd_set_section_contents (output_bfd, output_section, (PTR) buf,
				     (file_ptr) link_order->offset, size);
      free (buf);
      if (! ok)
	return FALSE;
d5860 8
a5867 2
  /* Store the reloc information in the right place.  It will get
     swapped and written out at the end of the final_link routine.  */
d5869 19
a5887 4
  irel = (finfo->section_info[output_section->target_index].relocs
	  + output_section->reloc_count);
  rel_hash_ptr = (finfo->section_info[output_section->target_index].rel_hashes
		  + output_section->reloc_count);
d5889 12
a5900 2
  memset (irel, 0, sizeof (struct internal_reloc));
  *rel_hash_ptr = NULL;
d5902 1
a5902 1
  irel->r_vaddr = output_section->vma + link_order->offset;
d5904 3
a5906 3
  if (h->indx >= 0)
    irel->r_symndx = h->indx;
  else
d5908 10
a5917 4
      /* Set the index to -2 to force this symbol to get written out.  */
      h->indx = -2;
      *rel_hash_ptr = h;
      irel->r_symndx = 0;
d5920 3
a5922 4
  irel->r_type = howto->type;
  irel->r_size = howto->bitsize - 1;
  if (howto->complain_on_overflow == complain_overflow_signed)
    irel->r_size |= 0x80;
d5924 1
a5924 1
  ++output_section->reloc_count;
d5926 3
a5928 1
  /* Now output the reloc to the .loader section.  */
d5930 1
a5930 3
  ldrel.l_vaddr = irel->r_vaddr;

  if (hsec != NULL)
d5932 1
a5932 1
      const char *secname;
d5934 1
a5934 9
      secname = hsec->output_section->name;

      if (strcmp (secname, ".text") == 0)
	ldrel.l_symndx = 0;
      else if (strcmp (secname, ".data") == 0)
	ldrel.l_symndx = 1;
      else if (strcmp (secname, ".bss") == 0)
	ldrel.l_symndx = 2;
      else
d5936 4
a5939 5
	  (*_bfd_error_handler)
	    (_("%s: loader reloc in unrecognized section `%s'"),
	     bfd_get_filename (output_bfd), secname);
	  bfd_set_error (bfd_error_nonrepresentable_section);
	  return FALSE;
d5941 1
a5941 13
    }
  else
    {
      if (h->ldindx < 0)
	{
	  (*_bfd_error_handler)
	    (_("%s: `%s' in loader reloc but not loader sym"),
	     bfd_get_filename (output_bfd),
	     h->root.root.string);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      ldrel.l_symndx = h->ldindx;
d5944 15
a5958 24
  ldrel.l_rtype = (irel->r_size << 8) | irel->r_type;
  ldrel.l_rsecnm = output_section->target_index;
  bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
  finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);

  return TRUE;
}

/* Sort relocs by VMA.  This is called via qsort.  */

static int
xcoff_sort_relocs (p1, p2)
     const PTR p1;
     const PTR p2;
{
  const struct internal_reloc *r1 = (const struct internal_reloc *) p1;
  const struct internal_reloc *r2 = (const struct internal_reloc *) p2;

  if (r1->r_vaddr > r2->r_vaddr)
    return 1;
  else if (r1->r_vaddr < r2->r_vaddr)
    return -1;
  else
    return 0;
a5959 4




@


1.36
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d6046 1
a6046 1
		 (finfo->info, link_order->u.reloc.p->u.name,
@


1.35
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d1828 1
a1828 1
		  else if ((*sym_hash)->root.und_next != NULL
@


1.34
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d1243 2
a1244 2
		    (_("%s: `%s' has line numbers but no enclosing section"),
		     bfd_archive_filename (abfd), name);
d1296 2
a1297 2
	    (_("%s: class %d symbol `%s' has no aux entries"),
	     bfd_archive_filename (abfd), sym.n_sclass, name);
d1319 2
a1320 2
	    (_("%s: symbol `%s' has unrecognized csect type %d"),
	     bfd_archive_filename (abfd), name, smtyp);
d1331 2
a1332 2
		(_("%s: bad XTY_ER symbol `%s': class %d scnum %d scnlen %d"),
		 bfd_archive_filename (abfd), name, sym.n_sclass, sym.n_scnum,
d1367 2
a1368 3
		    (_("%s: XMC_TC0 symbol `%s' is class %d scnlen %d"),
		     bfd_archive_filename (abfd), name, sym.n_sclass,
		     aux.x_csect.x_scnlen.l);
d1518 2
a1519 2
		  (_("%s: csect `%s' not in enclosing section"),
		   bfd_archive_filename (abfd), name);
d1625 2
a1626 2
		  (_("%s: misplaced XTY_LD `%s'"),
		   bfd_archive_filename (abfd), name);
d1956 2
a1957 2
		    (_("%s: reloc %s:%d not in csect"),
		     bfd_archive_filename (abfd), o->name, i);
d5285 2
a5286 3
			    (_("%s: loader reloc in unrecognized section `%s'"),
			     bfd_archive_filename (input_bfd),
			     sec->name);
d5306 2
a5307 2
			    (_("%s: `%s' in loader reloc but not loader sym"),
			     bfd_archive_filename (input_bfd),
d5321 2
a5322 4
			(_("%s: loader reloc in read-only section %s"),
			 bfd_archive_filename (input_bfd),
			 bfd_get_section_name (finfo->output_bfd,
					       o->output_section));
@


1.33
log
@Rename bfd_link_hash_entry field "next" -> "und_next".
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d174 8
a181 9
      coff_section_data (abfd, sec)->contents = ((bfd_byte *)
						 bfd_malloc (sec->_raw_size));
      if (coff_section_data (abfd, sec)->contents == NULL)
	return FALSE;

      if (! bfd_get_section_contents (abfd, sec,
				      coff_section_data (abfd, sec)->contents,
				      (file_ptr) 0, sec->_raw_size))
	return FALSE;
d1516 1
a1516 1
			> enclosing->vma + enclosing->_raw_size)))
d1528 1
a1528 1
	    csect->_raw_size = aux.x_csect.x_scnlen.l;
d1565 1
a1565 1
		       && rel->r_vaddr < csect->vma + csect->_raw_size)
d1666 1
a1666 1
	  csect->_raw_size = aux.x_csect.x_scnlen.l;
d1692 1
a1692 1
	      csect->_raw_size = 0;
d1897 1
a1897 1
		  csect->_raw_size = 0;
d1939 1
a1939 1
	o->_raw_size = 0;
d2513 1
a2513 1
		  o->_raw_size = 0;
d3037 2
a3038 2
  lsec->_raw_size = stoff + ldhdr->l_stlen;
  lsec->contents = (bfd_byte *) bfd_zalloc (output_bfd, lsec->_raw_size);
d3087 1
a3087 1
  if (sec->_raw_size > 0)
d3089 1
a3089 1
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->_raw_size);
d3094 1
a3094 1
  if (sec->_raw_size > 0)
d3096 1
a3096 1
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->_raw_size);
d3101 1
a3101 1
  if (sec->_raw_size > 0)
d3103 1
a3103 1
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->_raw_size);
d3124 1
a3124 1
      if (subdeb == NULL || subdeb->_raw_size == 0)
d3131 1
a3131 1
	  subdeb->_raw_size = 0;
d3150 1
a3150 5
      debug_contents = (bfd_byte *) bfd_malloc (subdeb->_raw_size);
      if (debug_contents == NULL)
	goto error_return;
      if (! bfd_get_section_contents (sub, subdeb, (PTR) debug_contents,
				      (file_ptr) 0, subdeb->_raw_size))
d3198 1
a3198 1
      subdeb->_raw_size = 0;
d3208 1
a3208 1
    xcoff_hash_table (info)->debug_section->_raw_size =
d3367 1
a3367 1
      h->root.u.def.value = sec->_raw_size;
d3370 1
a3370 1
      sec->_raw_size += bfd_xcoff_glink_code_size(ldinfo->output_bfd);
d3394 2
a3395 2
	  hds->u.toc_offset = hds->toc_section->_raw_size;
	  hds->toc_section->_raw_size += byte_size;
d3430 1
a3430 1
	  h->root.u.def.value = sec->_raw_size;
d3436 1
a3436 1
	  sec->_raw_size +=
d3463 1
a3463 1
      && h->root.u.c.p->section->_raw_size == 0)
d3466 1
a3466 1
      h->root.u.c.p->section->_raw_size = h->root.u.c.size;
d3616 4
a3619 2
	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
d3722 1
a3722 1
		  BFD_ASSERT (o->_raw_size == 0);
d3726 1
a3726 1
		      o->_raw_size = file_align - pageoff;
d3734 1
a3734 1
		    sofar += BFD_ALIGN (o->_raw_size,
d4083 1
a4083 1
				  (file_ptr) o->output_offset, o->_raw_size))
d4088 1
a4088 1
  if (o->_raw_size > 0
d4091 1
a4091 1
				     o->_raw_size))
d4094 1
a4094 1
  if (o->_raw_size > 0
d4097 1
a4097 1
				     o->_raw_size))
d4100 1
a4100 1
  if (o->_raw_size > 0
d4103 1
a4103 1
				     o->_raw_size))
d4128 1
a4128 1
      BFD_ASSERT (o->output_section->_raw_size - o->output_offset
d4423 1
a4423 1
			+ (*csectpp)->output_section->_raw_size);
d4435 1
a4435 1
				       + o->_cooked_size);
d5053 1
a5053 1
	  || o->_raw_size == 0
d5062 7
a5068 6
      else {
	if (! bfd_get_section_contents (input_bfd, o, finfo->contents,
					(file_ptr) 0, o->_raw_size))
	  return FALSE;
	contents = finfo->contents;
      }
d5353 1
a5353 3
				      (o->_cooked_size != 0
				       ? o->_cooked_size
				       : o->_raw_size)))
@


1.33.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d174 9
a182 8
      bfd_byte *contents;
      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	{
	  if (contents != NULL)
	    free (contents);
	  return FALSE;
	}
      coff_section_data (abfd, sec)->contents = contents;
d1244 2
a1245 2
		    (_("%B: `%s' has line numbers but no enclosing section"),
		     abfd, name);
d1297 2
a1298 2
	    (_("%B: class %d symbol `%s' has no aux entries"),
	     abfd, sym.n_sclass, name);
d1320 2
a1321 2
	    (_("%B: symbol `%s' has unrecognized csect type %d"),
	     abfd, name, smtyp);
d1332 2
a1333 2
		(_("%B: bad XTY_ER symbol `%s': class %d scnum %d scnlen %d"),
		 abfd, name, sym.n_sclass, sym.n_scnum,
d1368 3
a1370 2
		    (_("%B: XMC_TC0 symbol `%s' is class %d scnlen %d"),
		     abfd, name, sym.n_sclass, aux.x_csect.x_scnlen.l);
d1517 1
a1517 1
			> enclosing->vma + enclosing->size)))
d1520 2
a1521 2
		  (_("%B: csect `%s' not in enclosing section"),
		   abfd, name);
d1529 1
a1529 1
	    csect->size = aux.x_csect.x_scnlen.l;
d1566 1
a1566 1
		       && rel->r_vaddr < csect->vma + csect->size)
d1627 2
a1628 2
		  (_("%B: misplaced XTY_LD `%s'"),
		   abfd, name);
d1667 1
a1667 1
	  csect->size = aux.x_csect.x_scnlen.l;
d1693 1
a1693 1
	      csect->size = 0;
d1898 1
a1898 1
		  csect->size = 0;
d1940 1
a1940 1
	o->size = 0;
d1958 2
a1959 2
		    (_("%B: reloc %s:%d not in csect"),
		     abfd, o->name, i);
d2514 1
a2514 1
		  o->size = 0;
d3038 2
a3039 2
  lsec->size = stoff + ldhdr->l_stlen;
  lsec->contents = (bfd_byte *) bfd_zalloc (output_bfd, lsec->size);
d3088 1
a3088 1
  if (sec->size > 0)
d3090 1
a3090 1
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->size);
d3095 1
a3095 1
  if (sec->size > 0)
d3097 1
a3097 1
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->size);
d3102 1
a3102 1
  if (sec->size > 0)
d3104 1
a3104 1
      sec->contents = (bfd_byte *) bfd_zalloc (output_bfd, sec->size);
d3125 1
a3125 1
      if (subdeb == NULL || subdeb->size == 0)
d3132 1
a3132 1
	  subdeb->size = 0;
d3151 5
a3155 1
      if (!bfd_malloc_and_get_section (sub, subdeb, &debug_contents))
d3203 1
a3203 1
      subdeb->size = 0;
d3213 1
a3213 1
    xcoff_hash_table (info)->debug_section->size =
d3372 1
a3372 1
      h->root.u.def.value = sec->size;
d3375 1
a3375 1
      sec->size += bfd_xcoff_glink_code_size(ldinfo->output_bfd);
d3399 2
a3400 2
	  hds->u.toc_offset = hds->toc_section->size;
	  hds->toc_section->size += byte_size;
d3435 1
a3435 1
	  h->root.u.def.value = sec->size;
d3441 1
a3441 1
	  sec->size +=
d3468 1
a3468 1
      && h->root.u.c.p->section->size == 0)
d3471 1
a3471 1
      h->root.u.c.p->section->size = h->root.u.c.size;
d3621 2
a3622 4
	      if (sec->rawsize > max_contents_size)
		max_contents_size = sec->rawsize;
	      if (sec->size > max_contents_size)
		max_contents_size = sec->size;
d3725 1
a3725 1
		  BFD_ASSERT (o->size == 0);
d3729 1
a3729 1
		      o->size = file_align - pageoff;
d3737 1
a3737 1
		    sofar += BFD_ALIGN (o->size,
d4086 1
a4086 1
				  (file_ptr) o->output_offset, o->size))
d4091 1
a4091 1
  if (o->size > 0
d4094 1
a4094 1
				     o->size))
d4097 1
a4097 1
  if (o->size > 0
d4100 1
a4100 1
				     o->size))
d4103 1
a4103 1
  if (o->size > 0
d4106 1
a4106 1
				     o->size))
d4131 1
a4131 1
      BFD_ASSERT (o->output_section->size - o->output_offset
d4426 1
a4426 1
			+ (*csectpp)->output_section->size);
d4438 1
a4438 1
				       + o->size);
d5056 1
a5056 1
	  || o->size == 0
d5065 6
a5070 7
      else
	{
	  bfd_size_type sz = o->rawsize ? o->rawsize : o->size;
	  if (!bfd_get_section_contents (input_bfd, o, finfo->contents, 0, sz))
	    return FALSE;
	  contents = finfo->contents;
	}
d5288 3
a5290 2
			    (_("%B: loader reloc in unrecognized section `%A'"),
			     input_bfd, sec);
d5310 2
a5311 2
			    (_("%B: `%s' in loader reloc but not loader sym"),
			     input_bfd,
d5325 4
a5328 2
			(_("%B: loader reloc in read-only section %A"),
			 input_bfd, o->output_section);
d5355 3
a5357 1
				      o->size))
@


1.33.8.2
log
@Merge from mainline.
@
text
@d1828 1
a1828 1
		  else if ((*sym_hash)->root.u.undef.next != NULL
@


1.32
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d1830 1
a1830 1
		  else if ((*sym_hash)->root.next != NULL
@


1.31
log
@Correct spelling of "relocatable".
@
text
@d1251 1
a1251 1
	      /* explict cast to bfd_signed_vma for compiler */
d2901 1
a2901 1
      /* __rtinit initalized */
@


1.30
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d2935 1
a2935 1
  if (info->relocateable
d5297 1
a5297 1
		      if (! finfo->info->relocateable
@


1.29
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@d118 1
a118 1
static boolean xcoff_get_section_contents PARAMS ((bfd *, asection *));
d120 1
a120 1
  PARAMS ((bfd *, asection *, boolean, bfd_byte *, boolean,
d122 1
a122 1
static boolean xcoff_link_add_object_symbols
d124 6
a129 6
static boolean xcoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
static boolean xcoff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
static boolean xcoff_link_check_dynamic_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
d132 1
a132 2
static boolean xcoff_link_add_symbols PARAMS ((bfd *, struct bfd_link_info *));
static boolean xcoff_link_add_dynamic_symbols
d134 3
a136 1
static boolean xcoff_mark_symbol
d138 1
a138 1
static boolean xcoff_mark PARAMS ((struct bfd_link_info *, asection *));
d140 1
a140 1
static boolean xcoff_build_ldsyms
d142 1
a142 1
static boolean xcoff_link_input_bfd
d144 1
a144 1
static boolean xcoff_write_global_symbol
d146 1
a146 1
static boolean xcoff_reloc_link_order
d158 1
a158 1
static boolean
d169 1
a169 1
	return false;
d177 1
a177 1
	return false;
d182 1
a182 1
	return false;
d185 1
a185 1
  return true;
d251 1
a251 1
  coff_section_data (abfd, lsec)->keep_contents = true;
d299 1
a299 1
         with the loader symbol.  */
d425 2
a426 2
         correct if ldrel.l_rtype == 0.  In other cases, we should use
         a different howto.  */
d505 2
a506 2
  ret->textro = false;
  ret->gc = false;
d512 1
a512 1
  xcoff_data (abfd)->full_aouthdr = true;
d539 1
a539 1
     boolean cache;
d541 1
a541 1
     boolean require_internal;
d559 2
a560 2
	  if (_bfd_coff_read_internal_relocs (abfd, enclosing, true,
					      external_relocs, false,
d591 1
a591 1
boolean
d604 4
a607 4
         to check the archive for dynamic objects, because they may not 
	 appear in the archive map even though they should, perhaps, be 
	 included.  If the archive has no map, we just consider each object 
	 file in turn, since that apparently is what the AIX native linker 
d613 1
a613 1
	    return false;
d618 1
a618 1
	
d626 3
a628 3
		boolean needed;
		
		if (! xcoff_link_check_archive_element (member, info, 
d630 1
a630 1
		  return false;
d638 1
a638 1
      return true;
d642 1
a642 1
      return false;
d648 1
a648 1
static boolean
d655 1
a655 1
    return false;
d657 1
a657 1
    return false;
d661 1
a661 1
	return false;
d663 1
a663 1
  return true;
d671 1
a671 1
static boolean
d675 1
a675 1
     boolean *pneeded;
d679 1
a679 1
    return false;
d682 1
a682 1
    return false;
d687 1
a687 1
	return false;
d693 1
a693 1
	return false;
d696 1
a696 1
  return true;
d702 1
a702 1
static boolean
d706 1
a706 1
     boolean *pneeded;
d712 1
a712 1
  *pneeded = false;
d735 1
a735 1
             object file.  */
d740 2
a741 2
	    return false;
	  h = bfd_link_hash_lookup (info->hash, name, false, false, true);
d755 3
a757 3
		return false;
	      *pneeded = true;
	      return true;
d765 1
a765 1
  return true;
d772 1
a772 1
static boolean
d776 1
a776 1
     boolean *pneeded;
d784 1
a784 1
  *pneeded = false;
d790 1
a790 1
      return true;
d794 1
a794 1
    return false;
d826 1
a826 1
      h = bfd_link_hash_lookup (info->hash, name, false, false, true);
d829 2
a830 2
         undefined.  At this point we know that we are using an XCOFF
         hash table.  */
d837 3
a839 3
	    return false;
	  *pneeded = true;
	  return true;
d851 1
a851 1
  return true;
d909 1
a909 1
static boolean
d913 1
a913 1
  boolean return_value = false;
d1002 1
a1002 1
  return_value = true;
d1027 1
a1027 1
static boolean
d1034 1
a1034 1
  boolean default_copy;
d1041 1
a1041 1
  boolean keep_syms;
d1062 1
a1062 1
	return false;
d1066 1
a1066 1
  if (false == xcoff_link_create_extra_sections(abfd, info))
d1071 1
a1071 1
    return true;
d1081 1
a1081 1
    default_copy = false;
d1083 1
a1083 1
    default_copy = true;
d1126 2
a1127 2
	    xcoff_read_internal_relocs (abfd, o, true, (bfd_byte *) NULL,
					false, (struct internal_reloc *) NULL);
d1154 1
a1154 1
  obj_coff_keep_syms (abfd) = true;
d1218 5
a1222 5
         and we're not stripping it, count the number of entries and
         add them to the count for this csect.  In the final link pass
         we are going to attach line number information by symbol,
         rather than by section, in order to more easily handle
         garbage collection.  */
d1340 1
a1340 1
             an absolute location.  */
d1434 1
a1434 1
		      boolean copy;
d1457 2
a1458 2
						      relname, true, copy,
						      false);
d1610 1
a1610 1
	    boolean bad;
d1612 1
a1612 1
	    bad = false;
d1616 1
a1616 1
	      bad = true;
d1622 1
a1622 1
		  bad = true;
d1639 5
a1643 5
             the storage mapping class, but we don't bother except for
             an XMC_TD symbol.  If this csect is externally visible,
             it is a common symbol.  We put XMC_TD symbols in sections
             named .tocbss, and rely on the linker script to put that
             in the TOC area.  */
d1734 1
a1734 1
         linker hash table.  */
d1738 1
a1738 1
	  boolean copy;
d1743 1
a1743 1
             syment itself, rather than the string table.  */
d1747 1
a1747 1
	    copy = true;
d1779 1
a1779 1
						      name, true, copy, false);
d1787 2
a1788 2
							     true, true, 
							     false));
d1805 5
a1809 5
                         either the existing symbol is not global
                         linkage code or this symbol is global linkage
                         code.  If the existing symbol is global
                         linkage code and the new symbol is not, then
                         we want to use the new symbol.  */
d1817 1
a1817 1
                         Replace it.  */
d1825 2
a1826 2
                         in an archive.  Just ignore it.  See the
                         comment above.  */
d1834 3
a1836 3
                         case, we just continue and permit the
                         multiple definition error.  See the comment
                         above about the behaviour of the AIX linker.  */
d1841 2
a1842 2
                         class.  There is at least a chance that this
                         is a semi-legitimate redefinition.  */
d1887 1
a1887 1
		  (const char *) NULL, copy, true,
d1978 8
a1985 8
                     the code of a function.  If the symbol is
                     currently undefined, then add an undefined symbol
                     for the function descriptor.  This should do no
                     harm, because any regular object that defines the
                     function should also define the function
                     descriptor.  It helps, because it means that we
                     will identify the function descriptor with a
                     dynamic object if a dynamic object defines it.  */
d1994 1
a1994 1
						    true, false, true);
d2003 2
a2004 2
				  (bfd_vma) 0, (const char *) NULL, false,
				  true, &bh)))
d2037 1
a2037 1
         somewhere for the final link, to avoid reading them again.  */
d2049 1
a2049 1
  return true;
d2064 1
a2064 1
  return false;
d2073 1
a2073 1
static boolean
d2098 1
a2098 1
      return false;
d2119 1
a2119 1
      return false;
d2124 1
a2124 1
    return false;
d2166 2
a2167 2
      h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, true,
				  true, true);
d2169 1
a2169 1
	return false;
d2195 3
a2197 3
         define it, since we don't have a section to put it in anyhow.
         Instead, the relocation routines handle the DEF_DYNAMIC flag
         correctly.  */
d2225 1
a2225 1
		return false;
d2229 1
a2229 1
					    true, true, true);
d2232 1
a2232 1
		return false;
d2239 1
a2239 1
                     symbol list.  */
d2276 1
a2276 1
    return false;
d2309 1
a2309 1
  return true;
d2318 1
a2318 1
static INLINE boolean
d2325 1
a2325 1
    return true;
d2338 1
a2338 1
	    return false;
d2346 1
a2346 1
	return false;
d2349 1
a2349 1
  return true;
d2358 1
a2358 1
static boolean
d2365 1
a2365 1
    return true;
d2391 1
a2391 1
		return false;
d2400 2
a2401 2
	  rel = xcoff_read_internal_relocs (sec->owner, sec, true,
					    (bfd_byte *) NULL, false,
d2404 1
a2404 1
	    return false;
d2420 1
a2420 1
		    return false;
d2428 1
a2428 1
		    return false;
d2432 1
a2432 1
                 section.  */
d2481 1
a2481 1
  return true;
d2502 2
a2503 2
                 special sections.  Keep .debug sections for the
                 moment.  */
d2526 1
a2526 1
boolean
d2538 1
a2538 1
    return true;
d2547 1
a2547 1
    return false;
d2555 1
a2555 1
  return true;
d2560 1
a2560 1
boolean
d2575 1
a2575 1
    return true;
d2591 1
a2591 1
					true, false, true);
d2593 1
a2593 1
	    return false;
d2607 2
a2608 2
         rather than the symbol we were told to import.  FIXME: Is
         this correct in all cases?  */
d2625 1
a2625 1
	    return false;
d2645 1
a2645 1
         reserved for the library search path.  */
d2663 1
a2663 1
	    return false;
d2674 1
a2674 1
  return true;
d2679 1
a2679 1
boolean
d2688 1
a2688 1
    return true;
d2706 1
a2706 1
	return false;
d2710 1
a2710 1
				    fnname, false, false, true);
d2725 1
a2725 1
    return false;
d2735 1
a2735 1
	return false;
d2738 1
a2738 1
  return true;
d2745 1
a2745 1
boolean
d2754 1
a2754 1
    return true;
d2757 2
a2758 2
       bfd_wrapped_link_hash_lookup (output_bfd, info, name, false, false,
				     false));
d2763 1
a2763 1
      return false;
d2771 1
a2771 1
    return false;
d2773 1
a2773 1
  return true;
d2779 1
a2779 1
boolean
d2788 1
a2788 1
    return true;
d2790 2
a2791 2
  h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, true, true,
			      false);
d2793 1
a2793 1
    return false;
d2797 1
a2797 1
  return true;
d2817 1
a2817 1
boolean
d2829 1
a2829 1
     boolean gc;
d2831 2
a2832 2
     boolean textro;
     boolean export_defineds;
d2834 1
a2834 1
     boolean rtld;
d2855 1
a2855 1
      return true;
d2858 1
a2858 1
  ldinfo.failed = false;
d2878 1
a2878 1
				       false, false, true);
d2884 1
a2884 1
  if (info->init_function || info->fini_function || rtld) 
d2888 1
a2888 1
      
d2890 1
a2890 1
				     "__rtinit", false, false, true);
d2895 1
a2895 1
	  return false;
d2897 1
a2897 1
      
d2904 8
a2911 8
      
      ldsym->l_value = 0;                  /* will be filled in later */
      ldsym->l_scnum = 2;                  /* data section */
      ldsym->l_smtype = XTY_SD;            /* csect section definition */
      ldsym->l_smclas = 5;                 /* .rw */
      ldsym->l_ifile = 0;                  /* special system loader symbol */
      ldsym->l_parm = 0;                   /* NA */
      
d2914 1
a2914 1
	 
d2918 1
a2918 1
      
d2922 5
a2926 6
      
      if (false == bfd_xcoff_put_ldsymbol_name (ldinfo.output_bfd, &ldinfo,
						hsym->ldsym,
						hsym->root.root.string))
	return false;
      
d2941 2
a2942 2
      gc = false;
      xcoff_hash_table (info)->gc = false;
d2945 1
a2945 1
         correctly.  */
d2965 1
a2965 1
      xcoff_hash_table (info)->gc = true;
d2985 1
a2985 1
      return true;
d3161 1
a3161 1
      if (NULL != csectpp) 
d3186 1
a3186 1
		  indx = _bfd_stringtab_add (debug_strtab, name, true, true);
d3216 1
a3216 1
  return true;
d3223 1
a3223 1
  return false;
d3226 1
a3226 1
boolean 
d3231 1
a3231 1
     boolean rtld;
d3234 1
a3234 1
  
d3238 1
a3238 1
    return false;
d3250 2
a3251 2
  if (false == bfd_xcoff_generate_rtinit (abfd, init, fini, rtld)) 
    return false;
d3258 1
a3258 1
  return true;
d3264 1
a3264 1
static boolean
d3277 1
a3277 1
      return true;
d3299 1
a3299 1
      boolean export;
d3315 1
a3315 1
      export = true;
d3329 1
a3329 1
		  export = false;
d3378 1
a3378 1
         descriptor.  */
d3396 1
a3396 1
	    return false;
d3428 4
a3431 4
             a defined entry point.  We can build up a function
             descriptor ourselves.  Believe it or not, the AIX linker
             actually does this, and there are cases where we need to
             do it as well.  */
d3458 1
a3458 1
	  return true;
d3487 1
a3487 1
      return true;
d3496 1
a3496 1
      return true;
d3502 1
a3502 1
    return true;
d3511 2
a3512 2
      ldinfo->failed = true;
      return false;
d3524 2
a3525 3
  if (false == bfd_xcoff_put_ldsymbol_name (ldinfo->output_bfd, ldinfo,
					    h->ldsym,
					    h->root.root.string))
d3527 1
a3527 1
      return false;
d3532 1
a3532 1
  return true;
d3537 1
a3537 1
boolean
d3613 1
a3613 1
	      sec->linker_mark = true;
d3653 1
a3653 1
	  boolean saw_contents;
d3657 1
a3657 1
	  
d3659 3
a3661 3
             contents and is loaded, if it is preceded by some other
             section which has contents and is loaded.  */
	  saw_contents = true;
d3665 1
a3665 1
		saw_contents = false;
d3670 1
a3670 1
		    saw_contents = true;
d3674 1
a3674 1
		      
d3676 1
a3676 1
			 that needs padding.  This requires unlinking and 
d3678 1
a3678 1
		      
d3682 1
a3682 1
		      n->alignment_power = 0; 
d3689 1
a3689 1
		      saw_contents = false;
d3693 1
a3693 1
	  
d3695 1
a3695 1
             sections.  */
d3705 3
a3707 3
             each section to land on a page boundary.  This bit of
             code knows what compute_section_file_positions is going
             to do.  */
d3777 2
a3778 2
             allocate the buffers, so that later code doesn't have to
             worry about whether we are stripping or not.  */
d3789 7
a3795 7
             written out all the local symbols.  For each section in
             the output file, we keep an array of pointers to hash
             table entries.  Each entry in the array corresponds to a
             reloc.  When we find a reloc against a global symbol, we
             set the corresponding entry in this array so that we can
             fix up the symbol index after we have written out all the
             local symbols.
d3852 1
a3852 1
      sub->output_has_begun = false;
d3905 1
a3905 1
		  sub->output_has_begun = true;
d4144 1
a4144 1
  return true;
d4178 1
a4178 1
  return false;
d4184 1
a4184 1
static boolean
d4194 1
a4194 1
  boolean copy, hash;
d4209 1
a4209 1
  boolean keep_syms;
d4215 1
a4215 1
    return true;
d4234 1
a4234 1
  copy = false;
d4236 2
a4237 2
    copy = true;
  hash = true;
d4239 1
a4239 1
    hash = false;
d4242 1
a4242 1
    return false;
d4262 2
a4263 2
      boolean skip;
      boolean require;
d4269 1
a4269 1
         information.  */
d4289 3
a4291 3
         .loader symbol information.  If this is an external symbol
         reference to a defined symbol, though, then wait until we get
         to the definition.  */
d4381 2
a4382 2
      skip = false;
      require = false;
d4387 1
a4387 1
	skip = true;
d4390 1
a4390 1
         symbol.  */
d4395 1
a4395 1
	skip = true;
d4400 1
a4400 1
	skip = true;
d4408 1
a4408 1
	    skip = true;
d4420 5
a4424 5
                 as the TOC anchor--that is, whether we can access all
                 of the TOC using a 16 bit offset from tocval.  This
                 test assumes that the TOC comes at the end of the
                 output section, as it does in the default linker
                 script.  */
d4451 1
a4451 1
		  return false;
d4467 1
a4467 1
	      require = true;
d4475 1
a4475 1
	skip = true;
d4482 1
a4482 1
	skip = true;
d4485 1
a4485 1
         else.  */
d4493 1
a4493 1
	skip = true;
d4501 1
a4501 1
	skip = true;
d4504 1
a4504 1
         symbol, then skip it.  */
d4508 1
a4508 1
	skip = true;
d4526 1
a4526 1
	    return false;
d4529 2
a4530 2
	       && (bfd_hash_lookup (finfo->info->keep_hash, name, false,
				    false) == NULL))
d4536 1
a4536 1
	    skip = true;
d4543 1
a4543 1
	skip = false;
d4567 1
a4567 1
		    return false;
d4570 1
a4570 1
		    return false;
d4624 1
a4624 1
			return false;
d4633 2
a4634 2
             into the line numbers.  We update the symbol values when
             we handle the line numbers.  */
d4661 2
a4662 2
             (class XMC_TC), remember the symbol index of the TOC
             symbol.  */
d4717 1
a4717 1
                 index of the containing csect.  */
d4762 1
a4762 1
			    return false;
d4768 1
a4768 1
			return false;
d4778 1
a4778 1
                     anybody does.  */
d4781 1
a4781 1
                     better clobber them just in case.  */
d4820 3
a4822 3
                             the index of the next symbol we are going
                             to include.  I don't know if this is
                             entirely right.  */
d4879 1
a4879 1
			    return false;
d4939 1
a4939 1
			    return false;
d4951 2
a4952 2
                                 that refer to a line number in the
                                 range we just output.  */
d5030 1
a5030 1
	return false;
d5041 1
a5041 1
  obj_coff_keep_syms (input_bfd) = true;
d5068 1
a5068 1
	  return false;
d5085 2
a5086 2
			     (input_bfd, o, false, finfo->external_relocs,
			      true,
d5090 1
a5090 1
	    return false;
d5100 1
a5100 1
	    return false;
d5111 1
a5111 1
	      boolean quiet;
d5155 1
a5155 1
			    return false;
d5235 1
a5235 1
			    return false;
d5240 1
a5240 1
			    return false;
d5245 1
a5245 1
	      quiet = false;
d5292 1
a5292 1
			  return false;
d5305 1
a5305 1
			  quiet = true;
d5314 1
a5314 1
			  return false;
d5330 1
a5330 1
		      return false;
d5358 1
a5358 1
	return false;
d5366 1
a5366 1
	return false;
d5369 1
a5369 1
  return true;
d5378 1
a5378 1
static boolean
d5388 1
a5388 1
  boolean result;
d5399 1
a5399 1
	return true;
d5405 1
a5405 1
    return true;
d5627 1
a5627 1
	  return false;
d5647 2
a5648 4
	  if (false == result)
	    {
	      return false;
	    }
d5674 1
a5674 1
		return false;
d5721 1
a5721 1
	  return false;
d5759 1
a5759 1
	  return false;
d5821 1
a5821 1
	  return false;
d5832 1
a5832 1
      return true;
d5839 1
a5839 1
				  false, false) == NULL)))
d5842 1
a5842 1
      return true;
d5849 1
a5849 1
      return true;
d5858 2
a5859 4
  if (false == result)
    {
      return false;
    }
d5955 1
a5955 1
    return false;
d5959 1
a5959 1
  return true;
d5964 1
a5964 1
static boolean
d5983 3
a5985 3
         symbol must either have a value of zero, or we must adjust
         the addend by the value of the symbol.  FIXME: Write this
         when we need it.  The old linker couldn't handle this anyhow.  */
d5993 1
a5993 1
      return false;
d5999 1
a5999 1
				     false, false, true));
d6005 2
a6006 2
	return false;
      return true;
d6037 1
a6037 1
      boolean ok;
d6042 1
a6042 1
	return false;
d6059 1
a6059 1
	      return false;
d6067 1
a6067 1
	return false;
d6122 1
a6122 1
	  return false;
d6134 1
a6134 1
	  return false;
d6144 1
a6144 1
  return true;
@


1.28
log
@	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.
@
text
@d1989 1
d1998 1
d2003 1
a2003 2
				  true,
				  (struct bfd_link_hash_entry **) &hds)))
d2005 1
@


1.28.12.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a1988 1
		      struct bfd_link_hash_entry *bh;
a1996 1
			  bh = &hds->root;
d2001 2
a2002 1
				  true, &bh)))
a2003 1
			  hds = (struct xcoff_link_hash_entry *) bh;
@


1.28.12.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d118 1
a118 1
static bfd_boolean xcoff_get_section_contents PARAMS ((bfd *, asection *));
d120 1
a120 1
  PARAMS ((bfd *, asection *, bfd_boolean, bfd_byte *, bfd_boolean,
d122 1
a122 1
static bfd_boolean xcoff_link_add_object_symbols
d124 6
a129 6
static bfd_boolean xcoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_dynamic_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
d132 2
a133 1
static bfd_boolean xcoff_link_add_symbols
d135 1
a135 3
static bfd_boolean xcoff_link_add_dynamic_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean xcoff_mark_symbol
d137 1
a137 1
static bfd_boolean xcoff_mark PARAMS ((struct bfd_link_info *, asection *));
d139 1
a139 1
static bfd_boolean xcoff_build_ldsyms
d141 1
a141 1
static bfd_boolean xcoff_link_input_bfd
d143 1
a143 1
static bfd_boolean xcoff_write_global_symbol
d145 1
a145 1
static bfd_boolean xcoff_reloc_link_order
d157 1
a157 1
static bfd_boolean
d168 1
a168 1
	return FALSE;
d176 1
a176 1
	return FALSE;
d181 1
a181 1
	return FALSE;
d184 1
a184 1
  return TRUE;
d250 1
a250 1
  coff_section_data (abfd, lsec)->keep_contents = TRUE;
d298 1
a298 1
	 with the loader symbol.  */
d424 2
a425 2
	 correct if ldrel.l_rtype == 0.  In other cases, we should use
	 a different howto.  */
d504 2
a505 2
  ret->textro = FALSE;
  ret->gc = FALSE;
d511 1
a511 1
  xcoff_data (abfd)->full_aouthdr = TRUE;
d538 1
a538 1
     bfd_boolean cache;
d540 1
a540 1
     bfd_boolean require_internal;
d558 2
a559 2
	  if (_bfd_coff_read_internal_relocs (abfd, enclosing, TRUE,
					      external_relocs, FALSE,
d590 1
a590 1
bfd_boolean
d603 4
a606 4
	 to check the archive for dynamic objects, because they may not
	 appear in the archive map even though they should, perhaps, be
	 included.  If the archive has no map, we just consider each object
	 file in turn, since that apparently is what the AIX native linker
d612 1
a612 1
	    return FALSE;
d617 1
a617 1

d625 3
a627 3
		bfd_boolean needed;

		if (! xcoff_link_check_archive_element (member, info,
d629 1
a629 1
		  return FALSE;
d637 1
a637 1
      return TRUE;
d641 1
a641 1
      return FALSE;
d647 1
a647 1
static bfd_boolean
d654 1
a654 1
    return FALSE;
d656 1
a656 1
    return FALSE;
d660 1
a660 1
	return FALSE;
d662 1
a662 1
  return TRUE;
d670 1
a670 1
static bfd_boolean
d674 1
a674 1
     bfd_boolean *pneeded;
d678 1
a678 1
    return FALSE;
d681 1
a681 1
    return FALSE;
d686 1
a686 1
	return FALSE;
d692 1
a692 1
	return FALSE;
d695 1
a695 1
  return TRUE;
d701 1
a701 1
static bfd_boolean
d705 1
a705 1
     bfd_boolean *pneeded;
d711 1
a711 1
  *pneeded = FALSE;
d734 1
a734 1
	     object file.  */
d739 2
a740 2
	    return FALSE;
	  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d754 3
a756 3
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
d764 1
a764 1
  return TRUE;
d771 1
a771 1
static bfd_boolean
d775 1
a775 1
     bfd_boolean *pneeded;
d783 1
a783 1
  *pneeded = FALSE;
d789 1
a789 1
      return TRUE;
d793 1
a793 1
    return FALSE;
d825 1
a825 1
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d828 2
a829 2
	 undefined.  At this point we know that we are using an XCOFF
	 hash table.  */
d836 3
a838 3
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
d850 1
a850 1
  return TRUE;
d908 1
a908 1
static bfd_boolean
d912 1
a912 1
  bfd_boolean return_value = FALSE;
d1001 1
a1001 1
  return_value = TRUE;
d1026 1
a1026 1
static bfd_boolean
d1033 1
a1033 1
  bfd_boolean default_copy;
d1040 1
a1040 1
  bfd_boolean keep_syms;
d1061 1
a1061 1
	return FALSE;
d1065 1
a1065 1
  if (! xcoff_link_create_extra_sections (abfd, info))
d1070 1
a1070 1
    return TRUE;
d1080 1
a1080 1
    default_copy = FALSE;
d1082 1
a1082 1
    default_copy = TRUE;
d1125 2
a1126 2
	    xcoff_read_internal_relocs (abfd, o, TRUE, (bfd_byte *) NULL,
					FALSE, (struct internal_reloc *) NULL);
d1153 1
a1153 1
  obj_coff_keep_syms (abfd) = TRUE;
d1217 5
a1221 5
	 and we're not stripping it, count the number of entries and
	 add them to the count for this csect.  In the final link pass
	 we are going to attach line number information by symbol,
	 rather than by section, in order to more easily handle
	 garbage collection.  */
d1250 1
a1250 1
	      /* explicit cast to bfd_signed_vma for compiler */
d1339 1
a1339 1
	     an absolute location.  */
d1433 1
a1433 1
		      bfd_boolean copy;
d1456 2
a1457 2
						      relname, TRUE, copy,
						      FALSE);
d1609 1
a1609 1
	    bfd_boolean bad;
d1611 1
a1611 1
	    bad = FALSE;
d1615 1
a1615 1
	      bad = TRUE;
d1621 1
a1621 1
		  bad = TRUE;
d1638 5
a1642 5
	     the storage mapping class, but we don't bother except for
	     an XMC_TD symbol.  If this csect is externally visible,
	     it is a common symbol.  We put XMC_TD symbols in sections
	     named .tocbss, and rely on the linker script to put that
	     in the TOC area.  */
d1733 1
a1733 1
	 linker hash table.  */
d1737 1
a1737 1
	  bfd_boolean copy;
d1742 1
a1742 1
	     syment itself, rather than the string table.  */
d1746 1
a1746 1
	    copy = TRUE;
d1778 1
a1778 1
						      name, TRUE, copy, FALSE);
d1786 2
a1787 2
							     TRUE, TRUE,
							     FALSE));
d1804 5
a1808 5
			 either the existing symbol is not global
			 linkage code or this symbol is global linkage
			 code.  If the existing symbol is global
			 linkage code and the new symbol is not, then
			 we want to use the new symbol.  */
d1816 1
a1816 1
			 Replace it.  */
d1824 2
a1825 2
			 in an archive.  Just ignore it.  See the
			 comment above.  */
d1829 1
a1829 1
		  else if ((*sym_hash)->root.und_next != NULL
d1833 3
a1835 3
			 case, we just continue and permit the
			 multiple definition error.  See the comment
			 above about the behaviour of the AIX linker.  */
d1840 2
a1841 2
			 class.  There is at least a chance that this
			 is a semi-legitimate redefinition.  */
d1886 1
a1886 1
		  (const char *) NULL, copy, TRUE,
d1977 8
a1984 8
		     the code of a function.  If the symbol is
		     currently undefined, then add an undefined symbol
		     for the function descriptor.  This should do no
		     harm, because any regular object that defines the
		     function should also define the function
		     descriptor.  It helps, because it means that we
		     will identify the function descriptor with a
		     dynamic object if a dynamic object defines it.  */
d1993 1
a1993 1
						    TRUE, FALSE, TRUE);
d2002 2
a2003 2
				  (bfd_vma) 0, (const char *) NULL, FALSE,
				  TRUE, &bh)))
d2036 1
a2036 1
	 somewhere for the final link, to avoid reading them again.  */
d2048 1
a2048 1
  return TRUE;
d2063 1
a2063 1
  return FALSE;
d2072 1
a2072 1
static bfd_boolean
d2097 1
a2097 1
      return FALSE;
d2118 1
a2118 1
      return FALSE;
d2123 1
a2123 1
    return FALSE;
d2165 2
a2166 2
      h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE,
				  TRUE, TRUE);
d2168 1
a2168 1
	return FALSE;
d2194 3
a2196 3
	 define it, since we don't have a section to put it in anyhow.
	 Instead, the relocation routines handle the DEF_DYNAMIC flag
	 correctly.  */
d2224 1
a2224 1
		return FALSE;
d2228 1
a2228 1
					    TRUE, TRUE, TRUE);
d2231 1
a2231 1
		return FALSE;
d2238 1
a2238 1
		     symbol list.  */
d2275 1
a2275 1
    return FALSE;
d2308 1
a2308 1
  return TRUE;
d2317 1
a2317 1
static INLINE bfd_boolean
d2324 1
a2324 1
    return TRUE;
d2337 1
a2337 1
	    return FALSE;
d2345 1
a2345 1
	return FALSE;
d2348 1
a2348 1
  return TRUE;
d2357 1
a2357 1
static bfd_boolean
d2364 1
a2364 1
    return TRUE;
d2390 1
a2390 1
		return FALSE;
d2399 2
a2400 2
	  rel = xcoff_read_internal_relocs (sec->owner, sec, TRUE,
					    (bfd_byte *) NULL, FALSE,
d2403 1
a2403 1
	    return FALSE;
d2419 1
a2419 1
		    return FALSE;
d2427 1
a2427 1
		    return FALSE;
d2431 1
a2431 1
		 section.  */
d2480 1
a2480 1
  return TRUE;
d2501 2
a2502 2
		 special sections.  Keep .debug sections for the
		 moment.  */
d2525 1
a2525 1
bfd_boolean
d2537 1
a2537 1
    return TRUE;
d2546 1
a2546 1
    return FALSE;
d2554 1
a2554 1
  return TRUE;
d2559 1
a2559 1
bfd_boolean
d2574 1
a2574 1
    return TRUE;
d2590 1
a2590 1
					TRUE, FALSE, TRUE);
d2592 1
a2592 1
	    return FALSE;
d2606 2
a2607 2
	 rather than the symbol we were told to import.  FIXME: Is
	 this correct in all cases?  */
d2624 1
a2624 1
	    return FALSE;
d2644 1
a2644 1
	 reserved for the library search path.  */
d2662 1
a2662 1
	    return FALSE;
d2673 1
a2673 1
  return TRUE;
d2678 1
a2678 1
bfd_boolean
d2687 1
a2687 1
    return TRUE;
d2705 1
a2705 1
	return FALSE;
d2709 1
a2709 1
				    fnname, FALSE, FALSE, TRUE);
d2724 1
a2724 1
    return FALSE;
d2734 1
a2734 1
	return FALSE;
d2737 1
a2737 1
  return TRUE;
d2744 1
a2744 1
bfd_boolean
d2753 1
a2753 1
    return TRUE;
d2756 2
a2757 2
       bfd_wrapped_link_hash_lookup (output_bfd, info, name, FALSE, FALSE,
				     FALSE));
d2762 1
a2762 1
      return FALSE;
d2770 1
a2770 1
    return FALSE;
d2772 1
a2772 1
  return TRUE;
d2778 1
a2778 1
bfd_boolean
d2787 1
a2787 1
    return TRUE;
d2789 2
a2790 2
  h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE, TRUE,
			      FALSE);
d2792 1
a2792 1
    return FALSE;
d2796 1
a2796 1
  return TRUE;
d2816 1
a2816 1
bfd_boolean
d2828 1
a2828 1
     bfd_boolean gc;
d2830 2
a2831 2
     bfd_boolean textro;
     bfd_boolean export_defineds;
d2833 1
a2833 1
     bfd_boolean rtld;
d2854 1
a2854 1
      return TRUE;
d2857 1
a2857 1
  ldinfo.failed = FALSE;
d2877 1
a2877 1
				       FALSE, FALSE, TRUE);
d2883 1
a2883 1
  if (info->init_function || info->fini_function || rtld)
d2887 1
a2887 1

d2889 1
a2889 1
				     "__rtinit", FALSE, FALSE, TRUE);
d2894 1
a2894 1
	  return FALSE;
d2896 1
a2896 1

d2900 1
a2900 1
      /* __rtinit initialized */
d2903 8
a2910 8

      ldsym->l_value = 0;		/* will be filled in later */
      ldsym->l_scnum = 2;		/* data section */
      ldsym->l_smtype = XTY_SD;		/* csect section definition */
      ldsym->l_smclas = 5;		/* .rw */
      ldsym->l_ifile = 0;		/* special system loader symbol */
      ldsym->l_parm = 0;		/* NA */

d2913 1
a2913 1

d2917 1
a2917 1

d2921 6
a2926 5

      if (! bfd_xcoff_put_ldsymbol_name (ldinfo.output_bfd, &ldinfo,
					 hsym->ldsym, hsym->root.root.string))
	return FALSE;

d2935 1
a2935 1
  if (info->relocatable
d2941 2
a2942 2
      gc = FALSE;
      xcoff_hash_table (info)->gc = FALSE;
d2945 1
a2945 1
	 correctly.  */
d2965 1
a2965 1
      xcoff_hash_table (info)->gc = TRUE;
d2985 1
a2985 1
      return TRUE;
d3161 1
a3161 1
      if (NULL != csectpp)
d3186 1
a3186 1
		  indx = _bfd_stringtab_add (debug_strtab, name, TRUE, TRUE);
d3216 1
a3216 1
  return TRUE;
d3223 1
a3223 1
  return FALSE;
d3226 1
a3226 1
bfd_boolean
d3231 1
a3231 1
     bfd_boolean rtld;
d3234 1
a3234 1

d3238 1
a3238 1
    return FALSE;
d3250 2
a3251 2
  if (! bfd_xcoff_generate_rtinit (abfd, init, fini, rtld))
    return FALSE;
d3258 1
a3258 1
  return TRUE;
d3264 1
a3264 1
static bfd_boolean
d3277 1
a3277 1
      return TRUE;
d3299 1
a3299 1
      bfd_boolean export;
d3315 1
a3315 1
      export = TRUE;
d3329 1
a3329 1
		  export = FALSE;
d3378 1
a3378 1
	 descriptor.  */
d3396 1
a3396 1
	    return FALSE;
d3428 4
a3431 4
	     a defined entry point.  We can build up a function
	     descriptor ourselves.  Believe it or not, the AIX linker
	     actually does this, and there are cases where we need to
	     do it as well.  */
d3458 1
a3458 1
	  return TRUE;
d3487 1
a3487 1
      return TRUE;
d3496 1
a3496 1
      return TRUE;
d3502 1
a3502 1
    return TRUE;
d3511 2
a3512 2
      ldinfo->failed = TRUE;
      return FALSE;
d3524 3
a3526 2
  if (! bfd_xcoff_put_ldsymbol_name (ldinfo->output_bfd, ldinfo,
				     h->ldsym, h->root.root.string))
d3528 1
a3528 1
      return FALSE;
d3533 1
a3533 1
  return TRUE;
d3538 1
a3538 1
bfd_boolean
d3614 1
a3614 1
	      sec->linker_mark = TRUE;
d3654 1
a3654 1
	  bfd_boolean saw_contents;
d3658 1
a3658 1

d3660 3
a3662 3
	     contents and is loaded, if it is preceded by some other
	     section which has contents and is loaded.  */
	  saw_contents = TRUE;
d3666 1
a3666 1
		saw_contents = FALSE;
d3671 1
a3671 1
		    saw_contents = TRUE;
d3675 1
a3675 1

d3677 1
a3677 1
			 that needs padding.  This requires unlinking and
d3679 1
a3679 1

d3683 1
a3683 1
		      n->alignment_power = 0;
d3690 1
a3690 1
		      saw_contents = FALSE;
d3694 1
a3694 1

d3696 1
a3696 1
	     sections.  */
d3706 3
a3708 3
	     each section to land on a page boundary.  This bit of
	     code knows what compute_section_file_positions is going
	     to do.  */
d3778 2
a3779 2
	     allocate the buffers, so that later code doesn't have to
	     worry about whether we are stripping or not.  */
d3790 7
a3796 7
	     written out all the local symbols.  For each section in
	     the output file, we keep an array of pointers to hash
	     table entries.  Each entry in the array corresponds to a
	     reloc.  When we find a reloc against a global symbol, we
	     set the corresponding entry in this array so that we can
	     fix up the symbol index after we have written out all the
	     local symbols.
d3853 1
a3853 1
      sub->output_has_begun = FALSE;
d3906 1
a3906 1
		  sub->output_has_begun = TRUE;
d4145 1
a4145 1
  return TRUE;
d4179 1
a4179 1
  return FALSE;
d4185 1
a4185 1
static bfd_boolean
d4195 1
a4195 1
  bfd_boolean copy, hash;
d4210 1
a4210 1
  bfd_boolean keep_syms;
d4216 1
a4216 1
    return TRUE;
d4235 1
a4235 1
  copy = FALSE;
d4237 2
a4238 2
    copy = TRUE;
  hash = TRUE;
d4240 1
a4240 1
    hash = FALSE;
d4243 1
a4243 1
    return FALSE;
d4263 2
a4264 2
      bfd_boolean skip;
      bfd_boolean require;
d4270 1
a4270 1
	 information.  */
d4290 3
a4292 3
	 .loader symbol information.  If this is an external symbol
	 reference to a defined symbol, though, then wait until we get
	 to the definition.  */
d4382 2
a4383 2
      skip = FALSE;
      require = FALSE;
d4388 1
a4388 1
	skip = TRUE;
d4391 1
a4391 1
	 symbol.  */
d4396 1
a4396 1
	skip = TRUE;
d4401 1
a4401 1
	skip = TRUE;
d4409 1
a4409 1
	    skip = TRUE;
d4421 5
a4425 5
		 as the TOC anchor--that is, whether we can access all
		 of the TOC using a 16 bit offset from tocval.  This
		 test assumes that the TOC comes at the end of the
		 output section, as it does in the default linker
		 script.  */
d4452 1
a4452 1
		  return FALSE;
d4468 1
a4468 1
	      require = TRUE;
d4476 1
a4476 1
	skip = TRUE;
d4483 1
a4483 1
	skip = TRUE;
d4486 1
a4486 1
	 else.  */
d4494 1
a4494 1
	skip = TRUE;
d4502 1
a4502 1
	skip = TRUE;
d4505 1
a4505 1
	 symbol, then skip it.  */
d4509 1
a4509 1
	skip = TRUE;
d4527 1
a4527 1
	    return FALSE;
d4530 2
a4531 2
	       && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
				    FALSE) == NULL))
d4537 1
a4537 1
	    skip = TRUE;
d4544 1
a4544 1
	skip = FALSE;
d4568 1
a4568 1
		    return FALSE;
d4571 1
a4571 1
		    return FALSE;
d4625 1
a4625 1
			return FALSE;
d4634 2
a4635 2
	     into the line numbers.  We update the symbol values when
	     we handle the line numbers.  */
d4662 2
a4663 2
	     (class XMC_TC), remember the symbol index of the TOC
	     symbol.  */
d4718 1
a4718 1
		 index of the containing csect.  */
d4763 1
a4763 1
			    return FALSE;
d4769 1
a4769 1
			return FALSE;
d4779 1
a4779 1
		     anybody does.  */
d4782 1
a4782 1
		     better clobber them just in case.  */
d4821 3
a4823 3
			     the index of the next symbol we are going
			     to include.  I don't know if this is
			     entirely right.  */
d4880 1
a4880 1
			    return FALSE;
d4940 1
a4940 1
			    return FALSE;
d4952 2
a4953 2
				 that refer to a line number in the
				 range we just output.  */
d5031 1
a5031 1
	return FALSE;
d5042 1
a5042 1
  obj_coff_keep_syms (input_bfd) = TRUE;
d5069 1
a5069 1
	  return FALSE;
d5086 2
a5087 2
			     (input_bfd, o, FALSE, finfo->external_relocs,
			      TRUE,
d5091 1
a5091 1
	    return FALSE;
d5101 1
a5101 1
	    return FALSE;
d5112 1
a5112 1
	      bfd_boolean quiet;
d5156 1
a5156 1
			    return FALSE;
d5236 1
a5236 1
			    return FALSE;
d5241 1
a5241 1
			    return FALSE;
d5246 1
a5246 1
	      quiet = FALSE;
d5293 1
a5293 1
			  return FALSE;
d5298 1
a5298 1
		      if (! finfo->info->relocatable
d5306 1
a5306 1
			  quiet = TRUE;
d5315 1
a5315 1
			  return FALSE;
d5331 1
a5331 1
		      return FALSE;
d5359 1
a5359 1
	return FALSE;
d5367 1
a5367 1
	return FALSE;
d5370 1
a5370 1
  return TRUE;
d5379 1
a5379 1
static bfd_boolean
d5389 1
a5389 1
  bfd_boolean result;
d5400 1
a5400 1
	return TRUE;
d5406 1
a5406 1
    return TRUE;
d5628 1
a5628 1
	  return FALSE;
d5648 4
a5651 2
	  if (!result)
	    return FALSE;
d5677 1
a5677 1
		return FALSE;
d5724 1
a5724 1
	  return FALSE;
d5762 1
a5762 1
	  return FALSE;
d5824 1
a5824 1
	  return FALSE;
d5835 1
a5835 1
      return TRUE;
d5842 1
a5842 1
				  FALSE, FALSE) == NULL)))
d5845 1
a5845 1
      return TRUE;
d5852 1
a5852 1
      return TRUE;
d5861 4
a5864 2
  if (!result)
    return FALSE;
d5960 1
a5960 1
    return FALSE;
d5964 1
a5964 1
  return TRUE;
d5969 1
a5969 1
static bfd_boolean
d5988 3
a5990 3
	 symbol must either have a value of zero, or we must adjust
	 the addend by the value of the symbol.  FIXME: Write this
	 when we need it.  The old linker couldn't handle this anyhow.  */
d5998 1
a5998 1
      return FALSE;
d6004 1
a6004 1
				     FALSE, FALSE, TRUE));
d6010 2
a6011 2
	return FALSE;
      return TRUE;
d6042 1
a6042 1
      bfd_boolean ok;
d6047 1
a6047 1
	return FALSE;
d6064 1
a6064 1
	      return FALSE;
d6072 1
a6072 1
	return FALSE;
d6127 1
a6127 1
	  return FALSE;
d6139 1
a6139 1
	  return FALSE;
d6149 1
a6149 1
  return TRUE;
@


1.28.10.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a1988 1
		      struct bfd_link_hash_entry *bh;
a1996 1
			  bh = &hds->root;
d2001 2
a2002 1
				  true, &bh)))
a2003 1
			  hds = (struct xcoff_link_hash_entry *) bh;
@


1.28.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d118 1
a118 1
static bfd_boolean xcoff_get_section_contents PARAMS ((bfd *, asection *));
d120 1
a120 1
  PARAMS ((bfd *, asection *, bfd_boolean, bfd_byte *, bfd_boolean,
d122 1
a122 1
static bfd_boolean xcoff_link_add_object_symbols
d124 6
a129 6
static bfd_boolean xcoff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean xcoff_link_check_dynamic_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
d132 2
a133 1
static bfd_boolean xcoff_link_add_symbols
d135 1
a135 3
static bfd_boolean xcoff_link_add_dynamic_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean xcoff_mark_symbol
d137 1
a137 1
static bfd_boolean xcoff_mark PARAMS ((struct bfd_link_info *, asection *));
d139 1
a139 1
static bfd_boolean xcoff_build_ldsyms
d141 1
a141 1
static bfd_boolean xcoff_link_input_bfd
d143 1
a143 1
static bfd_boolean xcoff_write_global_symbol
d145 1
a145 1
static bfd_boolean xcoff_reloc_link_order
d157 1
a157 1
static bfd_boolean
d168 1
a168 1
	return FALSE;
d176 1
a176 1
	return FALSE;
d181 1
a181 1
	return FALSE;
d184 1
a184 1
  return TRUE;
d250 1
a250 1
  coff_section_data (abfd, lsec)->keep_contents = TRUE;
d298 1
a298 1
	 with the loader symbol.  */
d424 2
a425 2
	 correct if ldrel.l_rtype == 0.  In other cases, we should use
	 a different howto.  */
d504 2
a505 2
  ret->textro = FALSE;
  ret->gc = FALSE;
d511 1
a511 1
  xcoff_data (abfd)->full_aouthdr = TRUE;
d538 1
a538 1
     bfd_boolean cache;
d540 1
a540 1
     bfd_boolean require_internal;
d558 2
a559 2
	  if (_bfd_coff_read_internal_relocs (abfd, enclosing, TRUE,
					      external_relocs, FALSE,
d590 1
a590 1
bfd_boolean
d603 4
a606 4
	 to check the archive for dynamic objects, because they may not
	 appear in the archive map even though they should, perhaps, be
	 included.  If the archive has no map, we just consider each object
	 file in turn, since that apparently is what the AIX native linker
d612 1
a612 1
	    return FALSE;
d617 1
a617 1

d625 3
a627 3
		bfd_boolean needed;

		if (! xcoff_link_check_archive_element (member, info,
d629 1
a629 1
		  return FALSE;
d637 1
a637 1
      return TRUE;
d641 1
a641 1
      return FALSE;
d647 1
a647 1
static bfd_boolean
d654 1
a654 1
    return FALSE;
d656 1
a656 1
    return FALSE;
d660 1
a660 1
	return FALSE;
d662 1
a662 1
  return TRUE;
d670 1
a670 1
static bfd_boolean
d674 1
a674 1
     bfd_boolean *pneeded;
d678 1
a678 1
    return FALSE;
d681 1
a681 1
    return FALSE;
d686 1
a686 1
	return FALSE;
d692 1
a692 1
	return FALSE;
d695 1
a695 1
  return TRUE;
d701 1
a701 1
static bfd_boolean
d705 1
a705 1
     bfd_boolean *pneeded;
d711 1
a711 1
  *pneeded = FALSE;
d734 1
a734 1
	     object file.  */
d739 2
a740 2
	    return FALSE;
	  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d754 3
a756 3
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
d764 1
a764 1
  return TRUE;
d771 1
a771 1
static bfd_boolean
d775 1
a775 1
     bfd_boolean *pneeded;
d783 1
a783 1
  *pneeded = FALSE;
d789 1
a789 1
      return TRUE;
d793 1
a793 1
    return FALSE;
d825 1
a825 1
      h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d828 2
a829 2
	 undefined.  At this point we know that we are using an XCOFF
	 hash table.  */
d836 3
a838 3
	    return FALSE;
	  *pneeded = TRUE;
	  return TRUE;
d850 1
a850 1
  return TRUE;
d908 1
a908 1
static bfd_boolean
d912 1
a912 1
  bfd_boolean return_value = FALSE;
d1001 1
a1001 1
  return_value = TRUE;
d1026 1
a1026 1
static bfd_boolean
d1033 1
a1033 1
  bfd_boolean default_copy;
d1040 1
a1040 1
  bfd_boolean keep_syms;
d1061 1
a1061 1
	return FALSE;
d1065 1
a1065 1
  if (! xcoff_link_create_extra_sections (abfd, info))
d1070 1
a1070 1
    return TRUE;
d1080 1
a1080 1
    default_copy = FALSE;
d1082 1
a1082 1
    default_copy = TRUE;
d1125 2
a1126 2
	    xcoff_read_internal_relocs (abfd, o, TRUE, (bfd_byte *) NULL,
					FALSE, (struct internal_reloc *) NULL);
d1153 1
a1153 1
  obj_coff_keep_syms (abfd) = TRUE;
d1217 5
a1221 5
	 and we're not stripping it, count the number of entries and
	 add them to the count for this csect.  In the final link pass
	 we are going to attach line number information by symbol,
	 rather than by section, in order to more easily handle
	 garbage collection.  */
d1339 1
a1339 1
	     an absolute location.  */
d1433 1
a1433 1
		      bfd_boolean copy;
d1456 2
a1457 2
						      relname, TRUE, copy,
						      FALSE);
d1609 1
a1609 1
	    bfd_boolean bad;
d1611 1
a1611 1
	    bad = FALSE;
d1615 1
a1615 1
	      bad = TRUE;
d1621 1
a1621 1
		  bad = TRUE;
d1638 5
a1642 5
	     the storage mapping class, but we don't bother except for
	     an XMC_TD symbol.  If this csect is externally visible,
	     it is a common symbol.  We put XMC_TD symbols in sections
	     named .tocbss, and rely on the linker script to put that
	     in the TOC area.  */
d1733 1
a1733 1
	 linker hash table.  */
d1737 1
a1737 1
	  bfd_boolean copy;
d1742 1
a1742 1
	     syment itself, rather than the string table.  */
d1746 1
a1746 1
	    copy = TRUE;
d1778 1
a1778 1
						      name, TRUE, copy, FALSE);
d1786 2
a1787 2
							     TRUE, TRUE,
							     FALSE));
d1804 5
a1808 5
			 either the existing symbol is not global
			 linkage code or this symbol is global linkage
			 code.  If the existing symbol is global
			 linkage code and the new symbol is not, then
			 we want to use the new symbol.  */
d1816 1
a1816 1
			 Replace it.  */
d1824 2
a1825 2
			 in an archive.  Just ignore it.  See the
			 comment above.  */
d1833 3
a1835 3
			 case, we just continue and permit the
			 multiple definition error.  See the comment
			 above about the behaviour of the AIX linker.  */
d1840 2
a1841 2
			 class.  There is at least a chance that this
			 is a semi-legitimate redefinition.  */
d1886 1
a1886 1
		  (const char *) NULL, copy, TRUE,
d1977 8
a1984 8
		     the code of a function.  If the symbol is
		     currently undefined, then add an undefined symbol
		     for the function descriptor.  This should do no
		     harm, because any regular object that defines the
		     function should also define the function
		     descriptor.  It helps, because it means that we
		     will identify the function descriptor with a
		     dynamic object if a dynamic object defines it.  */
d1993 1
a1993 1
						    TRUE, FALSE, TRUE);
d2002 2
a2003 2
				  (bfd_vma) 0, (const char *) NULL, FALSE,
				  TRUE, &bh)))
d2036 1
a2036 1
	 somewhere for the final link, to avoid reading them again.  */
d2048 1
a2048 1
  return TRUE;
d2063 1
a2063 1
  return FALSE;
d2072 1
a2072 1
static bfd_boolean
d2097 1
a2097 1
      return FALSE;
d2118 1
a2118 1
      return FALSE;
d2123 1
a2123 1
    return FALSE;
d2165 2
a2166 2
      h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE,
				  TRUE, TRUE);
d2168 1
a2168 1
	return FALSE;
d2194 3
a2196 3
	 define it, since we don't have a section to put it in anyhow.
	 Instead, the relocation routines handle the DEF_DYNAMIC flag
	 correctly.  */
d2224 1
a2224 1
		return FALSE;
d2228 1
a2228 1
					    TRUE, TRUE, TRUE);
d2231 1
a2231 1
		return FALSE;
d2238 1
a2238 1
		     symbol list.  */
d2275 1
a2275 1
    return FALSE;
d2308 1
a2308 1
  return TRUE;
d2317 1
a2317 1
static INLINE bfd_boolean
d2324 1
a2324 1
    return TRUE;
d2337 1
a2337 1
	    return FALSE;
d2345 1
a2345 1
	return FALSE;
d2348 1
a2348 1
  return TRUE;
d2357 1
a2357 1
static bfd_boolean
d2364 1
a2364 1
    return TRUE;
d2390 1
a2390 1
		return FALSE;
d2399 2
a2400 2
	  rel = xcoff_read_internal_relocs (sec->owner, sec, TRUE,
					    (bfd_byte *) NULL, FALSE,
d2403 1
a2403 1
	    return FALSE;
d2419 1
a2419 1
		    return FALSE;
d2427 1
a2427 1
		    return FALSE;
d2431 1
a2431 1
		 section.  */
d2480 1
a2480 1
  return TRUE;
d2501 2
a2502 2
		 special sections.  Keep .debug sections for the
		 moment.  */
d2525 1
a2525 1
bfd_boolean
d2537 1
a2537 1
    return TRUE;
d2546 1
a2546 1
    return FALSE;
d2554 1
a2554 1
  return TRUE;
d2559 1
a2559 1
bfd_boolean
d2574 1
a2574 1
    return TRUE;
d2590 1
a2590 1
					TRUE, FALSE, TRUE);
d2592 1
a2592 1
	    return FALSE;
d2606 2
a2607 2
	 rather than the symbol we were told to import.  FIXME: Is
	 this correct in all cases?  */
d2624 1
a2624 1
	    return FALSE;
d2644 1
a2644 1
	 reserved for the library search path.  */
d2662 1
a2662 1
	    return FALSE;
d2673 1
a2673 1
  return TRUE;
d2678 1
a2678 1
bfd_boolean
d2687 1
a2687 1
    return TRUE;
d2705 1
a2705 1
	return FALSE;
d2709 1
a2709 1
				    fnname, FALSE, FALSE, TRUE);
d2724 1
a2724 1
    return FALSE;
d2734 1
a2734 1
	return FALSE;
d2737 1
a2737 1
  return TRUE;
d2744 1
a2744 1
bfd_boolean
d2753 1
a2753 1
    return TRUE;
d2756 2
a2757 2
       bfd_wrapped_link_hash_lookup (output_bfd, info, name, FALSE, FALSE,
				     FALSE));
d2762 1
a2762 1
      return FALSE;
d2770 1
a2770 1
    return FALSE;
d2772 1
a2772 1
  return TRUE;
d2778 1
a2778 1
bfd_boolean
d2787 1
a2787 1
    return TRUE;
d2789 2
a2790 2
  h = xcoff_link_hash_lookup (xcoff_hash_table (info), name, TRUE, TRUE,
			      FALSE);
d2792 1
a2792 1
    return FALSE;
d2796 1
a2796 1
  return TRUE;
d2816 1
a2816 1
bfd_boolean
d2828 1
a2828 1
     bfd_boolean gc;
d2830 2
a2831 2
     bfd_boolean textro;
     bfd_boolean export_defineds;
d2833 1
a2833 1
     bfd_boolean rtld;
d2854 1
a2854 1
      return TRUE;
d2857 1
a2857 1
  ldinfo.failed = FALSE;
d2877 1
a2877 1
				       FALSE, FALSE, TRUE);
d2883 1
a2883 1
  if (info->init_function || info->fini_function || rtld)
d2887 1
a2887 1

d2889 1
a2889 1
				     "__rtinit", FALSE, FALSE, TRUE);
d2894 1
a2894 1
	  return FALSE;
d2896 1
a2896 1

d2903 8
a2910 8

      ldsym->l_value = 0;		/* will be filled in later */
      ldsym->l_scnum = 2;		/* data section */
      ldsym->l_smtype = XTY_SD;		/* csect section definition */
      ldsym->l_smclas = 5;		/* .rw */
      ldsym->l_ifile = 0;		/* special system loader symbol */
      ldsym->l_parm = 0;		/* NA */

d2913 1
a2913 1

d2917 1
a2917 1

d2921 6
a2926 5

      if (! bfd_xcoff_put_ldsymbol_name (ldinfo.output_bfd, &ldinfo,
					 hsym->ldsym, hsym->root.root.string))
	return FALSE;

d2941 2
a2942 2
      gc = FALSE;
      xcoff_hash_table (info)->gc = FALSE;
d2945 1
a2945 1
	 correctly.  */
d2965 1
a2965 1
      xcoff_hash_table (info)->gc = TRUE;
d2985 1
a2985 1
      return TRUE;
d3161 1
a3161 1
      if (NULL != csectpp)
d3186 1
a3186 1
		  indx = _bfd_stringtab_add (debug_strtab, name, TRUE, TRUE);
d3216 1
a3216 1
  return TRUE;
d3223 1
a3223 1
  return FALSE;
d3226 1
a3226 1
bfd_boolean
d3231 1
a3231 1
     bfd_boolean rtld;
d3234 1
a3234 1

d3238 1
a3238 1
    return FALSE;
d3250 2
a3251 2
  if (! bfd_xcoff_generate_rtinit (abfd, init, fini, rtld))
    return FALSE;
d3258 1
a3258 1
  return TRUE;
d3264 1
a3264 1
static bfd_boolean
d3277 1
a3277 1
      return TRUE;
d3299 1
a3299 1
      bfd_boolean export;
d3315 1
a3315 1
      export = TRUE;
d3329 1
a3329 1
		  export = FALSE;
d3378 1
a3378 1
	 descriptor.  */
d3396 1
a3396 1
	    return FALSE;
d3428 4
a3431 4
	     a defined entry point.  We can build up a function
	     descriptor ourselves.  Believe it or not, the AIX linker
	     actually does this, and there are cases where we need to
	     do it as well.  */
d3458 1
a3458 1
	  return TRUE;
d3487 1
a3487 1
      return TRUE;
d3496 1
a3496 1
      return TRUE;
d3502 1
a3502 1
    return TRUE;
d3511 2
a3512 2
      ldinfo->failed = TRUE;
      return FALSE;
d3524 3
a3526 2
  if (! bfd_xcoff_put_ldsymbol_name (ldinfo->output_bfd, ldinfo,
				     h->ldsym, h->root.root.string))
d3528 1
a3528 1
      return FALSE;
d3533 1
a3533 1
  return TRUE;
d3538 1
a3538 1
bfd_boolean
d3614 1
a3614 1
	      sec->linker_mark = TRUE;
d3654 1
a3654 1
	  bfd_boolean saw_contents;
d3658 1
a3658 1

d3660 3
a3662 3
	     contents and is loaded, if it is preceded by some other
	     section which has contents and is loaded.  */
	  saw_contents = TRUE;
d3666 1
a3666 1
		saw_contents = FALSE;
d3671 1
a3671 1
		    saw_contents = TRUE;
d3675 1
a3675 1

d3677 1
a3677 1
			 that needs padding.  This requires unlinking and
d3679 1
a3679 1

d3683 1
a3683 1
		      n->alignment_power = 0;
d3690 1
a3690 1
		      saw_contents = FALSE;
d3694 1
a3694 1

d3696 1
a3696 1
	     sections.  */
d3706 3
a3708 3
	     each section to land on a page boundary.  This bit of
	     code knows what compute_section_file_positions is going
	     to do.  */
d3778 2
a3779 2
	     allocate the buffers, so that later code doesn't have to
	     worry about whether we are stripping or not.  */
d3790 7
a3796 7
	     written out all the local symbols.  For each section in
	     the output file, we keep an array of pointers to hash
	     table entries.  Each entry in the array corresponds to a
	     reloc.  When we find a reloc against a global symbol, we
	     set the corresponding entry in this array so that we can
	     fix up the symbol index after we have written out all the
	     local symbols.
d3853 1
a3853 1
      sub->output_has_begun = FALSE;
d3906 1
a3906 1
		  sub->output_has_begun = TRUE;
d4145 1
a4145 1
  return TRUE;
d4179 1
a4179 1
  return FALSE;
d4185 1
a4185 1
static bfd_boolean
d4195 1
a4195 1
  bfd_boolean copy, hash;
d4210 1
a4210 1
  bfd_boolean keep_syms;
d4216 1
a4216 1
    return TRUE;
d4235 1
a4235 1
  copy = FALSE;
d4237 2
a4238 2
    copy = TRUE;
  hash = TRUE;
d4240 1
a4240 1
    hash = FALSE;
d4243 1
a4243 1
    return FALSE;
d4263 2
a4264 2
      bfd_boolean skip;
      bfd_boolean require;
d4270 1
a4270 1
	 information.  */
d4290 3
a4292 3
	 .loader symbol information.  If this is an external symbol
	 reference to a defined symbol, though, then wait until we get
	 to the definition.  */
d4382 2
a4383 2
      skip = FALSE;
      require = FALSE;
d4388 1
a4388 1
	skip = TRUE;
d4391 1
a4391 1
	 symbol.  */
d4396 1
a4396 1
	skip = TRUE;
d4401 1
a4401 1
	skip = TRUE;
d4409 1
a4409 1
	    skip = TRUE;
d4421 5
a4425 5
		 as the TOC anchor--that is, whether we can access all
		 of the TOC using a 16 bit offset from tocval.  This
		 test assumes that the TOC comes at the end of the
		 output section, as it does in the default linker
		 script.  */
d4452 1
a4452 1
		  return FALSE;
d4468 1
a4468 1
	      require = TRUE;
d4476 1
a4476 1
	skip = TRUE;
d4483 1
a4483 1
	skip = TRUE;
d4486 1
a4486 1
	 else.  */
d4494 1
a4494 1
	skip = TRUE;
d4502 1
a4502 1
	skip = TRUE;
d4505 1
a4505 1
	 symbol, then skip it.  */
d4509 1
a4509 1
	skip = TRUE;
d4527 1
a4527 1
	    return FALSE;
d4530 2
a4531 2
	       && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
				    FALSE) == NULL))
d4537 1
a4537 1
	    skip = TRUE;
d4544 1
a4544 1
	skip = FALSE;
d4568 1
a4568 1
		    return FALSE;
d4571 1
a4571 1
		    return FALSE;
d4625 1
a4625 1
			return FALSE;
d4634 2
a4635 2
	     into the line numbers.  We update the symbol values when
	     we handle the line numbers.  */
d4662 2
a4663 2
	     (class XMC_TC), remember the symbol index of the TOC
	     symbol.  */
d4718 1
a4718 1
		 index of the containing csect.  */
d4763 1
a4763 1
			    return FALSE;
d4769 1
a4769 1
			return FALSE;
d4779 1
a4779 1
		     anybody does.  */
d4782 1
a4782 1
		     better clobber them just in case.  */
d4821 3
a4823 3
			     the index of the next symbol we are going
			     to include.  I don't know if this is
			     entirely right.  */
d4880 1
a4880 1
			    return FALSE;
d4940 1
a4940 1
			    return FALSE;
d4952 2
a4953 2
				 that refer to a line number in the
				 range we just output.  */
d5031 1
a5031 1
	return FALSE;
d5042 1
a5042 1
  obj_coff_keep_syms (input_bfd) = TRUE;
d5069 1
a5069 1
	  return FALSE;
d5086 2
a5087 2
			     (input_bfd, o, FALSE, finfo->external_relocs,
			      TRUE,
d5091 1
a5091 1
	    return FALSE;
d5101 1
a5101 1
	    return FALSE;
d5112 1
a5112 1
	      bfd_boolean quiet;
d5156 1
a5156 1
			    return FALSE;
d5236 1
a5236 1
			    return FALSE;
d5241 1
a5241 1
			    return FALSE;
d5246 1
a5246 1
	      quiet = FALSE;
d5293 1
a5293 1
			  return FALSE;
d5306 1
a5306 1
			  quiet = TRUE;
d5315 1
a5315 1
			  return FALSE;
d5331 1
a5331 1
		      return FALSE;
d5359 1
a5359 1
	return FALSE;
d5367 1
a5367 1
	return FALSE;
d5370 1
a5370 1
  return TRUE;
d5379 1
a5379 1
static bfd_boolean
d5389 1
a5389 1
  bfd_boolean result;
d5400 1
a5400 1
	return TRUE;
d5406 1
a5406 1
    return TRUE;
d5628 1
a5628 1
	  return FALSE;
d5648 4
a5651 2
	  if (!result)
	    return FALSE;
d5677 1
a5677 1
		return FALSE;
d5724 1
a5724 1
	  return FALSE;
d5762 1
a5762 1
	  return FALSE;
d5824 1
a5824 1
	  return FALSE;
d5835 1
a5835 1
      return TRUE;
d5842 1
a5842 1
				  FALSE, FALSE) == NULL)))
d5845 1
a5845 1
      return TRUE;
d5852 1
a5852 1
      return TRUE;
d5861 4
a5864 2
  if (!result)
    return FALSE;
d5960 1
a5960 1
    return FALSE;
d5964 1
a5964 1
  return TRUE;
d5969 1
a5969 1
static bfd_boolean
d5988 3
a5990 3
	 symbol must either have a value of zero, or we must adjust
	 the addend by the value of the symbol.  FIXME: Write this
	 when we need it.  The old linker couldn't handle this anyhow.  */
d5998 1
a5998 1
      return FALSE;
d6004 1
a6004 1
				     FALSE, FALSE, TRUE));
d6010 2
a6011 2
	return FALSE;
      return TRUE;
d6042 1
a6042 1
      bfd_boolean ok;
d6047 1
a6047 1
	return FALSE;
d6064 1
a6064 1
	      return FALSE;
d6072 1
a6072 1
	return FALSE;
d6127 1
a6127 1
	  return FALSE;
d6139 1
a6139 1
	  return FALSE;
d6149 1
a6149 1
  return TRUE;
@


1.28.10.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d2935 1
a2935 1
  if (info->relocatable
d5297 1
a5297 1
		      if (! finfo->info->relocatable
@


1.28.10.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1251 1
a1251 1
	      /* explicit cast to bfd_signed_vma for compiler */
d1830 1
a1830 1
		  else if ((*sym_hash)->root.und_next != NULL
d2901 1
a2901 1
      /* __rtinit initialized */
@


1.27
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d5890 4
a5893 1
      isym.n_scnum = h->root.u.def.section->output_section->target_index;
@


1.27.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d5890 1
a5890 4
      if (bfd_is_abs_section (h->root.u.def.section->output_section))
	isym.n_scnum = N_ABS;
      else
	isym.n_scnum = h->root.u.def.section->output_section->target_index;
@


1.27.2.2
log
@Fix numerous occurrences of
warning: dereferencing type-punned pointer will break strict-aliasing rules
@
text
@a1988 1
		      struct bfd_link_hash_entry *bh;
a1996 1
			  bh = &hds->root;
d2001 2
a2002 1
				  true, &bh)))
a2003 1
			  hds = (struct xcoff_link_hash_entry *) bh;
@


1.26
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d2881 1
a2881 1
  if (info->init_function || info->fini_function || rtld == true) 
@


1.25
log
@Fix a problem with static linking with cross tools.
@
text
@d1089 1
a1089 1
  sym_hash = (struct xcoff_link_hash_entry **) bfd_alloc (abfd, amt);
a1092 1
  memset (sym_hash, 0, (size_t) amt);
d1098 1
a1098 1
  csect_cache = (asection **) bfd_alloc (abfd, amt);
a1101 1
  memset (csect_cache, 0, (size_t) amt);
d1110 1
a1110 1
  reloc_info = (struct reloc_info_struct *) bfd_malloc (amt);
a1112 1
  memset ((PTR) reloc_info, 0, (size_t) amt);
d1129 1
a1129 1
	  reloc_info[o->target_index].csects = (asection **) bfd_malloc (amt);
a1131 2
	  memset (reloc_info[o->target_index].csects, 0, (size_t) amt);

@


1.25.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1089 1
a1089 1
  sym_hash = (struct xcoff_link_hash_entry **) bfd_zalloc (abfd, amt);
d1093 1
d1099 1
a1099 1
  csect_cache = (asection **) bfd_zalloc (abfd, amt);
d1103 1
d1112 1
a1112 1
  reloc_info = (struct reloc_info_struct *) bfd_zmalloc (amt);
d1115 1
d1132 1
a1132 1
	  reloc_info[o->target_index].csects = (asection **) bfd_zmalloc (amt);
d1135 2
@


1.25.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d2881 1
a2881 1
  if (info->init_function || info->fini_function || rtld) 
@


1.25.6.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d5890 1
a5890 4
      if (bfd_is_abs_section (h->root.u.def.section->output_section))
	isym.n_scnum = N_ABS;
      else
	isym.n_scnum = h->root.u.def.section->output_section->target_index;
@


1.25.6.4
log
@merge from mainline
@
text
@a1988 1
		      struct bfd_link_hash_entry *bh;
a1996 1
			  bh = &hds->root;
d2001 2
a2002 1
				  true, &bh)))
a2003 1
			  hds = (struct xcoff_link_hash_entry *) bh;
@


1.25.4.1
log
@merge from trunk
@
text
@d1089 1
a1089 1
  sym_hash = (struct xcoff_link_hash_entry **) bfd_zalloc (abfd, amt);
d1093 1
d1099 1
a1099 1
  csect_cache = (asection **) bfd_zalloc (abfd, amt);
d1103 1
d1112 1
a1112 1
  reloc_info = (struct reloc_info_struct *) bfd_zmalloc (amt);
d1115 1
d1132 1
a1132 1
	  reloc_info[o->target_index].csects = (asection **) bfd_zmalloc (amt);
d1135 2
@


1.24
log
@	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
@
text
@d1781 4
a1784 2
		*sym_hash = xcoff_link_hash_lookup (xcoff_hash_table (info),
						    name, true, copy, false);
d1786 8
a1793 3
		*sym_hash = ((struct xcoff_link_hash_entry *)
			     bfd_wrapped_link_hash_lookup (abfd, info, name,
							   true, copy, false));
@


1.23
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d2124 1
a2124 1
  abfd->sections = NULL;
@


1.22
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d485 1
a485 1
  ret = (struct xcoff_link_hash_table *) bfd_alloc (abfd, amt);
d490 1
a490 1
      bfd_release (abfd, ret);
d516 12
@


1.21
log
@Fix problem with linking shared libstdc++-v3 on AIX.
@
text
@d3256 3
d5379 7
@


1.20
log
@Add AIX 64 shared library support and emulation layer for binutils
@
text
@d591 5
a595 5
         to check the archive for stripped dynamic objects, because
         they will not appear in the archive map even though they
         should, perhaps, be included.  If the archive has no map, we
         just consider each object file in turn, since that apparently
         is what the AIX native linker does.  */
d605 1
a605 1

d610 2
a611 3
		&& (! bfd_has_map (abfd)
		    || ((member->flags & DYNAMIC) != 0
			&& (member->flags & HAS_SYMS) == 0)))
d614 3
a616 2

		if (! xcoff_link_check_archive_element (member, info, &needed))
@


1.19
log
@Add support for -brtl, run time linking, to AIX ld.
@
text
@d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d3144 35
a3178 26
      symesz = bfd_coff_symesz (sub);
      esym = (bfd_byte *) obj_coff_external_syms (sub);
      esymend = esym + symcount * symesz;
      while (esym < esymend)
	{
	  struct internal_syment sym;

	  bfd_coff_swap_sym_in (sub, (PTR) esym, (PTR) &sym);

	  *debug_index = (unsigned long) -1;

	  if (sym._n._n_n._n_zeroes == 0
	      && *csectpp != NULL
	      && (! gc
		  || ((*csectpp)->flags & SEC_MARK) != 0
		  || *csectpp == bfd_abs_section_ptr)
	      && bfd_coff_symname_in_debug (sub, &sym))
	    {
	      char *name;
	      bfd_size_type indx;

	      name = (char *) debug_contents + sym._n._n_n._n_offset;
	      indx = _bfd_stringtab_add (debug_strtab, name, true, true);
	      if (indx == (bfd_size_type) -1)
		goto error_return;
	      *debug_index = indx;
a3179 4

	  esym += (sym.n_numaux + 1) * symesz;
	  csectpp += sym.n_numaux + 1;
	  debug_index += sym.n_numaux + 1;
@


1.18
log
@	* section.c (bfd_section_init): Remove unnecessary initialisations.
	(bfd_section_list_clear): New function.
	(bfd_section_list_remove, bfd_section_list_insert): New macros.
	(_bfd_strip_section_from_output): Use them.
	* coffcode.h (coff_set_alignment_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_final_link): Likewise.
	* elf64-mips.c (mips_elf64_final_link): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.
	* bfd-in2.h: Regenerate.

	* netbsd-core.c (netbsd_core_file_p): Use bfd_make_section_anyway
	rather than doing our own section handling.  Clean up after errors
	with bfd_release and bfd_section_list_clear.  Handle unexpected
	flags.
	* aoutf1.h (sunos4_core_file_p): Likewise.
	* aix386-core.c (aix386_core_file_p): Likewise.
	* cisco-core.c (cisco_core_file_validate): Likewise.
	* ptrace-core.c (ptrace_unix_core_file_p): Likewise.
	* trad-core.c (trad_unix_core_file_p): Likewise.

	* hppabsd-core.c (hppabsd_core_core_file_p):  Clean up after errors
	with bfd_release and bfd_section_list_clear.
	* hpux-core.c (hpux_core_core_file_p): Likewise.
	* irix-core.c (irix_core_core_file_p): Likewise.
	* lynx-core.c (lynx_core_file_p): Likewise.
	* osf-core.c (osf_core_core_file_p): Likewise.
	* rs6000-core.c (rs6000coff_core_p): Likewise.
	* sco5-core.c (sco5_core_file_p): Likewise.
@
text
@d1049 1
a1049 3
	{
	  return false;
	}
d1054 1
a1054 3
    {
      goto error_return;
    }
a1144 1

d2804 1
a2804 1
				 special_sections)
d2817 1
a2835 1

d2857 2
a2858 5
  if (entry == NULL)
    {
      hentry = NULL;
    }
  else
d2867 42
a2908 17
  if (info->init_function || info->fini_function) {
    struct xcoff_link_hash_entry *hrtinit;
    struct internal_ldsym *ldsym;

    hrtinit = xcoff_link_hash_lookup (xcoff_hash_table (info),
				      "__rtinit",
				      false, false, true);
    if (hrtinit != NULL)
      {
	xcoff_mark_symbol (info, hrtinit);
	hrtinit->flags |= (XCOFF_DEF_REGULAR | XCOFF_RTINIT);
      }
    else
      {
	(*_bfd_error_handler)
	  (_("error: undefined symbol __rtinit"));

d2910 7
a2916 41
      }

    /* __rtinit initalized here
       Some information, like the location of the .initfini seciton will
       be filled in later.

       name or offset taken care of below with bfd_xcoff_put_ldsymbol_name.  */
    amt = sizeof (struct internal_ldsym);
    ldsym = (struct internal_ldsym *) bfd_malloc (amt);

    ldsym->l_value = 0;                  /* will be filled in later */
    ldsym->l_scnum = 2;                  /* data section */
    ldsym->l_smtype = XTY_SD;            /* csect section definition */
    ldsym->l_smclas = 5;                 /* .rw */
    ldsym->l_ifile = 0;                  /* special system loader symbol */
    ldsym->l_parm = 0;                   /* NA */

    /* Force __rtinit to be the first symbol in the loader symbol table
       See xcoff_build_ldsyms

       The first 3 symbol table indices are reserved to indicate the data,
       text and bss sections.  */
    BFD_ASSERT (0 == ldinfo.ldsym_count);

    hrtinit->ldindx = 3;
    ldinfo.ldsym_count = 1;
    hrtinit->ldsym = ldsym;

    if (false == bfd_xcoff_put_ldsymbol_name (ldinfo.output_bfd, &ldinfo,
					      hrtinit->ldsym,
					      hrtinit->root.root.string))
      {
	return false;
      }

    /* This symbol is written out by xcoff_write_global_symbol
       Set stuff up so xcoff_write_global_symbol logic works.  */
    hrtinit->flags |= XCOFF_DEF_REGULAR | XCOFF_MARK;
    hrtinit->root.type = bfd_link_hash_defined;
    hrtinit->root.u.def.value = 0;
  }
d3206 1
a3206 1
bfd_xcoff_link_generate_rtinit (abfd, init, fini)
d3210 1
d3229 1
a3229 1
  if (false == bfd_xcoff_generate_rtinit (abfd, init, fini)) 
d3251 1
a3251 4
  /* __rtinit
     Special handling of this symbol to make is the first symbol in
     the loader symbol table.  Make sure this pass through does not
     undo it.  */
a3252 1
    {
a3253 1
    }
d3368 1
a3368 3
	    {
	      byte_size = 8;
	    }
d3370 1
a3370 3
	    {
	      byte_size = 4;
	    }
d3372 1
a3372 3
	    {
	      return false;
	    }
@


1.18.2.1
log
@Merge from mainline.
@
text
@a3266 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct xcoff_link_hash_entry *) h->root.u.i.link;

a5397 7

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct xcoff_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return true;
    }
@


1.18.2.2
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@d2117 1
a2117 1
  bfd_section_list_clear (abfd);
@


1.17
log
@Fix xcoff linker's ordering of pad sections
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
d3659 1
a3659 1
	  asection **op, **prev;
d3666 1
a3666 2
	  for (op = &abfd->sections, prev = NULL; 
	       *op != NULL; prev = op, op = &(*op)->next)
d3677 1
a3677 1
		      asection *n, *hold, **st;
d3681 1
a3681 7
			 relinking the bfd's sections list. 
			 
			 sections = S1
			 .          S1.next = S2
			 .          S2.next = S3
			 .          S3.next = NULL
			 section_tail = &S3.next */
a3682 1
		      hold = *op;
a3683 1
		      
a3686 9
		      
		      if (NULL == prev) 
			abfd->sections = n;
		      else
			(*prev)->next = n;
		      
		      n->next = hold;
		      *st = NULL;
		      abfd->section_tail = st;
d3688 5
@


1.16
log
@-binitfini emulation, put __rtinit symbol generation into linker.
@
text
@d3659 1
a3659 1
	  asection **op;
d3661 1
a3661 1

d3666 2
a3667 1
	  for (op = &abfd->sections; *op != NULL; op = &(*op)->next)
d3678 12
a3689 2
		      asection *n, *hold;

d3691 2
a3692 1
		      *op = NULL;
d3694 8
a3701 1
		      BFD_ASSERT (*op == n);
d3703 3
a3705 2
		      n->flags = SEC_HAS_CONTENTS;
		      n->alignment_power = 0;
d3710 1
a3710 1

a3979 11

  /* init-fini */
  if (info->init_function || info->fini_function)
    {
      struct xcoff_link_hash_entry *hrtinit;

      hrtinit = xcoff_link_hash_lookup (xcoff_hash_table (info),
					"__rtinit",
					false, false, true);
    }

@


1.15
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d3222 35
@


1.14
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1242 1
a1242 1
		     bfd_get_filename (abfd), name);
d1295 1
a1295 1
	     bfd_get_filename (abfd), sym.n_sclass, name);
d1318 1
a1318 1
	     bfd_get_filename (abfd), name, smtyp);
d1330 1
a1330 1
		 bfd_get_filename (abfd), name, sym.n_sclass, sym.n_scnum,
d1366 1
a1366 1
		     bfd_get_filename (abfd), name, sym.n_sclass,
d1518 1
a1518 1
		   bfd_get_filename (abfd), name);
d1625 1
a1625 1
		   bfd_get_filename (abfd), name);
d1949 1
a1949 1
		     bfd_get_filename (abfd), o->name, i);
d5262 1
a5262 1
			     bfd_get_filename (input_bfd),
d5284 1
a5284 1
			     bfd_get_filename (input_bfd),
d5299 1
a5299 1
			 bfd_get_filename (input_bfd),
@


1.13
log
@Fix import symbols for AIX.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
d42 2
a43 1
struct xcoff_import_file {
d57 2
a58 1
struct xcoff_link_section_info {
d77 2
a78 1
struct xcoff_final_link_info {
d165 2
a166 2
      sec->used_by_bfd = bfd_zalloc (abfd,
				     sizeof (struct coff_section_tdata));
d173 2
a174 2
      coff_section_data (abfd, sec)->contents =
	(bfd_byte *) bfd_malloc (sec->_raw_size);
d278 1
a278 1
	  c = bfd_alloc (abfd, SYMNMLEN + 1);
d380 2
a381 2
  for (; elrel < elrelend; elrel += bfd_xcoff_ldrelsz(abfd), relbuf++, 
	   prelocs++)
d483 1
d485 1
a485 2
  ret = ((struct xcoff_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct xcoff_link_hash_table)));
d737 1
a737 1
 	      && (info->hash->creator != abfd->xvec 
d892 4
a895 5
/* 
 * xcoff_link_create_extra_sections
 *
 * Takes care of creating the .loader, .gl, .ds, .debug and sections
 */
d897 2
a898 1
xcoff_link_create_extra_sections(bfd * abfd, struct bfd_link_info *info) {
d902 2
a903 1
   if (info->hash->creator == abfd->xvec) { 
d909 11
a919 6
      if (xcoff_hash_table (info)->loader_section == NULL) {
	asection *lsec;
	
	lsec = bfd_make_section_anyway (abfd, ".loader");
	if (lsec == NULL) {
	  goto end_return;
a920 3
	xcoff_hash_table (info)->loader_section = lsec;
	lsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
      }
d923 9
a931 2
      if (xcoff_hash_table (info)->linkage_section == NULL) {
	asection *lsec;
d933 4
a936 3
	lsec = bfd_make_section_anyway (abfd, ".gl");
	if (lsec == NULL) {
	  goto end_return;
d939 10
a948 5
	xcoff_hash_table (info)->linkage_section = lsec;
	lsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			| SEC_IN_MEMORY);
	lsec->alignment_power = 2;
      }
d950 4
a953 7
      /* Likewise for the TOC section.  */
      if (xcoff_hash_table (info)->toc_section == NULL) {
	asection *tsec;
	
	tsec = bfd_make_section_anyway (abfd, ".tc");
	if (tsec == NULL) {
	  goto end_return;
d956 10
a965 5
	xcoff_hash_table (info)->toc_section = tsec;
	tsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			| SEC_IN_MEMORY);
	tsec->alignment_power = 2;
      }
d967 4
a970 7
      /* Likewise for the descriptor section.  */
      if (xcoff_hash_table (info)->descriptor_section == NULL) {
	asection *dsec;
	
	dsec = bfd_make_section_anyway (abfd, ".ds");
	if (dsec == NULL) {
	  goto end_return;
a972 6
	xcoff_hash_table (info)->descriptor_section = dsec;
	dsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			| SEC_IN_MEMORY);
	dsec->alignment_power = 2;
      }

d975 3
a977 2
	  && info->strip != strip_all) {
	asection *dsec;
d979 7
a985 3
	dsec = bfd_make_section_anyway (abfd, ".debug");
	if (dsec == NULL) {
	  goto end_return;
d987 2
a988 5
	xcoff_hash_table (info)->debug_section = dsec;
	dsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
      }
  } 
  
d1035 1
a1035 1
  struct reloc_info_struct 
d1041 1
d1046 6
a1051 3
      && ! info->static_link) {
    if (! xcoff_link_add_dynamic_symbols (abfd, info)) {
      return false;
a1052 1
  }
d1055 4
a1058 3
  if (false == xcoff_link_create_extra_sections(abfd, info)) {
    goto error_return;
  }
d1076 1
a1076 1
  symcount = obj_raw_syment_count (abfd); 
d1080 2
a1081 4
  sym_hash = ((struct xcoff_link_hash_entry **)
	      bfd_alloc (abfd,
			 (symcount
			  * sizeof (struct xcoff_link_hash_entry *))));
d1085 1
a1085 2
  memset (sym_hash, 0,
	  (size_t) symcount * sizeof (struct xcoff_link_hash_entry *));
d1090 2
a1091 2
  csect_cache = ((asection **)
		 bfd_alloc (abfd, symcount * sizeof (asection *)));
d1095 1
a1095 1
  memset (csect_cache, 0, (size_t) symcount * sizeof (asection *));
d1102 3
a1104 3
  reloc_info = ((struct reloc_info_struct *)
		bfd_malloc ((abfd->section_count + 1)
			    * sizeof (struct reloc_info_struct)));
d1107 1
a1107 2
  memset ((PTR) reloc_info, 0,
	  (abfd->section_count + 1) * sizeof (struct reloc_info_struct));
d1112 16
a1127 1
  for (o = abfd->sections; o != NULL; o = o->next) {
d1129 1
a1129 2
    last_real = o;
    if ((o->flags & SEC_RELOC) != 0) {
d1131 3
a1133 11
      reloc_info[o->target_index].relocs =
	xcoff_read_internal_relocs (abfd, o, true, (bfd_byte *) NULL,
				    false, (struct internal_reloc *) NULL);
      reloc_info[o->target_index].csects =
	(asection **) bfd_malloc (o->reloc_count * sizeof (asection *));
      if (reloc_info[o->target_index].csects == NULL)
	goto error_return;
      memset (reloc_info[o->target_index].csects, 0,
	      o->reloc_count * sizeof (asection *));
      
    }
d1135 1
a1135 2
    if ((info->strip == strip_none || info->strip == strip_some)
	&& o->lineno_count > 0)	{
d1137 8
a1144 1
      bfd_byte *linenos;
d1146 1
a1146 9
      linenos = (bfd_byte *) bfd_malloc (o->lineno_count * linesz);
      if (linenos == NULL)
	goto error_return;
      reloc_info[o->target_index].linenos = linenos;
      if (bfd_seek (abfd, o->line_filepos, SEEK_SET) != 0
	  || (bfd_read (linenos, linesz, o->lineno_count, abfd)
	      != linesz * o->lineno_count))
	goto error_return;
      
a1147 1
  }
d1162 43
a1204 32
  while (esym < esym_end) {
    struct internal_syment sym;
    union internal_auxent aux;
    const char *name;
    char buf[SYMNMLEN + 1];
    int smtyp;
    flagword flags;
    asection *section;
    bfd_vma value;
    struct xcoff_link_hash_entry *set_toc;

    bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &sym);
    
    /* In this pass we are only interested in symbols with csect
       information.  */
    if (sym.n_sclass != C_EXT && sym.n_sclass != C_HIDEXT) {

      /*
       * Set csect_cache, 
       *   Normally csect is a .pr, .rw  etc. created in the loop
       *   If C_FILE or first time, handle special
       * 
       * Advance esym, sym_hash, csect_hash ptr's
       * Keep track of the last_symndx for the current file
       */
      if (sym.n_sclass == C_FILE && csect != NULL) {
	xcoff_section_data (abfd, csect)->last_symndx =
	  ((esym
	    - (bfd_byte *) obj_coff_external_syms (abfd))
	   / symesz);
	csect = NULL;
      }
d1206 2
a1207 12
      if (csect != NULL)
	*csect_cache = csect;
      else if (first_csect == NULL || sym.n_sclass == C_FILE)
	*csect_cache = coff_section_from_bfd_index (abfd, sym.n_scnum);
      else
	*csect_cache = NULL;
      esym += (sym.n_numaux + 1) * symesz;
      sym_hash += sym.n_numaux + 1;
      csect_cache += sym.n_numaux + 1;
      
      continue;
    }
d1209 1
a1209 1
    name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
d1211 2
a1212 2
    if (name == NULL)
      goto error_return;
d1220 44
a1263 4
    if ((info->strip == strip_none || info->strip == strip_some) && 
	(sym.n_numaux > 1) && 
	(csect != NULL) && 
	(ISFCN (sym.n_type))) {
d1265 23
a1287 1
      union internal_auxent auxlin;
d1289 1
a1289 3
      bfd_coff_swap_aux_in (abfd, (PTR) (esym + symesz),
			    sym.n_type, sym.n_sclass,
			    0, sym.n_numaux, (PTR) &auxlin);
d1291 2
a1292 6
      if (auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr != 0) {
	asection *enclosing;
	bfd_signed_vma linoff;
	  
	enclosing = xcoff_section_data (abfd, csect)->enclosing;
	if (enclosing == NULL) {
d1294 2
a1295 2
	    (_("%s: `%s' has line numbers but no enclosing section"),
	     bfd_get_filename (abfd), name);
a1298 37
	linoff = (auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr
		  - enclosing->line_filepos);
	/* explict cast to bfd_signed_vma for compiler */
	if (linoff < (bfd_signed_vma)(enclosing->lineno_count * linesz)) {
	  struct internal_lineno lin;
	  bfd_byte *linpstart;

	  linpstart = (reloc_info[enclosing->target_index].linenos
		       + linoff);
	  bfd_coff_swap_lineno_in (abfd, (PTR) linpstart, (PTR) &lin);
	  if (lin.l_lnno == 0
	      && ((bfd_size_type) lin.l_addr.l_symndx
		  == ((esym
		       - (bfd_byte *) obj_coff_external_syms (abfd))
		      / symesz))) {
	    bfd_byte *linpend, *linp;

	    linpend = (reloc_info[enclosing->target_index].linenos
		       + enclosing->lineno_count * linesz);
	    for (linp = linpstart + linesz; linp < linpend; linp += linesz) {
	      bfd_coff_swap_lineno_in (abfd, (PTR) linp,
				       (PTR) &lin);
	      if (lin.l_lnno == 0)
		break;
	    }
	    csect->lineno_count += (linp - linpstart) / linesz;
	    /* The setting of line_filepos will only be
	       useful if all the line number entries for a
	       csect are contiguous; this only matters for
	       error reporting.  */
	    if (csect->line_filepos == 0)
	      csect->line_filepos =
		auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr;
	  }
	}
      }
    }
d1300 3
a1302 13
    /* Pick up the csect auxiliary information.  */

    if (sym.n_numaux == 0) {
      (*_bfd_error_handler)
	(_("%s: class %d symbol `%s' has no aux entries"),
	 bfd_get_filename (abfd), sym.n_sclass, name);
      bfd_set_error (bfd_error_bad_value);
      goto error_return;
    }

    bfd_coff_swap_aux_in (abfd,
			  (PTR) (esym + symesz * sym.n_numaux),
			  sym.n_type, sym.n_sclass,
d1352 1
a1352 3
		((esym
		  - (bfd_byte *) obj_coff_external_syms (abfd))
		 / symesz);
d1356 1
a1356 1
	  csect_index = -1;
d1374 49
a1422 23
	  /* 
	   * We must merge TOC entries for the same symbol.  We can
	   * merge two TOC entries if they are both C_HIDEXT, they
	   * both have the same name, they are both 4 or 8 bytes long, and
	   * they both have a relocation table entry for an external
	   * symbol with the same name.  Unfortunately, this means
	   * that we must look through the relocations.  Ick.  
	   * 
	   * Logic for 32 bit vs 64 bit.
	   * 32 bit has a csect length of 4 for TOC 
	   * 64 bit has a csect length of 8 for TOC
	   * 
	   * The conditions to get past the if-check are not that bad. 
	   * They are what is used to create the TOC csects in the first 
	   * place
	   */
	  if ((aux.x_csect.x_smclas == XMC_TC) && 
	      (sym.n_sclass == C_HIDEXT) &&
 	      (info->hash->creator == abfd->xvec) && 
	      (((bfd_xcoff_is_xcoff32(abfd)) && 
		(aux.x_csect.x_scnlen.l == 4)) || 
	       ((bfd_xcoff_is_xcoff64(abfd)) && 
		(aux.x_csect.x_scnlen.l == 8)))) {
d1424 49
a1472 4
	    asection *enclosing;
	    struct internal_reloc *relocs;
	    bfd_size_type relindx;
	    struct internal_reloc *rel;
d1474 8
a1481 3
	    enclosing = coff_section_from_bfd_index (abfd, sym.n_scnum);
	    if (enclosing == NULL)
	      goto error_return;
d1483 7
a1489 84
	    relocs = reloc_info[enclosing->target_index].relocs;
	    relindx = xcoff_find_reloc (relocs, enclosing->reloc_count,
					sym.n_value);
	    rel = relocs + relindx;

	      /*
	       * 32 bit R_POS r_size is 31
	       * 64 bit R_POS r_size is 63
	       */
	    if ((relindx < enclosing->reloc_count) &&
		(rel->r_vaddr == (bfd_vma) sym.n_value) &&
		(rel->r_type == R_POS) &&
		(((bfd_xcoff_is_xcoff32(abfd)) && 
		  (rel->r_size == 31)) ||
		 ((bfd_xcoff_is_xcoff64(abfd)) && 
		  (rel->r_size == 63)))) {

	      bfd_byte *erelsym;

	      struct internal_syment relsym;

	      erelsym = ((bfd_byte *) obj_coff_external_syms (abfd)
			 + rel->r_symndx * symesz);
	      bfd_coff_swap_sym_in (abfd, (PTR) erelsym, (PTR) &relsym);
	      if (relsym.n_sclass == C_EXT) {
		const char *relname;
		char relbuf[SYMNMLEN + 1];
		boolean copy;
		struct xcoff_link_hash_entry *h;
		    
		/* At this point we know that the TOC entry is
		   for an externally visible symbol.  */

		relname = _bfd_coff_internal_syment_name (abfd, &relsym,
							  relbuf);
		if (relname == NULL)
		  goto error_return;
		    
		/* We only merge TOC entries if the TC name is
		   the same as the symbol name.  This handles
		   the normal case, but not common cases like
		   SYM.P4 which gcc generates to store SYM + 4
		   in the TOC.  FIXME.  */

		if (strcmp (name, relname) == 0) {
		  copy = (! info->keep_memory
			  || relsym._n._n_n._n_zeroes != 0
			  || relsym._n._n_n._n_offset == 0);
		  h = xcoff_link_hash_lookup (xcoff_hash_table (info),
					      relname, true, copy,
					      false);
		  if (h == NULL)
		    goto error_return;
		      
		  /* At this point h->root.type could be
		     bfd_link_hash_new.  That should be OK,
		     since we know for sure that we will come
		     across this symbol as we step through the
		     file.  */
		      
		  /* We store h in *sym_hash for the
		     convenience of the relocate_section
		     function.  */
		  *sym_hash = h;
		      
		  if (h->toc_section != NULL) {
		    asection **rel_csects;
			
		    /* We already have a TOC entry for this
		       symbol, so we can just ignore this
		       one.  */
		    rel_csects =
		      reloc_info[enclosing->target_index].csects;
		    rel_csects[relindx] = bfd_und_section_ptr;
		    break;
		  }
		      
		  /* We are about to create a TOC entry for
		     this symbol.  */
		  set_toc = h;
		} /* merge toc reloc */
	      } /* c_ext */
	    } /* reloc */
	  } /* merge toc */
d1500 4
a1503 3
	    if (NULL == csect) {
	      goto error_return;
	    }
d1505 2
a1506 4
	    /*
	     * The enclosing section is the main section : .data, .text
	     * or .bss that the csect is coming from
	     */
d1511 11
a1521 10
	    if (! bfd_is_abs_section (enclosing) && 
		((bfd_vma) sym.n_value < enclosing->vma || 
		 ((bfd_vma) sym.n_value + aux.x_csect.x_scnlen.l
		  > enclosing->vma + enclosing->_raw_size))) {
	      (*_bfd_error_handler)
		(_("%s: csect `%s' not in enclosing section"),
		 bfd_get_filename (abfd), name);
	      bfd_set_error (bfd_error_bad_value);
	      goto error_return;
	    }
d1532 2
a1533 2
	    csect->used_by_bfd =
	      (PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
d1536 2
a1537 2
	    coff_section_data (abfd, csect)->tdata =
	      bfd_zalloc (abfd, sizeof (struct xcoff_section_tdata));
d1544 21
a1564 5
	    if (enclosing->owner == abfd) {
	      struct internal_reloc *relocs;
	      bfd_size_type relindx;
	      struct internal_reloc *rel;
	      asection **rel_csect;
d1566 7
a1572 20
	      relocs = reloc_info[enclosing->target_index].relocs;
	      relindx = xcoff_find_reloc (relocs, enclosing->reloc_count,
					  csect->vma);

	      rel = relocs + relindx;
	      rel_csect = (reloc_info[enclosing->target_index].csects
			   + relindx);

	      csect->rel_filepos = (enclosing->rel_filepos
				    + relindx * bfd_coff_relsz (abfd));
	      while (relindx < enclosing->reloc_count && 
		     *rel_csect == NULL && 
		     rel->r_vaddr < csect->vma + csect->_raw_size) {

		*rel_csect = csect;
		csect->flags |= SEC_RELOC;
		++csect->reloc_count;
		++relindx;
		++rel;
		++rel_csect;
a1573 1
	    }
d1603 1
a1603 1
	     symbol index of the csect.  Usually the XTY_LD symbol will 
d1650 5
a1654 6
	  if (aux.x_csect.x_smclas == XMC_TD) {
	    /*
	     * The linker script puts the .td section in the data 
	     * section after the .tc section 
	     */
	    csect = bfd_make_section_anyway (abfd, ".td");
d1656 5
a1660 3
	  } else {
	    csect = bfd_make_section_anyway (abfd, ".bss");
	  }
d1674 2
a1675 2
	  csect->used_by_bfd =
	    (PTR) bfd_zalloc (abfd, sizeof (struct coff_section_tdata));
d1678 2
a1679 2
	  coff_section_data (abfd, csect)->tdata =
	    bfd_zalloc (abfd, sizeof (struct xcoff_section_tdata));
d1699 30
a1728 25
      if ((smtyp == XTY_SD || smtyp == XTY_CM) && 
	  (aux.x_csect.x_smclas != XMC_TC) && 
	  (aux.x_csect.x_smclas != XMC_TD)) {

	int i = -1;

	if (name[0] == '_') {
	  if (strcmp (name, "_text") == 0)
	    i = XCOFF_SPECIAL_SECTION_TEXT;
	  else if (strcmp (name, "_etext") == 0)
	    i = XCOFF_SPECIAL_SECTION_ETEXT;
	  else if (strcmp (name, "_data") == 0)
	    i = XCOFF_SPECIAL_SECTION_DATA;
	  else if (strcmp (name, "_edata") == 0)
	    i = XCOFF_SPECIAL_SECTION_EDATA;
	  else if (strcmp (name, "_end") == 0)
	    i = XCOFF_SPECIAL_SECTION_END;
	} else if (name[0] == 'e' && strcmp (name, "end") == 0) {
	  i = XCOFF_SPECIAL_SECTION_END2;
	} 
	
	if (i != -1) {
	  xcoff_hash_table (info)->special_sections[i] = csect;
	} 
      }
d1771 1
a1771 1
 	  if (info->hash->creator == abfd->xvec) 
d1853 1
a1853 1
			  (bfd *) NULL, (asection *) NULL, 0,
d1893 1
a1893 1
		     = csect->alignment_power;
d1897 1
a1897 1
 	  if (info->hash->creator == abfd->xvec) 
d1957 1
a1957 1
 	      if (info->hash->creator == abfd->xvec 
d2049 1
a2049 1
    free (reloc_info);
d2080 1
a2080 1
   if (info->hash->creator != abfd->xvec) 
d2085 1
a2085 1
      bfd_set_error (bfd_error_invalid_operation); 
d2088 1
a2088 1
  
d2211 1
a2211 1
	      dsnm = bfd_malloc (strlen (name) + 2);
d2262 1
a2262 1
       bfd_alloc (abfd, sizeof (struct xcoff_import_file)));
d2523 1
d2532 2
a2533 2
  n = ((struct xcoff_link_size_list *)
       bfd_alloc (output_bfd, sizeof (struct xcoff_link_size_list)));
d2647 1
d2649 1
a2649 2
	  n = ((struct xcoff_import_file *)
	       bfd_alloc (output_bfd, sizeof (struct xcoff_import_file)));
d2690 1
d2692 1
a2692 1
      fnname = (char *) bfd_malloc (strlen (h->root.root.string) + 2);
d2836 1
d2838 2
a2839 1
  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour) {
d2841 4
a2844 4
    for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++)
      special_sections[i] = NULL;
    return true;
  }
d2862 11
a2872 8
  if (entry == NULL) {
    hentry = NULL;
  } else {
    hentry = xcoff_link_hash_lookup (xcoff_hash_table (info), entry,
				     false, false, true);
    if (hentry != NULL)
      hentry->flags |= XCOFF_ENTRY;
  }
d2879 1
a2879 1
    hrtinit = xcoff_link_hash_lookup (xcoff_hash_table (info), 
d2882 20
a2901 9
    if (hrtinit != NULL) {
      xcoff_mark_symbol (info, hrtinit);
      hrtinit->flags |= (XCOFF_DEF_REGULAR | XCOFF_RTINIT);
    } else {
      (*_bfd_error_handler)
	(_("error: undefined symbol __rtinit"));
      
      return false;
    }
a2902 11
    /*
     * 
     * __rtinit initalized here 
     * Some information, like the location of the .initfini seciton will
     * be filled in later
     *
     * name or offset taken case of below with bfd_xcoff_put_ldsymbol_name 
     */
    ldsym = (struct internal_ldsym *) 
      bfd_malloc(sizeof (struct internal_ldsym));
    
d2909 6
a2914 8
    
    /* 
     * Force __rtinit to be the first symbol in the loader symbol table
     * See xcoff_build_ldsyms 
     *
     * The first 3 symbol table indices are reserved to indicate the data, 
     * text and bss sections.  
     */
d2916 1
a2916 1
    
d2920 1
a2920 1
    
d2922 5
a2926 4
					      hrtinit->ldsym, 
					      hrtinit->root.root.string)) {
      return false;
    }
d2928 2
a2929 4
    /* 
     * This symbol is written out by xcoff_write_global_symbol 
     * Set stuff up so xcoff_write_global_symbol logic works.
     */
d2932 1
a2932 1
    hrtinit->root.u.def.value = 0; 
d2970 11
a2980 8
  for (i = 0; i < XCOFF_NUMBER_OF_SPECIAL_SECTIONS; i++) {
    asection *sec;
    
    sec = xcoff_hash_table (info)->special_sections[i];

    if ((sec != NULL) && 
	(gc && (sec->flags & SEC_MARK) == 0)) {
      sec = NULL;
a2981 2
    special_sections[i] = sec;
  }
d2983 5
a2987 4
  if (info->input_bfds == NULL) {
    /* I'm not sure what to do in this bizarre case.  */
    return true;
  }
d3028 7
a3034 8
  /* 
   * 64 bit elements to ldhdr
   * The swap out routine for 32 bit will ignore them.
   * Nothing fancy, symbols come after the header and relocs come after symbols
   */
  ldhdr->l_symoff = bfd_xcoff_ldhdrsz(output_bfd);
  ldhdr->l_rldoff = bfd_xcoff_ldhdrsz(output_bfd) + 
    (ldhdr->l_nsyms * bfd_xcoff_ldsymsz(output_bfd));
d3084 1
a3084 1
     xcoff_link_input_bfd.  
d3230 10
a3239 9
  
  /*
   * __rtinit 
   * Special handling of this symbol to make is the first symbol in the
   * loader symbol table.  Make sure this pass through does not undo it
   */
  if (h->flags & XCOFF_RTINIT) {
    return true;
  }
d3346 3
a3348 2
      if (hds->toc_section == NULL) {
	int byte_size;
d3350 27
a3376 11
	/*
	 * 32 vs 64
	 * xcoff32 uses 4 bytes in the toc
	 * xcoff64 uses 8 bytes in the toc
	 */
	if (bfd_xcoff_is_xcoff64(ldinfo->output_bfd)) {
	  byte_size = 8;
	} else if (bfd_xcoff_is_xcoff32(ldinfo->output_bfd)) {
	  byte_size = 4;
	} else {
	  return false;
a3377 15

	hds->toc_section = xcoff_hash_table (ldinfo->info)->toc_section;
	hds->u.toc_offset = hds->toc_section->_raw_size;
	hds->toc_section->_raw_size += byte_size;
	++xcoff_hash_table (ldinfo->info)->ldrel_count;
	++hds->toc_section->reloc_count;
	hds->indx = -2;
	hds->flags |= XCOFF_SET_TOC | XCOFF_LDREL;

	/* 
	 * We need to call xcoff_build_ldsyms recursively here,
	 * because we may already have passed hds on the traversal.  
	 */
	xcoff_build_ldsyms (hds, p);
      }
d3407 3
a3409 5
	  /*
	   * The size of the function descriptor depends if this is an
	   * xcoff32 (12) or xcoff64 (24)
	   */
	  sec->_raw_size += 
d3412 2
a3413 4
	  /* 
	   * A function descriptor uses two relocs: one for the
           * associated code, and one for the TOC address.  
	   */
d3417 2
a3418 4
	  /* 
	   * We handle writing out the contents of the descriptor in
           * xcoff_write_global_symbol.  
	   */
d3475 2
a3476 3
  h->ldsym = ((struct internal_ldsym *)
	      bfd_zalloc (ldinfo->output_bfd,
			  sizeof (struct internal_ldsym)));
d3486 2
a3487 4
  /* 
   * The first 3 symbol table indices are reserved to indicate the data, 
   * text and bss sections.  
   */
d3493 5
a3497 4
					    h->ldsym, 
					    h->root.root.string)) {
    return false;
  }
d3515 5
a3519 5
  size_t max_contents_size;
  size_t max_sym_count;
  size_t max_lineno_count;
  size_t max_reloc_count;
  size_t max_output_reloc_count;
d3527 2
d3548 6
a3553 5
  finfo.ldsym = xcoff_hash_table (info)->loader_section->contents + 
    bfd_xcoff_ldhdrsz(abfd);
  finfo.ldrel = xcoff_hash_table (info)->loader_section->contents + 
    bfd_xcoff_ldhdrsz(abfd) + 
    xcoff_hash_table (info)->ldhdr.l_nsyms * bfd_xcoff_ldsymsz(abfd);
d3673 5
a3677 6
	  for (o = abfd->sections; o != NULL; o = o->next) {
	    if ((true == 
		 bfd_xcoff_is_reloc_count_overflow(abfd, o->reloc_count)) ||
		(true == 
		 bfd_xcoff_is_lineno_count_overflow(abfd, o->lineno_count))) {

d3680 1
a3680 2
	    }
	  }
d3715 3
a3717 4
    finfo.section_info =
      ((struct xcoff_link_section_info *)
       bfd_malloc ((abfd->section_count + 1)
		   * sizeof (struct xcoff_link_section_info)));
d3763 2
d3766 4
a3769 2
	    ((struct internal_reloc *)
	     bfd_malloc (o->reloc_count * sizeof (struct internal_reloc)));
d3771 2
a3772 3
	    ((struct xcoff_link_hash_entry **)
	     bfd_malloc (o->reloc_count
			 * sizeof (struct xcoff_link_hash_entry *)));
d3812 1
a3812 1
      size_t sz;
d3821 18
a3838 11
  finfo.internal_syms = ((struct internal_syment *)
			 bfd_malloc (max_sym_count
				     * sizeof (struct internal_syment)));

  finfo.sym_indices = (long *) bfd_malloc (max_sym_count * sizeof (long));
  finfo.outsyms = ((bfd_byte *)
		   bfd_malloc ((size_t) ((max_sym_count + 1) * symesz)));
  finfo.linenos = (bfd_byte *) bfd_malloc (max_lineno_count
					   * bfd_coff_linesz (abfd));
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  finfo.external_relocs = (bfd_byte *) bfd_malloc (max_reloc_count * relsz);
d3887 25
a3911 20
  if (finfo.internal_syms != NULL) {
    free (finfo.internal_syms);
    finfo.internal_syms = NULL;
  }
  if (finfo.sym_indices != NULL) {
    free (finfo.sym_indices);
    finfo.sym_indices = NULL;
  }
  if (finfo.linenos != NULL) {
    free (finfo.linenos);
    finfo.linenos = NULL;
  }
  if (finfo.contents != NULL) {
    free (finfo.contents);
    finfo.contents = NULL;
  }
  if (finfo.external_relocs != NULL) {
    free (finfo.external_relocs);
    finfo.external_relocs = NULL;
  }
d3915 10
a3924 11
  if (finfo.last_file_index != -1) {
    finfo.last_file.n_value = -1;
    bfd_coff_swap_sym_out (abfd, (PTR) &finfo.last_file,
			   (PTR) finfo.outsyms);
    if (bfd_seek (abfd,
		  (obj_sym_filepos (abfd)
		   + finfo.last_file_index * symesz),
		  SEEK_SET) != 0
	|| bfd_write (finfo.outsyms, symesz, 1, abfd) != symesz)
      goto error_return;
  }
d3927 3
a3929 2
  if (info->init_function || info->fini_function) {
    struct xcoff_link_hash_entry *hrtinit;
d3931 4
a3934 4
    hrtinit = xcoff_link_hash_lookup (xcoff_hash_table (info), 
				      "__rtinit",
				      false, false, true);
  }
d3952 2
a3953 1
  external_relocs = (bfd_byte *) bfd_malloc (max_output_reloc_count * relsz);
d3957 51
a4007 27
  for (o = abfd->sections; o != NULL; o = o->next) {
    struct internal_reloc *irel;
    struct internal_reloc *irelend;
    struct xcoff_link_hash_entry **rel_hash;
    struct xcoff_toc_rel_hash *toc_rel_hash;
    bfd_byte *erel;
    
    /* A stripped file has no relocs.  */
    if (info->strip == strip_all) {
      o->reloc_count = 0;
      continue;
    }
    
    if (o->reloc_count == 0)
      continue;

    irel = finfo.section_info[o->target_index].relocs;
    irelend = irel + o->reloc_count;
    rel_hash = finfo.section_info[o->target_index].rel_hashes;
    for (; irel < irelend; irel++, rel_hash++, erel += relsz) {
      if (*rel_hash != NULL) {
	if ((*rel_hash)->indx < 0) {
	  if (! ((*info->callbacks->unattached_reloc)
		 (info, (*rel_hash)->root.root.string,
		  (bfd *) NULL, o, irel->r_vaddr)))
	    goto error_return;
	  (*rel_hash)->indx = 0;
d4009 20
a4028 2
	irel->r_symndx = (*rel_hash)->indx;
      }
d4031 4
a4034 11
    for (toc_rel_hash = finfo.section_info[o->target_index].toc_rel_hashes;
	 toc_rel_hash != NULL;
	 toc_rel_hash = toc_rel_hash->next) {
      if (toc_rel_hash->h->u.toc_indx < 0) {
	if (! ((*info->callbacks->unattached_reloc)
	       (info, toc_rel_hash->h->root.root.string,
		(bfd *) NULL, o, toc_rel_hash->rel->r_vaddr)))
	  goto error_return;
	toc_rel_hash->h->u.toc_indx = 0;
      }
      toc_rel_hash->rel->r_symndx = toc_rel_hash->h->u.toc_indx;
a4036 26
    /* XCOFF requires that the relocs be sorted by address.  We tend
       to produce them in the order in which their containing csects
       appear in the symbol table, which is not necessarily by
       address.  So we sort them here.  There may be a better way to
       do this.  */
    qsort ((PTR) finfo.section_info[o->target_index].relocs,
	   o->reloc_count, sizeof (struct internal_reloc),
	   xcoff_sort_relocs);
    
    irel = finfo.section_info[o->target_index].relocs;
    irelend = irel + o->reloc_count;
    erel = external_relocs;
    for (; irel < irelend; irel++, rel_hash++, erel += relsz)
      bfd_coff_swap_reloc_out (abfd, (PTR) irel, (PTR) erel);

    if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0
	|| bfd_write ((PTR) external_relocs, relsz, o->reloc_count,
		      abfd) != relsz * o->reloc_count)
      goto error_return;
  }

  if (external_relocs != NULL) {
    free (external_relocs);
    external_relocs = NULL;
  }

d4038 3
a4040 2
  if (finfo.section_info != NULL) {
    unsigned int i;
d4042 9
a4050 5
    for (i = 0; i < abfd->section_count; i++) {
      if (finfo.section_info[i].relocs != NULL)
	free (finfo.section_info[i].relocs);
      if (finfo.section_info[i].rel_hashes != NULL)
	free (finfo.section_info[i].rel_hashes);
a4051 3
    free (finfo.section_info);
    finfo.section_info = NULL;
  }
d4058 2
a4059 3
  if (! bfd_set_section_contents (abfd, o->output_section,
				  o->contents, o->output_offset,
				  o->_raw_size))
d4066 2
a4067 1
				     o->output_offset, o->_raw_size))
d4072 2
a4073 1
				     o->output_offset, o->_raw_size))
d4078 2
a4079 1
				     o->output_offset, o->_raw_size))
d4083 2
a4084 4
  if (bfd_seek (abfd,
		(obj_sym_filepos (abfd)
		 + obj_raw_syment_count (abfd) * symesz),
		SEEK_SET) != 0)
d4086 5
a4090 4
  bfd_h_put_32 (abfd,
		_bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
		(bfd_byte *) strbuf);
  if (bfd_write (strbuf, 1, STRING_SIZE_SIZE, abfd) != STRING_SIZE_SIZE)
d4099 14
a4112 14
  if (o != NULL) {
    struct bfd_strtab_hash *debug_strtab;
    
    debug_strtab = xcoff_hash_table (info)->debug_strtab;
    BFD_ASSERT (o->output_section->_raw_size - o->output_offset
		>= _bfd_stringtab_size (debug_strtab));
    if (bfd_seek (abfd,
		  o->output_section->filepos + o->output_offset,
		  SEEK_SET) != 0)
      goto error_return;
    if (! _bfd_stringtab_emit (abfd, debug_strtab))
      goto error_return;
  }
  
d4116 1
a4116 1
  
d4122 13
a4134 9
  
  if (finfo.section_info != NULL) {
    unsigned int i;
    
    for (i = 0; i < abfd->section_count; i++) {
      if (finfo.section_info[i].relocs != NULL)
	free (finfo.section_info[i].relocs);
      if (finfo.section_info[i].rel_hashes != NULL)
	free (finfo.section_info[i].rel_hashes);
d4136 1
a4136 3
    free (finfo.section_info);
  }
  
d4337 3
a4339 2
				    finfo->ldsym + (h->ldindx - 3) * 
				    bfd_xcoff_ldsymsz(finfo->output_bfd));
d4343 7
a4349 6
	  if ((h->flags & XCOFF_ENTRY) != 0 && 
	      (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)) {
	    xcoff_data (output_bfd)->snentry =
	      h->root.u.def.section->output_section->target_index;
	  }
a4403 1
		  asection *o;
d4441 1
a4441 1
	      
d4586 2
d4591 5
a4595 5
		      if (bfd_seek (output_bfd,
				    (obj_sym_filepos (output_bfd)
				     + finfo->last_file_index * osymesz),
				    SEEK_SET) != 0
			  || (bfd_write (outsym, osymesz, 1, output_bfd)
d4760 1
a4760 1
		      bfd_signed_vma indx;
d4762 1
a4762 2

		      indx =  aux.x_csect.x_scnlen.l;
d4768 8
a4775 5
			  if (symindx < 0) {
			    aux.x_csect.x_scnlen.l = 0;
			  } else {
			    aux.x_csect.x_scnlen.l = symindx;
			  }
d4847 5
a4851 6
			  if (bfd_seek (input_bfd,
					enclosing->line_filepos,
					SEEK_SET) != 0
			      || (bfd_read (finfo->linenos, linesz,
					    enc_count, input_bfd)
				  != linesz * enc_count))
d4909 2
a4910 2
			      || (bfd_write (finfo->linenos + linoff,
					     linesz, count, output_bfd)
d4999 4
a5002 6
      if (bfd_seek (output_bfd,
		    obj_sym_filepos (output_bfd) + syment_base * osymesz,
		    SEEK_SET) != 0
	  || (bfd_write (finfo->outsyms, outsym - finfo->outsyms, 1,
			output_bfd)
	      != (bfd_size_type) (outsym - finfo->outsyms)))
d5017 57
a5073 25
  for (o = input_bfd->sections; o != NULL; o = o->next) {
    
    bfd_byte *contents;

    if (! o->linker_mark){
      /* This section was omitted from the link.  */
      continue;
    }

    if ((o->flags & SEC_HAS_CONTENTS) == 0
	|| o->_raw_size == 0
	|| (o->flags & SEC_IN_MEMORY) != 0)
      continue;
    
    /* We have set filepos correctly for the sections we created to
       represent csects, so bfd_get_section_contents should work.  */
    if (coff_section_data (input_bfd, o) != NULL
	&& coff_section_data (input_bfd, o)->contents != NULL)
      contents = coff_section_data (input_bfd, o)->contents;
    else {
      if (! bfd_get_section_contents (input_bfd, o, finfo->contents,
				      (file_ptr) 0, o->_raw_size))
	return false;
      contents = finfo->contents;
    }
d5075 10
a5084 18
    if ((o->flags & SEC_RELOC) != 0) {
      int target_index;
      struct internal_reloc *internal_relocs;
      struct internal_reloc *irel;
      bfd_vma offset;
      struct internal_reloc *irelend;
      struct xcoff_link_hash_entry **rel_hash;
      long r_symndx;
      
      /* Read in the relocs.  */
      target_index = o->output_section->target_index;
      internal_relocs = (xcoff_read_internal_relocs
			 (input_bfd, o, false, finfo->external_relocs,
			  true,
			  (finfo->section_info[target_index].relocs
			   + o->output_section->reloc_count)));
      if (internal_relocs == NULL)
	return false;
d5086 1
a5086 9
      /* Call processor specific code to relocate the section
	 contents.  */
      if (! bfd_coff_relocate_section (output_bfd, finfo->info,
				       input_bfd, o,
				       contents,
				       internal_relocs,
				       finfo->internal_syms,
				       xcoff_data (input_bfd)->csects))
	return false;
d5088 1
a5088 9
      offset = o->output_section->vma + o->output_offset - o->vma;
      irel = internal_relocs;
      irelend = irel + o->reloc_count;
      rel_hash = (finfo->section_info[target_index].rel_hashes
		  + o->output_section->reloc_count);
      for (; irel < irelend; irel++, rel_hash++) {
	struct xcoff_link_hash_entry *h = NULL;
	struct internal_ldrel ldrel;
	boolean quiet;
d5090 1
a5090 1
	*rel_hash = NULL;
d5092 1
a5092 1
	/* Adjust the reloc address and symbol index.  */
d5094 4
a5097 1
	irel->r_vaddr += offset;
d5099 57
a5155 1
	r_symndx = irel->r_symndx;
d5157 1
a5157 4
	if (r_symndx == -1)
	  h = NULL;
	else
	  h = obj_xcoff_sym_hashes (input_bfd)[r_symndx];
d5159 3
a5161 23
	if (r_symndx != -1 && finfo->info->strip != strip_all)
	  {
	    if (h != NULL
		&& h->smclas != XMC_TD
		&& (irel->r_type == R_TOC
		    || irel->r_type == R_GL
		    || irel->r_type == R_TCL
		    || irel->r_type == R_TRL
		    || irel->r_type == R_TRLA))
	      {
		/* This is a TOC relative reloc with a symbol
		   attached.  The symbol should be the one which
		   this reloc is for.  We want to make this
		   reloc against the TOC address of the symbol,
		   not the symbol itself.  */
		BFD_ASSERT (h->toc_section != NULL);
		BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
		if (h->u.toc_indx != -1)
		  irel->r_symndx = h->u.toc_indx;
		else
		  {
		    struct xcoff_toc_rel_hash *n;
		    struct xcoff_link_section_info *si;
d5163 9
a5171 32
		    n = ((struct xcoff_toc_rel_hash *)
			 bfd_alloc (finfo->output_bfd,
				    sizeof (struct xcoff_toc_rel_hash)));
		    if (n == NULL)
		      return false;
		    si = finfo->section_info + target_index;
		    n->next = si->toc_rel_hashes;
		    n->h = h;
		    n->rel = irel;
		    si->toc_rel_hashes = n;
		  }
	      }
	    else if (h != NULL)
	      {
		/* This is a global symbol.  */
		if (h->indx >= 0)
		  irel->r_symndx = h->indx;
		else
		  {
		    /* This symbol is being written at the end
		       of the file, and we do not yet know the
		       symbol index.  We save the pointer to the
		       hash table entry in the rel_hash list.
		       We set the indx field to -2 to indicate
		       that this symbol must not be stripped.  */
		    *rel_hash = h;
		    h->indx = -2;
		  }
	      }
	    else
	      {
		long indx;
d5173 15
a5187 1
		indx = finfo->sym_indices[r_symndx];
d5189 4
a5192 3
		if (indx == -1)
		  {
		    struct internal_syment *is;
d5194 1
a5194 9
		    /* Relocations against a TC0 TOC anchor are
		       automatically transformed to be against
		       the TOC anchor in the output file.  */
		    is = finfo->internal_syms + r_symndx;
		    if (is->n_sclass == C_HIDEXT
			&& is->n_numaux > 0)
		      {
			PTR auxptr;
			union internal_auxent aux;
d5196 2
a5197 15
			auxptr = ((PTR)
				  (((bfd_byte *)
				    obj_coff_external_syms (input_bfd))
				   + ((r_symndx + is->n_numaux)
				      * isymesz)));
			bfd_coff_swap_aux_in (input_bfd, auxptr,
					      is->n_type, is->n_sclass,
					      is->n_numaux - 1,
					      is->n_numaux,
					      (PTR) &aux);
			if (SMTYP_SMTYP (aux.x_csect.x_smtyp) == XTY_SD
			    && aux.x_csect.x_smclas == XMC_TC0)
			  indx = finfo->toc_symindx;
		      }
		  }
d5199 4
a5202 4
		if (indx != -1)
		  irel->r_symndx = indx;
		else
		  {
d5204 2
a5205 1
		    struct internal_syment *is;
d5207 2
a5208 2
		    const char *name;
		    char buf[SYMNMLEN + 1];
d5210 7
a5216 4
		    /* This reloc is against a symbol we are
		       stripping.  It would be possible to handle
		       this case, but I don't think it's worth it.  */
		    is = finfo->internal_syms + r_symndx;
d5218 25
a5242 2
		    name = (_bfd_coff_internal_syment_name
			    (input_bfd, is, buf));
d5244 7
a5250 2
		    if (name == NULL)
		      return false;
d5252 51
a5302 3
		    if (! ((*finfo->info->callbacks->unattached_reloc)
			   (finfo->info, name, input_bfd, o,
			    irel->r_vaddr)))
d5304 3
a5306 3
		  }
	      }
	  }
d5308 2
a5309 25
	quiet = false;
	switch (irel->r_type)
	  {
	  default:
	    if (h == NULL
		|| h->root.type == bfd_link_hash_defined
		|| h->root.type == bfd_link_hash_defweak
		|| h->root.type == bfd_link_hash_common)
	      break;
	    /* Fall through.  */
	  case R_POS:
	  case R_NEG:
	  case R_RL:
	  case R_RLA:
	    /* This reloc needs to be copied into the .loader
	       section.  */
	    ldrel.l_vaddr = irel->r_vaddr;
	    if (r_symndx == -1)
	      ldrel.l_symndx = -1;
	    else if (h == NULL
		     || (h->root.type == bfd_link_hash_defined
			 || h->root.type == bfd_link_hash_defweak
			 || h->root.type == bfd_link_hash_common))
	      {
		asection *sec;
d5311 10
a5320 63
		if (h == NULL)
		  sec = xcoff_data (input_bfd)->csects[r_symndx];
		else if (h->root.type == bfd_link_hash_common)
		  sec = h->root.u.c.p->section;
		else
		  sec = h->root.u.def.section;
		sec = sec->output_section;

		if (strcmp (sec->name, ".text") == 0)
		  ldrel.l_symndx = 0;
		else if (strcmp (sec->name, ".data") == 0)
		  ldrel.l_symndx = 1;
		else if (strcmp (sec->name, ".bss") == 0)
		  ldrel.l_symndx = 2;
		else
		  {
		    (*_bfd_error_handler)
		      (_("%s: loader reloc in unrecognized section `%s'"),
		       bfd_get_filename (input_bfd),
		       sec->name);
		    bfd_set_error (bfd_error_nonrepresentable_section);
		    return false;
		  }
	      }
	    else
	      {
		if (! finfo->info->relocateable
		    && (h->flags & XCOFF_DEF_DYNAMIC) == 0
		    && (h->flags & XCOFF_IMPORT) == 0)
		  {
		    /* We already called the undefined_symbol
		       callback for this relocation, in
		       _bfd_ppc_xcoff_relocate_section.  Don't
		       issue any more warnings.  */
		    quiet = true;
		  }
		if (h->ldindx < 0 && ! quiet)
		  {
		    (*_bfd_error_handler)
		      (_("%s: `%s' in loader reloc but not loader sym"),
		       bfd_get_filename (input_bfd),
		       h->root.root.string);
		    bfd_set_error (bfd_error_bad_value);
		    return false;
		  }
		ldrel.l_symndx = h->ldindx;
	      }
	    ldrel.l_rtype = (irel->r_size << 8) | irel->r_type;
	    ldrel.l_rsecnm = o->output_section->target_index;
	    if (xcoff_hash_table (finfo->info)->textro
		&& strcmp (o->output_section->name, ".text") == 0
		&& ! quiet)
	      {
		(*_bfd_error_handler)
		  (_("%s: loader reloc in read-only section %s"),
		   bfd_get_filename (input_bfd),
		   bfd_get_section_name (finfo->output_bfd,
					 o->output_section));
		bfd_set_error (bfd_error_invalid_operation);
		return false;
	      }
	    bfd_xcoff_swap_ldrel_out (output_bfd, &ldrel,
				      finfo->ldrel);
d5322 2
a5323 2
	    finfo->ldrel += bfd_xcoff_ldrelsz(output_bfd);
	    break;
d5325 7
a5331 12
	  case R_TOC:
	  case R_GL:
	  case R_TCL:
	  case R_TRL:
	  case R_TRLA:
	    /* We should never need a .loader reloc for a TOC
	       relative reloc.  */
	    break;
	  }
      }

      o->output_section->reloc_count += o->reloc_count;
a5333 9
    /* Write out the modified section contents.  */
    if (! bfd_set_section_contents (output_bfd, o->output_section,
				    contents, o->output_offset,
				    (o->_cooked_size != 0
				     ? o->_cooked_size
				     : o->_raw_size)))
      return false;
  }

d5352 1
a5352 1
xcoff_write_global_symbol (h, p)
d5354 1
a5354 1
     PTR p;
d5356 1
a5356 1
  struct xcoff_final_link_info *finfo = (struct xcoff_final_link_info *) p;
d5362 2
d5374 34
a5407 13
  if (h->ldsym != NULL) {
    struct internal_ldsym *ldsym;
    bfd *impbfd;
    
    ldsym = h->ldsym;

    if (h->root.type == bfd_link_hash_undefined || 
	h->root.type == bfd_link_hash_undefweak) {

      ldsym->l_value = 0;
      ldsym->l_scnum = N_UNDEF;
      ldsym->l_smtype = XTY_ER;
      impbfd = h->root.u.undef.abfd;
d5409 10
a5418 2
    } else if (h->root.type == bfd_link_hash_defined || 
	       h->root.type == bfd_link_hash_defweak) {
d5420 11
a5430 9
      asection *sec;
      
      sec = h->root.u.def.section;
      ldsym->l_value = (sec->output_section->vma
			+ sec->output_offset
			+ h->root.u.def.value);
      ldsym->l_scnum = sec->output_section->target_index;
      ldsym->l_smtype = XTY_SD;
      impbfd = sec->owner;
d5432 4
a5435 3
    } else {
      abort ();
    }
d5437 1
a5437 8
    if (((h->flags & XCOFF_DEF_REGULAR) == 0 && 
	 (h->flags & XCOFF_DEF_DYNAMIC) != 0) || 
	(h->flags & XCOFF_IMPORT) != 0) {
      /* Clear l_smtype 
	 Import symbols are defined so the check above will make the l_smtype
	 XTY_SD.  But this is not correct, it should be cleared. */
      ldsym->l_smtype = L_IMPORT;
    }
d5439 22
a5460 5
    if (((h->flags & XCOFF_DEF_REGULAR) != 0 && 
	 (h->flags & XCOFF_DEF_DYNAMIC) != 0) || 
	(h->flags & XCOFF_EXPORT) != 0) {
      ldsym->l_smtype |= L_EXPORT;
    }
d5462 20
a5481 3
    if ((h->flags & XCOFF_ENTRY) != 0) {
      ldsym->l_smtype |= L_ENTRY;
    }
d5483 1
a5483 3
    if ((h->flags & XCOFF_RTINIT) != 0) {
      ldsym->l_smtype = XTY_SD;
    }
d5485 1
a5485 1
    ldsym->l_smclas = h->smclas;
d5487 5
a5491 35
    if (ldsym->l_smtype & L_IMPORT)
      {
	if ((h->root.type == bfd_link_hash_defined ||
	     h->root.type == bfd_link_hash_defweak) &&
	    (h->root.u.def.value != 0))
	  {
	    ldsym->l_smclas = XMC_XO;
	  }
	else if ((h->flags & (XCOFF_SYSCALL32 | XCOFF_SYSCALL64)) ==
		 (XCOFF_SYSCALL32 | XCOFF_SYSCALL64))
	  {
	    ldsym->l_smclas = XMC_SV3264;
	  }
	else if (h->flags & XCOFF_SYSCALL32) 
	  {
	    ldsym->l_smclas = XMC_SV;
	  }
	else if (h->flags & XCOFF_SYSCALL64) 
	  {
	    ldsym->l_smclas = XMC_SV64;
	  }
      }
       
    if (ldsym->l_ifile == (bfd_size_type) -1) {
      ldsym->l_ifile = 0;

    } else if (ldsym->l_ifile == 0) {
      if ((ldsym->l_smtype & L_IMPORT) == 0) {
	ldsym->l_ifile = 0;
      } else if (impbfd == NULL) {
	ldsym->l_ifile = 0;
      } else {
	BFD_ASSERT (impbfd->xvec == output_bfd->xvec);
	ldsym->l_ifile = xcoff_data (impbfd)->import_file_id;
      }
d5493 1
a5493 11
    
    ldsym->l_parm = 0;
    
    BFD_ASSERT (h->ldindx >= 0);
    
    bfd_xcoff_swap_ldsym_out (output_bfd, ldsym, finfo->ldsym + 
			      (h->ldindx - 3) * 
			      bfd_xcoff_ldsymsz(finfo->output_bfd));
    h->ldsym = NULL;
  }
  
d5495 9
a5503 3
  if (h->root.type == bfd_link_hash_defined && 
      (h->root.u.def.section == 
       xcoff_hash_table (finfo->info)->linkage_section)) {
d5505 17
a5521 5
    bfd_byte *p;
    bfd_vma tocoff;
    unsigned int i;
    
    p = h->root.u.def.section->contents + h->root.u.def.value;
d5523 9
a5531 27
    /* The first instruction in the global linkage code loads a
       specific TOC element.  */
    tocoff = (h->descriptor->toc_section->output_section->vma
	      + h->descriptor->toc_section->output_offset
	      - xcoff_data (output_bfd)->toc);

    if ((h->descriptor->flags & XCOFF_SET_TOC) != 0) {
      tocoff += h->descriptor->u.toc_offset;
    }
    

    /*
     * The first instruction in the glink code needs to be cooked to 
     * to hold the correct offset in the toc.  The rest are just outputted
     * raw.
     */
    bfd_put_32 (output_bfd, 
		bfd_xcoff_glink_code(output_bfd, 0) | (tocoff & 0xffff), p);

    /* 
     * Start with i == 1 to get past the first instruction done above 
     * The /4 is because the glink code is in bytes and we are going 4
     * at a pop
     */
    for (i = 1; i < bfd_xcoff_glink_code_size(output_bfd) / 4; i++) {
      bfd_put_32 (output_bfd, bfd_xcoff_glink_code(output_bfd, i), 
		  &p[4 * i]);
a5532 1
  }
d5555 10
a5564 7
      if (h->indx >= 0) {
	irel->r_symndx = h->indx;
      } else {
	h->indx = -2;
	irel->r_symndx = obj_raw_syment_count (output_bfd);
      }
      
d5567 3
a5569 5
      /*
       * Initialize the aux union here instead of closer to when it is
       * written out below because the length of the csect depends on 
       * whether the output is 32 or 64 bit
       */
d5575 2
d5578 17
a5594 17
      /* 
       * 32 bit uses a 32 bit R_POS to do the relocations
       * 64 bit uses a 64 bit R_POS to do the relocations
       * 
       * Also needs to change the csect size : 4 for 32 bit, 8 for 64 bit
       * 
       * Which one is determined by the backend
       */
      if (bfd_xcoff_is_xcoff64(output_bfd)) {
	irel->r_size = 63;
	iraux.x_csect.x_scnlen.l = 8;
      } else if (bfd_xcoff_is_xcoff32(output_bfd)) {
	irel->r_size = 31;
	iraux.x_csect.x_scnlen.l = 4;
      } else {
	return false;
      }
d5606 17
a5622 2
      /* We need to emit a symbol to define a csect which holds the reloc.  */
      if (finfo->info->strip != strip_all) {
d5624 2
a5625 5
	result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab, &irsym, 
					    h->root.root.string);
	if (false == result) {
	  return false;
	}
d5627 4
a5630 13
	irsym.n_value = irel->r_vaddr;
	irsym.n_scnum = osec->target_index;
	irsym.n_sclass = C_HIDEXT;
	irsym.n_type = T_NULL;
	irsym.n_numaux = 1;

	bfd_coff_swap_sym_out (output_bfd, (PTR) &irsym, (PTR) outsym);
	outsym += bfd_coff_symesz (output_bfd);

	/* note : iraux is initialized above */
	bfd_coff_swap_aux_out (output_bfd, (PTR) &iraux, T_NULL, C_HIDEXT,
			       0, 1, (PTR) outsym);
	outsym += bfd_coff_auxesz (output_bfd);
d5632 3
a5634 3
	if (h->indx >= 0)
	  {
	    /* We aren't going to write out the symbols below, so we
d5636 6
a5641 8
	      if (bfd_seek (output_bfd,
			    (obj_sym_filepos (output_bfd)
			     + (obj_raw_syment_count (output_bfd)
				* bfd_coff_symesz (output_bfd))),
			    SEEK_SET) != 0
		  || (bfd_write (finfo->outsyms, outsym - finfo->outsyms, 1,
				 output_bfd)
		      != (bfd_size_type) (outsym - finfo->outsyms)))
d5651 10
a5660 12
  /* 
   * If this symbol is a specially defined function descriptor, write
   * it out.  The first word is the address of the function code
   * itself, the second word is the address of the TOC, and the third
   * word is zero.  
   *
   * 32 bit vs 64 bit
   * The addresses for the 32 bit will take 4 bytes and the addresses 
   * for 64 bit will take 8 bytes.  Similar for the relocs.  This type 
   * of logic was also done above to create a TOC entry in 
   * xcoff_write_global_symbol
   */
d5677 14
a5690 9
      if (bfd_xcoff_is_xcoff64(output_bfd)) {
	reloc_size = 63;
	byte_size = 8;
      } else if (bfd_xcoff_is_xcoff32(output_bfd)) {
	reloc_size = 31;
	byte_size = 4;
      } else {
	return false;
      }
d5734 27
a5760 27
      /*
       * There are three items to write out, 
       * the address of the code
       * the address of the toc anchor
       * the environment pointer.  
       * We are ignoring the environment pointer.  So set it to zero
       */
      if (bfd_xcoff_is_xcoff64(output_bfd)) {
	bfd_put_64 (output_bfd, (esec->output_section->vma + 
				 esec->output_offset + 
				 hentry->root.u.def.value), p);
	bfd_put_64 (output_bfd, xcoff_data (output_bfd)->toc, p + 8);
	bfd_put_64 (output_bfd, 0, p + 16);
      } else {
	/* 
	 * 32 bit backend 
	 *
	 * This logic was already called above so the error case where 
	 * the backend is neither has already been checked 
	 */
	bfd_put_32 (output_bfd, (esec->output_section->vma + 
				 esec->output_offset + 
				 hentry->root.u.def.value), p);
	bfd_put_32 (output_bfd, xcoff_data (output_bfd)->toc, p + 4);
	bfd_put_32 (output_bfd, 0, p + 8);
      } 
      
d5806 2
a5807 3
	      && (bfd_hash_lookup (finfo->info->keep_hash,
				   h->root.root.string, false, false)
		  == NULL))))
d5824 1
a5824 1
  result = bfd_xcoff_put_symbol_name (output_bfd, finfo->strtab, &isym, 
d5826 4
a5829 3
  if (false == result) {
    return false;
  }
d5917 5
a5921 7
  if (bfd_seek (output_bfd,
		(obj_sym_filepos (output_bfd)
		 + (obj_raw_syment_count (output_bfd)
		    * bfd_coff_symesz (output_bfd))),
		SEEK_SET) != 0
      || (bfd_write (finfo->outsyms, outsym - finfo->outsyms, 1, output_bfd)
	  != (bfd_size_type) (outsym - finfo->outsyms)))
@


1.12
log
@Fix for xty_ld symbols
@
text
@d2517 1
a2517 1
			 impmember)
d2525 1
d2568 1
a2568 1
  h->flags |= XCOFF_IMPORT;
d2635 1
a2635 1
bfd_xcoff_export_symbol (output_bfd, info, harg, syscall)
a2638 1
     boolean syscall ATTRIBUTE_UNUSED;
d5337 4
a5340 1
      ldsym->l_smtype |= L_IMPORT;
d5359 23
@


1.11
log
@Support for xcoff64
@
text
@d1577 3
a1579 3
             symbol index of the csect.  I believe that this must
             always follow the appropriate XTY_SD symbol, so I will
             insist on it.  */
d1603 1
a1603 1

@


1.10
log
@Update copyright notices
@
text
@d27 1
d29 1
a34 52
/* Get the XCOFF hash table entries for a BFD.  */
#define obj_xcoff_sym_hashes(bfd) \
  ((struct xcoff_link_hash_entry **) obj_coff_sym_hashes (bfd))

/* XCOFF relocation types.  These probably belong in a header file
   somewhere.  The relocations are described in the function
   _bfd_ppc_xcoff_relocate_section in this file.  */

#define R_POS   (0x00)
#define R_NEG   (0x01)
#define R_REL   (0x02)
#define R_TOC   (0x03)
#define R_RTB   (0x04)
#define R_GL    (0x05)
#define R_TCL   (0x06)
#define R_BA    (0x08)
#define R_BR    (0x0a)
#define R_RL    (0x0c)
#define R_RLA   (0x0d)
#define R_REF   (0x0f)
#define R_TRL   (0x12)
#define R_TRLA  (0x13)
#define R_RRTBI (0x14)
#define R_RRTBA (0x15)
#define R_CAI   (0x16)
#define R_CREL  (0x17)
#define R_RBA   (0x18)
#define R_RBAC  (0x19)
#define R_RBR   (0x1a)
#define R_RBRC  (0x1b)

/* The first word of global linkage code.  This must be modified by
   filling in the correct TOC offset.  */

#define XCOFF_GLINK_FIRST (0x81820000)	/* lwz r12,0(r2) */

/* The remaining words of global linkage code.  */

static unsigned long xcoff_glink_code[] = {
  0x90410014,	/* stw r2,20(r1) */
  0x800c0000,	/* lwz r0,0(r12) */
  0x804c0004,	/* lwz r2,4(r12) */
  0x7c0903a6,	/* mtctr r0 */
  0x4e800420,	/* bctr */
  0x0,		/* start of traceback table */
  0x000c8000,	/* traceback table */
  0x0		/* traceback table */
};

#define XCOFF_GLINK_SIZE \
  (((sizeof xcoff_glink_code / sizeof xcoff_glink_code[0]) * 4) + 4)

a39 117
/* The ldhdr structure.  This appears at the start of the .loader
   section.  */

struct internal_ldhdr {
  /* The version number: currently always 1.  */
  unsigned long l_version;
  /* The number of symbol table entries.  */
  bfd_size_type l_nsyms;
  /* The number of relocation table entries.  */
  bfd_size_type l_nreloc;
  /* The length of the import file string table.  */
  bfd_size_type l_istlen;
  /* The number of import files.  */
  bfd_size_type l_nimpid;
  /* The offset from the start of the .loader section to the first
     entry in the import file table.  */
  bfd_size_type l_impoff;
  /* The length of the string table.  */
  bfd_size_type l_stlen;
  /* The offset from the start of the .loader section to the first
     entry in the string table.  */
  bfd_size_type l_stoff;
};

struct external_ldhdr {
  bfd_byte l_version[4];
  bfd_byte l_nsyms[4];
  bfd_byte l_nreloc[4];
  bfd_byte l_istlen[4];
  bfd_byte l_nimpid[4];
  bfd_byte l_impoff[4];
  bfd_byte l_stlen[4];
  bfd_byte l_stoff[4];
};

#define LDHDRSZ (8 * 4)

/* The ldsym structure.  This is used to represent a symbol in the
   .loader section.  */

struct internal_ldsym {
  union {
    /* The symbol name if <= SYMNMLEN characters.  */
    char _l_name[SYMNMLEN];
    struct {
      /* Zero if the symbol name is more than SYMNMLEN characters.  */
      long _l_zeroes;
      /* The offset in the string table if the symbol name is more
	 than SYMNMLEN characters.  */
      long _l_offset;
    } _l_l;
  } _l;
  /* The symbol value.  */
  bfd_vma l_value;
  /* The symbol section number.  */
  short l_scnum;
  /* The symbol type and flags.  */
  char l_smtype;
  /* The symbol storage class.  */
  char l_smclas;
  /* The import file ID.  */
  bfd_size_type l_ifile;
  /* Offset to the parameter type check string.  */
  bfd_size_type l_parm;
};

struct external_ldsym {
  union {
    bfd_byte _l_name[SYMNMLEN];
    struct {
      bfd_byte _l_zeroes[4];
      bfd_byte _l_offset[4];
    } _l_l;
  } _l;
  bfd_byte l_value[4];
  bfd_byte l_scnum[2];
  bfd_byte l_smtype[1];
  bfd_byte l_smclas[1];
  bfd_byte l_ifile[4];
  bfd_byte l_parm[4];
};

#define LDSYMSZ (8 + 3 * 4 + 2 + 2)

/* These flags are for the l_smtype field (the lower three bits are an
   XTY_* value).  */

/* Imported symbol.  */
#define L_IMPORT (0x40)
/* Entry point.  */
#define L_ENTRY (0x20)
/* Exported symbol.  */
#define L_EXPORT (0x10)

/* The ldrel structure.  This is used to represent a reloc in the
   .loader section.  */

struct internal_ldrel {
  /* The reloc address.  */
  bfd_vma l_vaddr;
  /* The symbol table index in the .loader section symbol table.  */
  bfd_size_type l_symndx;
  /* The relocation type and size.  */
  short l_rtype;
  /* The section number this relocation applies to.  */
  short l_rsecnm;
};

struct external_ldrel {
  bfd_byte l_vaddr[4];
  bfd_byte l_symndx[4];
  bfd_byte l_rtype[2];
  bfd_byte l_rsecnm[2];
};

#define LDRELSZ (2 * 4 + 2 * 2)

a52 128
/* An entry in the XCOFF linker hash table.  */

struct xcoff_link_hash_entry {
  struct bfd_link_hash_entry root;

  /* Symbol index in output file.  Set to -1 initially.  Set to -2 if
     there is a reloc against this symbol.  */
  long indx;

  /* If we have created a TOC entry for this symbol, this is the .tc
     section which holds it.  */
  asection *toc_section;

  union {
    /* If we have created a TOC entry (the XCOFF_SET_TOC flag is set),
       this is the offset in toc_section.  */
    bfd_vma toc_offset;
    /* If the TOC entry comes from an input file, this is set to the
       symbol index of the C_HIDEXT XMC_TC or XMC_TD symbol.  */
    long toc_indx;
  } u;

  /* If this symbol is a function entry point which is called, this
     field holds a pointer to the function descriptor.  If this symbol
     is a function descriptor, this field holds a pointer to the
     function entry point.  */
  struct xcoff_link_hash_entry *descriptor;

  /* The .loader symbol table entry, if there is one.  */
  struct internal_ldsym *ldsym;

  /* If XCOFF_BUILT_LDSYM is set, this is the .loader symbol table
     index.  If XCOFF_BUILD_LDSYM is clear, and XCOFF_IMPORT is set,
     this is the l_ifile value.  */
  long ldindx;

  /* Some linker flags.  */
  unsigned short flags;
  /* Symbol is referenced by a regular object.  */
#define XCOFF_REF_REGULAR (01)
  /* Symbol is defined by a regular object.  */
#define XCOFF_DEF_REGULAR (02)
  /* Symbol is defined by a dynamic object.  */
#define XCOFF_DEF_DYNAMIC (04)
  /* Symbol is used in a reloc being copied into the .loader section.  */
#define XCOFF_LDREL (010)
  /* Symbol is the entry point.  */
#define XCOFF_ENTRY (020)
  /* Symbol is called; this is, it appears in a R_BR reloc.  */
#define XCOFF_CALLED (040)
  /* Symbol needs the TOC entry filled in.  */
#define XCOFF_SET_TOC (0100)
  /* Symbol is explicitly imported.  */
#define XCOFF_IMPORT (0200)
  /* Symbol is explicitly exported.  */
#define XCOFF_EXPORT (0400)
  /* Symbol has been processed by xcoff_build_ldsyms.  */
#define XCOFF_BUILT_LDSYM (01000)
  /* Symbol is mentioned by a section which was not garbage collected.  */
#define XCOFF_MARK (02000)
  /* Symbol size is recorded in size_list list from hash table.  */
#define XCOFF_HAS_SIZE (04000)
  /* Symbol is a function descriptor.  */
#define XCOFF_DESCRIPTOR (010000)
  /* Multiple definitions have been for the symbol.  */
#define XCOFF_MULTIPLY_DEFINED (020000)

  /* The storage mapping class.  */
  unsigned char smclas;
};

/* The XCOFF linker hash table.  */

struct xcoff_link_hash_table {
  struct bfd_link_hash_table root;

  /* The .debug string hash table.  We need to compute this while
     reading the input files, so that we know how large the .debug
     section will be before we assign section positions.  */
  struct bfd_strtab_hash *debug_strtab;

  /* The .debug section we will use for the final output.  */
  asection *debug_section;

  /* The .loader section we will use for the final output.  */
  asection *loader_section;

  /* A count of non TOC relative relocs which will need to be
     allocated in the .loader section.  */
  size_t ldrel_count;

  /* The .loader section header.  */
  struct internal_ldhdr ldhdr;

  /* The .gl section we use to hold global linkage code.  */
  asection *linkage_section;

  /* The .tc section we use to hold toc entries we build for global
     linkage code.  */
  asection *toc_section;

  /* The .ds section we use to hold function descriptors which we
     create for exported symbols.  */
  asection *descriptor_section;

  /* The list of import files.  */
  struct xcoff_import_file *imports;

  /* Required alignment of sections within the output file.  */
  unsigned long file_align;

  /* Whether the .text section must be read-only.  */
  boolean textro;

  /* Whether garbage collection was done.  */
  boolean gc;

  /* A linked list of symbols for which we have size information.  */
  struct xcoff_link_size_list {
    struct xcoff_link_size_list *next;
    struct xcoff_link_hash_entry *h;
    bfd_size_type size;
  } *size_list;

  /* Magic sections: _text, _etext, _data, _edata, _end, end.  */
  asection *special_sections[6];
};

d92 1
a92 1
  struct external_ldsym *ldsym;
d94 1
a94 1
  struct external_ldrel *ldrel;
a112 12
static void xcoff_swap_ldhdr_in
  PARAMS ((bfd *, const struct external_ldhdr *, struct internal_ldhdr *));
static void xcoff_swap_ldhdr_out
  PARAMS ((bfd *, const struct internal_ldhdr *, struct external_ldhdr *));
static void xcoff_swap_ldsym_in
  PARAMS ((bfd *, const struct external_ldsym *, struct internal_ldsym *));
static void xcoff_swap_ldsym_out
  PARAMS ((bfd *, const struct internal_ldsym *, struct external_ldsym *));
static void xcoff_swap_ldrel_in
  PARAMS ((bfd *, const struct external_ldrel *, struct internal_ldrel *));
static void xcoff_swap_ldrel_out
  PARAMS ((bfd *, const struct internal_ldrel *, struct external_ldrel *));
a146 102
/* Routines to swap information in the XCOFF .loader section.  If we
   ever need to write an XCOFF loader, this stuff will need to be
   moved to another file shared by the linker (which XCOFF calls the
   ``binder'') and the loader.  */

/* Swap in the ldhdr structure.  */

static void
xcoff_swap_ldhdr_in (abfd, src, dst)
     bfd *abfd;
     const struct external_ldhdr *src;
     struct internal_ldhdr *dst;
{
  dst->l_version = bfd_get_32 (abfd, src->l_version);
  dst->l_nsyms = bfd_get_32 (abfd, src->l_nsyms);
  dst->l_nreloc = bfd_get_32 (abfd, src->l_nreloc);
  dst->l_istlen = bfd_get_32 (abfd, src->l_istlen);
  dst->l_nimpid = bfd_get_32 (abfd, src->l_nimpid);
  dst->l_impoff = bfd_get_32 (abfd, src->l_impoff);
  dst->l_stlen = bfd_get_32 (abfd, src->l_stlen);
  dst->l_stoff = bfd_get_32 (abfd, src->l_stoff);
}

/* Swap out the ldhdr structure.  */

static void
xcoff_swap_ldhdr_out (abfd, src, dst)
     bfd *abfd;
     const struct internal_ldhdr *src;
     struct external_ldhdr *dst;
{
  bfd_put_32 (abfd, src->l_version, dst->l_version);
  bfd_put_32 (abfd, src->l_nsyms, dst->l_nsyms);
  bfd_put_32 (abfd, src->l_nreloc, dst->l_nreloc);
  bfd_put_32 (abfd, src->l_istlen, dst->l_istlen);
  bfd_put_32 (abfd, src->l_nimpid, dst->l_nimpid);
  bfd_put_32 (abfd, src->l_impoff, dst->l_impoff);
  bfd_put_32 (abfd, src->l_stlen, dst->l_stlen);
  bfd_put_32 (abfd, src->l_stoff, dst->l_stoff);
}

/* Swap in the ldsym structure.  */

static void
xcoff_swap_ldsym_in (abfd, src, dst)
     bfd *abfd;
     const struct external_ldsym *src;
     struct internal_ldsym *dst;
{
  if (bfd_get_32 (abfd, src->_l._l_l._l_zeroes) != 0)
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  else
    {
      dst->_l._l_l._l_zeroes = 0;
      dst->_l._l_l._l_offset = bfd_get_32 (abfd, src->_l._l_l._l_offset);
    }
  dst->l_value = bfd_get_32 (abfd, src->l_value);
  dst->l_scnum = bfd_get_16 (abfd, src->l_scnum);
  dst->l_smtype = bfd_get_8 (abfd, src->l_smtype);
  dst->l_smclas = bfd_get_8 (abfd, src->l_smclas);
  dst->l_ifile = bfd_get_32 (abfd, src->l_ifile);
  dst->l_parm = bfd_get_32 (abfd, src->l_parm);
}

/* Swap out the ldsym structure.  */

static void
xcoff_swap_ldsym_out (abfd, src, dst)
     bfd *abfd;
     const struct internal_ldsym *src;
     struct external_ldsym *dst;
{
  if (src->_l._l_l._l_zeroes != 0)
    memcpy (dst->_l._l_name, src->_l._l_name, SYMNMLEN);
  else
    {
      bfd_put_32 (abfd, 0, dst->_l._l_l._l_zeroes);
      bfd_put_32 (abfd, src->_l._l_l._l_offset, dst->_l._l_l._l_offset);
    }
  bfd_put_32 (abfd, src->l_value, dst->l_value);
  bfd_put_16 (abfd, src->l_scnum, dst->l_scnum);
  bfd_put_8 (abfd, src->l_smtype, dst->l_smtype);
  bfd_put_8 (abfd, src->l_smclas, dst->l_smclas);
  bfd_put_32 (abfd, src->l_ifile, dst->l_ifile);
  bfd_put_32 (abfd, src->l_parm, dst->l_parm);
}

/* Swap in the ldrel structure.  */

static void
xcoff_swap_ldrel_in (abfd, src, dst)
     bfd *abfd;
     const struct external_ldrel *src;
     struct internal_ldrel *dst;
{
  dst->l_vaddr = bfd_get_32 (abfd, src->l_vaddr);
  dst->l_symndx = bfd_get_32 (abfd, src->l_symndx);
  dst->l_rtype = bfd_get_16 (abfd, src->l_rtype);
  dst->l_rsecnm = bfd_get_16 (abfd, src->l_rsecnm);
}

/* Swap out the ldrel structure.  */
a147 12
static void
xcoff_swap_ldrel_out (abfd, src, dst)
     bfd *abfd;
     const struct internal_ldrel *src;
     struct external_ldrel *dst;
{
  bfd_put_32 (abfd, src->l_vaddr, dst->l_vaddr);
  bfd_put_32 (abfd, src->l_symndx, dst->l_symndx);
  bfd_put_16 (abfd, src->l_rtype, dst->l_rtype);
  bfd_put_16 (abfd, src->l_rsecnm, dst->l_rsecnm);
}

d159 1
d211 1
a211 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);
d227 1
a227 1
  struct external_ldsym *elsym, *elsymend;
d249 1
a249 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);
d258 4
a261 3
  elsym = (struct external_ldsym *) (contents + LDHDRSZ);
  elsymend = elsym + ldhdr.l_nsyms;
  for (; elsym < elsymend; elsym++, symbuf++, psyms++)
d265 1
a265 1
      xcoff_swap_ldsym_in (abfd, elsym, &ldsym);
d273 1
a273 10
	  int i;

	  for (i = 0; i < SYMNMLEN; i++)
	    if (ldsym._l._l_name[i] == '\0')
	      break;
	  if (i < SYMNMLEN)
	    symbuf->symbol.name = (char *) elsym->_l._l_name;
	  else
	    {
	      char *c;
d275 6
a280 7
	      c = bfd_alloc (abfd, SYMNMLEN + 1);
	      if (c == NULL)
		return -1;
	      memcpy (c, ldsym._l._l_name, SYMNMLEN);
	      c[SYMNMLEN] = '\0';
	      symbuf->symbol.name = c;
	    }
d332 1
a332 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);
a336 17
/* The typical dynamic reloc.  */

static reloc_howto_type xcoff_dynamic_reloc =
  HOWTO (0,	                /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 false,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "R_POS",               /* name */
	 true,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 false);                /* pcrel_offset */

d349 1
a349 1
  struct external_ldrel *elrel, *elrelend;
d368 1
a368 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) contents, &ldhdr);
d374 5
a378 4
  elrel = ((struct external_ldrel *)
	   (contents + LDHDRSZ + ldhdr.l_nsyms * LDSYMSZ));
  elrelend = elrel + ldhdr.l_nreloc;
  for (; elrel < elrelend; elrel++, relbuf++, prelocs++)
d382 1
a382 1
      xcoff_swap_ldrel_in (abfd, elrel, &ldrel);
d423 1
a423 1
      relbuf->howto = &xcoff_dynamic_reloc;
a512 19
/* Look up an entry in an XCOFF link hash table.  */

#define xcoff_link_hash_lookup(table, string, create, copy, follow) \
  ((struct xcoff_link_hash_entry *) \
   bfd_link_hash_lookup (&(table)->root, (string), (create), (copy),\
			 (follow)))

/* Traverse an XCOFF link hash table.  */

#define xcoff_link_hash_traverse(table, func, info)			\
  (bfd_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct bfd_link_hash_entry *, PTR))) (func),	\
    (info)))

/* Get the XCOFF link hash table from the info structure.  This is
   just a cast.  */

#define xcoff_hash_table(p) ((struct xcoff_link_hash_table *) ((p)->hash))
d528 1
d558 1
d580 1
d637 1
d661 1
d722 1
d734 1
a734 1
	      && (info->hash->creator != abfd->xvec
d763 1
a763 1
  bfd_byte *buf;
d766 1
a766 1
  struct external_ldsym *elsym, *elsymend;
d779 3
a781 1
  buf = coff_section_data (abfd, lsec)->contents;
d783 1
a783 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) buf, &ldhdr);
d785 1
a785 1
  strings = (char *) buf + ldhdr.l_stoff;
d787 2
a788 3
  elsym = (struct external_ldsym *) (buf + LDHDRSZ);
  elsymend = elsym + ldhdr.l_nsyms;
  for (; elsym < elsymend; elsym++)
d795 1
a795 1
      xcoff_swap_ldsym_in (abfd, elsym, &ldsym);
d829 1
a829 1
  if (buf != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
d888 94
d1021 6
a1026 6
  struct reloc_info_struct
    {
      struct internal_reloc *relocs;
      asection **csects;
      bfd_byte *linenos;
    } *reloc_info = NULL;
d1031 3
a1033 4
      && ! info->static_link)
    {
      if (! xcoff_link_add_dynamic_symbols (abfd, info))
	return false;
d1035 1
d1037 4
a1040 67
  if (info->hash->creator == abfd->xvec)
    {
      /* We need to build a .loader section, so we do it here.  This
	 won't work if we're producing an XCOFF output file with no
	 XCOFF input files.  FIXME.  */
      if (xcoff_hash_table (info)->loader_section == NULL)
	{
	  asection *lsec;

	  lsec = bfd_make_section_anyway (abfd, ".loader");
	  if (lsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->loader_section = lsec;
	  lsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
	}
      /* Likewise for the linkage section.  */
      if (xcoff_hash_table (info)->linkage_section == NULL)
	{
	  asection *lsec;

	  lsec = bfd_make_section_anyway (abfd, ".gl");
	  if (lsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->linkage_section = lsec;
	  lsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
	  lsec->alignment_power = 2;
	}
      /* Likewise for the TOC section.  */
      if (xcoff_hash_table (info)->toc_section == NULL)
	{
	  asection *tsec;

	  tsec = bfd_make_section_anyway (abfd, ".tc");
	  if (tsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->toc_section = tsec;
	  tsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
	  tsec->alignment_power = 2;
	}
      /* Likewise for the descriptor section.  */
      if (xcoff_hash_table (info)->descriptor_section == NULL)
	{
	  asection *dsec;

	  dsec = bfd_make_section_anyway (abfd, ".ds");
	  if (dsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->descriptor_section = dsec;
	  dsec->flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			  | SEC_IN_MEMORY);
	  dsec->alignment_power = 2;
	}
      /* Likewise for the .debug section.  */
      if (xcoff_hash_table (info)->debug_section == NULL
	  && info->strip != strip_all)
	{
	  asection *dsec;

	  dsec = bfd_make_section_anyway (abfd, ".debug");
	  if (dsec == NULL)
	    goto error_return;
	  xcoff_hash_table (info)->debug_section = dsec;
	  dsec->flags |= SEC_HAS_CONTENTS | SEC_IN_MEMORY;
	}
    }
d1058 1
a1058 1
  symcount = obj_raw_syment_count (abfd);
d1098 19
a1116 15
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      last_real = o;
      if ((o->flags & SEC_RELOC) != 0)
	{
	  reloc_info[o->target_index].relocs =
	    xcoff_read_internal_relocs (abfd, o, true, (bfd_byte *) NULL,
					false, (struct internal_reloc *) NULL);
	  reloc_info[o->target_index].csects =
	    (asection **) bfd_malloc (o->reloc_count * sizeof (asection *));
	  if (reloc_info[o->target_index].csects == NULL)
	    goto error_return;
	  memset (reloc_info[o->target_index].csects, 0,
		  o->reloc_count * sizeof (asection *));
	}
d1118 1
a1118 4
      if ((info->strip == strip_none || info->strip == strip_some)
	  && o->lineno_count > 0)
	{
	  bfd_byte *linenos;
d1120 9
a1128 9
	  linenos = (bfd_byte *) bfd_malloc (o->lineno_count * linesz);
	  if (linenos == NULL)
	    goto error_return;
	  reloc_info[o->target_index].linenos = linenos;
	  if (bfd_seek (abfd, o->line_filepos, SEEK_SET) != 0
	      || (bfd_read (linenos, linesz, o->lineno_count, abfd)
		  != linesz * o->lineno_count))
	    goto error_return;
	}
d1130 2
a1143 11
  while (esym < esym_end)
    {
      struct internal_syment sym;
      union internal_auxent aux;
      const char *name;
      char buf[SYMNMLEN + 1];
      int smtyp;
      flagword flags;
      asection *section;
      bfd_vma value;
      struct xcoff_link_hash_entry *set_toc;
d1145 32
a1176 1
      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &sym);
d1178 12
a1189 12
      /* In this pass we are only interested in symbols with csect
         information.  */
      if (sym.n_sclass != C_EXT && sym.n_sclass != C_HIDEXT)
	{
	  if (sym.n_sclass == C_FILE && csect != NULL)
	    {
	      xcoff_section_data (abfd, csect)->last_symndx =
		((esym
		  - (bfd_byte *) obj_coff_external_syms (abfd))
		 / symesz);
	      csect = NULL;
	    }
d1191 1
a1191 11
	  if (csect != NULL)
	    *csect_cache = csect;
	  else if (first_csect == NULL || sym.n_sclass == C_FILE)
	    *csect_cache = coff_section_from_bfd_index (abfd, sym.n_scnum);
	  else
	    *csect_cache = NULL;
	  esym += (sym.n_numaux + 1) * symesz;
	  sym_hash += sym.n_numaux + 1;
	  csect_cache += sym.n_numaux + 1;
	  continue;
	}
d1193 2
a1194 3
      name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
      if (name == NULL)
	goto error_return;
d1202 4
a1205 14
      if ((info->strip == strip_none || info->strip == strip_some)
	  && sym.n_numaux > 1
	  && csect != NULL
	  && ISFCN (sym.n_type))
	{
	  union internal_auxent auxlin;

	  bfd_coff_swap_aux_in (abfd, (PTR) (esym + symesz),
				sym.n_type, sym.n_sclass,
				0, sym.n_numaux, (PTR) &auxlin);
	  if (auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr != 0)
	    {
	      asection *enclosing;
	      bfd_size_type linoff;
d1207 1
a1207 15
	      enclosing = xcoff_section_data (abfd, csect)->enclosing;
	      if (enclosing == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: `%s' has line numbers but no enclosing section"),
		     bfd_get_filename (abfd), name);
		  bfd_set_error (bfd_error_bad_value);
		  goto error_return;
		}
	      linoff = (auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr
			- enclosing->line_filepos);
	      if (linoff < enclosing->lineno_count * linesz)
		{
		  struct internal_lineno lin;
		  bfd_byte *linpstart;
d1209 3
a1211 10
		  linpstart = (reloc_info[enclosing->target_index].linenos
			       + linoff);
		  bfd_coff_swap_lineno_in (abfd, (PTR) linpstart, (PTR) &lin);
		  if (lin.l_lnno == 0
		      && ((bfd_size_type) lin.l_addr.l_symndx
			  == ((esym
			       - (bfd_byte *) obj_coff_external_syms (abfd))
			      / symesz)))
		    {
		      bfd_byte *linpend, *linp;
d1213 11
a1223 22
		      linpend = (reloc_info[enclosing->target_index].linenos
				 + enclosing->lineno_count * linesz);
		      for (linp = linpstart + linesz;
			   linp < linpend;
			   linp += linesz)
			{
			  bfd_coff_swap_lineno_in (abfd, (PTR) linp,
						   (PTR) &lin);
			  if (lin.l_lnno == 0)
			    break;
			}
		      csect->lineno_count += (linp - linpstart) / linesz;
		      /* The setting of line_filepos will only be
                         useful if all the line number entries for a
                         csect are contiguous; this only matters for
                         error reporting.  */
		      if (csect->line_filepos == 0)
			csect->line_filepos =
			  auxlin.x_sym.x_fcnary.x_fcn.x_lnnoptr;
		    }
		}
	    }
d1225 37
d1263 1
a1263 1
      /* Pick up the csect auxiliary information.  */
d1265 7
a1271 8
      if (sym.n_numaux == 0)
	{
	  (*_bfd_error_handler)
	    (_("%s: class %d symbol `%s' has no aux entries"),
	     bfd_get_filename (abfd), sym.n_sclass, name);
	  bfd_set_error (bfd_error_bad_value);
	  goto error_return;
	}
d1273 3
a1275 3
      bfd_coff_swap_aux_in (abfd,
			    (PTR) (esym + symesz * sym.n_numaux),
			    sym.n_type, sym.n_sclass,
a1321 1

d1349 23
a1371 15
	  /* We must merge TOC entries for the same symbol.  We can
	     merge two TOC entries if they are both C_HIDEXT, they
	     both have the same name, they are both 4 bytes long, and
	     they both have a relocation table entry for an external
	     symbol with the same name.  Unfortunately, this means
	     that we must look through the relocations.  Ick.  */
	  if (aux.x_csect.x_smclas == XMC_TC
	      && sym.n_sclass == C_HIDEXT
	      && aux.x_csect.x_scnlen.l == 4
	      && info->hash->creator == abfd->xvec)
	    {
	      asection *enclosing;
	      struct internal_reloc *relocs;
	      bfd_size_type relindx;
	      struct internal_reloc *rel;
d1373 4
a1376 3
	      enclosing = coff_section_from_bfd_index (abfd, sym.n_scnum);
	      if (enclosing == NULL)
		goto error_return;
d1378 3
a1380 11
	      relocs = reloc_info[enclosing->target_index].relocs;
	      relindx = xcoff_find_reloc (relocs, enclosing->reloc_count,
					  sym.n_value);
	      rel = relocs + relindx;
	      if (relindx < enclosing->reloc_count
		  && rel->r_vaddr == (bfd_vma) sym.n_value
		  && rel->r_size == 31
		  && rel->r_type == R_POS)
		{
		  bfd_byte *erelsym;
		  struct internal_syment relsym;
d1382 84
a1465 16
		  erelsym = ((bfd_byte *) obj_coff_external_syms (abfd)
			     + rel->r_symndx * symesz);
		  bfd_coff_swap_sym_in (abfd, (PTR) erelsym, (PTR) &relsym);
		  if (relsym.n_sclass == C_EXT)
		    {
		      const char *relname;
		      char relbuf[SYMNMLEN + 1];
		      boolean copy;
		      struct xcoff_link_hash_entry *h;

		      /* At this point we know that the TOC entry is
			 for an externally visible symbol.  */
		      relname = _bfd_coff_internal_syment_name (abfd, &relsym,
								relbuf);
		      if (relname == NULL)
			goto error_return;
d1467 1
a1467 15
		      /* We only merge TOC entries if the TC name is
                         the same as the symbol name.  This handles
                         the normal case, but not common cases like
                         SYM.P4 which gcc generates to store SYM + 4
                         in the TOC.  FIXME.  */
		      if (strcmp (name, relname) == 0)
			{
			  copy = (! info->keep_memory
				  || relsym._n._n_n._n_zeroes != 0
				  || relsym._n._n_n._n_offset == 0);
			  h = xcoff_link_hash_lookup (xcoff_hash_table (info),
						      relname, true, copy,
						      false);
			  if (h == NULL)
			    goto error_return;
d1469 1
a1469 10
			  /* At this point h->root.type could be
			     bfd_link_hash_new.  That should be OK,
			     since we know for sure that we will come
			     across this symbol as we step through the
			     file.  */

			  /* We store h in *sym_hash for the
			     convenience of the relocate_section
			     function.  */
			  *sym_hash = h;
d1471 3
a1473 3
			  if (h->toc_section != NULL)
			    {
			      asection **rel_csects;
d1475 3
a1477 15
			      /* We already have a TOC entry for this
				 symbol, so we can just ignore this
				 one.  */
			      rel_csects =
				reloc_info[enclosing->target_index].csects;
			      rel_csects[relindx] = bfd_und_section_ptr;
			      break;
			    }

			  /* We are about to create a TOC entry for
			     this symbol.  */
			  set_toc = h;
			}
		    }
		}
d1480 4
a1483 27
	  /* We need to create a new section.  We get the name from
	     the csect storage mapping class, so that the linker can
	     accumulate similar csects together.  */
	  {
	    static const char *csect_name_by_class[] = {
	      ".pr", ".ro", ".db", ".tc", ".ua", ".rw", ".gl", ".xo",
	      ".sv", ".bs", ".ds", ".uc", ".ti", ".tb", NULL, ".tc0",
	      ".td"
	    };
	    const char *csect_name;
	    asection *enclosing;

	    if ((aux.x_csect.x_smclas >=
		 sizeof csect_name_by_class / sizeof csect_name_by_class[0])
		|| csect_name_by_class[aux.x_csect.x_smclas] == NULL)
	      {
		(*_bfd_error_handler)
		  (_("%s: symbol `%s' has unrecognized smclas %d"),
		   bfd_get_filename (abfd), name, aux.x_csect.x_smclas);
		bfd_set_error (bfd_error_bad_value);
		goto error_return;
	      }

	    csect_name = csect_name_by_class[aux.x_csect.x_smclas];
	    csect = bfd_make_section_anyway (abfd, csect_name);
	    if (csect == NULL)
	      goto error_return;
d1487 11
a1497 11
	    if (! bfd_is_abs_section (enclosing)
		&& ((bfd_vma) sym.n_value < enclosing->vma
		    || ((bfd_vma) sym.n_value + aux.x_csect.x_scnlen.l
			> enclosing->vma + enclosing->_raw_size)))
	      {
		(*_bfd_error_handler)
		  (_("%s: csect `%s' not in enclosing section"),
		   bfd_get_filename (abfd), name);
		bfd_set_error (bfd_error_bad_value);
		goto error_return;
	      }
d1520 26
a1545 26
	    if (enclosing->owner == abfd)
	      {
		struct internal_reloc *relocs;
		bfd_size_type relindx;
		struct internal_reloc *rel;
		asection **rel_csect;

		relocs = reloc_info[enclosing->target_index].relocs;
		relindx = xcoff_find_reloc (relocs, enclosing->reloc_count,
					    csect->vma);
		rel = relocs + relindx;
		rel_csect = (reloc_info[enclosing->target_index].csects
			     + relindx);
		csect->rel_filepos = (enclosing->rel_filepos
				      + relindx * bfd_coff_relsz (abfd));
		while (relindx < enclosing->reloc_count
		       && *rel_csect == NULL
		       && rel->r_vaddr < csect->vma + csect->_raw_size)
		  {
		    *rel_csect = csect;
		    csect->flags |= SEC_RELOC;
		    ++csect->reloc_count;
		    ++relindx;
		    ++rel;
		    ++rel_csect;
		  }
d1547 1
d1624 8
a1631 3
	  if (aux.x_csect.x_smclas == XMC_TD)
	    csect = bfd_make_section_anyway (abfd, ".tocbss");
	  else
d1633 1
d1672 25
a1696 26
      if ((smtyp == XTY_SD || smtyp == XTY_CM)
	  && aux.x_csect.x_smclas != XMC_TC
	  && aux.x_csect.x_smclas != XMC_TD)
	{
	  int i;

	  i = -1;
	  if (name[0] == '_')
	    {
	      if (strcmp (name, "_text") == 0)
		i = 0;
	      else if (strcmp (name, "_etext") == 0)
		i = 1;
	      else if (strcmp (name, "_data") == 0)
		i = 2;
	      else if (strcmp (name, "_edata") == 0)
		i = 3;
	      else if (strcmp (name, "_end") == 0)
		i = 4;
	    }
	  else if (name[0] == 'e' && strcmp (name, "end") == 0)
	    i = 5;

	  if (i != -1)
	    xcoff_hash_table (info)->special_sections[i] = csect;
	}
d1739 1
a1739 1
	  if (info->hash->creator == abfd->xvec)
d1861 1
a1861 1
		    = csect->alignment_power;
d1865 1
a1865 1
	  if (info->hash->creator == abfd->xvec)
d1909 1
d1912 1
d1925 1
a1925 1
	      if (info->hash->creator == abfd->xvec
d1978 1
a1978 1
	  o->flags &= ~SEC_RELOC;
d2035 1
a2035 1
  bfd_byte *buf;
d2038 1
a2038 1
  struct external_ldsym *elsym, *elsymend;
d2048 1
a2048 1
  if (info->hash->creator != abfd->xvec)
d2053 1
a2053 1
      bfd_set_error (bfd_error_invalid_operation);
d2056 1
a2056 1

d2078 1
d2081 1
a2081 1
  buf = coff_section_data (abfd, lsec)->contents;
d2087 5
a2091 1
  xcoff_swap_ldhdr_in (abfd, (struct external_ldhdr *) buf, &ldhdr);
d2093 1
a2093 1
  strings = (char *) buf + ldhdr.l_stoff;
d2095 1
a2095 4
  elsym = (struct external_ldsym *) (buf + LDHDRSZ);
  elsymend = elsym + ldhdr.l_nsyms;
  BFD_ASSERT (sizeof (struct external_ldsym) == LDSYMSZ);
  for (; elsym < elsymend; elsym++)
d2102 1
a2102 1
      xcoff_swap_ldsym_in (abfd, elsym, &ldsym);
d2221 1
a2221 1
  if (buf != NULL && ! coff_section_data (abfd, lsec)->keep_contents)
d2279 1
a2753 22
/* This structure is used to pass information through
   xcoff_link_hash_traverse.  */

struct xcoff_loader_info {
  /* Set if a problem occurred.  */
  boolean failed;
  /* Output BFD.  */
  bfd *output_bfd;
  /* Link information structure.  */
  struct bfd_link_info *info;
  /* Whether all defined symbols should be exported.  */
  boolean export_defineds;
  /* Number of ldsym structures.  */
  size_t ldsym_count;
  /* Size of string table.  */
  size_t string_size;
  /* String table.  */
  bfd_byte *strings;
  /* Allocated size of string table.  */
  size_t string_alc;
};

d2803 6
a2808 6
  if (bfd_get_flavour (output_bfd) != bfd_target_xcoff_flavour)
    {
      for (i = 0; i < 6; i++)
	special_sections[i] = NULL;
      return true;
    }
d2826 1
a2826 1
  if (entry == NULL)
d2828 60
a2887 6
  else
    {
      hentry = xcoff_link_hash_lookup (xcoff_hash_table (info), entry,
				       false, false, true);
      if (hentry != NULL)
	hentry->flags |= XCOFF_ENTRY;
d2890 9
d2934 8
a2941 10
  for (i = 0; i < 6; i++)
    {
      asection *sec;

      sec = xcoff_hash_table (info)->special_sections[i];
      if (sec != NULL
	  && gc
	  && (sec->flags & SEC_MARK) == 0)
	sec = NULL;
      special_sections[i] = sec;
d2943 2
d2946 4
a2949 5
  if (info->input_bfds == NULL)
    {
      /* I'm not sure what to do in this bizarre case.  */
      return true;
    }
d2975 1
a2975 1
  ldhdr->l_version = 1;
d2980 3
a2982 3
  ldhdr->l_impoff = (LDHDRSZ
		     + ldhdr->l_nsyms * LDSYMSZ
		     + ldhdr->l_nreloc * LDRELSZ);
d2990 9
d3008 1
a3008 2
  xcoff_swap_ldhdr_out (output_bfd, ldhdr,
			(struct external_ldhdr *) lsec->contents);
d3047 2
a3048 1
     xcoff_link_input_bfd.  */
d3193 9
a3201 1
  size_t len;
d3299 1
a3299 1
      sec->_raw_size += XCOFF_GLINK_SIZE;
d3308 14
a3321 13
      if (hds->toc_section == NULL)
	{
	  hds->toc_section = xcoff_hash_table (ldinfo->info)->toc_section;
	  hds->u.toc_offset = hds->toc_section->_raw_size;
	  hds->toc_section->_raw_size += 4;
	  ++xcoff_hash_table (ldinfo->info)->ldrel_count;
	  ++hds->toc_section->reloc_count;
	  hds->indx = -2;
	  hds->flags |= XCOFF_SET_TOC | XCOFF_LDREL;

	  /* We need to call xcoff_build_ldsyms recursively here,
             because we may already have passed hds on the traversal.  */
	  xcoff_build_ldsyms (hds, p);
d3323 15
a3365 1
	  sec->_raw_size += 12;
d3367 11
a3377 2
	  /* A function descriptor uses two relocs: one for the
             associated code, and one for the TOC address.  */
d3381 4
a3384 2
	  /* We handle writing out the contents of the descriptor in
             xcoff_write_global_symbol.  */
d3453 4
a3456 2
  /* The first 3 symbol table indices are reserved to indicate the
     sections.  */
d3461 5
a3465 34
  len = strlen (h->root.root.string);
  if (len <= SYMNMLEN)
    strncpy (h->ldsym->_l._l_name, h->root.root.string, SYMNMLEN);
  else
    {
      if (ldinfo->string_size + len + 3 > ldinfo->string_alc)
	{
	  size_t newalc;
	  bfd_byte *newstrings;

	  newalc = ldinfo->string_alc * 2;
	  if (newalc == 0)
	    newalc = 32;
	  while (ldinfo->string_size + len + 3 > newalc)
	    newalc *= 2;

	  newstrings = ((bfd_byte *)
			bfd_realloc ((PTR) ldinfo->strings, newalc));
	  if (newstrings == NULL)
	    {
	      ldinfo->failed = true;
	      return false;
	    }
	  ldinfo->string_alc = newalc;
	  ldinfo->strings = newstrings;
	}

      bfd_put_16 (ldinfo->output_bfd, len + 1,
		  ldinfo->strings + ldinfo->string_size);
      strcpy (ldinfo->strings + ldinfo->string_size + 2, h->root.root.string);
      h->ldsym->_l._l_l._l_zeroes = 0;
      h->ldsym->_l._l_l._l_offset = ldinfo->string_size + 2;
      ldinfo->string_size += len + 3;
    }
d3514 5
a3518 7
  finfo.ldsym = ((struct external_ldsym *)
		 (xcoff_hash_table (info)->loader_section->contents
		  + LDHDRSZ));
  finfo.ldrel = ((struct external_ldrel *)
		 (xcoff_hash_table (info)->loader_section->contents
		  + LDHDRSZ
		  + xcoff_hash_table (info)->ldhdr.l_nsyms * LDSYMSZ));
d3638 7
a3644 2
	  for (o = abfd->sections; o != NULL; o = o->next)
	    if (o->reloc_count >= 0xffff || o->lineno_count >= 0xffff)
d3646 2
a3647 1

d3789 1
d3842 1
d3845 20
a3864 25
  if (finfo.internal_syms != NULL)
    {
      free (finfo.internal_syms);
      finfo.internal_syms = NULL;
    }
  if (finfo.sym_indices != NULL)
    {
      free (finfo.sym_indices);
      finfo.sym_indices = NULL;
    }
  if (finfo.linenos != NULL)
    {
      free (finfo.linenos);
      finfo.linenos = NULL;
    }
  if (finfo.contents != NULL)
    {
      free (finfo.contents);
      finfo.contents = NULL;
    }
  if (finfo.external_relocs != NULL)
    {
      free (finfo.external_relocs);
      finfo.external_relocs = NULL;
    }
d3868 21
a3888 12
  if (finfo.last_file_index != -1)
    {
      finfo.last_file.n_value = -1;
      bfd_coff_swap_sym_out (abfd, (PTR) &finfo.last_file,
			     (PTR) finfo.outsyms);
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + finfo.last_file_index * symesz),
		    SEEK_SET) != 0
	  || bfd_write (finfo.outsyms, symesz, 1, abfd) != symesz)
	goto error_return;
    }
d3909 27
a3935 13
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      struct internal_reloc *irel;
      struct internal_reloc *irelend;
      struct xcoff_link_hash_entry **rel_hash;
      struct xcoff_toc_rel_hash *toc_rel_hash;
      bfd_byte *erel;

      /* A stripped file has no relocs.  */
      if (info->strip == strip_all)
	{
	  o->reloc_count = 0;
	  continue;
d3937 3
d3941 12
a3952 2
      if (o->reloc_count == 0)
	continue;
d3954 20
a3973 18
      irel = finfo.section_info[o->target_index].relocs;
      irelend = irel + o->reloc_count;
      rel_hash = finfo.section_info[o->target_index].rel_hashes;
      for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	{
	  if (*rel_hash != NULL)
	    {
	      if ((*rel_hash)->indx < 0)
		{
		  if (! ((*info->callbacks->unattached_reloc)
			 (info, (*rel_hash)->root.root.string,
			  (bfd *) NULL, o, irel->r_vaddr)))
		    goto error_return;
		  (*rel_hash)->indx = 0;
		}
	      irel->r_symndx = (*rel_hash)->indx;
	    }
	}
d3975 4
a3978 41
      for (toc_rel_hash = finfo.section_info[o->target_index].toc_rel_hashes;
	   toc_rel_hash != NULL;
	   toc_rel_hash = toc_rel_hash->next)
	{
	  if (toc_rel_hash->h->u.toc_indx < 0)
	    {
	      if (! ((*info->callbacks->unattached_reloc)
		     (info, toc_rel_hash->h->root.root.string,
		      (bfd *) NULL, o, toc_rel_hash->rel->r_vaddr)))
		goto error_return;
	      toc_rel_hash->h->u.toc_indx = 0;
	    }
	  toc_rel_hash->rel->r_symndx = toc_rel_hash->h->u.toc_indx;
	}

      /* XCOFF requires that the relocs be sorted by address.  We tend
         to produce them in the order in which their containing csects
         appear in the symbol table, which is not necessarily by
         address.  So we sort them here.  There may be a better way to
         do this.  */
      qsort ((PTR) finfo.section_info[o->target_index].relocs,
	     o->reloc_count, sizeof (struct internal_reloc),
	     xcoff_sort_relocs);

      irel = finfo.section_info[o->target_index].relocs;
      irelend = irel + o->reloc_count;
      erel = external_relocs;
      for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	bfd_coff_swap_reloc_out (abfd, (PTR) irel, (PTR) erel);

      if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0
	  || bfd_write ((PTR) external_relocs, relsz, o->reloc_count,
			abfd) != relsz * o->reloc_count)
	goto error_return;
    }

  if (external_relocs != NULL)
    {
      free (external_relocs);
      external_relocs = NULL;
    }
d3981 2
a3982 3
  if (finfo.section_info != NULL)
    {
      unsigned int i;
d3984 5
a3988 9
      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
      finfo.section_info = NULL;
d3990 3
d4039 14
a4052 15
  if (o != NULL)
    {
      struct bfd_strtab_hash *debug_strtab;

      debug_strtab = xcoff_hash_table (info)->debug_strtab;
      BFD_ASSERT (o->output_section->_raw_size - o->output_offset
		  >= _bfd_stringtab_size (debug_strtab));
      if (bfd_seek (abfd,
		    o->output_section->filepos + o->output_offset,
		    SEEK_SET) != 0)
	goto error_return;
      if (! _bfd_stringtab_emit (abfd, debug_strtab))
	goto error_return;
    }

d4056 1
a4056 1

d4062 9
a4070 12
  if (finfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
d4072 3
d4169 1
d4189 1
d4274 3
a4276 3
	  BFD_ASSERT (LDSYMSZ == sizeof (struct external_ldsym));
	  xcoff_swap_ldsym_out (finfo->output_bfd, ldsym,
				finfo->ldsym + h->ldindx - 3);
d4280 3
a4282 3
	  if ((h->flags & XCOFF_ENTRY) != 0
	      && (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak))
d4285 1
d4378 1
d4434 1
d4475 1
d4504 1
a4504 1
		  && finfo->last_file.n_value != (long) output_index)
d4621 2
a4622 1
	      unsigned long indx;
d4684 1
d4692 1
d4695 2
a4696 1
		      unsigned long indx;
d4698 1
a4698 1
		      indx = aux.x_csect.x_scnlen.l;
d4704 5
a4708 4
			  if (symindx < 0)
			    aux.x_sym.x_tagndx.l = 0;
			  else
			    aux.x_sym.x_tagndx.l = symindx;
d4737 1
d4752 1
d4772 1
a4772 1
		      bfd_size_type linoff;
d4871 1
a4871 1
					  >= enclosing->line_filepos + linoff)
d4953 25
a4977 3
  for (o = input_bfd->sections; o != NULL; o = o->next)
    {
      bfd_byte *contents;
d4979 18
a4996 5
      if (! o->linker_mark)
	{
	  /* This section was omitted from the link.  */
	  continue;
	}
d4998 9
a5006 4
      if ((o->flags & SEC_HAS_CONTENTS) == 0
	  || o->_raw_size == 0
	  || (o->flags & SEC_IN_MEMORY) != 0)
	continue;
d5008 9
a5016 12
      /* We have set filepos correctly for the sections we created to
         represent csects, so bfd_get_section_contents should work.  */
      if (coff_section_data (input_bfd, o) != NULL
	  && coff_section_data (input_bfd, o)->contents != NULL)
	contents = coff_section_data (input_bfd, o)->contents;
      else
	{
	  if (! bfd_get_section_contents (input_bfd, o, finfo->contents,
					  (file_ptr) 0, o->_raw_size))
	    return false;
	  contents = finfo->contents;
	}
d5018 1
a5018 19
      if ((o->flags & SEC_RELOC) != 0)
	{
	  int target_index;
	  struct internal_reloc *internal_relocs;
	  struct internal_reloc *irel;
	  bfd_vma offset;
	  struct internal_reloc *irelend;
	  struct xcoff_link_hash_entry **rel_hash;
	  long r_symndx;

	  /* Read in the relocs.  */
	  target_index = o->output_section->target_index;
	  internal_relocs = (xcoff_read_internal_relocs
			     (input_bfd, o, false, finfo->external_relocs,
			      true,
			      (finfo->section_info[target_index].relocs
			       + o->output_section->reloc_count)));
	  if (internal_relocs == NULL)
	    return false;
d5020 1
a5020 9
	  /* Call processor specific code to relocate the section
             contents.  */
	  if (! bfd_coff_relocate_section (output_bfd, finfo->info,
					   input_bfd, o,
					   contents,
					   internal_relocs,
					   finfo->internal_syms,
					   xcoff_data (input_bfd)->csects))
	    return false;
d5022 1
a5022 10
	  offset = o->output_section->vma + o->output_offset - o->vma;
	  irel = internal_relocs;
	  irelend = irel + o->reloc_count;
	  rel_hash = (finfo->section_info[target_index].rel_hashes
		      + o->output_section->reloc_count);
	  for (; irel < irelend; irel++, rel_hash++)
	    {
	      struct xcoff_link_hash_entry *h = NULL;
	      struct internal_ldrel ldrel;
	      boolean quiet;
d5024 1
a5024 1
	      *rel_hash = NULL;
d5026 4
a5029 1
	      /* Adjust the reloc address and symbol index.  */
d5031 56
a5086 1
	      irel->r_vaddr += offset;
d5088 1
a5088 1
	      r_symndx = irel->r_symndx;
d5090 3
a5092 4
	      if (r_symndx == -1)
		h = NULL;
	      else
		h = obj_xcoff_sym_hashes (input_bfd)[r_symndx];
d5094 9
a5102 23
	      if (r_symndx != -1 && finfo->info->strip != strip_all)
		{
		  if (h != NULL
		      && h->smclas != XMC_TD
		      && (irel->r_type == R_TOC
			  || irel->r_type == R_GL
			  || irel->r_type == R_TCL
			  || irel->r_type == R_TRL
			  || irel->r_type == R_TRLA))
		    {
		      /* This is a TOC relative reloc with a symbol
                         attached.  The symbol should be the one which
                         this reloc is for.  We want to make this
                         reloc against the TOC address of the symbol,
                         not the symbol itself.  */
		      BFD_ASSERT (h->toc_section != NULL);
		      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
		      if (h->u.toc_indx != -1)
			irel->r_symndx = h->u.toc_indx;
		      else
			{
			  struct xcoff_toc_rel_hash *n;
			  struct xcoff_link_section_info *si;
d5104 15
a5118 32
			  n = ((struct xcoff_toc_rel_hash *)
			       bfd_alloc (finfo->output_bfd,
					  sizeof (struct xcoff_toc_rel_hash)));
			  if (n == NULL)
			    return false;
			  si = finfo->section_info + target_index;
			  n->next = si->toc_rel_hashes;
			  n->h = h;
			  n->rel = irel;
			  si->toc_rel_hashes = n;
			}
		    }
		  else if (h != NULL)
		    {
		      /* This is a global symbol.  */
		      if (h->indx >= 0)
			irel->r_symndx = h->indx;
		      else
			{
			  /* This symbol is being written at the end
			     of the file, and we do not yet know the
			     symbol index.  We save the pointer to the
			     hash table entry in the rel_hash list.
			     We set the indx field to -2 to indicate
			     that this symbol must not be stripped.  */
			  *rel_hash = h;
			  h->indx = -2;
			}
		    }
		  else
		    {
		      long indx;
d5120 4
a5123 1
		      indx = finfo->sym_indices[r_symndx];
d5125 1
a5125 3
		      if (indx == -1)
			{
			  struct internal_syment *is;
d5127 2
a5128 9
			  /* Relocations against a TC0 TOC anchor are
			     automatically transformed to be against
			     the TOC anchor in the output file.  */
			  is = finfo->internal_syms + r_symndx;
			  if (is->n_sclass == C_HIDEXT
			      && is->n_numaux > 0)
			    {
			      PTR auxptr;
			      union internal_auxent aux;
d5130 4
a5133 15
			      auxptr = ((PTR)
					(((bfd_byte *)
					  obj_coff_external_syms (input_bfd))
					 + ((r_symndx + is->n_numaux)
					    * isymesz)));
			      bfd_coff_swap_aux_in (input_bfd, auxptr,
						    is->n_type, is->n_sclass,
						    is->n_numaux - 1,
						    is->n_numaux,
						    (PTR) &aux);
			      if (SMTYP_SMTYP (aux.x_csect.x_smtyp) == XTY_SD
				  && aux.x_csect.x_smclas == XMC_TC0)
				indx = finfo->toc_symindx;
			    }
			}
d5135 2
a5136 17
		      if (indx != -1)
			irel->r_symndx = indx;
		      else
			{
			  struct internal_syment *is;
			  const char *name;
			  char buf[SYMNMLEN + 1];

			  /* This reloc is against a symbol we are
			     stripping.  It would be possible to handle
			     this case, but I don't think it's worth it.  */
			  is = finfo->internal_syms + r_symndx;

			  name = (_bfd_coff_internal_syment_name
				  (input_bfd, is, buf));
			  if (name == NULL)
			    return false;
d5138 2
a5139 7
			  if (! ((*finfo->info->callbacks->unattached_reloc)
				 (finfo->info, name, input_bfd, o,
				  irel->r_vaddr)))
			    return false;
			}
		    }
		}
d5141 7
a5147 25
	      quiet = false;
	      switch (irel->r_type)
		{
		default:
		  if (h == NULL
		      || h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak
		      || h->root.type == bfd_link_hash_common)
		    break;
		  /* Fall through.  */
		case R_POS:
		case R_NEG:
		case R_RL:
		case R_RLA:
		  /* This reloc needs to be copied into the .loader
		     section.  */
		  ldrel.l_vaddr = irel->r_vaddr;
		  if (r_symndx == -1)
		    ldrel.l_symndx = -1;
		  else if (h == NULL
			   || (h->root.type == bfd_link_hash_defined
			       || h->root.type == bfd_link_hash_defweak
			       || h->root.type == bfd_link_hash_common))
		    {
		      asection *sec;
d5149 25
a5173 7
		      if (h == NULL)
			sec = xcoff_data (input_bfd)->csects[r_symndx];
		      else if (h->root.type == bfd_link_hash_common)
			sec = h->root.u.c.p->section;
		      else
			sec = h->root.u.def.section;
		      sec = sec->output_section;
d5175 63
a5237 58
		      if (strcmp (sec->name, ".text") == 0)
			ldrel.l_symndx = 0;
		      else if (strcmp (sec->name, ".data") == 0)
			ldrel.l_symndx = 1;
		      else if (strcmp (sec->name, ".bss") == 0)
			ldrel.l_symndx = 2;
		      else
			{
			  (*_bfd_error_handler)
			    (_("%s: loader reloc in unrecognized section `%s'"),
			     bfd_get_filename (input_bfd),
			     sec->name);
			  bfd_set_error (bfd_error_nonrepresentable_section);
			  return false;
			}
		    }
		  else
		    {
		      if (! finfo->info->relocateable
			  && (h->flags & XCOFF_DEF_DYNAMIC) == 0
			  && (h->flags & XCOFF_IMPORT) == 0)
			{
			  /* We already called the undefined_symbol
			     callback for this relocation, in
			     _bfd_ppc_xcoff_relocate_section.  Don't
			     issue any more warnings.  */
			  quiet = true;
			}
		      if (h->ldindx < 0 && ! quiet)
			{
			  (*_bfd_error_handler)
			    (_("%s: `%s' in loader reloc but not loader sym"),
			     bfd_get_filename (input_bfd),
			     h->root.root.string);
			  bfd_set_error (bfd_error_bad_value);
			  return false;
			}
		      ldrel.l_symndx = h->ldindx;
		    }
		  ldrel.l_rtype = (irel->r_size << 8) | irel->r_type;
		  ldrel.l_rsecnm = o->output_section->target_index;
		  if (xcoff_hash_table (finfo->info)->textro
		      && strcmp (o->output_section->name, ".text") == 0
		      && ! quiet)
		    {
		      (*_bfd_error_handler)
			(_("%s: loader reloc in read-only section %s"),
			 bfd_get_filename (input_bfd),
			 bfd_get_section_name (finfo->output_bfd,
					       o->output_section));
		      bfd_set_error (bfd_error_invalid_operation);
		      return false;
		    }
		  xcoff_swap_ldrel_out (output_bfd, &ldrel,
					finfo->ldrel);
		  BFD_ASSERT (sizeof (struct external_ldrel) == LDRELSZ);
		  ++finfo->ldrel;
		  break;
d5239 2
a5240 10
		case R_TOC:
		case R_GL:
		case R_TCL:
		case R_TRL:
		case R_TRLA:
		  /* We should never need a .loader reloc for a TOC
		     relative reloc.  */
		  break;
		}
	    }
d5242 10
a5251 2
	  o->output_section->reloc_count += o->reloc_count;
	}
d5253 1
a5253 7
      /* Write out the modified section contents.  */
      if (! bfd_set_section_contents (output_bfd, o->output_section,
				      contents, o->output_offset,
				      (o->_cooked_size != 0
				       ? o->_cooked_size
				       : o->_raw_size)))
	return false;
d5256 9
d5281 1
d5292 1
d5303 26
a5328 4
  if (h->ldsym != NULL)
    {
      struct internal_ldsym *ldsym;
      bfd *impbfd;
d5330 3
a5332 1
      ldsym = h->ldsym;
d5334 5
a5338 12
      if (h->root.type == bfd_link_hash_undefined
	  || h->root.type == bfd_link_hash_undefweak)
	{
	  ldsym->l_value = 0;
	  ldsym->l_scnum = N_UNDEF;
	  ldsym->l_smtype = XTY_ER;
	  impbfd = h->root.u.undef.abfd;
	}
      else if (h->root.type == bfd_link_hash_defined
	       || h->root.type == bfd_link_hash_defweak)
	{
	  asection *sec;
d5340 5
a5344 10
	  sec = h->root.u.def.section;
	  ldsym->l_value = (sec->output_section->vma
			    + sec->output_offset
			    + h->root.u.def.value);
	  ldsym->l_scnum = sec->output_section->target_index;
	  ldsym->l_smtype = XTY_SD;
	  impbfd = sec->owner;
	}
      else
	abort ();
d5346 3
a5348 10
      if (((h->flags & XCOFF_DEF_REGULAR) == 0
	   && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	  || (h->flags & XCOFF_IMPORT) != 0)
	ldsym->l_smtype |= L_IMPORT;
      if (((h->flags & XCOFF_DEF_REGULAR) != 0
	   && (h->flags & XCOFF_DEF_DYNAMIC) != 0)
	  || (h->flags & XCOFF_EXPORT) != 0)
	ldsym->l_smtype |= L_EXPORT;
      if ((h->flags & XCOFF_ENTRY) != 0)
	ldsym->l_smtype |= L_ENTRY;
d5350 3
a5352 1
      ldsym->l_smclas = h->smclas;
d5354 1
a5354 14
      if (ldsym->l_ifile == (bfd_size_type) -1)
	ldsym->l_ifile = 0;
      else if (ldsym->l_ifile == 0)
	{
	  if ((ldsym->l_smtype & L_IMPORT) == 0)
	    ldsym->l_ifile = 0;
	  else if (impbfd == NULL)
	    ldsym->l_ifile = 0;
	  else
	    {
	      BFD_ASSERT (impbfd->xvec == output_bfd->xvec);
	      ldsym->l_ifile = xcoff_data (impbfd)->import_file_id;
	    }
	}
d5356 2
a5357 1
      ldsym->l_parm = 0;
d5359 9
a5367 4
      BFD_ASSERT (h->ldindx >= 0);
      BFD_ASSERT (LDSYMSZ == sizeof (struct external_ldsym));
      xcoff_swap_ldsym_out (output_bfd, ldsym, finfo->ldsym + h->ldindx - 3);
      h->ldsym = NULL;
d5369 11
a5379 1

d5381 3
a5383 7
  if (h->root.type == bfd_link_hash_defined
      && (h->root.u.def.section
	  == xcoff_hash_table (finfo->info)->linkage_section))
    {
      bfd_byte *p;
      bfd_vma tocoff;
      unsigned int i;
d5385 5
a5389 1
      p = h->root.u.def.section->contents + h->root.u.def.value;
d5391 27
a5417 12
      /* The first instruction in the global linkage code loads a
         specific TOC element.  */
      tocoff = (h->descriptor->toc_section->output_section->vma
		+ h->descriptor->toc_section->output_offset
		- xcoff_data (output_bfd)->toc);
      if ((h->descriptor->flags & XCOFF_SET_TOC) != 0)
	tocoff += h->descriptor->u.toc_offset;
      bfd_put_32 (output_bfd, XCOFF_GLINK_FIRST | (tocoff & 0xffff), p);
      for (i = 0, p += 4;
	   i < sizeof xcoff_glink_code / sizeof xcoff_glink_code[0];
	   i++, p += 4)
	bfd_put_32 (output_bfd, xcoff_glink_code[i], p);
d5419 1
d5440 3
a5442 1
      if (h->indx >= 0)
d5444 35
a5478 5
      else
	{
	  h->indx = -2;
	  irel->r_symndx = obj_raw_syment_count (output_bfd);
	}
a5479 1
      irel->r_size = 31;
a5482 1
      BFD_ASSERT (h->ldindx >= 0);
d5485 1
a5485 1
      ldrel.l_rtype = (31 << 8) | R_POS;
d5487 2
a5488 2
      xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      ++finfo->ldrel;
d5490 2
a5491 10
      /* We need to emit a symbol to define a csect which holds the
         reloc.  */
      if (finfo->info->strip != strip_all)
	{
	  if (strlen (h->root.root.string) <= SYMNMLEN)
	    strncpy (irsym._n._n_name, h->root.root.string, SYMNMLEN);
	  else
	    {
	      boolean hash;
	      bfd_size_type indx;
d5493 5
a5497 10
	      hash = true;
	      if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
		hash = false;
	      indx = _bfd_stringtab_add (finfo->strtab, h->root.root.string,
					 hash, false);
	      if (indx == (bfd_size_type) -1)
		return false;
	      irsym._n._n_n._n_zeroes = 0;
	      irsym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
	    }
d5499 13
a5511 5
	  irsym.n_value = irel->r_vaddr;
	  irsym.n_scnum = osec->target_index;
	  irsym.n_sclass = C_HIDEXT;
	  irsym.n_type = T_NULL;
	  irsym.n_numaux = 1;
d5513 3
a5515 15
	  bfd_coff_swap_sym_out (output_bfd, (PTR) &irsym, (PTR) outsym);
	  outsym += bfd_coff_symesz (output_bfd);

	  memset (&iraux, 0, sizeof iraux);
	  iraux.x_csect.x_smtyp = XTY_SD;
	  iraux.x_csect.x_scnlen.l = 4;
	  iraux.x_csect.x_smclas = XMC_TC;

	  bfd_coff_swap_aux_out (output_bfd, (PTR) &iraux, T_NULL, C_HIDEXT,
				 0, 1, (PTR) outsym);
	  outsym += bfd_coff_auxesz (output_bfd);

	  if (h->indx >= 0)
	    {
	      /* We aren't going to write out the symbols below, so we
d5534 12
a5545 4
  /* If this symbol is a specially defined function descriptor, write
     it out.  The first word is the address of the function code
     itself, the second word is the address of the TOC, and the third
     word is zero.  */
d5560 11
a5581 5
      bfd_put_32 (output_bfd,
		  (esec->output_section->vma
		   + esec->output_offset
		   + hentry->root.u.def.value),
		  p);
d5589 1
a5589 1
      irel->r_size = 31;
d5609 1
a5609 1
      ldrel.l_rtype = (31 << 8) | R_POS;
d5611 2
a5612 4
      xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      ++finfo->ldrel;

      bfd_put_32 (output_bfd, xcoff_data (output_bfd)->toc, p + 4);
d5614 27
d5648 1
a5648 1
		       + 4);
d5651 1
a5651 1
      irel->r_size = 31;
d5671 1
a5671 1
      ldrel.l_rtype = (31 << 8) | R_POS;
d5673 2
a5674 2
      xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
      ++finfo->ldrel;
d5705 5
a5709 17
  if (strlen (h->root.root.string) <= SYMNMLEN)
    strncpy (isym._n._n_name, h->root.root.string, SYMNMLEN);
  else
    {
      boolean hash;
      bfd_size_type indx;

      hash = true;
      if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
	hash = false;
      indx = _bfd_stringtab_add (finfo->strtab, h->root.root.string, hash,
				 false);
      if (indx == (bfd_size_type) -1)
	return false;
      isym._n._n_n._n_zeroes = 0;
      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
    }
a5773 1

a5791 1

d5990 2
a5991 2
  xcoff_swap_ldrel_out (output_bfd, &ldrel, finfo->ldrel);
  ++finfo->ldrel;
a6013 3
/* This is the relocation function for the RS/6000/POWER/PowerPC.
   This is currently the only processor which uses XCOFF; I hope that
   will never change.  */
a6014 15
boolean
_bfd_ppc_xcoff_relocate_section (output_bfd, info, input_bfd,
				 input_section, contents, relocs, syms,
				 sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;
a6015 17
  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct xcoff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma addend;
      bfd_vma val;
      struct reloc_howto_struct howto;
      bfd_reloc_status_type rstat;

      /* Relocation type R_REF is a special relocation type which is
         merely used to prevent garbage collection from occurring for
         the csect including the symbol which it references.  */
      if (rel->r_type == R_REF)
	continue;
a6016 314
      symndx = rel->r_symndx;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	  addend = 0;
	}
      else
	{
	  h = obj_xcoff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	  addend = - sym->n_value;
	}

      /* We build the howto information on the fly.  */

      howto.type = rel->r_type;
      howto.rightshift = 0;
      howto.size = 2;
      howto.bitsize = (rel->r_size & 0x1f) + 1;
      howto.pc_relative = false;
      howto.bitpos = 0;
      if ((rel->r_size & 0x80) != 0)
	howto.complain_on_overflow = complain_overflow_signed;
      else
	howto.complain_on_overflow = complain_overflow_bitfield;
      howto.special_function = NULL;
      howto.name = "internal";
      howto.partial_inplace = true;
      if (howto.bitsize == 32)
	howto.src_mask = howto.dst_mask = 0xffffffff;
      else
	{
	  howto.src_mask = howto.dst_mask = (1 << howto.bitsize) - 1;
	  if (howto.bitsize == 16)
	    howto.size = 1;
	}
      howto.pcrel_offset = false;

      val = 0;

      if (h == NULL)
	{
	  asection *sec;

	  if (symndx == -1)
	    {
	      sec = bfd_abs_section_ptr;
	      val = 0;
	    }
	  else
	    {
	      sec = sections[symndx];
	      /* Hack to make sure we use the right TOC anchor value
                 if this reloc is against the TOC anchor.  */
	      if (sec->name[3] == '0'
		  && strcmp (sec->name, ".tc0") == 0)
		val = xcoff_data (output_bfd)->toc;
	      else
		val = (sec->output_section->vma
		       + sec->output_offset
		       + sym->n_value
		       - sec->vma);
	    }
	}
      else
	{
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      asection *sec;

	      sec = h->root.u.def.section;
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_common)
	    {
	      asection *sec;

	      sec = h->root.u.c.p->section;
	      val = (sec->output_section->vma
		     + sec->output_offset);
	    }
	  else if ((h->flags & XCOFF_DEF_DYNAMIC) != 0
		   || (h->flags & XCOFF_IMPORT) != 0)
	    {
	      /* Every symbol in a shared object is defined somewhere.  */
	      val = 0;
	    }
	  else if (! info->relocateable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, true)))
		return false;

	      /* Don't try to process the reloc.  It can't help, and
                 it may generate another error.  */
	      continue;
	    }
	}

      /* I took the relocation type definitions from two documents:
	 the PowerPC AIX Version 4 Application Binary Interface, First
	 Edition (April 1992), and the PowerOpen ABI, Big-Endian
	 32-Bit Hardware Implementation (June 30, 1994).  Differences
	 between the documents are noted below.  */

      switch (rel->r_type)
	{
	case R_RTB:
	case R_RRTBI:
	case R_RRTBA:
	  /* These relocs are defined by the PowerPC ABI to be
             relative branches which use half of the difference
             between the symbol and the program counter.  I can't
             quite figure out when this is useful.  These relocs are
             not defined by the PowerOpen ABI.  */
	default:
	  (*_bfd_error_handler)
	    (_("%s: unsupported relocation type 0x%02x"),
	     bfd_get_filename (input_bfd), (unsigned int) rel->r_type);
	  bfd_set_error (bfd_error_bad_value);
	  return false;
	case R_POS:
	  /* Simple positive relocation.  */
	  break;
	case R_NEG:
	  /* Simple negative relocation.  */
	  val = - val;
	  break;
	case R_REL:
	  /* Simple PC relative relocation.  */
	  howto.pc_relative = true;
	  break;
	case R_TOC:
	  /* TOC relative relocation.  The value in the instruction in
             the input file is the offset from the input file TOC to
             the desired location.  We want the offset from the final
             TOC to the desired location.  We have:
	         isym = iTOC + in
		 iinsn = in + o
		 osym = oTOC + on
		 oinsn = on + o
	     so we must change insn by on - in.
	     */
	case R_GL:
	  /* Global linkage relocation.  The value of this relocation
             is the address of the entry in the TOC section.  */
	case R_TCL:
	  /* Local object TOC address.  I can't figure out the
             difference between this and case R_GL.  */
	case R_TRL:
	  /* TOC relative relocation.  A TOC relative load instruction
             which may be changed to a load address instruction.
             FIXME: We don't currently implement this optimization.  */
	case R_TRLA:
	  /* TOC relative relocation.  This is a TOC relative load
             address instruction which may be changed to a load
             instruction.  FIXME: I don't know if this is the correct
             implementation.  */
	  if (h != NULL && h->smclas != XMC_TD)
	    {
	      if (h->toc_section == NULL)
		{
		  (*_bfd_error_handler)
		    (_("%s: TOC reloc at 0x%x to symbol `%s' with no TOC entry"),
		     bfd_get_filename (input_bfd), rel->r_vaddr,
		     h->root.root.string);
		  bfd_set_error (bfd_error_bad_value);
		  return false;
		}

	      BFD_ASSERT ((h->flags & XCOFF_SET_TOC) == 0);
	      val = (h->toc_section->output_section->vma
		     + h->toc_section->output_offset);
	    }

	  val = ((val - xcoff_data (output_bfd)->toc)
		 - (sym->n_value - xcoff_data (input_bfd)->toc));
	  addend = 0;
	  break;
	case R_BA:
	  /* Absolute branch.  We don't want to mess with the lower
             two bits of the instruction.  */
	case R_CAI:
	  /* The PowerPC ABI defines this as an absolute call which
             may be modified to become a relative call.  The PowerOpen
             ABI does not define this relocation type.  */
	case R_RBA:
	  /* Absolute branch which may be modified to become a
             relative branch.  */
	case R_RBAC:
	  /* The PowerPC ABI defines this as an absolute branch to a
             fixed address which may be modified to an absolute branch
             to a symbol.  The PowerOpen ABI does not define this
             relocation type.  */
	case R_RBRC:
	  /* The PowerPC ABI defines this as an absolute branch to a
             fixed address which may be modified to a relative branch.
             The PowerOpen ABI does not define this relocation type.  */
	  howto.src_mask &= ~3;
	  howto.dst_mask = howto.src_mask;
	  break;
	case R_BR:
	  /* Relative branch.  We don't want to mess with the lower
             two bits of the instruction.  */
	case R_CREL:
	  /* The PowerPC ABI defines this as a relative call which may
             be modified to become an absolute call.  The PowerOpen
             ABI does not define this relocation type.  */
	case R_RBR:
	  /* A relative branch which may be modified to become an
             absolute branch.  FIXME: We don't implement this,
             although we should for symbols of storage mapping class
             XMC_XO.  */
	  howto.pc_relative = true;
	  howto.src_mask &= ~3;
	  howto.dst_mask = howto.src_mask;
	  break;
	case R_RL:
	  /* The PowerPC AIX ABI describes this as a load which may be
             changed to a load address.  The PowerOpen ABI says this
             is the same as case R_POS.  */
	  break;
	case R_RLA:
	  /* The PowerPC AIX ABI describes this as a load address
             which may be changed to a load.  The PowerOpen ABI says
             this is the same as R_POS.  */
	  break;
	}

      /* If we see an R_BR or R_RBR reloc which is jumping to global
         linkage code, and it is followed by an appropriate cror nop
         instruction, we replace the cror with lwz r2,20(r1).  This
         restores the TOC after the glink code.  Contrariwise, if the
         call is followed by a lwz r2,20(r1), but the call is not
         going to global linkage code, we can replace the load with a
         cror.  */
      if ((rel->r_type == R_BR || rel->r_type == R_RBR)
	  && h != NULL
	  && h->root.type == bfd_link_hash_defined
	  && (rel->r_vaddr - input_section->vma + 8
	      <= input_section->_cooked_size))
	{
	  bfd_byte *pnext;
	  unsigned long next;

	  pnext = contents + (rel->r_vaddr - input_section->vma) + 4;
	  next = bfd_get_32 (input_bfd, pnext);

	  /* The _ptrgl function is magic.  It is used by the AIX
             compiler to call a function through a pointer.  */
	  if (h->smclas == XMC_GL
	      || strcmp (h->root.root.string, "._ptrgl") == 0)
	    {
	      if (next == 0x4def7b82		/* cror 15,15,15 */
		  || next == 0x4ffffb82		/* cror 31,31,31 */
		  || next == 0x60000000)	/* ori r0,r0,0 */
		bfd_put_32 (input_bfd, 0x80410014, pnext); /* lwz r1,20(r1) */
	    }
	  else
	    {
	      if (next == 0x80410014)		/* lwz r1,20(r1) */
		bfd_put_32 (input_bfd, 0x60000000, pnext); /* ori r0,r0,0 */
	    }
	}

      /* A PC relative reloc includes the section address.  */
      if (howto.pc_relative)
	addend += input_section->vma;

      rstat = _bfd_final_link_relocate (&howto, input_bfd, input_section,
					contents,
					rel->r_vaddr - input_section->vma,
					val, addend);

      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];
	    char howto_name[10];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = h->root.root.string;
	    else
	      {
		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
		if (name == NULL)
		  return false;
	      }
	    sprintf (howto_name, "0x%02x", rel->r_type);

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, name, howto_name, (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
	      return false;
	  }
	}
    }

  return true;
}
@


1.9
log
@2000-11-30  Kazu Hirata  <kazu@@hxi.com>

	* xcofflink.c: Fix formatting.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.9.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
@


1.8
log
@	* xcofflink.c (xcoff_link_input_bfd): Include the .tocbss
 	pseduo-section when determining where the TOC ends.

	* coff-rs6000.c (_bfd_xcoff_swap_aux_out): Use bfd_h_put_16 to
	output x_tvndx as it is only two bytes wide.

	* coff-rs6000.c (xcoff_howto_table): A modifiable branch-absolute
        reloc is 26 or 32 bits wide.

	* coff-rs6000.c (_bfd_xcoff_rtype2howto): The bitsize is irrelevant
        for relocs that don't change anything.  Also look at the full
        6 bits of bitsize.
@
text
@d70 1
a70 2
static unsigned long xcoff_glink_code[] =
{
d92 1
a92 2
struct internal_ldhdr
{
d113 1
a113 2
struct external_ldhdr
{
d129 12
a140 15
struct internal_ldsym
{
  union
    {
      /* The symbol name if <= SYMNMLEN characters.  */
      char _l_name[SYMNMLEN];
      struct
	{
	  /* Zero if the symbol name is more than SYMNMLEN characters.  */
	  long _l_zeroes;
	  /* The offset in the string table if the symbol name is more
             than SYMNMLEN characters.  */
	  long _l_offset;
	} _l_l;
    } _l;
d155 8
a162 11
struct external_ldsym
{
  union
    {
      bfd_byte _l_name[SYMNMLEN];
      struct
	{
	  bfd_byte _l_zeroes[4];
	  bfd_byte _l_offset[4];
	} _l_l;
    } _l;
d186 1
a186 2
struct internal_ldrel
{
d197 1
a197 2
struct external_ldrel
{
d208 1
a208 2
struct xcoff_import_file
{
d221 1
a221 2
struct xcoff_link_hash_entry
{
d232 8
a239 9
  union
    {
      /* If we have created a TOC entry (the XCOFF_SET_TOC flag is
	 set), this is the offset in toc_section.  */
      bfd_vma toc_offset;
      /* If the TOC entry comes from an input file, this is set to the
         symbol index of the C_HIDEXT XMC_TC or XMC_TD symbol.  */
      long toc_indx;
    } u;
d292 1
a292 2
struct xcoff_link_hash_table
{
d337 5
a341 6
  struct xcoff_link_size_list
    {
      struct xcoff_link_size_list *next;
      struct xcoff_link_hash_entry *h;
      bfd_size_type size;
    } *size_list;
d350 1
a350 2
struct xcoff_link_section_info
{
d360 5
a364 6
  struct xcoff_toc_rel_hash
    {
      struct xcoff_toc_rel_hash *next;
      struct xcoff_link_hash_entry *h;
      struct internal_reloc *rel;
    } *toc_rel_hashes;
d369 1
a369 2
struct xcoff_final_link_info
{
d768 6
a773 6
  HOWTO (0,	                /* type */                                 
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d775 5
a779 5
	 0,		        /* special_function */                     
	 "R_POS",               /* name */                                 
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d1870 5
a1874 6
	    static const char *csect_name_by_class[] =
	      {
		".pr", ".ro", ".db", ".tc", ".ua", ".rw", ".gl", ".xo",
		".sv", ".bs", ".ds", ".uc", ".ti", ".tb", NULL, ".tc0",
		".td"
	      };
d2264 1
a2264 1
		     = csect->alignment_power;
d2379 1
a2379 1
	  o->flags &=~ SEC_RELOC;
d3120 1
a3120 1
  
d3155 1
a3155 2
struct xcoff_loader_info
{
d4075 1
a4075 1
		     * sizeof (struct xcoff_link_hash_entry *)));
d4676 2
a4677 2
	      for (inp = finfo->info->input_bfds; 
		   inp != NULL; 
d4681 1
a4681 1
		  
d4692 1
a4692 1
		  
d4694 1
a4694 1
	      
d6326 1
a6326 1
	{    
@


1.7
log
@* xcofflink.c (_bfd_ppc_xcoff_relocate_section): Add ori r0,r0,0
to the list of NOPs we recognize after a branch-and-link.
Use the ori NOP when one is needed.

* coff-rs6000.c (_bfd_xcoff_slurp_armap): Finish implementation
for large archives.
@
text
@d4682 1
d4688 1
d4694 1
a4694 3
                 script.  FIXME: This doesn't handle .tocbss sections
                 created from XMC_TD common symbols correctly.  */

d4697 19
a4715 1

@


1.6
log
@	* bfd-in.h (bfd_family_coff): Define.
	* bfd-in2.h: Regenerate.
	* coffgen.c (coff_count_linenumbers, coff_symbol_from,
	coff_find_nearest_line): Check COFFness using bfd_family_coff()
	instead of bfd_target_coff_flavour.
	* cofflink.c (_bfd_coff_final_link): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Don't strcmp() target name to
	exclude XCOFF files.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Likewise.
	* targets.c (enum bfd_flavour): Add bfd_target_xcoff_flavour.
	* xcoff-target.h (TARGET_SYM): Use bfd_target_xcoff_flavour.
	* xcofflink.c (XCOFF_XVECP): Delete.
	(bfd_xcoff_link_record_set, bfd_xcoff_import_symbol,
	bfd_xcoff_export_symbol, bfd_xcoff_link_count_reloc,
	bfd_xcoff_record_link_assignment,
	bfd_xcoff_size_dynamic_sections): Replace XCOFF_XVECP() with
	check for bfd_target_xcoff_flavour.
@
text
@d6580 2
a6581 1
		  || next == 0x4ffffb82)	/* cror 31,31,31 */
d6587 1
a6587 1
		bfd_put_32 (input_bfd, 0x4ffffb82, pnext); /* cror 31,31,31 */
@


1.5
log
@	Add XCOFF64 support.

	bfd:
	* Makefile.am (coff64-rs6000.lo): New rule.
	* Makefile.in: Regenerate.
	* coff-rs6000.c (xcoff_mkobject, xcoff_copy_private_bfd_data,
	xcoff_is_local_label_name, xcoff_rtype2howto,
	xcoff_reloc_type_lookup, xcoff_slurp_armap, xcoff_archive_p,
	xcoff_read_ar_hdr, xcoff_openr_next_archived_file, xcoff_write_armap,
	xcoff_write_archive_contents): No longer static, and prefix with _bfd_.
	(NO_COFF_SYMBOLS): Define.
	(xcoff64_swap_sym_in, xcoff64_swap_sym_out, xcoff64_swap_aux_in,
	xcoff64_swap_aux_out): New functions; handle xcoff symbol tables
	internally.
	(MINUS_ONE): New macro.
	(xcoff_howto_tabl, xcoff_reloc_type_lookup): Add 64 bit POS
	relocation.
	(coff_SWAP_sym_in, coff_SWAP_sym_out, coff_SWAP_aux_in,
	coff_SWAP_aux_out): Map to the new functions.
	* coff64-rs6000.c: New file.
	* libcoff.h (bfd_coff_backend_data): Add new fields
	_bfd_coff_force_symnames_in_strings and
	_bfd_coff_debug_string_prefix_length.
	(bfd_coff_force_symnames_in_strings,
	bfd_coff_debug_string_prefix_length): New macros for above fields.
	* coffcode.h (coff_set_arch_mach_hook): Handle XCOFF64 magic.
	Set machine to 620 for XCOFF64.  Use bfd_coff_swap_sym_in instead
	of using coff_swap_sym_in directly.
	(FORCE_SYMNAMES_IN_STRINGS): New macro, defined for XCOFF64.
	(coff_set_flags) Set magic for XCOFF64.
	(coff_compute_section_file_positions): Add symbol name length to
	string section length if bfd_coff_debug_string_prefix_length is
	true.
	(coff_write_object_contents): Don't do reloc overflow for XCOFF64.
	(coff_slurp_line_table): Use bfd_coff_swap_lineno_in instead of
	using coff_swap_lineno_in directly.
	(bfd_coff_backend_data): Add _bfd_coff_force_symnames_in_strings
	and _bfd_coff_debug_string_prefix_length fields.
	* coffgen.c (coff_fix_symbol_name, coff_write_symbols): Force
	symbol names into strings table when
	bfd_coff_force_symnames_in_strings is true.
	* coffswap.h (MAX_SCNHDR_NRELOC, MAX_SCNHDR_NLNNO, GET_RELOC_VADDR,
	SET_RELOC_VADDR): New macros.
	(coff_swap_reloc_in, coff_swap_reloc_out): Use above macros.
	(coff_swap_aux_in, coff_swap_aux_out): Remove RS6000COFF_C
	code.
	(coff_swap_aouthdr_in, coff_swap_aouthdr_out): Handle XCOFF64
	changes within RS6000COFF_C specific code.
	(coff_swap_scnhdr_out): Use PUT_SCNHDR_NLNNO, PUT_SCNHDR_NRELOC,
	MAX_SCNHDR_NRELOC, and MAX_SCNHDR_NLNNO.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Extend existing hack on target name.
	* xcofflink.c (XCOFF_XVECP): Extend existing hack on
	target name.
	* coff-tic54x.c (ticof): Keep up to date with new fields
	in bfd_coff_backend_data.
	* config.bfd: Add bfd_powerpc_64_arch to targ_arch and define
	targ_selvecs to include rs6000coff64_vec for rs6000.
	* configure.in: Add rs6000coff64_vec case.
 	* cpu-powerpc.c: New bfd_arch_info_type.

	gas:
	* as.c (parse_args): Allow md_parse_option to override -a listing
	option.
	* config/obj-coff.c (add_lineno): Change type of offset parameter
	from "int" to "bfd_vma."
	* config/tc-ppc.c (md_pseudo_table): Add "llong" and "machine."
	(ppc_mach, ppc_subseg_align, ppc_target_format): New.
	(ppc_change_csect): Align correctly for XCOFF64.
	(ppc_machine): New function, which discards "ppc_machine" line.
	(ppc_tc): Cons for 8 when code is 64 bit.
	(md_apply_fix3): Don't check operand->insert.  Handle 64 bit
	relocations.
	(md_parse_option): Handle -a64 and -a32.
	(ppc_xcoff64): New.
	* config/tc-ppc.h (TARGET_MACH): Define.
	(TARGET_FORMAT): Move to function.
	(SUB_SEGMENT_ALIGN): Use ppc_subseg_align.

	include:
	* include/coff/rs6k64.h: New file.

	opcodes:
	* configure.in: Add bfd_powerpc_64_arch.
	* disassemble.c (disassembler): Use print_insn_big_powerpc for
	64 bit code.
@
text
@a31 9
/* In order to support linking different object file formats into an
   XCOFF format, we need to be able to determine whether a particular
   bfd_target is an XCOFF vector.  FIXME: We need to rethink this
   whole approach.  */
#define XCOFF_XVECP(xv) \
  (strcmp ((xv)->name, "aixcoff-rs6000") == 0 \
   || strcmp ((xv)->name, "aixcoff64-rs6000") == 0 \
   || strcmp ((xv)->name, "xcoff-powermac") == 0)

d2910 1
a2910 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d2946 1
a2946 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d3060 1
a3060 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d3125 1
a3125 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d3159 1
a3159 1
  if (! XCOFF_XVECP (output_bfd->xvec))
d3244 1
a3244 1
  if (! XCOFF_XVECP (output_bfd->xvec))
@


1.4
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d38 1
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d6424 1
a6424 1
		      rel->r_vaddr - input_section->vma)))
@


1.2
log
@	* xcofflink.c (bfd_xcoff_size_dynamic_sections): Don't crash if
	the entry symbol is not set.
@
text
@d3064 1
a3064 1
     boolean syscall;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997 Free Software Foundation, Inc.
d3275 9
a3283 4
  hentry = xcoff_link_hash_lookup (xcoff_hash_table (info), entry,
				   false, false, true);
  if (hentry != NULL)
    hentry->flags |= XCOFF_ENTRY;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

