head	1.82;
access;
symbols
	sid-snapshot-20180601:1.82
	sid-snapshot-20180501:1.82
	sid-snapshot-20180401:1.82
	sid-snapshot-20180301:1.82
	sid-snapshot-20180201:1.82
	sid-snapshot-20180101:1.82
	sid-snapshot-20171201:1.82
	sid-snapshot-20171101:1.82
	sid-snapshot-20171001:1.82
	sid-snapshot-20170901:1.82
	sid-snapshot-20170801:1.82
	sid-snapshot-20170701:1.82
	sid-snapshot-20170601:1.82
	sid-snapshot-20170501:1.82
	sid-snapshot-20170401:1.82
	sid-snapshot-20170301:1.82
	sid-snapshot-20170201:1.82
	sid-snapshot-20170101:1.82
	sid-snapshot-20161201:1.82
	sid-snapshot-20161101:1.82
	sid-snapshot-20160901:1.82
	sid-snapshot-20160801:1.82
	sid-snapshot-20160701:1.82
	sid-snapshot-20160601:1.82
	sid-snapshot-20160501:1.82
	sid-snapshot-20160401:1.82
	sid-snapshot-20160301:1.82
	sid-snapshot-20160201:1.82
	sid-snapshot-20160101:1.82
	sid-snapshot-20151201:1.82
	sid-snapshot-20151101:1.82
	sid-snapshot-20151001:1.82
	sid-snapshot-20150901:1.82
	sid-snapshot-20150801:1.82
	sid-snapshot-20150701:1.82
	sid-snapshot-20150601:1.82
	sid-snapshot-20150501:1.82
	sid-snapshot-20150401:1.82
	sid-snapshot-20150301:1.82
	sid-snapshot-20150201:1.82
	sid-snapshot-20150101:1.82
	sid-snapshot-20141201:1.82
	sid-snapshot-20141101:1.82
	sid-snapshot-20141001:1.82
	sid-snapshot-20140901:1.82
	sid-snapshot-20140801:1.82
	sid-snapshot-20140701:1.82
	sid-snapshot-20140601:1.82
	sid-snapshot-20140501:1.82
	sid-snapshot-20140401:1.82
	sid-snapshot-20140301:1.82
	sid-snapshot-20140201:1.82
	sid-snapshot-20140101:1.82
	sid-snapshot-20131201:1.82
	sid-snapshot-20131101:1.82
	sid-snapshot-20131001:1.82
	binutils-2_24-branch:1.82.0.2
	binutils-2_24-branchpoint:1.82
	binutils-2_21_1:1.63
	sid-snapshot-20130901:1.82
	gdb_7_6_1-2013-08-30-release:1.74
	sid-snapshot-20130801:1.82
	sid-snapshot-20130701:1.78
	sid-snapshot-20130601:1.78
	sid-snapshot-20130501:1.76
	gdb_7_6-2013-04-26-release:1.74
	sid-snapshot-20130401:1.76
	binutils-2_23_2:1.71.4.1
	gdb_7_6-branch:1.74.0.2
	gdb_7_6-2013-03-12-branchpoint:1.74
	sid-snapshot-20130301:1.74
	sid-snapshot-20130201:1.73
	sid-snapshot-20130101:1.73
	sid-snapshot-20121201:1.73
	gdb_7_5_1-2012-11-29-release:1.71
	binutils-2_23_1:1.71.4.1
	sid-snapshot-20121101:1.73
	binutils-2_23:1.71.4.1
	sid-snapshot-20121001:1.73
	sid-snapshot-20120901:1.72
	gdb_7_5-2012-08-17-release:1.71
	sid-snapshot-20120801:1.71
	binutils-2_23-branch:1.71.0.4
	binutils-2_23-branchpoint:1.71
	gdb_7_5-branch:1.71.0.2
	gdb_7_5-2012-07-18-branchpoint:1.71
	sid-snapshot-20120701:1.70
	sid-snapshot-20120601:1.69
	sid-snapshot-20120501:1.66
	binutils-2_22_branch:1.64.0.6
	gdb_7_4_1-2012-04-26-release:1.64
	sid-snapshot-20120401:1.65
	sid-snapshot-20120301:1.64
	sid-snapshot-20120201:1.64
	gdb_7_4-2012-01-24-release:1.64
	sid-snapshot-20120101:1.64
	gdb_7_4-branch:1.64.0.4
	gdb_7_4-2011-12-13-branchpoint:1.64
	sid-snapshot-20111201:1.64
	binutils-2_22:1.64
	sid-snapshot-20111101:1.64
	sid-snapshot-20111001:1.64
	binutils-2_22-branch:1.64.0.2
	binutils-2_22-branchpoint:1.64
	gdb_7_3_1-2011-09-04-release:1.63
	sid-snapshot-20110901:1.64
	sid-snapshot-20110801:1.64
	gdb_7_3-2011-07-26-release:1.63
	sid-snapshot-20110701:1.64
	sid-snapshot-20110601:1.63
	sid-snapshot-20110501:1.63
	gdb_7_3-branch:1.63.0.4
	gdb_7_3-2011-04-01-branchpoint:1.63
	sid-snapshot-20110401:1.63
	sid-snapshot-20110301:1.63
	sid-snapshot-20110201:1.63
	sid-snapshot-20110101:1.63
	binutils-2_21:1.63
	sid-snapshot-20101201:1.63
	binutils-2_21-branch:1.63.0.2
	binutils-2_21-branchpoint:1.63
	sid-snapshot-20101101:1.63
	sid-snapshot-20101001:1.62
	binutils-2_20_1:1.56
	gdb_7_2-2010-09-02-release:1.61
	sid-snapshot-20100901:1.61
	sid-snapshot-20100801:1.61
	gdb_7_2-branch:1.61.0.2
	gdb_7_2-2010-07-07-branchpoint:1.61
	sid-snapshot-20100701:1.61
	sid-snapshot-20100601:1.60
	sid-snapshot-20100501:1.60
	sid-snapshot-20100401:1.60
	gdb_7_1-2010-03-18-release:1.60
	sid-snapshot-20100301:1.60
	gdb_7_1-branch:1.60.0.2
	gdb_7_1-2010-02-18-branchpoint:1.60
	sid-snapshot-20100201:1.59
	sid-snapshot-20100101:1.59
	gdb_7_0_1-2009-12-22-release:1.56
	sid-snapshot-20091201:1.59
	sid-snapshot-20091101:1.59
	binutils-2_20:1.56
	gdb_7_0-2009-10-06-release:1.56
	sid-snapshot-20091001:1.56
	gdb_7_0-branch:1.56.0.4
	gdb_7_0-2009-09-16-branchpoint:1.56
	arc-sim-20090309:1.47
	binutils-arc-20081103-branch:1.47.0.20
	binutils-arc-20081103-branchpoint:1.47
	binutils-2_20-branch:1.56.0.2
	binutils-2_20-branchpoint:1.56
	sid-snapshot-20090901:1.55
	sid-snapshot-20090801:1.55
	msnyder-checkpoint-072509-branch:1.55.0.4
	msnyder-checkpoint-072509-branchpoint:1.55
	sid-snapshot-20090701:1.55
	dje-cgen-play1-branch:1.55.0.2
	dje-cgen-play1-branchpoint:1.55
	sid-snapshot-20090601:1.49
	sid-snapshot-20090501:1.49
	sid-snapshot-20090401:1.48
	arc-20081103-branch:1.47.0.18
	arc-20081103-branchpoint:1.47
	arc-insight_6_8-branch:1.47.0.16
	arc-insight_6_8-branchpoint:1.47
	insight_6_8-branch:1.47.0.14
	insight_6_8-branchpoint:1.47
	sid-snapshot-20090301:1.48
	binutils-2_19_1:1.47
	sid-snapshot-20090201:1.48
	sid-snapshot-20090101:1.48
	reverse-20081226-branch:1.48.0.2
	reverse-20081226-branchpoint:1.48
	sid-snapshot-20081201:1.48
	multiprocess-20081120-branch:1.47.0.12
	multiprocess-20081120-branchpoint:1.47
	sid-snapshot-20081101:1.47
	binutils-2_19:1.47
	sid-snapshot-20081001:1.47
	reverse-20080930-branch:1.47.0.10
	reverse-20080930-branchpoint:1.47
	binutils-2_19-branch:1.47.0.8
	binutils-2_19-branchpoint:1.47
	sid-snapshot-20080901:1.47
	sid-snapshot-20080801:1.47
	reverse-20080717-branch:1.47.0.6
	reverse-20080717-branchpoint:1.47
	sid-snapshot-20080701:1.47
	msnyder-reverse-20080609-branch:1.47.0.4
	msnyder-reverse-20080609-branchpoint:1.47
	drow-reverse-20070409-branch:1.42.0.2
	drow-reverse-20070409-branchpoint:1.42
	sid-snapshot-20080601:1.47
	sid-snapshot-20080501:1.47
	sid-snapshot-20080403:1.47
	sid-snapshot-20080401:1.47
	gdb_6_8-2008-03-27-release:1.47
	sid-snapshot-20080301:1.47
	gdb_6_8-branch:1.47.0.2
	gdb_6_8-2008-02-26-branchpoint:1.47
	sid-snapshot-20080201:1.47
	sid-snapshot-20080101:1.46
	sid-snapshot-20071201:1.46
	sid-snapshot-20071101:1.46
	gdb_6_7_1-2007-10-29-release:1.45
	gdb_6_7-2007-10-10-release:1.45
	sid-snapshot-20071001:1.46
	gdb_6_7-branch:1.45.0.4
	gdb_6_7-2007-09-07-branchpoint:1.45
	binutils-2_18:1.45
	binutils-2_18-branch:1.45.0.2
	binutils-2_18-branchpoint:1.45
	insight_6_6-20070208-release:1.39
	binutils-csl-coldfire-4_1-32:1.36
	binutils-csl-sourcerygxx-4_1-32:1.36
	gdb_6_6-2006-12-18-release:1.39
	binutils-csl-innovasic-fido-3_4_4-33:1.36
	binutils-csl-sourcerygxx-3_4_4-32:1.26
	binutils-csl-coldfire-4_1-30:1.36
	binutils-csl-sourcerygxx-4_1-30:1.36
	binutils-csl-coldfire-4_1-28:1.36
	binutils-csl-sourcerygxx-4_1-29:1.36
	binutils-csl-sourcerygxx-4_1-28:1.36
	gdb_6_6-branch:1.39.0.2
	gdb_6_6-2006-11-15-branchpoint:1.39
	binutils-csl-arm-2006q3-27:1.36
	binutils-csl-sourcerygxx-4_1-27:1.36
	binutils-csl-arm-2006q3-26:1.36
	binutils-csl-sourcerygxx-4_1-26:1.36
	binutils-csl-sourcerygxx-4_1-25:1.36
	binutils-csl-sourcerygxx-4_1-24:1.36
	binutils-csl-sourcerygxx-4_1-23:1.36
	insight_6_5-20061003-release:1.36
	gdb-csl-symbian-6_4_50_20060226-12:1.34
	binutils-csl-sourcerygxx-4_1-21:1.36
	binutils-csl-arm-2006q3-21:1.36
	binutils-csl-sourcerygxx-4_1-22:1.36
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.36
	binutils-csl-sourcerygxx-4_1-20:1.36
	binutils-csl-arm-2006q3-19:1.36
	binutils-csl-sourcerygxx-4_1-19:1.36
	binutils-csl-sourcerygxx-4_1-18:1.36
	binutils-csl-renesas-4_1-9:1.36
	gdb-csl-sourcerygxx-3_4_4-25:1.34
	binutils-csl-sourcerygxx-3_4_4-25:1.26
	nickrob-async-20060828-mergepoint:1.36
	gdb-csl-symbian-6_4_50_20060226-11:1.34
	binutils-csl-renesas-4_1-8:1.36
	binutils-csl-renesas-4_1-7:1.36
	binutils-csl-renesas-4_1-6:1.36
	gdb-csl-sourcerygxx-4_1-17:1.34
	binutils-csl-sourcerygxx-4_1-17:1.36
	gdb-csl-20060226-branch-local-2:1.34
	gdb-csl-sourcerygxx-4_1-14:1.34
	binutils-csl-sourcerygxx-4_1-14:1.36
	binutils-csl-sourcerygxx-4_1-15:1.36
	gdb-csl-sourcerygxx-4_1-13:1.34
	binutils-csl-sourcerygxx-4_1-13:1.36
	binutils-2_17:1.36
	gdb-csl-sourcerygxx-4_1-12:1.34
	binutils-csl-sourcerygxx-4_1-12:1.36
	gdb-csl-sourcerygxx-3_4_4-21:1.34
	binutils-csl-sourcerygxx-3_4_4-21:1.36
	gdb_6_5-20060621-release:1.36
	binutils-csl-wrs-linux-3_4_4-24:1.26
	binutils-csl-wrs-linux-3_4_4-23:1.26
	gdb-csl-sourcerygxx-4_1-9:1.34
	binutils-csl-sourcerygxx-4_1-9:1.36
	gdb-csl-sourcerygxx-4_1-8:1.34
	binutils-csl-sourcerygxx-4_1-8:1.36
	gdb-csl-sourcerygxx-4_1-7:1.34
	binutils-csl-sourcerygxx-4_1-7:1.36
	gdb-csl-arm-2006q1-6:1.34
	binutils-csl-arm-2006q1-6:1.36
	gdb-csl-sourcerygxx-4_1-6:1.34
	binutils-csl-sourcerygxx-4_1-6:1.36
	binutils-csl-wrs-linux-3_4_4-22:1.26
	gdb-csl-symbian-6_4_50_20060226-10:1.34
	gdb-csl-symbian-6_4_50_20060226-9:1.34
	gdb-csl-symbian-6_4_50_20060226-8:1.34
	gdb-csl-coldfire-4_1-11:1.34
	binutils-csl-coldfire-4_1-11:1.36
	gdb-csl-sourcerygxx-3_4_4-19:1.34
	binutils-csl-sourcerygxx-3_4_4-19:1.36
	gdb-csl-coldfire-4_1-10:1.34
	gdb_6_5-branch:1.36.0.14
	gdb_6_5-2006-05-14-branchpoint:1.36
	binutils-csl-coldfire-4_1-10:1.36
	gdb-csl-sourcerygxx-4_1-5:1.34
	binutils-csl-sourcerygxx-4_1-5:1.36
	nickrob-async-20060513-branch:1.36.0.12
	nickrob-async-20060513-branchpoint:1.36
	gdb-csl-sourcerygxx-4_1-4:1.34
	binutils-csl-sourcerygxx-4_1-4:1.36
	msnyder-reverse-20060502-branch:1.36.0.10
	msnyder-reverse-20060502-branchpoint:1.36
	binutils-csl-wrs-linux-3_4_4-21:1.26
	gdb-csl-morpho-4_1-4:1.34
	binutils-csl-morpho-4_1-4:1.36
	gdb-csl-sourcerygxx-3_4_4-17:1.34
	binutils-csl-sourcerygxx-3_4_4-17:1.36
	binutils-csl-wrs-linux-3_4_4-20:1.26
	readline_5_1-import-branch:1.36.0.8
	readline_5_1-import-branchpoint:1.36
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.34
	binutils-2_17-branch:1.36.0.6
	binutils-2_17-branchpoint:1.36
	gdb-csl-symbian-20060226-branch:1.34.0.12
	gdb-csl-symbian-20060226-branchpoint:1.34
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.34
	msnyder-reverse-20060331-branch:1.36.0.4
	msnyder-reverse-20060331-branchpoint:1.36
	binutils-csl-2_17-branch:1.36.0.2
	binutils-csl-2_17-branchpoint:1.36
	gdb-csl-available-20060303-branch:1.35.0.2
	gdb-csl-available-20060303-branchpoint:1.35
	gdb-csl-20060226-branch:1.34.0.10
	gdb-csl-20060226-branchpoint:1.34
	gdb_6_4-20051202-release:1.34
	msnyder-fork-checkpoint-branch:1.34.0.8
	msnyder-fork-checkpoint-branchpoint:1.34
	gdb-csl-gxxpro-6_3-branch:1.34.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.34
	gdb_6_4-branch:1.34.0.4
	gdb_6_4-2005-11-01-branchpoint:1.34
	gdb-csl-arm-20051020-branch:1.34.0.2
	gdb-csl-arm-20051020-branchpoint:1.34
	binutils-csl-gxxpro-3_4-branch:1.26.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.26
	binutils-2_16_1:1.26
	msnyder-tracepoint-checkpoint-branch:1.30.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.30
	gdb-csl-arm-20050325-2005-q1b:1.26
	binutils-csl-arm-2005q1b:1.26
	binutils-2_16:1.26
	gdb-csl-arm-20050325-2005-q1a:1.26
	binutils-csl-arm-2005q1a:1.26
	csl-arm-20050325-branch:1.26.0.6
	csl-arm-20050325-branchpoint:1.26
	binutils-csl-arm-2005q1-branch:1.26.0.4
	binutils-csl-arm-2005q1-branchpoint:1.26
	binutils-2_16-branch:1.26.0.2
	binutils-2_16-branchpoint:1.26
	csl-arm-2004-q3d:1.25
	gdb_6_3-20041109-release:1.24
	gdb_6_3-branch:1.24.0.2
	gdb_6_3-20041019-branchpoint:1.24
	csl-arm-2004-q3:1.24
	drow_intercu-merge-20040921:1.24
	drow_intercu-merge-20040915:1.22
	jimb-gdb_6_2-e500-branch:1.22.0.6
	jimb-gdb_6_2-e500-branchpoint:1.22
	gdb_6_2-20040730-release:1.22
	gdb_6_2-branch:1.22.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.22
	gdb_6_1_1-20040616-release:1.18
	binutils-2_15:1.18.6.1
	binutils-2_15-branchpoint:1.18
	csl-arm-2004-q1a:1.21
	csl-arm-2004-q1:1.21
	gdb_6_1-2004-04-05-release:1.18
	drow_intercu-merge-20040402:1.21
	drow_intercu-merge-20040327:1.20
	ezannoni_pie-20040323-branch:1.19.0.2
	ezannoni_pie-20040323-branchpoint:1.19
	cagney_tramp-20040321-mergepoint:1.18
	cagney_tramp-20040309-branch:1.18.0.12
	cagney_tramp-20040309-branchpoint:1.18
	gdb_6_1-branch:1.18.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.18
	drow_intercu-20040221-branch:1.18.0.8
	drow_intercu-20040221-branchpoint:1.18
	binutils-2_15-branch:1.18.0.6
	cagney_bfdfile-20040213-branch:1.18.0.4
	cagney_bfdfile-20040213-branchpoint:1.18
	drow-cplus-merge-20040208:1.18
	carlton_dictionary-20040126-merge:1.18
	cagney_bigcore-20040122-branch:1.18.0.2
	cagney_bigcore-20040122-branchpoint:1.18
	drow-cplus-merge-20040113:1.18
	csl-arm-2003-q4:1.17
	drow-cplus-merge-20031224:1.17
	drow-cplus-merge-20031220:1.17
	carlton_dictionary-20031215-merge:1.17
	drow-cplus-merge-20031214:1.17
	carlton-dictionary-20031111-merge:1.16
	gdb_6_0-2003-10-04-release:1.12
	kettenis_sparc-20030918-branch:1.14.0.6
	kettenis_sparc-20030918-branchpoint:1.14
	carlton_dictionary-20030917-merge:1.14
	ezannoni_pie-20030916-branchpoint:1.14
	ezannoni_pie-20030916-branch:1.14.0.4
	cagney_x86i386-20030821-branch:1.14.0.2
	cagney_x86i386-20030821-branchpoint:1.14
	carlton_dictionary-20030805-merge:1.13
	carlton_dictionary-20030627-merge:1.13
	gdb_6_0-branch:1.12.0.32
	gdb_6_0-2003-06-23-branchpoint:1.12
	jimb-ppc64-linux-20030613-branch:1.12.0.30
	jimb-ppc64-linux-20030613-branchpoint:1.12
	binutils-2_14:1.12
	cagney_convert-20030606-branch:1.12.0.28
	cagney_convert-20030606-branchpoint:1.12
	cagney_writestrings-20030508-branch:1.12.0.26
	cagney_writestrings-20030508-branchpoint:1.12
	jimb-ppc64-linux-20030528-branch:1.12.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.12
	carlton_dictionary-20030523-merge:1.12
	cagney_fileio-20030521-branch:1.12.0.22
	cagney_fileio-20030521-branchpoint:1.12
	kettenis_i386newframe-20030517-mergepoint:1.12
	jimb-ppc64-linux-20030509-branch:1.12.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.12
	kettenis_i386newframe-20030504-mergepoint:1.12
	carlton_dictionary-20030430-merge:1.12
	binutils-2_14-branch:1.12.0.18
	binutils-2_14-branchpoint:1.12
	kettenis_i386newframe-20030419-branch:1.12.0.16
	kettenis_i386newframe-20030419-branchpoint:1.12
	carlton_dictionary-20030416-merge:1.12
	cagney_frameaddr-20030409-mergepoint:1.12
	kettenis_i386newframe-20030406-branch:1.12.0.14
	kettenis_i386newframe-20030406-branchpoint:1.12
	cagney_frameaddr-20030403-branchpoint:1.12
	cagney_frameaddr-20030403-branch:1.12.0.12
	cagney_framebase-20030330-mergepoint:1.12
	cagney_framebase-20030326-branch:1.12.0.10
	cagney_framebase-20030326-branchpoint:1.12
	cagney_lazyid-20030317-branch:1.12.0.8
	cagney_lazyid-20030317-branchpoint:1.12
	kettenis-i386newframe-20030316-mergepoint:1.12
	offbyone-20030313-branch:1.12.0.6
	offbyone-20030313-branchpoint:1.12
	kettenis-i386newframe-20030308-branch:1.12.0.4
	kettenis-i386newframe-20030308-branchpoint:1.12
	carlton_dictionary-20030305-merge:1.12
	cagney_offbyone-20030303-branch:1.12.0.2
	cagney_offbyone-20030303-branchpoint:1.12
	carlton_dictionary-20030207-merge:1.11
	interps-20030202-branch:1.11.0.4
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.2
	cagney-unwind-20030108-branchpoint:1.11
	binutils-2_13_2_1:1.5.2.1
	binutils-2_13_2:1.5.2.1
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.6
	carlton_dictionary-20021115-merge:1.8
	binutils-2_13_1:1.5.2.1
	kseitz_interps-20021105-merge:1.8
	kseitz_interps-20021103-merge:1.8
	drow-cplus-merge-20021020:1.8
	drow-cplus-merge-20021025:1.8
	carlton_dictionary-20021025-merge:1.8
	carlton_dictionary-20021011-merge:1.8
	drow-cplus-branch:1.8.0.2
	drow-cplus-branchpoint:1.8
	kseitz_interps-20020930-merge:1.8
	carlton_dictionary-20020927-merge:1.6
	carlton_dictionary-branch:1.6.0.10
	carlton_dictionary-20020920-branchpoint:1.6
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.8
	gdb_5_3-branch:1.6.0.6
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.6
	cagney_sysregs-20020825-branch:1.6.0.4
	cagney_sysregs-20020825-branchpoint:1.6
	readline_4_3-import-branch:1.6.0.2
	readline_4_3-import-branchpoint:1.6
	binutils-2_13:1.5
	binutils-2_13-branchpoint:1.5
	binutils-2_13-branch:1.5.0.2
	kseitz_interps-20020528-branch:1.3.0.4
	cagney_regbuf-20020515-branch:1.3.0.2
	binutils_latest_snapshot:1.82;
locks; strict;
comment	@ * @;


1.82
date	2013.07.27.22.38.50;	author macro;	state Exp;
branches;
next	1.81;

1.81
date	2013.07.27.22.21.10;	author macro;	state Exp;
branches;
next	1.80;

1.80
date	2013.07.27.19.32.53;	author macro;	state Exp;
branches;
next	1.79;

1.79
date	2013.07.27.19.17.29;	author macro;	state Exp;
branches;
next	1.78;

1.78
date	2013.05.20.23.28.32;	author macro;	state Exp;
branches;
next	1.77;

1.77
date	2013.05.19.21.40.00;	author macro;	state Exp;
branches;
next	1.76;

1.76
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2013.02.10.04.36.32;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2012.09.02.12.17.26;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2012.08.05.22.45.19;	author macro;	state Exp;
branches;
next	1.71;

1.71
date	2012.07.13.14.22.47;	author nickc;	state Exp;
branches
	1.71.4.1;
next	1.70;

1.70
date	2012.06.29.14.46.01;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2012.05.19.19.27.01;	author macro;	state Exp;
branches;
next	1.68;

1.68
date	2012.05.19.19.23.24;	author macro;	state Exp;
branches;
next	1.67;

1.67
date	2012.05.07.03.27.51;	author macro;	state Exp;
branches;
next	1.66;

1.66
date	2012.04.24.05.12.35;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2012.03.13.06.04.35;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2011.06.13.00.59.11;	author amodra;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.24.12.14.24;	author tschwinge;	state Exp;
branches;
next	1.61;

1.61
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2010.02.04.09.16.40;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.25.01.43.06;	author macro;	state Exp;
branches;
next	1.58;

1.58
date	2009.10.25.01.27.56;	author macro;	state Exp;
branches;
next	1.57;

1.57
date	2009.10.25.00.49.43;	author macro;	state Exp;
branches;
next	1.56;

1.56
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2009.06.16.02.23.09;	author macro;	state Exp;
branches;
next	1.54;

1.54
date	2009.06.16.02.16.54;	author macro;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.16.02.14.12;	author macro;	state Exp;
branches;
next	1.52;

1.52
date	2009.06.16.02.07.22;	author macro;	state Exp;
branches;
next	1.51;

1.51
date	2009.06.16.01.57.39;	author macro;	state Exp;
branches;
next	1.50;

1.50
date	2009.06.16.01.52.12;	author macro;	state Exp;
branches;
next	1.49;

1.49
date	2009.04.02.00.20.42;	author matt;	state Exp;
branches;
next	1.48;

1.48
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2008.01.11.09.07.03;	author gingold;	state Exp;
branches;
next	1.46;

1.46
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.45;

1.45
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2007.05.15.13.55.53;	author hjl;	state Exp;
branches;
next	1.43;

1.43
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.06.16.29.32;	author matt;	state Exp;
branches;
next	1.41;

1.41
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.34;

1.34
date	2005.08.18.01.28.24;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.08.06.20.01;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.20.18.12.08;	author hjl;	state Exp;
branches;
next	1.31;

1.31
date	2005.06.03.10.13.15;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.05.14.33.53;	author hjl;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.04.15.53.23;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.04.11.00.16;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.04.07.19.24;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.11.09.32.51;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.21.15.28.25;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2004.09.17.07.14.28;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2004.09.16.14.52.05;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.24.04.46.21;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2004.03.25.12.48.37;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2004.03.22.02.28.17;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.11.07.40.24;	author kazu;	state Exp;
branches
	1.18.6.1
	1.18.8.1;
next	1.17;

1.17
date	2003.12.01.06.33.01;	author kazu;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.11.13.32.37;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.25.06.40.25;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2003.02.17.18.24.39;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.20.22.41.13;	author kazu;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.28.11.55.41;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.28.23.15.50;	author thorpej;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2002.09.27.22.28.17;	author thorpej;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches
	1.6.10.1;
next	1.5;

1.5
date	2002.07.01.16.43.36;	author thorpej;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2002.07.01.08.06.44;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.04.05.28.52;	author amodra;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches;
next	1.1;

1.1
date	2002.05.30.02.14.13;	author thorpej;	state Exp;
branches;
next	;

1.71.4.1
date	2012.09.04.13.34.49;	author gingold;	state Exp;
branches;
next	;

1.64.2.1
date	2012.05.11.12.24.28;	author nickc;	state Exp;
branches;
next	;

1.18.6.1
date	2004.04.08.12.41.44;	author amodra;	state Exp;
branches;
next	;

1.18.8.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.18.8.2;

1.18.8.2
date	2004.04.02.16.47.35;	author drow;	state Exp;
branches;
next	1.18.8.3;

1.18.8.3
date	2004.09.16.17.00.28;	author drow;	state Exp;
branches;
next	1.18.8.4;

1.18.8.4
date	2004.09.21.20.44.02;	author drow;	state Exp;
branches;
next	;

1.8.2.1
date	2003.12.14.20.26.42;	author drow;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2004.01.13.16.11.37;	author drow;	state Exp;
branches;
next	;

1.6.10.1
date	2002.10.11.22.22.48;	author carlton;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2002.12.23.19.37.46;	author carlton;	state Exp;
branches;
next	1.6.10.3;

1.6.10.3
date	2003.03.06.00.56.16;	author carlton;	state Exp;
branches;
next	1.6.10.4;

1.6.10.4
date	2003.06.27.21.49.19;	author carlton;	state Exp;
branches;
next	1.6.10.5;

1.6.10.5
date	2003.09.17.21.27.53;	author carlton;	state Exp;
branches;
next	1.6.10.6;

1.6.10.6
date	2003.11.11.23.50.21;	author carlton;	state Exp;
branches;
next	1.6.10.7;

1.6.10.7
date	2003.12.15.23.59.33;	author carlton;	state Exp;
branches;
next	1.6.10.8;

1.6.10.8
date	2004.01.26.19.11.05;	author carlton;	state Exp;
branches;
next	;

1.5.2.1
date	2002.10.28.18.45.44;	author drow;	state Exp;
branches;
next	;

1.3.2.1
date	2002.06.15.16.42.37;	author cagney;	state Exp;
branches;
next	;

1.3.4.1
date	2002.06.20.01.30.24;	author kseitz;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.07.22.21.46.45;	author kseitz;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.08.09.18.34.15;	author kseitz;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.10.01.00.45.47;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.82
log
@	* elf32-vax.c (elf_vax_finish_dynamic_sections): Don't set GOT's
	entry size if there is no ELF section data.
@
text
@/* VAX series support for 32-bit ELF
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
   Contributed by Matt Thomas <matt@@3am-software.com>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/vax.h"

static reloc_howto_type *reloc_type_lookup (bfd *, bfd_reloc_code_real_type);
static void rtype_to_howto (bfd *, arelent *, Elf_Internal_Rela *);
static struct bfd_hash_entry *elf_vax_link_hash_newfunc (struct bfd_hash_entry *,
							 struct bfd_hash_table *,
							 const char *);
static struct bfd_link_hash_table *elf_vax_link_hash_table_create (bfd *);
static bfd_boolean elf_vax_check_relocs (bfd *, struct bfd_link_info *,
					 asection *, const Elf_Internal_Rela *);
static bfd_boolean elf_vax_adjust_dynamic_symbol (struct bfd_link_info *,
						  struct elf_link_hash_entry *);
static bfd_boolean elf_vax_size_dynamic_sections (bfd *, struct bfd_link_info *);
static bfd_boolean elf_vax_relocate_section (bfd *, struct bfd_link_info *,
					     bfd *, asection *, bfd_byte *,
					     Elf_Internal_Rela *,
					     Elf_Internal_Sym *, asection **);
static bfd_boolean elf_vax_finish_dynamic_symbol (bfd *, struct bfd_link_info *,
						  struct elf_link_hash_entry *,
						  Elf_Internal_Sym *);
static bfd_boolean elf_vax_finish_dynamic_sections (bfd *,
						    struct bfd_link_info *);
static bfd_vma elf_vax_plt_sym_val (bfd_vma, const asection *,
				    const arelent *);

static bfd_boolean elf32_vax_set_private_flags (bfd *, flagword);
static bfd_boolean elf32_vax_merge_private_bfd_data (bfd *, bfd *);
static bfd_boolean elf32_vax_print_private_bfd_data (bfd *, void *);

static reloc_howto_type howto_table[] = {
  HOWTO (R_VAX_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x00000000,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_VAX_32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_VAX_16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_VAX_8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000000ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_VAX_PC32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_PC32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_VAX_PC16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_PC16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x0000ffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_VAX_PC8,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_PC8",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x000000ff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  HOWTO (R_VAX_GOT32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_GOT32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),

  HOWTO (R_VAX_PLT32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_PLT32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),
  EMPTY_HOWTO (-1),

  HOWTO (R_VAX_COPY,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_COPY",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_VAX_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_VAX_JMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_JMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_VAX_RELATIVE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_VAX_RELATIVE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy */
  HOWTO (R_VAX_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_VAX_GNU_VTINHERIT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage */
  HOWTO (R_VAX_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 _bfd_elf_rel_vtable_reloc_fn, /* special_function */
	 "R_VAX_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

static void
rtype_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
		Elf_Internal_Rela *dst)
{
  BFD_ASSERT (ELF32_R_TYPE(dst->r_info) < (unsigned int) R_VAX_max);
  cache_ptr->howto = &howto_table[ELF32_R_TYPE(dst->r_info)];
}

#define elf_info_to_howto rtype_to_howto

static const struct
{
  bfd_reloc_code_real_type bfd_val;
  int elf_val;
} reloc_map[] = {
  { BFD_RELOC_NONE, R_VAX_NONE },
  { BFD_RELOC_32, R_VAX_32 },
  { BFD_RELOC_16, R_VAX_16 },
  { BFD_RELOC_8, R_VAX_8 },
  { BFD_RELOC_32_PCREL, R_VAX_PC32 },
  { BFD_RELOC_16_PCREL, R_VAX_PC16 },
  { BFD_RELOC_8_PCREL, R_VAX_PC8 },
  { BFD_RELOC_32_GOT_PCREL, R_VAX_GOT32 },
  { BFD_RELOC_32_PLT_PCREL, R_VAX_PLT32 },
  { BFD_RELOC_NONE, R_VAX_COPY },
  { BFD_RELOC_VAX_GLOB_DAT, R_VAX_GLOB_DAT },
  { BFD_RELOC_VAX_JMP_SLOT, R_VAX_JMP_SLOT },
  { BFD_RELOC_VAX_RELATIVE, R_VAX_RELATIVE },
  { BFD_RELOC_CTOR, R_VAX_32 },
  { BFD_RELOC_VTABLE_INHERIT, R_VAX_GNU_VTINHERIT },
  { BFD_RELOC_VTABLE_ENTRY, R_VAX_GNU_VTENTRY },
};

static reloc_howto_type *
reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED, bfd_reloc_code_real_type code)
{
  unsigned int i;
  for (i = 0; i < sizeof (reloc_map) / sizeof (reloc_map[0]); i++)
    {
      if (reloc_map[i].bfd_val == code)
	return &howto_table[reloc_map[i].elf_val];
    }
  return 0;
}

static reloc_howto_type *
reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
		   const char *r_name)
{
  unsigned int i;

  for (i = 0; i < sizeof (howto_table) / sizeof (howto_table[0]); i++)
    if (howto_table[i].name != NULL
	&& strcasecmp (howto_table[i].name, r_name) == 0)
      return &howto_table[i];

  return NULL;
}

#define bfd_elf32_bfd_reloc_type_lookup reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup reloc_name_lookup
#define ELF_ARCH bfd_arch_vax
/* end code generated by elf.el */

/* Functions for the VAX ELF linker.  */

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/usr/libexec/ld.elf_so"

/* The size in bytes of an entry in the procedure linkage table.  */

#define PLT_ENTRY_SIZE 12

/* The first entry in a procedure linkage table looks like this.  See
   the SVR4 ABI VAX supplement to see how this works.  */

static const bfd_byte elf_vax_plt0_entry[PLT_ENTRY_SIZE] =
{
  0xdd, 0xef,		/* pushl l^ */
  0, 0, 0, 0,		/* offset to .plt.got + 4 */
  0x17, 0xff,		/* jmp @@L^(pc) */
  0, 0, 0, 0,		/* offset to .plt.got + 8 */
};

/* Subsequent entries in a procedure linkage table look like this.  */

static const bfd_byte elf_vax_plt_entry[PLT_ENTRY_SIZE] =
{
  0xfc, 0x0f,		/* .word ^M<r11:r2> */
  0x16, 0xef,		/* jsb L^(pc) */
  0, 0, 0, 0,		/* replaced with offset to start of .plt  */
  0, 0, 0, 0,		/* index into .rela.plt */
};

/* The VAX linker needs to keep track of the number of relocs that it
   decides to copy in check_relocs for each symbol.  This is so that it
   can discard PC relative relocs if it doesn't need them when linking
   with -Bsymbolic.  We store the information in a field extending the
   regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we have
   copied for a given symbol.  */

struct elf_vax_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_vax_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
  bfd_size_type count;
};

/* VAX ELF linker hash entry.  */

struct elf_vax_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Number of PC relative relocs copied for this symbol.  */
  struct elf_vax_pcrel_relocs_copied *pcrel_relocs_copied;

  bfd_vma got_addend;
};

/* Declare this now that the above structures are defined.  */

static bfd_boolean elf_vax_discard_copies (struct elf_vax_link_hash_entry *,
					   void *);

/* Declare this now that the above structures are defined.  */

static bfd_boolean elf_vax_instantiate_got_entries (struct elf_link_hash_entry *,
						    void *);

/* Traverse an VAX ELF linker hash table.  */

#define elf_vax_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   ((table),								\
    (bfd_boolean (*) (struct elf_link_hash_entry *, void *)) (func),	\
    (info)))

/* Create an entry in an VAX ELF linker hash table.  */

static struct bfd_hash_entry *
elf_vax_link_hash_newfunc (struct bfd_hash_entry *entry,
			   struct bfd_hash_table *table,
			   const char *string)
{
  struct elf_vax_link_hash_entry *ret =
    (struct elf_vax_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = ((struct elf_vax_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf_vax_link_hash_entry)));
  if (ret == NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct elf_vax_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != NULL)
    {
      ret->pcrel_relocs_copied = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Create an VAX ELF linker hash table.  */

static struct bfd_link_hash_table *
elf_vax_link_hash_table_create (bfd *abfd)
{
  struct elf_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_link_hash_table);

  ret = bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (ret, abfd,
				      elf_vax_link_hash_newfunc,
				      sizeof (struct elf_vax_link_hash_entry),
				      GENERIC_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->root;
}

/* Keep vax-specific flags in the ELF header */
static bfd_boolean
elf32_vax_set_private_flags (bfd *abfd, flagword flags)
{
  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */
static bfd_boolean
elf32_vax_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword in_flags;

  if (   bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  in_flags  = elf_elfheader (ibfd)->e_flags;

  if (!elf_flags_init (obfd))
    {
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = in_flags;
    }

  return TRUE;
}

/* Display the flags field */
static bfd_boolean
elf32_vax_print_private_bfd_data (bfd *abfd, void * ptr)
{
  FILE *file = (FILE *) ptr;

  BFD_ASSERT (abfd != NULL && ptr != NULL);

  /* Print normal ELF private data.  */
  _bfd_elf_print_private_bfd_data (abfd, ptr);

  /* Ignore init flag - it may not be set, despite the flags field containing valid data.  */

  /* xgettext:c-format */
  fprintf (file, _("private flags = %lx:"), elf_elfheader (abfd)->e_flags);

  if (elf_elfheader (abfd)->e_flags & EF_VAX_NONPIC)
    fprintf (file, _(" [nonpic]"));

  if (elf_elfheader (abfd)->e_flags & EF_VAX_DFLOAT)
    fprintf (file, _(" [d-float]"));

  if (elf_elfheader (abfd)->e_flags & EF_VAX_GFLOAT)
    fprintf (file, _(" [g-float]"));

  fputc ('\n', file);

  return TRUE;
}
/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
elf_vax_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
		      const Elf_Internal_Rela *relocs)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sgot;
  asection *srelgot;
  asection *sreloc;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  sgot = NULL;
  srelgot = NULL;
  sreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_VAX_GOT32:
	  BFD_ASSERT (h != NULL);

	  /* If this is a local symbol, we resolve it directly without
	     creating a global offset table entry.  */
	  if (h->forced_local
	      || h == elf_hash_table (info)->hgot
	      || h == elf_hash_table (info)->hplt)
	    break;

	  /* This symbol requires a global offset table entry.  */

	  if (dynobj == NULL)
	    {
	      /* Create the .got section.  */
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (!_bfd_elf_create_got_section (dynobj, info))
		return FALSE;
	    }

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_linker_section (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_linker_section (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				    | SEC_IN_MEMORY | SEC_LINKER_CREATED
				    | SEC_READONLY);

		  srelgot = bfd_make_section_anyway_with_flags (dynobj,
								".rela.got",
								flags);
		  if (srelgot == NULL
		      || !bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

	  if (h != NULL)
	    {
	      struct elf_vax_link_hash_entry *eh;

	      eh = (struct elf_vax_link_hash_entry *) h;
	      if (h->got.refcount == -1)
		{
		  h->got.refcount = 1;
		  eh->got_addend = rel->r_addend;
		}
	      else
		{
		  h->got.refcount++;
		  if (eh->got_addend != (bfd_vma) rel->r_addend)
		    (*_bfd_error_handler)
		      (_("%s: warning: GOT addend of %ld to `%s' does"
			 " not match previous GOT addend of %ld"),
			 bfd_get_filename (abfd), rel->r_addend,
			 h->root.root.string,
			 eh->got_addend);

		}
	    }
	  break;

	case R_VAX_PLT32:
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code which is
             never referenced by a dynamic object, in which case we
             don't need to generate a procedure linkage table entry
             after all.  */
	  BFD_ASSERT (h != NULL);

	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */
	  if (h->forced_local)
	    break;

	  h->needs_plt = 1;
	  if (h->plt.refcount == -1)
	    h->plt.refcount = 1;
	  else
	    h->plt.refcount++;
	  break;

	case R_VAX_PC8:
	case R_VAX_PC16:
	case R_VAX_PC32:
	  /* If we are creating a shared library and this is not a local
	     symbol, we need to copy the reloc into the shared library.
	     However when linking with -Bsymbolic and this is a global
	     symbol which is defined in an object we are including in the
	     link (i.e., DEF_REGULAR is set), then we can resolve the
	     reloc directly.  At this point we have not seen all the input
	     files, so it is possible that DEF_REGULAR is not set now but
	     will be set later (it is never cleared).  We account for that
	     possibility below by storing information in the
	     pcrel_relocs_copied field of the hash table entry.  */
	  if (!(info->shared
		&& (sec->flags & SEC_ALLOC) != 0
		&& h != NULL
		&& (!info->symbolic
		    || !h->def_regular)))
	    {
	      if (h != NULL
		  && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		  && !h->forced_local)
		{
		  /* Make sure a plt entry is created for this symbol if
		     it turns out to be a function defined by a dynamic
		     object.  */
		  if (h->plt.refcount == -1)
		    h->plt.refcount = 1;
		  else
		    h->plt.refcount++;
		}
	      break;
	    }
	  /* If this is a local symbol, we can resolve it directly.  */
	  if (h != NULL
	      && (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		  || h->forced_local))
	    break;

	  /* Fall through.  */
	case R_VAX_8:
	case R_VAX_16:
	case R_VAX_32:
	  if (h != NULL && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    {
	      /* Make sure a plt entry is created for this symbol if it
		 turns out to be a function defined by a dynamic object.  */
	      if (h->plt.refcount == -1)
		h->plt.refcount = 1;
	      else
		h->plt.refcount++;
	    }

	  /* If we are creating a shared library, we need to copy the
	     reloc into the shared library.  */
	  if (info->shared
	      && (sec->flags & SEC_ALLOC) != 0)
	    {
	      /* When creating a shared object, we must copy these
		 reloc types into the output file.  We create a reloc
		 section in dynobj and make room for this reloc.  */
	      if (sreloc == NULL)
		{
		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, dynobj, 2, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;

		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
		}

	      sreloc->size += sizeof (Elf32_External_Rela);

	      /* If we are linking with -Bsymbolic, we count the number of
		 PC relative relocations we have entered for this symbol,
		 so that we can discard them again if the symbol is later
		 defined by a regular object.  Note that this function is
		 only called if we are using a vaxelf linker hash table,
		 which means that h is really a pointer to an
		 elf_vax_link_hash_entry.  */
	      if ((ELF32_R_TYPE (rel->r_info) == R_VAX_PC8
		   || ELF32_R_TYPE (rel->r_info) == R_VAX_PC16
		   || ELF32_R_TYPE (rel->r_info) == R_VAX_PC32)
		  && info->symbolic)
		{
		  struct elf_vax_link_hash_entry *eh;
		  struct elf_vax_pcrel_relocs_copied *p;

		  eh = (struct elf_vax_link_hash_entry *) h;

		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		    if (p->section == sreloc)
		      break;

		  if (p == NULL)
		    {
		      p = ((struct elf_vax_pcrel_relocs_copied *)
			   bfd_alloc (dynobj, (bfd_size_type) sizeof *p));
		      if (p == NULL)
			return FALSE;
		      p->next = eh->pcrel_relocs_copied;
		      eh->pcrel_relocs_copied = p;
		      p->section = sreloc;
		      p->count = 0;
		    }

		  ++p->count;
		}
	    }

	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_VAX_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_VAX_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
elf_vax_gc_mark_hook (asection *sec,
		      struct bfd_link_info *info,
		      Elf_Internal_Rela *rel,
		      struct elf_link_hash_entry *h,
		      Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_VAX_GNU_VTINHERIT:
      case R_VAX_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf_vax_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info, asection *sec,
		       const Elf_Internal_Rela *relocs)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel, *relend;
  bfd *dynobj;

  if (info->relocatable)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}

      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_VAX_GOT32:
	  if (h != NULL && h->got.refcount > 0)
	    --h->got.refcount;
	  break;

	case R_VAX_PLT32:
	case R_VAX_PC8:
	case R_VAX_PC16:
	case R_VAX_PC32:
	case R_VAX_8:
	case R_VAX_16:
	case R_VAX_32:
	  if (h != NULL && h->plt.refcount > 0)
	    --h->plt.refcount;
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf_vax_adjust_dynamic_symbol (struct bfd_link_info *info,
			       struct elf_link_hash_entry *h)
{
  bfd *dynobj;
  asection *s;

  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || h->needs_plt)
    {
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
	{
	  /* This case can occur if we saw a PLTxx reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PCxx reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	  return TRUE;
	}

      s = bfd_get_linker_section (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->size == 0)
	{
	  s->size += PLT_ENTRY_SIZE;
	}

      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (!info->shared
	  && !h->def_regular)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->size;
	}

      h->plt.offset = s->size;

      /* Make room for this entry.  */
      s->size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */

      s = bfd_get_linker_section (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->size += 4;

      /* We also need to make an entry in the .rela.plt section.  */

      s = bfd_get_linker_section (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->size += sizeof (Elf32_External_Rela);

      return TRUE;
    }

  /* Reinitialize the plt offset now that it is not used as a reference
     count any more.  */
  h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  s = bfd_get_linker_section (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);

  /* We must generate a R_VAX_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      asection *srel;

      srel = bfd_get_linker_section (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* This function is called via elf_link_hash_traverse.  It resets GOT
   and PLT (.GOT) reference counts back to -1 so normal PC32 relocation
   will be done.  */

static bfd_boolean
elf_vax_discard_got_entries (struct elf_link_hash_entry *h,
			     void *infoptr ATTRIBUTE_UNUSED)
{
  h->got.refcount = -1;
  h->plt.refcount = -1;

  return TRUE;
}

/* Discard unused dynamic data if this is a static link.  */

static bfd_boolean
elf_vax_always_size_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			      struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;

  dynobj = elf_hash_table (info)->dynobj;

  if (dynobj && !elf_hash_table (info)->dynamic_sections_created)
    {
      /* We may have created entries in the .rela.got and .got sections.
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.got
	 and .got, which will cause them to get stripped from the output
	 file below.  */
      s = bfd_get_linker_section (dynobj, ".rela.got");
      if (s != NULL)
	s->size = 0;
      s = bfd_get_linker_section (dynobj, ".got.plt");
      if (s != NULL)
	s->size = 0;
      s = bfd_get_linker_section (dynobj, ".got");
      if (s != NULL)
	s->size = 0;
    }

  /* If this is a static link, we need to discard all the got entries we've
     recorded.  */
  if (!dynobj || !elf_hash_table (info)->dynamic_sections_created)
    elf_link_hash_traverse (elf_hash_table (info),
			    elf_vax_discard_got_entries,
			    info);

  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf_vax_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *s;
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* If this is a -Bsymbolic shared link, then we need to discard all PC
     relative relocs against symbols defined in a regular object.  We
     allocated space for them in the check_relocs routine, but we will not
     fill them in in the relocate_section routine.  */
  if (info->shared && info->symbolic)
    elf_vax_link_hash_traverse (elf_hash_table (info),
				elf_vax_discard_copies,
				NULL);

  /* If this is a -Bsymbolic shared link, we need to discard all the got
     entries we've recorded.  Otherwise, we need to instantiate (allocate
     space for them).  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_vax_instantiate_got_entries,
			  info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      if (strcmp (name, ".plt") == 0)
	{
	  /* Remember whether there is a PLT.  */
	  plt = s->size != 0;
	}
      else if (CONST_STRNEQ (name, ".rela"))
	{
	  if (s->size != 0)
	    {
	      asection *target;

	      /* Remember whether there are any reloc sections other
                 than .rela.plt.  */
	      if (strcmp (name, ".rela.plt") != 0)
		{
		  const char *outname;

		  relocs = TRUE;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  .rela.plt is actually associated with
		     .got.plt, which is never readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 5);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = TRUE;
		}

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else if (! CONST_STRNEQ (name, ".got")
	       && strcmp (name, ".dynbss") != 0)
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_vax_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (!info->shared)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (plt)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;
	}

      if (reltext || (info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* This function is called via elf_vax_link_hash_traverse if we are
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are defined
   in regular objects.  We allocated space for them in the check_relocs
   routine, but we won't fill them in in the relocate_section routine.  */

static bfd_boolean
elf_vax_discard_copies (struct elf_vax_link_hash_entry *h,
			void * ignore ATTRIBUTE_UNUSED)
{
  struct elf_vax_pcrel_relocs_copied *s;

  /* We only discard relocs for symbols defined in a regular object.  */
  if (!h->root.def_regular)
    return TRUE;

  for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
    s->section->size -= s->count * sizeof (Elf32_External_Rela);

  return TRUE;
}

/* This function is called via elf_link_hash_traverse.  It looks for
   entries that have GOT or PLT (.GOT) references.  If creating a shared
   object with -Bsymbolic, or the symbol has been forced local, then it
   resets the reference count back to -1 so normal PC32 relocation will
   be done.  Otherwise space in the .got and .rela.got will be reserved
   for the symbol.  */

static bfd_boolean
elf_vax_instantiate_got_entries (struct elf_link_hash_entry *h, void * infoptr)
{
  struct bfd_link_info *info = (struct bfd_link_info *) infoptr;
  bfd *dynobj;
  asection *sgot;
  asection *srelgot;

  /* We don't care about non-GOT (and non-PLT) entries.  */
  if (h->got.refcount <= 0 && h->plt.refcount <= 0)
    return TRUE;

  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);

  sgot = bfd_get_linker_section (dynobj, ".got");
  srelgot = bfd_get_linker_section (dynobj, ".rela.got");

  if (SYMBOL_REFERENCES_LOCAL (info, h))
    {
      h->got.refcount = -1;
      h->plt.refcount = -1;
    }
  else if (h->got.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (!bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      /* Allocate space in the .got and .rela.got sections.  */
      sgot->size += 4;
      srelgot->size += sizeof (Elf32_External_Rela);
    }

  return TRUE;
}

/* Relocate an VAX ELF section.  */

static bfd_boolean
elf_vax_relocate_section (bfd *output_bfd,
			  struct bfd_link_info *info,
			  bfd *input_bfd,
			  asection *input_section,
			  bfd_byte *contents,
			  Elf_Internal_Rela *relocs,
			  Elf_Internal_Sym *local_syms,
			  asection **local_sections)
{
  bfd *dynobj;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma plt_index;
  bfd_vma got_offset;
  asection *sgot;
  asection *splt;
  asection *sgotplt;
  asection *sreloc;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  dynobj = elf_hash_table (info)->dynobj;
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);

  sgot = NULL;
  splt = NULL;
  sgotplt = NULL;
  sreloc = NULL;

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma relocation;
      bfd_reloc_status_type r;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type < 0 || r_type >= (int) R_VAX_max)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
      howto = howto_table + r_type;

      r_symndx = ELF32_R_SYM (rel->r_info);
      h = NULL;
      sym = NULL;
      sec = NULL;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean unresolved_reloc;
	  bfd_boolean warned;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);

	  if ((h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	      && ((r_type == R_VAX_PLT32
		   && h->plt.offset != (bfd_vma) -1
		   && !h->forced_local
		   && elf_hash_table (info)->dynamic_sections_created)
		  || (r_type == R_VAX_GOT32
		      && h->got.offset != (bfd_vma) -1
		      && !h->forced_local
		      && elf_hash_table (info)->dynamic_sections_created
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || !h->def_regular))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || !h->def_regular)
		      && ((input_section->flags & SEC_ALLOC) != 0
			  /* DWARF will emit R_VAX_32 relocations in its
			     sections against symbols defined externally
			     in shared libraries.  We can't do anything
			     with them here.  */

			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && h->def_dynamic))
		      && (r_type == R_VAX_8
			  || r_type == R_VAX_16
			  || r_type == R_VAX_32))))
	    /* In these cases, we don't need the relocation
	       value.  We check specially because in some
	       obscure cases sec->output_section will be NULL.  */
	    relocation = 0;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      switch (r_type)
	{
	case R_VAX_GOT32:
	  /* Relocation is to the address of the entry for this symbol
	     in the global offset table.  */

	  /* Resolve a GOTxx reloc against a local symbol directly,
	     without using the global offset table.  */
	  if (h == NULL
	      || h->got.offset == (bfd_vma) -1)
	    break;

	  {
	    bfd_vma off;

	    if (sgot == NULL)
	      {
		sgot = bfd_get_linker_section (dynobj, ".got");
		BFD_ASSERT (sgot != NULL);
	      }

	    off = h->got.offset;
	    BFD_ASSERT (off < sgot->size);

	    bfd_put_32 (output_bfd, rel->r_addend, sgot->contents + off);

	    relocation = sgot->output_offset + off;
	    /* The GOT relocation uses the addend.  */
	    rel->r_addend = 0;

	    /* Change the reference to be indirect.  */
	    contents[rel->r_offset - 1] |= 0x10;
	    relocation += sgot->output_section->vma;
	  }
	  break;

	case R_VAX_PC32:
	  /* If we are creating an executable and the function this
	     reloc refers to is in a shared lib, then we made a PLT
	     entry for this symbol and need to handle the reloc like
	     a PLT reloc.  */
	  if (info->shared)
	     goto r_vax_pc32_shared;
	  /* Fall through.  */
	case R_VAX_PLT32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLTxx reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL
	      || h->plt.offset == (bfd_vma) -1)
	    break;

	  if (splt == NULL)
	    {
	      splt = bfd_get_linker_section (dynobj, ".plt");
	      BFD_ASSERT (splt != NULL);
	    }

	  if (sgotplt == NULL)
	    {
	      sgotplt = bfd_get_linker_section (dynobj, ".got.plt");
	      BFD_ASSERT (sgotplt != NULL);
	    }

	  plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;

	  /* Get the offset into the .got table of the entry that
	     corresponds to this function.  Each .got entry is 4 bytes.
	     The first two are reserved.  */
	  got_offset = (plt_index + 3) * 4;

	  /* We want the relocation to point into the .got.plt instead
	     of the plt itself.  */
	  relocation = (sgotplt->output_section->vma
			+ sgotplt->output_offset
			+ got_offset);
	  contents[rel->r_offset-1] |= 0x10; /* make indirect */
	  if (rel->r_addend == 2)
	    {
	      h->plt.offset |= 1;
	    }
	  else if (rel->r_addend != 0)
	    (*_bfd_error_handler)
	      (_("%s: warning: PLT addend of %d to `%s' from %s section ignored"),
		      bfd_get_filename (input_bfd), rel->r_addend,
		      h->root.root.string,
		      bfd_get_section_name (input_bfd, input_section));
	  rel->r_addend = 0;

	  break;

	case R_VAX_PC8:
	case R_VAX_PC16:
	r_vax_pc32_shared:
	  if (h == NULL
	      || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      || h->forced_local)
	    break;
	  /* Fall through.  */
	case R_VAX_8:
	case R_VAX_16:
	case R_VAX_32:
	  if (info->shared
	      && r_symndx != STN_UNDEF
	      && (input_section->flags & SEC_ALLOC) != 0
	      && ((r_type != R_VAX_PC8
		   && r_type != R_VAX_PC16
		   && r_type != R_VAX_PC32)
		  || ((input_section->flags & SEC_CODE)
		      && (!info->symbolic
			  || (!h->def_regular && h->type != STT_SECTION)))))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */
	      if (sreloc == NULL)
		{
		  sreloc = _bfd_elf_get_dynamic_reloc_section
		    (input_bfd, input_section, /*rela?*/ TRUE);
		  if (sreloc == NULL)
		    return FALSE;
		}

	      skip = FALSE;
	      relocate = FALSE;

	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		skip = TRUE;
	      if (outrel.r_offset == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		  memset (&outrel, 0, sizeof outrel);
	      /* h->dynindx may be -1 if the symbol was marked to
                 become local.  */
	      else if (h != NULL
		       && ((! info->symbolic && h->dynindx != -1)
			   || !h->def_regular))
		{
		  BFD_ASSERT (h->dynindx != -1);
		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
		  outrel.r_addend = relocation + rel->r_addend;
		}
	      else
		{
		  if (r_type == R_VAX_32)
		    {
		      relocate = TRUE;
		      outrel.r_info = ELF32_R_INFO (0, R_VAX_RELATIVE);
		      BFD_ASSERT (bfd_get_signed_32 (input_bfd,
						     &contents[rel->r_offset]) == 0);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
		  else
		    {
		      long indx;

		      if (bfd_is_abs_section (sec))
			indx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  /* We are turning this relocation into one
			     against a section symbol.  It would be
			     proper to subtract the symbol's value,
			     osec->vma, from the emitted reloc addend,
			     but ld.so expects buggy relocs.  */
			  osec = sec->output_section;
			  indx = elf_section_data (osec)->dynindx;
			  if (indx == 0)
			    {
			      struct elf_link_hash_table *htab;
			      htab = elf_hash_table (info);
			      osec = htab->text_index_section;
			      indx = elf_section_data (osec)->dynindx;
			    }
			  BFD_ASSERT (indx != 0);
			}

		      outrel.r_info = ELF32_R_INFO (indx, r_type);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
		}

	      if ((input_section->flags & SEC_CODE) != 0
		  || (ELF32_R_TYPE (outrel.r_info) != R_VAX_32
		      && ELF32_R_TYPE (outrel.r_info) != R_VAX_RELATIVE
		      && ELF32_R_TYPE (outrel.r_info) != R_VAX_COPY
		      && ELF32_R_TYPE (outrel.r_info) != R_VAX_JMP_SLOT
		      && ELF32_R_TYPE (outrel.r_info) != R_VAX_GLOB_DAT))
		{
		  if (h != NULL)
		    (*_bfd_error_handler)
		      (_("%s: warning: %s relocation against symbol `%s' from %s section"),
		      bfd_get_filename (input_bfd), howto->name,
		      h->root.root.string,
		      bfd_get_section_name (input_bfd, input_section));
		  else
		    (*_bfd_error_handler)
		      (_("%s: warning: %s relocation to 0x%x from %s section"),
		      bfd_get_filename (input_bfd), howto->name,
		      outrel.r_addend,
		      bfd_get_section_name (input_bfd, input_section));
		}
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      /* This reloc will be computed at runtime, so there's no
                 need to do anything now, except for R_VAX_32
                 relocations that have been turned into
                 R_VAX_RELATIVE.  */
	      if (!relocate)
		continue;
	    }

	  break;

	case R_VAX_GNU_VTINHERIT:
	case R_VAX_GNU_VTENTRY:
	  /* These are no-ops in the end.  */
	  continue;

	default:
	  break;
	}

      /* VAX PCREL relocations are from the end of relocation, not the start.
         So subtract the difference from the relocation amount since we can't
         add it to the offset.  */
      if (howto->pc_relative && howto->pcrel_offset)
	relocation -= bfd_get_reloc_size(howto);

      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  switch (r)
	    {
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = NULL;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return FALSE;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (!(info->callbacks->reloc_overflow
		      (info, (h ? &h->root : NULL), name, howto->name,
		       (bfd_vma) 0, input_bfd, input_section,
		       rel->r_offset)))
		  return FALSE;
	      }
	      break;
	    }
	}
    }

  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf_vax_finish_dynamic_symbol (bfd *output_bfd, struct bfd_link_info *info,
			       struct elf_link_hash_entry *h,
			       Elf_Internal_Sym *sym)
{
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

  if (h->plt.offset != (bfd_vma) -1)
    {
      asection *splt;
      asection *sgot;
      asection *srela;
      bfd_vma plt_index;
      bfd_vma got_offset;
      bfd_vma addend;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */
      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_linker_section (dynobj, ".plt");
      sgot = bfd_get_linker_section (dynobj, ".got.plt");
      srela = bfd_get_linker_section (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);

      addend = 2 * (h->plt.offset & 1);
      h->plt.offset &= ~1;

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.  */
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;

      /* Get the offset into the .got table of the entry that
	 corresponds to this function.  Each .got entry is 4 bytes.
	 The first two are reserved.  */
      got_offset = (plt_index + 3) * 4;

      /* Fill in the entry in the procedure linkage table.  */
      memcpy (splt->contents + h->plt.offset, elf_vax_plt_entry,
	          PLT_ENTRY_SIZE);

      /* The offset is relative to the first extension word.  */
      bfd_put_32 (output_bfd,
		  -(h->plt.offset + 8),
		  splt->contents + h->plt.offset + 4);

      bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rela),
		  splt->contents + h->plt.offset + 8);

      /* Fill in the entry in the global offset table.  */
      bfd_put_32 (output_bfd,
		  (splt->output_section->vma
		   + splt->output_offset
		   + h->plt.offset) + addend,
		  sgot->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + got_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_VAX_JMP_SLOT);
      rela.r_addend = addend;
      loc = srela->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	}
    }

  if (h->got.offset != (bfd_vma) -1)
    {
      asection *sgot;
      asection *srela;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */
      sgot = bfd_get_linker_section (dynobj, ".got");
      srela = bfd_get_linker_section (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srela != NULL);

      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + h->got.offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_VAX_GLOB_DAT);
      rela.r_addend = bfd_get_signed_32 (output_bfd,
					 sgot->contents + h->got.offset);

      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

  if (h->needs_copy)
    {
      asection *s;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol needs a copy reloc.  Set it up.  */
      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_linker_section (dynobj, ".rela.bss");
      BFD_ASSERT (s != NULL);

      rela.r_offset = (h->root.u.def.value
		       + h->root.u.def.section->output_section->vma
		       + h->root.u.def.section->output_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_VAX_COPY);
      rela.r_addend = 0;
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (h == elf_hash_table (info)->hdynamic
      || h == elf_hash_table (info)->hgot)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf_vax_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
{
  bfd *dynobj;
  asection *sgot;
  asection *sdyn;

  dynobj = elf_hash_table (info)->dynobj;

  sgot = bfd_get_linker_section (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      asection *splt;
      Elf32_External_Dyn *dyncon, *dynconend;

      splt = bfd_get_linker_section (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  const char *name;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      break;

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
	    case DT_JMPREL:
	      name = ".rela.plt";
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_PLTRELSZ:
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val = s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;

	    case DT_RELASZ:
	      /* The procedure linkage table relocs (DT_JMPREL) should
		 not be included in the overall relocs (DT_RELA).
		 Therefore, we override the DT_RELASZ entry here to
		 make it not include the JMPREL relocs.  Since the
		 linker script arranges for .rela.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_RELA entry.  */
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s != NULL)
		dyn.d_un.d_val -= s->size;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	      break;
	    }
	}

      /* Fill in the first entry in the procedure linkage table.  */
      if (splt->size > 0)
	{
	  memcpy (splt->contents, elf_vax_plt0_entry, PLT_ENTRY_SIZE);
	  bfd_put_32 (output_bfd,
		          (sgot->output_section->vma
		           + sgot->output_offset + 4
		           - (splt->output_section->vma + 6)),
		          splt->contents + 2);
	  bfd_put_32 (output_bfd,
		          (sgot->output_section->vma
		           + sgot->output_offset + 8
		           - (splt->output_section->vma + 12)),
		          splt->contents + 8);
          elf_section_data (splt->output_section)->this_hdr.sh_entsize
           = PLT_ENTRY_SIZE;
	}
    }

  /* Fill in the first three entries in the global offset table.  */
  if (sgot->size > 0)
    {
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
    }

  if (elf_section_data (sgot->output_section) != NULL)
    elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;

  return TRUE;
}

static enum elf_reloc_type_class
elf_vax_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			  const asection *rel_sec ATTRIBUTE_UNUSED,
			  const Elf_Internal_Rela *rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_VAX_RELATIVE:
      return reloc_class_relative;
    case R_VAX_JMP_SLOT:
      return reloc_class_plt;
    case R_VAX_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

static bfd_vma
elf_vax_plt_sym_val (bfd_vma i, const asection *plt,
		     const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + (i + 1) * PLT_ENTRY_SIZE;
}

#define TARGET_LITTLE_SYM		bfd_elf32_vax_vec
#define TARGET_LITTLE_NAME		"elf32-vax"
#define ELF_MACHINE_CODE		EM_VAX
#define ELF_MAXPAGESIZE			0x1000

#define elf_backend_create_dynamic_sections \
					_bfd_elf_create_dynamic_sections
#define bfd_elf32_bfd_link_hash_table_create \
					elf_vax_link_hash_table_create
#define bfd_elf32_bfd_final_link	bfd_elf_gc_common_final_link

#define elf_backend_check_relocs	elf_vax_check_relocs
#define elf_backend_adjust_dynamic_symbol \
					elf_vax_adjust_dynamic_symbol
#define elf_backend_always_size_sections \
					elf_vax_always_size_sections
#define elf_backend_size_dynamic_sections \
					elf_vax_size_dynamic_sections
#define elf_backend_init_index_section	_bfd_elf_init_1_index_section
#define elf_backend_relocate_section	elf_vax_relocate_section
#define elf_backend_finish_dynamic_symbol \
					elf_vax_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections \
					elf_vax_finish_dynamic_sections
#define elf_backend_reloc_type_class	elf_vax_reloc_type_class
#define elf_backend_gc_mark_hook	elf_vax_gc_mark_hook
#define elf_backend_gc_sweep_hook	elf_vax_gc_sweep_hook
#define elf_backend_plt_sym_val		elf_vax_plt_sym_val
#define bfd_elf32_bfd_merge_private_bfd_data \
                                        elf32_vax_merge_private_bfd_data
#define bfd_elf32_bfd_set_private_flags \
                                        elf32_vax_set_private_flags
#define bfd_elf32_bfd_print_private_bfd_data \
                                        elf32_vax_print_private_bfd_data

#define elf_backend_can_gc_sections	1
#define elf_backend_want_got_plt	1
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_got_header_size	16
#define elf_backend_rela_normal		1

#include "elf32-target.h"
@


1.81
log
@	bfd/
	* elf32-vax.c (elf_vax_check_relocs) <R_VAX_GOT32, R_VAX_PLT32>:
	Don't check symbol visibility here.  Remove a check already
	asserted for.
	(elf_vax_instantiate_got_entries): Use SYMBOL_REFERENCES_LOCAL
	instead of individual checks.
	(elf_vax_relocate_section) <R_VAX_GOT32, R_VAX_PLT32>: Only
	check the offset to decide if produce a GOT or PLT entry.
	Remove redundant assertions.  Remove code to produce GOT entries
	for local symbols.  Remove a duplicate comment and add a comment
	on GOT relocations.
	(elf_vax_finish_dynamic_symbol): Remove code to produce RELATIVE
	dynamic relocs.

	ld/testsuite/
	* ld-vax-elf/got-local-exe.xd: New test.
	* ld-vax-elf/got-local-lib.xd: New test.
	* ld-vax-elf/got-local-aux.s: New test source.
	* ld-vax-elf/got-local-def.s: New test source.
	* ld-vax-elf/got-local-ref.s: New test source.
	* ld-vax-elf/vax-elf.exp: Run the new tests.
@
text
@d1992 2
a1993 1
  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
@


1.80
log
@	* elf32-vax.c (elf_vax_always_size_sections): Correct a comment
	typo.
@
text
@d598 3
a605 5
	  /* If this is a local symbol, we resolve it directly without
	     creating a global offset table entry.  */
	  if (h == NULL || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    break;

d673 1
d677 1
a677 2
	  BFD_ASSERT (h != NULL);
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT || h->forced_local)
d1322 1
a1322 2
  if ((info->shared && info->symbolic)
      || h->forced_local)
a1328 2
      bfd_boolean dyn;

a1335 1
      dyn = elf_hash_table (info)->dynamic_sections_created;
d1337 2
a1338 7
      if (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  && (info->shared
	      || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	{
	  sgot->size += 4;
	  srelgot->size += sizeof (Elf32_External_Rela);
	}
d1463 3
d1467 1
a1467 3
	      || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      || h->got.offset == (bfd_vma) -1
	      || h->forced_local)
a1469 3
	  /* Relocation is the offset of the entry for this symbol in
	     the global offset table.  */

a1470 1
	    bfd_boolean dyn;
a1478 1
	    BFD_ASSERT (h != NULL);
a1479 1
	    BFD_ASSERT (off != (bfd_vma) -1);
d1482 1
a1482 26
	    dyn = elf_hash_table (info)->dynamic_sections_created;
	    if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		|| (info->shared
		    && SYMBOL_REFERENCES_LOCAL (info, h)))
	      {
		/* The symbol was forced to be local
		   because of a version file..  We must initialize
		   this entry in the global offset table.  Since
		   the offset must always be a multiple of 4, we
		   use the least significant bit to record whether
		   we have initialized it already.

		   When doing a dynamic link, we create a .rela.got
		   relocation entry to initialize the value.  This
		   is done in the finish_dynamic_symbol routine.  */
		if ((off & 1) != 0)
		  off &= ~1;
		else
		  {
		    bfd_put_32 (output_bfd, relocation + rel->r_addend,
				sgot->contents + off);
		    h->got.offset |= 1;
		  }
	      } else {
		bfd_put_32 (output_bfd, rel->r_addend, sgot->contents + off);
	      }
d1509 1
a1509 2
	      || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      || h->forced_local)
a1511 9
	  if (h->plt.offset == (bfd_vma) -1
	      || !elf_hash_table (info)->dynamic_sections_created)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }

d1846 2
a1847 16
		       + (h->got.offset &~ 1));

      /* If the symbol was forced to be local because of a version file
	 locally we just want to emit a RELATIVE reloc.  The entry in
	 the global offset table will already have been initialized in
	 the relocate_section function.  */
      if (info->shared
	  && h->dynindx == -1
	  && h->def_regular)
	{
	  rela.r_info = ELF32_R_INFO (0, R_VAX_RELATIVE);
	}
      else
	{
	  rela.r_info = ELF32_R_INFO (h->dynindx, R_VAX_GLOB_DAT);
	}
d1849 1
a1849 2
					 (sgot->contents
					  + (h->got.offset & ~1)));
@


1.79
log
@	* elf32-vax.c (elf_vax_discard_got_entries): New function.
	(elf_vax_always_size_sections): Likewise.
	(elf_vax_size_dynamic_sections): Remove code moved to
	elf_vax_always_size_sections.  Make comment on
	elf_vax_instantiate_got_entries match reality.
	(elf_vax_instantiate_got_entries): Assert that rather than check
	if dynobj is null.  Don't check for dynamic_sections_created.
	Make function description match reality.
	(elf_backend_always_size_sections): New macro.
@
text
@d1083 1
a1083 1
	 and .got, which will cause it to get stripped from the output
@


1.78
log
@	* elf32-vax.c (elf_vax_instantiate_got_entries): Only set the
	refcount member of the gotplt_union when resetting the reference
	count.  Adjust comment.
@
text
@d1053 53
a1130 17
  else
    {
      /* We may have created entries in the .rela.got and .got sections.
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.got
	 and .got, which will cause it to get stripped from the output
	 file below.  */
      s = bfd_get_linker_section (dynobj, ".rela.got");
      if (s != NULL)
	s->size = 0;
      s = bfd_get_linker_section (dynobj, ".got.plt");
      if (s != NULL)
	s->size = 0;
      s = bfd_get_linker_section (dynobj, ".got");
      if (s != NULL)
	s->size = 0;
    }
d1141 3
a1143 3
  /* If this is a -Bsymbolic shared link or a static link, we need to
     discard all the got entries we've recorded.  Otherwise, we need to
     instantiate (allocate space for them).  */
d1299 6
a1304 6
/* This function is called via elf_link_hash_traverse.  It looks for entries
   that have GOT or PLT (.GOT) references.  If creating a static object or a
   shared object with -Bsymbolic, or the symbol has been forced local, then
   it resets the reference count back to -1 so normal PC32 relocation will
   be done.  Otherwise space in the .got and .rela.got will be reserved for
   the symbol.  */
d1319 1
a1319 2
  if (dynobj == NULL)
    return TRUE;
d1324 1
a1324 2
  if (!elf_hash_table (info)->dynamic_sections_created
      || (info->shared && info->symbolic)
d2102 2
@


1.77
log
@	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Convert K&R
	function definition.
@
text
@d1265 4
a1268 4
   shared object with -Bsymbolic, it resets the reference count back to 0
   and sets the offset to -1 so normal PC32 relocation will be done.  If
   creating a shared object or executable, space in the .got and .rela.got
   will be reserved for the symbol.  */
d1293 2
a1294 4
      h->got.refcount = 0;
      h->got.offset = (bfd_vma) -1;
      h->plt.refcount = 0;
      h->plt.offset = (bfd_vma) -1;
@


1.76
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d917 2
a918 3
elf_vax_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
@


1.75
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d588 4
@


1.74
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d2029 3
a2031 1
elf_vax_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.73
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d468 1
a468 1
  ret = bfd_malloc (amt);
@


1.72
log
@	bfd/
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Don't allocate
	PLT slots for local symbols.

	ld/testsuite/
	* ld-vax-elf: New directory.
	* ld-vax-elf/plt-local-lib.dd: New test.
	* ld-vax-elf/plt-local-lib.ld: New test linker script.
	* ld-vax-elf/plt-local-lib.s: New test source.
	* ld-vax-elf/plt-local.dd: New test.
	* ld-vax-elf/plt-local.ld: New test linker script.
	* ld-vax-elf/plt-local.s: New test source.
	* ld-vax-elf/plt-local-hidden-pic.s: New test source.
	* ld-vax-elf/plt-local-rehidden-pic.s: New test source.
	* ld-vax-elf/vax-elf.exp: New test script.
@
text
@d1911 1
a1911 1
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
@


1.71
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d936 4
a939 7
      if (! info->shared
	  && !h->def_dynamic
	  && !h->ref_dynamic
	  /* We must always create the plt entry if it was referenced
	     by a PLTxxO relocation.  In this case we already recorded
	     it as a dynamic symbol.  */
	  && h->dynindx == -1)
d943 3
a945 4
	     object.  In such a case, we don't actually need to build
	     a procedure linkage table, and we can just do a PCxx
	     reloc instead.  */
	  BFD_ASSERT (h->needs_plt);
a946 6
	  return TRUE;
	}

      /* GC may have rendered this entry unused.  */
      if (h->plt.refcount <= 0)
	{
a947 1
	  h->plt.offset = (bfd_vma) -1;
a950 7
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

@


1.71.4.1
log
@bfd/
2012-08-05  Maciej W. Rozycki  <macro@@linux-mips.org>

	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Don't allocate
	PLT slots for local symbols.

ld/
2012-08-05  Maciej W. Rozycki  <macro@@linux-mips.org>

	* ld-vax-elf: New directory.
	* ld-vax-elf/plt-local-lib.dd: New test.
	* ld-vax-elf/plt-local-lib.ld: New test linker script.
	* ld-vax-elf/plt-local-lib.s: New test source.
	* ld-vax-elf/plt-local.dd: New test.
	* ld-vax-elf/plt-local.ld: New test linker script.
	* ld-vax-elf/plt-local.s: New test source.
	* ld-vax-elf/plt-local-hidden-pic.s: New test source.
	* ld-vax-elf/plt-local-rehidden-pic.s: New test source.
	* ld-vax-elf/vax-elf.exp: New test script.
@
text
@d936 7
a942 4
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d946 4
a949 3
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PCxx reloc instead.  */
d951 6
d958 1
d962 7
@


1.70
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d56 1
a56 1
static bfd_boolean elf32_vax_print_private_bfd_data (bfd *, PTR);
d426 1
a426 1
    (bfd_boolean (*) (struct elf_link_hash_entry *, PTR)) (func),	\
d517 1
a517 1
elf32_vax_print_private_bfd_data (bfd *abfd, PTR ptr)
d1125 1
a1125 1
			  (PTR) info);
d1264 1
a1264 1
			PTR ignore ATTRIBUTE_UNUSED)
d1286 1
a1286 1
elf_vax_instantiate_got_entries (struct elf_link_hash_entry *h, PTR infoptr)
@


1.69
log
@	* elf32-vax.c (elf_vax_relocate_section)
	<R_VAX_8, R_VAX_16, R_VAX_32>: Don't check if info->shared again.
@
text
@d616 1
a616 1
	      sgot = bfd_get_section_by_name (dynobj, ".got");
d623 1
a623 1
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d626 7
a632 8
		  srelgot = bfd_make_section_with_flags (dynobj,
							 ".rela.got",
							 (SEC_ALLOC
							  | SEC_LOAD
							  | SEC_HAS_CONTENTS
							  | SEC_IN_MEMORY
							  | SEC_LINKER_CREATED
							  | SEC_READONLY));
d969 1
a969 1
      s = bfd_get_section_by_name (dynobj, ".plt");
d999 1
a999 1
      s = bfd_get_section_by_name (dynobj, ".got.plt");
d1005 1
a1005 1
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
d1048 1
a1048 1
  s = bfd_get_section_by_name (dynobj, ".dynbss");
d1059 1
a1059 1
      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
d1087 1
a1087 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d1100 1
a1100 1
      s = bfd_get_section_by_name (dynobj, ".rela.got");
d1103 1
a1103 1
      s = bfd_get_section_by_name (dynobj, ".got.plt");
d1106 1
a1106 1
      s = bfd_get_section_by_name (dynobj, ".got");
d1301 2
a1302 2
  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d1472 1
a1472 1
		sgot = bfd_get_section_by_name (dynobj, ".got");
d1548 1
a1548 1
	      splt = bfd_get_section_by_name (dynobj, ".plt");
d1554 1
a1554 1
	      sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
d1810 3
a1812 3
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srela = bfd_get_section_by_name (dynobj, ".rela.plt");
d1874 2
a1875 2
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
d1916 1
a1916 2
      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
d1947 1
a1947 1
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
d1949 1
a1949 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d1956 1
a1956 1
      splt = bfd_get_section_by_name (dynobj, ".plt");
@


1.68
log
@	* elf32-vax.c (elf_vax_relocate_section)
	<R_VAX_8, R_VAX_16, R_VAX_32>: Use section flags rather than
	its name as the check for text sections.
@
text
@d1695 1
a1695 2
		  || (info->shared
		      && ELF32_R_TYPE (outrel.r_info) != R_VAX_32
@


1.67
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d1694 7
a1700 8
	      if (!strcmp (bfd_get_section_name (input_bfd, input_section),
			   ".text") != 0 ||
		  (info->shared
		   && ELF32_R_TYPE(outrel.r_info) != R_VAX_32
		   && ELF32_R_TYPE(outrel.r_info) != R_VAX_RELATIVE
		   && ELF32_R_TYPE(outrel.r_info) != R_VAX_COPY
		   && ELF32_R_TYPE(outrel.r_info) != R_VAX_JMP_SLOT
		   && ELF32_R_TYPE(outrel.r_info) != R_VAX_GLOB_DAT))
@


1.66
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1448 1
a1448 1
					 rel, relend, howto, contents);
@


1.65
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d1446 1
a1446 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.64
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
a1038 7
  if (h->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
      return TRUE;
    }

d1056 1
a1056 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.64.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d1453 1
a1453 1
      if (sec != NULL && discarded_section (sec))
@


1.63
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d3 2
a4 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010  Free Software Foundation, Inc.
a1275 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf_vax_link_hash_entry *) h->root.root.u.i.link;

@


1.62
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d1456 2
a1457 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.61
log
@fix set but unused variable warnings
@
text
@d1614 1
a1614 1
	      && r_symndx != 0
@


1.60
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@a496 1
  flagword out_flags;
a503 1
  out_flags = elf_elfheader (obfd)->e_flags;
a1362 1
  bfd_vma *local_got_offsets;
a1374 1
  local_got_offsets = elf_local_got_offsets (input_bfd);
@


1.59
log
@	* elf32-vax.c (elf_vax_relocate_section): Correct assertion.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation, Inc.
a409 7
/* VAX ELF linker hash table.  */

struct elf_vax_link_hash_table
{
  struct elf_link_hash_table root;
};

d413 1
a413 1
					   PTR);
d418 1
a418 1
						    PTR);
d424 1
a424 1
   (&(table)->root,							\
a427 4
/* Get the VAX ELF linker hash table from a link_info structure.  */

#define elf_vax_hash_table(p) ((struct elf_vax_link_hash_table *) (p)->hash)

d464 2
a465 2
  struct elf_vax_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_vax_link_hash_table);
d471 1
a471 1
  if (!_bfd_elf_link_hash_table_init (&ret->root, abfd,
d473 2
a474 1
				      sizeof (struct elf_vax_link_hash_entry)))
d480 1
a480 1
  return &ret->root.root;
d1125 1
a1125 1
    elf_vax_link_hash_traverse (elf_vax_hash_table (info),
@


1.58
log
@	* elf32-vax.c (elf_vax_plt_entry): Fix formatting.
@
text
@d1586 1
a1586 1
	      BFD_ASSERT (splt != NULL);
@


1.57
log
@	* elf32-vax.c (elf_vax_relocate_section): Fix a typo.
@
text
@d374 1
a374 1
  0x16,	0xef,		/* jsb L^(pc) */
@


1.56
log
@update copyright dates
@
text
@d1596 1
a1596 1
	  /* We want the relocate to point into the .got.plt instead
@


1.55
log
@bfd/
* elf32-vax.c (elf_vax_plt_sym_val): New function.
(elf_backend_plt_sym_val): Define.

opcodes/
* vax-dis.c (is_function_entry): Return success for synthetic
symbols too.
(is_plt_tail): New function.
(print_insn_vax): Decode PLT entry offset longword.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
@


1.54
log
@bfd/
* elf32-vax.c (elf_vax_reloc_type_class): New function.
(elf_backend_reloc_type_class): Define.
@
text
@d50 2
d2096 7
d2128 1
@


1.53
log
@bfd/
* elf32-vax.c (elf_vax_relocate_section): For symbol references
from an executable to a shared library treat R_VAX_PC32
relocations as R_VAX_PLT32 ones.
@
text
@d2078 16
d2116 1
@


1.52
log
@bfd/
* elf32-vax.c (elf_vax_instantiate_got_entries): Skip local
symbols in GOT space calculation.
(elf_vax_relocate_section): Adjust accordingly.
@
text
@d1547 8
d1616 1
a1616 1
	case R_VAX_PC32:
@


1.51
log
@bfd/
* elf32-vax.c (elf_vax_plt_entry): Set the entry mask to
include <R11:R2>.
@
text
@d1335 2
d1344 1
d1346 7
a1352 2
      sgot->size += 4;
      srelgot->size += sizeof (Elf32_External_Rela);
d1496 1
d1510 4
a1513 3
	    if (info->shared
		&& h->dynindx == -1
		&& h->def_regular)
@


1.50
log
@bfd/
* elf32-vax.c (elf_vax_check_relocs): Handle the visibility
attribute.
(elf_vax_relocate_section): Likewise.

gas/
* config/tc-vax.c (md_estimate_size_before_relax): Accept
indirect symbol references in the PIC mode and emit a
PC-relative relocation instead of a GOT/PLT one.  Likewise
for symbols known to be hidden at this point.
@
text
@d371 1
a371 1
  0x40, 0x00,		/* .word ^M<r6> */
@


1.49
log
@2009-04-01  Matt Thomas  <matt@@netbsd.org>

	* elf32-vax.c (elf_vax_check_relocs): Do not put relocations against
	hidden symbols into the GOT or PLT.GOT.
	(elf_vax_relocate_section): Do not emit a PCREL reloc
	into a shared object if it is against a hidden symbol.
@
text
@d608 5
d685 1
a685 1
	  if (h->forced_local)
d714 3
a716 1
	      if (h != NULL && !h->forced_local)
d728 4
a731 1
	  if (h != NULL && h->forced_local)
d738 1
a738 1
	  if (h != NULL)
d1478 4
a1481 1
	  if (h == NULL || h->got.offset == (bfd_vma) -1 || h->forced_local)
d1543 3
a1545 1
	  if (h == NULL || h->forced_local)
d1599 3
a1601 1
	  if (h == NULL || h->forced_local)
@


1.48
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d602 4
a605 2
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d659 5
a663 4
		      (_("%s: warning: GOT addend of %ld to `%s' does not match previous GOT addend of %ld"),
			      bfd_get_filename (abfd), rel->r_addend,
			      h->root.root.string,
			      eh->got_addend);
d679 3
a681 2
	  if (h == NULL)
	    continue;
d709 1
a709 1
	      if (h != NULL)
d721 3
d1315 2
a1316 1
      || (info->shared && info->symbolic))
d1420 1
d1423 2
a1424 2
		      && strcmp (h->root.root.string,
				 "_GLOBAL_OFFSET_TABLE_") != 0
d1442 1
a1442 4
			  || r_type == R_VAX_32
			  || r_type == R_VAX_PC8
			  || r_type == R_VAX_PC16
			  || r_type == R_VAX_PC32))))
d1468 1
a1468 1
	  if (h == NULL || h->got.offset == (bfd_vma) -1)
d1530 1
a1530 1
	  if (h == NULL)
d1584 1
a1584 1
	  if (h == NULL)
@


1.47
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d741 2
a742 1
		  const char *name;
d744 1
a744 5
		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
a746 19
		  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  if (sreloc == NULL)
		    {
		      sreloc = bfd_make_section_with_flags (dynobj,
							    name,
							    (SEC_ALLOC
							     | SEC_LOAD
							     | SEC_HAS_CONTENTS
							     | SEC_IN_MEMORY
							     | SEC_LINKER_CREATED
							     | SEC_READONLY));
		      if (sreloc == NULL
			  || !bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
		    }
d1603 3
a1605 7
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
a1606 8

		  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
@


1.46
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d870 3
@


1.45
log
@Switch sources over to use the GPL version 3
@
text
@d824 3
a826 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.44
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.43
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a927 1
  unsigned int power_of_two;
d1081 1
a1081 22
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
    {
      if (!bfd_set_section_alignment (dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.42
log
@2007-04-03  Matt Thomas  <matt@@netbsd.org>

	* elf32-vax.c (elf_vax_relocate_section): Do not emit a PCREL reloc
	in a shared object if it is not in a CODE section or if it is against
	a section symbol.  This allows DWARF2 to use pcrel format.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.41
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d1628 3
a1630 2
		  || (!info->symbolic
		      || !h->def_regular)))
@


1.40
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d3 1
a3 1
   2004, 2005, 2006 Free Software Foundation, Inc.
d325 14
d340 1
@


1.39
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@a1379 3
  if (info->relocatable)
    return TRUE;

a1410 1
      /* This is a final link.  */
d1466 14
@


1.38
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d1683 5
d1690 8
a1697 1
			  BFD_ASSERT (indx > 0);
d2077 1
@


1.37
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@a36 7
static asection *elf_vax_gc_mark_hook (asection *, struct bfd_link_info *,
				       Elf_Internal_Rela *,
				       struct elf_link_hash_entry *,
				       Elf_Internal_Sym *);
static bfd_boolean elf_vax_gc_sweep_hook (bfd *, struct bfd_link_info *,
					  asection *,
					  const Elf_Internal_Rela *);
d825 1
a825 1
		      struct bfd_link_info *info ATTRIBUTE_UNUSED,
d831 6
a836 24
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_VAX_GNU_VTINHERIT:
	case R_VAX_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    default:
	      break;

	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d838 1
a838 1
  return NULL;
@


1.36
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d741 1
a741 1
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d1197 1
a1197 1
      else if (strncmp (name, ".rela", 5) == 0)
d1229 1
a1229 1
      else if (strncmp (name, ".got", 4) != 0
d1649 1
a1649 1
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
@


1.35
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d3 1
a3 1
   2004, 2005 Free Software Foundation, Inc.
d471 3
a473 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       elf_vax_link_hash_newfunc))
@


1.34
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d1957 1
a1957 1
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.33
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d1057 7
@


1.32
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@a1175 1
      bfd_boolean strip;
a1183 2
      strip = FALSE;

d1186 2
a1187 11
	  if (s->size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
d1191 1
a1191 14
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = TRUE;
	    }
	  else
d1221 2
a1222 1
      else if (strncmp (name, ".got", 4) != 0)
d1228 1
a1228 1
      if (strip)
d1230 9
d1243 3
d1248 1
a1248 1
      if (s->contents == NULL && s->size != 0)
@


1.31
log
@Convert to ISO C90 formatting
@
text
@d582 6
a587 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.30
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d29 31
a59 36
static reloc_howto_type *reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void rtype_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static struct bfd_hash_entry *elf_vax_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *elf_vax_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean elf_vax_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static asection *elf_vax_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf_vax_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static bfd_boolean elf_vax_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean elf_vax_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_vax_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf_vax_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean elf_vax_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));

static bfd_boolean elf32_vax_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean elf32_vax_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static bfd_boolean elf32_vax_print_private_bfd_data
  PARAMS ((bfd *, PTR));
d288 2
a289 4
rtype_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d321 1
a321 3
reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d408 2
a409 2
static bfd_boolean elf_vax_discard_copies
  PARAMS ((struct elf_vax_link_hash_entry *, PTR));
d413 2
a414 2
static bfd_boolean elf_vax_instantiate_got_entries
  PARAMS ((struct elf_link_hash_entry *, PTR));
d421 1
a421 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d426 1
a426 2
#define elf_vax_hash_table(p) \
  ((struct elf_vax_link_hash_table *) (p)->hash)
d431 3
a433 4
elf_vax_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d440 1
a440 1
  if (ret == (struct elf_vax_link_hash_entry *) NULL)
d444 1
a444 1
  if (ret == (struct elf_vax_link_hash_entry *) NULL)
d451 1
a451 1
  if (ret != (struct elf_vax_link_hash_entry *) NULL)
d462 1
a462 2
elf_vax_link_hash_table_create (abfd)
     bfd *abfd;
d467 2
a468 2
  ret = (struct elf_vax_link_hash_table *) bfd_malloc (amt);
  if (ret == (struct elf_vax_link_hash_table *) NULL)
d483 1
a483 3
elf32_vax_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d493 1
a493 3
elf32_vax_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d516 1
a516 3
elf32_vax_print_private_bfd_data (abfd, ptr)
     bfd *abfd;
     PTR ptr;
d548 2
a549 5
elf_vax_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d768 2
a769 2
 		   || ELF32_R_TYPE (rel->r_info) == R_VAX_PC16
 		   || ELF32_R_TYPE (rel->r_info) == R_VAX_PC32)
d825 5
a829 6
elf_vax_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d863 2
a864 5
elf_vax_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1106 1
a1106 3
elf_vax_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d1153 1
a1153 1
				(PTR) NULL);
d1310 2
a1311 3
elf_vax_discard_copies (h, ignore)
     struct elf_vax_link_hash_entry *h;
     PTR ignore ATTRIBUTE_UNUSED;
d1336 1
a1336 3
elf_vax_instantiate_got_entries (h, infoptr)
     struct elf_link_hash_entry *h;
     PTR infoptr;
d1382 8
a1389 10
elf_vax_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1458 1
a1458 1
	   
d1813 3
a1815 5
elf_vax_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1966 1
a1966 3
elf_vax_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
@


1.29
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d634 8
a641 1
		  srelgot = bfd_make_section (dynobj, ".rela.got");
a642 7
		      || !bfd_set_section_flags (dynobj, srelgot,
						 (SEC_ALLOC
						  | SEC_LOAD
						  | SEC_HAS_CONTENTS
						  | SEC_IN_MEMORY
						  | SEC_LINKER_CREATED
						  | SEC_READONLY))
d763 8
a770 1
		      sreloc = bfd_make_section (dynobj, name);
a771 7
			  || !bfd_set_section_flags (dynobj, sreloc,
						     (SEC_ALLOC
						      | SEC_LOAD
						      | SEC_HAS_CONTENTS
						      | SEC_IN_MEMORY
						      | SEC_LINKER_CREATED
						      | SEC_READONLY))
@


1.28
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.27
log
@Update the FSF address in the copyright/GPL notice
@
text
@d1276 1
a1276 1
	  _bfd_strip_section_from_output (info, s);
@


1.26
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.25
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d3 1
a3 1
   2004 Free Software Foundation, Inc.
d907 10
a916 1
      struct elf_link_hash_entry *h;
d921 2
a922 7
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->got.refcount > 0)
		--h->got.refcount;
	    }
d932 2
a933 7
	  r_symndx = ELF32_R_SYM (rel->r_info);
	  if (r_symndx >= symtab_hdr->sh_info)
	    {
	      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	      if (h->plt.refcount > 0)
		--h->plt.refcount;
	    }
@


1.24
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d1817 1
a1817 1
		  name = h->root.root.string;
d1829 3
a1831 2
		      (info, name, howto->name, (bfd_vma) 0,
		       input_bfd, input_section, rel->r_offset)))
@


1.23
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d965 1
a965 1
		  || h->weakdef != NULL
d1059 1
a1059 1
  if (h->weakdef != NULL)
d1061 4
a1064 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
@


1.22
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d685 1
a685 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d709 1
a709 2
		    || (h->elf_link_hash_flags
			& ELF_LINK_HASH_DEF_REGULAR) == 0)))
d964 1
a964 1
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
d966 3
a968 6
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
d974 1
a974 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d977 2
a978 2
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
d989 1
a989 1
	  BFD_ASSERT ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0);
d997 1
a997 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1025 1
a1025 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1102 1
a1102 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d1348 1
a1348 1
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1503 1
a1503 2
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
d1506 1
a1506 2
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1514 1
a1514 2
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d1554 1
a1554 1
		&& (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d1661 1
a1661 2
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d1709 1
a1709 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
d1917 1
a1917 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1948 1
a1948 1
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d1965 1
a1965 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.21
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d780 1
a780 1
	      sreloc->_raw_size += sizeof (Elf32_External_Rela);
d1018 1
a1018 1
      if (s->_raw_size == 0)
d1020 1
a1020 1
	  s->_raw_size += PLT_ENTRY_SIZE;
d1032 1
a1032 1
	  h->root.u.def.value = s->_raw_size;
d1035 1
a1035 1
      h->plt.offset = s->_raw_size;
d1038 1
a1038 1
      s->_raw_size += PLT_ENTRY_SIZE;
d1045 1
a1045 1
      s->_raw_size += 4;
d1051 1
a1051 1
      s->_raw_size += sizeof (Elf32_External_Rela);
d1105 1
a1105 1
      srel->_raw_size += sizeof (Elf32_External_Rela);
d1116 1
a1116 2
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
d1125 1
a1125 1
  h->root.u.def.value = s->_raw_size;
d1128 1
a1128 1
  s->_raw_size += h->size;
d1156 1
a1156 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d1169 1
a1169 1
	s->_raw_size = 0;
d1172 1
a1172 1
	s->_raw_size = 0;
d1175 1
a1175 1
	s->_raw_size = 0;
d1216 1
a1216 1
	  if (s->_raw_size == 0)
d1230 1
a1230 1
	  if (s->_raw_size == 0)
d1286 2
a1287 2
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d1356 1
a1356 1
    s->section->_raw_size -= s->count * sizeof (Elf32_External_Rela);
d1407 2
a1408 2
      sgot->_raw_size += 4;
      srelgot->_raw_size += sizeof (Elf32_External_Rela);
d1557 1
a1557 1
	    BFD_ASSERT (off < sgot->_raw_size);
d2032 1
a2032 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d2061 1
a2061 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d2075 1
a2075 6
		{
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
		}
d2082 1
a2082 1
      if (splt->_raw_size > 0)
d2101 1
a2101 1
  if (sgot->_raw_size > 0)
@


1.20
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d824 1
a824 1
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d831 1
a831 1
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1009 1
a1009 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d1403 1
a1403 1
	  if (!bfd_elf32_link_record_dynamic_symbol (info, h))
d2136 1
a2136 1
#define bfd_elf32_bfd_final_link	_bfd_elf32_gc_common_final_link
@


1.19
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d1300 1
a1300 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.18
log
@	* elf32-cris.c (cris_elf_gc_sweep_hook): Return early if no
	dynamic object is present.  Declare r_symndx and h in an inner
	scope.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
@
text
@d2 2
a3 2
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d1492 4
a1495 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.18.6.1
log
@Merge from mainline
@
text
@d2 2
a3 2
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d824 1
a824 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d831 1
a831 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1009 1
a1009 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1300 1
a1300 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d1403 1
a1403 1
	  if (!bfd_elf_link_record_dynamic_symbol (info, h))
d1492 4
a1495 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d2136 1
a2136 1
#define bfd_elf32_bfd_final_link	bfd_elf_gc_common_final_link
@


1.18.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 2
a3 2
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d1300 1
a1300 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d1492 4
a1495 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.18.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d824 1
a824 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d831 1
a831 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1009 1
a1009 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1403 1
a1403 1
	  if (!bfd_elf_link_record_dynamic_symbol (info, h))
d2136 1
a2136 1
#define bfd_elf32_bfd_final_link	bfd_elf_gc_common_final_link
@


1.18.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d780 1
a780 1
	      sreloc->size += sizeof (Elf32_External_Rela);
d1018 1
a1018 1
      if (s->size == 0)
d1020 1
a1020 1
	  s->size += PLT_ENTRY_SIZE;
d1032 1
a1032 1
	  h->root.u.def.value = s->size;
d1035 1
a1035 1
      h->plt.offset = s->size;
d1038 1
a1038 1
      s->size += PLT_ENTRY_SIZE;
d1045 1
a1045 1
      s->size += 4;
d1051 1
a1051 1
      s->size += sizeof (Elf32_External_Rela);
d1105 1
a1105 1
      srel->size += sizeof (Elf32_External_Rela);
d1116 2
a1117 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d1126 1
a1126 1
  h->root.u.def.value = s->size;
d1129 1
a1129 1
  s->size += h->size;
d1157 1
a1157 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d1170 1
a1170 1
	s->size = 0;
d1173 1
a1173 1
	s->size = 0;
d1176 1
a1176 1
	s->size = 0;
d1217 1
a1217 1
	  if (s->size == 0)
d1231 1
a1231 1
	  if (s->size == 0)
d1287 2
a1288 2
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->size);
      if (s->contents == NULL && s->size != 0)
d1357 1
a1357 1
    s->section->size -= s->count * sizeof (Elf32_External_Rela);
d1408 2
a1409 2
      sgot->size += 4;
      srelgot->size += sizeof (Elf32_External_Rela);
d1558 1
a1558 1
	    BFD_ASSERT (off < sgot->size);
d2033 1
a2033 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
d2062 4
a2065 1
	      dyn.d_un.d_val = s->size;
d2079 6
a2084 1
		dyn.d_un.d_val -= s->size;
d2091 1
a2091 1
      if (splt->size > 0)
d2110 1
a2110 1
  if (sgot->size > 0)
@


1.18.8.4
log
@Merge from mainline.
@
text
@d685 1
a685 1
	  h->needs_plt = 1;
d709 2
a710 1
		    || !h->def_regular)))
d965 8
a972 5
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d978 1
a978 1
      || h->needs_plt)
d981 2
a982 2
	  && !h->def_dynamic
	  && !h->ref_dynamic
d993 1
a993 1
	  BFD_ASSERT (h->needs_plt);
d1001 1
a1001 1
	  h->needs_plt = 0;
d1029 1
a1029 1
	  && !h->def_regular)
d1063 1
a1063 1
  if (h->u.weakdef != NULL)
d1065 4
a1068 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d1106 1
a1106 1
      h->needs_copy = 1;
d1352 1
a1352 1
  if (!h->root.def_regular)
d1507 2
a1508 1
			  || !h->def_regular))
d1511 2
a1512 1
			  || !h->def_regular)
d1520 2
a1521 1
			      && h->def_dynamic))
d1561 1
a1561 1
		&& h->def_regular)
d1668 2
a1669 1
		      || !h->def_regular)))
d1717 2
a1718 1
			   || !h->def_regular))
d1926 1
a1926 1
      if (!h->def_regular)
d1957 1
a1957 1
	  && h->def_regular)
d1974 1
a1974 1
  if (h->needs_copy)
@


1.17
log
@	* coff-rs6000.c: Remove ARGSUSED and VARARGS.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* elf32-vax.c: Likewise.
	* hash.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* ihex.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* pdp11.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* section.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
@
text
@a894 2
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
a896 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

d901 3
d907 3
@


1.16
log
@Fix decision about when a .interp section should exist
@
text
@a1340 1
/*ARGSUSED*/
a1367 1
/*ARGSUSED*/
@


1.15
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d1152 1
a1152 1
      if (!info->shared)
@


1.14
log
@Better handking for unresolved symbols
@
text
@d1486 1
a1486 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d1740 1
a1740 10
		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
@


1.13
log
@Correct spelling of "relocatable".
@
text
@d1490 9
a1498 5
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  if (h->root.type == bfd_link_hash_defined
d1500 1
a1500 3
	    {
	      sec = h->root.u.def.section;
	      if ((r_type == R_VAX_PLT32
d1529 4
a1532 17
			  || r_type == R_VAX_PC32)))
		{
		  /* In these cases, we don't need the relocation
		     value.  We check specially because in some
		     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
	      else
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else if (info->shared
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
a1533 10
	  else
	    {
	      if (!(info->callbacks->undefined_symbol
		    (info, h->root.root.string, input_bfd,
		     input_section, rel->r_offset,
		     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      relocation = 0;
	    }
@


1.12
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d581 1
a581 1
  if (info->relocateable)
d1443 1
a1443 1
  if (info->relocateable)
@


1.11
log
@	* coff-h8300.c: Fix comment typos.
	* coffcode.h: Likewise.
	* cpu-cris.c: Likewise.
	* elf32-vax.c: Likewise.
	* genlink.h: Likewise.
	* linker.c: Likewise.
	* som.c: Likewise.
	* tekhex.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a1541 1
		   && (!info->symbolic || info->allow_shlib_undefined)
a1700 1

a1908 1

a1974 1

a2012 1

@


1.10
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d786 1
a786 1
		 only called if we are using an vaxelf linker hash table,
@


1.9
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d37 1
a37 1
static boolean elf_vax_check_relocs
d43 1
a43 1
static boolean elf_vax_gc_sweep_hook
d46 1
a46 1
static boolean elf_vax_adjust_dynamic_symbol
d48 1
a48 1
static boolean elf_vax_size_dynamic_sections
d50 1
a50 1
static boolean elf_vax_relocate_section
d53 1
a53 1
static boolean elf_vax_finish_dynamic_symbol
d56 1
a56 1
static boolean elf_vax_finish_dynamic_sections
d59 1
a59 1
static boolean elf32_vax_set_private_flags
d61 1
a61 1
static boolean elf32_vax_merge_private_bfd_data
d63 1
a63 1
static boolean elf32_vax_print_private_bfd_data
d71 1
a71 1
	 false,			/* pc_relative */
d76 1
a76 1
	 false,			/* partial_inplace */
d79 1
a79 1
	 false),		/* pcrel_offset */
d85 1
a85 1
	 false,			/* pc_relative */
d90 1
a90 1
	 false,			/* partial_inplace */
d93 1
a93 1
	 false),		/* pcrel_offset */
d99 1
a99 1
	 false,			/* pc_relative */
d104 1
a104 1
	 false,			/* partial_inplace */
d107 1
a107 1
	 false),		/* pcrel_offset */
d113 1
a113 1
	 false,			/* pc_relative */
d118 1
a118 1
	 false,			/* partial_inplace */
d121 1
a121 1
	 false),		/* pcrel_offset */
d127 1
a127 1
	 true,			/* pc_relative */
d132 1
a132 1
	 false,			/* partial_inplace */
d135 1
a135 1
	 true),			/* pcrel_offset */
d141 1
a141 1
	 true,			/* pc_relative */
d146 1
a146 1
	 false,			/* partial_inplace */
d149 1
a149 1
	 true),			/* pcrel_offset */
d155 1
a155 1
	 true,			/* pc_relative */
d160 1
a160 1
	 false,			/* partial_inplace */
d163 1
a163 1
	 true),			/* pcrel_offset */
d169 1
a169 1
	 true,			/* pc_relative */
d174 1
a174 1
	 false,			/* partial_inplace */
d177 1
a177 1
	 true),			/* pcrel_offset */
d189 1
a189 1
	 true,			/* pc_relative */
d194 1
a194 1
	 false,			/* partial_inplace */
d197 1
a197 1
	 true),			/* pcrel_offset */
d209 1
a209 1
	 false,			/* pc_relative */
d214 1
a214 1
	 false,			/* partial_inplace */
d217 1
a217 1
	 false),		/* pcrel_offset */
d223 1
a223 1
	 false,			/* pc_relative */
d228 1
a228 1
	 false,			/* partial_inplace */
d231 1
a231 1
	 false),		/* pcrel_offset */
d237 1
a237 1
	 false,			/* pc_relative */
d242 1
a242 1
	 false,			/* partial_inplace */
d245 1
a245 1
	 false),		/* pcrel_offset */
d251 1
a251 1
	 false,			/* pc_relative */
d256 1
a256 1
	 false,			/* partial_inplace */
d259 1
a259 1
	 false),		/* pcrel_offset */
d266 1
a266 1
	 false,			/* pc_relative */
d271 1
a271 1
	 false,			/* partial_inplace */
d274 1
a274 1
	 false),		/* pcrel_offset */
d281 1
a281 1
	 false,			/* pc_relative */
d286 1
a286 1
	 false,			/* partial_inplace */
d289 1
a289 1
	 false),		/* pcrel_offset */
d417 1
a417 1
static boolean elf_vax_discard_copies
d422 1
a422 1
static boolean elf_vax_instantiate_got_entries
d430 1
a430 1
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
d494 1
a494 1
static boolean
d500 2
a501 2
  elf_flags_init (abfd) = true;
  return true;
d506 1
a506 1
static boolean
d516 1
a516 1
    return true;
d523 1
a523 1
      elf_flags_init (obfd) = true;
d527 1
a527 1
  return true;
d531 1
a531 1
static boolean
d559 1
a559 1
  return true;
d565 1
a565 1
static boolean
d582 1
a582 1
    return true;
d619 1
a619 1
		return false;
d644 1
a644 1
		    return false;
d755 1
a755 1
		    return false;
d774 1
a774 1
			return false;
d808 1
a808 1
			return false;
d825 1
a825 1
	    return false;
d832 1
a832 1
	    return false;
d840 1
a840 1
  return true;
d885 1
a885 1
static boolean
d904 1
a904 1
    return true;
d942 1
a942 1
  return true;
d951 1
a951 1
static boolean
d994 1
a994 1
	  return true;
d1002 1
a1002 1
	  return true;
d1009 1
a1009 1
	    return false;
d1052 1
a1052 1
      return true;
d1068 1
a1068 1
      return true;
d1079 1
a1079 1
    return true;
d1120 1
a1120 1
	return false;
d1130 1
a1130 1
  return true;
d1135 1
a1135 1
static boolean
d1142 3
a1144 3
  boolean plt;
  boolean relocs;
  boolean reltext;
d1187 1
a1187 1
  /* If this is a -Bsymbolic shared link or a static link, we need to 
d1197 3
a1199 3
  plt = false;
  relocs = false;
  reltext = false;
d1203 1
a1203 1
      boolean strip;
d1212 1
a1212 1
      strip = false;
d1220 1
a1220 1
	      strip = true;
d1225 1
a1225 1
	      plt = true;
d1241 1
a1241 1
	      strip = true;
d1253 1
a1253 1
		  relocs = true;
d1265 1
a1265 1
		    reltext = true;
d1288 1
a1288 1
	return false;
d1304 1
a1304 1
	    return false;
d1313 1
a1313 1
	    return false;
d1321 1
a1321 1
	    return false;
d1327 1
a1327 1
	    return false;
d1332 1
a1332 1
  return true;
d1342 1
a1342 1
static boolean
d1354 1
a1354 1
    return true;
d1359 1
a1359 1
  return true;
d1370 1
a1370 1
static boolean
d1379 1
a1379 1
  
d1382 1
a1382 1
    return true;
d1386 1
a1386 1
    return true;
d1405 1
a1405 1
	    return false;
d1413 1
a1413 1
  return true;
d1418 1
a1418 1
static boolean
d1444 1
a1444 1
    return true;
d1473 1
a1473 1
	  return false;
d1553 1
a1553 1
		return false;
d1697 1
a1697 1
	      boolean skip, relocate;
d1712 1
a1712 1
		    return false;
d1723 2
a1724 2
	      skip = false;
	      relocate = false;
d1730 1
a1730 1
		skip = true;
d1732 1
a1732 1
		skip = true, relocate = true;
d1753 1
a1753 1
		      relocate = true;
d1777 1
a1777 1
			  return false;
d1838 1
a1838 1
      /* VAX PCREL relocations are from the end of relocation, not the start.  
d1867 1
a1867 1
		      return false;
d1874 1
a1874 1
		  return false;
d1881 1
a1881 1
  return true;
d1887 1
a1887 1
static boolean
d2040 1
a2040 1
  return true;
d2045 1
a2045 1
static boolean
d2160 1
a2160 1
  return true;
@


1.8
log
@* elf32-vax.c (elf_vax_size_dynamic_section): Don't strip
.got sections.
@
text
@d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf32_Internal_Rela *));
d1696 1
d1815 3
a1817 5
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d1907 1
d1958 2
a1959 3
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) srela->contents
				  + plt_index));
d1974 1
d2005 3
a2007 4
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) srela->contents
				  + srela->reloc_count));
      ++srela->reloc_count;
d2014 1
d2031 2
a2032 4
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
@


1.8.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d37 1
a37 1
static bfd_boolean elf_vax_check_relocs
d43 1
a43 1
static bfd_boolean elf_vax_gc_sweep_hook
d46 1
a46 1
static bfd_boolean elf_vax_adjust_dynamic_symbol
d48 1
a48 1
static bfd_boolean elf_vax_size_dynamic_sections
d50 1
a50 1
static bfd_boolean elf_vax_relocate_section
d53 1
a53 1
static bfd_boolean elf_vax_finish_dynamic_symbol
d56 1
a56 1
static bfd_boolean elf_vax_finish_dynamic_sections
d59 1
a59 1
static bfd_boolean elf32_vax_set_private_flags
d61 1
a61 1
static bfd_boolean elf32_vax_merge_private_bfd_data
d63 1
a63 1
static bfd_boolean elf32_vax_print_private_bfd_data
d71 1
a71 1
	 FALSE,			/* pc_relative */
d76 1
a76 1
	 FALSE,			/* partial_inplace */
d79 1
a79 1
	 FALSE),		/* pcrel_offset */
d85 1
a85 1
	 FALSE,			/* pc_relative */
d90 1
a90 1
	 FALSE,			/* partial_inplace */
d93 1
a93 1
	 FALSE),		/* pcrel_offset */
d99 1
a99 1
	 FALSE,			/* pc_relative */
d104 1
a104 1
	 FALSE,			/* partial_inplace */
d107 1
a107 1
	 FALSE),		/* pcrel_offset */
d113 1
a113 1
	 FALSE,			/* pc_relative */
d118 1
a118 1
	 FALSE,			/* partial_inplace */
d121 1
a121 1
	 FALSE),		/* pcrel_offset */
d127 1
a127 1
	 TRUE,			/* pc_relative */
d132 1
a132 1
	 FALSE,			/* partial_inplace */
d135 1
a135 1
	 TRUE),			/* pcrel_offset */
d141 1
a141 1
	 TRUE,			/* pc_relative */
d146 1
a146 1
	 FALSE,			/* partial_inplace */
d149 1
a149 1
	 TRUE),			/* pcrel_offset */
d155 1
a155 1
	 TRUE,			/* pc_relative */
d160 1
a160 1
	 FALSE,			/* partial_inplace */
d163 1
a163 1
	 TRUE),			/* pcrel_offset */
d169 1
a169 1
	 TRUE,			/* pc_relative */
d174 1
a174 1
	 FALSE,			/* partial_inplace */
d177 1
a177 1
	 TRUE),			/* pcrel_offset */
d189 1
a189 1
	 TRUE,			/* pc_relative */
d194 1
a194 1
	 FALSE,			/* partial_inplace */
d197 1
a197 1
	 TRUE),			/* pcrel_offset */
d209 1
a209 1
	 FALSE,			/* pc_relative */
d214 1
a214 1
	 FALSE,			/* partial_inplace */
d217 1
a217 1
	 FALSE),		/* pcrel_offset */
d223 1
a223 1
	 FALSE,			/* pc_relative */
d228 1
a228 1
	 FALSE,			/* partial_inplace */
d231 1
a231 1
	 FALSE),		/* pcrel_offset */
d237 1
a237 1
	 FALSE,			/* pc_relative */
d242 1
a242 1
	 FALSE,			/* partial_inplace */
d245 1
a245 1
	 FALSE),		/* pcrel_offset */
d251 1
a251 1
	 FALSE,			/* pc_relative */
d256 1
a256 1
	 FALSE,			/* partial_inplace */
d259 1
a259 1
	 FALSE),		/* pcrel_offset */
d266 1
a266 1
	 FALSE,			/* pc_relative */
d271 1
a271 1
	 FALSE,			/* partial_inplace */
d274 1
a274 1
	 FALSE),		/* pcrel_offset */
d281 1
a281 1
	 FALSE,			/* pc_relative */
d286 1
a286 1
	 FALSE,			/* partial_inplace */
d289 1
a289 1
	 FALSE),		/* pcrel_offset */
d417 1
a417 1
static bfd_boolean elf_vax_discard_copies
d422 1
a422 1
static bfd_boolean elf_vax_instantiate_got_entries
d430 1
a430 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d494 1
a494 1
static bfd_boolean
d500 2
a501 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d506 1
a506 1
static bfd_boolean
d516 1
a516 1
    return TRUE;
d523 1
a523 1
      elf_flags_init (obfd) = TRUE;
d527 1
a527 1
  return TRUE;
d531 1
a531 1
static bfd_boolean
d559 1
a559 1
  return TRUE;
d565 1
a565 1
static bfd_boolean
d581 2
a582 2
  if (info->relocatable)
    return TRUE;
d619 1
a619 1
		return FALSE;
d644 1
a644 1
		    return FALSE;
d755 1
a755 1
		    return FALSE;
d774 1
a774 1
			return FALSE;
d786 1
a786 1
		 only called if we are using a vaxelf linker hash table,
d808 1
a808 1
			return FALSE;
d825 1
a825 1
	    return FALSE;
d832 1
a832 1
	    return FALSE;
d840 1
a840 1
  return TRUE;
d885 1
a885 1
static bfd_boolean
d904 1
a904 1
    return TRUE;
d942 1
a942 1
  return TRUE;
d951 1
a951 1
static bfd_boolean
d994 1
a994 1
	  return TRUE;
d1002 1
a1002 1
	  return TRUE;
d1009 1
a1009 1
	    return FALSE;
d1052 1
a1052 1
      return TRUE;
d1068 1
a1068 1
      return TRUE;
d1079 1
a1079 1
    return TRUE;
d1120 1
a1120 1
	return FALSE;
d1130 1
a1130 1
  return TRUE;
d1135 1
a1135 1
static bfd_boolean
d1142 3
a1144 3
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;
d1152 1
a1152 1
      if (info->executable)
d1187 1
a1187 1
  /* If this is a -Bsymbolic shared link or a static link, we need to
d1197 3
a1199 3
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
d1203 1
a1203 1
      bfd_boolean strip;
d1212 1
a1212 1
      strip = FALSE;
d1220 1
a1220 1
	      strip = TRUE;
d1225 1
a1225 1
	      plt = TRUE;
d1241 1
a1241 1
	      strip = TRUE;
d1253 1
a1253 1
		  relocs = TRUE;
d1265 1
a1265 1
		    reltext = TRUE;
d1288 1
a1288 1
	return FALSE;
d1304 1
a1304 1
	    return FALSE;
d1313 1
a1313 1
	    return FALSE;
d1321 1
a1321 1
	    return FALSE;
d1327 1
a1327 1
	    return FALSE;
d1332 1
a1332 1
  return TRUE;
d1341 2
a1342 1
static bfd_boolean
d1354 1
a1354 1
    return TRUE;
d1359 1
a1359 1
  return TRUE;
d1369 2
a1370 1
static bfd_boolean
d1379 1
a1379 1

d1382 1
a1382 1
    return TRUE;
d1386 1
a1386 1
    return TRUE;
d1405 1
a1405 1
	    return FALSE;
d1413 1
a1413 1
  return TRUE;
d1418 1
a1418 1
static bfd_boolean
d1443 2
a1444 2
  if (info->relocatable)
    return TRUE;
d1473 1
a1473 1
	  return FALSE;
d1486 1
a1486 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1490 5
a1494 9
	  bfd_boolean unresolved_reloc;
	  bfd_boolean warned;

	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
	   
	  if ((h->root.type == bfd_link_hash_defined
d1496 3
a1498 1
	      && ((r_type == R_VAX_PLT32
d1527 13
a1539 4
			  || r_type == R_VAX_PC32))))
	    /* In these cases, we don't need the relocation
	       value.  We check specially because in some
	       obscure cases sec->output_section will be NULL.  */
d1541 15
d1696 1
a1696 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d1701 1
d1711 1
a1711 1
		    return FALSE;
d1722 2
a1723 2
	      skip = FALSE;
	      relocate = FALSE;
d1729 1
a1729 1
		skip = TRUE;
d1731 1
a1731 1
		skip = TRUE, relocate = TRUE;
d1752 1
a1752 1
		      relocate = TRUE;
d1762 10
a1771 1
		      if (bfd_is_abs_section (sec))
d1776 1
a1776 1
			  return FALSE;
d1814 5
a1818 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d1839 1
a1839 1
      /* VAX PCREL relocations are from the end of relocation, not the start.
d1868 1
a1868 1
		      return FALSE;
d1875 1
a1875 1
		  return FALSE;
d1882 1
a1882 1
  return TRUE;
d1888 1
a1888 1
static bfd_boolean
a1907 1
      bfd_byte *loc;
d1911 1
d1958 3
a1960 2
      loc = srela->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a1974 1
      bfd_byte *loc;
d1978 1
d2005 4
a2008 3
      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a2014 1
      bfd_byte *loc;
d2017 1
d2031 4
a2034 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d2042 1
a2042 1
  return TRUE;
d2047 1
a2047 1
static bfd_boolean
d2162 1
a2162 1
  return TRUE;
@


1.8.2.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d895 2
d899 3
a905 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

a908 3
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

@


1.7
log
@* elf32-vax.c (elf_vax_check_relocs): Remove unused
local_got_refcounts usage.  Remove allocation of got slot.
(elf_vax_gc_sweep_hook): Remove unused local_got_refcounts usage.
Remove de-allocation of got slot.
(elf_vax_size_dynamic_section): Fix some indentation.  Add hash
traversal for elf_vax_instantiate_got_entries.  Allow empty .got
sections to be GC'ed.
(elf_vax_instantiate_got_entries): New function.
(elf_vax_relocate_section): Simplify R_VAX_GOT32 handling.  Remove
tests that are now handled by elf_vax_instantiate_got_entries.
Assert GOT entry falls within .got section size.  Remove redundant
comparisions.  Fix comments.
@
text
@d1273 1
a1273 10
      else if (strncmp (name, ".got", 4) == 0)
	{
	  if (s->_raw_size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = true;
	    }
	}
      else
@


1.6
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d420 5
a574 1
  bfd_signed_vma *local_got_refcounts;
a586 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
a656 12

		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1)
		    {
		      if (!bfd_elf32_link_record_dynamic_symbol (info, h))
			return false;
		    }

		  /* Allocate space in the .got section.  */
		  sgot->_raw_size += 4;
		  /* Allocate relocation space.  */
		  srelgot->_raw_size += sizeof (Elf32_External_Rela);
a893 1
  bfd_signed_vma *local_got_refcounts;
a897 2
  asection *sgot;
  asection *srelgot;
a900 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
a905 3
  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");

d917 1
a917 23
		{
		  --h->got.refcount;
		  if (h->got.refcount == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->_raw_size -= 4;
		      srelgot->_raw_size -= sizeof (Elf32_External_Rela);
		    }
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		{
		  --local_got_refcounts[r_symndx];
		  if (local_got_refcounts[r_symndx] == 0)
		    {
		      /* We don't need the .got entry any more.  */
		      sgot->_raw_size -= 4;
		      if (info->shared)
			srelgot->_raw_size -= sizeof (Elf32_External_Rela);
		    }
		}
d1184 9
a1192 2
				 elf_vax_discard_copies,
				 (PTR) NULL);
d1273 10
a1282 1
      else if (strncmp (name, ".got", 4) != 0)
d1371 54
d1572 1
a1572 2
	  if (h != NULL
	      && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
a1580 12
	    if (!elf_hash_table (info)->dynamic_sections_created
		|| (h == NULL)
	        || (info->shared
	         && info->symbolic
	         && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	      {
	        /* This is actually a static link, or it is a -Bsymbolic link
		   and the symbol is defined locally or there is no symbol.
		   Change the GOT32 entry to a PC32 entry.  */
		break;
	      }

d1590 1
d1619 1
a1619 1
	    /* Neither GOT relocation uses the addend.  */
d1622 3
a1624 6
	    if (r_type == R_VAX_GOT32)
	      {
		/* Change the reference to be indirect */
		contents[rel->r_offset - 1] |= 0x10;
	        relocation += sgot->output_section->vma;
	      }
d1848 3
a1850 1
      /* VAX PCREL relocations are from the end of relocation, not the start */
d1852 1
a1852 3
	{
	  relocation -= bfd_get_reloc_size(howto);
	}
@


1.6.10.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a419 5
/* Declare this now that the above structures are defined.  */

static boolean elf_vax_instantiate_got_entries
  PARAMS ((struct elf_link_hash_entry *, PTR));

d570 1
d583 1
d654 12
d903 1
d908 2
d913 1
d919 3
d933 23
a955 1
		--h->got.refcount;
d1222 2
a1223 9
				elf_vax_discard_copies,
				(PTR) NULL);

  /* If this is a -Bsymbolic shared link or a static link, we need to 
     discard all the got entries we've recorded.  Otherwise, we need to
     instantiate (allocate space for them).  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_vax_instantiate_got_entries,
			  (PTR) info);
a1392 54
/* This function is called via elf_link_hash_traverse.  It looks for entries
   that have GOT or PLT (.GOT) references.  If creating a static object or a
   shared object with -Bsymbolic, it resets the reference count back to 0
   and sets the offset to -1 so normal PC32 relocation will be done.  If
   creating a shared object or executable, space in the .got and .rela.got
   will be reserved for the symbol.  */

/*ARGSUSED*/
static boolean
elf_vax_instantiate_got_entries (h, infoptr)
     struct elf_link_hash_entry *h;
     PTR infoptr;
{
  struct bfd_link_info *info = (struct bfd_link_info *) infoptr;
  bfd *dynobj;
  asection *sgot;
  asection *srelgot;
  
  /* We don't care about non-GOT (and non-PLT) entries.  */
  if (h->got.refcount <= 0 && h->plt.refcount <= 0)
    return true;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return true;

  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");

  if (!elf_hash_table (info)->dynamic_sections_created
      || (info->shared && info->symbolic))
    {
      h->got.refcount = 0;
      h->got.offset = (bfd_vma) -1;
      h->plt.refcount = 0;
      h->plt.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (!bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      /* Allocate space in the .got and .rela.got sections.  */
      sgot->_raw_size += 4;
      srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }

  return true;
}

d1540 2
a1541 1
	  if (h == NULL || h->got.offset == (bfd_vma) -1)
d1550 12
a1570 1
	    BFD_ASSERT (off < sgot->_raw_size);
d1599 1
a1599 1
	    /* The GOT relocation uses the addend.  */
d1602 6
a1607 3
	    /* Change the reference to be indirect.  */
	    contents[rel->r_offset - 1] |= 0x10;
	    relocation += sgot->output_section->vma;
d1831 1
a1831 3
      /* VAX PCREL relocations are from the end of relocation, not the start.  
         So subtract the difference from the relocation amount since we can't
         add it to the offset.  */
d1833 3
a1835 1
	relocation -= bfd_get_reloc_size(howto);
@


1.6.10.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d32 1
a32 1
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
d37 1
a37 1
static bfd_boolean elf_vax_check_relocs
d43 1
a43 1
static bfd_boolean elf_vax_gc_sweep_hook
d46 1
a46 1
static bfd_boolean elf_vax_adjust_dynamic_symbol
d48 1
a48 1
static bfd_boolean elf_vax_size_dynamic_sections
d50 1
a50 1
static bfd_boolean elf_vax_relocate_section
d53 1
a53 1
static bfd_boolean elf_vax_finish_dynamic_symbol
d56 1
a56 1
static bfd_boolean elf_vax_finish_dynamic_sections
d59 1
a59 1
static bfd_boolean elf32_vax_set_private_flags
d61 1
a61 1
static bfd_boolean elf32_vax_merge_private_bfd_data
d63 1
a63 1
static bfd_boolean elf32_vax_print_private_bfd_data
d71 1
a71 1
	 FALSE,			/* pc_relative */
d76 1
a76 1
	 FALSE,			/* partial_inplace */
d79 1
a79 1
	 FALSE),		/* pcrel_offset */
d85 1
a85 1
	 FALSE,			/* pc_relative */
d90 1
a90 1
	 FALSE,			/* partial_inplace */
d93 1
a93 1
	 FALSE),		/* pcrel_offset */
d99 1
a99 1
	 FALSE,			/* pc_relative */
d104 1
a104 1
	 FALSE,			/* partial_inplace */
d107 1
a107 1
	 FALSE),		/* pcrel_offset */
d113 1
a113 1
	 FALSE,			/* pc_relative */
d118 1
a118 1
	 FALSE,			/* partial_inplace */
d121 1
a121 1
	 FALSE),		/* pcrel_offset */
d127 1
a127 1
	 TRUE,			/* pc_relative */
d132 1
a132 1
	 FALSE,			/* partial_inplace */
d135 1
a135 1
	 TRUE),			/* pcrel_offset */
d141 1
a141 1
	 TRUE,			/* pc_relative */
d146 1
a146 1
	 FALSE,			/* partial_inplace */
d149 1
a149 1
	 TRUE),			/* pcrel_offset */
d155 1
a155 1
	 TRUE,			/* pc_relative */
d160 1
a160 1
	 FALSE,			/* partial_inplace */
d163 1
a163 1
	 TRUE),			/* pcrel_offset */
d169 1
a169 1
	 TRUE,			/* pc_relative */
d174 1
a174 1
	 FALSE,			/* partial_inplace */
d177 1
a177 1
	 TRUE),			/* pcrel_offset */
d189 1
a189 1
	 TRUE,			/* pc_relative */
d194 1
a194 1
	 FALSE,			/* partial_inplace */
d197 1
a197 1
	 TRUE),			/* pcrel_offset */
d209 1
a209 1
	 FALSE,			/* pc_relative */
d214 1
a214 1
	 FALSE,			/* partial_inplace */
d217 1
a217 1
	 FALSE),		/* pcrel_offset */
d223 1
a223 1
	 FALSE,			/* pc_relative */
d228 1
a228 1
	 FALSE,			/* partial_inplace */
d231 1
a231 1
	 FALSE),		/* pcrel_offset */
d237 1
a237 1
	 FALSE,			/* pc_relative */
d242 1
a242 1
	 FALSE,			/* partial_inplace */
d245 1
a245 1
	 FALSE),		/* pcrel_offset */
d251 1
a251 1
	 FALSE,			/* pc_relative */
d256 1
a256 1
	 FALSE,			/* partial_inplace */
d259 1
a259 1
	 FALSE),		/* pcrel_offset */
d266 1
a266 1
	 FALSE,			/* pc_relative */
d271 1
a271 1
	 FALSE,			/* partial_inplace */
d274 1
a274 1
	 FALSE),		/* pcrel_offset */
d281 1
a281 1
	 FALSE,			/* pc_relative */
d286 1
a286 1
	 FALSE,			/* partial_inplace */
d289 1
a289 1
	 FALSE),		/* pcrel_offset */
d417 1
a417 1
static bfd_boolean elf_vax_discard_copies
d422 1
a422 1
static bfd_boolean elf_vax_instantiate_got_entries
d430 1
a430 1
    (bfd_boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func), \
d494 1
a494 1
static bfd_boolean
d500 2
a501 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d506 1
a506 1
static bfd_boolean
d516 1
a516 1
    return TRUE;
d523 1
a523 1
      elf_flags_init (obfd) = TRUE;
d527 1
a527 1
  return TRUE;
d531 1
a531 1
static bfd_boolean
d559 1
a559 1
  return TRUE;
d565 1
a565 1
static bfd_boolean
d582 1
a582 1
    return TRUE;
d619 1
a619 1
		return FALSE;
d644 1
a644 1
		    return FALSE;
d755 1
a755 1
		    return FALSE;
d774 1
a774 1
			return FALSE;
d786 1
a786 1
		 only called if we are using a vaxelf linker hash table,
d808 1
a808 1
			return FALSE;
d825 1
a825 1
	    return FALSE;
d832 1
a832 1
	    return FALSE;
d840 1
a840 1
  return TRUE;
d885 1
a885 1
static bfd_boolean
d904 1
a904 1
    return TRUE;
d942 1
a942 1
  return TRUE;
d951 1
a951 1
static bfd_boolean
d994 1
a994 1
	  return TRUE;
d1002 1
a1002 1
	  return TRUE;
d1009 1
a1009 1
	    return FALSE;
d1052 1
a1052 1
      return TRUE;
d1068 1
a1068 1
      return TRUE;
d1079 1
a1079 1
    return TRUE;
d1120 1
a1120 1
	return FALSE;
d1130 1
a1130 1
  return TRUE;
d1135 1
a1135 1
static bfd_boolean
d1142 3
a1144 3
  bfd_boolean plt;
  bfd_boolean relocs;
  bfd_boolean reltext;
d1187 1
a1187 1
  /* If this is a -Bsymbolic shared link or a static link, we need to
d1197 3
a1199 3
  plt = FALSE;
  relocs = FALSE;
  reltext = FALSE;
d1203 1
a1203 1
      bfd_boolean strip;
d1212 1
a1212 1
      strip = FALSE;
d1220 1
a1220 1
	      strip = TRUE;
d1225 1
a1225 1
	      plt = TRUE;
d1241 1
a1241 1
	      strip = TRUE;
d1253 1
a1253 1
		  relocs = TRUE;
d1265 1
a1265 1
		    reltext = TRUE;
d1288 1
a1288 1
	return FALSE;
d1304 1
a1304 1
	    return FALSE;
d1313 1
a1313 1
	    return FALSE;
d1321 1
a1321 1
	    return FALSE;
d1327 1
a1327 1
	    return FALSE;
d1332 1
a1332 1
  return TRUE;
d1342 1
a1342 1
static bfd_boolean
d1354 1
a1354 1
    return TRUE;
d1359 1
a1359 1
  return TRUE;
d1370 1
a1370 1
static bfd_boolean
d1379 1
a1379 1

d1382 1
a1382 1
    return TRUE;
d1386 1
a1386 1
    return TRUE;
d1405 1
a1405 1
	    return FALSE;
d1413 1
a1413 1
  return TRUE;
d1418 1
a1418 1
static bfd_boolean
d1444 1
a1444 1
    return TRUE;
d1473 1
a1473 1
	  return FALSE;
d1553 1
a1553 1
		return FALSE;
d1696 1
a1696 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d1711 1
a1711 1
		    return FALSE;
d1722 2
a1723 2
	      skip = FALSE;
	      relocate = FALSE;
d1729 1
a1729 1
		skip = TRUE;
d1731 1
a1731 1
		skip = TRUE, relocate = TRUE;
d1752 1
a1752 1
		      relocate = TRUE;
d1776 1
a1776 1
			  return FALSE;
d1814 5
a1818 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d1839 1
a1839 1
      /* VAX PCREL relocations are from the end of relocation, not the start.
d1868 1
a1868 1
		      return FALSE;
d1875 1
a1875 1
		  return FALSE;
d1882 1
a1882 1
  return TRUE;
d1888 1
a1888 1
static bfd_boolean
a1907 1
      bfd_byte *loc;
d1958 3
a1960 2
      loc = srela->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a1974 1
      bfd_byte *loc;
d2005 4
a2008 3
      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a2014 1
      bfd_byte *loc;
d2031 4
a2034 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d2042 1
a2042 1
  return TRUE;
d2047 1
a2047 1
static bfd_boolean
d2162 1
a2162 1
  return TRUE;
@


1.6.10.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 1993, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d1542 1
d1702 1
d1911 1
d1978 1
d2017 1
@


1.6.10.4
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d581 1
a581 1
  if (info->relocatable)
d1443 1
a1443 1
  if (info->relocatable)
@


1.6.10.5
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d1490 5
a1494 9
	  bfd_boolean unresolved_reloc;
	  bfd_boolean warned;

	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
	   
	  if ((h->root.type == bfd_link_hash_defined
d1496 3
a1498 1
	      && ((r_type == R_VAX_PLT32
d1527 17
a1543 4
			  || r_type == R_VAX_PC32))))
	    /* In these cases, we don't need the relocation
	       value.  We check specially because in some
	       obscure cases sec->output_section will be NULL.  */
d1545 10
@


1.6.10.6
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1152 1
a1152 1
      if (info->executable)
d1486 1
a1486 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1740 10
a1749 1
		      if (bfd_is_abs_section (sec))
@


1.6.10.7
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1341 1
d1369 1
@


1.6.10.8
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d895 2
d899 3
a905 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);

a908 3
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

@


1.5
log
@include/elf:

2002-07-01  Matt Thomas  <matt@@3am-software.com>

* Rename EF_* to EF_VAX_*.

bfd:

2002-07-01  Matt Thomas  <matt@@3am-software.com>

* elf32-vax.c (elf32_vax_print_private_bfd_data): Change EF_*
to EF_VAX_*.

binutils:

2002-07-01  Matt Thomas  <matt@@3am-software.com>

* readelf.c: Include "elf/vax.h".
(guess_is_rela): Move EM_VAX from unknown to RELA case.
(dump_relocations): Handle VAX relocations.
(get_machine_flags): Handle VAX machine flags.
@
text
@a343 2

#define USE_RELA
d1420 3
d1454 1
a1455 21

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d2192 1
@


1.5.2.1
log
@Merge from mainline.
@
text
@a421 5
/* Declare this now that the above structures are defined.  */

static boolean elf_vax_instantiate_got_entries
  PARAMS ((struct elf_link_hash_entry *, PTR));

d572 1
d585 1
d656 12
d905 1
d910 2
d915 1
d921 3
d935 23
a957 1
		--h->got.refcount;
d1224 2
a1225 9
				elf_vax_discard_copies,
				(PTR) NULL);

  /* If this is a -Bsymbolic shared link or a static link, we need to 
     discard all the got entries we've recorded.  Otherwise, we need to
     instantiate (allocate space for them).  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_vax_instantiate_got_entries,
			  (PTR) info);
a1394 54
/* This function is called via elf_link_hash_traverse.  It looks for entries
   that have GOT or PLT (.GOT) references.  If creating a static object or a
   shared object with -Bsymbolic, it resets the reference count back to 0
   and sets the offset to -1 so normal PC32 relocation will be done.  If
   creating a shared object or executable, space in the .got and .rela.got
   will be reserved for the symbol.  */

/*ARGSUSED*/
static boolean
elf_vax_instantiate_got_entries (h, infoptr)
     struct elf_link_hash_entry *h;
     PTR infoptr;
{
  struct bfd_link_info *info = (struct bfd_link_info *) infoptr;
  bfd *dynobj;
  asection *sgot;
  asection *srelgot;
  
  /* We don't care about non-GOT (and non-PLT) entries.  */
  if (h->got.refcount <= 0 && h->plt.refcount <= 0)
    return true;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return true;

  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");

  if (!elf_hash_table (info)->dynamic_sections_created
      || (info->shared && info->symbolic))
    {
      h->got.refcount = 0;
      h->got.offset = (bfd_vma) -1;
      h->plt.refcount = 0;
      h->plt.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (!bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      /* Allocate space in the .got and .rela.got sections.  */
      sgot->_raw_size += 4;
      srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }

  return true;
}

d1559 2
a1560 1
	  if (h == NULL || h->got.offset == (bfd_vma) -1)
d1569 12
a1589 1
	    BFD_ASSERT (off < sgot->_raw_size);
d1618 1
a1618 1
	    /* The GOT relocation uses the addend.  */
d1621 6
a1626 3
	    /* Change the reference to be indirect.  */
	    contents[rel->r_offset - 1] |= 0x10;
	    relocation += sgot->output_section->vma;
d1850 1
a1850 3
      /* VAX PCREL relocations are from the end of relocation, not the start.  
         So subtract the difference from the relocation amount since we can't
         add it to the offset.  */
d1852 3
a1854 1
	relocation -= bfd_get_reloc_size(howto);
@


1.4
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d545 1
a545 1
  if (elf_elfheader (abfd)->e_flags & EF_NONPIC)
d548 1
a548 1
  if (elf_elfheader (abfd)->e_flags & EF_DFLOAT)
d551 1
a551 1
  if (elf_elfheader (abfd)->e_flags & EF_GFLOAT)
@


1.3
log
@	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Remove
	ATTRIBUTE_UNUSED on used params.
	* elf32-vax.c (elf_vax_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
@
text
@d41 1
a41 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d858 2
a859 2
elf_vax_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d889 1
a889 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.3.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@@


1.3.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d41 1
a41 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d545 1
a545 1
  if (elf_elfheader (abfd)->e_flags & EF_VAX_NONPIC)
d548 1
a548 1
  if (elf_elfheader (abfd)->e_flags & EF_VAX_DFLOAT)
d551 1
a551 1
  if (elf_elfheader (abfd)->e_flags & EF_VAX_GFLOAT)
d858 2
a859 2
elf_vax_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d889 3
a891 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
@


1.3.4.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d344 2
a1421 3
  if (info->relocateable)
    return true;

d1453 21
a1474 1
      r_symndx = ELF32_R_SYM (rel->r_info);
a2210 1
#define elf_backend_rela_normal		1
@


1.3.4.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@a419 5
/* Declare this now that the above structures are defined.  */

static boolean elf_vax_instantiate_got_entries
  PARAMS ((struct elf_link_hash_entry *, PTR));

d570 1
d583 1
d654 12
d903 1
d908 2
d913 1
d919 3
d933 23
a955 1
		--h->got.refcount;
d1222 2
a1223 9
				elf_vax_discard_copies,
				(PTR) NULL);

  /* If this is a -Bsymbolic shared link or a static link, we need to 
     discard all the got entries we've recorded.  Otherwise, we need to
     instantiate (allocate space for them).  */
  elf_link_hash_traverse (elf_hash_table (info),
			  elf_vax_instantiate_got_entries,
			  (PTR) info);
a1392 54
/* This function is called via elf_link_hash_traverse.  It looks for entries
   that have GOT or PLT (.GOT) references.  If creating a static object or a
   shared object with -Bsymbolic, it resets the reference count back to 0
   and sets the offset to -1 so normal PC32 relocation will be done.  If
   creating a shared object or executable, space in the .got and .rela.got
   will be reserved for the symbol.  */

/*ARGSUSED*/
static boolean
elf_vax_instantiate_got_entries (h, infoptr)
     struct elf_link_hash_entry *h;
     PTR infoptr;
{
  struct bfd_link_info *info = (struct bfd_link_info *) infoptr;
  bfd *dynobj;
  asection *sgot;
  asection *srelgot;
  
  /* We don't care about non-GOT (and non-PLT) entries.  */
  if (h->got.refcount <= 0 && h->plt.refcount <= 0)
    return true;

  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return true;

  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");

  if (!elf_hash_table (info)->dynamic_sections_created
      || (info->shared && info->symbolic))
    {
      h->got.refcount = 0;
      h->got.offset = (bfd_vma) -1;
      h->plt.refcount = 0;
      h->plt.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (!bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      /* Allocate space in the .got and .rela.got sections.  */
      sgot->_raw_size += 4;
      srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }

  return true;
}

d1540 2
a1541 1
	  if (h == NULL || h->got.offset == (bfd_vma) -1)
d1550 12
a1570 1
	    BFD_ASSERT (off < sgot->_raw_size);
d1599 1
a1599 1
	    /* The GOT relocation uses the addend.  */
d1602 6
a1607 3
	    /* Change the reference to be indirect.  */
	    contents[rel->r_offset - 1] |= 0x10;
	    relocation += sgot->output_section->vma;
d1831 1
a1831 3
      /* VAX PCREL relocations are from the end of relocation, not the start.  
         So subtract the difference from the relocation amount since we can't
         add it to the offset.  */
d1833 3
a1835 1
	relocation -= bfd_get_reloc_size(howto);
@


1.3.2.1
log
@merge from trunk
@
text
@@


1.2
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d890 1
a890 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
@


1.1
log
@2002-05-29  Matt Thomas  <matt@@3am-software.com>

* Makefile.am (BFD32_BACKENDS): Add elf32-vax.lo.
(BFD32_BACKENDS_CFILES): Add elf32-vax.c.
(elf32-vax.lo): New rule.
* Makefile.in: Regenerate.
* configure.in (bfd_elf32_vax_vec)
(vaxnetbsd_vec): New vectors.
* configure: Regenerate.
* config.bfd (vax-*-netbsdelf*)
(vax-*-netbsdaout*)
(vax-*-netbsd*): New targets.
* elf32-vax.c: New file.
* reloc.c: Add VAX relocations.
* bfd-in2.h: Regenerate.
* targets.c (_bfd_target_vector): Add bfd_elf32_vax_vec.
@
text
@d678 1
a678 1
		
d1585 1
a1585 1
		   Change the GOT32 entry to a PC32 entry. */
d1676 1
a1676 1
	     of the plt itself. */
d1812 1
a1812 1
			   ".text") != 0 || 
d2161 1
a2161 1
          elf_section_data (splt->output_section)->this_hdr.sh_entsize 
@

