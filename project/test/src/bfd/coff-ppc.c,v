head	1.45;
access;
symbols
	sid-snapshot-20180601:1.45
	sid-snapshot-20180501:1.45
	sid-snapshot-20180401:1.45
	sid-snapshot-20180301:1.45
	sid-snapshot-20180201:1.45
	sid-snapshot-20180101:1.45
	sid-snapshot-20171201:1.45
	sid-snapshot-20171101:1.45
	sid-snapshot-20171001:1.45
	sid-snapshot-20170901:1.45
	sid-snapshot-20170801:1.45
	sid-snapshot-20170701:1.45
	sid-snapshot-20170601:1.45
	sid-snapshot-20170501:1.45
	sid-snapshot-20170401:1.45
	sid-snapshot-20170301:1.45
	sid-snapshot-20170201:1.45
	sid-snapshot-20170101:1.45
	sid-snapshot-20161201:1.45
	sid-snapshot-20161101:1.45
	sid-snapshot-20160901:1.45
	sid-snapshot-20160801:1.45
	sid-snapshot-20160701:1.45
	sid-snapshot-20160601:1.45
	sid-snapshot-20160501:1.45
	sid-snapshot-20160401:1.45
	sid-snapshot-20160301:1.45
	sid-snapshot-20160201:1.45
	sid-snapshot-20160101:1.45
	sid-snapshot-20151201:1.45
	sid-snapshot-20151101:1.45
	sid-snapshot-20151001:1.45
	sid-snapshot-20150901:1.45
	sid-snapshot-20150801:1.45
	sid-snapshot-20150701:1.45
	sid-snapshot-20150601:1.45
	sid-snapshot-20150501:1.45
	sid-snapshot-20150401:1.45
	sid-snapshot-20150301:1.45
	sid-snapshot-20150201:1.45
	sid-snapshot-20150101:1.45
	sid-snapshot-20141201:1.45
	sid-snapshot-20141101:1.45
	sid-snapshot-20141001:1.45
	sid-snapshot-20140901:1.45
	sid-snapshot-20140801:1.45
	sid-snapshot-20140701:1.45
	sid-snapshot-20140601:1.45
	sid-snapshot-20140501:1.45
	sid-snapshot-20140401:1.45
	sid-snapshot-20140301:1.45
	sid-snapshot-20140201:1.45
	sid-snapshot-20140101:1.45
	sid-snapshot-20131201:1.45
	sid-snapshot-20131101:1.45
	sid-snapshot-20131001:1.45
	binutils-2_24-branch:1.45.0.4
	binutils-2_24-branchpoint:1.45
	binutils-2_21_1:1.38.4.1
	sid-snapshot-20130901:1.45
	gdb_7_6_1-2013-08-30-release:1.45
	sid-snapshot-20130801:1.45
	sid-snapshot-20130701:1.45
	sid-snapshot-20130601:1.45
	sid-snapshot-20130501:1.45
	gdb_7_6-2013-04-26-release:1.45
	sid-snapshot-20130401:1.45
	binutils-2_23_2:1.43
	gdb_7_6-branch:1.45.0.2
	gdb_7_6-2013-03-12-branchpoint:1.45
	sid-snapshot-20130301:1.45
	sid-snapshot-20130201:1.45
	sid-snapshot-20130101:1.44
	sid-snapshot-20121201:1.44
	gdb_7_5_1-2012-11-29-release:1.43
	binutils-2_23_1:1.43
	sid-snapshot-20121101:1.43
	binutils-2_23:1.43
	sid-snapshot-20121001:1.43
	sid-snapshot-20120901:1.43
	gdb_7_5-2012-08-17-release:1.43
	sid-snapshot-20120801:1.43
	binutils-2_23-branch:1.43.0.4
	binutils-2_23-branchpoint:1.43
	gdb_7_5-branch:1.43.0.2
	gdb_7_5-2012-07-18-branchpoint:1.43
	sid-snapshot-20120701:1.42
	sid-snapshot-20120601:1.42
	sid-snapshot-20120501:1.41
	binutils-2_22_branch:1.41.0.6
	gdb_7_4_1-2012-04-26-release:1.41
	sid-snapshot-20120401:1.41
	sid-snapshot-20120301:1.41
	sid-snapshot-20120201:1.41
	gdb_7_4-2012-01-24-release:1.41
	sid-snapshot-20120101:1.41
	gdb_7_4-branch:1.41.0.4
	gdb_7_4-2011-12-13-branchpoint:1.41
	sid-snapshot-20111201:1.41
	binutils-2_22:1.41
	sid-snapshot-20111101:1.41
	sid-snapshot-20111001:1.41
	binutils-2_22-branch:1.41.0.2
	binutils-2_22-branchpoint:1.41
	gdb_7_3_1-2011-09-04-release:1.39
	sid-snapshot-20110901:1.41
	sid-snapshot-20110801:1.41
	gdb_7_3-2011-07-26-release:1.39
	sid-snapshot-20110701:1.41
	sid-snapshot-20110601:1.39
	sid-snapshot-20110501:1.39
	gdb_7_3-branch:1.39.0.2
	gdb_7_3-2011-04-01-branchpoint:1.39
	sid-snapshot-20110401:1.39
	sid-snapshot-20110301:1.39
	sid-snapshot-20110201:1.39
	sid-snapshot-20110101:1.38
	binutils-2_21:1.38
	sid-snapshot-20101201:1.38
	binutils-2_21-branch:1.38.0.4
	binutils-2_21-branchpoint:1.38
	sid-snapshot-20101101:1.38
	sid-snapshot-20101001:1.38
	binutils-2_20_1:1.37
	gdb_7_2-2010-09-02-release:1.38
	sid-snapshot-20100901:1.38
	sid-snapshot-20100801:1.38
	gdb_7_2-branch:1.38.0.2
	gdb_7_2-2010-07-07-branchpoint:1.38
	sid-snapshot-20100701:1.38
	sid-snapshot-20100601:1.37
	sid-snapshot-20100501:1.37
	sid-snapshot-20100401:1.37
	gdb_7_1-2010-03-18-release:1.37
	sid-snapshot-20100301:1.37
	gdb_7_1-branch:1.37.0.10
	gdb_7_1-2010-02-18-branchpoint:1.37
	sid-snapshot-20100201:1.37
	sid-snapshot-20100101:1.37
	gdb_7_0_1-2009-12-22-release:1.37
	sid-snapshot-20091201:1.37
	sid-snapshot-20091101:1.37
	binutils-2_20:1.37
	gdb_7_0-2009-10-06-release:1.37
	sid-snapshot-20091001:1.37
	gdb_7_0-branch:1.37.0.8
	gdb_7_0-2009-09-16-branchpoint:1.37
	arc-sim-20090309:1.34
	binutils-arc-20081103-branch:1.35.0.12
	binutils-arc-20081103-branchpoint:1.35
	binutils-2_20-branch:1.37.0.6
	binutils-2_20-branchpoint:1.37
	sid-snapshot-20090901:1.37
	sid-snapshot-20090801:1.37
	msnyder-checkpoint-072509-branch:1.37.0.4
	msnyder-checkpoint-072509-branchpoint:1.37
	sid-snapshot-20090701:1.37
	dje-cgen-play1-branch:1.37.0.2
	dje-cgen-play1-branchpoint:1.37
	sid-snapshot-20090601:1.37
	sid-snapshot-20090501:1.37
	sid-snapshot-20090401:1.37
	arc-20081103-branch:1.35.0.10
	arc-20081103-branchpoint:1.35
	arc-insight_6_8-branch:1.34.0.10
	arc-insight_6_8-branchpoint:1.34
	insight_6_8-branch:1.34.0.8
	insight_6_8-branchpoint:1.34
	sid-snapshot-20090301:1.37
	binutils-2_19_1:1.35
	sid-snapshot-20090201:1.37
	sid-snapshot-20090101:1.35
	reverse-20081226-branch:1.35.0.8
	reverse-20081226-branchpoint:1.35
	sid-snapshot-20081201:1.35
	multiprocess-20081120-branch:1.35.0.6
	multiprocess-20081120-branchpoint:1.35
	sid-snapshot-20081101:1.35
	binutils-2_19:1.35
	sid-snapshot-20081001:1.35
	reverse-20080930-branch:1.35.0.4
	reverse-20080930-branchpoint:1.35
	binutils-2_19-branch:1.35.0.2
	binutils-2_19-branchpoint:1.35
	sid-snapshot-20080901:1.35
	sid-snapshot-20080801:1.35
	reverse-20080717-branch:1.34.0.6
	reverse-20080717-branchpoint:1.34
	sid-snapshot-20080701:1.34
	msnyder-reverse-20080609-branch:1.34.0.4
	msnyder-reverse-20080609-branchpoint:1.34
	drow-reverse-20070409-branch:1.31.0.2
	drow-reverse-20070409-branchpoint:1.31
	sid-snapshot-20080601:1.34
	sid-snapshot-20080501:1.34
	sid-snapshot-20080403:1.34
	sid-snapshot-20080401:1.34
	gdb_6_8-2008-03-27-release:1.34
	sid-snapshot-20080301:1.34
	gdb_6_8-branch:1.34.0.2
	gdb_6_8-2008-02-26-branchpoint:1.34
	sid-snapshot-20080201:1.34
	sid-snapshot-20080101:1.34
	sid-snapshot-20071201:1.34
	sid-snapshot-20071101:1.34
	gdb_6_7_1-2007-10-29-release:1.33
	gdb_6_7-2007-10-10-release:1.33
	sid-snapshot-20071001:1.33
	gdb_6_7-branch:1.33.0.4
	gdb_6_7-2007-09-07-branchpoint:1.33
	binutils-2_18:1.33
	binutils-2_18-branch:1.33.0.2
	binutils-2_18-branchpoint:1.33
	insight_6_6-20070208-release:1.30
	binutils-csl-coldfire-4_1-32:1.29
	binutils-csl-sourcerygxx-4_1-32:1.29
	gdb_6_6-2006-12-18-release:1.30
	binutils-csl-innovasic-fido-3_4_4-33:1.29
	binutils-csl-sourcerygxx-3_4_4-32:1.25
	binutils-csl-coldfire-4_1-30:1.29
	binutils-csl-sourcerygxx-4_1-30:1.29
	binutils-csl-coldfire-4_1-28:1.29
	binutils-csl-sourcerygxx-4_1-29:1.29
	binutils-csl-sourcerygxx-4_1-28:1.29
	gdb_6_6-branch:1.30.0.2
	gdb_6_6-2006-11-15-branchpoint:1.30
	binutils-csl-arm-2006q3-27:1.29
	binutils-csl-sourcerygxx-4_1-27:1.29
	binutils-csl-arm-2006q3-26:1.29
	binutils-csl-sourcerygxx-4_1-26:1.29
	binutils-csl-sourcerygxx-4_1-25:1.29
	binutils-csl-sourcerygxx-4_1-24:1.29
	binutils-csl-sourcerygxx-4_1-23:1.29
	insight_6_5-20061003-release:1.29
	gdb-csl-symbian-6_4_50_20060226-12:1.28
	binutils-csl-sourcerygxx-4_1-21:1.29
	binutils-csl-arm-2006q3-21:1.29
	binutils-csl-sourcerygxx-4_1-22:1.29
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.29
	binutils-csl-sourcerygxx-4_1-20:1.29
	binutils-csl-arm-2006q3-19:1.29
	binutils-csl-sourcerygxx-4_1-19:1.29
	binutils-csl-sourcerygxx-4_1-18:1.29
	binutils-csl-renesas-4_1-9:1.29
	gdb-csl-sourcerygxx-3_4_4-25:1.28
	binutils-csl-sourcerygxx-3_4_4-25:1.25
	nickrob-async-20060828-mergepoint:1.29
	gdb-csl-symbian-6_4_50_20060226-11:1.28
	binutils-csl-renesas-4_1-8:1.29
	binutils-csl-renesas-4_1-7:1.29
	binutils-csl-renesas-4_1-6:1.29
	gdb-csl-sourcerygxx-4_1-17:1.28
	binutils-csl-sourcerygxx-4_1-17:1.29
	gdb-csl-20060226-branch-local-2:1.28
	gdb-csl-sourcerygxx-4_1-14:1.28
	binutils-csl-sourcerygxx-4_1-14:1.29
	binutils-csl-sourcerygxx-4_1-15:1.29
	gdb-csl-sourcerygxx-4_1-13:1.28
	binutils-csl-sourcerygxx-4_1-13:1.29
	binutils-2_17:1.29
	gdb-csl-sourcerygxx-4_1-12:1.28
	binutils-csl-sourcerygxx-4_1-12:1.29
	gdb-csl-sourcerygxx-3_4_4-21:1.28
	binutils-csl-sourcerygxx-3_4_4-21:1.29
	gdb_6_5-20060621-release:1.29
	binutils-csl-wrs-linux-3_4_4-24:1.25
	binutils-csl-wrs-linux-3_4_4-23:1.25
	gdb-csl-sourcerygxx-4_1-9:1.28
	binutils-csl-sourcerygxx-4_1-9:1.29
	gdb-csl-sourcerygxx-4_1-8:1.28
	binutils-csl-sourcerygxx-4_1-8:1.29
	gdb-csl-sourcerygxx-4_1-7:1.28
	binutils-csl-sourcerygxx-4_1-7:1.29
	gdb-csl-arm-2006q1-6:1.28
	binutils-csl-arm-2006q1-6:1.29
	gdb-csl-sourcerygxx-4_1-6:1.28
	binutils-csl-sourcerygxx-4_1-6:1.29
	binutils-csl-wrs-linux-3_4_4-22:1.25
	gdb-csl-symbian-6_4_50_20060226-10:1.28
	gdb-csl-symbian-6_4_50_20060226-9:1.28
	gdb-csl-symbian-6_4_50_20060226-8:1.28
	gdb-csl-coldfire-4_1-11:1.28
	binutils-csl-coldfire-4_1-11:1.29
	gdb-csl-sourcerygxx-3_4_4-19:1.28
	binutils-csl-sourcerygxx-3_4_4-19:1.29
	gdb-csl-coldfire-4_1-10:1.28
	gdb_6_5-branch:1.29.0.14
	gdb_6_5-2006-05-14-branchpoint:1.29
	binutils-csl-coldfire-4_1-10:1.29
	gdb-csl-sourcerygxx-4_1-5:1.28
	binutils-csl-sourcerygxx-4_1-5:1.29
	nickrob-async-20060513-branch:1.29.0.12
	nickrob-async-20060513-branchpoint:1.29
	gdb-csl-sourcerygxx-4_1-4:1.28
	binutils-csl-sourcerygxx-4_1-4:1.29
	msnyder-reverse-20060502-branch:1.29.0.10
	msnyder-reverse-20060502-branchpoint:1.29
	binutils-csl-wrs-linux-3_4_4-21:1.25
	gdb-csl-morpho-4_1-4:1.28
	binutils-csl-morpho-4_1-4:1.29
	gdb-csl-sourcerygxx-3_4_4-17:1.28
	binutils-csl-sourcerygxx-3_4_4-17:1.29
	binutils-csl-wrs-linux-3_4_4-20:1.25
	readline_5_1-import-branch:1.29.0.8
	readline_5_1-import-branchpoint:1.29
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.28
	binutils-2_17-branch:1.29.0.6
	binutils-2_17-branchpoint:1.29
	gdb-csl-symbian-20060226-branch:1.28.0.16
	gdb-csl-symbian-20060226-branchpoint:1.28
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.28
	msnyder-reverse-20060331-branch:1.29.0.4
	msnyder-reverse-20060331-branchpoint:1.29
	binutils-csl-2_17-branch:1.29.0.2
	binutils-csl-2_17-branchpoint:1.29
	gdb-csl-available-20060303-branch:1.28.0.14
	gdb-csl-available-20060303-branchpoint:1.28
	gdb-csl-20060226-branch:1.28.0.12
	gdb-csl-20060226-branchpoint:1.28
	gdb_6_4-20051202-release:1.28
	msnyder-fork-checkpoint-branch:1.28.0.10
	msnyder-fork-checkpoint-branchpoint:1.28
	gdb-csl-gxxpro-6_3-branch:1.28.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.28
	gdb_6_4-branch:1.28.0.6
	gdb_6_4-2005-11-01-branchpoint:1.28
	gdb-csl-arm-20051020-branch:1.28.0.4
	gdb-csl-arm-20051020-branchpoint:1.28
	binutils-csl-gxxpro-3_4-branch:1.25.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.25
	binutils-2_16_1:1.25
	msnyder-tracepoint-checkpoint-branch:1.28.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.28
	gdb-csl-arm-20050325-2005-q1b:1.25
	binutils-csl-arm-2005q1b:1.25
	binutils-2_16:1.25
	gdb-csl-arm-20050325-2005-q1a:1.25
	binutils-csl-arm-2005q1a:1.25
	csl-arm-20050325-branch:1.25.0.6
	csl-arm-20050325-branchpoint:1.25
	binutils-csl-arm-2005q1-branch:1.25.0.4
	binutils-csl-arm-2005q1-branchpoint:1.25
	binutils-2_16-branch:1.25.0.2
	binutils-2_16-branchpoint:1.25
	csl-arm-2004-q3d:1.23
	gdb_6_3-20041109-release:1.22
	gdb_6_3-branch:1.22.0.2
	gdb_6_3-20041019-branchpoint:1.22
	csl-arm-2004-q3:1.22
	drow_intercu-merge-20040921:1.22
	drow_intercu-merge-20040915:1.22
	jimb-gdb_6_2-e500-branch:1.21.0.6
	jimb-gdb_6_2-e500-branchpoint:1.21
	gdb_6_2-20040730-release:1.21
	gdb_6_2-branch:1.21.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.21
	gdb_6_1_1-20040616-release:1.19
	binutils-2_15:1.19
	binutils-2_15-branchpoint:1.19
	csl-arm-2004-q1a:1.19
	csl-arm-2004-q1:1.19
	gdb_6_1-2004-04-05-release:1.19
	drow_intercu-merge-20040402:1.19
	drow_intercu-merge-20040327:1.19
	ezannoni_pie-20040323-branch:1.19.0.14
	ezannoni_pie-20040323-branchpoint:1.19
	cagney_tramp-20040321-mergepoint:1.19
	cagney_tramp-20040309-branch:1.19.0.12
	cagney_tramp-20040309-branchpoint:1.19
	gdb_6_1-branch:1.19.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.19
	drow_intercu-20040221-branch:1.19.0.8
	drow_intercu-20040221-branchpoint:1.19
	binutils-2_15-branch:1.19.0.6
	cagney_bfdfile-20040213-branch:1.19.0.4
	cagney_bfdfile-20040213-branchpoint:1.19
	drow-cplus-merge-20040208:1.19
	carlton_dictionary-20040126-merge:1.19
	cagney_bigcore-20040122-branch:1.19.0.2
	cagney_bigcore-20040122-branchpoint:1.19
	drow-cplus-merge-20040113:1.19
	csl-arm-2003-q4:1.19
	drow-cplus-merge-20031224:1.19
	drow-cplus-merge-20031220:1.19
	carlton_dictionary-20031215-merge:1.19
	drow-cplus-merge-20031214:1.19
	carlton-dictionary-20031111-merge:1.18
	gdb_6_0-2003-10-04-release:1.17
	kettenis_sparc-20030918-branch:1.18.0.6
	kettenis_sparc-20030918-branchpoint:1.18
	carlton_dictionary-20030917-merge:1.18
	ezannoni_pie-20030916-branchpoint:1.18
	ezannoni_pie-20030916-branch:1.18.0.4
	cagney_x86i386-20030821-branch:1.18.0.2
	cagney_x86i386-20030821-branchpoint:1.18
	carlton_dictionary-20030805-merge:1.18
	carlton_dictionary-20030627-merge:1.18
	gdb_6_0-branch:1.17.0.32
	gdb_6_0-2003-06-23-branchpoint:1.17
	jimb-ppc64-linux-20030613-branch:1.17.0.30
	jimb-ppc64-linux-20030613-branchpoint:1.17
	binutils-2_14:1.17
	cagney_convert-20030606-branch:1.17.0.28
	cagney_convert-20030606-branchpoint:1.17
	cagney_writestrings-20030508-branch:1.17.0.26
	cagney_writestrings-20030508-branchpoint:1.17
	jimb-ppc64-linux-20030528-branch:1.17.0.24
	jimb-ppc64-linux-20030528-branchpoint:1.17
	carlton_dictionary-20030523-merge:1.17
	cagney_fileio-20030521-branch:1.17.0.22
	cagney_fileio-20030521-branchpoint:1.17
	kettenis_i386newframe-20030517-mergepoint:1.17
	jimb-ppc64-linux-20030509-branch:1.17.0.20
	jimb-ppc64-linux-20030509-branchpoint:1.17
	kettenis_i386newframe-20030504-mergepoint:1.17
	carlton_dictionary-20030430-merge:1.17
	binutils-2_14-branch:1.17.0.18
	binutils-2_14-branchpoint:1.17
	kettenis_i386newframe-20030419-branch:1.17.0.16
	kettenis_i386newframe-20030419-branchpoint:1.17
	carlton_dictionary-20030416-merge:1.17
	cagney_frameaddr-20030409-mergepoint:1.17
	kettenis_i386newframe-20030406-branch:1.17.0.14
	kettenis_i386newframe-20030406-branchpoint:1.17
	cagney_frameaddr-20030403-branchpoint:1.17
	cagney_frameaddr-20030403-branch:1.17.0.12
	cagney_framebase-20030330-mergepoint:1.17
	cagney_framebase-20030326-branch:1.17.0.10
	cagney_framebase-20030326-branchpoint:1.17
	cagney_lazyid-20030317-branch:1.17.0.8
	cagney_lazyid-20030317-branchpoint:1.17
	kettenis-i386newframe-20030316-mergepoint:1.17
	offbyone-20030313-branch:1.17.0.6
	offbyone-20030313-branchpoint:1.17
	kettenis-i386newframe-20030308-branch:1.17.0.4
	kettenis-i386newframe-20030308-branchpoint:1.17
	carlton_dictionary-20030305-merge:1.17
	cagney_offbyone-20030303-branch:1.17.0.2
	cagney_offbyone-20030303-branchpoint:1.17
	carlton_dictionary-20030207-merge:1.16
	interps-20030202-branch:1.16.0.4
	interps-20030202-branchpoint:1.16
	cagney-unwind-20030108-branch:1.16.0.2
	cagney-unwind-20030108-branchpoint:1.16
	binutils-2_13_2_1:1.15
	binutils-2_13_2:1.15
	carlton_dictionary-20021223-merge:1.16
	gdb_5_3-2002-12-12-release:1.15
	carlton_dictionary-20021115-merge:1.15
	binutils-2_13_1:1.15
	kseitz_interps-20021105-merge:1.15
	kseitz_interps-20021103-merge:1.15
	drow-cplus-merge-20021020:1.15
	drow-cplus-merge-20021025:1.15
	carlton_dictionary-20021025-merge:1.15
	carlton_dictionary-20021011-merge:1.15
	drow-cplus-branch:1.15.0.20
	drow-cplus-branchpoint:1.15
	kseitz_interps-20020930-merge:1.15
	carlton_dictionary-20020927-merge:1.15
	carlton_dictionary-branch:1.15.0.18
	carlton_dictionary-20020920-branchpoint:1.15
	sid-20020905-branchpoint:1.15
	sid-20020905-branch:1.15.0.16
	gdb_5_3-branch:1.15.0.14
	gdb_5_3-2002-09-04-branchpoint:1.15
	kseitz_interps-20020829-merge:1.15
	cagney_sysregs-20020825-branch:1.15.0.12
	cagney_sysregs-20020825-branchpoint:1.15
	readline_4_3-import-branch:1.15.0.10
	readline_4_3-import-branchpoint:1.15
	binutils-2_13:1.15
	gdb_5_2_1-2002-07-23-release:1.14
	binutils-2_13-branchpoint:1.15
	binutils-2_13-branch:1.15.0.8
	kseitz_interps-20020528-branch:1.15.0.6
	kseitz_interps-20020528-branchpoint:1.15
	cagney_regbuf-20020515-branch:1.15.0.4
	cagney_regbuf-20020515-branchpoint:1.15
	binutils-2_12_1:1.14
	jimb-macro-020506-branch:1.15.0.2
	jimb-macro-020506-branchpoint:1.15
	gdb_5_2-2002-04-29-release:1.14
	binutils-2_12:1.14
	gdb_5_2-branch:1.14.0.4
	gdb_5_2-2002-03-03-branchpoint:1.14
	binutils-2_12-branch:1.14.0.2
	binutils-2_12-branchpoint:1.14
	gdb_5_1_1-2002-01-24-release:1.11
	gdb_5_1_0_1-2002-01-03-release:1.11
	cygnus_cvs_20020108_pre:1.14
	gdb_5_1_0_1-2002-01-03-branch:1.11.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.11
	gdb_5_1-2001-11-21-release:1.11
	gdb_s390-2001-09-26-branch:1.11.0.4
	gdb_s390-2001-09-26-branchpoint:1.11
	gdb_5_1-2001-07-29-branch:1.11.0.2
	gdb_5_1-2001-07-29-branchpoint:1.11
	binutils-2_11_2:1.10.2.1
	binutils-2_11_1:1.10.2.1
	binutils-2_11:1.10
	x86_64versiong3:1.10
	binutils-2_11-branch:1.10.0.2
	insight-precleanup-2001-01-01:1.9
	binutils-2_10_1:1.6
	binutils-2_10:1.6
	gdb-premipsmulti-2000-06-06-branch:1.6.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.6
	gdb_5_0-2000-05-19-release:1.6
	gdb_4_18_2-2000-05-18-release:1.6
	gdb_4_95_1-2000-05-11-snapshot:1.6
	gdb_4_95_0-2000-04-27-snapshot:1.6
	gdb_5_0-2000-04-10-branch:1.6.0.4
	gdb_5_0-2000-04-10-branchpoint:1.6
	binutils-2_10-branch:1.6.0.2
	binutils-2_10-branchpoint:1.6
	binutils_latest_snapshot:1.45
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2012.11.06.06.36.42;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2012.07.13.14.22.44;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2012.05.01.16.07.33;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2011.06.13.00.59.09;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2011.06.06.01.26.01;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.14.12.35.56;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches
	1.38.4.1;
next	1.37;

1.37
date	2009.01.03.16.19.52;	author hjl;	state Exp;
branches;
next	1.36;

1.36
date	2009.01.02.16.11.37;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.15.02.00.11;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2007.03.26.12.22.59;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.04.15.53.03;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.04.11.00.08;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.03.11.40.57;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.31.23.13.16;	author bje;	state Exp;
branches;
next	1.23;

1.23
date	2004.10.21.15.28.16;	author hjl;	state Exp;
branches;
next	1.22;

1.22
date	2004.08.13.03.15.56;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2004.06.28.13.57.58;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2004.06.24.04.46.15;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.24.18.06.40;	author kazu;	state Exp;
branches
	1.19.8.1;
next	1.18;

1.18
date	2003.06.25.06.40.18;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2003.02.20.18.59.32;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.30.08.39.35;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.04.19.53.35;	author drow;	state Exp;
branches
	1.15.18.1
	1.15.20.1;
next	1.14;

1.14
date	2001.09.21.14.25.08;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.20.23.30.34;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.23.11.45.52;	author kazu;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.11.22.01.08.53;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.15.20.20.52;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.14.19.23.49;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	99.09.11.23.38.11;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.09.11.21.39.03;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.07.19.14.55.15;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.10.28.41;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.38.4.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	;

1.19.8.1
date	2004.09.16.17.00.13;	author drow;	state Exp;
branches;
next	;

1.15.18.1
date	2002.12.23.19.37.27;	author carlton;	state Exp;
branches;
next	1.15.18.2;

1.15.18.2
date	2003.03.06.00.56.13;	author carlton;	state Exp;
branches;
next	1.15.18.3;

1.15.18.3
date	2003.06.27.21.49.06;	author carlton;	state Exp;
branches;
next	1.15.18.4;

1.15.18.4
date	2003.12.15.23.59.13;	author carlton;	state Exp;
branches;
next	;

1.15.20.1
date	2003.12.14.20.26.34;	author drow;	state Exp;
branches;
next	;

1.10.2.1
date	2001.06.07.03.08.23;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* BFD back-end for PowerPC Microsoft Portable Executable files.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
   2012  Free Software Foundation, Inc.

   Original version pieced together by Kim Knuttila (krk@@cygnus.com)

   There is nothing new under the sun. This file draws a lot on other
   coff files, in particular, those for the rs/6000, alpha, mips, and
   intel backends, and the PE work for the arm.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/* Current State:
   - objdump works
   - relocs generated by gas
   - ld will link files, but they do not run.
   - dlltool will not produce correct output in some .reloc cases, and will
     not produce the right glue code for dll function calls.  */

#include "sysdep.h"
#include "bfd.h"
#include "libbfd.h"

#include "coff/powerpc.h"
#include "coff/internal.h"

#include "coff/pe.h"

#ifdef BADMAG
#undef BADMAG
#endif

#define BADMAG(x) PPCBADMAG(x)

#include "libcoff.h"

/* This file is compiled more than once, but we only compile the
   final_link routine once.  */
extern bfd_boolean ppc_bfd_coff_final_link (bfd *, struct bfd_link_info *);
extern void dump_toc (void *);

/* The toc is a set of bfd_vma fields. We use the fact that valid
   addresses are even (i.e. the bit representing "1" is off) to allow
   us to encode a little extra information in the field
   - Unallocated addresses are initialized to 1.
   - Allocated addresses are even numbers.
   The first time we actually write a reference to the toc in the bfd,
   we want to record that fact in a fixup file (if it is asked for), so
   we keep track of whether or not an address has been written by marking
   the low order bit with a "1" upon writing.  */

#define SET_UNALLOCATED(x)  ((x) = 1)
#define IS_UNALLOCATED(x)   ((x) == 1)

#define IS_WRITTEN(x)       ((x) & 1)
#define MARK_AS_WRITTEN(x)  ((x) |= 1)
#define MAKE_ADDR_AGAIN(x)  ((x) &= ~1)

/* Turn on this check if you suspect something amiss in the hash tables.  */
#ifdef DEBUG_HASH

/* Need a 7 char string for an eye catcher.  */
#define EYE "krkjunk"

#define HASH_CHECK_DCL char eye_catcher[8];
#define HASH_CHECK_INIT(ret)      strcpy(ret->eye_catcher, EYE)
#define HASH_CHECK(addr) \
 if (strcmp(addr->eye_catcher, EYE) != 0) \
  { \
    fprintf (stderr,\
    _("File %s, line %d, Hash check failure, bad eye %8s\n"), \
    __FILE__, __LINE__, addr->eye_catcher); \
    abort (); \
 }

#else

#define HASH_CHECK_DCL
#define HASH_CHECK_INIT(ret)
#define HASH_CHECK(addr)

#endif

/* In order not to add an int to every hash table item for every coff
   linker, we define our own hash table, derived from the coff one.  */

/* PE linker hash table entries.  */

struct ppc_coff_link_hash_entry
{
  struct coff_link_hash_entry root; /* First entry, as required.  */

  /* As we wonder around the relocs, we'll keep the assigned toc_offset
     here.  */
  bfd_vma toc_offset;               /* Our addition, as required.  */
  int symbol_is_glue;
  unsigned long int glue_insn;

  HASH_CHECK_DCL
};

/* PE linker hash table.  */

struct ppc_coff_link_hash_table
{
  struct coff_link_hash_table root; /* First entry, as required.  */
};

/* Routine to create an entry in the link hash table.  */

static struct bfd_hash_entry *
ppc_coff_link_hash_newfunc (struct bfd_hash_entry * entry,
			    struct bfd_hash_table * table,
			    const char * string)
{
  struct ppc_coff_link_hash_entry *ret =
    (struct ppc_coff_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct ppc_coff_link_hash_entry *) NULL)
    ret = (struct ppc_coff_link_hash_entry *)
      bfd_hash_allocate (table,
			 sizeof (struct ppc_coff_link_hash_entry));

  if (ret == (struct ppc_coff_link_hash_entry *) NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct ppc_coff_link_hash_entry *)
	 _bfd_coff_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				      table, string));

  if (ret)
    {
      /* Initialize the local fields.  */
      SET_UNALLOCATED (ret->toc_offset);
      ret->symbol_is_glue = 0;
      ret->glue_insn = 0;

      HASH_CHECK_INIT (ret);
    }

  return (struct bfd_hash_entry *) ret;
}

/* Initialize a PE linker hash table.  */

static bfd_boolean
ppc_coff_link_hash_table_init (struct ppc_coff_link_hash_table *table,
			       bfd *abfd,
			       struct bfd_hash_entry *(*newfunc)
			         (struct bfd_hash_entry *,
				  struct bfd_hash_table *,
				  const char *),
			       unsigned int entsize)
{
  return _bfd_coff_link_hash_table_init (&table->root, abfd, newfunc, entsize);
}

/* Create a PE linker hash table.  */

static struct bfd_link_hash_table *
ppc_coff_link_hash_table_create (bfd *abfd)
{
  struct ppc_coff_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct ppc_coff_link_hash_table);

  ret = (struct ppc_coff_link_hash_table *) bfd_malloc (amt);
  if (ret == NULL)
    return NULL;
  if (!ppc_coff_link_hash_table_init (ret, abfd,
				      ppc_coff_link_hash_newfunc,
				      sizeof (struct ppc_coff_link_hash_entry)))
    {
      free (ret);
      return (struct bfd_link_hash_table *) NULL;
    }
  return &ret->root.root;
}

/* Now, tailor coffcode.h to use our hash stuff.  */

#define coff_bfd_link_hash_table_create ppc_coff_link_hash_table_create

/* The nt loader points the toc register to &toc + 32768, in order to
   use the complete range of a 16-bit displacement. We have to adjust
   for this when we fix up loads displaced off the toc reg.  */
#define TOC_LOAD_ADJUSTMENT (-32768)
#define TOC_SECTION_NAME ".private.toc"

/* The main body of code is in coffcode.h.  */

#define COFF_DEFAULT_SECTION_ALIGNMENT_POWER (3)

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value
   from smaller values.  Start with zero, widen, *then* decrement.  */
#define MINUS_ONE	(((bfd_vma)0) - 1)

/* These should definitely go in a header file somewhere...  */

/* NOP */
#define IMAGE_REL_PPC_ABSOLUTE          0x0000

/* 64-bit address */
#define IMAGE_REL_PPC_ADDR64            0x0001

/* 32-bit address */
#define IMAGE_REL_PPC_ADDR32            0x0002

/* 26-bit address, shifted left 2 (branch absolute) */
#define IMAGE_REL_PPC_ADDR24            0x0003

/* 16-bit address */
#define IMAGE_REL_PPC_ADDR16            0x0004

/* 16-bit address, shifted left 2 (load doubleword) */
#define IMAGE_REL_PPC_ADDR14            0x0005

/* 26-bit PC-relative offset, shifted left 2 (branch relative) */
#define IMAGE_REL_PPC_REL24             0x0006

/* 16-bit PC-relative offset, shifted left 2 (br cond relative) */
#define IMAGE_REL_PPC_REL14             0x0007

/* 16-bit offset from TOC base */
#define IMAGE_REL_PPC_TOCREL16          0x0008

/* 16-bit offset from TOC base, shifted left 2 (load doubleword) */
#define IMAGE_REL_PPC_TOCREL14          0x0009

/* 32-bit addr w/o image base */
#define IMAGE_REL_PPC_ADDR32NB          0x000A

/* va of containing section (as in an image sectionhdr) */
#define IMAGE_REL_PPC_SECREL            0x000B

/* sectionheader number */
#define IMAGE_REL_PPC_SECTION           0x000C

/* substitute TOC restore instruction iff symbol is glue code */
#define IMAGE_REL_PPC_IFGLUE            0x000D

/* symbol is glue code; virtual address is TOC restore instruction */
#define IMAGE_REL_PPC_IMGLUE            0x000E

/* va of containing section (limited to 16 bits) */
#define IMAGE_REL_PPC_SECREL16          0x000F

/* Stuff to handle immediate data when the number of bits in the
   data is greater than the number of bits in the immediate field
   We need to do (usually) 32 bit arithmetic on 16 bit chunks.  */
#define IMAGE_REL_PPC_REFHI             0x0010
#define IMAGE_REL_PPC_REFLO             0x0011
#define IMAGE_REL_PPC_PAIR              0x0012

/* This is essentially the same as tocrel16, with TOCDEFN assumed.  */
#define IMAGE_REL_PPC_TOCREL16_DEFN     0x0013

/* Flag bits in IMAGE_RELOCATION.TYPE.  */

/* Subtract reloc value rather than adding it.  */
#define IMAGE_REL_PPC_NEG               0x0100

/* Fix branch prediction bit to predict branch taken.  */
#define IMAGE_REL_PPC_BRTAKEN           0x0200

/* Fix branch prediction bit to predict branch not taken.  */
#define IMAGE_REL_PPC_BRNTAKEN          0x0400

/* TOC slot defined in file (or, data in toc).  */
#define IMAGE_REL_PPC_TOCDEFN           0x0800

/* Masks to isolate above values in IMAGE_RELOCATION.Type.  */
#define IMAGE_REL_PPC_TYPEMASK          0x00FF
#define IMAGE_REL_PPC_FLAGMASK          0x0F00

#define EXTRACT_TYPE(x)                 ((x) & IMAGE_REL_PPC_TYPEMASK)
#define EXTRACT_FLAGS(x) ((x) & IMAGE_REL_PPC_FLAGMASK)
#define EXTRACT_JUNK(x)  \
           ((x) & ~(IMAGE_REL_PPC_TYPEMASK | IMAGE_REL_PPC_FLAGMASK))

/* Static helper functions to make relocation work.  */
/* (Work In Progress) */

static bfd_reloc_status_type ppc_refhi_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc_pair_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc_toc16_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc_section_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc_secrel_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc_imglue_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);

/* FIXME: It'll take a while to get through all of these. I only need a few to
   get us started, so those I'll make sure work. Those marked FIXME are either
   completely unverified or have a specific unknown marked in the comment.  */

/* Relocation entries for Windows/NT on PowerPC.

   From the document "" we find the following listed as used relocs:

     ABSOLUTE       : The noop
     ADDR[64|32|16] : fields that hold addresses in data fields or the
                      16 bit displacement field on a load/store.
     ADDR[24|14]    : fields that hold addresses in branch and cond
                      branches. These represent [26|16] bit addresses.
                      The low order 2 bits are preserved.
     REL[24|14]     : branches relative to the Instruction Address
                      register. These represent [26|16] bit addresses,
                      as before. The instruction field will be zero, and
                      the address of the SYM will be inserted at link time.
     TOCREL16       : 16 bit displacement field referring to a slot in
                      toc.
     TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14.
     ADDR32NB       : 32 bit address relative to the virtual origin.
                      (On the alpha, this is always a linker generated thunk)
                      (i.e. 32bit addr relative to the image base)
     SECREL         : The value is relative to the start of the section
                      containing the symbol.
     SECTION        : access to the header containing the item. Supports the
                      codeview debugger.

   In particular, note that the document does not indicate that the
   relocations listed in the header file are used.  */


static reloc_howto_type ppc_coff_howto_table[] =
{
  /* IMAGE_REL_PPC_ABSOLUTE 0x0000   NOP */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_ABSOLUTE, /* type */
	 0,	                 /* rightshift */
	 0,	                 /* size (0 = byte, 1 = short, 2 = long) */
	 0,	                 /* bitsize */
	 FALSE,	                 /* pc_relative */
	 0,	                 /* bitpos */
	 complain_overflow_dont, /* dont complain_on_overflow */
	 0,		         /* special_function */
	 "ABSOLUTE",             /* name */
	 FALSE,	                 /* partial_inplace */
	 0x00,	 	         /* src_mask */
	 0x00,        		 /* dst_mask */
	 FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR64 0x0001  64-bit address */
  /* Unused: */
  HOWTO(IMAGE_REL_PPC_ADDR64,    /* type */
	0,	                 /* rightshift */
	3,	                 /* size (0 = byte, 1 = short, 2 = long) */
	64,	                 /* bitsize */
	FALSE,	                 /* pc_relative */
	0,	                 /* bitpos */
	complain_overflow_bitfield, 	 /* complain_on_overflow */
	0,		         /* special_function */
	"ADDR64",               /* name */
	TRUE,	                 /* partial_inplace */
	MINUS_ONE,	 	 /* src_mask */
	MINUS_ONE,        	 /* dst_mask */
	FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR32 0x0002  32-bit address */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_ADDR32,	/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR32",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,            /* src_mask */
	 0xffffffff,            /* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR24 0x0003  26-bit address, shifted left 2 (branch absolute) */
  /* the LI field is in bit 6 through bit 29 is 24 bits, + 2 for the shift */
  /* Of course, That's the IBM approved bit numbering, which is not what */
  /* anyone else uses.... The li field is in bit 2 thru 25 */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_ADDR24,  /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR24",              /* name */
	 TRUE,	                /* partial_inplace */
	 0x07fffffc,	        /* src_mask */
	 0x07fffffc,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR16 0x0004  16-bit address */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_ADDR16,  /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR16",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR14 0x0005 */
  /*  16-bit address, shifted left 2 (load doubleword) */
  /* FIXME: the mask is likely wrong, and the bit position may be as well */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */
	 1,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR16",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_REL24 0x0006 */
  /*   26-bit PC-relative offset, shifted left 2 (branch relative) */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_REL24,   /* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 26,	                /* bitsize */
	 TRUE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "REL24",               /* name */
	 TRUE,	                /* partial_inplace */
	 0x3fffffc,	        /* src_mask */
	 0x3fffffc,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_REL14 0x0007 */
  /*   16-bit PC-relative offset, shifted left 2 (br cond relative) */
  /* FIXME: the mask is likely wrong, and the bit position may be as well */
  /* FIXME: how does it know how far to shift? */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */
	 1,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "ADDR16",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_TOCREL16 0x0008 */
  /*   16-bit offset from TOC base */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_TOCREL16,/* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_toc16_reloc,       /* special_function */
	 "TOCREL16",            /* name */
	 FALSE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_TOCREL14 0x0009 */
  /*   16-bit offset from TOC base, shifted left 2 (load doubleword) */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_TOCREL14,/* type */
	 1,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "TOCREL14",            /* name */
	 FALSE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_ADDR32NB 0x000A */
  /*   32-bit addr w/ image base */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_ADDR32NB,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,                     /* special_function */
	 "ADDR32NB",            /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_SECREL 0x000B */
  /*   va of containing section (as in an image sectionhdr) */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_SECREL,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_secrel_reloc,      /* special_function */
	 "SECREL",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_SECTION 0x000C */
  /*   sectionheader number */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_SECTION,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_section_reloc,     /* special_function */
	 "SECTION",             /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_IFGLUE 0x000D */
  /*   substitute TOC restore instruction iff symbol is glue code */
  /* Used: */
  HOWTO (IMAGE_REL_PPC_IFGLUE,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "IFGLUE",              /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_IMGLUE 0x000E */
  /*   symbol is glue code; virtual address is TOC restore instruction */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_IMGLUE,/* type */
	 0,	                /* rightshift */
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */
	 32,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_imglue_reloc,      /* special_function */
	 "IMGLUE",              /* name */
	 FALSE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_SECREL16 0x000F */
  /*   va of containing section (limited to 16 bits) */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_SECREL16,/* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,		        /* special_function */
	 "SECREL16",            /* name */
	 TRUE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 TRUE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_REFHI             0x0010 */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_REFHI,   /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_refhi_reloc,	/* special_function */
	 "REFHI",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                 /* pcrel_offset */

  /* IMAGE_REL_PPC_REFLO             0x0011 */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_REFLO,   /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_refhi_reloc,	/* special_function */
	 "REFLO",               /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_PAIR              0x0012 */
  /* Unused: */
  HOWTO (IMAGE_REL_PPC_PAIR,    /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_pair_reloc,        /* special_function */
	 "PAIR",                /* name */
	 TRUE,	                /* partial_inplace */
	 0xffffffff,	        /* src_mask */
	 0xffffffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

  /* IMAGE_REL_PPC_TOCREL16_DEFN 0x0013 */
  /*   16-bit offset from TOC base, without causing a definition */
  /* Used: */
  HOWTO ( (IMAGE_REL_PPC_TOCREL16 | IMAGE_REL_PPC_TOCDEFN), /* type */
	 0,	                /* rightshift */
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */
	 16,	                /* bitsize */
	 FALSE,	                /* pc_relative */
	 0,	                /* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,                     /* special_function */
	 "TOCREL16, TOCDEFN",   /* name */
	 FALSE,	                /* partial_inplace */
	 0xffff,	        /* src_mask */
	 0xffff,        	/* dst_mask */
	 FALSE),                /* pcrel_offset */

};

/* Some really cheezy macros that can be turned on to test stderr :-)  */

#ifdef DEBUG_RELOC
#define UN_IMPL(x)                                           \
{                                                            \
   static int i;                                             \
   if (i == 0)                                               \
     {                                                       \
       i = 1;                                                \
       fprintf (stderr,_("Unimplemented Relocation -- %s\n"),x); \
     }                                                       \
}

#define DUMP_RELOC(n,r)                              \
{                                                    \
   fprintf (stderr,"%s sym %d, addr %d, addend %d\n", \
	   n, (*(r->sym_ptr_ptr))->name,             \
	   r->address, r->addend);                   \
}

/* Given a reloc name, n, and a pointer to an internal_reloc,
   dump out interesting information on the contents

#define n_name		_n._n_name
#define n_zeroes	_n._n_n._n_zeroes
#define n_offset	_n._n_n._n_offset  */

#define DUMP_RELOC2(n,r)                     		\
{                                            		\
   fprintf (stderr,"%s sym %d, r_vaddr %d %s\n", 	\
	   n, r->r_symndx, r->r_vaddr,			\
	   (((r->r_type) & IMAGE_REL_PPC_TOCDEFN) == 0) \
	   ?" ":" TOCDEFN"  );      			\
}

#else
#define UN_IMPL(x)
#define DUMP_RELOC(n,r)
#define DUMP_RELOC2(n,r)
#endif

/* TOC construction and management routines.  */

/* This file is compiled twice, and these variables are defined in one
   of the compilations.  FIXME: This is confusing and weird.  Also,
   BFD should not use global variables.  */
extern bfd *    bfd_of_toc_owner;
extern long int global_toc_size;
extern long int import_table_size;
extern long int first_thunk_address;
extern long int thunk_size;

enum toc_type
{
  default_toc,
  toc_32,
  toc_64
};

enum ref_category
{
  priv,
  pub,
  tocdata
};

struct list_ele
{
  struct list_ele *next;
  bfd_vma addr;
  enum ref_category cat;
  int offset;
  const char *name;
};

extern struct list_ele *head;
extern struct list_ele *tail;

static void
record_toc (asection *toc_section,
	    bfd_signed_vma our_toc_offset,
	    enum ref_category cat,
	    const char *name)
{
  /* Add this entry to our toc addr-offset-name list.  */
  bfd_size_type amt = sizeof (struct list_ele);
  struct list_ele *t = (struct list_ele *) bfd_malloc (amt);

  if (t == NULL)
    abort ();
  t->next = 0;
  t->offset = our_toc_offset;
  t->name = name;
  t->cat = cat;
  t->addr = toc_section->output_offset + our_toc_offset;

  if (head == 0)
    {
      head = t;
      tail = t;
    }
  else
    {
      tail->next = t;
      tail = t;
    }
}

#ifdef COFF_IMAGE_WITH_PE

/* Record a toc offset against a symbol.  */
static bfd_boolean
ppc_record_toc_entry (bfd *abfd,
		      struct bfd_link_info *info ATTRIBUTE_UNUSED,
		      asection *sec ATTRIBUTE_UNUSED,
		      int sym,
		      enum toc_type toc_kind ATTRIBUTE_UNUSED)
{
  struct ppc_coff_link_hash_entry *h;
  int *local_syms;

  h = 0;

  h = (struct ppc_coff_link_hash_entry *) (obj_coff_sym_hashes (abfd)[sym]);
  if (h != 0)
    {
      HASH_CHECK(h);
    }

  if (h == 0)
    {
      local_syms = obj_coff_local_toc_table(abfd);

      if (local_syms == 0)
	{
	  unsigned int i;
	  bfd_size_type amt;

	  /* allocate a table */
	  amt = (bfd_size_type) obj_raw_syment_count (abfd) * sizeof (int);
	  local_syms = (int *) bfd_zalloc (abfd, amt);
	  if (local_syms == 0)
	    return FALSE;
	  obj_coff_local_toc_table (abfd) = local_syms;

	  for (i = 0; i < obj_raw_syment_count (abfd); ++i)
	    {
	      SET_UNALLOCATED (local_syms[i]);
	    }
	}

      if (IS_UNALLOCATED(local_syms[sym]))
	{
	  local_syms[sym] = global_toc_size;
	  global_toc_size += 4;

	  /* The size must fit in a 16-bit displacement.  */
	  if (global_toc_size > 65535)
	    {
	      (*_bfd_error_handler) (_("TOC overflow"));
	      bfd_set_error (bfd_error_file_too_big);
	      return FALSE;
	    }
	}
    }
  else
    {
      /* Check to see if there's a toc slot allocated. If not, do it
	 here. It will be used in relocate_section.  */
      if (IS_UNALLOCATED(h->toc_offset))
	{
	  h->toc_offset = global_toc_size;
	  global_toc_size += 4;

	  /* The size must fit in a 16-bit displacement.  */
	  if (global_toc_size >= 65535)
	    {
	      (*_bfd_error_handler) (_("TOC overflow"));
	      bfd_set_error (bfd_error_file_too_big);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Record a toc offset against a symbol.  */
static void
ppc_mark_symbol_as_glue (bfd *abfd,
			 int sym,
			 struct internal_reloc *rel)
{
  struct ppc_coff_link_hash_entry *h;

  h = (struct ppc_coff_link_hash_entry *) (obj_coff_sym_hashes (abfd)[sym]);

  HASH_CHECK(h);

  h->symbol_is_glue = 1;
  h->glue_insn = bfd_get_32 (abfd, (bfd_byte *) &rel->r_vaddr);

  return;
}

#endif /* COFF_IMAGE_WITH_PE */

/* Return TRUE if this relocation should
   appear in the output .reloc section.  */

static bfd_boolean
in_reloc_p (bfd * abfd ATTRIBUTE_UNUSED,
	    reloc_howto_type *howto)
{
  return
    (! howto->pc_relative)
      && (howto->type != IMAGE_REL_PPC_ADDR32NB)
      && (howto->type != IMAGE_REL_PPC_TOCREL16)
      && (howto->type != IMAGE_REL_PPC_IMGLUE)
      && (howto->type != IMAGE_REL_PPC_IFGLUE)
      && (howto->type != IMAGE_REL_PPC_SECREL)
      && (howto->type != IMAGE_REL_PPC_SECTION)
      && (howto->type != IMAGE_REL_PPC_SECREL16)
      && (howto->type != IMAGE_REL_PPC_REFHI)
      && (howto->type != IMAGE_REL_PPC_REFLO)
      && (howto->type != IMAGE_REL_PPC_PAIR)
      && (howto->type != IMAGE_REL_PPC_TOCREL16_DEFN) ;
}

static bfd_boolean
write_base_file_entry (bfd *obfd, struct bfd_link_info *info, bfd_vma addr)
{
  if (coff_data (obfd)->pe)
     addr -= pe_data (obfd)->pe_opthdr.ImageBase;
  if (fwrite (&addr, sizeof (addr), 1, (FILE *) info->base_file) == 1)
    return TRUE;

  bfd_set_error (bfd_error_system_call);
  return FALSE;
}

/* The reloc processing routine for the optimized COFF linker.  */

static bfd_boolean
coff_ppc_relocate_section (bfd *output_bfd,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   struct internal_reloc *relocs,
			   struct internal_syment *syms,
			   asection **sections)
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;
  asection *toc_section = 0;
  bfd_vma relocation;
  reloc_howto_type *howto = 0;

  /* If we are performing a relocatable link, we don't need to do a
     thing.  The caller will take care of adjusting the reloc
     addresses and symbol indices.  */
  if (info->relocatable)
    return TRUE;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct ppc_coff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma val;

      asection *sec;
      bfd_reloc_status_type rstat;
      bfd_byte *loc;

      unsigned short r_type  = EXTRACT_TYPE (rel->r_type);
      unsigned short r_flags = EXTRACT_FLAGS(rel->r_type);

      symndx = rel->r_symndx;
      loc = contents + rel->r_vaddr - input_section->vma;

      /* FIXME: check bounds on r_type */
      howto = ppc_coff_howto_table + r_type;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	}
      else
	{
	  h = (struct ppc_coff_link_hash_entry *)
	    (obj_coff_sym_hashes (input_bfd)[symndx]);
	  if (h != 0)
	    {
	      HASH_CHECK(h);
	    }

	  sym = syms + symndx;
	}

      if (r_type == IMAGE_REL_PPC_IMGLUE && h == 0)
	{
	  /* An IMGLUE reloc must have a name. Something is very wrong.  */
	  abort ();
	}

      sec = NULL;
      val = 0;

      /* FIXME: PAIR unsupported in the following code.  */
      if (h == NULL)
	{
	  if (symndx == -1)
	    sec = bfd_abs_section_ptr;
	  else
	    {
	      sec = sections[symndx];
	      val = (sec->output_section->vma
		     + sec->output_offset
		     + sym->n_value);
	      if (! obj_pe (output_bfd))
		val -= sec->vma;
	    }
	}
      else
	{
	  HASH_CHECK(h);

	  if (h->root.root.type == bfd_link_hash_defined
	      || h->root.root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.root.u.def.section;
	      val = (h->root.root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	    }
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
	    }
	}

      rstat = bfd_reloc_ok;

      /* Each case must do its own relocation, setting rstat appropriately.  */
      switch (r_type)
	{
	default:
	  (*_bfd_error_handler)
	    (_("%B: unsupported relocation type 0x%02x"), input_bfd, r_type);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	case IMAGE_REL_PPC_TOCREL16:
	  {
	    bfd_signed_vma our_toc_offset;
	    int fixit;

	    DUMP_RELOC2(howto->name, rel);

	    if (toc_section == 0)
	      {
		toc_section = bfd_get_section_by_name (bfd_of_toc_owner,
						       TOC_SECTION_NAME);

		if ( toc_section == NULL )
		  {
		    /* There is no toc section. Something is very wrong.  */
		    abort ();
		  }
	      }

	    /* Amazing bit tricks present. As we may have seen earlier, we
	       use the 1 bit to tell us whether or not a toc offset has been
	       allocated. Now that they've all been allocated, we will use
	       the 1 bit to tell us if we've written this particular toc
	       entry out.  */
	    fixit = FALSE;
	    if (h == 0)
	      {
		/* It is a file local symbol.  */
		int *local_toc_table;
		const char *name;

		sym = syms + symndx;
		name = sym->_n._n_name;

		local_toc_table = obj_coff_local_toc_table(input_bfd);
		our_toc_offset = local_toc_table[symndx];

		if (IS_WRITTEN(our_toc_offset))
		  {
		    /* If it has been written out, it is marked with the
		       1 bit. Fix up our offset, but do not write it out
		       again.  */
		    MAKE_ADDR_AGAIN(our_toc_offset);
		  }
		else
		  {
		    /* Write out the toc entry.  */
		    record_toc (toc_section, our_toc_offset, priv,
				strdup (name));

		    bfd_put_32 (output_bfd, val,
			       toc_section->contents + our_toc_offset);

		    MARK_AS_WRITTEN(local_toc_table[symndx]);
		    fixit = TRUE;
		  }
	      }
	    else
	      {
		const char *name = h->root.root.root.string;
		our_toc_offset = h->toc_offset;

		if ((r_flags & IMAGE_REL_PPC_TOCDEFN)
		    == IMAGE_REL_PPC_TOCDEFN )
		  {
		    /* This is unbelievable cheese. Some knowledgable asm
		       hacker has decided to use r2 as a base for loading
		       a value. He/She does this by setting the tocdefn bit,
		       and not supplying a toc definition. The behaviour is
		       then to use the difference between the value of the
		       symbol and the actual location of the toc as the toc
		       index.

		       In fact, what is usually happening is, because the
		       Import Address Table is mapped immediately following
		       the toc, some trippy library code trying for speed on
		       dll linkage, takes advantage of that and considers
		       the IAT to be part of the toc, thus saving a load.  */

		    our_toc_offset = val - (toc_section->output_section->vma
					    + toc_section->output_offset);

		    /* The size must still fit in a 16-bit displacement.  */
		    if ((bfd_vma) our_toc_offset >= 65535)
		      {
			(*_bfd_error_handler)
			  (_("%B: Relocation for %s of %lx exceeds Toc size limit"),
			   input_bfd, name,
			   (unsigned long) our_toc_offset);
			bfd_set_error (bfd_error_bad_value);
			return FALSE;
		      }

		    record_toc (toc_section, our_toc_offset, pub,
				strdup (name));
		  }
		else if (IS_WRITTEN (our_toc_offset))
		  {
		    /* If it has been written out, it is marked with the
		       1 bit. Fix up our offset, but do not write it out
		       again.  */
		    MAKE_ADDR_AGAIN(our_toc_offset);
		  }
		else
		  {
		    record_toc(toc_section, our_toc_offset, pub,
			       strdup (name));

		    /* Write out the toc entry.  */
		    bfd_put_32 (output_bfd, val,
			       toc_section->contents + our_toc_offset);

		    MARK_AS_WRITTEN(h->toc_offset);
		    /* The tricky part is that this is the address that
		       needs a .reloc entry for it.  */
		    fixit = TRUE;
		  }
	      }

	    if (fixit && info->base_file)
	      {
		/* So if this is non pcrelative, and is referenced
		   to a section or a common symbol, then it needs a reloc.  */

		/* Relocation to a symbol in a section which
		   isn't absolute - we output the address here
		   to a file.  */
		bfd_vma addr = (toc_section->output_section->vma
				+ toc_section->output_offset + our_toc_offset);

		if (!write_base_file_entry (output_bfd, info, addr))
		  return FALSE;
	      }

	    /* FIXME: this test is conservative.  */
	    if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN
		&& (bfd_vma) our_toc_offset > toc_section->size)
	      {
		(*_bfd_error_handler)
		  (_("%B: Relocation exceeds allocated TOC (%lx)"),
		   input_bfd, (unsigned long) toc_section->size);
		bfd_set_error (bfd_error_bad_value);
		return FALSE;
	      }

	    /* Now we know the relocation for this toc reference.  */
	    relocation =  our_toc_offset + TOC_LOAD_ADJUSTMENT;
	    rstat = _bfd_relocate_contents (howto, input_bfd, relocation, loc);
	  }
	  break;
	case IMAGE_REL_PPC_IFGLUE:
	  {
	    /* To solve this, we need to know whether or not the symbol
	       appearing on the call instruction is a glue function or not.
	       A glue function must announce itself via a IMGLUE reloc, and
	       the reloc contains the required toc restore instruction.  */
	    DUMP_RELOC2 (howto->name, rel);

	    if (h != 0)
	      {
		if (h->symbol_is_glue == 1)
		  {
		    bfd_put_32 (input_bfd, (bfd_vma) h->glue_insn, loc);
		  }
	      }
	  }
	  break;
	case IMAGE_REL_PPC_SECREL:
	  /* Unimplemented: codeview debugging information.  */
	  /* For fast access to the header of the section
	     containing the item.  */
	  break;
	case IMAGE_REL_PPC_SECTION:
	  /* Unimplemented: codeview debugging information.  */
	  /* Is used to indicate that the value should be relative
	     to the beginning of the section that contains the
	     symbol.  */
	  break;
	case IMAGE_REL_PPC_ABSOLUTE:
	  {
	    const char *my_name;

	    if (h == 0)
	      my_name = (syms+symndx)->_n._n_name;
	    else
	      my_name = h->root.root.root.string;

	    (*_bfd_error_handler)
	      (_("Warning: unsupported reloc %s <file %B, section %A>\n"
		 "sym %ld (%s), r_vaddr %ld (%lx)"),
	       input_bfd, input_section, howto->name,
	       rel->r_symndx, my_name, (long) rel->r_vaddr,
	       (unsigned long) rel->r_vaddr);
	  }
	  break;
	case IMAGE_REL_PPC_IMGLUE:
	  {
	    /* There is nothing to do now. This reloc was noted in the first
	       pass over the relocs, and the glue instruction extracted.  */
	    const char *my_name;

	    if (h->symbol_is_glue == 1)
	      break;
	    my_name = h->root.root.root.string;

	    (*_bfd_error_handler)
	      (_("%B: Out of order IMGLUE reloc for %s"), input_bfd, my_name);
	    bfd_set_error (bfd_error_bad_value);
	    return FALSE;
	  }

	case IMAGE_REL_PPC_ADDR32NB:
	  {
	    const char *name = 0;

	    DUMP_RELOC2 (howto->name, rel);

	    if (CONST_STRNEQ (input_section->name, ".idata$2") && first_thunk_address == 0)
	      {
		/* Set magic values.  */
		int idata5offset;
		struct coff_link_hash_entry *myh;

		myh = coff_link_hash_lookup (coff_hash_table (info),
					     "__idata5_magic__",
					     FALSE, FALSE, TRUE);
		first_thunk_address = myh->root.u.def.value +
		  sec->output_section->vma +
		    sec->output_offset -
		      pe_data(output_bfd)->pe_opthdr.ImageBase;

		idata5offset = myh->root.u.def.value;
		myh = coff_link_hash_lookup (coff_hash_table (info),
					     "__idata6_magic__",
					     FALSE, FALSE, TRUE);

		thunk_size = myh->root.u.def.value - idata5offset;
		myh = coff_link_hash_lookup (coff_hash_table (info),
					     "__idata4_magic__",
					     FALSE, FALSE, TRUE);
		import_table_size = myh->root.u.def.value;
	      }

	    if (h == 0)
	      {
		/* It is a file local symbol.  */
		sym = syms + symndx;
		name = sym->_n._n_name;
	      }
	    else
	      {
		char *target = 0;

		name = h->root.root.root.string;
		if (strcmp (".idata$2", name) == 0)
		  target = "__idata2_magic__";
		else if (strcmp (".idata$4", name) == 0)
		  target = "__idata4_magic__";
		else if (strcmp (".idata$5", name) == 0)
		  target = "__idata5_magic__";

		if (target != 0)
		  {
		    struct coff_link_hash_entry *myh;

		    myh = coff_link_hash_lookup (coff_hash_table (info),
						 target,
						 FALSE, FALSE, TRUE);
		    if (myh == 0)
		      {
			/* Missing magic cookies. Something is very wrong.  */
			abort ();
		      }

		    val = myh->root.u.def.value +
		      sec->output_section->vma + sec->output_offset;
		    if (first_thunk_address == 0)
		      {
			int idata5offset;
			myh = coff_link_hash_lookup (coff_hash_table (info),
						     "__idata5_magic__",
						     FALSE, FALSE, TRUE);
			first_thunk_address = myh->root.u.def.value +
			  sec->output_section->vma +
			    sec->output_offset -
			      pe_data(output_bfd)->pe_opthdr.ImageBase;

			idata5offset = myh->root.u.def.value;
			myh = coff_link_hash_lookup (coff_hash_table (info),
						     "__idata6_magic__",
						     FALSE, FALSE, TRUE);

			thunk_size = myh->root.u.def.value - idata5offset;
			myh = coff_link_hash_lookup (coff_hash_table (info),
						     "__idata4_magic__",
						     FALSE, FALSE, TRUE);
			import_table_size = myh->root.u.def.value;
		      }
		  }
	      }

	    rstat = _bfd_relocate_contents (howto,
					    input_bfd,
					    val -
					    pe_data (output_bfd)->pe_opthdr.ImageBase,
					    loc);
	  }
	  break;

	case IMAGE_REL_PPC_REL24:
	  DUMP_RELOC2(howto->name, rel);
	  val -= (input_section->output_section->vma
		  + input_section->output_offset);

	  rstat = _bfd_relocate_contents (howto,
					  input_bfd,
					  val,
					  loc);
	  break;
	case IMAGE_REL_PPC_ADDR16:
	case IMAGE_REL_PPC_ADDR24:
	case IMAGE_REL_PPC_ADDR32:
	  DUMP_RELOC2(howto->name, rel);
	  rstat = _bfd_relocate_contents (howto,
					  input_bfd,
					  val,
					  loc);
	  break;
	}

      if (info->base_file)
	{
	  /* So if this is non pcrelative, and is referenced
	     to a section or a common symbol, then it needs a reloc.  */
	  if (sym && pe_data(output_bfd)->in_reloc_p (output_bfd, howto))
	    {
	      /* Relocation to a symbol in a section which
		 isn't absolute - we output the address here
		 to a file.  */
	      bfd_vma addr = (rel->r_vaddr
			      - input_section->vma
			      + input_section->output_offset
			      + input_section->output_section->vma);

	      if (!write_base_file_entry (output_bfd, info, addr))
		return FALSE;
	    }
	}

      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = NULL;
	    else if (sym == NULL)
	      name = "*unknown*";
	    else if (sym->_n._n_n._n_zeroes == 0
		     && sym->_n._n_n._n_offset != 0)
	      name = obj_coff_strings (input_bfd) + sym->_n._n_n._n_offset;
	    else
	      {
		strncpy (buf, sym->_n._n_name, SYMNMLEN);
		buf[SYMNMLEN] = '\0';
		name = buf;
	      }

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, (h ? &h->root.root : NULL), name, howto->name,
		    (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
	      return FALSE;
	  }
	}
    }

  return TRUE;
}

#ifdef COFF_IMAGE_WITH_PE

/* FIXME: BFD should not use global variables.  This file is compiled
   twice, and these variables are shared.  This is confusing and
   weird.  */

long int global_toc_size = 4;

bfd* bfd_of_toc_owner = 0;

long int import_table_size;
long int first_thunk_address;
long int thunk_size;

struct list_ele *head;
struct list_ele *tail;

static char *
h1 = N_("\n\t\t\tTOC MAPPING\n\n");
static char *
h2 = N_(" TOC    disassembly  Comments       Name\n");
static char *
h3 = N_(" Offset  spelling                   (if present)\n");

void
dump_toc (void * vfile)
{
  FILE *file = (FILE *) vfile;
  struct list_ele *t;

  fputs (_(h1), file);
  fputs (_(h2), file);
  fputs (_(h3), file);

  for (t = head; t != 0; t=t->next)
    {
      const char *cat = "";

      if (t->cat == priv)
	cat = _("private       ");
      else if (t->cat == pub)
	cat = _("public        ");
      else if (t->cat == tocdata)
	cat = _("data-in-toc   ");

      if (t->offset > global_toc_size)
	{
	  if (t->offset <= global_toc_size + thunk_size)
	    cat = _("IAT reference ");
	  else
	    {
	      fprintf (file,
		      _("**** global_toc_size %ld(%lx), thunk_size %ld(%lx)\n"),
		       global_toc_size, (unsigned long) global_toc_size,
		       thunk_size, (unsigned long) thunk_size);
	      cat = _("Out of bounds!");
	    }
	}

      fprintf (file,
	      " %04lx    (%d)", (unsigned long) t->offset, t->offset - 32768);
      fprintf (file,
	      "    %s %s\n",
	      cat, t->name);

    }

  fprintf (file, "\n");
}

bfd_boolean
ppc_allocate_toc_section (struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  asection *s;
  bfd_byte *foo;
  bfd_size_type amt;
  static char test_char = '1';

  if ( global_toc_size == 0 ) /* FIXME: does this get me in trouble?  */
    return TRUE;

  if (bfd_of_toc_owner == 0)
    /* No toc owner? Something is very wrong.  */
    abort ();

  s = bfd_get_section_by_name ( bfd_of_toc_owner , TOC_SECTION_NAME);
  if (s == NULL)
    /* No toc section? Something is very wrong.  */
    abort ();

  amt = global_toc_size;
  foo = (bfd_byte *) bfd_alloc (bfd_of_toc_owner, amt);
  memset(foo, test_char, (size_t) global_toc_size);

  s->size = global_toc_size;
  s->contents = foo;

  return TRUE;
}

bfd_boolean
ppc_process_before_allocation (bfd *abfd,
			       struct bfd_link_info *info)
{
  asection *sec;
  struct internal_reloc *i, *rel;

  /* Here we have a bfd that is to be included on the link. We have a hook
     to do reloc rummaging, before section sizes are nailed down.  */
  _bfd_coff_get_external_symbols (abfd);

  /* Rummage around all the relocs and map the toc.  */
  sec = abfd->sections;

  if (sec == 0)
    return TRUE;

  for (; sec != 0; sec = sec->next)
    {
      if (sec->reloc_count == 0)
	continue;

      /* load the relocs */
      /* FIXME: there may be a storage leak here */
      i=_bfd_coff_read_internal_relocs(abfd,sec,1,0,0,0);

      if (i == 0)
	abort ();

      for (rel = i; rel < i + sec->reloc_count; ++rel)
	{
	  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
	  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
	  bfd_boolean ok = TRUE;

	  DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, rel);

	  switch(r_type)
	    {
	    case IMAGE_REL_PPC_TOCREL16:
	      /* If TOCDEFN is on, ignore as someone else has allocated the
		 toc entry.  */
	      if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN)
		ok = ppc_record_toc_entry(abfd, info, sec,
					  rel->r_symndx, default_toc);
	      if (!ok)
		return FALSE;
	      break;
	    case IMAGE_REL_PPC_IMGLUE:
	      ppc_mark_symbol_as_glue (abfd, rel->r_symndx, rel);
	      break;
	    default:
	      break;
	    }
	}
    }

  return TRUE;
}

#endif

static bfd_reloc_status_type
ppc_refhi_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		 arelent *reloc_entry ATTRIBUTE_UNUSED,
		 asymbol *symbol ATTRIBUTE_UNUSED,
		 void * data ATTRIBUTE_UNUSED,
		 asection *input_section ATTRIBUTE_UNUSED,
		 bfd *output_bfd,
		 char **error_message ATTRIBUTE_UNUSED)
{
  UN_IMPL("REFHI");
  DUMP_RELOC("REFHI",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_undefined;
}

static bfd_reloc_status_type
ppc_pair_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		arelent *reloc_entry ATTRIBUTE_UNUSED,
		asymbol *symbol ATTRIBUTE_UNUSED,
		void * data ATTRIBUTE_UNUSED,
		asection *input_section ATTRIBUTE_UNUSED,
		bfd *output_bfd,
		char **error_message ATTRIBUTE_UNUSED)
{
  UN_IMPL("PAIR");
  DUMP_RELOC("PAIR",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_undefined;
}

static bfd_reloc_status_type
ppc_toc16_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		 arelent *reloc_entry ATTRIBUTE_UNUSED,
		 asymbol *symbol ATTRIBUTE_UNUSED,
		 void * data ATTRIBUTE_UNUSED,
		 asection *input_section ATTRIBUTE_UNUSED,
		 bfd *output_bfd,
		 char **error_message ATTRIBUTE_UNUSED)
{
  UN_IMPL ("TOCREL16");
  DUMP_RELOC ("TOCREL16",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
ppc_secrel_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		  arelent *reloc_entry ATTRIBUTE_UNUSED,
		  asymbol *symbol ATTRIBUTE_UNUSED,
		  void * data ATTRIBUTE_UNUSED,
		  asection *input_section ATTRIBUTE_UNUSED,
		  bfd *output_bfd,
		  char **error_message ATTRIBUTE_UNUSED)
{
  UN_IMPL("SECREL");
  DUMP_RELOC("SECREL",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
ppc_section_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		   arelent *reloc_entry ATTRIBUTE_UNUSED,
		   asymbol *symbol ATTRIBUTE_UNUSED,
		   void * data ATTRIBUTE_UNUSED,
		   asection *input_section ATTRIBUTE_UNUSED,
		   bfd *output_bfd,
		   char **error_message ATTRIBUTE_UNUSED)
{
  UN_IMPL("SECTION");
  DUMP_RELOC("SECTION",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_ok;
}

static bfd_reloc_status_type
ppc_imglue_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		  arelent *reloc_entry ATTRIBUTE_UNUSED,
		  asymbol *symbol ATTRIBUTE_UNUSED,
		  void * data ATTRIBUTE_UNUSED,
		  asection *input_section ATTRIBUTE_UNUSED,
		  bfd *output_bfd,
		  char **error_message ATTRIBUTE_UNUSED)

{
  UN_IMPL("IMGLUE");
  DUMP_RELOC("IMGLUE",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_ok;
}

#define MAX_RELOC_INDEX  \
      (sizeof (ppc_coff_howto_table) / sizeof (ppc_coff_howto_table[0]) - 1)

/* FIXME: There is a possibility that when we read in a reloc from a file,
          that there are some bits encoded in the upper portion of the
	  type field. Not yet implemented.  */

static void
ppc_coff_rtype2howto (arelent *relent, struct internal_reloc *internal)
{
  /* We can encode one of three things in the type field, aside from the
     type:
     1. IMAGE_REL_PPC_NEG - indicates the value field is a subtraction
        value, rather than an addition value
     2. IMAGE_REL_PPC_BRTAKEN, IMAGE_REL_PPC_BRNTAKEN - indicates that
        the branch is expected to be taken or not.
     3. IMAGE_REL_PPC_TOCDEFN - toc slot definition in the file
     For now, we just strip this stuff to find the type, and ignore it other
     than that.  */
  reloc_howto_type *howto;
  unsigned short r_type  = EXTRACT_TYPE (internal->r_type);
  unsigned short r_flags = EXTRACT_FLAGS(internal->r_type);
  unsigned short junk    = EXTRACT_JUNK (internal->r_type);

  /* The masking process only slices off the bottom byte for r_type.  */
  if ( r_type > MAX_RELOC_INDEX )
    abort ();

  /* Check for absolute crap.  */
  if (junk != 0)
    abort ();

  switch(r_type)
    {
    case IMAGE_REL_PPC_ADDR16:
    case IMAGE_REL_PPC_REL24:
    case IMAGE_REL_PPC_ADDR24:
    case IMAGE_REL_PPC_ADDR32:
    case IMAGE_REL_PPC_IFGLUE:
    case IMAGE_REL_PPC_ADDR32NB:
    case IMAGE_REL_PPC_SECTION:
    case IMAGE_REL_PPC_SECREL:
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_IMGLUE:
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_TOCREL16:
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
      if (r_flags & IMAGE_REL_PPC_TOCDEFN)
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16_DEFN;
      else
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16;
      break;
    default:
      (*_bfd_error_handler) (_("warning: unsupported reloc %s [%d] used -- it may not work"),
			     ppc_coff_howto_table[r_type].name,
			     r_type);
      howto = ppc_coff_howto_table + r_type;
      break;
    }

  relent->howto = howto;
}

static reloc_howto_type *
coff_ppc_rtype_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			 asection *sec,
			 struct internal_reloc *rel,
			 struct coff_link_hash_entry *h ATTRIBUTE_UNUSED,
			 struct internal_syment *sym ATTRIBUTE_UNUSED,
			 bfd_vma *addendp)
{
  reloc_howto_type *howto;

  /* We can encode one of three things in the type field, aside from the
     type:
     1. IMAGE_REL_PPC_NEG - indicates the value field is a subtraction
        value, rather than an addition value
     2. IMAGE_REL_PPC_BRTAKEN, IMAGE_REL_PPC_BRNTAKEN - indicates that
        the branch is expected to be taken or not.
     3. IMAGE_REL_PPC_TOCDEFN - toc slot definition in the file
     For now, we just strip this stuff to find the type, and ignore it other
     than that.  */

  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
  unsigned short junk    = EXTRACT_JUNK  (rel->r_type);

  /* The masking process only slices off the bottom byte for r_type.  */
  if (r_type > MAX_RELOC_INDEX)
    abort ();

  /* Check for absolute crap.  */
  if (junk != 0)
    abort ();

  switch(r_type)
    {
    case IMAGE_REL_PPC_ADDR32NB:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
      *addendp -= pe_data(sec->output_section->owner)->pe_opthdr.ImageBase;
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_TOCREL16:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
      if (r_flags & IMAGE_REL_PPC_TOCDEFN)
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16_DEFN;
      else
	howto = ppc_coff_howto_table + IMAGE_REL_PPC_TOCREL16;
      break;
    case IMAGE_REL_PPC_ADDR16:
    case IMAGE_REL_PPC_REL24:
    case IMAGE_REL_PPC_ADDR24:
    case IMAGE_REL_PPC_ADDR32:
    case IMAGE_REL_PPC_IFGLUE:
    case IMAGE_REL_PPC_SECTION:
    case IMAGE_REL_PPC_SECREL:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
      howto = ppc_coff_howto_table + r_type;
      break;
    case IMAGE_REL_PPC_IMGLUE:
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
      howto = ppc_coff_howto_table + r_type;
      break;
    default:
      (*_bfd_error_handler) (_("warning: unsupported reloc %s [%d] used -- it may not work"),
			     ppc_coff_howto_table[r_type].name,
			     r_type);
      howto = ppc_coff_howto_table + r_type;
      break;
    }

  return howto;
}

/* A cheesy little macro to make the code a little more readable.  */
#define HOW2MAP(bfd_rtype,ppc_rtype)  \
 case bfd_rtype: return &ppc_coff_howto_table[ppc_rtype]

static reloc_howto_type *
ppc_coff_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
{
  switch (code)
    {
      HOW2MAP(BFD_RELOC_32_GOTOFF,    IMAGE_REL_PPC_IMGLUE);
      HOW2MAP(BFD_RELOC_16_GOT_PCREL, IMAGE_REL_PPC_IFGLUE);
      HOW2MAP(BFD_RELOC_16,           IMAGE_REL_PPC_ADDR16);
      HOW2MAP(BFD_RELOC_PPC_B26,      IMAGE_REL_PPC_REL24);
      HOW2MAP(BFD_RELOC_PPC_BA26,     IMAGE_REL_PPC_ADDR24);
      HOW2MAP(BFD_RELOC_PPC_TOC16,    IMAGE_REL_PPC_TOCREL16);
      HOW2MAP(BFD_RELOC_16_GOTOFF,    IMAGE_REL_PPC_TOCREL16_DEFN);
      HOW2MAP(BFD_RELOC_32,           IMAGE_REL_PPC_ADDR32);
      HOW2MAP(BFD_RELOC_RVA,          IMAGE_REL_PPC_ADDR32NB);
    default:
      return NULL;
    }
}
#undef HOW2MAP

static reloc_howto_type *
ppc_coff_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (ppc_coff_howto_table) / sizeof (ppc_coff_howto_table[0]);
       i++)
    if (ppc_coff_howto_table[i].name != NULL
	&& strcasecmp (ppc_coff_howto_table[i].name, r_name) == 0)
      return &ppc_coff_howto_table[i];

  return NULL;
}

/* Tailor coffcode.h -- macro heaven.  */

#define RTYPE2HOWTO(cache_ptr, dst)  ppc_coff_rtype2howto (cache_ptr, dst)

/* We use the special COFF backend linker, with our own special touch.  */

#define coff_bfd_reloc_type_lookup   ppc_coff_reloc_type_lookup
#define coff_bfd_reloc_name_lookup ppc_coff_reloc_name_lookup
#define coff_rtype_to_howto          coff_ppc_rtype_to_howto
#define coff_relocate_section        coff_ppc_relocate_section
#define coff_bfd_final_link          ppc_bfd_coff_final_link

#ifndef COFF_IMAGE_WITH_PE
#endif

#define SELECT_RELOC(internal, howto) {internal.r_type=howto->type;}

#define COFF_PAGE_SIZE                       0x1000

/* FIXME: This controls some code that used to be in peicode.h and is
   now in peigen.c.  It will not control the code in peigen.c.  If
   anybody wants to get this working, you will need to fix that.  */
#define POWERPC_LE_PE

#define COFF_SECTION_ALIGNMENT_ENTRIES \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$2"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$3"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 0 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$4"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$5"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 2 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".idata$6"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 1 }, \
{ COFF_SECTION_NAME_EXACT_MATCH (".reloc"), \
  COFF_ALIGNMENT_FIELD_EMPTY, COFF_ALIGNMENT_FIELD_EMPTY, 1 }

#include "coffcode.h"

#ifndef COFF_IMAGE_WITH_PE

static bfd_boolean
ppc_do_last (bfd *abfd)
{
  if (abfd == bfd_of_toc_owner)
    return TRUE;
  else
    return FALSE;
}

static bfd *
ppc_get_last (void)
{
  return bfd_of_toc_owner;
}

/* This piece of machinery exists only to guarantee that the bfd that holds
   the toc section is written last.

   This does depend on bfd_make_section attaching a new section to the
   end of the section list for the bfd.

   This is otherwise intended to be functionally the same as
   cofflink.c:_bfd_coff_final_link(). It is specifically different only
   where the POWERPC_LE_PE macro modifies the code. It is left in as a
   precise form of comment. krk@@cygnus.com  */

/* Do the final link step.  */

bfd_boolean
ppc_bfd_coff_final_link (bfd *abfd, struct bfd_link_info *info)
{
  bfd_size_type symesz;
  struct coff_final_link_info flaginfo;
  bfd_boolean debug_merge_allocated;
  asection *o;
  struct bfd_link_order *p;
  bfd_size_type max_sym_count;
  bfd_size_type max_lineno_count;
  bfd_size_type max_reloc_count;
  bfd_size_type max_output_reloc_count;
  bfd_size_type max_contents_size;
  file_ptr rel_filepos;
  unsigned int relsz;
  file_ptr line_filepos;
  unsigned int linesz;
  bfd *sub;
  bfd_byte *external_relocs = NULL;
  char strbuf[STRING_SIZE_SIZE];
  bfd_size_type amt;

  symesz = bfd_coff_symesz (abfd);

  flaginfo.info = info;
  flaginfo.output_bfd = abfd;
  flaginfo.strtab = NULL;
  flaginfo.section_info = NULL;
  flaginfo.last_file_index = -1;
  flaginfo.last_bf_index = -1;
  flaginfo.internal_syms = NULL;
  flaginfo.sec_ptrs = NULL;
  flaginfo.sym_indices = NULL;
  flaginfo.outsyms = NULL;
  flaginfo.linenos = NULL;
  flaginfo.contents = NULL;
  flaginfo.external_relocs = NULL;
  flaginfo.internal_relocs = NULL;
  debug_merge_allocated = FALSE;

  coff_data (abfd)->link_info = info;

  flaginfo.strtab = _bfd_stringtab_init ();
  if (flaginfo.strtab == NULL)
    goto error_return;

  if (! coff_debug_merge_hash_table_init (&flaginfo.debug_merge))
    goto error_return;
  debug_merge_allocated = TRUE;

  /* Compute the file positions for all the sections.  */
  if (! abfd->output_has_begun)
    {
      if (! bfd_coff_compute_section_file_positions (abfd))
	return FALSE;
    }

  /* Count the line numbers and relocation entries required for the
     output file.  Set the file positions for the relocs.  */
  rel_filepos = obj_relocbase (abfd);
  relsz = bfd_coff_relsz (abfd);
  max_contents_size = 0;
  max_lineno_count = 0;
  max_reloc_count = 0;

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      o->reloc_count = 0;
      o->lineno_count = 0;

      for (p = o->map_head.link_order; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;

	      if (info->strip == strip_none
		  || info->strip == strip_some)
		o->lineno_count += sec->lineno_count;

	      if (info->relocatable)
		o->reloc_count += sec->reloc_count;

	      if (sec->rawsize > max_contents_size)
		max_contents_size = sec->rawsize;
	      if (sec->size > max_contents_size)
		max_contents_size = sec->size;
	      if (sec->lineno_count > max_lineno_count)
		max_lineno_count = sec->lineno_count;
	      if (sec->reloc_count > max_reloc_count)
		max_reloc_count = sec->reloc_count;
	    }
	  else if (info->relocatable
		   && (p->type == bfd_section_reloc_link_order
		       || p->type == bfd_symbol_reloc_link_order))
	    ++o->reloc_count;
	}
      if (o->reloc_count == 0)
	o->rel_filepos = 0;
      else
	{
	  o->flags |= SEC_RELOC;
	  o->rel_filepos = rel_filepos;
	  rel_filepos += o->reloc_count * relsz;
	}
    }

  /* If doing a relocatable link, allocate space for the pointers we
     need to keep.  */
  if (info->relocatable)
    {
      unsigned int i;

      /* We use section_count + 1, rather than section_count, because
         the target_index fields are 1 based.  */
      amt = abfd->section_count + 1;
      amt *= sizeof (struct coff_link_section_info);
      flaginfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);

      if (flaginfo.section_info == NULL)
	goto error_return;

      for (i = 0; i <= abfd->section_count; i++)
	{
	  flaginfo.section_info[i].relocs = NULL;
	  flaginfo.section_info[i].rel_hashes = NULL;
	}
    }

  /* We now know the size of the relocs, so we can determine the file
     positions of the line numbers.  */
  line_filepos = rel_filepos;
  linesz = bfd_coff_linesz (abfd);
  max_output_reloc_count = 0;

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->lineno_count == 0)
	o->line_filepos = 0;
      else
	{
	  o->line_filepos = line_filepos;
	  line_filepos += o->lineno_count * linesz;
	}

      if (o->reloc_count != 0)
	{
	  /* We don't know the indices of global symbols until we have
             written out all the local symbols.  For each section in
             the output file, we keep an array of pointers to hash
             table entries.  Each entry in the array corresponds to a
             reloc.  When we find a reloc against a global symbol, we
             set the corresponding entry in this array so that we can
             fix up the symbol index after we have written out all the
             local symbols.

	     Because of this problem, we also keep the relocs in
	     memory until the end of the link.  This wastes memory,
	     but only when doing a relocatable link, which is not the
	     common case.  */
	  BFD_ASSERT (info->relocatable);
	  amt = o->reloc_count;
	  amt *= sizeof (struct internal_reloc);
	  flaginfo.section_info[o->target_index].relocs =
	    (struct internal_reloc *) bfd_malloc (amt);
	  amt = o->reloc_count;
	  amt *= sizeof (struct coff_link_hash_entry *);
	  flaginfo.section_info[o->target_index].rel_hashes =
	    (struct coff_link_hash_entry **) bfd_malloc (amt);
	  if (flaginfo.section_info[o->target_index].relocs == NULL
	      || flaginfo.section_info[o->target_index].rel_hashes == NULL)
	    goto error_return;

	  if (o->reloc_count > max_output_reloc_count)
	    max_output_reloc_count = o->reloc_count;
	}

      /* Reset the reloc and lineno counts, so that we can use them to
	 count the number of entries we have output so far.  */
      o->reloc_count = 0;
      o->lineno_count = 0;
    }

  obj_sym_filepos (abfd) = line_filepos;

  /* Figure out the largest number of symbols in an input BFD.  Take
     the opportunity to clear the output_has_begun fields of all the
     input BFD's.  */
  max_sym_count = 0;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      bfd_size_type sz;

      sub->output_has_begun = FALSE;
      sz = obj_raw_syment_count (sub);
      if (sz > max_sym_count)
	max_sym_count = sz;
    }

  /* Allocate some buffers used while linking.  */
  amt = max_sym_count * sizeof (struct internal_syment);
  flaginfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
  amt = max_sym_count * sizeof (asection *);
  flaginfo.sec_ptrs = (asection **) bfd_malloc (amt);
  amt = max_sym_count * sizeof (long);
  flaginfo.sym_indices = (long *) bfd_malloc (amt);
  amt = (max_sym_count + 1) * symesz;
  flaginfo.outsyms = (bfd_byte *) bfd_malloc (amt);
  amt = max_lineno_count * bfd_coff_linesz (abfd);
  flaginfo.linenos = (bfd_byte *) bfd_malloc (amt);
  flaginfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  flaginfo.external_relocs = (bfd_byte *) bfd_malloc (max_reloc_count * relsz);
  if (! info->relocatable)
    {
      amt = max_reloc_count * sizeof (struct internal_reloc);
      flaginfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);
    }
  if ((flaginfo.internal_syms == NULL && max_sym_count > 0)
      || (flaginfo.sec_ptrs == NULL && max_sym_count > 0)
      || (flaginfo.sym_indices == NULL && max_sym_count > 0)
      || flaginfo.outsyms == NULL
      || (flaginfo.linenos == NULL && max_lineno_count > 0)
      || (flaginfo.contents == NULL && max_contents_size > 0)
      || (flaginfo.external_relocs == NULL && max_reloc_count > 0)
      || (! info->relocatable
	  && flaginfo.internal_relocs == NULL
	  && max_reloc_count > 0))
    goto error_return;

  /* We now know the position of everything in the file, except that
     we don't know the size of the symbol table and therefore we don't
     know where the string table starts.  We just build the string
     table in memory as we go along.  We process all the relocations
     for a single input file at once.  */
  obj_raw_syment_count (abfd) = 0;

  if (coff_backend_info (abfd)->_bfd_coff_start_final_link)
    {
      if (! bfd_coff_start_final_link (abfd, info))
	goto error_return;
    }

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->map_head.link_order; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && (bfd_get_flavour (p->u.indirect.section->owner)
		  == bfd_target_coff_flavour))
	    {
	      sub = p->u.indirect.section->owner;
#ifdef POWERPC_LE_PE
	      if (! sub->output_has_begun && !ppc_do_last(sub))
#else
	      if (! sub->output_has_begun)
#endif
		{
		  if (! _bfd_coff_link_input_bfd (&flaginfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! _bfd_coff_reloc_link_order (abfd, &flaginfo, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }

#ifdef POWERPC_LE_PE
  {
    bfd* last_one = ppc_get_last();
    if (last_one)
      {
	if (! _bfd_coff_link_input_bfd (&flaginfo, last_one))
	  goto error_return;
      }
    last_one->output_has_begun = TRUE;
  }
#endif

  /* Free up the buffers used by _bfd_coff_link_input_bfd.  */
  coff_debug_merge_hash_table_free (&flaginfo.debug_merge);
  debug_merge_allocated = FALSE;

  if (flaginfo.internal_syms != NULL)
    {
      free (flaginfo.internal_syms);
      flaginfo.internal_syms = NULL;
    }
  if (flaginfo.sec_ptrs != NULL)
    {
      free (flaginfo.sec_ptrs);
      flaginfo.sec_ptrs = NULL;
    }
  if (flaginfo.sym_indices != NULL)
    {
      free (flaginfo.sym_indices);
      flaginfo.sym_indices = NULL;
    }
  if (flaginfo.linenos != NULL)
    {
      free (flaginfo.linenos);
      flaginfo.linenos = NULL;
    }
  if (flaginfo.contents != NULL)
    {
      free (flaginfo.contents);
      flaginfo.contents = NULL;
    }
  if (flaginfo.external_relocs != NULL)
    {
      free (flaginfo.external_relocs);
      flaginfo.external_relocs = NULL;
    }
  if (flaginfo.internal_relocs != NULL)
    {
      free (flaginfo.internal_relocs);
      flaginfo.internal_relocs = NULL;
    }

  /* The value of the last C_FILE symbol is supposed to be the symbol
     index of the first external symbol.  Write it out again if
     necessary.  */
  if (flaginfo.last_file_index != -1
      && (unsigned int) flaginfo.last_file.n_value != obj_raw_syment_count (abfd))
    {
      file_ptr pos;

      flaginfo.last_file.n_value = obj_raw_syment_count (abfd);
      bfd_coff_swap_sym_out (abfd, &flaginfo.last_file,
			     flaginfo.outsyms);
      pos = obj_sym_filepos (abfd) + flaginfo.last_file_index * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (flaginfo.outsyms, symesz, abfd) != symesz)
	return FALSE;
    }

  /* Write out the global symbols.  */
  flaginfo.failed = FALSE;
  bfd_hash_traverse (&info->hash->table, _bfd_coff_write_global_sym, &flaginfo);
  if (flaginfo.failed)
    goto error_return;

  /* The outsyms buffer is used by _bfd_coff_write_global_sym.  */
  if (flaginfo.outsyms != NULL)
    {
      free (flaginfo.outsyms);
      flaginfo.outsyms = NULL;
    }

  if (info->relocatable)
    {
      /* Now that we have written out all the global symbols, we know
	 the symbol indices to use for relocs against them, and we can
	 finally write out the relocs.  */
      amt = max_output_reloc_count * relsz;
      external_relocs = (bfd_byte *) bfd_malloc (amt);
      if (external_relocs == NULL)
	goto error_return;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  struct internal_reloc *irel;
	  struct internal_reloc *irelend;
	  struct coff_link_hash_entry **rel_hash;
	  bfd_byte *erel;

	  if (o->reloc_count == 0)
	    continue;

	  irel = flaginfo.section_info[o->target_index].relocs;
	  irelend = irel + o->reloc_count;
	  rel_hash = flaginfo.section_info[o->target_index].rel_hashes;
	  erel = external_relocs;
	  for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	    {
	      if (*rel_hash != NULL)
		{
		  BFD_ASSERT ((*rel_hash)->indx >= 0);
		  irel->r_symndx = (*rel_hash)->indx;
		}
	      bfd_coff_swap_reloc_out (abfd, irel, erel);
	    }

	  amt = relsz * o->reloc_count;
	  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0
	      || bfd_bwrite (external_relocs, amt, abfd) != amt)
	    goto error_return;
	}

      free (external_relocs);
      external_relocs = NULL;
    }

  /* Free up the section information.  */
  if (flaginfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (flaginfo.section_info[i].relocs != NULL)
	    free (flaginfo.section_info[i].relocs);
	  if (flaginfo.section_info[i].rel_hashes != NULL)
	    free (flaginfo.section_info[i].rel_hashes);
	}
      free (flaginfo.section_info);
      flaginfo.section_info = NULL;
    }

  /* If we have optimized stabs strings, output them.  */
  if (coff_hash_table (info)->stab_info.stabstr != NULL)
    {
      if (! _bfd_write_stab_strings (abfd, &coff_hash_table (info)->stab_info))
	return FALSE;
    }

  /* Write out the string table.  */
  if (obj_raw_syment_count (abfd) != 0)
    {
      file_ptr pos;

      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
	return FALSE;

#if STRING_SIZE_SIZE == 4
      H_PUT_32 (abfd,
		_bfd_stringtab_size (flaginfo.strtab) + STRING_SIZE_SIZE,
		strbuf);
#else
 #error Change H_PUT_32 above
#endif

      if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)
	  != STRING_SIZE_SIZE)
	return FALSE;

      if (! _bfd_stringtab_emit (abfd, flaginfo.strtab))
	return FALSE;
    }

  _bfd_stringtab_free (flaginfo.strtab);

  /* Setting bfd_get_symcount to 0 will cause write_object_contents to
     not try to write out the symbols.  */
  bfd_get_symcount (abfd) = 0;

  return TRUE;

 error_return:
  if (debug_merge_allocated)
    coff_debug_merge_hash_table_free (&flaginfo.debug_merge);
  if (flaginfo.strtab != NULL)
    _bfd_stringtab_free (flaginfo.strtab);
  if (flaginfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (flaginfo.section_info[i].relocs != NULL)
	    free (flaginfo.section_info[i].relocs);
	  if (flaginfo.section_info[i].rel_hashes != NULL)
	    free (flaginfo.section_info[i].rel_hashes);
	}
      free (flaginfo.section_info);
    }
  if (flaginfo.internal_syms != NULL)
    free (flaginfo.internal_syms);
  if (flaginfo.sec_ptrs != NULL)
    free (flaginfo.sec_ptrs);
  if (flaginfo.sym_indices != NULL)
    free (flaginfo.sym_indices);
  if (flaginfo.outsyms != NULL)
    free (flaginfo.outsyms);
  if (flaginfo.linenos != NULL)
    free (flaginfo.linenos);
  if (flaginfo.contents != NULL)
    free (flaginfo.contents);
  if (flaginfo.external_relocs != NULL)
    free (flaginfo.external_relocs);
  if (flaginfo.internal_relocs != NULL)
    free (flaginfo.internal_relocs);
  if (external_relocs != NULL)
    free (external_relocs);
  return FALSE;
}
#endif

/* Forward declaration for use by alternative_target field.  */
#ifdef TARGET_BIG_SYM
extern const bfd_target TARGET_BIG_SYM;
#endif

/* The transfer vectors that lead the outside world to all of the above.  */

#ifdef TARGET_LITTLE_SYM
const bfd_target TARGET_LITTLE_SYM =
{
  TARGET_LITTLE_NAME,		/* name or coff-arm-little */
  bfd_target_coff_flavour,
  BFD_ENDIAN_LITTLE,		/* data byte order is little */
  BFD_ENDIAN_LITTLE,		/* header byte order is little */

  (HAS_RELOC | EXEC_P |		/* FIXME: object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

#ifndef COFF_WITH_PE
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY
   | SEC_RELOC),		/* section flags */
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY
   | SEC_RELOC | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
#endif

  0,				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen??? FIXMEmgo */
  0,				/* match priority.  */

  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* data */

  bfd_getl64, bfd_getl_signed_64, bfd_putl64,
  bfd_getl32, bfd_getl_signed_32, bfd_putl32,
  bfd_getl16, bfd_getl_signed_16, bfd_putl16, /* hdrs */

  {_bfd_dummy_target, coff_object_p, 	/* bfd_check_format */
     bfd_generic_archive_p, /* _bfd_dummy_target */ coff_object_p },
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  /* Alternative_target.  */
#ifdef TARGET_BIG_SYM
  & TARGET_BIG_SYM,
#else
  NULL,
#endif

  COFF_SWAP_TABLE
};
#endif

#ifdef TARGET_BIG_SYM
const bfd_target TARGET_BIG_SYM =
{
  TARGET_BIG_NAME,
  bfd_target_coff_flavour,
  BFD_ENDIAN_BIG,		/* data byte order is big */
  BFD_ENDIAN_BIG,		/* header byte order is big */

  (HAS_RELOC | EXEC_P |		/* FIXME: object flags */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED),

#ifndef COFF_WITH_PE
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY
   | SEC_RELOC),		/* section flags */
#else
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY
   | SEC_RELOC | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
#endif

  0,				/* leading char */
  '/',				/* ar_pad_char */
  15,				/* ar_max_namelen??? FIXMEmgo */
  0,				/* match priority.  */

  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* data */

  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16, /* hdrs */

  {_bfd_dummy_target, coff_object_p, 	/* bfd_check_format */
     bfd_generic_archive_p, /* _bfd_dummy_target */ coff_object_p },
  {bfd_false, coff_mkobject, _bfd_generic_mkarchive, /* bfd_set_format */
     bfd_false},
  {bfd_false, coff_write_object_contents,	/* bfd_write_contents */
     _bfd_write_archive_contents, bfd_false},

  BFD_JUMP_TABLE_GENERIC (coff),
  BFD_JUMP_TABLE_COPY (coff),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (_bfd_archive_coff),
  BFD_JUMP_TABLE_SYMBOLS (coff),
  BFD_JUMP_TABLE_RELOCS (coff),
  BFD_JUMP_TABLE_WRITE (coff),
  BFD_JUMP_TABLE_LINK (coff),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  /* Alternative_target.  */
#ifdef TARGET_LITTLE_SYM
  & TARGET_LITTLE_SYM,
#else
  NULL,
#endif

  COFF_SWAP_TABLE
};

#endif
@


1.44
log
@Allow SEC_CODE and SEC_READONLY in section flags.
@
text
@d304 1
a304 1
static bfd_reloc_status_type ppc_pair_reloc 
d310 1
a310 1
static bfd_reloc_status_type ppc_secrel_reloc 
d319 1
a319 1
/* Relocation entries for Windows/NT on PowerPC.                             
d1203 1
a1203 1
	       A glue function must announce itself via a IMGLUE reloc, and 
@


1.43
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d2483 2
a2484 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
d2486 2
a2487 2
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
d2544 2
a2545 1
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC), /* section flags */
d2547 2
a2548 2
  (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_RELOC /* section flags */
   | SEC_LINK_ONCE | SEC_LINK_DUPLICATES),
@


1.42
log
@	PR binutils/13121
	Rename 'finfo' to 'flaginfo' to avoid conflicts with
	AIX system headers.
@
text
@d3 2
a4 2
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
d55 2
a56 3
extern bfd_boolean ppc_bfd_coff_final_link
  PARAMS ((bfd *, struct bfd_link_info *));
extern void dump_toc PARAMS ((PTR));
a124 13
static struct bfd_hash_entry *ppc_coff_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
	   const char *));
static struct bfd_link_hash_table *ppc_coff_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean coff_ppc_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   struct internal_reloc *, struct internal_syment *, asection **));
static reloc_howto_type *coff_ppc_rtype_to_howto
  PARAMS ((bfd *, asection *, struct internal_reloc *,
	   struct coff_link_hash_entry *, struct internal_syment *,
	   bfd_vma *));

d128 3
a130 4
ppc_coff_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d168 4
a171 3
			       struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
								  struct bfd_hash_table *,
								  const char *),
d180 1
a180 2
ppc_coff_link_hash_table_create (abfd)
     bfd *abfd;
d302 12
a313 46
static bfd_reloc_status_type ppc_refhi_reloc PARAMS ((bfd *abfd,
						      arelent *reloc,
						      asymbol *symbol,
						      PTR data,
						      asection *section,
						      bfd *output_bfd,
						      char **error));
static bfd_reloc_status_type ppc_pair_reloc PARAMS ((bfd *abfd,
						     arelent *reloc,
						     asymbol *symbol,
						     PTR data,
						     asection *section,
						     bfd *output_bfd,
						     char **error));

static bfd_reloc_status_type ppc_toc16_reloc PARAMS ((bfd *abfd,
						      arelent *reloc,
						      asymbol *symbol,
						      PTR data,
						      asection *section,
						      bfd *output_bfd,
						      char **error));

static bfd_reloc_status_type ppc_section_reloc PARAMS ((bfd *abfd,
							arelent *reloc,
							asymbol *symbol,
							PTR data,
							asection *section,
							bfd *output_bfd,
							char **error));

static bfd_reloc_status_type ppc_secrel_reloc PARAMS ((bfd *abfd,
						       arelent *reloc,
						       asymbol *symbol,
						       PTR data,
						       asection *section,
						       bfd *output_bfd,
						       char **error));

static bfd_reloc_status_type ppc_imglue_reloc PARAMS ((bfd *abfd,
						       arelent *reloc,
						       asymbol *symbol,
						       PTR data,
						       asection *section,
						       bfd *output_bfd,
						       char **error));
a314 2
static bfd_boolean in_reloc_p PARAMS((bfd *abfd, reloc_howto_type *howto));

a767 3
static void record_toc
  PARAMS ((asection *, bfd_signed_vma, enum ref_category, const char *));

d769 4
a772 5
record_toc (toc_section, our_toc_offset, cat, name)
     asection *toc_section;
     bfd_signed_vma our_toc_offset;
     enum ref_category cat;
     const char *name;
a799 5
static bfd_boolean ppc_record_toc_entry
  PARAMS ((bfd *, struct bfd_link_info *, asection *, int, enum toc_type));
static void ppc_mark_symbol_as_glue
  PARAMS ((bfd *, int, struct internal_reloc *));

d802 5
a806 6
ppc_record_toc_entry(abfd, info, sec, sym, toc_kind)
     bfd *abfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     int sym;
     enum toc_type toc_kind ATTRIBUTE_UNUSED;
d879 3
a881 4
ppc_mark_symbol_as_glue(abfd, sym, rel)
     bfd *abfd;
     int sym;
     struct internal_reloc *rel;
d900 3
a902 3
static bfd_boolean in_reloc_p(abfd, howto)
     bfd * abfd ATTRIBUTE_UNUSED;
     reloc_howto_type *howto;
d934 8
a941 10
coff_ppc_relocate_section (output_bfd, info, input_bfd, input_section,
			   contents, relocs, syms, sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
d1462 1
a1462 2
dump_toc (vfile)
     PTR vfile;
d1508 1
a1508 2
ppc_allocate_toc_section (info)
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d1538 2
a1539 3
ppc_process_before_allocation (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d1600 7
a1606 9
ppc_refhi_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1618 7
a1624 9
ppc_pair_reloc (abfd, reloc_entry, symbol, data,
		input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1634 1
a1634 1

d1636 7
a1642 9
ppc_toc16_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1654 7
a1660 9
ppc_secrel_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1672 7
a1678 9
ppc_section_reloc (abfd, reloc_entry, symbol, data,
		   input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1690 8
a1697 9
ppc_imglue_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry ATTRIBUTE_UNUSED;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section ATTRIBUTE_UNUSED;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
a1713 1
static void ppc_coff_rtype2howto PARAMS ((arelent *, struct internal_reloc *));
d1716 1
a1716 3
ppc_coff_rtype2howto (relent, internal)
     arelent *relent;
     struct internal_reloc *internal;
d1776 6
a1781 7
coff_ppc_rtype_to_howto (abfd, sec, rel, h, sym, addendp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     struct internal_reloc *rel;
     struct coff_link_hash_entry *h ATTRIBUTE_UNUSED;
     struct internal_syment *sym ATTRIBUTE_UNUSED;
     bfd_vma *addendp;
a1849 3
static reloc_howto_type *ppc_coff_reloc_type_lookup
PARAMS ((bfd *, bfd_reloc_code_real_type));

d1851 2
a1852 3
ppc_coff_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
a1928 3
static bfd_boolean ppc_do_last PARAMS ((bfd *));
static bfd *ppc_get_last PARAMS ((void));

d1930 1
a1930 2
ppc_do_last (abfd)
     bfd *abfd;
d1939 1
a1939 1
ppc_get_last()
d1958 1
a1958 3
ppc_bfd_coff_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2302 2
a2303 2
      bfd_coff_swap_sym_out (abfd, (PTR) &flaginfo.last_file,
			     (PTR) flaginfo.outsyms);
d2354 1
a2354 1
	      bfd_coff_swap_reloc_out (abfd, (PTR) irel, (PTR) erel);
d2359 1
a2359 1
	      || bfd_bwrite ((PTR) external_relocs, amt, abfd) != amt)
@


1.41
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d2053 1
a2053 1
  struct coff_final_link_info finfo;
d2073 14
a2086 14
  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.strtab = NULL;
  finfo.section_info = NULL;
  finfo.last_file_index = -1;
  finfo.last_bf_index = -1;
  finfo.internal_syms = NULL;
  finfo.sec_ptrs = NULL;
  finfo.sym_indices = NULL;
  finfo.outsyms = NULL;
  finfo.linenos = NULL;
  finfo.contents = NULL;
  finfo.external_relocs = NULL;
  finfo.internal_relocs = NULL;
d2091 2
a2092 2
  finfo.strtab = _bfd_stringtab_init ();
  if (finfo.strtab == NULL)
d2095 1
a2095 1
  if (! coff_debug_merge_hash_table_init (&finfo.debug_merge))
d2174 1
a2174 1
      finfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);
d2176 1
a2176 1
      if (finfo.section_info == NULL)
d2181 2
a2182 2
	  finfo.section_info[i].relocs = NULL;
	  finfo.section_info[i].rel_hashes = NULL;
d2220 1
a2220 1
	  finfo.section_info[o->target_index].relocs =
d2224 1
a2224 1
	  finfo.section_info[o->target_index].rel_hashes =
d2226 2
a2227 2
	  if (finfo.section_info[o->target_index].relocs == NULL
	      || finfo.section_info[o->target_index].rel_hashes == NULL)
d2258 1
a2258 1
  finfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
d2260 1
a2260 1
  finfo.sec_ptrs = (asection **) bfd_malloc (amt);
d2262 1
a2262 1
  finfo.sym_indices = (long *) bfd_malloc (amt);
d2264 1
a2264 1
  finfo.outsyms = (bfd_byte *) bfd_malloc (amt);
d2266 3
a2268 3
  finfo.linenos = (bfd_byte *) bfd_malloc (amt);
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  finfo.external_relocs = (bfd_byte *) bfd_malloc (max_reloc_count * relsz);
d2272 1
a2272 1
      finfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);
d2274 7
a2280 7
  if ((finfo.internal_syms == NULL && max_sym_count > 0)
      || (finfo.sec_ptrs == NULL && max_sym_count > 0)
      || (finfo.sym_indices == NULL && max_sym_count > 0)
      || finfo.outsyms == NULL
      || (finfo.linenos == NULL && max_lineno_count > 0)
      || (finfo.contents == NULL && max_contents_size > 0)
      || (finfo.external_relocs == NULL && max_reloc_count > 0)
d2282 1
a2282 1
	  && finfo.internal_relocs == NULL
d2314 1
a2314 1
		  if (! _bfd_coff_link_input_bfd (&finfo, sub))
d2322 1
a2322 1
	      if (! _bfd_coff_reloc_link_order (abfd, &finfo, o, p))
d2338 1
a2338 1
	if (! _bfd_coff_link_input_bfd (&finfo, last_one))
d2346 1
a2346 1
  coff_debug_merge_hash_table_free (&finfo.debug_merge);
d2349 1
a2349 1
  if (finfo.internal_syms != NULL)
d2351 2
a2352 2
      free (finfo.internal_syms);
      finfo.internal_syms = NULL;
d2354 1
a2354 1
  if (finfo.sec_ptrs != NULL)
d2356 2
a2357 2
      free (finfo.sec_ptrs);
      finfo.sec_ptrs = NULL;
d2359 1
a2359 1
  if (finfo.sym_indices != NULL)
d2361 2
a2362 2
      free (finfo.sym_indices);
      finfo.sym_indices = NULL;
d2364 1
a2364 1
  if (finfo.linenos != NULL)
d2366 2
a2367 2
      free (finfo.linenos);
      finfo.linenos = NULL;
d2369 1
a2369 1
  if (finfo.contents != NULL)
d2371 2
a2372 2
      free (finfo.contents);
      finfo.contents = NULL;
d2374 1
a2374 1
  if (finfo.external_relocs != NULL)
d2376 2
a2377 2
      free (finfo.external_relocs);
      finfo.external_relocs = NULL;
d2379 1
a2379 1
  if (finfo.internal_relocs != NULL)
d2381 2
a2382 2
      free (finfo.internal_relocs);
      finfo.internal_relocs = NULL;
d2388 2
a2389 2
  if (finfo.last_file_index != -1
      && (unsigned int) finfo.last_file.n_value != obj_raw_syment_count (abfd))
d2393 4
a2396 4
      finfo.last_file.n_value = obj_raw_syment_count (abfd);
      bfd_coff_swap_sym_out (abfd, (PTR) &finfo.last_file,
			     (PTR) finfo.outsyms);
      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
d2398 1
a2398 1
	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
d2403 3
a2405 3
  finfo.failed = FALSE;
  bfd_hash_traverse (&info->hash->table, _bfd_coff_write_global_sym, &finfo);
  if (finfo.failed)
d2409 1
a2409 1
  if (finfo.outsyms != NULL)
d2411 2
a2412 2
      free (finfo.outsyms);
      finfo.outsyms = NULL;
d2435 1
a2435 1
	  irel = finfo.section_info[o->target_index].relocs;
d2437 1
a2437 1
	  rel_hash = finfo.section_info[o->target_index].rel_hashes;
d2460 1
a2460 1
  if (finfo.section_info != NULL)
d2466 4
a2469 4
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
d2471 2
a2472 2
      free (finfo.section_info);
      finfo.section_info = NULL;
d2493 1
a2493 1
		_bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
d2503 1
a2503 1
      if (! _bfd_stringtab_emit (abfd, finfo.strtab))
d2507 1
a2507 1
  _bfd_stringtab_free (finfo.strtab);
d2517 4
a2520 4
    coff_debug_merge_hash_table_free (&finfo.debug_merge);
  if (finfo.strtab != NULL)
    _bfd_stringtab_free (finfo.strtab);
  if (finfo.section_info != NULL)
d2526 4
a2529 4
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
d2531 1
a2531 1
      free (finfo.section_info);
d2533 16
a2548 16
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.sec_ptrs != NULL)
    free (finfo.sec_ptrs);
  if (finfo.sym_indices != NULL)
    free (finfo.sym_indices);
  if (finfo.outsyms != NULL)
    free (finfo.outsyms);
  if (finfo.linenos != NULL)
    free (finfo.linenos);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
@


1.40
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d2404 1
a2404 2
  coff_link_hash_traverse (coff_hash_table (info), _bfd_coff_write_global_sym,
			   (PTR) &finfo);
@


1.39
log
@	* bfd.c (bfd_perror): Flush stdout before and stderr after printing
	error.
	(_bfd_default_error_handler): Likewise.
	* elf.c (print_segment_map): Likewise.
	* libbfd.c (warn_deprecated): Likewise.
	* som.c (som_sizeof_headers): No need to do so here.
	* coff-i860.c: Replace use of printf for error messages with
	_bfd_error_handler.
	* coff-ppc.c: Likewise.
	* coff-sh.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-mep.c: Likewise.
	* elf32-v850.c: Likewise.
	* mach-o.c: Likewise.
	* pef.c: Likewise.
@
text
@d2585 1
d2645 1
@


1.38
log
@fix set but unused variable warnings
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d1846 3
a1848 4
      fprintf (stderr,
	      _("Warning: Unsupported reloc %s [%d] used -- it may not work.\n"),
	      ppc_coff_howto_table[r_type].name,
	      r_type);
d1918 3
a1920 4
      fprintf (stderr,
	      _("Warning: Unsupported reloc %s [%d] used -- it may not work.\n"),
	      ppc_coff_howto_table[r_type].name,
	      r_type);
@


1.38.4.1
log
@backport from mainline
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d1846 4
a1849 3
      (*_bfd_error_handler) (_("warning: unsupported reloc %s [%d] used -- it may not work"),
			     ppc_coff_howto_table[r_type].name,
			     r_type);
d1919 4
a1922 3
      (*_bfd_error_handler) (_("warning: unsupported reloc %s [%d] used -- it may not work"),
			     ppc_coff_howto_table[r_type].name,
			     r_type);
@


1.37
log
@2009-01-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* coff-ppc.c: Add 2009 to Copyright.
	* elf32-cris.c: Likewise.
	* elflink.c: Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
a869 2
  const char *name;

a917 2
      name = h->root.root.root.string;

a1008 2
  bfd_boolean hihalf;
  bfd_vma hihalf_val;
a1018 3
  hihalf = FALSE;
  hihalf_val = 0;

a1268 3
	    bfd_vma x;
	    const char *my_name;
	    
a1272 1
		my_name = h->root.root.root.string;
a1274 1
		    x = bfd_get_32 (input_bfd, loc);
@


1.36
log
@PR 9682
   * coff-ppc.c (dump_toc): Fix up calls to fprintf without a string
   literal.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.35
log
@Silence gcc printf warnings
@
text
@d1546 3
a1548 3
  fprintf (file, _(h1));
  fprintf (file, _(h2));
  fprintf (file, _(h3));
@


1.34
log
@	* coff-arm.c (arm_emit_base_file_entry): Check fwrite return value.
	Return status.  Adjust callers.
	* coff-mcore.c (mcore_emit_base_file_entry): Likewise.
	* coff-ppc.c (write_base_file_entry): New function.
	(coff_ppc_relocate_section): Use it.
	* elf32-arm.c (find_thumb_glue): Check asprintf return status.
	(find_arm_glue): Likewise.
	* vms-misc.c (_bfd_vms_output_flush): Check fwrite return value.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d1569 2
a1570 2
		       global_toc_size, global_toc_size,
		       thunk_size, thunk_size);
@


1.33
log
@Switch sources over to use the GPL version 3
@
text
@d985 12
d1252 2
a1253 4
		if (coff_data (output_bfd)->pe)
		  addr -= pe_data(output_bfd)->pe_opthdr.ImageBase;

		fwrite (&addr, 1,4, (FILE *) info->base_file);
d1466 4
a1469 4
	      bfd_vma addr = rel->r_vaddr
		- input_section->vma
		+ input_section->output_offset
		  + input_section->output_section->vma;
d1471 2
a1472 4
	      if (coff_data (output_bfd)->pe)
		addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;

	      fwrite (&addr, 1,4, (FILE *) info->base_file);
@


1.32
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d16 1
a16 1
   the Free Software Foundation; either version 2 of the License, or
@


1.31
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d36 1
a37 2
#include "sysdep.h"

@


1.30
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
d1964 7
d1972 9
a1980 1
#undef HOW2MAP
d1989 1
@


1.29
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d1335 1
a1335 1
	    if (strncmp(".idata$2",input_section->name,8) == 0 && first_thunk_address == 0)
@


1.28
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
a129 5
static bfd_boolean ppc_coff_link_hash_table_init
  PARAMS ((struct ppc_coff_link_hash_table *, bfd *,
	   struct bfd_hash_entry *(*) (struct bfd_hash_entry *,
				       struct bfd_hash_table *,
				       const char *)));
d182 6
a187 6
ppc_coff_link_hash_table_init (table, abfd, newfunc)
     struct ppc_coff_link_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
d189 1
a189 1
  return _bfd_coff_link_hash_table_init (&table->root, abfd, newfunc);
d204 3
a206 2
  if (! ppc_coff_link_hash_table_init (ret, abfd,
					ppc_coff_link_hash_newfunc))
@


1.27
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d26 1
a26 1
   Foundation, 59 Temple Place - Suite 330,
@


1.26
log
@Update the FSF address in the copyright/GPL notice
@
text
@d2116 1
a2116 1
      for (p = o->link_order_head; p != NULL; p = p->next)
d2298 1
a2298 1
      for (p = o->link_order_head; p != NULL; p = p->next)
@


1.25
log
@update copyright dates
@
text
@d27 1
a27 1
   Boston, MA 02111-1307, USA.  */
@


1.24
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
@


1.23
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@a328 9
#if 0
static bfd_reloc_status_type ppc_reflo_reloc PARAMS ((bfd *abfd,
						      arelent *reloc,
						      asymbol *symbol,
						      PTR data,
						      asection *section,
						      bfd *output_bfd,
						      char **error));
#endif
a344 9
#if 0
static bfd_reloc_status_type ppc_addr32nb_reloc PARAMS ((bfd *abfd,
							 arelent *reloc,
							 asymbol *symbol,
							 PTR data,
							 asection *section,
							 bfd *output_bfd,
							 char **error));
#endif
a989 61
#if 0

/* This function is in charge of performing all the ppc PE relocations
   Don't yet know if we want to do this this particular way ... (krk).  */
/* FIXME: (it is not yet enabled).  */

static bfd_reloc_status_type
pe_ppc_reloc (abfd, reloc_entry, symbol_in, data, input_section, output_bfd,
	      error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol_in;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* The consth relocation comes in two parts, we have to remember
     the state between calls, in these variables.  */
  static bfd_boolean part1_consth_active = FALSE;
  static unsigned long part1_consth_value;

  unsigned long sym_value;
  unsigned short r_type;
  unsigned long addr = reloc_entry->address ; /*+ input_section->vma*/

  r_type = reloc_entry->howto->type;

  if (output_bfd)
    {
      /* Partial linking - do nothing.  */
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (symbol_in != NULL
      && bfd_is_und_section (symbol_in->section))
    {
      /* Keep the state machine happy in case we're called again.  */
      if (r_type == IMAGE_REL_PPC_REFHI)
	{
	  part1_consth_active = TRUE;
	  part1_consth_value  = 0;
	}
      return(bfd_reloc_undefined);
    }

  if ((part1_consth_active) && (r_type != IMAGE_REL_PPC_PAIR))
    {
      part1_consth_active = FALSE;
      *error_message = (char *) _("Missing PAIR");
      return(bfd_reloc_dangerous);
    }

  sym_value = get_symbol_value(symbol_in);

  return(bfd_reloc_ok);
}

#endif /* 0 */

a1696 24
#if 0

static bfd_reloc_status_type
ppc_reflo_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  UN_IMPL("REFLO");
  DUMP_RELOC("REFLO",reloc_entry);

  if (output_bfd == (bfd *) NULL)
    return bfd_reloc_continue;

  return bfd_reloc_undefined;
}

#endif

a1736 25
#if 0

/* ADDR32NB : 32 bit address relative to the virtual origin.
              (On the alpha, this is always a linker generated thunk)
              (i.e. 32bit addr relative to the image base).  */

static bfd_reloc_status_type
ppc_addr32nb_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  UN_IMPL("ADDR32NB");
  DUMP_RELOC("ADDR32NB",reloc_entry);

  return bfd_reloc_ok;
}

#endif

a1982 4
/* FIXME: This no longer works.  */
#if 0
#define coff_swap_sym_in_hook        ppc_coff_swap_sym_in_hook
#endif
a2010 56
/* FIXME: This no longer works.  */
#if 0
/* FIXME:
   What we're trying to do here is allocate a toc section (early), and attach
   it to the last bfd to be processed. This avoids the problem of having a toc
   written out before all files have been processed. This code allocates
   a toc section for every file, and records the last one seen. There are
   at least two problems with this approach:
   1. We allocate whole bunches of toc sections that are ignored, but at
      at least we will not allocate a toc if no .toc is present.
   2. It's not clear to me that being the last bfd read necessarily means
      that you are the last bfd closed.
   3. Doing it on a "swap in" hook depends on when the "swap in" is called,
      and how often, etc. It's not clear to me that there isn't a hole here.  */
static void ppc_coff_swap_sym_in_hook PARAMS ((bfd *, PTR, PTR));

static void
ppc_coff_swap_sym_in_hook (abfd, ext1, in1)
     bfd            *abfd;
     PTR ext1 ATTRIBUTE_UNUSED;
     PTR in1;
{
  struct internal_syment * in = (struct internal_syment *)in1;

  if (bfd_of_toc_owner != 0) /* We already have a toc, so go home.  */
    return;

  if (strcmp (in->_n._n_name, ".toc") == 0)
    {
      flagword flags;
      register asection *s;

      s = bfd_get_section_by_name (abfd, TOC_SECTION_NAME);
      if (s != NULL)
	return;

      flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY ;

      s = bfd_make_section (abfd, TOC_SECTION_NAME);

      if (s == NULL
	  || !bfd_set_section_flags (abfd, s, flags)
	  || !bfd_set_section_alignment (abfd, s, 2))
	/* FIXME: set appropriate bfd error.  */
	abort ();

      /* Save the bfd for later allocation.  */
      bfd_of_toc_owner = abfd;
    }

  return;
}
#endif
#endif

#ifndef COFF_IMAGE_WITH_PE
@


1.22
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d1566 1
a1566 1
	      name = h->root.root.root.string;
d1580 1
a1580 1
		   (info, name, howto->name,
@


1.21
log
@	* bfd-in.h (struct stab_info): Move from stabs.c.
	* stabs.c (struct stab_link_includes_table): Delete.
	(stab_link_includes_lookup): Delete.
	(_bfd_write_section_stabs, _bfd_write_stab_strings): Remove one
	level of indirection from sinfo parm.
	(_bfd_link_section_stabs): Likewise.  Set SEC_LINKER_CREATED on
	stabstr section.  Adjust hash table accesses.
	* coff-ppc.c (ppc_bfd_coff_final_link): Do include rawsize in contents
	alloc.  Adjust stab_info test.
	* cofflink.c (_bfd_coff_link_hash_table_init): Clear stab_info.
	(_bfd_coff_final_link): Adjust stab_info test.
	(_bfd_coff_link_input_bfd): Ignore SEC_LINKER_CREATED sections.
	* elf-bfd.h (struct elf_link_hash_table): Include struct stab_info
	in place.
	* libcoff-in.h (struct coff_link_hash_table): Likewise.
	* elf.c (_bfd_elf_link_hash_table_init): Clear stab_info.
	* elflink.c (bfd_elf_final_link): Don't attempt to link linker created
	stabstr section.  Adjust stab_info test.
	* libbfd-in.h (_bfd_link_section_stabs, _bfd_write_section_stabs)
	(_bfd_write_stab_strings): Adjust prototypes.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d1191 1
a1191 2
	    (_("%s: unsupported relocation type 0x%02x"),
	     bfd_archive_filename (input_bfd), r_type);
d1280 2
a1281 2
			  (_("%s: Relocation for %s of %lx exceeds Toc size limit"),
			   bfd_archive_filename (input_bfd), name,
d1335 2
a1336 3
		  (_("%s: Relocation exceeds allocated TOC (%lx)"),
		   bfd_archive_filename (input_bfd),
		   (unsigned long) toc_section->size);
d1388 6
a1393 9
	    fprintf (stderr,
		    _("Warning: unsupported reloc %s <file %s, section %s>\n"),
		    howto->name,
		    bfd_archive_filename(input_bfd),
		    input_section->name);

	    fprintf (stderr,"sym %ld (%s), r_vaddr %ld (%lx)\n",
		    rel->r_symndx, my_name, (long) rel->r_vaddr,
		    (unsigned long) rel->r_vaddr);
d1407 1
a1407 2
	      (_("%s: Out of order IMGLUE reloc for %s"),
	       bfd_archive_filename (input_bfd), my_name);
@


1.20
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d2331 2
d2668 1
a2668 1
  if (coff_hash_table (info)->stab_info != NULL)
@


1.19
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d1333 1
a1333 1
		&& (bfd_vma) our_toc_offset > toc_section->_raw_size)
d1338 1
a1338 1
		   (unsigned long) toc_section->_raw_size);
d1693 1
a1693 1
  s->_raw_size = s->_cooked_size = global_toc_size;
d2331 2
a2332 2
	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
@


1.19.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d1191 2
a1192 1
	    (_("%B: unsupported relocation type 0x%02x"), input_bfd, r_type);
d1281 2
a1282 2
			  (_("%B: Relocation for %s of %lx exceeds Toc size limit"),
			   input_bfd, name,
d1333 1
a1333 1
		&& (bfd_vma) our_toc_offset > toc_section->size)
d1336 3
a1338 2
		  (_("%B: Relocation exceeds allocated TOC (%lx)"),
		   input_bfd, (unsigned long) toc_section->size);
d1390 9
a1398 6
	    (*_bfd_error_handler)
	      (_("Warning: unsupported reloc %s <file %B, section %A>\n"
		 "sym %ld (%s), r_vaddr %ld (%lx)"),
	       input_bfd, input_section, howto->name,
	       rel->r_symndx, my_name, (long) rel->r_vaddr,
	       (unsigned long) rel->r_vaddr);
d1412 2
a1413 1
	      (_("%B: Out of order IMGLUE reloc for %s"), input_bfd, my_name);
d1693 1
a1693 1
  s->size = global_toc_size;
d2331 2
a2332 4
	      if (sec->rawsize > max_contents_size)
		max_contents_size = sec->rawsize;
	      if (sec->size > max_contents_size)
		max_contents_size = sec->size;
d2666 1
a2666 1
  if (coff_hash_table (info)->stab_info.stabstr != NULL)
@


1.18
log
@Correct spelling of "relocatable".
@
text
@d932 1
a932 1
	  /* The size must fit in a 16bit displacment.  */
d952 1
a952 1
	  /* The size must fit in a 16bit displacment.  */
d1277 1
a1277 1
		    /* The size must still fit in a 16bit displacment.  */
d1934 1
a1934 1
/* FIXME: There is a possiblity that when we read in a reloc from a file,
@


1.17
log
@Fix typo: intial -> initial.
@
text
@d1091 1
a1091 1
  /* If we are performing a relocateable link, we don't need to do a
d1094 1
a1094 1
  if (info->relocateable)
d2328 1
a2328 1
	      if (info->relocateable)
d2338 1
a2338 1
	  else if (info->relocateable
d2353 1
a2353 1
  /* If doing a relocateable link, allocate space for the pointers we
d2355 1
a2355 1
  if (info->relocateable)
d2404 1
a2404 1
	     but only when doing a relocateable link, which is not the
d2406 1
a2406 1
	  BFD_ASSERT (info->relocateable);
d2458 1
a2458 1
  if (! info->relocateable)
d2470 1
a2470 1
      || (! info->relocateable
d2605 1
a2605 1
  if (info->relocateable)
@


1.16
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d12 1
a12 1
This file is part of BFD, the Binary File Descriptor library.
d14 14
a27 14
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.  */
d34 1
a34 2
     not produce the right glue code for dll function calls.
*/
d60 9
a68 9
/* The toc is a set of bfd_vma fields. We use the fact that valid         */
/* addresses are even (i.e. the bit representing "1" is off) to allow     */
/* us to encode a little extra information in the field                   */
/* - Unallocated addresses are intialized to 1.                           */
/* - Allocated addresses are even numbers.                                */
/* The first time we actually write a reference to the toc in the bfd,    */
/* we want to record that fact in a fixup file (if it is asked for), so   */
/* we keep track of whether or not an address has been written by marking */
/* the low order bit with a "1" upon writing                              */
d77 1
a77 1
/* Turn on this check if you suspect something amiss in the hash tables */
d80 1
a80 1
/* Need a 7 char string for an eye catcher */
d103 1
a103 1
   linker, we define our own hash table, derived from the coff one */
d109 1
a109 1
  struct coff_link_hash_entry root; /* First entry, as required  */
d112 2
a113 2
     here */
  bfd_vma toc_offset;               /* Our addition, as required */
d124 1
a124 1
  struct coff_link_hash_table root; /* First entry, as required */
d174 1
a174 1
      SET_UNALLOCATED(ret->toc_offset);
d178 1
a178 1
      HASH_CHECK_INIT(ret);
d218 1
a218 1
/* Now, tailor coffcode.h to use our hash stuff */
d222 3
a224 3
/* The nt loader points the toc register to &toc + 32768, in order to */
/* use the complete range of a 16-bit displacement. We have to adjust */
/* for this when we fix up loads displaced off the toc reg.           */
d236 1
a236 1
/* these should definitely go in a header file somewhere...  */
d286 3
a288 3
/* stuff to handle immediate data when the number of bits in the */
/* data is greater than the number of bits in the immediate field */
/* We need to do (usually) 32 bit arithmetic on 16 bit chunks */
d293 1
a293 1
/* This is essentially the same as tocrel16, with TOCDEFN assumed */
d296 1
a296 1
/*  Flag bits in IMAGE_RELOCATION.TYPE */
d298 1
a298 1
/* subtract reloc value rather than adding it */
d301 1
a301 1
/* fix branch prediction bit to predict branch taken */
d304 1
a304 1
/* fix branch prediction bit to predict branch not taken */
d307 1
a307 1
/* toc slot defined in file (or, data in toc) */
d310 1
a310 1
/* masks to isolate above values in IMAGE_RELOCATION.Type */
d319 1
a319 1
/* static helper functions to make relocation work */
d391 29
a419 1
   completely unverified or have a specific unknown marked in the comment */
a420 33
/*---------------------------------------------------------------------------*/
/*                                                                           */
/* Relocation entries for Windows/NT on PowerPC.                             */
/*                                                                           */
/* From the document "" we find the following listed as used relocs:         */
/*                                                                           */
/*   ABSOLUTE       : The noop                                               */
/*   ADDR[64|32|16] : fields that hold addresses in data fields or the       */
/*                    16 bit displacement field on a load/store.             */
/*   ADDR[24|14]    : fields that hold addresses in branch and cond          */
/*                    branches. These represent [26|16] bit addresses.       */
/*                    The low order 2 bits are preserved.                    */
/*   REL[24|14]     : branches relative to the Instruction Address           */
/*                    register. These represent [26|16] bit addresses,       */
/*                    as before. The instruction field will be zero, and     */
/*                    the address of the SYM will be inserted at link time.  */
/*   TOCREL16       : 16 bit displacement field referring to a slot in       */
/*                    toc.                                                   */
/*   TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14.  */
/*   ADDR32NB       : 32 bit address relative to the virtual origin.         */
/*                    (On the alpha, this is always a linker generated thunk)*/
/*                    (i.e. 32bit addr relative to the image base)           */
/*   SECREL         : The value is relative to the start of the section      */
/*                    containing the symbol.                                 */
/*   SECTION        : access to the header containing the item. Supports the */
/*                    codeview debugger.                                     */
/*                                                                           */
/* In particular, note that the document does not indicate that the          */
/* relocations listed in the header file are used.                           */
/*                                                                           */
/*                                                                           */
/*                                                                           */
/*---------------------------------------------------------------------------*/
d764 1
a764 1
/* Some really cheezy macros that can be turned on to test stderr :-) */
d789 1
a789 3
#define n_offset	_n._n_n._n_offset

*/
d791 4
a794 4
#define DUMP_RELOC2(n,r)                     \
{                                            \
   fprintf (stderr,"%s sym %d, r_vaddr %d %s\n", \
	   n, r->r_symndx, r->r_vaddr,\
d796 1
a796 1
	   ?" ":" TOCDEFN"  );      \
d805 1
a805 1
/* toc construction and management routines */
d810 1
a810 1
extern bfd* bfd_of_toc_owner;
a811 1

d852 1
a852 1
  /* add this entry to our toc addr-offset-name list */
d883 1
a883 1
/* record a toc offset against a symbol */
d908 1
d913 1
d920 1
d932 1
a932 1
	  /* The size must fit in a 16bit displacment */
d945 2
a946 2
      /* check to see if there's a toc slot allocated. If not, do it
	 here. It will be used in relocate_section */
d952 1
a952 1
	  /* The size must fit in a 16bit displacment */
d965 1
a965 1
/* record a toc offset against a symbol */
d1010 3
a1012 3
/* this function is in charge of performing all the ppc PE relocations */
/* Don't yet know if we want to do this this particular way ... (krk)  */
/* FIXME: (it is not yet enabled) */
d1025 2
a1026 2
  /* the consth relocation comes in two parts, we have to remember
     the state between calls, in these variables */
d1038 1
a1038 1
      /* Partial linking - do nothing */
d1046 1
a1046 1
      /* Keep the state machine happy in case we're called again */
d1148 1
a1148 1
      /* FIXME: PAIR unsupported in the following code */
d1186 1
a1186 1
      /* Each case must do its own relocation, setting rstat appropriately */
d1214 5
a1218 7
	    /*
	     *  Amazing bit tricks present. As we may have seen earlier, we
	     *  use the 1 bit to tell us whether or not a toc offset has been
	     *  allocated. Now that they've all been allocated, we will use
	     *  the 1 bit to tell us if we've written this particular toc
	     *  entry out.
	     */
d1221 2
a1222 1
	      { /* it is a file local symbol */
d1234 1
a1234 1
		    /* if it has been written out, it is marked with the
d1236 1
a1236 2
		       again.
		     */
d1241 1
a1241 1
		    /* write out the toc entry */
d1272 1
a1272 2
		       the IAT to be part of the toc, thus saving a load.
		    */
d1277 1
a1277 1
		    /* The size must still fit in a 16bit displacment */
d1291 1
a1291 1
		else if (IS_WRITTEN(our_toc_offset))
d1293 1
a1293 1
		    /* if it has been written out, it is marked with the
d1295 1
a1295 2
		       again.
		     */
d1303 1
a1303 1
		    /* write out the toc entry */
d1308 2
a1309 2
		    /* The tricky part is that this is the address that */
		    /* needs a .reloc entry for it */
d1317 1
a1317 1
		   to a section or a common symbol, then it needs a reloc */
d1319 1
a1319 1
		/* relocation to a symbol in a section which
d1321 1
a1321 2
		   to a file */

d1325 1
a1325 1
		if (coff_data(output_bfd)->pe)
d1331 1
a1331 1
	    /* FIXME: this test is conservative */
d1343 1
a1343 1
	    /* Now we know the relocation for this toc reference */
d1350 4
a1353 5
	    /* To solve this, we need to know whether or not the symbol */
	    /* appearing on the call instruction is a glue function or not.  */
	    /* A glue function must announce itself via a IMGLUE reloc, and */
	    /* the reloc contains the required toc restore instruction */

d1356 2
a1357 1
	    DUMP_RELOC2(howto->name, rel);
d1371 1
a1371 1
	  /* Unimplemented: codeview debugging information */
d1376 1
a1376 1
	  /* Unimplemented: codeview debugging information */
d1379 1
a1379 1
	     symbol */
d1384 1
d1386 1
a1386 1
		my_name = (syms+symndx)->_n._n_name;
d1388 1
a1388 3
	      {
		my_name = h->root.root.root.string;
	      }
d1404 1
a1404 1
	       pass over the relocs, and the glue instruction extracted */
d1406 1
d1421 2
a1422 1
	    DUMP_RELOC2(howto->name, rel);
d1426 1
a1426 1
		/* set magic values */
d1429 1
d1451 2
a1452 1
	      { /* it is a file local symbol */
d1461 1
a1461 1
		if (strcmp(".idata$2", name) == 0)
d1463 1
a1463 1
		else if (strcmp(".idata$4", name) == 0)
d1465 1
a1465 1
		else if (strcmp(".idata$5", name) == 0)
d1509 4
a1512 4
		      	      input_bfd,
			      val -
			      pe_data(output_bfd)->pe_opthdr.ImageBase,
			      loc);
d1537 1
a1537 1
      if ( info->base_file )
d1540 2
a1541 2
	     to a section or a common symbol, then it needs a reloc */
	  if (sym && pe_data(output_bfd)->in_reloc_p(output_bfd, howto))
d1543 1
a1543 1
	      /* relocation to a symbol in a section which
d1545 1
a1545 1
		 to a file */
d1551 3
a1553 4
	      if (coff_data(output_bfd)->pe)
		{
		  addr -= pe_data(output_bfd)->pe_opthdr.ImageBase;
		}
d1589 1
a1589 3
	      {
		return FALSE;
	      }
a1591 1

d1677 1
a1677 1
  if ( global_toc_size == 0 ) /* FIXME: does this get me in trouble? */
d1681 2
a1682 4
    {
      /* No toc owner? Something is very wrong.  */
      abort ();
    }
d1686 2
a1687 4
    {
      /* No toc section? Something is very wrong.  */
      abort ();
    }
d1707 1
a1707 1
  /* here we have a bfd that is to be included on the link. We have a hook
d1709 1
d1711 1
a1711 3
  _bfd_coff_get_external_symbols(abfd);

  /* rummage around all the relocs and map the toc */
d1715 1
a1715 3
    {
      return TRUE;
    }
d1718 3
a1720 3
  {
    if (sec->reloc_count == 0)
      continue;
d1722 3
a1724 3
    /* load the relocs */
    /* FIXME: there may be a storage leak here */
    i=_bfd_coff_read_internal_relocs(abfd,sec,1,0,0,0);
d1726 2
a1727 2
    if (i == 0)
      abort ();
d1729 5
a1733 5
    for (rel=i;rel<i+sec->reloc_count;++rel)
      {
	unsigned short r_type  = EXTRACT_TYPE (rel->r_type);
	unsigned short r_flags = EXTRACT_FLAGS(rel->r_type);
	bfd_boolean ok = TRUE;
d1735 1
a1735 1
	DUMP_RELOC2(ppc_coff_howto_table[r_type].name, rel);
d1737 19
a1755 19
	switch(r_type)
	  {
	  case IMAGE_REL_PPC_TOCREL16:
	    /* if TOCDEFN is on, ignore as someone else has allocated the
	       toc entry */
	    if ( (r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN )
	      ok = ppc_record_toc_entry(abfd, info, sec,
					rel->r_symndx, default_toc);
	    if (!ok)
	      return FALSE;
	    break;
	  case IMAGE_REL_PPC_IMGLUE:
	    ppc_mark_symbol_as_glue(abfd, rel->r_symndx, rel);
	    break;
	  default:
	    break;
	  }
      }
  }
d1763 2
a1764 7
ppc_refhi_reloc (abfd,
		 reloc_entry,
		 symbol,
		 data,
		 input_section,
		 output_bfd,
		 error_message)
d1785 2
a1786 7
ppc_reflo_reloc (abfd,
		 reloc_entry,
		 symbol,
		 data,
		 input_section,
		 output_bfd,
		 error_message)
d1807 2
a1808 7
ppc_pair_reloc (abfd,
		reloc_entry,
		symbol,
		data,
		input_section,
		output_bfd,
		error_message)
d1827 2
a1828 7
ppc_toc16_reloc (abfd,
		 reloc_entry,
		 symbol,
		 data,
		 input_section,
		 output_bfd,
		 error_message)
d1837 2
a1838 2
  UN_IMPL("TOCREL16");
  DUMP_RELOC("TOCREL16",reloc_entry);
d1841 1
a1841 3
    {
      return bfd_reloc_continue;
    }
d1848 3
a1850 5
/* ADDR32NB : 32 bit address relative to the virtual origin.         */
/*            (On the alpha, this is always a linker generated thunk)*/
/*            (i.e. 32bit addr relative to the image base)           */
/*                                                                   */
/*                                                                   */
d1853 2
a1854 7
ppc_addr32nb_reloc (abfd,
		    reloc_entry,
		    symbol,
		    data,
		    input_section,
		    output_bfd,
		    error_message)
d1872 2
a1873 7
ppc_secrel_reloc (abfd,
		  reloc_entry,
		  symbol,
		  data,
		  input_section,
		  output_bfd,
		  error_message)
d1892 2
a1893 7
ppc_section_reloc (abfd,
		   reloc_entry,
		   symbol,
		   data,
		   input_section,
		   output_bfd,
		   error_message)
d1912 2
a1913 7
ppc_imglue_reloc (abfd,
		  reloc_entry,
		  symbol,
		  data,
		  input_section,
		  output_bfd,
		  error_message)
d1936 2
a1937 4
	  type field. Not yet implemented.
*/
static void ppc_coff_rtype2howto PARAMS ((arelent *relent,
					  struct internal_reloc *internal));
a1943 1

d1952 1
a1952 2
     than that.
  */
d1958 1
a1958 1
  /* the masking process only slices off the bottom byte for r_type.  */
d1962 2
a1963 2
  /* check for absolute crap */
  if ( junk != 0 )
d1976 1
a1976 1
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, internal);
d1980 1
a1980 1
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, internal);
d1984 1
a1984 1
      DUMP_RELOC2(ppc_coff_howto_table[r_type].name, internal);
a1999 1

d2021 1
a2021 2
     than that.
  */
d2023 3
a2025 3
  unsigned short r_type  = EXTRACT_TYPE (rel->r_type);
  unsigned short r_flags = EXTRACT_FLAGS(rel->r_type);
  unsigned short junk    = EXTRACT_JUNK (rel->r_type);
d2027 2
a2028 2
  /* the masking process only slices off the bottom byte for r_type.  */
  if ( r_type > MAX_RELOC_INDEX )
d2031 2
a2032 2
  /* check for absolute crap */
  if ( junk != 0 )
d2075 1
a2075 1
/* a cheesy little macro to make the code a little more readable */
a2100 1
  /*NOTREACHED*/
d2162 1
a2162 2
      and how often, etc. It's not clear to me that there isn't a hole here.
*/
d2171 1
a2171 1
  struct internal_syment      *in = (struct internal_syment *)in1;
d2173 1
a2173 1
  if (bfd_of_toc_owner != 0) /* we already have a toc, so go home */
d2176 1
a2176 1
  if (strcmp(in->_n._n_name, ".toc") == 0)
d2181 1
a2181 1
      s = bfd_get_section_by_name ( abfd , TOC_SECTION_NAME);
d2183 1
a2183 3
	{
	  return;
	}
d2192 2
a2193 4
	{
	  /* FIXME: set appropriate bfd error */
	  abort ();
	}
d2195 1
a2195 1
      /* save the bfd for later allocation */
d2225 1
a2225 1
/* this piece of machinery exists only to guarantee that the bfd that holds
d2234 1
a2234 2
   precise form of comment. krk@@cygnus.com
*/
d2309 1
a2311 1

d2364 1
d2367 1
d2380 1
a2534 1

@


1.15
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d57 1
a57 1
extern boolean ppc_bfd_coff_final_link
d131 1
a131 1
static boolean ppc_coff_link_hash_table_init
d138 1
a138 1
static boolean coff_ppc_relocate_section
d187 1
a187 1
static boolean
d388 1
a388 1
static boolean in_reloc_p PARAMS((bfd *abfd, reloc_howto_type *howto));
d436 1
a436 1
	 false,	                 /* pc_relative */
d441 1
a441 1
	 false,	                 /* partial_inplace */
d444 1
a444 1
	 false),                 /* pcrel_offset */
d452 1
a452 1
	false,	                 /* pc_relative */
d457 1
a457 1
	true,	                 /* partial_inplace */
d460 1
a460 1
	false),                 /* pcrel_offset */
d468 1
a468 1
	 false,	                /* pc_relative */
d473 1
a473 1
	 true,	                /* partial_inplace */
d476 1
a476 1
	 false),                /* pcrel_offset */
d487 1
a487 1
	 false,	                /* pc_relative */
d492 1
a492 1
	 true,	                /* partial_inplace */
d495 1
a495 1
	 false),                /* pcrel_offset */
d503 1
a503 1
	 false,	                /* pc_relative */
d508 1
a508 1
	 true,	                /* partial_inplace */
d511 1
a511 1
	 false),                /* pcrel_offset */
d521 1
a521 1
	 false,	                /* pc_relative */
d526 1
a526 1
	 true,	                /* partial_inplace */
d529 1
a529 1
	 false),                /* pcrel_offset */
d538 1
a538 1
	 true,	                /* pc_relative */
d543 1
a543 1
	 true,	                /* partial_inplace */
d546 1
a546 1
	 false),                /* pcrel_offset */
d557 1
a557 1
	 false,	                /* pc_relative */
d562 1
a562 1
	 true,	                /* partial_inplace */
d565 1
a565 1
	 true),                 /* pcrel_offset */
d574 1
a574 1
	 false,	                /* pc_relative */
d579 1
a579 1
	 false,	                /* partial_inplace */
d582 1
a582 1
	 false),                /* pcrel_offset */
d591 1
a591 1
	 false,	                /* pc_relative */
d596 1
a596 1
	 false,	                /* partial_inplace */
d599 1
a599 1
	 false),                /* pcrel_offset */
d608 1
a608 1
	 false,	                /* pc_relative */
d613 1
a613 1
	 true,	                /* partial_inplace */
d616 1
a616 1
	 false),                 /* pcrel_offset */
d625 1
a625 1
	 false,	                /* pc_relative */
d630 1
a630 1
	 true,	                /* partial_inplace */
d633 1
a633 1
	 true),                 /* pcrel_offset */
d642 1
a642 1
	 false,	                /* pc_relative */
d647 1
a647 1
	 true,	                /* partial_inplace */
d650 1
a650 1
	 true),                 /* pcrel_offset */
d659 1
a659 1
	 false,	                /* pc_relative */
d664 1
a664 1
	 true,	                /* partial_inplace */
d667 1
a667 1
	 false),                /* pcrel_offset */
d676 1
a676 1
	 false,	                /* pc_relative */
d681 1
a681 1
	 false,	                /* partial_inplace */
d684 1
a684 1
	 false),                 /* pcrel_offset */
d693 1
a693 1
	 false,	                /* pc_relative */
d698 1
a698 1
	 true,	                /* partial_inplace */
d701 1
a701 1
	 true),                 /* pcrel_offset */
d709 1
a709 1
	 false,	                /* pc_relative */
d714 1
a714 1
	 true,	                /* partial_inplace */
d717 1
a717 1
	 false),                 /* pcrel_offset */
d725 1
a725 1
	 false,	                /* pc_relative */
d730 1
a730 1
	 true,	                /* partial_inplace */
d733 1
a733 1
	 false),                /* pcrel_offset */
d741 1
a741 1
	 false,	                /* pc_relative */
d746 1
a746 1
	 true,	                /* partial_inplace */
d749 1
a749 1
	 false),                /* pcrel_offset */
d758 1
a758 1
	 false,	                /* pc_relative */
d763 1
a763 1
	 false,	                /* partial_inplace */
d766 1
a766 1
	 false),                /* pcrel_offset */
d887 1
a887 1
static boolean ppc_record_toc_entry
d893 1
a893 1
static boolean
d925 1
a925 1
	    return false;
d943 1
a943 1
	      return false;
d963 1
a963 1
	      return false;
d968 1
a968 1
  return true;
d992 1
a992 1
/* Return true if this relocation should
d995 1
a995 1
static boolean in_reloc_p(abfd, howto)
d1033 1
a1033 1
  static boolean part1_consth_active = false;
d1055 1
a1055 1
	  part1_consth_active = true;
d1063 1
a1063 1
      part1_consth_active = false;
d1077 1
a1077 1
static boolean
d1091 1
a1091 1
  boolean hihalf;
d1101 1
a1101 1
    return true;
d1103 1
a1103 1
  hihalf = false;
d1185 2
a1186 2
		      rel->r_vaddr - input_section->vma, true)))
		return false;
d1200 1
a1200 1
	  return false;
d1227 1
a1227 1
	    fixit = false;
d1257 1
a1257 1
		    fixit = true;
d1294 1
a1294 1
			return false;
d1320 1
a1320 1
		    fixit = true;
d1351 1
a1351 1
		return false;
d1426 1
a1426 1
	    return false;
d1441 1
a1441 1
					     false, false, true);
d1450 1
a1450 1
					     false, false, true);
d1455 1
a1455 1
					     false, false, true);
d1482 1
a1482 1
						 false, false, true);
d1496 1
a1496 1
						     false, false, true);
d1505 1
a1505 1
						     false, false, true);
d1510 1
a1510 1
						     false, false, true);
d1599 1
a1599 1
		return false;
d1606 1
a1606 1
  return true;
d1680 1
a1680 1
boolean
d1690 1
a1690 1
    return true;
d1712 1
a1712 1
  return true;
d1715 1
a1715 1
boolean
d1733 1
a1733 1
      return true;
d1752 1
a1752 1
	boolean ok = true;
d1765 1
a1765 1
	      return false;
d1776 1
a1776 1
  return true;
d2281 1
a2281 1
static boolean ppc_do_last PARAMS ((bfd *));
d2284 1
a2284 1
static boolean
d2289 1
a2289 1
    return true;
d2291 1
a2291 1
    return false;
d2314 1
a2314 1
boolean
d2321 1
a2321 1
  boolean debug_merge_allocated;
d2354 1
a2354 1
  debug_merge_allocated = false;
d2364 1
a2364 1
  debug_merge_allocated = true;
d2370 1
a2370 1
	return false;
d2398 1
a2398 1
	      sec->linker_mark = true;
d2512 1
a2512 1
      sub->output_has_begun = false;
d2578 1
a2578 1
		  sub->output_has_begun = true;
d2603 1
a2603 1
    last_one->output_has_begun = true;
d2610 1
a2610 1
  debug_merge_allocated = false;
d2662 1
a2662 1
	return false;
d2666 1
a2666 1
  finfo.failed = false;
d2743 1
a2743 1
	return false;
d2753 1
a2753 1
	return false;
d2765 1
a2765 1
	return false;
d2768 1
a2768 1
	return false;
d2777 1
a2777 1
  return true;
d2815 1
a2815 1
  return false;
@


1.15.20.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d12 1
a12 1
   This file is part of BFD, the Binary File Descriptor library.
d14 14
a27 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d34 2
a35 1
     not produce the right glue code for dll function calls.  */
d57 1
a57 1
extern bfd_boolean ppc_bfd_coff_final_link
d61 9
a69 9
/* The toc is a set of bfd_vma fields. We use the fact that valid
   addresses are even (i.e. the bit representing "1" is off) to allow
   us to encode a little extra information in the field
   - Unallocated addresses are initialized to 1.
   - Allocated addresses are even numbers.
   The first time we actually write a reference to the toc in the bfd,
   we want to record that fact in a fixup file (if it is asked for), so
   we keep track of whether or not an address has been written by marking
   the low order bit with a "1" upon writing.  */
d78 1
a78 1
/* Turn on this check if you suspect something amiss in the hash tables.  */
d81 1
a81 1
/* Need a 7 char string for an eye catcher.  */
d104 1
a104 1
   linker, we define our own hash table, derived from the coff one.  */
d110 1
a110 1
  struct coff_link_hash_entry root; /* First entry, as required.  */
d113 2
a114 2
     here.  */
  bfd_vma toc_offset;               /* Our addition, as required.  */
d125 1
a125 1
  struct coff_link_hash_table root; /* First entry, as required.  */
d131 1
a131 1
static bfd_boolean ppc_coff_link_hash_table_init
d138 1
a138 1
static bfd_boolean coff_ppc_relocate_section
d175 1
a175 1
      SET_UNALLOCATED (ret->toc_offset);
d179 1
a179 1
      HASH_CHECK_INIT (ret);
d187 1
a187 1
static bfd_boolean
d219 1
a219 1
/* Now, tailor coffcode.h to use our hash stuff.  */
d223 3
a225 3
/* The nt loader points the toc register to &toc + 32768, in order to
   use the complete range of a 16-bit displacement. We have to adjust
   for this when we fix up loads displaced off the toc reg.  */
d237 1
a237 1
/* These should definitely go in a header file somewhere...  */
d287 3
a289 3
/* Stuff to handle immediate data when the number of bits in the
   data is greater than the number of bits in the immediate field
   We need to do (usually) 32 bit arithmetic on 16 bit chunks.  */
d294 1
a294 1
/* This is essentially the same as tocrel16, with TOCDEFN assumed.  */
d297 1
a297 1
/* Flag bits in IMAGE_RELOCATION.TYPE.  */
d299 1
a299 1
/* Subtract reloc value rather than adding it.  */
d302 1
a302 1
/* Fix branch prediction bit to predict branch taken.  */
d305 1
a305 1
/* Fix branch prediction bit to predict branch not taken.  */
d308 1
a308 1
/* TOC slot defined in file (or, data in toc).  */
d311 1
a311 1
/* Masks to isolate above values in IMAGE_RELOCATION.Type.  */
d320 1
a320 1
/* Static helper functions to make relocation work.  */
d388 1
a388 1
static bfd_boolean in_reloc_p PARAMS((bfd *abfd, reloc_howto_type *howto));
d392 1
a392 29
   completely unverified or have a specific unknown marked in the comment.  */

/* Relocation entries for Windows/NT on PowerPC.                             

   From the document "" we find the following listed as used relocs:

     ABSOLUTE       : The noop
     ADDR[64|32|16] : fields that hold addresses in data fields or the
                      16 bit displacement field on a load/store.
     ADDR[24|14]    : fields that hold addresses in branch and cond
                      branches. These represent [26|16] bit addresses.
                      The low order 2 bits are preserved.
     REL[24|14]     : branches relative to the Instruction Address
                      register. These represent [26|16] bit addresses,
                      as before. The instruction field will be zero, and
                      the address of the SYM will be inserted at link time.
     TOCREL16       : 16 bit displacement field referring to a slot in
                      toc.
     TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14.
     ADDR32NB       : 32 bit address relative to the virtual origin.
                      (On the alpha, this is always a linker generated thunk)
                      (i.e. 32bit addr relative to the image base)
     SECREL         : The value is relative to the start of the section
                      containing the symbol.
     SECTION        : access to the header containing the item. Supports the
                      codeview debugger.

   In particular, note that the document does not indicate that the
   relocations listed in the header file are used.  */
d394 33
d436 1
a436 1
	 FALSE,	                 /* pc_relative */
d441 1
a441 1
	 FALSE,	                 /* partial_inplace */
d444 1
a444 1
	 FALSE),                 /* pcrel_offset */
d452 1
a452 1
	FALSE,	                 /* pc_relative */
d457 1
a457 1
	TRUE,	                 /* partial_inplace */
d460 1
a460 1
	FALSE),                 /* pcrel_offset */
d468 1
a468 1
	 FALSE,	                /* pc_relative */
d473 1
a473 1
	 TRUE,	                /* partial_inplace */
d476 1
a476 1
	 FALSE),                /* pcrel_offset */
d487 1
a487 1
	 FALSE,	                /* pc_relative */
d492 1
a492 1
	 TRUE,	                /* partial_inplace */
d495 1
a495 1
	 FALSE),                /* pcrel_offset */
d503 1
a503 1
	 FALSE,	                /* pc_relative */
d508 1
a508 1
	 TRUE,	                /* partial_inplace */
d511 1
a511 1
	 FALSE),                /* pcrel_offset */
d521 1
a521 1
	 FALSE,	                /* pc_relative */
d526 1
a526 1
	 TRUE,	                /* partial_inplace */
d529 1
a529 1
	 FALSE),                /* pcrel_offset */
d538 1
a538 1
	 TRUE,	                /* pc_relative */
d543 1
a543 1
	 TRUE,	                /* partial_inplace */
d546 1
a546 1
	 FALSE),                /* pcrel_offset */
d557 1
a557 1
	 FALSE,	                /* pc_relative */
d562 1
a562 1
	 TRUE,	                /* partial_inplace */
d565 1
a565 1
	 TRUE),                 /* pcrel_offset */
d574 1
a574 1
	 FALSE,	                /* pc_relative */
d579 1
a579 1
	 FALSE,	                /* partial_inplace */
d582 1
a582 1
	 FALSE),                /* pcrel_offset */
d591 1
a591 1
	 FALSE,	                /* pc_relative */
d596 1
a596 1
	 FALSE,	                /* partial_inplace */
d599 1
a599 1
	 FALSE),                /* pcrel_offset */
d608 1
a608 1
	 FALSE,	                /* pc_relative */
d613 1
a613 1
	 TRUE,	                /* partial_inplace */
d616 1
a616 1
	 FALSE),                 /* pcrel_offset */
d625 1
a625 1
	 FALSE,	                /* pc_relative */
d630 1
a630 1
	 TRUE,	                /* partial_inplace */
d633 1
a633 1
	 TRUE),                 /* pcrel_offset */
d642 1
a642 1
	 FALSE,	                /* pc_relative */
d647 1
a647 1
	 TRUE,	                /* partial_inplace */
d650 1
a650 1
	 TRUE),                 /* pcrel_offset */
d659 1
a659 1
	 FALSE,	                /* pc_relative */
d664 1
a664 1
	 TRUE,	                /* partial_inplace */
d667 1
a667 1
	 FALSE),                /* pcrel_offset */
d676 1
a676 1
	 FALSE,	                /* pc_relative */
d681 1
a681 1
	 FALSE,	                /* partial_inplace */
d684 1
a684 1
	 FALSE),                 /* pcrel_offset */
d693 1
a693 1
	 FALSE,	                /* pc_relative */
d698 1
a698 1
	 TRUE,	                /* partial_inplace */
d701 1
a701 1
	 TRUE),                 /* pcrel_offset */
d709 1
a709 1
	 FALSE,	                /* pc_relative */
d714 1
a714 1
	 TRUE,	                /* partial_inplace */
d717 1
a717 1
	 FALSE),                 /* pcrel_offset */
d725 1
a725 1
	 FALSE,	                /* pc_relative */
d730 1
a730 1
	 TRUE,	                /* partial_inplace */
d733 1
a733 1
	 FALSE),                /* pcrel_offset */
d741 1
a741 1
	 FALSE,	                /* pc_relative */
d746 1
a746 1
	 TRUE,	                /* partial_inplace */
d749 1
a749 1
	 FALSE),                /* pcrel_offset */
d758 1
a758 1
	 FALSE,	                /* pc_relative */
d763 1
a763 1
	 FALSE,	                /* partial_inplace */
d766 1
a766 1
	 FALSE),                /* pcrel_offset */
d770 1
a770 1
/* Some really cheezy macros that can be turned on to test stderr :-)  */
d795 3
a797 1
#define n_offset	_n._n_n._n_offset  */
d799 4
a802 4
#define DUMP_RELOC2(n,r)                     		\
{                                            		\
   fprintf (stderr,"%s sym %d, r_vaddr %d %s\n", 	\
	   n, r->r_symndx, r->r_vaddr,			\
d804 1
a804 1
	   ?" ":" TOCDEFN"  );      			\
d813 1
a813 1
/* TOC construction and management routines.  */
d818 1
a818 1
extern bfd *    bfd_of_toc_owner;
d820 1
d861 1
a861 1
  /* Add this entry to our toc addr-offset-name list.  */
d887 1
a887 1
static bfd_boolean ppc_record_toc_entry
d892 2
a893 2
/* Record a toc offset against a symbol.  */
static bfd_boolean
a916 1

a920 1

d925 1
a925 1
	    return FALSE;
a926 1

d938 1
a938 1
	  /* The size must fit in a 16-bit displacement.  */
d943 1
a943 1
	      return FALSE;
d951 2
a952 2
      /* Check to see if there's a toc slot allocated. If not, do it
	 here. It will be used in relocate_section.  */
d958 1
a958 1
	  /* The size must fit in a 16-bit displacement.  */
d963 1
a963 1
	      return FALSE;
d968 1
a968 1
  return TRUE;
d971 1
a971 1
/* Record a toc offset against a symbol.  */
d992 1
a992 1
/* Return TRUE if this relocation should
d995 1
a995 1
static bfd_boolean in_reloc_p(abfd, howto)
d1016 3
a1018 3
/* This function is in charge of performing all the ppc PE relocations
   Don't yet know if we want to do this this particular way ... (krk).  */
/* FIXME: (it is not yet enabled).  */
d1031 3
a1033 3
  /* The consth relocation comes in two parts, we have to remember
     the state between calls, in these variables.  */
  static bfd_boolean part1_consth_active = FALSE;
d1044 1
a1044 1
      /* Partial linking - do nothing.  */
d1052 1
a1052 1
      /* Keep the state machine happy in case we're called again.  */
d1055 1
a1055 1
	  part1_consth_active = TRUE;
d1063 1
a1063 1
      part1_consth_active = FALSE;
d1077 1
a1077 1
static bfd_boolean
d1091 1
a1091 1
  bfd_boolean hihalf;
d1097 1
a1097 1
  /* If we are performing a relocatable link, we don't need to do a
d1100 2
a1101 2
  if (info->relocatable)
    return TRUE;
d1103 1
a1103 1
  hihalf = FALSE;
d1154 1
a1154 1
      /* FIXME: PAIR unsupported in the following code.  */
d1185 2
a1186 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d1192 1
a1192 1
      /* Each case must do its own relocation, setting rstat appropriately.  */
d1200 1
a1200 1
	  return FALSE;
d1220 8
a1227 6
	    /* Amazing bit tricks present. As we may have seen earlier, we
	       use the 1 bit to tell us whether or not a toc offset has been
	       allocated. Now that they've all been allocated, we will use
	       the 1 bit to tell us if we've written this particular toc
	       entry out.  */
	    fixit = FALSE;
d1229 1
a1229 2
	      {
		/* It is a file local symbol.  */
d1241 1
a1241 1
		    /* If it has been written out, it is marked with the
d1243 2
a1244 1
		       again.  */
d1249 1
a1249 1
		    /* Write out the toc entry.  */
d1257 1
a1257 1
		    fixit = TRUE;
d1280 2
a1281 1
		       the IAT to be part of the toc, thus saving a load.  */
d1286 1
a1286 1
		    /* The size must still fit in a 16-bit displacement.  */
d1294 1
a1294 1
			return FALSE;
d1300 1
a1300 1
		else if (IS_WRITTEN (our_toc_offset))
d1302 1
a1302 1
		    /* If it has been written out, it is marked with the
d1304 2
a1305 1
		       again.  */
d1313 1
a1313 1
		    /* Write out the toc entry.  */
d1318 3
a1320 3
		    /* The tricky part is that this is the address that
		       needs a .reloc entry for it.  */
		    fixit = TRUE;
d1327 1
a1327 1
		   to a section or a common symbol, then it needs a reloc.  */
d1329 1
a1329 1
		/* Relocation to a symbol in a section which
d1331 2
a1332 1
		   to a file.  */
d1336 1
a1336 1
		if (coff_data (output_bfd)->pe)
d1342 1
a1342 1
	    /* FIXME: this test is conservative.  */
d1351 1
a1351 1
		return FALSE;
d1354 1
a1354 1
	    /* Now we know the relocation for this toc reference.  */
d1361 5
a1365 4
	    /* To solve this, we need to know whether or not the symbol
	       appearing on the call instruction is a glue function or not.
	       A glue function must announce itself via a IMGLUE reloc, and 
	       the reloc contains the required toc restore instruction.  */
d1368 1
a1368 2
	    
	    DUMP_RELOC2 (howto->name, rel);
d1382 1
a1382 1
	  /* Unimplemented: codeview debugging information.  */
d1387 1
a1387 1
	  /* Unimplemented: codeview debugging information.  */
d1390 1
a1390 1
	     symbol.  */
a1394 1

d1396 1
a1396 1
	      my_name = (syms+symndx)->_n._n_name;
d1398 3
a1400 1
	      my_name = h->root.root.root.string;
d1416 1
a1416 1
	       pass over the relocs, and the glue instruction extracted.  */
a1417 1

d1426 1
a1426 1
	    return FALSE;
d1432 1
a1432 2

	    DUMP_RELOC2 (howto->name, rel);
d1436 1
a1436 1
		/* Set magic values.  */
a1438 1

d1441 1
a1441 1
					     FALSE, FALSE, TRUE);
d1450 1
a1450 1
					     FALSE, FALSE, TRUE);
d1455 1
a1455 1
					     FALSE, FALSE, TRUE);
d1460 1
a1460 2
	      {
		/* It is a file local symbol.  */
d1469 1
a1469 1
		if (strcmp (".idata$2", name) == 0)
d1471 1
a1471 1
		else if (strcmp (".idata$4", name) == 0)
d1473 1
a1473 1
		else if (strcmp (".idata$5", name) == 0)
d1482 1
a1482 1
						 FALSE, FALSE, TRUE);
d1496 1
a1496 1
						     FALSE, FALSE, TRUE);
d1505 1
a1505 1
						     FALSE, FALSE, TRUE);
d1510 1
a1510 1
						     FALSE, FALSE, TRUE);
d1517 4
a1520 4
					    input_bfd,
					    val -
					    pe_data (output_bfd)->pe_opthdr.ImageBase,
					    loc);
d1545 1
a1545 1
      if (info->base_file)
d1548 2
a1549 2
	     to a section or a common symbol, then it needs a reloc.  */
	  if (sym && pe_data(output_bfd)->in_reloc_p (output_bfd, howto))
d1551 1
a1551 1
	      /* Relocation to a symbol in a section which
d1553 1
a1553 1
		 to a file.  */
d1559 4
a1562 3
	      if (coff_data (output_bfd)->pe)
		addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;

d1598 3
a1600 1
	      return FALSE;
d1603 1
d1606 1
a1606 1
  return TRUE;
d1680 1
a1680 1
bfd_boolean
d1689 2
a1690 2
  if ( global_toc_size == 0 ) /* FIXME: does this get me in trouble?  */
    return TRUE;
d1693 4
a1696 2
    /* No toc owner? Something is very wrong.  */
    abort ();
d1700 4
a1703 2
    /* No toc section? Something is very wrong.  */
    abort ();
d1712 1
a1712 1
  return TRUE;
d1715 1
a1715 1
bfd_boolean
d1723 1
a1723 1
  /* Here we have a bfd that is to be included on the link. We have a hook
a1724 1
  _bfd_coff_get_external_symbols (abfd);
d1726 3
a1728 1
  /* Rummage around all the relocs and map the toc.  */
d1732 3
a1734 1
    return TRUE;
d1737 3
a1739 3
    {
      if (sec->reloc_count == 0)
	continue;
d1741 3
a1743 3
      /* load the relocs */
      /* FIXME: there may be a storage leak here */
      i=_bfd_coff_read_internal_relocs(abfd,sec,1,0,0,0);
d1745 2
a1746 2
      if (i == 0)
	abort ();
d1748 5
a1752 5
      for (rel = i; rel < i + sec->reloc_count; ++rel)
	{
	  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
	  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
	  bfd_boolean ok = TRUE;
d1754 1
a1754 1
	  DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, rel);
d1756 19
a1774 19
	  switch(r_type)
	    {
	    case IMAGE_REL_PPC_TOCREL16:
	      /* If TOCDEFN is on, ignore as someone else has allocated the
		 toc entry.  */
	      if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN)
		ok = ppc_record_toc_entry(abfd, info, sec,
					  rel->r_symndx, default_toc);
	      if (!ok)
		return FALSE;
	      break;
	    case IMAGE_REL_PPC_IMGLUE:
	      ppc_mark_symbol_as_glue (abfd, rel->r_symndx, rel);
	      break;
	    default:
	      break;
	    }
	}
    }
d1776 1
a1776 1
  return TRUE;
d1782 7
a1788 2
ppc_refhi_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
d1809 7
a1815 2
ppc_reflo_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
d1836 7
a1842 2
ppc_pair_reloc (abfd, reloc_entry, symbol, data,
		input_section, output_bfd, error_message)
d1861 7
a1867 2
ppc_toc16_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
d1876 2
a1877 2
  UN_IMPL ("TOCREL16");
  DUMP_RELOC ("TOCREL16",reloc_entry);
d1880 3
a1882 1
    return bfd_reloc_continue;
d1889 5
a1893 3
/* ADDR32NB : 32 bit address relative to the virtual origin.
              (On the alpha, this is always a linker generated thunk)
              (i.e. 32bit addr relative to the image base).  */
d1896 7
a1902 2
ppc_addr32nb_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
d1920 7
a1926 2
ppc_secrel_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
d1945 7
a1951 2
ppc_section_reloc (abfd, reloc_entry, symbol, data,
		   input_section, output_bfd, error_message)
d1970 7
a1976 2
ppc_imglue_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
d1997 1
a1997 1
/* FIXME: There is a possibility that when we read in a reloc from a file,
d1999 4
a2002 2
	  type field. Not yet implemented.  */
static void ppc_coff_rtype2howto PARAMS ((arelent *, struct internal_reloc *));
d2009 1
d2018 2
a2019 1
     than that.  */
d2025 1
a2025 1
  /* The masking process only slices off the bottom byte for r_type.  */
d2029 2
a2030 2
  /* Check for absolute crap.  */
  if (junk != 0)
d2043 1
a2043 1
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
d2047 1
a2047 1
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
d2051 1
a2051 1
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
d2067 1
d2089 2
a2090 1
     than that.  */
d2092 3
a2094 3
  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
  unsigned short junk    = EXTRACT_JUNK  (rel->r_type);
d2096 2
a2097 2
  /* The masking process only slices off the bottom byte for r_type.  */
  if (r_type > MAX_RELOC_INDEX)
d2100 2
a2101 2
  /* Check for absolute crap.  */
  if (junk != 0)
d2144 1
a2144 1
/* A cheesy little macro to make the code a little more readable.  */
d2170 1
d2232 2
a2233 1
      and how often, etc. It's not clear to me that there isn't a hole here.  */
d2242 1
a2242 1
  struct internal_syment * in = (struct internal_syment *)in1;
d2244 1
a2244 1
  if (bfd_of_toc_owner != 0) /* We already have a toc, so go home.  */
d2247 1
a2247 1
  if (strcmp (in->_n._n_name, ".toc") == 0)
d2252 1
a2252 1
      s = bfd_get_section_by_name (abfd, TOC_SECTION_NAME);
d2254 3
a2256 1
	return;
d2265 4
a2268 2
	/* FIXME: set appropriate bfd error.  */
	abort ();
d2270 1
a2270 1
      /* Save the bfd for later allocation.  */
d2281 1
a2281 1
static bfd_boolean ppc_do_last PARAMS ((bfd *));
d2284 1
a2284 1
static bfd_boolean
d2289 1
a2289 1
    return TRUE;
d2291 1
a2291 1
    return FALSE;
d2300 1
a2300 1
/* This piece of machinery exists only to guarantee that the bfd that holds
d2309 2
a2310 1
   precise form of comment. krk@@cygnus.com  */
d2314 1
a2314 1
bfd_boolean
d2321 1
a2321 1
  bfd_boolean debug_merge_allocated;
d2354 1
a2354 1
  debug_merge_allocated = FALSE;
d2364 1
a2364 1
  debug_merge_allocated = TRUE;
d2370 1
a2370 1
	return FALSE;
a2384 1

d2387 1
d2398 1
a2398 1
	      sec->linker_mark = TRUE;
d2404 1
a2404 1
	      if (info->relocatable)
d2414 1
a2414 1
	  else if (info->relocatable
d2429 1
a2429 1
  /* If doing a relocatable link, allocate space for the pointers we
d2431 1
a2431 1
  if (info->relocatable)
a2439 1

a2441 1

a2453 1

d2477 1
a2477 1
	     but only when doing a relocatable link, which is not the
d2479 1
a2479 1
	  BFD_ASSERT (info->relocatable);
d2512 1
a2512 1
      sub->output_has_begun = FALSE;
d2531 1
a2531 1
  if (! info->relocatable)
d2543 1
a2543 1
      || (! info->relocatable
d2578 1
a2578 1
		  sub->output_has_begun = TRUE;
d2603 1
a2603 1
    last_one->output_has_begun = TRUE;
d2608 1
d2610 1
a2610 1
  debug_merge_allocated = FALSE;
d2662 1
a2662 1
	return FALSE;
d2666 1
a2666 1
  finfo.failed = FALSE;
d2679 1
a2679 1
  if (info->relocatable)
d2743 1
a2743 1
	return FALSE;
d2753 1
a2753 1
	return FALSE;
d2765 1
a2765 1
	return FALSE;
d2768 1
a2768 1
	return FALSE;
d2777 1
a2777 1
  return TRUE;
d2815 1
a2815 1
  return FALSE;
@


1.15.18.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d57 1
a57 1
extern bfd_boolean ppc_bfd_coff_final_link
d131 1
a131 1
static bfd_boolean ppc_coff_link_hash_table_init
d138 1
a138 1
static bfd_boolean coff_ppc_relocate_section
d187 1
a187 1
static bfd_boolean
d388 1
a388 1
static bfd_boolean in_reloc_p PARAMS((bfd *abfd, reloc_howto_type *howto));
d436 1
a436 1
	 FALSE,	                 /* pc_relative */
d441 1
a441 1
	 FALSE,	                 /* partial_inplace */
d444 1
a444 1
	 FALSE),                 /* pcrel_offset */
d452 1
a452 1
	FALSE,	                 /* pc_relative */
d457 1
a457 1
	TRUE,	                 /* partial_inplace */
d460 1
a460 1
	FALSE),                 /* pcrel_offset */
d468 1
a468 1
	 FALSE,	                /* pc_relative */
d473 1
a473 1
	 TRUE,	                /* partial_inplace */
d476 1
a476 1
	 FALSE),                /* pcrel_offset */
d487 1
a487 1
	 FALSE,	                /* pc_relative */
d492 1
a492 1
	 TRUE,	                /* partial_inplace */
d495 1
a495 1
	 FALSE),                /* pcrel_offset */
d503 1
a503 1
	 FALSE,	                /* pc_relative */
d508 1
a508 1
	 TRUE,	                /* partial_inplace */
d511 1
a511 1
	 FALSE),                /* pcrel_offset */
d521 1
a521 1
	 FALSE,	                /* pc_relative */
d526 1
a526 1
	 TRUE,	                /* partial_inplace */
d529 1
a529 1
	 FALSE),                /* pcrel_offset */
d538 1
a538 1
	 TRUE,	                /* pc_relative */
d543 1
a543 1
	 TRUE,	                /* partial_inplace */
d546 1
a546 1
	 FALSE),                /* pcrel_offset */
d557 1
a557 1
	 FALSE,	                /* pc_relative */
d562 1
a562 1
	 TRUE,	                /* partial_inplace */
d565 1
a565 1
	 TRUE),                 /* pcrel_offset */
d574 1
a574 1
	 FALSE,	                /* pc_relative */
d579 1
a579 1
	 FALSE,	                /* partial_inplace */
d582 1
a582 1
	 FALSE),                /* pcrel_offset */
d591 1
a591 1
	 FALSE,	                /* pc_relative */
d596 1
a596 1
	 FALSE,	                /* partial_inplace */
d599 1
a599 1
	 FALSE),                /* pcrel_offset */
d608 1
a608 1
	 FALSE,	                /* pc_relative */
d613 1
a613 1
	 TRUE,	                /* partial_inplace */
d616 1
a616 1
	 FALSE),                 /* pcrel_offset */
d625 1
a625 1
	 FALSE,	                /* pc_relative */
d630 1
a630 1
	 TRUE,	                /* partial_inplace */
d633 1
a633 1
	 TRUE),                 /* pcrel_offset */
d642 1
a642 1
	 FALSE,	                /* pc_relative */
d647 1
a647 1
	 TRUE,	                /* partial_inplace */
d650 1
a650 1
	 TRUE),                 /* pcrel_offset */
d659 1
a659 1
	 FALSE,	                /* pc_relative */
d664 1
a664 1
	 TRUE,	                /* partial_inplace */
d667 1
a667 1
	 FALSE),                /* pcrel_offset */
d676 1
a676 1
	 FALSE,	                /* pc_relative */
d681 1
a681 1
	 FALSE,	                /* partial_inplace */
d684 1
a684 1
	 FALSE),                 /* pcrel_offset */
d693 1
a693 1
	 FALSE,	                /* pc_relative */
d698 1
a698 1
	 TRUE,	                /* partial_inplace */
d701 1
a701 1
	 TRUE),                 /* pcrel_offset */
d709 1
a709 1
	 FALSE,	                /* pc_relative */
d714 1
a714 1
	 TRUE,	                /* partial_inplace */
d717 1
a717 1
	 FALSE),                 /* pcrel_offset */
d725 1
a725 1
	 FALSE,	                /* pc_relative */
d730 1
a730 1
	 TRUE,	                /* partial_inplace */
d733 1
a733 1
	 FALSE),                /* pcrel_offset */
d741 1
a741 1
	 FALSE,	                /* pc_relative */
d746 1
a746 1
	 TRUE,	                /* partial_inplace */
d749 1
a749 1
	 FALSE),                /* pcrel_offset */
d758 1
a758 1
	 FALSE,	                /* pc_relative */
d763 1
a763 1
	 FALSE,	                /* partial_inplace */
d766 1
a766 1
	 FALSE),                /* pcrel_offset */
d887 1
a887 1
static bfd_boolean ppc_record_toc_entry
d893 1
a893 1
static bfd_boolean
d925 1
a925 1
	    return FALSE;
d943 1
a943 1
	      return FALSE;
d963 1
a963 1
	      return FALSE;
d968 1
a968 1
  return TRUE;
d992 1
a992 1
/* Return TRUE if this relocation should
d995 1
a995 1
static bfd_boolean in_reloc_p(abfd, howto)
d1033 1
a1033 1
  static bfd_boolean part1_consth_active = FALSE;
d1055 1
a1055 1
	  part1_consth_active = TRUE;
d1063 1
a1063 1
      part1_consth_active = FALSE;
d1077 1
a1077 1
static bfd_boolean
d1091 1
a1091 1
  bfd_boolean hihalf;
d1101 1
a1101 1
    return TRUE;
d1103 1
a1103 1
  hihalf = FALSE;
d1185 2
a1186 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d1200 1
a1200 1
	  return FALSE;
d1227 1
a1227 1
	    fixit = FALSE;
d1257 1
a1257 1
		    fixit = TRUE;
d1294 1
a1294 1
			return FALSE;
d1320 1
a1320 1
		    fixit = TRUE;
d1351 1
a1351 1
		return FALSE;
d1426 1
a1426 1
	    return FALSE;
d1441 1
a1441 1
					     FALSE, FALSE, TRUE);
d1450 1
a1450 1
					     FALSE, FALSE, TRUE);
d1455 1
a1455 1
					     FALSE, FALSE, TRUE);
d1482 1
a1482 1
						 FALSE, FALSE, TRUE);
d1496 1
a1496 1
						     FALSE, FALSE, TRUE);
d1505 1
a1505 1
						     FALSE, FALSE, TRUE);
d1510 1
a1510 1
						     FALSE, FALSE, TRUE);
d1599 1
a1599 1
		return FALSE;
d1606 1
a1606 1
  return TRUE;
d1680 1
a1680 1
bfd_boolean
d1690 1
a1690 1
    return TRUE;
d1712 1
a1712 1
  return TRUE;
d1715 1
a1715 1
bfd_boolean
d1733 1
a1733 1
      return TRUE;
d1752 1
a1752 1
	bfd_boolean ok = TRUE;
d1765 1
a1765 1
	      return FALSE;
d1776 1
a1776 1
  return TRUE;
d2281 1
a2281 1
static bfd_boolean ppc_do_last PARAMS ((bfd *));
d2284 1
a2284 1
static bfd_boolean
d2289 1
a2289 1
    return TRUE;
d2291 1
a2291 1
    return FALSE;
d2314 1
a2314 1
bfd_boolean
d2321 1
a2321 1
  bfd_boolean debug_merge_allocated;
d2354 1
a2354 1
  debug_merge_allocated = FALSE;
d2364 1
a2364 1
  debug_merge_allocated = TRUE;
d2370 1
a2370 1
	return FALSE;
d2398 1
a2398 1
	      sec->linker_mark = TRUE;
d2512 1
a2512 1
      sub->output_has_begun = FALSE;
d2578 1
a2578 1
		  sub->output_has_begun = TRUE;
d2603 1
a2603 1
    last_one->output_has_begun = TRUE;
d2610 1
a2610 1
  debug_merge_allocated = FALSE;
d2662 1
a2662 1
	return FALSE;
d2666 1
a2666 1
  finfo.failed = FALSE;
d2743 1
a2743 1
	return FALSE;
d2753 1
a2753 1
	return FALSE;
d2765 1
a2765 1
	return FALSE;
d2768 1
a2768 1
	return FALSE;
d2777 1
a2777 1
  return TRUE;
d2815 1
a2815 1
  return FALSE;
@


1.15.18.2
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d12 1
a12 1
   This file is part of BFD, the Binary File Descriptor library.
d14 14
a27 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d34 2
a35 1
     not produce the right glue code for dll function calls.  */
d61 9
a69 9
/* The toc is a set of bfd_vma fields. We use the fact that valid
   addresses are even (i.e. the bit representing "1" is off) to allow
   us to encode a little extra information in the field
   - Unallocated addresses are initialized to 1.
   - Allocated addresses are even numbers.
   The first time we actually write a reference to the toc in the bfd,
   we want to record that fact in a fixup file (if it is asked for), so
   we keep track of whether or not an address has been written by marking
   the low order bit with a "1" upon writing.  */
d78 1
a78 1
/* Turn on this check if you suspect something amiss in the hash tables.  */
d81 1
a81 1
/* Need a 7 char string for an eye catcher.  */
d104 1
a104 1
   linker, we define our own hash table, derived from the coff one.  */
d110 1
a110 1
  struct coff_link_hash_entry root; /* First entry, as required.  */
d113 2
a114 2
     here.  */
  bfd_vma toc_offset;               /* Our addition, as required.  */
d125 1
a125 1
  struct coff_link_hash_table root; /* First entry, as required.  */
d175 1
a175 1
      SET_UNALLOCATED (ret->toc_offset);
d179 1
a179 1
      HASH_CHECK_INIT (ret);
d219 1
a219 1
/* Now, tailor coffcode.h to use our hash stuff.  */
d223 3
a225 3
/* The nt loader points the toc register to &toc + 32768, in order to
   use the complete range of a 16-bit displacement. We have to adjust
   for this when we fix up loads displaced off the toc reg.  */
d237 1
a237 1
/* These should definitely go in a header file somewhere...  */
d287 3
a289 3
/* Stuff to handle immediate data when the number of bits in the
   data is greater than the number of bits in the immediate field
   We need to do (usually) 32 bit arithmetic on 16 bit chunks.  */
d294 1
a294 1
/* This is essentially the same as tocrel16, with TOCDEFN assumed.  */
d297 1
a297 1
/* Flag bits in IMAGE_RELOCATION.TYPE.  */
d299 1
a299 1
/* Subtract reloc value rather than adding it.  */
d302 1
a302 1
/* Fix branch prediction bit to predict branch taken.  */
d305 1
a305 1
/* Fix branch prediction bit to predict branch not taken.  */
d308 1
a308 1
/* TOC slot defined in file (or, data in toc).  */
d311 1
a311 1
/* Masks to isolate above values in IMAGE_RELOCATION.Type.  */
d320 1
a320 1
/* Static helper functions to make relocation work.  */
d392 1
a392 29
   completely unverified or have a specific unknown marked in the comment.  */

/* Relocation entries for Windows/NT on PowerPC.                             

   From the document "" we find the following listed as used relocs:

     ABSOLUTE       : The noop
     ADDR[64|32|16] : fields that hold addresses in data fields or the
                      16 bit displacement field on a load/store.
     ADDR[24|14]    : fields that hold addresses in branch and cond
                      branches. These represent [26|16] bit addresses.
                      The low order 2 bits are preserved.
     REL[24|14]     : branches relative to the Instruction Address
                      register. These represent [26|16] bit addresses,
                      as before. The instruction field will be zero, and
                      the address of the SYM will be inserted at link time.
     TOCREL16       : 16 bit displacement field referring to a slot in
                      toc.
     TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14.
     ADDR32NB       : 32 bit address relative to the virtual origin.
                      (On the alpha, this is always a linker generated thunk)
                      (i.e. 32bit addr relative to the image base)
     SECREL         : The value is relative to the start of the section
                      containing the symbol.
     SECTION        : access to the header containing the item. Supports the
                      codeview debugger.

   In particular, note that the document does not indicate that the
   relocations listed in the header file are used.  */
d394 33
d770 1
a770 1
/* Some really cheezy macros that can be turned on to test stderr :-)  */
d795 3
a797 1
#define n_offset	_n._n_n._n_offset  */
d799 4
a802 4
#define DUMP_RELOC2(n,r)                     		\
{                                            		\
   fprintf (stderr,"%s sym %d, r_vaddr %d %s\n", 	\
	   n, r->r_symndx, r->r_vaddr,			\
d804 1
a804 1
	   ?" ":" TOCDEFN"  );      			\
d813 1
a813 1
/* TOC construction and management routines.  */
d818 1
a818 1
extern bfd *    bfd_of_toc_owner;
d820 1
d861 1
a861 1
  /* Add this entry to our toc addr-offset-name list.  */
d892 1
a892 1
/* Record a toc offset against a symbol.  */
a916 1

a920 1

a926 1

d938 1
a938 1
	  /* The size must fit in a 16bit displacment.  */
d951 2
a952 2
      /* Check to see if there's a toc slot allocated. If not, do it
	 here. It will be used in relocate_section.  */
d958 1
a958 1
	  /* The size must fit in a 16bit displacment.  */
d971 1
a971 1
/* Record a toc offset against a symbol.  */
d1016 3
a1018 3
/* This function is in charge of performing all the ppc PE relocations
   Don't yet know if we want to do this this particular way ... (krk).  */
/* FIXME: (it is not yet enabled).  */
d1031 2
a1032 2
  /* The consth relocation comes in two parts, we have to remember
     the state between calls, in these variables.  */
d1044 1
a1044 1
      /* Partial linking - do nothing.  */
d1052 1
a1052 1
      /* Keep the state machine happy in case we're called again.  */
d1154 1
a1154 1
      /* FIXME: PAIR unsupported in the following code.  */
d1192 1
a1192 1
      /* Each case must do its own relocation, setting rstat appropriately.  */
d1220 7
a1226 5
	    /* Amazing bit tricks present. As we may have seen earlier, we
	       use the 1 bit to tell us whether or not a toc offset has been
	       allocated. Now that they've all been allocated, we will use
	       the 1 bit to tell us if we've written this particular toc
	       entry out.  */
d1229 1
a1229 2
	      {
		/* It is a file local symbol.  */
d1241 1
a1241 1
		    /* If it has been written out, it is marked with the
d1243 2
a1244 1
		       again.  */
d1249 1
a1249 1
		    /* Write out the toc entry.  */
d1280 2
a1281 1
		       the IAT to be part of the toc, thus saving a load.  */
d1286 1
a1286 1
		    /* The size must still fit in a 16bit displacment.  */
d1300 1
a1300 1
		else if (IS_WRITTEN (our_toc_offset))
d1302 1
a1302 1
		    /* If it has been written out, it is marked with the
d1304 2
a1305 1
		       again.  */
d1313 1
a1313 1
		    /* Write out the toc entry.  */
d1318 2
a1319 2
		    /* The tricky part is that this is the address that
		       needs a .reloc entry for it.  */
d1327 1
a1327 1
		   to a section or a common symbol, then it needs a reloc.  */
d1329 1
a1329 1
		/* Relocation to a symbol in a section which
d1331 2
a1332 1
		   to a file.  */
d1336 1
a1336 1
		if (coff_data (output_bfd)->pe)
d1342 1
a1342 1
	    /* FIXME: this test is conservative.  */
d1354 1
a1354 1
	    /* Now we know the relocation for this toc reference.  */
d1361 5
a1365 4
	    /* To solve this, we need to know whether or not the symbol
	       appearing on the call instruction is a glue function or not.
	       A glue function must announce itself via a IMGLUE reloc, and 
	       the reloc contains the required toc restore instruction.  */
d1368 1
a1368 2
	    
	    DUMP_RELOC2 (howto->name, rel);
d1382 1
a1382 1
	  /* Unimplemented: codeview debugging information.  */
d1387 1
a1387 1
	  /* Unimplemented: codeview debugging information.  */
d1390 1
a1390 1
	     symbol.  */
a1394 1

d1396 1
a1396 1
	      my_name = (syms+symndx)->_n._n_name;
d1398 3
a1400 1
	      my_name = h->root.root.root.string;
d1416 1
a1416 1
	       pass over the relocs, and the glue instruction extracted.  */
a1417 1

d1432 1
a1432 2

	    DUMP_RELOC2 (howto->name, rel);
d1436 1
a1436 1
		/* Set magic values.  */
a1438 1

d1460 1
a1460 2
	      {
		/* It is a file local symbol.  */
d1469 1
a1469 1
		if (strcmp (".idata$2", name) == 0)
d1471 1
a1471 1
		else if (strcmp (".idata$4", name) == 0)
d1473 1
a1473 1
		else if (strcmp (".idata$5", name) == 0)
d1517 4
a1520 4
					    input_bfd,
					    val -
					    pe_data (output_bfd)->pe_opthdr.ImageBase,
					    loc);
d1545 1
a1545 1
      if (info->base_file)
d1548 2
a1549 2
	     to a section or a common symbol, then it needs a reloc.  */
	  if (sym && pe_data(output_bfd)->in_reloc_p (output_bfd, howto))
d1551 1
a1551 1
	      /* Relocation to a symbol in a section which
d1553 1
a1553 1
		 to a file.  */
d1559 4
a1562 3
	      if (coff_data (output_bfd)->pe)
		addr -= pe_data (output_bfd)->pe_opthdr.ImageBase;

d1598 3
a1600 1
	      return FALSE;
d1603 1
d1689 1
a1689 1
  if ( global_toc_size == 0 ) /* FIXME: does this get me in trouble?  */
d1693 4
a1696 2
    /* No toc owner? Something is very wrong.  */
    abort ();
d1700 4
a1703 2
    /* No toc section? Something is very wrong.  */
    abort ();
d1723 1
a1723 1
  /* Here we have a bfd that is to be included on the link. We have a hook
a1724 1
  _bfd_coff_get_external_symbols (abfd);
d1726 3
a1728 1
  /* Rummage around all the relocs and map the toc.  */
d1732 3
a1734 1
    return TRUE;
d1737 3
a1739 3
    {
      if (sec->reloc_count == 0)
	continue;
d1741 3
a1743 3
      /* load the relocs */
      /* FIXME: there may be a storage leak here */
      i=_bfd_coff_read_internal_relocs(abfd,sec,1,0,0,0);
d1745 2
a1746 2
      if (i == 0)
	abort ();
d1748 5
a1752 5
      for (rel = i; rel < i + sec->reloc_count; ++rel)
	{
	  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
	  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
	  bfd_boolean ok = TRUE;
d1754 1
a1754 1
	  DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, rel);
d1756 19
a1774 19
	  switch(r_type)
	    {
	    case IMAGE_REL_PPC_TOCREL16:
	      /* If TOCDEFN is on, ignore as someone else has allocated the
		 toc entry.  */
	      if ((r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN)
		ok = ppc_record_toc_entry(abfd, info, sec,
					  rel->r_symndx, default_toc);
	      if (!ok)
		return FALSE;
	      break;
	    case IMAGE_REL_PPC_IMGLUE:
	      ppc_mark_symbol_as_glue (abfd, rel->r_symndx, rel);
	      break;
	    default:
	      break;
	    }
	}
    }
d1782 7
a1788 2
ppc_refhi_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
d1809 7
a1815 2
ppc_reflo_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
d1836 7
a1842 2
ppc_pair_reloc (abfd, reloc_entry, symbol, data,
		input_section, output_bfd, error_message)
d1861 7
a1867 2
ppc_toc16_reloc (abfd, reloc_entry, symbol, data,
		 input_section, output_bfd, error_message)
d1876 2
a1877 2
  UN_IMPL ("TOCREL16");
  DUMP_RELOC ("TOCREL16",reloc_entry);
d1880 3
a1882 1
    return bfd_reloc_continue;
d1889 5
a1893 3
/* ADDR32NB : 32 bit address relative to the virtual origin.
              (On the alpha, this is always a linker generated thunk)
              (i.e. 32bit addr relative to the image base).  */
d1896 7
a1902 2
ppc_addr32nb_reloc (abfd, reloc_entry, symbol, data,
		    input_section, output_bfd, error_message)
d1920 7
a1926 2
ppc_secrel_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
d1945 7
a1951 2
ppc_section_reloc (abfd, reloc_entry, symbol, data,
		   input_section, output_bfd, error_message)
d1970 7
a1976 2
ppc_imglue_reloc (abfd, reloc_entry, symbol, data,
		  input_section, output_bfd, error_message)
d1999 4
a2002 2
	  type field. Not yet implemented.  */
static void ppc_coff_rtype2howto PARAMS ((arelent *, struct internal_reloc *));
d2009 1
d2018 2
a2019 1
     than that.  */
d2025 1
a2025 1
  /* The masking process only slices off the bottom byte for r_type.  */
d2029 2
a2030 2
  /* Check for absolute crap.  */
  if (junk != 0)
d2043 1
a2043 1
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
d2047 1
a2047 1
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
d2051 1
a2051 1
      DUMP_RELOC2 (ppc_coff_howto_table[r_type].name, internal);
d2067 1
d2089 2
a2090 1
     than that.  */
d2092 3
a2094 3
  unsigned short r_type  = EXTRACT_TYPE  (rel->r_type);
  unsigned short r_flags = EXTRACT_FLAGS (rel->r_type);
  unsigned short junk    = EXTRACT_JUNK  (rel->r_type);
d2096 2
a2097 2
  /* The masking process only slices off the bottom byte for r_type.  */
  if (r_type > MAX_RELOC_INDEX)
d2100 2
a2101 2
  /* Check for absolute crap.  */
  if (junk != 0)
d2144 1
a2144 1
/* A cheesy little macro to make the code a little more readable.  */
d2170 1
d2232 2
a2233 1
      and how often, etc. It's not clear to me that there isn't a hole here.  */
d2242 1
a2242 1
  struct internal_syment * in = (struct internal_syment *)in1;
d2244 1
a2244 1
  if (bfd_of_toc_owner != 0) /* We already have a toc, so go home.  */
d2247 1
a2247 1
  if (strcmp (in->_n._n_name, ".toc") == 0)
d2252 1
a2252 1
      s = bfd_get_section_by_name (abfd, TOC_SECTION_NAME);
d2254 3
a2256 1
	return;
d2265 4
a2268 2
	/* FIXME: set appropriate bfd error.  */
	abort ();
d2270 1
a2270 1
      /* Save the bfd for later allocation.  */
d2300 1
a2300 1
/* This piece of machinery exists only to guarantee that the bfd that holds
d2309 2
a2310 1
   precise form of comment. krk@@cygnus.com  */
a2384 1

d2387 1
a2439 1

a2441 1

a2453 1

d2608 1
@


1.15.18.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d1091 1
a1091 1
  /* If we are performing a relocatable link, we don't need to do a
d1094 1
a1094 1
  if (info->relocatable)
d2328 1
a2328 1
	      if (info->relocatable)
d2338 1
a2338 1
	  else if (info->relocatable
d2353 1
a2353 1
  /* If doing a relocatable link, allocate space for the pointers we
d2355 1
a2355 1
  if (info->relocatable)
d2404 1
a2404 1
	     but only when doing a relocatable link, which is not the
d2406 1
a2406 1
	  BFD_ASSERT (info->relocatable);
d2458 1
a2458 1
  if (! info->relocatable)
d2470 1
a2470 1
      || (! info->relocatable
d2605 1
a2605 1
  if (info->relocatable)
@


1.15.18.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d932 1
a932 1
	  /* The size must fit in a 16-bit displacement.  */
d952 1
a952 1
	  /* The size must fit in a 16-bit displacement.  */
d1277 1
a1277 1
		    /* The size must still fit in a 16-bit displacement.  */
d1934 1
a1934 1
/* FIXME: There is a possibility that when we read in a reloc from a file,
@


1.14
log
@Fix compile time warnings
@
text
@d3 1
a3 1
   2000, 2001
d207 1
a207 1
  ret = (struct ppc_coff_link_hash_table *) bfd_alloc (abfd, amt);
d213 1
a213 1
      bfd_release (abfd, ret);
@


1.13
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@a2178 4
#ifndef COFF_IMAGE_WITH_PE
static void ppc_coff_swap_sym_in_hook PARAMS ((bfd *, PTR, PTR));
#endif

d2188 1
d2191 1
d2219 2
d2234 1
d2276 1
@


1.12
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1198 1
a1198 1
	     bfd_get_filename (input_bfd), r_type);
d1291 1
a1291 1
			   bfd_get_filename (input_bfd), name,
d1348 1
a1348 1
		   bfd_get_filename (input_bfd),
d1405 1
a1405 1
		    bfd_get_filename(input_bfd),
d1424 1
a1424 1
	       bfd_get_filename (input_bfd), my_name);
@


1.11
log
@Update copyright notices
@
text
@d205 1
d207 1
a207 2
  ret = ((struct ppc_coff_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct ppc_coff_link_hash_table)));
d836 1
a836 1
  data
d852 1
a852 1
  PARAMS ((asection *, int, enum ref_category, const char *));
d857 1
a857 1
     int our_toc_offset;
d862 3
a864 2
  struct list_ele *t;
  t = (struct list_ele *) bfd_malloc (sizeof (struct list_ele));
d920 1
d922 2
a923 3
	  local_syms =
	    (int *) bfd_zalloc (abfd,
				obj_raw_syment_count(abfd) * sizeof (int));
d926 2
a927 2
	  obj_coff_local_toc_table(abfd) = local_syms;
	  for (i = 0; i < obj_raw_syment_count(abfd); ++i)
d929 1
a929 1
	      SET_UNALLOCATED(local_syms[i]);
d1203 1
a1203 1
	    bfd_vma our_toc_offset;
d1250 2
a1251 4
		    record_toc(toc_section,
			       our_toc_offset,
			       priv,
			       strdup(name));
d1253 1
a1253 2
		    bfd_put_32 (output_bfd,
			       val,
d1283 2
a1284 3
		    our_toc_offset = val -
		      (toc_section->output_section->vma +
		       toc_section->output_offset);
d1287 1
a1287 1
		    if (our_toc_offset >= 65535)
d1290 3
a1292 2
			  (_("%s: Relocation for %s of %x exceeds Toc size limit"),
			   bfd_get_filename (input_bfd), name, our_toc_offset);
d1297 2
a1298 1
		    record_toc(toc_section, our_toc_offset, pub, strdup(name));
d1310 2
a1311 1
		    record_toc(toc_section, our_toc_offset, pub, strdup(name));
d1314 1
a1314 2
		    bfd_put_32 (output_bfd,
			       val,
d1333 2
a1334 2
		bfd_vma addr =  toc_section->output_section->vma
		  + toc_section->output_offset + our_toc_offset;
d1343 2
a1344 2
	    if ( (r_flags & IMAGE_REL_PPC_TOCDEFN) != IMAGE_REL_PPC_TOCDEFN &&
		our_toc_offset > toc_section->_raw_size)
d1347 1
a1347 1
		  (_("%s: Relocation exceeds allocated TOC (%x)"),
d1349 1
a1349 1
		   toc_section->_raw_size);
d1356 1
a1356 4
	    rstat = _bfd_relocate_contents (howto,
					    input_bfd,
					    relocation,
					    loc);
d1376 1
a1376 1
		    bfd_put_32 (input_bfd, h->glue_insn, loc);
a1430 1
	    struct coff_link_hash_entry *myh = 0;
d1438 1
a1438 1
		struct coff_link_hash_entry *myh = 0;
d1478 1
a1478 1
		    myh = 0;
d1652 1
a1652 1
      else if (t->cat == data)
d1663 2
a1664 1
		      global_toc_size, global_toc_size, thunk_size, thunk_size);
d1686 1
d1705 3
a1707 2
  foo = (bfd_byte *) bfd_alloc(bfd_of_toc_owner, global_toc_size);
  memset(foo, test_char, global_toc_size);
d2322 5
a2326 5
  size_t max_sym_count;
  size_t max_lineno_count;
  size_t max_reloc_count;
  size_t max_output_reloc_count;
  size_t max_contents_size;
d2334 1
d2435 3
a2437 4
      finfo.section_info =
	((struct coff_link_section_info *)
	 bfd_malloc ((abfd->section_count + 1)
		     * sizeof (struct coff_link_section_info)));
d2478 2
d2481 3
a2483 2
	    ((struct internal_reloc *)
	     bfd_malloc (o->reloc_count * sizeof (struct internal_reloc)));
d2485 1
a2485 3
	    ((struct coff_link_hash_entry **)
	     bfd_malloc (o->reloc_count
		     * sizeof (struct coff_link_hash_entry *)));
d2508 1
a2508 1
      size_t sz;
d2517 10
a2526 10
  finfo.internal_syms = ((struct internal_syment *)
			 bfd_malloc (max_sym_count
				     * sizeof (struct internal_syment)));
  finfo.sec_ptrs = (asection **) bfd_malloc (max_sym_count
					     * sizeof (asection *));
  finfo.sym_indices = (long *) bfd_malloc (max_sym_count * sizeof (long));
  finfo.outsyms = ((bfd_byte *)
		   bfd_malloc ((size_t) ((max_sym_count + 1) * symesz)));
  finfo.linenos = (bfd_byte *) bfd_malloc (max_lineno_count
				       * bfd_coff_linesz (abfd));
d2530 4
a2533 3
    finfo.internal_relocs = ((struct internal_reloc *)
			     bfd_malloc (max_reloc_count
					 * sizeof (struct internal_reloc)));
d2652 2
d2657 3
a2659 5
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + finfo.last_file_index * symesz),
		    SEEK_SET) != 0
	  || bfd_write (finfo.outsyms, symesz, 1, abfd) != symesz)
d2682 2
a2683 2
      external_relocs = ((bfd_byte *)
			 bfd_malloc (max_output_reloc_count * relsz));
d2711 1
d2713 1
a2713 2
	      || bfd_write ((PTR) external_relocs, relsz, o->reloc_count,
			    abfd) != relsz * o->reloc_count)
d2747 4
a2750 4
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + obj_raw_syment_count (abfd) * symesz),
		    SEEK_SET) != 0)
d2754 3
a2756 3
      bfd_h_put_32 (abfd,
		    _bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
		    (bfd_byte *) strbuf);
d2758 1
a2758 1
 #error Change bfd_h_put_32
d2761 2
a2762 1
      if (bfd_write (strbuf, 1, STRING_SIZE_SIZE, abfd) != STRING_SIZE_SIZE)
@


1.10
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
@


1.10.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.9
log
@2000-11-21  Kazu Hirata  <kazu@@hxi.com>

	* coff-a29k.c: Fix formatting.
	* coff-h8500.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-w65.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-hppa.c: Likewise.
	* cpu-ns32k.c: Likewise.
@
text
@a220 1

a317 1

a344 1

a387 1

a767 1

a768 1

a810 1

a989 1

a1859 1

a1993 1

a1994 1

a2174 1

a2219 1

a2220 1

a2814 1

@


1.8
log
@2000-11-15  Kazu Hirata  <kazu@@hxi.com>

	* coff-arm.c: Fix formatting.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
@
text
@d88 1
a88 1
    fprintf(stderr,\
d784 1
a784 1
       fprintf(stderr,_("Unimplemented Relocation -- %s\n"),x); \
d790 1
a790 1
   fprintf(stderr,"%s sym %d, addr %d, addend %d\n", \
d806 1
a806 1
   fprintf(stderr,"%s sym %d, r_vaddr %d %s\n", \
d1261 1
a1261 1
		    bfd_put_32(output_bfd,
d1321 1
a1321 1
		    bfd_put_32(output_bfd,
d1386 2
a1387 2
		    x = bfd_get_32(input_bfd, loc);
		    bfd_put_32(input_bfd, h->glue_insn, loc);
d1413 1
a1413 1
	    fprintf(stderr,
d1419 1
a1419 1
	    fprintf(stderr,"sym %ld (%s), r_vaddr %ld (%lx)\n",
d1652 3
a1654 3
  fprintf(file, _(h1));
  fprintf(file, _(h2));
  fprintf(file, _(h3));
d1656 1
a1656 1
  for(t = head; t != 0; t=t->next)
d1673 1
a1673 1
	      fprintf(file,
d1680 1
a1680 1
      fprintf(file,
d1682 1
a1682 1
      fprintf(file,
d1688 1
a1688 1
  fprintf(file, "\n");
d2070 1
a2070 1
      fprintf(stderr,
d2145 1
a2145 1
      fprintf(stderr,
@


1.7
log
@2000-11-14  Kazu Hirata  <kazu@@hxi.com>

	* coff-pmac.c: Fix formatting.
	* coff-ppc.c: Likewise.
@
text
@d91 1
a91 1
    abort(); \
d928 1
a928 1
				obj_raw_syment_count(abfd) * sizeof(int));
d1154 1
a1154 1
	  abort();
d1222 1
a1222 1
		    abort();
d1498 1
a1498 1
			abort();
d1705 1
a1705 1
      abort();
d1712 1
a1712 1
      abort();
d1755 1
a1755 1
      abort();
d2007 1
a2007 1
      (sizeof(ppc_coff_howto_table) / sizeof(ppc_coff_howto_table[0]) - 1)
d2039 1
a2039 1
    abort();
d2043 1
a2043 1
    abort();
d2110 1
a2110 1
    abort();
d2114 1
a2114 1
    abort();
d2281 1
a2281 1
	  abort();
@


1.6
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d8 1
a8 1
   coff files, in particular, those for the rs/6000, alpha, mips, and 
d32 1
a32 1
   - dlltool will not produce correct output in some .reloc cases, and will 
a35 1

a76 1

a93 1

d105 1
a105 1
/* PE linker hash table entries. */
a119 1

d153 1
a153 1
  struct ppc_coff_link_hash_entry *ret = 
d160 1
a160 1
      bfd_hash_allocate (table, 
d168 1
a168 1
	 _bfd_coff_link_hash_newfunc ((struct bfd_hash_entry *) ret, 
d237 1
a237 1
/* these should definitely go in a header file somewhere... */
a389 2


d415 1
a415 1
/*   TOCREL14       : 16 bit displacement field, similar to REL14 or ADDR14. */
d435 6
a440 6
  HOWTO (IMAGE_REL_PPC_ABSOLUTE, /* type */                                 
	 0,	                 /* rightshift */                           
	 0,	                 /* size (0 = byte, 1 = short, 2 = long) */ 
	 0,	                 /* bitsize */                   
	 false,	                 /* pc_relative */                          
	 0,	                 /* bitpos */                               
d442 1
a442 1
	 0,		         /* special_function */                     
d444 3
a446 3
	 false,	                 /* partial_inplace */                      
	 0x00,	 	         /* src_mask */                             
	 0x00,        		 /* dst_mask */                             
d448 1
a448 1
  
d451 6
a456 6
  HOWTO(IMAGE_REL_PPC_ADDR64,    /* type */                                 
	0,	                 /* rightshift */                           
	3,	                 /* size (0 = byte, 1 = short, 2 = long) */ 
	64,	                 /* bitsize */                   
	false,	                 /* pc_relative */                          
	0,	                 /* bitpos */                               
d458 1
a458 1
	0,		         /* special_function */                     
d460 1
a460 1
	true,	                 /* partial_inplace */                      
d468 5
a472 5
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d474 1
a474 1
	 0,		        /* special_function */                     
d476 3
a478 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,            /* src_mask */                             
	 0xffffffff,            /* dst_mask */                             
d480 1
a480 1
  
d484 1
a484 1
  /* anyone else uses.... The li field is in bit 2 thru 25 */ 
d487 2
a488 2
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
d490 2
a491 2
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d493 1
a493 1
	 0,		        /* special_function */                     
d495 3
a497 3
	 true,	                /* partial_inplace */                      
	 0x07fffffc,	        /* src_mask */                             
	 0x07fffffc,        	/* dst_mask */                             
d499 1
a499 1
  
d502 6
a507 6
  HOWTO (IMAGE_REL_PPC_ADDR16,  /* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d509 1
a509 1
	 0,		        /* special_function */                     
d511 3
a513 3
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d515 1
a515 1
  
d520 6
a525 6
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */             
	 1,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d527 1
a527 1
	 0,		        /* special_function */                     
d529 3
a531 3
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d533 1
a533 1
  
d538 5
a542 5
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 26,	                /* bitsize */                   
	 true,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d544 1
a544 1
	 0,		        /* special_function */                     
d546 3
a548 3
	 true,	                /* partial_inplace */                      
	 0x3fffffc,	        /* src_mask */                             
	 0x3fffffc,        	/* dst_mask */                             
d550 1
a550 1
  
d556 6
a561 6
  HOWTO (IMAGE_REL_PPC_ADDR14,  /* type */             
	 1,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d563 1
a563 1
	 0,		        /* special_function */                     
d565 3
a567 3
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d569 1
a569 1
  
d573 6
a578 6
  HOWTO (IMAGE_REL_PPC_TOCREL16,/* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d580 1
a580 1
	 ppc_toc16_reloc,       /* special_function */                     
d582 3
a584 3
	 false,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d586 1
a586 1
  
d590 6
a595 6
  HOWTO (IMAGE_REL_PPC_TOCREL14,/* type */             
	 1,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d597 1
a597 1
	 0,		        /* special_function */                     
d599 3
a601 3
	 false,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d603 1
a603 1
  
d607 6
a612 6
  HOWTO (IMAGE_REL_PPC_ADDR32NB,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d614 1
a614 1
	 0,                     /* special_function */                     
d616 3
a618 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d620 1
a620 1
  
d624 6
a629 6
  HOWTO (IMAGE_REL_PPC_SECREL,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d631 1
a631 1
	 ppc_secrel_reloc,      /* special_function */                     
d633 3
a635 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d641 6
a646 6
  HOWTO (IMAGE_REL_PPC_SECTION,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d648 1
a648 1
	 ppc_section_reloc,     /* special_function */                     
d650 3
a652 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d658 6
a663 6
  HOWTO (IMAGE_REL_PPC_IFGLUE,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d665 1
a665 1
	 0,		        /* special_function */                     
d667 3
a669 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d675 6
a680 6
  HOWTO (IMAGE_REL_PPC_IMGLUE,/* type */             
	 0,	                /* rightshift */                           
	 2,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 32,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d682 1
a682 1
	 ppc_imglue_reloc,      /* special_function */                     
d684 3
a686 3
	 false,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d692 6
a697 6
  HOWTO (IMAGE_REL_PPC_SECREL16,/* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d699 1
a699 1
	 0,		        /* special_function */                     
d701 3
a703 3
	 true,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
d708 6
a713 6
  HOWTO (IMAGE_REL_PPC_REFHI,   /* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d715 1
a715 1
	 ppc_refhi_reloc,	/* special_function */                     
d717 3
a719 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d724 6
a729 6
  HOWTO (IMAGE_REL_PPC_REFLO,   /* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d731 1
a731 1
	 ppc_refhi_reloc,	/* special_function */                     
d733 3
a735 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d740 6
a745 6
  HOWTO (IMAGE_REL_PPC_PAIR,    /* type */             
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d747 1
a747 1
	 ppc_pair_reloc,        /* special_function */                     
d749 3
a751 3
	 true,	                /* partial_inplace */                      
	 0xffffffff,	        /* src_mask */                             
	 0xffffffff,        	/* dst_mask */                             
d757 6
a762 6
  HOWTO ( (IMAGE_REL_PPC_TOCREL16 | IMAGE_REL_PPC_TOCDEFN), /* type */ 
	 0,	                /* rightshift */                           
	 1,	                /* size (0 = byte, 1 = short, 2 = long) */ 
	 16,	                /* bitsize */                   
	 false,	                /* pc_relative */                          
	 0,	                /* bitpos */                               
d764 1
a764 1
	 0,                     /* special_function */                     
d766 3
a768 3
	 false,	                /* partial_inplace */                      
	 0xffff,	        /* src_mask */                             
	 0xffff,        	/* dst_mask */                             
a772 1

d795 2
a796 2
/* Given a reloc name, n, and a pointer to an internal_reloc, 
   dump out interesting information on the contents 
a817 1

d919 2
a920 2
  if (h == 0) 
    { 
d926 2
a927 2
	  local_syms = 
	    (int *) bfd_zalloc (abfd, 
d938 1
a938 1
      if (IS_UNALLOCATED(local_syms[sym])) 
d999 1
a999 1
   appear in the output .reloc section. */
d1005 2
a1006 2
  return 
    (! howto->pc_relative) 
d1010 1
a1010 1
      && (howto->type != IMAGE_REL_PPC_IFGLUE) 
d1018 1
a1018 1
}     
d1045 1
a1045 1
	
d1048 1
a1048 1
  if (output_bfd) 
d1052 1
a1052 1
      return bfd_reloc_ok; 
d1059 1
a1059 1
      if (r_type == IMAGE_REL_PPC_REFHI) 
d1066 2
a1067 2
  
  if ((part1_consth_active) && (r_type != IMAGE_REL_PPC_PAIR)) 
d1074 1
d1076 1
a1076 3
  sym_value = get_symbol_value(symbol_in);
  
  return(bfd_reloc_ok);	
d1102 1
a1102 1
  
d1108 1
a1108 1
  
d1127 1
a1127 1
  
d1141 1
a1141 1
	  h = (struct ppc_coff_link_hash_entry *) 
d1143 1
a1143 1
	  if (h != 0) 
d1153 1
a1153 1
	  /* An IMGLUE reloc must have a name. Something is very wrong. */
d1197 1
a1197 1
      
d1214 1
a1214 1
	    if (toc_section == 0) 
d1216 1
a1216 1
		toc_section = bfd_get_section_by_name (bfd_of_toc_owner, 
d1219 1
a1219 1
		if ( toc_section == NULL ) 
d1221 1
a1221 1
		    /* There is no toc section. Something is very wrong. */
d1226 1
a1226 1
	    /* 
d1247 1
a1247 1
		    /* if it has been written out, it is marked with the 
d1256 3
a1258 3
		    record_toc(toc_section, 
			       our_toc_offset, 
			       priv, 
d1274 1
a1274 1
		if ((r_flags & IMAGE_REL_PPC_TOCDEFN) 
d1277 7
a1283 7
		    /* This is unbelievable cheese. Some knowledgable asm 
		       hacker has decided to use r2 as a base for loading 
		       a value. He/She does this by setting the tocdefn bit, 
		       and not supplying a toc definition. The behaviour is 
		       then to use the difference between the value of the 
		       symbol and the actual location of the toc as the toc 
		       index. 
d1288 1
a1288 1
		       dll linkage, takes advantage of that and considers 
d1292 2
a1293 2
		    our_toc_offset = val - 
		      (toc_section->output_section->vma + 
d1300 1
a1300 1
			  (_("%s: Relocation for %s of %x exceeds Toc size limit"), 
d1310 1
a1310 1
		    /* if it has been written out, it is marked with the 
d1332 1
a1332 1
	    if (fixit && info->base_file) 
d1338 1
a1338 1
		   isn't absolute - we output the address here 
d1343 1
a1343 1
		    
a1349 1

d1355 1
a1355 1
		  (_("%s: Relocation exceeds allocated TOC (%x)"), 
d1365 2
a1366 2
					    input_bfd, 
					    relocation, 
d1373 1
a1373 1
	    /* appearing on the call instruction is a glue function or not. */
d1376 1
a1376 1
	  
d1384 1
a1384 1
		if (h->symbol_is_glue == 1) 
d1394 2
a1395 2
	  /* For fast access to the header of the section 
	     containing the item. */
d1413 2
a1414 2
	    fprintf(stderr, 
		    _("Warning: unsupported reloc %s <file %s, section %s>\n"), 
d1419 1
a1419 1
	    fprintf(stderr,"sym %ld (%s), r_vaddr %ld (%lx)\n", 
d1421 1
a1421 1
		    (unsigned long) rel->r_vaddr);  
d1429 1
a1429 1
	    if (h->symbol_is_glue == 1) 
d1434 1
a1434 1
	      (_("%s: Out of order IMGLUE reloc for %s"), 
d1454 3
a1456 3
		first_thunk_address = myh->root.u.def.value + 
		  sec->output_section->vma + 
		    sec->output_offset - 
d1458 1
a1458 1
		
d1463 1
a1463 1
		
d1495 1
a1495 1
		    if (myh == 0) 
d1497 1
a1497 1
			/* Missing magic cookies. Something is very wrong. */
d1500 2
a1501 2
		    
		    val = myh->root.u.def.value + 
d1509 3
a1511 3
			first_thunk_address = myh->root.u.def.value + 
			  sec->output_section->vma + 
			    sec->output_offset - 
d1513 1
a1513 1
			
d1518 1
a1518 1
			
d1529 2
a1530 2
		      	      input_bfd, 
			      val - 
d1542 2
a1543 2
					  input_bfd, 
					  val, 
d1551 2
a1552 2
					  input_bfd, 
					  val, 
d1564 1
a1564 1
		 isn't absolute - we output the address here 
d1566 3
a1568 3
	      bfd_vma addr = rel->r_vaddr 
		- input_section->vma 
		+ input_section->output_offset 
d1607 1
a1607 1
		   (info, name, howto->name, 
d1616 1
a1616 1
    }     
d1692 1
a1692 1
ppc_allocate_toc_section (info) 
d1704 1
a1704 1
      /* No toc owner? Something is very wrong. */
d1709 1
a1709 1
  if (s == NULL) 
d1711 1
a1711 1
      /* No toc section? Something is very wrong. */
d1733 1
a1733 1
     to do reloc rummaging, before section sizes are nailed down. */
d1747 1
a1747 1
    if (sec->reloc_count == 0) 
d1753 1
a1753 1
    
d1757 1
a1757 1
    for (rel=i;rel<i+sec->reloc_count;++rel) 
d1765 1
a1765 1
	switch(r_type) 
d1771 1
a1771 1
	      ok = ppc_record_toc_entry(abfd, info, sec, 
a1789 1

a2008 1

d2010 1
a2010 1
          that there are some bits encoded in the upper portion of the 
d2020 1
a2020 1
{  
d2037 2
a2038 2
  /* the masking process only slices off the bottom byte for r_type. */
  if ( r_type > MAX_RELOC_INDEX ) 
d2045 1
a2045 1
  switch(r_type) 
d2070 1
a2070 1
      fprintf(stderr, 
d2074 1
a2074 1
      howto = ppc_coff_howto_table + r_type;      
d2077 1
a2077 1
  
d2079 1
a2079 1
  
d2108 2
a2109 2
  /* the masking process only slices off the bottom byte for r_type. */
  if ( r_type > MAX_RELOC_INDEX ) 
d2111 1
a2111 1
  
d2115 2
a2116 2
    
  switch(r_type) 
d2145 1
a2145 1
      fprintf(stderr, 
d2152 1
a2152 1
  
a2155 1

d2179 1
a2179 1
    default: 
d2188 1
a2188 1
/* Tailor coffcode.h -- macro heaven. */
d2201 1
a2201 1
#define coff_bfd_final_link          ppc_bfd_coff_final_link 
d2237 1
a2237 1
   What we're trying to do here is allocate a toc section (early), and attach 
d2267 1
a2267 1
      if (s != NULL) 
d2314 1
a2314 1
   the toc section is written last. 
d2317 1
a2317 1
   end of the section list for the bfd. 
d2319 3
a2321 3
   This is otherwise intended to be functionally the same as 
   cofflink.c:_bfd_coff_final_link(). It is specifically different only 
   where the POWERPC_LE_PE macro modifies the code. It is left in as a 
a2324 1

d2835 1
a2835 1
/* The transfer vectors that lead the outside world to all of the above. */
d2848 1
a2848 1
  
d2867 1
a2867 1
  
d2874 1
a2874 1
  
d2891 1
a2891 1
  
d2900 1
a2900 1
  bfd_target_coff_flavour,	
a2943 1

d2950 1
a2950 1
  
@


1.5
log
@add some comments about peigen.c
@
text
@d1200 1
a1200 1
		      rel->r_vaddr - input_section->vma)))
@


1.4
log
@	* coff-ppc.c (COFF_SECTION_ALIGNMENT_ENTRIES): Define.

1999-09-11  Donn Terry  <donn@@interix.com>

	* coffcode.h (coff_set_alignment_hook): Delete POWERPC_LE_PE
	special handling.
@
text
@d2217 1
d2225 3
@


1.3
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d2226 14
a2332 1
#define POWERPC_LE_PE
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2827 5
d2835 1
a2835 2
const bfd_target
TARGET_LITTLE_SYM =
d2881 7
d2889 1
a2889 1
  COFF_SWAP_TABLE,
d2894 1
a2894 2
const bfd_target
TARGET_BIG_SYM =
d2941 9
a2949 1
  COFF_SWAP_TABLE,
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d909 2
a910 2
     struct bfd_link_info *info;
     asection *sec;
d912 1
a912 1
     enum toc_type toc_kind;
d1010 1
a1010 1
     bfd * abfd;
d1703 1
a1703 1
     struct bfd_link_info *info;
d1809 5
a1813 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1815 1
a1815 1
     char **error_message;
d1863 5
a1867 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1869 1
a1869 1
     char **error_message;
d1889 5
a1893 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1895 1
a1895 1
     char **error_message;
d1948 5
a1952 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1954 1
a1954 1
     char **error_message;
d1973 5
a1977 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d1979 1
a1979 1
     char **error_message;
d1998 5
a2002 5
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
d2004 1
a2004 1
     char **error_message;
d2096 1
a2096 1
     bfd *abfd;
d2099 2
a2100 2
     struct coff_link_hash_entry *h;
     struct internal_syment *sym;
d2178 1
a2178 1
     bfd *abfd;
d2248 1
a2248 1
     PTR ext1;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

