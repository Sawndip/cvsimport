head	1.18;
access;
symbols
	sid-snapshot-20180601:1.18
	sid-snapshot-20180501:1.18
	sid-snapshot-20180401:1.18
	sid-snapshot-20180301:1.18
	sid-snapshot-20180201:1.18
	sid-snapshot-20180101:1.18
	sid-snapshot-20171201:1.18
	sid-snapshot-20171101:1.18
	sid-snapshot-20171001:1.18
	sid-snapshot-20170901:1.18
	sid-snapshot-20170801:1.18
	sid-snapshot-20170701:1.18
	sid-snapshot-20170601:1.18
	sid-snapshot-20170501:1.18
	sid-snapshot-20170401:1.18
	sid-snapshot-20170301:1.18
	sid-snapshot-20170201:1.18
	sid-snapshot-20170101:1.18
	sid-snapshot-20161201:1.18
	sid-snapshot-20161101:1.18
	sid-snapshot-20160901:1.18
	sid-snapshot-20160801:1.18
	sid-snapshot-20160701:1.18
	sid-snapshot-20160601:1.18
	sid-snapshot-20160501:1.18
	sid-snapshot-20160401:1.18
	sid-snapshot-20160301:1.18
	sid-snapshot-20160201:1.18
	sid-snapshot-20160101:1.18
	sid-snapshot-20151201:1.18
	sid-snapshot-20151101:1.18
	sid-snapshot-20151001:1.18
	sid-snapshot-20150901:1.18
	sid-snapshot-20150801:1.18
	sid-snapshot-20150701:1.18
	sid-snapshot-20150601:1.18
	sid-snapshot-20150501:1.18
	sid-snapshot-20150401:1.18
	sid-snapshot-20150301:1.18
	sid-snapshot-20150201:1.18
	sid-snapshot-20150101:1.18
	sid-snapshot-20141201:1.18
	sid-snapshot-20141101:1.18
	sid-snapshot-20141001:1.18
	sid-snapshot-20140901:1.18
	sid-snapshot-20140801:1.18
	sid-snapshot-20140701:1.18
	sid-snapshot-20140601:1.18
	sid-snapshot-20140501:1.18
	sid-snapshot-20140401:1.18
	sid-snapshot-20140301:1.18
	sid-snapshot-20140201:1.18
	sid-snapshot-20140101:1.18
	sid-snapshot-20131201:1.18
	sid-snapshot-20131101:1.18
	sid-snapshot-20131001:1.18
	binutils-2_24-branch:1.18.0.2
	binutils-2_24-branchpoint:1.18
	binutils-2_21_1:1.14
	sid-snapshot-20130901:1.18
	gdb_7_6_1-2013-08-30-release:1.17
	sid-snapshot-20130801:1.18
	sid-snapshot-20130701:1.18
	sid-snapshot-20130601:1.18
	sid-snapshot-20130501:1.18
	gdb_7_6-2013-04-26-release:1.17
	sid-snapshot-20130401:1.18
	binutils-2_23_2:1.15.12.1
	gdb_7_6-branch:1.17.0.2
	gdb_7_6-2013-03-12-branchpoint:1.17
	sid-snapshot-20130301:1.17
	sid-snapshot-20130201:1.17
	sid-snapshot-20130101:1.16
	sid-snapshot-20121201:1.16
	gdb_7_5_1-2012-11-29-release:1.15
	binutils-2_23_1:1.15.12.1
	sid-snapshot-20121101:1.16
	binutils-2_23:1.15.12.1
	sid-snapshot-20121001:1.16
	sid-snapshot-20120901:1.15
	gdb_7_5-2012-08-17-release:1.15
	sid-snapshot-20120801:1.15
	binutils-2_23-branch:1.15.0.12
	binutils-2_23-branchpoint:1.15
	gdb_7_5-branch:1.15.0.10
	gdb_7_5-2012-07-18-branchpoint:1.15
	sid-snapshot-20120701:1.15
	sid-snapshot-20120601:1.15
	sid-snapshot-20120501:1.15
	binutils-2_22_branch:1.15.0.8
	gdb_7_4_1-2012-04-26-release:1.15
	sid-snapshot-20120401:1.15
	sid-snapshot-20120301:1.15
	sid-snapshot-20120201:1.15
	gdb_7_4-2012-01-24-release:1.15
	sid-snapshot-20120101:1.15
	gdb_7_4-branch:1.15.0.6
	gdb_7_4-2011-12-13-branchpoint:1.15
	sid-snapshot-20111201:1.15
	binutils-2_22:1.15
	sid-snapshot-20111101:1.15
	sid-snapshot-20111001:1.15
	binutils-2_22-branch:1.15.0.4
	binutils-2_22-branchpoint:1.15
	gdb_7_3_1-2011-09-04-release:1.15
	sid-snapshot-20110901:1.15
	sid-snapshot-20110801:1.15
	gdb_7_3-2011-07-26-release:1.15
	sid-snapshot-20110701:1.15
	sid-snapshot-20110601:1.15
	sid-snapshot-20110501:1.15
	gdb_7_3-branch:1.15.0.2
	gdb_7_3-2011-04-01-branchpoint:1.15
	sid-snapshot-20110401:1.15
	sid-snapshot-20110301:1.14
	sid-snapshot-20110201:1.14
	sid-snapshot-20110101:1.14
	binutils-2_21:1.14
	sid-snapshot-20101201:1.14
	binutils-2_21-branch:1.14.0.22
	binutils-2_21-branchpoint:1.14
	sid-snapshot-20101101:1.14
	sid-snapshot-20101001:1.14
	binutils-2_20_1:1.14
	gdb_7_2-2010-09-02-release:1.14
	sid-snapshot-20100901:1.14
	sid-snapshot-20100801:1.14
	gdb_7_2-branch:1.14.0.20
	gdb_7_2-2010-07-07-branchpoint:1.14
	sid-snapshot-20100701:1.14
	sid-snapshot-20100601:1.14
	sid-snapshot-20100501:1.14
	sid-snapshot-20100401:1.14
	gdb_7_1-2010-03-18-release:1.14
	sid-snapshot-20100301:1.14
	gdb_7_1-branch:1.14.0.18
	gdb_7_1-2010-02-18-branchpoint:1.14
	sid-snapshot-20100201:1.14
	sid-snapshot-20100101:1.14
	gdb_7_0_1-2009-12-22-release:1.14
	sid-snapshot-20091201:1.14
	sid-snapshot-20091101:1.14
	binutils-2_20:1.14
	gdb_7_0-2009-10-06-release:1.14
	sid-snapshot-20091001:1.14
	gdb_7_0-branch:1.14.0.16
	gdb_7_0-2009-09-16-branchpoint:1.14
	arc-sim-20090309:1.12
	binutils-arc-20081103-branch:1.14.0.14
	binutils-arc-20081103-branchpoint:1.14
	binutils-2_20-branch:1.14.0.12
	binutils-2_20-branchpoint:1.14
	sid-snapshot-20090901:1.14
	sid-snapshot-20090801:1.14
	msnyder-checkpoint-072509-branch:1.14.0.10
	msnyder-checkpoint-072509-branchpoint:1.14
	sid-snapshot-20090701:1.14
	dje-cgen-play1-branch:1.14.0.8
	dje-cgen-play1-branchpoint:1.14
	sid-snapshot-20090601:1.14
	sid-snapshot-20090501:1.14
	sid-snapshot-20090401:1.14
	arc-20081103-branch:1.14.0.6
	arc-20081103-branchpoint:1.14
	arc-insight_6_8-branch:1.12.0.14
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.12
	insight_6_8-branchpoint:1.12
	sid-snapshot-20090301:1.14
	binutils-2_19_1:1.13
	sid-snapshot-20090201:1.14
	sid-snapshot-20090101:1.14
	reverse-20081226-branch:1.14.0.4
	reverse-20081226-branchpoint:1.14
	sid-snapshot-20081201:1.14
	multiprocess-20081120-branch:1.14.0.2
	multiprocess-20081120-branchpoint:1.14
	sid-snapshot-20081101:1.14
	binutils-2_19:1.13
	sid-snapshot-20081001:1.13
	reverse-20080930-branch:1.13.0.4
	reverse-20080930-branchpoint:1.13
	binutils-2_19-branch:1.13.0.2
	binutils-2_19-branchpoint:1.13
	sid-snapshot-20080901:1.13
	sid-snapshot-20080801:1.13
	reverse-20080717-branch:1.12.0.10
	reverse-20080717-branchpoint:1.12
	sid-snapshot-20080701:1.12
	msnyder-reverse-20080609-branch:1.12.0.8
	msnyder-reverse-20080609-branchpoint:1.12
	drow-reverse-20070409-branch:1.11.0.4
	drow-reverse-20070409-branchpoint:1.11
	sid-snapshot-20080601:1.12
	sid-snapshot-20080501:1.12
	sid-snapshot-20080403:1.12
	sid-snapshot-20080401:1.12
	gdb_6_8-2008-03-27-release:1.12
	sid-snapshot-20080301:1.12
	gdb_6_8-branch:1.12.0.6
	gdb_6_8-2008-02-26-branchpoint:1.12
	sid-snapshot-20080201:1.12
	sid-snapshot-20080101:1.12
	sid-snapshot-20071201:1.12
	sid-snapshot-20071101:1.12
	gdb_6_7_1-2007-10-29-release:1.12
	gdb_6_7-2007-10-10-release:1.12
	sid-snapshot-20071001:1.12
	gdb_6_7-branch:1.12.0.4
	gdb_6_7-2007-09-07-branchpoint:1.12
	binutils-2_18:1.12
	binutils-2_18-branch:1.12.0.2
	binutils-2_18-branchpoint:1.12
	insight_6_6-20070208-release:1.11
	binutils-csl-coldfire-4_1-32:1.9
	binutils-csl-sourcerygxx-4_1-32:1.9
	gdb_6_6-2006-12-18-release:1.11
	binutils-csl-innovasic-fido-3_4_4-33:1.9
	binutils-csl-sourcerygxx-3_4_4-32:1.7
	binutils-csl-coldfire-4_1-30:1.9
	binutils-csl-sourcerygxx-4_1-30:1.9
	binutils-csl-coldfire-4_1-28:1.9
	binutils-csl-sourcerygxx-4_1-29:1.9
	binutils-csl-sourcerygxx-4_1-28:1.9
	gdb_6_6-branch:1.11.0.2
	gdb_6_6-2006-11-15-branchpoint:1.11
	binutils-csl-arm-2006q3-27:1.9
	binutils-csl-sourcerygxx-4_1-27:1.9
	binutils-csl-arm-2006q3-26:1.9
	binutils-csl-sourcerygxx-4_1-26:1.9
	binutils-csl-sourcerygxx-4_1-25:1.9
	binutils-csl-sourcerygxx-4_1-24:1.9
	binutils-csl-sourcerygxx-4_1-23:1.9
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.9
	binutils-csl-sourcerygxx-4_1-21:1.9
	binutils-csl-arm-2006q3-21:1.9
	binutils-csl-sourcerygxx-4_1-22:1.9
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.9
	binutils-csl-sourcerygxx-4_1-20:1.9
	binutils-csl-arm-2006q3-19:1.9
	binutils-csl-sourcerygxx-4_1-19:1.9
	binutils-csl-sourcerygxx-4_1-18:1.9
	binutils-csl-renesas-4_1-9:1.9
	gdb-csl-sourcerygxx-3_4_4-25:1.9
	binutils-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.10
	gdb-csl-symbian-6_4_50_20060226-11:1.9
	binutils-csl-renesas-4_1-8:1.9
	binutils-csl-renesas-4_1-7:1.9
	binutils-csl-renesas-4_1-6:1.9
	gdb-csl-sourcerygxx-4_1-17:1.9
	binutils-csl-sourcerygxx-4_1-17:1.9
	gdb-csl-20060226-branch-local-2:1.9
	gdb-csl-sourcerygxx-4_1-14:1.9
	binutils-csl-sourcerygxx-4_1-14:1.9
	binutils-csl-sourcerygxx-4_1-15:1.9
	gdb-csl-sourcerygxx-4_1-13:1.9
	binutils-csl-sourcerygxx-4_1-13:1.9
	binutils-2_17:1.9
	gdb-csl-sourcerygxx-4_1-12:1.9
	binutils-csl-sourcerygxx-4_1-12:1.9
	gdb-csl-sourcerygxx-3_4_4-21:1.9
	binutils-csl-sourcerygxx-3_4_4-21:1.9
	gdb_6_5-20060621-release:1.10
	binutils-csl-wrs-linux-3_4_4-24:1.7
	binutils-csl-wrs-linux-3_4_4-23:1.7
	gdb-csl-sourcerygxx-4_1-9:1.9
	binutils-csl-sourcerygxx-4_1-9:1.9
	gdb-csl-sourcerygxx-4_1-8:1.9
	binutils-csl-sourcerygxx-4_1-8:1.9
	gdb-csl-sourcerygxx-4_1-7:1.9
	binutils-csl-sourcerygxx-4_1-7:1.9
	gdb-csl-arm-2006q1-6:1.9
	binutils-csl-arm-2006q1-6:1.9
	gdb-csl-sourcerygxx-4_1-6:1.9
	binutils-csl-sourcerygxx-4_1-6:1.9
	binutils-csl-wrs-linux-3_4_4-22:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.9
	gdb-csl-symbian-6_4_50_20060226-9:1.9
	gdb-csl-symbian-6_4_50_20060226-8:1.9
	gdb-csl-coldfire-4_1-11:1.9
	binutils-csl-coldfire-4_1-11:1.9
	gdb-csl-sourcerygxx-3_4_4-19:1.9
	binutils-csl-sourcerygxx-3_4_4-19:1.9
	gdb-csl-coldfire-4_1-10:1.9
	gdb_6_5-branch:1.10.0.4
	gdb_6_5-2006-05-14-branchpoint:1.10
	binutils-csl-coldfire-4_1-10:1.9
	gdb-csl-sourcerygxx-4_1-5:1.9
	binutils-csl-sourcerygxx-4_1-5:1.9
	nickrob-async-20060513-branch:1.10.0.2
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.9
	binutils-csl-sourcerygxx-4_1-4:1.9
	msnyder-reverse-20060502-branch:1.9.0.26
	msnyder-reverse-20060502-branchpoint:1.9
	binutils-csl-wrs-linux-3_4_4-21:1.7
	gdb-csl-morpho-4_1-4:1.9
	binutils-csl-morpho-4_1-4:1.9
	gdb-csl-sourcerygxx-3_4_4-17:1.9
	binutils-csl-sourcerygxx-3_4_4-17:1.9
	binutils-csl-wrs-linux-3_4_4-20:1.7
	readline_5_1-import-branch:1.9.0.24
	readline_5_1-import-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.9
	binutils-2_17-branch:1.9.0.22
	binutils-2_17-branchpoint:1.9
	gdb-csl-symbian-20060226-branch:1.9.0.20
	gdb-csl-symbian-20060226-branchpoint:1.9
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.9
	msnyder-reverse-20060331-branch:1.9.0.18
	msnyder-reverse-20060331-branchpoint:1.9
	binutils-csl-2_17-branch:1.9.0.16
	binutils-csl-2_17-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.9.0.14
	gdb-csl-available-20060303-branchpoint:1.9
	gdb-csl-20060226-branch:1.9.0.12
	gdb-csl-20060226-branchpoint:1.9
	gdb_6_4-20051202-release:1.9
	msnyder-fork-checkpoint-branch:1.9.0.10
	msnyder-fork-checkpoint-branchpoint:1.9
	gdb-csl-gxxpro-6_3-branch:1.9.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.9
	gdb_6_4-branch:1.9.0.6
	gdb_6_4-2005-11-01-branchpoint:1.9
	gdb-csl-arm-20051020-branch:1.9.0.4
	gdb-csl-arm-20051020-branchpoint:1.9
	binutils-csl-gxxpro-3_4-branch:1.7.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.7
	binutils-2_16_1:1.7
	msnyder-tracepoint-checkpoint-branch:1.9.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.9
	gdb-csl-arm-20050325-2005-q1b:1.7
	binutils-csl-arm-2005q1b:1.7
	binutils-2_16:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	binutils-csl-arm-2005q1a:1.7
	csl-arm-20050325-branch:1.7.0.6
	csl-arm-20050325-branchpoint:1.7
	binutils-csl-arm-2005q1-branch:1.7.0.4
	binutils-csl-arm-2005q1-branchpoint:1.7
	binutils-2_16-branch:1.7.0.2
	binutils-2_16-branchpoint:1.7
	csl-arm-2004-q3d:1.4
	gdb_6_3-20041109-release:1.4
	gdb_6_3-branch:1.4.0.4
	gdb_6_3-20041019-branchpoint:1.4
	csl-arm-2004-q3:1.4
	drow_intercu-merge-20040921:1.4
	drow_intercu-20040221-branch:1.4.0.2
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.2.0.6
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	binutils_latest_snapshot:1.18;
locks; strict;
comment	@ * @;


1.18
date	2013.03.23.10.25.02;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.16;

1.16
date	2012.09.19.00.53.28;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2011.03.14.15.54.58;	author rsandifo;	state Exp;
branches
	1.15.12.1;
next	1.14;

1.14
date	2008.10.20.11.05.47;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2006.05.02.09.56.00;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.04.15.53.19;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.04.07.19.24;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.28.15.57.13;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.24.13.34.38;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.16.14.52.05;	author amodra;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2004.08.13.03.15.57;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.09.12.32.35;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.06.16.58.42;	author nickc;	state Exp;
branches;
next	;

1.15.12.1
date	2012.09.24.12.22.45;	author gingold;	state Exp;
branches;
next	;

1.4.2.1
date	2004.09.16.17.00.26;	author drow;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2004.09.21.20.44.02;	author drow;	state Exp;
branches;
next	;


desc
@@


1.18
log
@	* elf-bfd.h (_bfd_elf_merge_symbol): Delete declaration.
	* elflink.c (_bfd_elf_merge_symbol): Make static.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Don't call
	_bfd_elf_merge_symbol, call _bfd_generic_link_add_one_symbol.
@
text
@/* Renesas / SuperH specific support for Symbian 32-bit ELF files
   Copyright 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
   Contributed by Red Hat

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* Stop elf32-sh.c from defining any target vectors.  */
#define SH_TARGET_ALREADY_DEFINED
#define sh_find_elf_flags           sh_symbian_find_elf_flags
#define sh_elf_get_flags_from_mach  sh_symbian_elf_get_flags_from_mach
#include "elf32-sh.c"


//#define SYMBIAN_DEBUG 1
#define SYMBIAN_DEBUG 0

#define DIRECTIVE_HEADER	"#<SYMEDIT>#\n"
#define DIRECTIVE_IMPORT	"IMPORT "
#define DIRECTIVE_EXPORT	"EXPORT "
#define DIRECTIVE_AS		"AS "

/* Macro to advance 's' until either it reaches 'e' or the
   character pointed to by 's' is equal to 'c'.  If 'e' is
   reached and SYMBIAN_DEBUG is enabled then the error message 'm'
   is displayed.  */
#define SKIP_UNTIL(s,e,c,m)					\
  do								\
    {								\
      while (s < e && *s != c)					\
	++ s;							\
      if (s >= e)						\
	{							\
          if (SYMBIAN_DEBUG)					\
	    fprintf (stderr, "Corrupt directive: %s\n", m);	\
	  result = FALSE;					\
	}							\
    }								\
  while (0);							\
  if (!result)							\
     break;

/* Like SKIP_UNTIL except there are two terminator characters
   c1 and c2.  */
#define SKIP_UNTIL2(s,e,c1,c2,m)				\
  do								\
    {								\
      while (s < e && *s != c1 && *s != c2)			\
	++ s;							\
      if (s >= e)						\
	{							\
          if (SYMBIAN_DEBUG)					\
	    fprintf (stderr, "Corrupt directive: %s\n", m);	\
	  result = FALSE;					\
	}							\
    }								\
  while (0);							\
  if (!result)							\
     break;

/* Macro to advance 's' until either it reaches 'e' or the
   character pointed to by 's' is not equal to 'c'.  If 'e'
   is reached and SYMBIAN_DEBUG is enabled then the error message
   'm' is displayed.  */
#define SKIP_WHILE(s,e,c,m)					\
  do								\
    {								\
      while (s < e && *s == c)					\
	++ s;							\
      if (s >= e)						\
	{							\
          if (SYMBIAN_DEBUG)					\
	    fprintf (stderr, "Corrupt directive: %s\n", m);	\
	  result = FALSE;					\
	}							\
    }								\
  while (0);							\
  if (!result)							\
     break;


typedef struct symbol_rename
{
  struct symbol_rename *       next;
  char *                       current_name;
  char *                       new_name;
  struct elf_link_hash_entry * current_hash;
  unsigned long                new_symndx;
}
symbol_rename;

static symbol_rename * rename_list = NULL;

/* Accumulate a list of symbols to be renamed.  */

static bfd_boolean
sh_symbian_import_as (struct bfd_link_info *info, bfd * abfd,
		      char * current_name, char * new_name)
{
  struct elf_link_hash_entry * new_hash;
  symbol_rename * node;

  if (SYMBIAN_DEBUG)
    fprintf (stderr, "IMPORT '%s' AS '%s'\n", current_name, new_name);

  for (node = rename_list; node; node = node->next)
    if (strcmp (node->current_name, current_name) == 0)
      {
	if (strcmp (node->new_name, new_name) == 0)
	  /* Already added to rename list.  */
	  return TRUE;

	bfd_set_error (bfd_error_invalid_operation);
	_bfd_error_handler (_("%B: IMPORT AS directive for %s conceals previous IMPORT AS"),
			    abfd, current_name);
	return FALSE;
      }

  if ((node = bfd_malloc (sizeof * node)) == NULL)
    {
      if (SYMBIAN_DEBUG)
	fprintf (stderr, "IMPORT AS: No mem for new rename node\n");
      return FALSE;
    }

  if ((node->current_name = bfd_malloc (strlen (current_name) + 1)) == NULL)
    {
      if (SYMBIAN_DEBUG)
	fprintf (stderr, "IMPORT AS: No mem for current name field in rename node\n");
      free (node);
      return FALSE;
    }
  else
    strcpy (node->current_name, current_name);

  if ((node->new_name = bfd_malloc (strlen (new_name) + 1)) == NULL)
    {
      if (SYMBIAN_DEBUG)
	fprintf (stderr, "IMPORT AS: No mem for new name field in rename node\n");
      free (node->current_name);
      free (node);
      return FALSE;
    }
  else
    strcpy (node->new_name, new_name);

  node->next = rename_list;
  node->current_hash = NULL;
  node->new_symndx = 0;
  rename_list = node;

  new_hash = elf_link_hash_lookup (elf_hash_table (info), node->new_name, TRUE, FALSE, TRUE);
  bfd_elf_link_record_dynamic_symbol (info, new_hash);
  if (new_hash->root.type == bfd_link_hash_new)
    new_hash->root.type = bfd_link_hash_undefined;

  return TRUE;
}


static bfd_boolean
sh_symbian_import (bfd * abfd ATTRIBUTE_UNUSED, char * name)
{
  if (SYMBIAN_DEBUG)
    fprintf (stderr, "IMPORT '%s'\n", name);

  /* XXX: Generate an import somehow ?  */

  return TRUE;
}

static bfd_boolean
sh_symbian_export (bfd * abfd ATTRIBUTE_UNUSED, char * name)
{
  if (SYMBIAN_DEBUG)
    fprintf (stderr, "EXPORT '%s'\n", name);

  /* XXX: Generate an export somehow ?  */

  return TRUE;
}

/* Process any magic embedded commands in the .directive. section.
   Returns TRUE upon sucecss, but if it fails it sets bfd_error and
   returns FALSE.  */

static bfd_boolean
sh_symbian_process_embedded_commands (struct bfd_link_info *info, bfd * abfd,
				      asection * sec, bfd_byte * contents)
{
  char *s;
  char *e;
  bfd_boolean result = TRUE;
  bfd_size_type sz = sec->rawsize ? sec->rawsize : sec->size;

  for (s = (char *) contents, e = s + sz; s < e;)
    {
      char * directive = s;

      switch (*s)
	{
	  /* I want to use "case DIRECTIVE_HEADER [0]:" here but gcc won't let me :-(  */
	case '#':
	  if (strcmp (s, DIRECTIVE_HEADER))
	    result = FALSE;
	  else
	    /* Just ignore the header.
	       XXX: Strictly speaking we ought to check that the header
	       is present and that it is the first thing in the file.  */
	    s += strlen (DIRECTIVE_HEADER) + 1;
	  break;

	case 'I':
	  if (! CONST_STRNEQ (s, DIRECTIVE_IMPORT))
	    result = FALSE;
	  else
	    {
	      char * new_name;
	      char * new_name_end;
	      char   name_end_char;

	      /* Skip the IMPORT directive.  */
	      s += strlen (DIRECTIVE_IMPORT);

	      new_name = s;
	      /* Find the end of the new name.  */
	      while (s < e && *s != ' ' && *s != '\n')
		++ s;
	      if (s >= e)
		{
		  /* We have reached the end of the .directive section
		     without encountering a string terminator.  This is
		     allowed for IMPORT directives.  */
		  new_name_end   = e - 1;
		  name_end_char  = * new_name_end;
		  * new_name_end = 0;
		  result = sh_symbian_import (abfd, new_name);
		  * new_name_end = name_end_char;
		  break;
		}

	      /* Remember where the name ends.  */
	      new_name_end = s;
	      /* Skip any whitespace before the 'AS'.  */
	      SKIP_WHILE (s, e, ' ', "IMPORT: Name just followed by spaces");
	      /* Terminate the new name.  (Do this after skiping...)  */
	      name_end_char = * new_name_end;
	      * new_name_end = 0;

	      /* Check to see if 'AS '... is present.  If so we have an
		 IMPORT AS directive, otherwise we have an IMPORT directive.  */
	      if (! CONST_STRNEQ (s, DIRECTIVE_AS))
		{
		  /* Skip the new-line at the end of the name.  */
		  if (SYMBIAN_DEBUG && name_end_char != '\n')
		    fprintf (stderr, "IMPORT: No newline at end of directive\n");
		  else
		    s ++;

		  result = sh_symbian_import (abfd, new_name);

		  /* Skip past the NUL character.  */
		  if (* s ++ != 0)
		    {
		      if (SYMBIAN_DEBUG)
			fprintf (stderr, "IMPORT: No NUL at end of directive\n");
		    }
		}
	      else
		{
		  char * current_name;
		  char * current_name_end;
		  char   current_name_end_char;

		  /* Skip the 'AS '.  */
		  s += strlen (DIRECTIVE_AS);
		  /* Skip any white space after the 'AS '.  */
		  SKIP_WHILE (s, e, ' ', "IMPORT AS: Nothing after AS");
		  current_name = s;
		  /* Find the end of the current name.  */
		  SKIP_UNTIL2 (s, e, ' ', '\n', "IMPORT AS: No newline at the end of the current name");
		  /* Skip (backwards) over spaces at the end of the current name.  */
		  current_name_end = s;
		  current_name_end_char = * current_name_end;

		  SKIP_WHILE (s, e, ' ', "IMPORT AS: Current name just followed by spaces");
		  /* Skip past the newline character.  */
		  if (* s ++ != '\n')
		    if (SYMBIAN_DEBUG)
		      fprintf (stderr, "IMPORT AS: No newline at end of directive\n");

		  /* Terminate the current name after having performed the skips.  */
		  * current_name_end = 0;

		  result = sh_symbian_import_as (info, abfd, current_name, new_name);

		  /* The next character should be a NUL.  */
		  if (* s != 0)
		    {
		      if (SYMBIAN_DEBUG)
			fprintf (stderr, "IMPORT AS: Junk at end of directive\n");
		      result = FALSE;
		    }
		  s ++;

		  * current_name_end = current_name_end_char;
		}

	      /* Restore the characters we overwrote, since
		 the .directive section will be emitted.  */
	      * new_name_end = name_end_char;
	    }
	  break;

	case 'E':
	  if (! CONST_STRNEQ (s, DIRECTIVE_EXPORT))
	    result = FALSE;
	  else
	    {
	      char * name;
	      char * name_end;
	      char   name_end_char;

	      /* Skip the directive.  */
	      s += strlen (DIRECTIVE_EXPORT);
	      name = s;
	      /* Find the end of the name to be exported.  */
	      SKIP_UNTIL (s, e, '\n', "EXPORT: no newline at end of directive");
	      /* Skip (backwards) over spaces at end of exported name.  */
	      for (name_end = s; name_end[-1] == ' '; name_end --)
		;
	      /* name_end now points at the first character after the
		 end of the exported name, so we can termiante it  */
	      name_end_char = * name_end;
	      * name_end = 0;
	      /* Skip passed the newline character.  */
	      s ++;

	      result = sh_symbian_export (abfd, name);

	      /* The next character should be a NUL.  */
	      if (* s != 0)
		{
		  if (SYMBIAN_DEBUG)
		    fprintf (stderr, "EXPORT: Junk at end of directive\n");
		  result = FALSE;
		}
	      s++;

	      /* Restore the character we deleted.  */
	      * name_end = name_end_char;
	    }
	  break;

	default:
	  result = FALSE;
	  break;
	}

      if (! result)
	{
	  if (SYMBIAN_DEBUG)
	    fprintf (stderr, "offset into .directive section: %ld\n",
		     (long) (directive - (char *) contents));

	  bfd_set_error (bfd_error_invalid_operation);
	  _bfd_error_handler (_("%B: Unrecognised .directive command: %s"),
			      abfd, directive);
	  break;
	}
    }

  return result;
}


/* Scan a bfd for a .directive section, and if found process it.
   Returns TRUE upon success, FALSE otherwise.  */

static bfd_boolean
sh_symbian_process_directives (bfd *abfd, struct bfd_link_info *info)
{
  bfd_boolean result = FALSE;
  bfd_byte *  contents;
  asection *  sec = bfd_get_section_by_name (abfd, ".directive");
  bfd_size_type sz;

  if (!sec)
    return TRUE;

  sz = sec->rawsize ? sec->rawsize : sec->size;
  contents = bfd_malloc (sz);

  if (!contents)
    bfd_set_error (bfd_error_no_memory);
  else
    {
      if (bfd_get_section_contents (abfd, sec, contents, 0, sz))
	result = sh_symbian_process_embedded_commands (info, abfd, sec, contents);
      free (contents);
    }

  return result;
}

/* Intercept the normal sh_relocate_section() function
   and magle the relocs to allow for symbol renaming.  */

static bfd_boolean
sh_symbian_relocate_section (bfd *                  output_bfd,
			     struct bfd_link_info * info,
			     bfd *                  input_bfd,
			     asection *             input_section,
			     bfd_byte *             contents,
			     Elf_Internal_Rela *    relocs,
			     Elf_Internal_Sym *     local_syms,
			     asection **            local_sections)
{
  /* When performing a final link we implement the IMPORT AS directives.  */
  if (!info->relocatable)
    {
      Elf_Internal_Rela *            rel;
      Elf_Internal_Rela *            relend;
      Elf_Internal_Shdr *            symtab_hdr;
      struct elf_link_hash_entry **  sym_hashes;
      struct elf_link_hash_entry **  sym_hashes_end;
      struct elf_link_hash_table *   hash_table;
      symbol_rename *                ptr;
      bfd_size_type                  num_global_syms;
      unsigned long		     num_local_syms;

      BFD_ASSERT (! elf_bad_symtab (input_bfd));

      symtab_hdr       = & elf_tdata (input_bfd)->symtab_hdr;
      hash_table       = elf_hash_table (info);
      num_local_syms   = symtab_hdr->sh_info;
      num_global_syms  = symtab_hdr->sh_size / sizeof (Elf32_External_Sym);
      num_global_syms -= num_local_syms;
      sym_hashes       = elf_sym_hashes (input_bfd);
      sym_hashes_end   = sym_hashes + num_global_syms;

      /* First scan the rename table, caching the hash entry and the new index.  */
      for (ptr = rename_list; ptr; ptr = ptr->next)
	{
	  struct elf_link_hash_entry *   new_hash;
	  struct elf_link_hash_entry **  h;

	  ptr->current_hash = elf_link_hash_lookup (hash_table, ptr->current_name, FALSE, FALSE, TRUE);

	  if (ptr->current_hash == NULL)
	    {
	      if (SYMBIAN_DEBUG)
		fprintf (stderr, "IMPORT AS: current symbol '%s' does not exist\n", ptr->current_name);
	      continue;
	    }

	  new_hash = elf_link_hash_lookup (hash_table, ptr->new_name,
					   FALSE, FALSE, TRUE);
	  /* If we could not find the symbol then it is a new, undefined symbol.
	     Symbian want this behaviour - ie they want to be able to rename the
	     reference in a reloc from one undefined symbol to another, new and
	     undefined symbol.  So we create that symbol here.  */
	  if (new_hash == NULL)
	    {
	      struct bfd_link_hash_entry *bh = NULL;
	      bfd_boolean collect = get_elf_backend_data (input_bfd)->collect;
	      if (_bfd_generic_link_add_one_symbol (info, input_bfd,
						    ptr->new_name, BSF_GLOBAL,
						    bfd_und_section_ptr, 0,
						    NULL, FALSE, collect,
						    &bh))
		{
		  new_hash = (struct elf_link_hash_entry *) bh;
		  new_hash->type = STT_FUNC;
		  new_hash->non_elf = 0;

		  if (SYMBIAN_DEBUG)
		    fprintf (stderr, "Created new symbol %s\n", ptr->new_name);
		}
	    }

	  if (new_hash == NULL)
	    {
	      _bfd_error_handler (_("%B: Failed to add renamed symbol %s"),
				  input_bfd, ptr->new_name);
	      continue;
	    }

	  /* Convert the new_hash value into a index into the table of symbol hashes.  */
	  for (h = sym_hashes; h < sym_hashes_end; h ++)
	    {
	      if (* h == new_hash)
		{
		  ptr->new_symndx = h - sym_hashes + num_local_syms;
		  if (SYMBIAN_DEBUG)
		    fprintf (stderr, "Converted new hash to index of %ld\n", ptr->new_symndx);
		  break;
		}
	    }
	  /* If the new symbol is not in the hash table then it must be
	     because it is one of the newly created undefined symbols
	     manufactured above.  So we extend the sym has table here to
	     include this extra symbol.  */
	  if (h == sym_hashes_end)
	    {
	      struct elf_link_hash_entry **  new_sym_hashes;

	      /* This is not very efficient, but it works.  */
	      ++ num_global_syms;
	      new_sym_hashes = bfd_alloc (input_bfd, num_global_syms * sizeof * sym_hashes);
	      if (new_sym_hashes == NULL)
		{
		  if (SYMBIAN_DEBUG)
		    fprintf (stderr, "Out of memory extending hash table\n");
		  continue;
		}
	      memcpy (new_sym_hashes, sym_hashes, (num_global_syms - 1) * sizeof * sym_hashes);
	      new_sym_hashes[num_global_syms - 1] = new_hash;
	      elf_sym_hashes (input_bfd) = sym_hashes = new_sym_hashes;
	      sym_hashes_end = sym_hashes + num_global_syms;
	      symtab_hdr->sh_size  = (num_global_syms + num_local_syms) * sizeof (Elf32_External_Sym);

	      ptr->new_symndx = num_global_syms - 1 + num_local_syms;

	      if (SYMBIAN_DEBUG)
		fprintf (stderr, "Extended symbol hash table to insert new symbol as index %ld\n",
			 ptr->new_symndx);
	    }
	}

      /* Walk the reloc list looking for references to renamed symbols.
	 When we find one, we alter the index in the reloc to point to the new symbol.  */
      for (rel = relocs, relend = relocs + input_section->reloc_count;
	   rel < relend;
	   rel ++)
	{
	  int                          r_type;
	  unsigned long                r_symndx;
	  struct elf_link_hash_entry * h;

	  r_symndx = ELF32_R_SYM (rel->r_info);
	  r_type = ELF32_R_TYPE (rel->r_info);

	  /* Ignore unused relocs.  */
	  if ((r_type >= (int) R_SH_GNU_VTINHERIT
	       && r_type <= (int) R_SH_LABEL)
	      || r_type == (int) R_SH_NONE
	      || r_type < 0
	      || r_type >= R_SH_max)
	    continue;

	  /* Ignore relocs against local symbols.  */
	  if (r_symndx < num_local_syms)
	    continue;

	  BFD_ASSERT (r_symndx < (num_global_syms + num_local_syms));
	  h = sym_hashes[r_symndx - num_local_syms];
	  BFD_ASSERT (h != NULL);

	  while (   h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* If the symbol is defined there is no need to rename it.
	     XXX - is this true ?  */
	  if (   h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak
	      || h->root.type == bfd_link_hash_undefweak)
	    continue;

	  for (ptr = rename_list; ptr; ptr = ptr->next)
	    if (h == ptr->current_hash)
	      {
		BFD_ASSERT (ptr->new_symndx);
		if (SYMBIAN_DEBUG)
		  fprintf (stderr, "convert reloc %lx from using index %ld to using index %ld\n",
			   (unsigned long) rel->r_info,
			   (long) ELF32_R_SYM (rel->r_info), ptr->new_symndx);
		rel->r_info = ELF32_R_INFO (ptr->new_symndx, r_type);
		break;
	      }
	}
    }

  return sh_elf_relocate_section (output_bfd, info, input_bfd, input_section,
				  contents, relocs, local_syms, local_sections);
}

#define TARGET_LITTLE_SYM	bfd_elf32_shl_symbian_vec
#define TARGET_LITTLE_NAME      "elf32-shl-symbian"

#undef  elf_backend_relocate_section
#define elf_backend_relocate_section	sh_symbian_relocate_section
#undef  elf_backend_check_directives
#define elf_backend_check_directives    sh_symbian_process_directives

#include "elf32-target.h"
@


1.17
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d473 2
a474 2
	  new_hash = elf_link_hash_lookup (hash_table, ptr->new_name, FALSE, FALSE, TRUE);

d481 7
a487 22
	      asection *                     psec = bfd_und_section_ptr;
	      Elf_Internal_Sym               new_sym;
	      bfd_vma                        new_value = 0;
	      bfd_boolean                    skip;
	      bfd_boolean                    override;
	      bfd_boolean                    type_change_ok;
	      bfd_boolean                    size_change_ok;

	      new_sym.st_value = 0;
	      new_sym.st_size  = 0;
	      new_sym.st_name  = -1;
	      new_sym.st_info  = ELF_ST_INFO (STB_GLOBAL, STT_FUNC);
	      new_sym.st_other = ELF_ST_VISIBILITY (STV_DEFAULT);
	      new_sym.st_shndx = SHN_UNDEF;
	      new_sym.st_target_internal = 0;

	      if (! _bfd_elf_merge_symbol (input_bfd, info,
					   ptr->new_name, & new_sym,
					   & psec, & new_value, NULL,
					   NULL, & new_hash, & skip,
					   & override, & type_change_ok,
					   & size_change_ok))
d489 6
a494 3
		  _bfd_error_handler (_("%B: Failed to add renamed symbol %s"),
				      input_bfd, ptr->new_name);
		  continue;
d496 1
a496 1
	      /* XXX - should we check psec, skip, override etc ?  */
d498 5
a502 8
	      new_hash->root.type = bfd_link_hash_undefined;

	      /* Allow the symbol to become local if necessary.  */
	      if (new_hash->dynindx == -1)
		new_hash->def_regular = 1;

	      if (SYMBIAN_DEBUG)
		fprintf (stderr, "Created new symbol %s\n", ptr->new_name);
@


1.16
log
@Properly handle common symbol and weak function

bfd/

	PR ld/14591
	* elf-bfd.h (_bfd_elf_merge_symbol): Add an argument to return
	if the old symbol is weak.

	* elf32-sh-symbian.c (sh_symbian_relocate_section): Update
	_bfd_elf_merge_symbol call.

	* elflink.c (_bfd_elf_merge_symbol): Add an argument to return
	if the old symbol is weak.
	(_bfd_elf_add_default_symbol): Update _bfd_elf_merge_symbol
	call.
	(elf_link_add_object_symbols): Don't update symbol type from a
	weak definition.  Update symbol type from a common symbol when
	overriding a weak symbol.

ld/testsuite/

	PR ld/14591
	* ld-elf/comm-data.exp (run_ld_link_tests): Add comm-data3a and
	comm-data3b tests.

	* ld-ifunc/ifunc.exp (run_ld_link_exec_tests): New.

	* ld-elf/comm-data3.sd: New file.
	* ld-elf/comm-data3a.s: Likewise.
	* ld-elf/comm-data3b.s: Likewise.
	* ld-ifunc/ifunc-17a-i386.d: Likewise.
	* ld-ifunc/ifunc-17a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-17a.s: Likewise.
	* ld-ifunc/ifunc-17b-i386.d: Likewise.
	* ld-ifunc/ifunc-17b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-17b.s: Likewise.
	* ld-ifunc/ifunc-common-1.out: Likewise.
	* ld-ifunc/ifunc-common-1a.c: Likewise.
	* ld-ifunc/ifunc-common-1b.c: Likewise.
@
text
@d27 1
a27 1
#define sh_elf_get_flags_from_mach  sh_symbian_elf_get_flags_from_mach 
d132 1
a132 1
	return FALSE;	    
d151 1
a151 1
  
d381 1
a381 1
	  
d412 1
a412 1
  else 
d447 1
a447 1
      
d449 1
a449 1
 
d472 1
a472 1
	  
d571 1
a571 1
      
d615 1
a615 1
  
@


1.15
log
@include/elf/
	* internal.h (elf_internal_sym): Add st_target_internal.
	* arm.h (arm_st_branch_type): New enum.
	(ARM_SYM_BRANCH_TYPE): New macro.

bfd/
	* elf-bfd.h (elf_link_hash_entry): Add target_internal.
	* elf.c (swap_out_syms): Set st_target_internal for each
	Elf_Internal_Sym.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Likewise.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* elflink.c (elf_link_output_extsym): Likewise.
	(bfd_elf_final_link): Likewise.
	(elf_link_add_object_symbols): Copy st_target_internal
	to the hash table if we see a definition.
	(_bfd_elf_copy_link_hash_symbol_type): Copy target_internal.
	* elf32-arm.c (elf32_arm_stub_hash_entry): Replace st_type with
	a branch_type field.
	(a8_erratum_fix, a8_erratum_reloc): Likewise.
	(arm_type_of_stub): Replace actual_st_type with an
	actual_branch_type parameter.
	(arm_build_one_stub): Use branch types rather than st_types to
	determine the type of branch.
	(cortex_a8_erratum_scan): Likewise.
	(elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(allocate_dynrelocs_for_symbol): Likewise.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_final_link_relocate): Replace sym_flags parameter with
	a branch_type parameter.
	(elf32_arm_relocate_section): Update call accordingly.
	(elf32_arm_adjust_dynamic_symbol): Don't check STT_ARM_TFUNC.
	(elf32_arm_output_map_sym): Initialize st_target_internal.
	(elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_symbol_processing): Delete.
	(elf32_arm_swap_symbol_in): Convert STT_ARM_TFUNCs into STT_FUNCs.
	Use st_target_internal to record the branch type.
	(elf32_arm_swap_symbol_out): Use st_target_internal to test for
	Thumb functions.
	(elf32_arm_is_function_type): Delete.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_is_function_type): Likewise.

gas/
	* config/tc-arm.c (arm_adjust_symtab): Set the branch type
	for Thumb symbols.

ld/
	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Check
	eh->target_internal.

opcodes/
	* arm-dis.c (get_sym_code_type): Don't check for STT_ARM_TFUNC.
	Use branch types instead.
	(print_insn): Likewise.
@
text
@d500 1
a500 1
					   & new_hash, & skip,
@


1.15.12.1
log
@bfd/
2012-09-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14591
	* elf-bfd.h (_bfd_elf_merge_symbol): Add an argument to return
	if the old symbol is weak.

	* elf32-sh-symbian.c (sh_symbian_relocate_section): Update
	_bfd_elf_merge_symbol call.

	* elflink.c (_bfd_elf_merge_symbol): Add an argument to return
	if the old symbol is weak.
	(_bfd_elf_add_default_symbol): Update _bfd_elf_merge_symbol
	call.
	(elf_link_add_object_symbols): Don't update symbol type from a
	weak definition.  Update symbol type from a common symbol when
	overriding a weak symbol.

ld/testsuite/
2012-09-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14591
	* ld-elf/comm-data.exp (run_ld_link_tests): Add comm-data3a and
	comm-data3b tests.

	* ld-ifunc/ifunc.exp (run_ld_link_exec_tests): New.

	* ld-elf/comm-data3.sd: New file.
	* ld-elf/comm-data3a.s: Likewise.
	* ld-elf/comm-data3b.s: Likewise.
	* ld-ifunc/ifunc-17a-i386.d: Likewise.
	* ld-ifunc/ifunc-17a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-17a.s: Likewise.
	* ld-ifunc/ifunc-17b-i386.d: Likewise.
	* ld-ifunc/ifunc-17b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-17b.s: Likewise.
	* ld-ifunc/ifunc-common-1.out: Likewise.
	* ld-ifunc/ifunc-common-1a.c: Likewise.
	* ld-ifunc/ifunc-common-1b.c: Likewise.
@
text
@d500 1
a500 1
					   NULL, & new_hash, & skip,
@


1.14
log
@	* elf64-ppc.c (ppc64_elf_process_dot_syms): Renamed from
	ppc64_elf_check_directives.
	* elf32-sh-symbian.c (sh_symbian_process_directives): Combine..
	(sh_symbian_check_directives): ..this
	(bfd_elf32_sh_symbian_process_directives) ..and this function.
@
text
@d495 1
@


1.13
log
@Silence gcc printf warnings
@
text
@a394 1
bfd_boolean bfd_elf32_sh_symbian_process_directives (struct bfd_link_info *info, bfd * abfd);
d396 2
a397 2
bfd_boolean
bfd_elf32_sh_symbian_process_directives (struct bfd_link_info *info, bfd * abfd)
a618 6
static bfd_boolean
sh_symbian_check_directives (bfd *abfd, struct bfd_link_info *info)
{
  return bfd_elf32_sh_symbian_process_directives (info, abfd);
}

d625 1
a625 1
#define elf_backend_check_directives    sh_symbian_check_directives
@


1.12
log
@Switch sources over to use the GPL version 3
@
text
@d2 1
a2 1
   Copyright 2004, 2005, 2006, 2007
d608 2
a609 1
			   (long) rel->r_info, (long) ELF32_R_SYM (rel->r_info), ptr->new_symndx);
@


1.11
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2 1
a2 1
   Copyright 2004, 2005, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 3
a22 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.10
log
@Rename DEBUG to SYMBIAN_DEBUG to avoid conflicts with global DEBUG definition
@
text
@d2 1
a2 1
   Copyright 2004, 2005
d228 1
a228 1
	  if (strncmp (s, DIRECTIVE_IMPORT, strlen (DIRECTIVE_IMPORT)))
d264 3
a266 3
	      /* Check to see if 'AS '... is present.  If se we have an IMPORT AS
		 directive, otherwise we have an IMPORT directive.  */
	      if (strncmp (s, DIRECTIVE_AS, strlen (DIRECTIVE_AS)))
d330 1
a330 1
	  if (strncmp (s, DIRECTIVE_EXPORT, strlen (DIRECTIVE_EXPORT)))
@


1.9
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d29 2
a30 2
//#define DEBUG 1
#define DEBUG 0
d39 1
a39 1
   reached and DEBUG is enabled then the error message 'm'
d48 1
a48 1
          if (DEBUG)						\
d66 1
a66 1
          if (DEBUG)						\
d77 1
a77 1
   is reached and DEBUG is enabled then the error message
d86 1
a86 1
          if (DEBUG)						\
d117 1
a117 1
  if (DEBUG)
d135 1
a135 1
      if (DEBUG)
d142 1
a142 1
      if (DEBUG)
d152 1
a152 1
      if (DEBUG)
d178 1
a178 1
  if (DEBUG)
d189 1
a189 1
  if (DEBUG)
d269 1
a269 1
		  if (DEBUG && name_end_char != '\n')
d279 1
a279 1
		      if (DEBUG)
d303 1
a303 1
		    if (DEBUG)
d314 1
a314 1
		      if (DEBUG)
d358 1
a358 1
		  if (DEBUG)
d376 1
a376 1
	  if (DEBUG)
d467 1
a467 1
	      if (DEBUG)
d514 1
a514 1
	      if (DEBUG)
d524 1
a524 1
		  if (DEBUG)
d542 1
a542 1
		  if (DEBUG)
d554 1
a554 1
	      if (DEBUG)
d604 1
a604 1
		if (DEBUG)
@


1.8
log
@Update the FSF address in the copyright/GPL notice
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.7
log
@2005-02-28  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 757
	* elf-bfd.h (_bfd_elf_merge_symbol): Add a pointer to unsigned
	int.

	* elf32-sh-symbian.c (sh_symbian_relocate_section): Pass NULL
	to _bfd_elf_merge_symbol.

	* elflink.c (_bfd_elf_merge_symbol): Use the pointer to
	unsigned int to return the alignment of the old common symbol
	in the dynamic object.
	(_bfd_elf_add_default_symbol): Pass NULL to
	_bfd_elf_merge_symbol.
	(elf_link_add_object_symbols): Pass &old_alignment to
	_bfd_elf_merge_symbol. Get the alignment of the new common
	symbol in the dynamic object.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.6
log
@	* coffcode.h (coff_print_aux): Warning fix.
	* elf-m10300.c (mn10300_elf_relax_section): Use section->id
	instead of section pointer to identify.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.  Allocate
	the correct size buffer for local sym mangling too.
	(h8300_bfd_link_add_symbols): Likewise.
	* elf32-sh-symbian.c (sh_symbian_process_embedded_commands): Fix
	warning.
	* elf32-sh64.c (shmedia_prepare_reloc): Use %B and %p in error message
	* elf32-xtensa.c (literal_value_hash): Warning fix.
	* versados.c (process_otr): Warning fix.
	(versados_canonicalize_reloc): Likewise.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Warning fix.
	* vms.c (fill_section_ptr): Warning fix.
@
text
@d495 5
a499 2
	      if (! _bfd_elf_merge_symbol (input_bfd, info, ptr->new_name, & new_sym, & psec,
					   & new_value, & new_hash, & skip, & override, & type_change_ok,
@


1.5
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d377 2
a378 2
	    fprintf (stderr, "offset into .directive section: %d\n",
		     directive - (char *) contents);
@


1.4
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d2 1
a2 1
   Copyright 2004
d99 2
a100 2
  bfd_byte *                   current_name;
  bfd_byte *                   new_name;
d112 1
a112 1
		      bfd_byte * current_name, bfd_byte * new_name)
d176 1
a176 1
sh_symbian_import (bfd * abfd ATTRIBUTE_UNUSED, bfd_byte * name)
d187 1
a187 1
sh_symbian_export (bfd * abfd ATTRIBUTE_UNUSED, bfd_byte * name)
d205 2
a206 2
  bfd_byte *s;
  bfd_byte *e;
d210 1
a210 1
  for (s = contents, e = s + sz; s < e;)
d212 1
a212 1
      bfd_byte * directive = s;
d232 3
a234 3
	      bfd_byte * new_name;
	      bfd_byte * new_name_end;
	      bfd_byte   name_end_char;
d285 3
a287 3
		  bfd_byte * current_name;
		  bfd_byte * current_name_end;
		  bfd_byte   current_name_end_char;
d334 3
a336 3
	      bfd_byte * name;
	      bfd_byte * name_end;
	      bfd_byte   name_end_char;
d377 2
a378 1
	    fprintf (stderr, "offset into .directive section: %d\n", directive - contents);
@


1.4.2.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d508 1
a508 1
		new_hash->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
@


1.4.2.2
log
@Merge from mainline.
@
text
@d508 1
a508 1
		new_hash->def_regular = 1;
@


1.3
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d508 1
a508 1
		new_hash->elf_link_hash_flags |= ELF_LINK_HASH_DEF_REGULAR;
@


1.2
log
@Rename sh-symbian-elf toolchain to sh-*-symbianelf
@
text
@d128 2
a129 2
	_bfd_error_handler (_("%s: IMPORT AS directive for %s conceals previous IMPORT AS"),
			    bfd_archive_filename (abfd), current_name);
d380 2
a381 2
	  _bfd_error_handler (_("%s: Unrecognised .directive command: %s"),
			      bfd_archive_filename (abfd), directive);
d498 2
a499 2
		  _bfd_error_handler (_("%s: Failed to add renamed symbol %s"),
				      bfd_archive_filename (input_bfd), ptr->new_name);
@


1.1
log
@Add support for sh-symbian-elf target
@
text
@d24 2
@

