head	1.113;
access;
symbols
	sid-snapshot-20180601:1.113
	sid-snapshot-20180501:1.113
	sid-snapshot-20180401:1.113
	sid-snapshot-20180301:1.113
	sid-snapshot-20180201:1.113
	sid-snapshot-20180101:1.113
	sid-snapshot-20171201:1.113
	sid-snapshot-20171101:1.113
	sid-snapshot-20171001:1.113
	sid-snapshot-20170901:1.113
	sid-snapshot-20170801:1.113
	sid-snapshot-20170701:1.113
	sid-snapshot-20170601:1.113
	sid-snapshot-20170501:1.113
	sid-snapshot-20170401:1.113
	sid-snapshot-20170301:1.113
	sid-snapshot-20170201:1.113
	sid-snapshot-20170101:1.113
	sid-snapshot-20161201:1.113
	sid-snapshot-20161101:1.113
	sid-snapshot-20160901:1.113
	sid-snapshot-20160801:1.113
	sid-snapshot-20160701:1.113
	sid-snapshot-20160601:1.113
	sid-snapshot-20160501:1.113
	sid-snapshot-20160401:1.113
	sid-snapshot-20160301:1.113
	sid-snapshot-20160201:1.113
	sid-snapshot-20160101:1.113
	sid-snapshot-20151201:1.113
	sid-snapshot-20151101:1.113
	sid-snapshot-20151001:1.113
	sid-snapshot-20150901:1.113
	sid-snapshot-20150801:1.113
	sid-snapshot-20150701:1.113
	sid-snapshot-20150601:1.113
	sid-snapshot-20150501:1.113
	sid-snapshot-20150401:1.113
	sid-snapshot-20150301:1.113
	sid-snapshot-20150201:1.113
	sid-snapshot-20150101:1.113
	sid-snapshot-20141201:1.113
	sid-snapshot-20141101:1.113
	sid-snapshot-20141001:1.113
	sid-snapshot-20140901:1.113
	sid-snapshot-20140801:1.113
	sid-snapshot-20140701:1.113
	sid-snapshot-20140601:1.113
	sid-snapshot-20140501:1.113
	sid-snapshot-20140401:1.113
	sid-snapshot-20140301:1.113
	sid-snapshot-20140201:1.113
	sid-snapshot-20140101:1.113
	sid-snapshot-20131201:1.113
	sid-snapshot-20131101:1.113
	sid-snapshot-20131001:1.113
	binutils-2_24-branch:1.113.0.2
	binutils-2_24-branchpoint:1.113
	binutils-2_21_1:1.56.4.1
	sid-snapshot-20130901:1.113
	gdb_7_6_1-2013-08-30-release:1.111
	sid-snapshot-20130801:1.113
	sid-snapshot-20130701:1.112
	sid-snapshot-20130601:1.112
	sid-snapshot-20130501:1.112
	gdb_7_6-2013-04-26-release:1.111
	sid-snapshot-20130401:1.111
	binutils-2_23_2:1.103
	gdb_7_6-branch:1.111.0.2
	gdb_7_6-2013-03-12-branchpoint:1.111
	sid-snapshot-20130301:1.111
	sid-snapshot-20130201:1.110
	sid-snapshot-20130101:1.107
	sid-snapshot-20121201:1.107
	gdb_7_5_1-2012-11-29-release:1.102
	binutils-2_23_1:1.103
	sid-snapshot-20121101:1.104
	binutils-2_23:1.103
	sid-snapshot-20121001:1.104
	sid-snapshot-20120901:1.104
	gdb_7_5-2012-08-17-release:1.102
	sid-snapshot-20120801:1.103
	binutils-2_23-branch:1.103.0.2
	binutils-2_23-branchpoint:1.103
	gdb_7_5-branch:1.102.0.2
	gdb_7_5-2012-07-18-branchpoint:1.102
	sid-snapshot-20120701:1.102
	sid-snapshot-20120601:1.102
	sid-snapshot-20120501:1.102
	binutils-2_22_branch:1.67.0.4
	gdb_7_4_1-2012-04-26-release:1.74
	sid-snapshot-20120401:1.102
	sid-snapshot-20120301:1.102
	sid-snapshot-20120201:1.98
	gdb_7_4-2012-01-24-release:1.74
	sid-snapshot-20120101:1.81
	gdb_7_4-branch:1.74.0.2
	gdb_7_4-2011-12-13-branchpoint:1.74
	sid-snapshot-20111201:1.68
	binutils-2_22:1.67
	sid-snapshot-20111101:1.67
	sid-snapshot-20111001:1.67
	binutils-2_22-branch:1.67.0.2
	binutils-2_22-branchpoint:1.67
	gdb_7_3_1-2011-09-04-release:1.57
	sid-snapshot-20110901:1.66
	sid-snapshot-20110801:1.58
	gdb_7_3-2011-07-26-release:1.57
	sid-snapshot-20110701:1.58
	sid-snapshot-20110601:1.57
	sid-snapshot-20110501:1.57
	gdb_7_3-branch:1.57.0.2
	gdb_7_3-2011-04-01-branchpoint:1.57
	sid-snapshot-20110401:1.57
	sid-snapshot-20110301:1.57
	sid-snapshot-20110201:1.57
	sid-snapshot-20110101:1.56
	binutils-2_21:1.56
	sid-snapshot-20101201:1.56
	binutils-2_21-branch:1.56.0.4
	binutils-2_21-branchpoint:1.56
	sid-snapshot-20101101:1.56
	sid-snapshot-20101001:1.56
	binutils-2_20_1:1.41
	gdb_7_2-2010-09-02-release:1.56
	sid-snapshot-20100901:1.56
	sid-snapshot-20100801:1.56
	gdb_7_2-branch:1.56.0.2
	gdb_7_2-2010-07-07-branchpoint:1.56
	sid-snapshot-20100701:1.56
	sid-snapshot-20100601:1.55
	sid-snapshot-20100501:1.55
	sid-snapshot-20100401:1.55
	gdb_7_1-2010-03-18-release:1.54
	sid-snapshot-20100301:1.54
	gdb_7_1-branch:1.54.0.2
	gdb_7_1-2010-02-18-branchpoint:1.54
	sid-snapshot-20100201:1.52
	sid-snapshot-20100101:1.50
	gdb_7_0_1-2009-12-22-release:1.43
	sid-snapshot-20091201:1.46
	sid-snapshot-20091101:1.46
	binutils-2_20:1.41
	gdb_7_0-2009-10-06-release:1.43
	sid-snapshot-20091001:1.43
	gdb_7_0-branch:1.43.0.2
	gdb_7_0-2009-09-16-branchpoint:1.43
	arc-sim-20090309:1.27
	binutils-arc-20081103-branch:1.29.0.8
	binutils-arc-20081103-branchpoint:1.29
	binutils-2_20-branch:1.41.0.2
	binutils-2_20-branchpoint:1.41
	sid-snapshot-20090901:1.41
	sid-snapshot-20090801:1.40
	msnyder-checkpoint-072509-branch:1.40.0.4
	msnyder-checkpoint-072509-branchpoint:1.40
	sid-snapshot-20090701:1.40
	dje-cgen-play1-branch:1.40.0.2
	dje-cgen-play1-branchpoint:1.40
	sid-snapshot-20090601:1.33
	sid-snapshot-20090501:1.33
	sid-snapshot-20090401:1.32
	arc-20081103-branch:1.29.0.6
	arc-20081103-branchpoint:1.29
	arc-insight_6_8-branch:1.27.0.10
	arc-insight_6_8-branchpoint:1.27
	insight_6_8-branch:1.27.0.8
	insight_6_8-branchpoint:1.27
	sid-snapshot-20090301:1.32
	binutils-2_19_1:1.29
	sid-snapshot-20090201:1.32
	sid-snapshot-20090101:1.31
	reverse-20081226-branch:1.31.0.2
	reverse-20081226-branchpoint:1.31
	sid-snapshot-20081201:1.30
	multiprocess-20081120-branch:1.30.0.2
	multiprocess-20081120-branchpoint:1.30
	sid-snapshot-20081101:1.29
	binutils-2_19:1.29
	sid-snapshot-20081001:1.29
	reverse-20080930-branch:1.29.0.4
	reverse-20080930-branchpoint:1.29
	binutils-2_19-branch:1.29.0.2
	binutils-2_19-branchpoint:1.29
	sid-snapshot-20080901:1.28
	sid-snapshot-20080801:1.28
	reverse-20080717-branch:1.27.0.6
	reverse-20080717-branchpoint:1.27
	sid-snapshot-20080701:1.27
	msnyder-reverse-20080609-branch:1.27.0.4
	msnyder-reverse-20080609-branchpoint:1.27
	drow-reverse-20070409-branch:1.23.0.2
	drow-reverse-20070409-branchpoint:1.23
	sid-snapshot-20080601:1.27
	sid-snapshot-20080501:1.27
	sid-snapshot-20080403:1.27
	sid-snapshot-20080401:1.27
	gdb_6_8-2008-03-27-release:1.27
	sid-snapshot-20080301:1.27
	gdb_6_8-branch:1.27.0.2
	gdb_6_8-2008-02-26-branchpoint:1.27
	sid-snapshot-20080201:1.26
	sid-snapshot-20080101:1.26
	sid-snapshot-20071201:1.26
	sid-snapshot-20071101:1.26
	gdb_6_7_1-2007-10-29-release:1.26
	gdb_6_7-2007-10-10-release:1.26
	sid-snapshot-20071001:1.26
	gdb_6_7-branch:1.26.0.2
	gdb_6_7-2007-09-07-branchpoint:1.26
	binutils-2_18:1.25
	binutils-2_18-branch:1.25.0.2
	binutils-2_18-branchpoint:1.25
	insight_6_6-20070208-release:1.22
	binutils-csl-coldfire-4_1-32:1.20
	binutils-csl-sourcerygxx-4_1-32:1.20
	gdb_6_6-2006-12-18-release:1.22
	binutils-csl-innovasic-fido-3_4_4-33:1.20
	binutils-csl-sourcerygxx-3_4_4-32:1.15
	binutils-csl-coldfire-4_1-30:1.20
	binutils-csl-sourcerygxx-4_1-30:1.20
	binutils-csl-coldfire-4_1-28:1.20
	binutils-csl-sourcerygxx-4_1-29:1.20
	binutils-csl-sourcerygxx-4_1-28:1.20
	gdb_6_6-branch:1.22.0.2
	gdb_6_6-2006-11-15-branchpoint:1.22
	binutils-csl-arm-2006q3-27:1.20
	binutils-csl-sourcerygxx-4_1-27:1.20
	binutils-csl-arm-2006q3-26:1.20
	binutils-csl-sourcerygxx-4_1-26:1.20
	binutils-csl-sourcerygxx-4_1-25:1.20
	binutils-csl-sourcerygxx-4_1-24:1.20
	binutils-csl-sourcerygxx-4_1-23:1.20
	insight_6_5-20061003-release:1.20
	gdb-csl-symbian-6_4_50_20060226-12:1.20
	binutils-csl-sourcerygxx-4_1-21:1.20
	binutils-csl-arm-2006q3-21:1.20
	binutils-csl-sourcerygxx-4_1-22:1.20
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.20
	binutils-csl-sourcerygxx-4_1-20:1.20
	binutils-csl-arm-2006q3-19:1.20
	binutils-csl-sourcerygxx-4_1-19:1.20
	binutils-csl-sourcerygxx-4_1-18:1.20
	binutils-csl-renesas-4_1-9:1.20
	gdb-csl-sourcerygxx-3_4_4-25:1.19
	binutils-csl-sourcerygxx-3_4_4-25:1.15
	nickrob-async-20060828-mergepoint:1.22
	gdb-csl-symbian-6_4_50_20060226-11:1.20
	binutils-csl-renesas-4_1-8:1.20
	binutils-csl-renesas-4_1-7:1.20
	binutils-csl-renesas-4_1-6:1.20
	gdb-csl-sourcerygxx-4_1-17:1.20
	binutils-csl-sourcerygxx-4_1-17:1.20
	gdb-csl-20060226-branch-local-2:1.20
	gdb-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-15:1.20
	gdb-csl-sourcerygxx-4_1-13:1.20
	binutils-csl-sourcerygxx-4_1-13:1.20
	binutils-2_17:1.20
	gdb-csl-sourcerygxx-4_1-12:1.20
	binutils-csl-sourcerygxx-4_1-12:1.20
	gdb-csl-sourcerygxx-3_4_4-21:1.20
	binutils-csl-sourcerygxx-3_4_4-21:1.20
	gdb_6_5-20060621-release:1.20
	binutils-csl-wrs-linux-3_4_4-24:1.15
	binutils-csl-wrs-linux-3_4_4-23:1.15
	gdb-csl-sourcerygxx-4_1-9:1.20
	binutils-csl-sourcerygxx-4_1-9:1.20
	gdb-csl-sourcerygxx-4_1-8:1.20
	binutils-csl-sourcerygxx-4_1-8:1.20
	gdb-csl-sourcerygxx-4_1-7:1.20
	binutils-csl-sourcerygxx-4_1-7:1.20
	gdb-csl-arm-2006q1-6:1.20
	binutils-csl-arm-2006q1-6:1.20
	gdb-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-wrs-linux-3_4_4-22:1.15
	gdb-csl-symbian-6_4_50_20060226-10:1.20
	gdb-csl-symbian-6_4_50_20060226-9:1.20
	gdb-csl-symbian-6_4_50_20060226-8:1.20
	gdb-csl-coldfire-4_1-11:1.20
	binutils-csl-coldfire-4_1-11:1.20
	gdb-csl-sourcerygxx-3_4_4-19:1.20
	binutils-csl-sourcerygxx-3_4_4-19:1.20
	gdb-csl-coldfire-4_1-10:1.20
	gdb_6_5-branch:1.20.0.20
	gdb_6_5-2006-05-14-branchpoint:1.20
	binutils-csl-coldfire-4_1-10:1.20
	gdb-csl-sourcerygxx-4_1-5:1.20
	binutils-csl-sourcerygxx-4_1-5:1.20
	nickrob-async-20060513-branch:1.20.0.18
	nickrob-async-20060513-branchpoint:1.20
	gdb-csl-sourcerygxx-4_1-4:1.20
	binutils-csl-sourcerygxx-4_1-4:1.20
	msnyder-reverse-20060502-branch:1.20.0.16
	msnyder-reverse-20060502-branchpoint:1.20
	binutils-csl-wrs-linux-3_4_4-21:1.15
	gdb-csl-morpho-4_1-4:1.20
	binutils-csl-morpho-4_1-4:1.20
	gdb-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-wrs-linux-3_4_4-20:1.15
	readline_5_1-import-branch:1.20.0.14
	readline_5_1-import-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.20
	binutils-2_17-branch:1.20.0.12
	binutils-2_17-branchpoint:1.20
	gdb-csl-symbian-20060226-branch:1.20.0.10
	gdb-csl-symbian-20060226-branchpoint:1.20
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.20
	msnyder-reverse-20060331-branch:1.20.0.8
	msnyder-reverse-20060331-branchpoint:1.20
	binutils-csl-2_17-branch:1.20.0.6
	binutils-csl-2_17-branchpoint:1.20
	gdb-csl-available-20060303-branch:1.20.0.4
	gdb-csl-available-20060303-branchpoint:1.20
	gdb-csl-20060226-branch:1.20.0.2
	gdb-csl-20060226-branchpoint:1.20
	gdb_6_4-20051202-release:1.19
	msnyder-fork-checkpoint-branch:1.19.0.10
	msnyder-fork-checkpoint-branchpoint:1.19
	gdb-csl-gxxpro-6_3-branch:1.19.0.8
	gdb-csl-gxxpro-6_3-branchpoint:1.19
	gdb_6_4-branch:1.19.0.6
	gdb_6_4-2005-11-01-branchpoint:1.19
	gdb-csl-arm-20051020-branch:1.19.0.4
	gdb-csl-arm-20051020-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.15.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.15
	binutils-2_16_1:1.15
	msnyder-tracepoint-checkpoint-branch:1.19.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.19
	gdb-csl-arm-20050325-2005-q1b:1.15
	binutils-csl-arm-2005q1b:1.15
	binutils-2_16:1.15
	gdb-csl-arm-20050325-2005-q1a:1.15
	binutils-csl-arm-2005q1a:1.15
	csl-arm-20050325-branch:1.15.0.6
	csl-arm-20050325-branchpoint:1.15
	binutils-csl-arm-2005q1-branch:1.15.0.4
	binutils-csl-arm-2005q1-branchpoint:1.15
	binutils-2_16-branch:1.15.0.2
	binutils-2_16-branchpoint:1.15
	csl-arm-2004-q3d:1.12
	gdb_6_3-20041109-release:1.12
	gdb_6_3-branch:1.12.0.2
	gdb_6_3-20041019-branchpoint:1.12
	csl-arm-2004-q3:1.11
	drow_intercu-merge-20040921:1.11
	drow_intercu-merge-20040915:1.11
	jimb-gdb_6_2-e500-branch:1.10.0.6
	jimb-gdb_6_2-e500-branchpoint:1.10
	gdb_6_2-20040730-release:1.10
	gdb_6_2-branch:1.10.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.10
	gdb_6_1_1-20040616-release:1.6
	binutils-2_15:1.6.8.1
	binutils-2_15-branchpoint:1.6
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.7
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.2
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.6.0.14
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.12
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.10
	drow_intercu-20040221-branchpoint:1.6
	binutils-2_15-branch:1.6.0.8
	cagney_bfdfile-20040213-branch:1.6.0.6
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.4
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	csl-arm-2003-q4:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-branch:1.6.0.2
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.4
	kettenis_sparc-20030918-branch:1.4.0.42
	kettenis_sparc-20030918-branchpoint:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.40
	cagney_x86i386-20030821-branch:1.4.0.38
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.36
	gdb_6_0-2003-06-23-branchpoint:1.4
	jimb-ppc64-linux-20030613-branch:1.4.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.4
	binutils-2_14:1.4
	cagney_convert-20030606-branch:1.4.0.32
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.30
	cagney_writestrings-20030508-branchpoint:1.4
	jimb-ppc64-linux-20030528-branch:1.4.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.26
	cagney_fileio-20030521-branchpoint:1.4
	kettenis_i386newframe-20030517-mergepoint:1.4
	jimb-ppc64-linux-20030509-branch:1.4.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.4
	kettenis_i386newframe-20030504-mergepoint:1.4
	carlton_dictionary-20030430-merge:1.4
	binutils-2_14-branch:1.4.0.22
	binutils-2_14-branchpoint:1.4
	kettenis_i386newframe-20030419-branch:1.4.0.20
	kettenis_i386newframe-20030419-branchpoint:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	kettenis_i386newframe-20030406-branch:1.4.0.18
	kettenis_i386newframe-20030406-branchpoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.16
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.14
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.12
	cagney_lazyid-20030317-branchpoint:1.4
	kettenis-i386newframe-20030316-mergepoint:1.4
	offbyone-20030313-branch:1.4.0.10
	offbyone-20030313-branchpoint:1.4
	kettenis-i386newframe-20030308-branch:1.4.0.8
	kettenis-i386newframe-20030308-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	carlton_dictionary-branch:1.3.0.2
	carlton_dictionary-20021115-merge:1.3
	binutils_latest_snapshot:1.113;
locks; strict;
comment	@ * @;


1.113
date	2013.07.18.11.40.37;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2013.04.17.14.16.01;	author nickc;	state Exp;
branches;
next	1.111;

1.111
date	2013.02.04.14.48.20;	author gingold;	state Exp;
branches;
next	1.110;

1.110
date	2013.01.31.09.55.41;	author gingold;	state Exp;
branches;
next	1.109;

1.109
date	2013.01.26.02.08.01;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2013.01.10.20.03.54;	author hjl;	state Exp;
branches;
next	1.107;

1.107
date	2012.11.14.11.03.27;	author gingold;	state Exp;
branches;
next	1.106;

1.106
date	2012.11.14.10.29.46;	author gingold;	state Exp;
branches;
next	1.105;

1.105
date	2012.11.06.06.44.01;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2012.08.20.14.32.31;	author tromey;	state Exp;
branches;
next	1.103;

1.103
date	2012.07.24.21.06.58;	author ccoutant;	state Exp;
branches;
next	1.102;

1.102
date	2012.02.23.16.29.55;	author iains;	state Exp;
branches;
next	1.101;

1.101
date	2012.02.10.11.24.44;	author iains;	state Exp;
branches;
next	1.100;

1.100
date	2012.02.10.11.07.33;	author iains;	state Exp;
branches;
next	1.99;

1.99
date	2012.02.02.11.55.42;	author gingold;	state Exp;
branches;
next	1.98;

1.98
date	2012.01.13.12.59.29;	author iains;	state Exp;
branches;
next	1.97;

1.97
date	2012.01.13.12.08.23;	author iains;	state Exp;
branches;
next	1.96;

1.96
date	2012.01.12.14.03.07;	author iains;	state Exp;
branches;
next	1.95;

1.95
date	2012.01.11.15.24.10;	author iains;	state Exp;
branches;
next	1.94;

1.94
date	2012.01.11.15.06.36;	author iains;	state Exp;
branches;
next	1.93;

1.93
date	2012.01.10.11.59.28;	author gingold;	state Exp;
branches;
next	1.92;

1.92
date	2012.01.09.10.47.45;	author iains;	state Exp;
branches;
next	1.91;

1.91
date	2012.01.04.13.31.27;	author gingold;	state Exp;
branches;
next	1.90;

1.90
date	2012.01.04.13.22.21;	author gingold;	state Exp;
branches;
next	1.89;

1.89
date	2012.01.04.10.37.35;	author gingold;	state Exp;
branches;
next	1.88;

1.88
date	2012.01.04.10.25.14;	author gingold;	state Exp;
branches;
next	1.87;

1.87
date	2012.01.04.10.14.25;	author gingold;	state Exp;
branches;
next	1.86;

1.86
date	2012.01.04.09.58.54;	author gingold;	state Exp;
branches;
next	1.85;

1.85
date	2012.01.04.08.44.04;	author gingold;	state Exp;
branches;
next	1.84;

1.84
date	2012.01.03.13.18.47;	author iains;	state Exp;
branches;
next	1.83;

1.83
date	2012.01.03.12.03.10;	author iains;	state Exp;
branches;
next	1.82;

1.82
date	2012.01.03.10.54.00;	author iains;	state Exp;
branches;
next	1.81;

1.81
date	2011.12.19.15.42.36;	author iains;	state Exp;
branches;
next	1.80;

1.80
date	2011.12.16.13.39.03;	author gingold;	state Exp;
branches;
next	1.79;

1.79
date	2011.12.15.14.04.52;	author gingold;	state Exp;
branches;
next	1.78;

1.78
date	2011.12.15.11.01.14;	author gingold;	state Exp;
branches;
next	1.77;

1.77
date	2011.12.15.10.56.47;	author gingold;	state Exp;
branches;
next	1.76;

1.76
date	2011.12.14.10.30.07;	author gingold;	state Exp;
branches;
next	1.75;

1.75
date	2011.12.13.14.02.19;	author gingold;	state Exp;
branches;
next	1.74;

1.74
date	2011.12.13.09.13.15;	author gingold;	state Exp;
branches;
next	1.73;

1.73
date	2011.12.12.13.45.47;	author gingold;	state Exp;
branches;
next	1.72;

1.72
date	2011.12.07.10.09.22;	author gingold;	state Exp;
branches;
next	1.71;

1.71
date	2011.12.05.14.42.31;	author gingold;	state Exp;
branches;
next	1.70;

1.70
date	2011.12.05.14.10.11;	author gingold;	state Exp;
branches;
next	1.69;

1.69
date	2011.12.05.13.48.54;	author gingold;	state Exp;
branches;
next	1.68;

1.68
date	2011.11.22.10.47.50;	author gingold;	state Exp;
branches;
next	1.67;

1.67
date	2011.09.21.10.10.11;	author gingold;	state Exp;
branches;
next	1.66;

1.66
date	2011.08.18.09.28.42;	author gingold;	state Exp;
branches;
next	1.65;

1.65
date	2011.08.17.10.17.39;	author gingold;	state Exp;
branches;
next	1.64;

1.64
date	2011.08.08.14.53.30;	author gingold;	state Exp;
branches;
next	1.63;

1.63
date	2011.08.08.10.56.31;	author gingold;	state Exp;
branches;
next	1.62;

1.62
date	2011.08.08.10.21.02;	author gingold;	state Exp;
branches;
next	1.61;

1.61
date	2011.08.08.08.59.32;	author gingold;	state Exp;
branches;
next	1.60;

1.60
date	2011.08.08.07.39.44;	author gingold;	state Exp;
branches;
next	1.59;

1.59
date	2011.08.03.08.12.07;	author gingold;	state Exp;
branches;
next	1.58;

1.58
date	2011.06.28.07.45.53;	author gingold;	state Exp;
branches;
next	1.57;

1.57
date	2011.01.14.12.35.56;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches
	1.56.4.1;
next	1.55;

1.55
date	2010.03.24.15.41.59;	author hjl;	state Exp;
branches;
next	1.54;

1.54
date	2010.02.09.13.39.22;	author gingold;	state Exp;
branches;
next	1.53;

1.53
date	2010.02.08.09.13.47;	author gingold;	state Exp;
branches;
next	1.52;

1.52
date	2010.01.26.13.42.26;	author gingold;	state Exp;
branches;
next	1.51;

1.51
date	2010.01.11.15.39.41;	author gingold;	state Exp;
branches;
next	1.50;

1.50
date	2009.12.15.09.50.15;	author gingold;	state Exp;
branches;
next	1.49;

1.49
date	2009.12.15.09.28.28;	author gingold;	state Exp;
branches;
next	1.48;

1.48
date	2009.12.11.13.42.04;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2009.12.03.14.14.03;	author gingold;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.09.15.33.39;	author gingold;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.09.15.14.56;	author gingold;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.09.08.18.17;	author gingold;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.16.13.30.31;	author gingold;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.09.14.58.12;	author gingold;	state Exp;
branches;
next	1.41;

1.41
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2009.06.25.12.39.06;	author gingold;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.22.08.14.34;	author gingold;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.19.09.23.54;	author gingold;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.19.09.12.41;	author gingold;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.12.09.15.46;	author gingold;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.09.07.37.19;	author gingold;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.05.09.19.44;	author gingold;	state Exp;
branches;
next	1.33;

1.33
date	2009.04.16.23.06.58;	author rsandifo;	state Exp;
branches;
next	1.32;

1.32
date	2009.01.27.16.37.10;	author schwab;	state Exp;
branches;
next	1.31;

1.31
date	2008.12.23.11.32.45;	author gingold;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.06.13.03.43;	author gingold;	state Exp;
branches;
next	1.29;

1.29
date	2008.09.05.08.07.54;	author gingold;	state Exp;
branches;
next	1.28;

1.28
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2008.02.20.17.42.36;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2007.08.31.14.55.24;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.15.08.33.53;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.01.03.45.58;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.12.23.10.19.40;	author brobecke;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.23.17.44.55;	author fnf;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.04.15.53.35;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.05.04.07.19.31;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.11.08.23.02;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.20.14.59.07;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2005.02.16.04.45.23;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.31.23.13.28;	author bje;	state Exp;
branches;
next	1.12;

1.12
date	2004.10.08.14.54.01;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.24.04.46.24;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2004.05.17.16.40.00;	author bwilson;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.30.14.23.39;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.15.12.23.10;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2003.11.04.11.30.54;	author amodra;	state Exp;
branches
	1.6.2.1
	1.6.8.1
	1.6.10.1
	1.6.14.1;
next	1.5;

1.5
date	2003.10.16.04.11.07;	author cagney;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2002.11.12.15.44.24;	author amodra;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.11.11.23.19.03;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.06.13.26.27;	author nickc;	state Exp;
branches;
next	;

1.56.4.1
date	2011.02.01.12.25.34;	author amodra;	state Exp;
branches;
next	;

1.6.2.1
date	2003.12.14.20.26.49;	author drow;	state Exp;
branches;
next	;

1.6.8.1
date	2004.03.15.13.17.38;	author amodra;	state Exp;
branches;
next	;

1.6.10.1
date	2004.03.27.17.37.38;	author drow;	state Exp;
branches;
next	1.6.10.2;

1.6.10.2
date	2004.09.16.17.00.34;	author drow;	state Exp;
branches;
next	;

1.6.14.1
date	2004.03.21.23.57.28;	author cagney;	state Exp;
branches;
next	;

1.3.2.1
date	2002.11.15.19.18.29;	author carlton;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2002.12.23.19.37.55;	author carlton;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.11.11.23.50.27;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.113
log
@	* mach-o.c (mach_o_section_name_xlat dw): Add entry for
	.debug_gdb_scripts
@
text
@/* Mach-O support for BFD.
   Copyright 1999-2013 Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "mach-o.h"
#include "bfd.h"
#include "libbfd.h"
#include "libiberty.h"
#include "aout/stab_gnu.h"
#include "mach-o/reloc.h"
#include "mach-o/external.h"
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#define bfd_mach_o_object_p bfd_mach_o_gen_object_p
#define bfd_mach_o_core_p bfd_mach_o_gen_core_p
#define bfd_mach_o_mkobject bfd_mach_o_gen_mkobject

#define FILE_ALIGN(off, algn) \
  (((off) + ((file_ptr) 1 << (algn)) - 1) & ((file_ptr) -1 << (algn)))

unsigned int
bfd_mach_o_version (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = NULL;

  BFD_ASSERT (bfd_mach_o_valid (abfd));
  mdata = bfd_mach_o_get_data (abfd);

  return mdata->header.version;
}

bfd_boolean
bfd_mach_o_valid (bfd *abfd)
{
  if (abfd == NULL || abfd->xvec == NULL)
    return FALSE;

  if (abfd->xvec->flavour != bfd_target_mach_o_flavour)
    return FALSE;

  if (bfd_mach_o_get_data (abfd) == NULL)
    return FALSE;
  return TRUE;
}

static INLINE bfd_boolean
mach_o_wide_p (bfd_mach_o_header *header)
{
  switch (header->version)
    {
    case 1:
      return FALSE;
    case 2:
      return TRUE;
    default:
      BFD_FAIL ();
      return FALSE;
    }
}

static INLINE bfd_boolean
bfd_mach_o_wide_p (bfd *abfd)
{
  return mach_o_wide_p (&bfd_mach_o_get_data (abfd)->header);
}

/* Tables to translate well known Mach-O segment/section names to bfd
   names.  Use of canonical names (such as .text or .debug_frame) is required
   by gdb.  */

/* __TEXT Segment.  */
static const mach_o_section_name_xlat text_section_names_xlat[] =
  {
    {	".text",				"__text",
	SEC_CODE | SEC_LOAD,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_PURE_INSTRUCTIONS,	0},
    {	".const",				"__const",
	SEC_READONLY | SEC_DATA | SEC_LOAD,	BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NONE,			0},
    {	".static_const",			"__static_const",
	SEC_READONLY | SEC_DATA | SEC_LOAD,	BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NONE,			0},
    {	".cstring",				"__cstring",
	SEC_READONLY | SEC_DATA | SEC_LOAD | SEC_MERGE | SEC_STRINGS,
						BFD_MACH_O_S_CSTRING_LITERALS,
	BFD_MACH_O_S_ATTR_NONE,			0},
    {	".literal4",				"__literal4",
	SEC_READONLY | SEC_DATA | SEC_LOAD,	BFD_MACH_O_S_4BYTE_LITERALS,
	BFD_MACH_O_S_ATTR_NONE,			2},
    {	".literal8",				"__literal8",
	SEC_READONLY | SEC_DATA | SEC_LOAD,	BFD_MACH_O_S_8BYTE_LITERALS,
	BFD_MACH_O_S_ATTR_NONE,			3},
    {	".literal16",				"__literal16",
	SEC_READONLY | SEC_DATA | SEC_LOAD,	BFD_MACH_O_S_16BYTE_LITERALS,
	BFD_MACH_O_S_ATTR_NONE,			4},
    {	".constructor",				"__constructor",
	SEC_CODE | SEC_LOAD,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NONE,			0},
    {	".destructor",				"__destructor",
	SEC_CODE | SEC_LOAD,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NONE,			0},
    {	".eh_frame",				"__eh_frame",
	SEC_READONLY | SEC_DATA | SEC_LOAD,	BFD_MACH_O_S_COALESCED,
	BFD_MACH_O_S_ATTR_LIVE_SUPPORT
	| BFD_MACH_O_S_ATTR_STRIP_STATIC_SYMS
	| BFD_MACH_O_S_ATTR_NO_TOC,		2},
    { NULL, NULL, 0, 0, 0, 0}
  };

/* __DATA Segment.  */
static const mach_o_section_name_xlat data_section_names_xlat[] =
  {
    {	".data",			"__data",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NONE,		0},
    {	".bss",				"__bss",
	SEC_NO_FLAGS,			BFD_MACH_O_S_ZEROFILL,
	BFD_MACH_O_S_ATTR_NONE,		0},
    {	".const_data",			"__const",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NONE,		0},
    {	".static_data",			"__static_data",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NONE,		0},
    {	".mod_init_func",		"__mod_init_func",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_MOD_INIT_FUNC_POINTERS,
	BFD_MACH_O_S_ATTR_NONE,		2},
    {	".mod_term_func",		"__mod_term_func",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_MOD_FINI_FUNC_POINTERS,
	BFD_MACH_O_S_ATTR_NONE,		2},
    {	".dyld",			"__dyld",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NONE,		0},
    {	".cfstring",			"__cfstring",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NONE,		2},
    { NULL, NULL, 0, 0, 0, 0}
  };

/* __DWARF Segment.  */
static const mach_o_section_name_xlat dwarf_section_names_xlat[] =
  {
    {	".debug_frame",			"__debug_frame",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_info",			"__debug_info",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_abbrev",		"__debug_abbrev",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_aranges",		"__debug_aranges",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_macinfo",		"__debug_macinfo",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_line",			"__debug_line",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_loc",			"__debug_loc",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_pubnames",		"__debug_pubnames",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_pubtypes",		"__debug_pubtypes",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_str",			"__debug_str",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_ranges",		"__debug_ranges",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_macro",			"__debug_macro",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    {	".debug_gdb_scripts",		"__debug_gdb_scri",
	SEC_DEBUGGING,			BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_DEBUG,	0},
    { NULL, NULL, 0, 0, 0, 0}
  };

/* __OBJC Segment.  */
static const mach_o_section_name_xlat objc_section_names_xlat[] =
  {
    {	".objc_class",			"__class",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_meta_class",		"__meta_class",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_cat_cls_meth",		"__cat_cls_meth",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_cat_inst_meth",		"__cat_inst_meth",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_protocol",		"__protocol",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_string_object",		"__string_object",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_cls_meth",		"__cls_meth",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_inst_meth",		"__inst_meth",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_cls_refs",		"__cls_refs",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_LITERAL_POINTERS,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_message_refs",		"__message_refs",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_LITERAL_POINTERS,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_symbols",		"__symbols",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_category",		"__category",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_class_vars",		"__class_vars",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_instance_vars",		"__instance_vars",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_module_info",		"__module_info",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_selector_strs",		"__selector_strs",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_CSTRING_LITERALS,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_image_info",		"__image_info",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc_selector_fixup",		"__sel_fixup",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    /* Objc V1 */
    {	".objc1_class_ext",		"__class_ext",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc1_property_list",		"__property",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    {	".objc1_protocol_ext",		"__protocol_ext",
	SEC_DATA | SEC_LOAD,		BFD_MACH_O_S_REGULAR,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, 0},
    { NULL, NULL, 0, 0, 0, 0}
  };

static const mach_o_segment_name_xlat segsec_names_xlat[] =
  {
    { "__TEXT", text_section_names_xlat },
    { "__DATA", data_section_names_xlat },
    { "__DWARF", dwarf_section_names_xlat },
    { "__OBJC", objc_section_names_xlat },
    { NULL, NULL }
  };

static const char dsym_subdir[] = ".dSYM/Contents/Resources/DWARF";

/* For both cases bfd-name => mach-o name and vice versa, the specific target
   is checked before the generic.  This allows a target (e.g. ppc for cstring)
   to override the generic definition with a more specific one.  */

/* Fetch the translation from a Mach-O section designation (segment, section)
   as a bfd short name, if one exists.  Otherwise return NULL.

   Allow the segment and section names to be unterminated 16 byte arrays.  */

const mach_o_section_name_xlat *
bfd_mach_o_section_data_for_mach_sect (bfd *abfd, const char *segname,
				       const char *sectname)
{
  const struct mach_o_segment_name_xlat *seg;
  const mach_o_section_name_xlat *sec;
  bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);

  /* First try any target-specific translations defined...  */
  if (bed->segsec_names_xlat)
    for (seg = bed->segsec_names_xlat; seg->segname; seg++)
      if (strncmp (seg->segname, segname, BFD_MACH_O_SEGNAME_SIZE) == 0)
	for (sec = seg->sections; sec->mach_o_name; sec++)
	  if (strncmp (sec->mach_o_name, sectname,
		       BFD_MACH_O_SECTNAME_SIZE) == 0)
	    return sec;

  /* ... and then the Mach-O generic ones.  */
  for (seg = segsec_names_xlat; seg->segname; seg++)
    if (strncmp (seg->segname, segname, BFD_MACH_O_SEGNAME_SIZE) == 0)
      for (sec = seg->sections; sec->mach_o_name; sec++)
        if (strncmp (sec->mach_o_name, sectname,
		     BFD_MACH_O_SECTNAME_SIZE) == 0)
          return sec;

  return NULL;
}

/* If the bfd_name for this section is a 'canonical' form for which we
   know the Mach-O data, return the segment name and the data for the
   Mach-O equivalent.  Otherwise return NULL.  */

const mach_o_section_name_xlat *
bfd_mach_o_section_data_for_bfd_name (bfd *abfd, const char *bfd_name,
				      const char **segname)
{
  const struct mach_o_segment_name_xlat *seg;
  const mach_o_section_name_xlat *sec;
  bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);
  *segname = NULL;

  if (bfd_name[0] != '.')
    return NULL;

  /* First try any target-specific translations defined...  */
  if (bed->segsec_names_xlat)
    for (seg = bed->segsec_names_xlat; seg->segname; seg++)
      for (sec = seg->sections; sec->bfd_name; sec++)
	if (strcmp (bfd_name, sec->bfd_name) == 0)
	  {
	    *segname = seg->segname;
	    return sec;
	  }

  /* ... and then the Mach-O generic ones.  */
  for (seg = segsec_names_xlat; seg->segname; seg++)
    for (sec = seg->sections; sec->bfd_name; sec++)
      if (strcmp (bfd_name, sec->bfd_name) == 0)
	{
	  *segname = seg->segname;
	  return sec;
	}

  return NULL;
}

/* Convert Mach-O section name to BFD.

   Try to use standard/canonical names, for which we have tables including
   default flag settings - which are returned.  Otherwise forge a new name
   in the form "<segmentname>.<sectionname>" this will be prefixed with
   LC_SEGMENT. if the segment name does not begin with an underscore.

   SEGNAME and SECTNAME are 16 byte arrays (they do not need to be NUL-
   terminated if the name length is exactly 16 bytes - but must be if the name
   length is less than 16 characters).  */

void
bfd_mach_o_convert_section_name_to_bfd (bfd *abfd, const char *segname,
					const char *secname, const char **name,
					flagword *flags)
{
  const mach_o_section_name_xlat *xlat;
  char *res;
  unsigned int len;
  const char *pfx = "";

  *name = NULL;
  *flags = SEC_NO_FLAGS;

  /* First search for a canonical name...
     xlat will be non-null if there is an entry for segname, secname.  */
  xlat = bfd_mach_o_section_data_for_mach_sect (abfd, segname, secname);
  if (xlat)
    {
      len = strlen (xlat->bfd_name);
      res = bfd_alloc (abfd, len+1);
      if (res == NULL)
	return;
      memcpy (res, xlat->bfd_name, len+1);
      *name = res;
      *flags = xlat->bfd_flags;
      return;
    }

  /* ... else we make up a bfd name from the segment concatenated with the
     section.  */

  len = 16 + 1 + 16 + 1;

  /* Put "LC_SEGMENT." prefix if the segment name is weird (ie doesn't start
     with an underscore.  */
  if (segname[0] != '_')
    {
      static const char seg_pfx[] = "LC_SEGMENT.";

      pfx = seg_pfx;
      len += sizeof (seg_pfx) - 1;
    }

  res = bfd_alloc (abfd, len);
  if (res == NULL)
    return;
  snprintf (res, len, "%s%.16s.%.16s", pfx, segname, secname);
  *name = res;
}

/* Convert a bfd section name to a Mach-O segment + section name.

   If the name is a canonical one for which we have a Darwin match
   return the translation table - which contains defaults for flags,
   type, attribute and default alignment data.

   Otherwise, expand the bfd_name (assumed to be in the form
   "[LC_SEGMENT.]<segmentname>.<sectionname>") and return NULL.  */

static const mach_o_section_name_xlat *
bfd_mach_o_convert_section_name_to_mach_o (bfd *abfd ATTRIBUTE_UNUSED,
                                           asection *sect,
                                           bfd_mach_o_section *section)
{
  const mach_o_section_name_xlat *xlat;
  const char *name = bfd_get_section_name (abfd, sect);
  const char *segname;
  const char *dot;
  unsigned int len;
  unsigned int seglen;
  unsigned int seclen;

  memset (section->segname, 0, BFD_MACH_O_SEGNAME_SIZE + 1);
  memset (section->sectname, 0, BFD_MACH_O_SECTNAME_SIZE + 1);

  /* See if is a canonical name ... */
  xlat = bfd_mach_o_section_data_for_bfd_name (abfd, name, &segname);
  if (xlat)
    {
      strcpy (section->segname, segname);
      strcpy (section->sectname, xlat->mach_o_name);
      return xlat;
    }

  /* .. else we convert our constructed one back to Mach-O.
     Strip LC_SEGMENT. prefix, if present.  */
  if (strncmp (name, "LC_SEGMENT.", 11) == 0)
    name += 11;

  /* Find a dot.  */
  dot = strchr (name, '.');
  len = strlen (name);

  /* Try to split name into segment and section names.  */
  if (dot && dot != name)
    {
      seglen = dot - name;
      seclen = len - (dot + 1 - name);

      if (seglen < 16 && seclen < 16)
        {
          memcpy (section->segname, name, seglen);
          section->segname[seglen] = 0;
          memcpy (section->sectname, dot + 1, seclen);
          section->sectname[seclen] = 0;
          return NULL;
        }
    }

  /* The segment and section names are both missing - don't make them
     into dots.  */
  if (dot && dot == name)
    return NULL;

  /* Just duplicate the name into both segment and section.  */
  if (len > 16)
    len = 16;
  memcpy (section->segname, name, len);
  section->segname[len] = 0;
  memcpy (section->sectname, name, len);
  section->sectname[len] = 0;
  return NULL;
}

/* Return the size of an entry for section SEC.
   Must be called only for symbol pointer section and symbol stubs
   sections.  */

unsigned int
bfd_mach_o_section_get_entry_size (bfd *abfd, bfd_mach_o_section *sec)
{
  switch (sec->flags & BFD_MACH_O_SECTION_TYPE_MASK)
    {
    case BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS:
    case BFD_MACH_O_S_LAZY_SYMBOL_POINTERS:
      return bfd_mach_o_wide_p (abfd) ? 8 : 4;
    case BFD_MACH_O_S_SYMBOL_STUBS:
      return sec->reserved2;
    default:
      BFD_FAIL ();
      return 0;
    }
}

/* Return the number of indirect symbols for a section.
   Must be called only for symbol pointer section and symbol stubs
   sections.  */

unsigned int
bfd_mach_o_section_get_nbr_indirect (bfd *abfd, bfd_mach_o_section *sec)
{
  unsigned int elsz;

  elsz = bfd_mach_o_section_get_entry_size (abfd, sec);
  if (elsz == 0)
    return 0;
  else
    return sec->size / elsz;
}


/* Copy any private info we understand from the input symbol
   to the output symbol.  */

bfd_boolean
bfd_mach_o_bfd_copy_private_symbol_data (bfd *ibfd ATTRIBUTE_UNUSED,
					 asymbol *isymbol,
					 bfd *obfd ATTRIBUTE_UNUSED,
					 asymbol *osymbol)
{
  bfd_mach_o_asymbol *os, *is;
  os = (bfd_mach_o_asymbol *)osymbol;
  is = (bfd_mach_o_asymbol *)isymbol;
  os->n_type = is->n_type;
  os->n_sect = is->n_sect;
  os->n_desc = is->n_desc;
  os->symbol.udata.i = is->symbol.udata.i;
  return TRUE;
}

/* Copy any private info we understand from the input section
   to the output section.  */

bfd_boolean
bfd_mach_o_bfd_copy_private_section_data (bfd *ibfd ATTRIBUTE_UNUSED,
					  asection *isection,
					  bfd *obfd ATTRIBUTE_UNUSED,
					  asection *osection)
{
  if (osection->used_by_bfd == NULL)
    osection->used_by_bfd = isection->used_by_bfd;
  else
    if (isection->used_by_bfd != NULL)
      memcpy (osection->used_by_bfd, isection->used_by_bfd,
	      sizeof (bfd_mach_o_section));

  if (osection->used_by_bfd != NULL)
    ((bfd_mach_o_section *)osection->used_by_bfd)->bfdsection = osection;

  return TRUE;
}

/* Copy any private info we understand from the input bfd
   to the output bfd.  */

bfd_boolean
bfd_mach_o_bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  if (bfd_get_flavour (ibfd) != bfd_target_mach_o_flavour
      || bfd_get_flavour (obfd) != bfd_target_mach_o_flavour)
    return TRUE;

  BFD_ASSERT (bfd_mach_o_valid (ibfd));
  BFD_ASSERT (bfd_mach_o_valid (obfd));

  /* FIXME: copy commands.  */

  return TRUE;
}

/* This allows us to set up to 32 bits of flags (unless we invent some
   fiendish scheme to subdivide).  For now, we'll just set the file flags
   without error checking - just overwrite.  */

bfd_boolean
bfd_mach_o_bfd_set_private_flags (bfd *abfd, flagword flags)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);

  if (!mdata)
    return FALSE;

  mdata->header.flags = flags;
  return TRUE;
}

/* Count the total number of symbols.  */

static long
bfd_mach_o_count_symbols (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);

  if (mdata->symtab == NULL)
    return 0;
  return mdata->symtab->nsyms;
}

long
bfd_mach_o_get_symtab_upper_bound (bfd *abfd)
{
  long nsyms = bfd_mach_o_count_symbols (abfd);

  return ((nsyms + 1) * sizeof (asymbol *));
}

long
bfd_mach_o_canonicalize_symtab (bfd *abfd, asymbol **alocation)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  long nsyms = bfd_mach_o_count_symbols (abfd);
  bfd_mach_o_symtab_command *sym = mdata->symtab;
  unsigned long j;

  if (nsyms < 0)
    return nsyms;

  if (nsyms == 0)
    {
      /* Do not try to read symbols if there are none.  */
      alocation[0] = NULL;
      return 0;
    }

  if (!bfd_mach_o_read_symtab_symbols (abfd))
    {
      (*_bfd_error_handler)
        (_("bfd_mach_o_canonicalize_symtab: unable to load symbols"));
      return 0;
    }

  BFD_ASSERT (sym->symbols != NULL);

  for (j = 0; j < sym->nsyms; j++)
    alocation[j] = &sym->symbols[j].symbol;

  alocation[j] = NULL;

  return nsyms;
}

/* Create synthetic symbols for indirect symbols.  */

long
bfd_mach_o_get_synthetic_symtab (bfd *abfd,
                                 long symcount ATTRIBUTE_UNUSED,
                                 asymbol **syms ATTRIBUTE_UNUSED,
                                 long dynsymcount ATTRIBUTE_UNUSED,
                                 asymbol **dynsyms ATTRIBUTE_UNUSED,
                                 asymbol **ret)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  bfd_mach_o_dysymtab_command *dysymtab = mdata->dysymtab;
  bfd_mach_o_symtab_command *symtab = mdata->symtab;
  asymbol *s;
  unsigned long count, i, j, n;
  size_t size;
  char *names;
  char *nul_name;

  *ret = NULL;

  /* Stop now if no symbols or no indirect symbols.  */
  if (dysymtab == NULL || symtab == NULL || symtab->symbols == NULL)
    return 0;

  if (dysymtab->nindirectsyms == 0)
    return 0;

  /* We need to allocate a bfd symbol for every indirect symbol and to
     allocate the memory for its name.  */
  count = dysymtab->nindirectsyms;
  size = count * sizeof (asymbol) + 1;

  for (j = 0; j < count; j++)
    {
      unsigned int isym = dysymtab->indirect_syms[j];

      /* Some indirect symbols are anonymous.  */
      if (isym < symtab->nsyms && symtab->symbols[isym].symbol.name)
        size += strlen (symtab->symbols[isym].symbol.name) + sizeof ("$stub");
    }

  s = *ret = (asymbol *) bfd_malloc (size);
  if (s == NULL)
    return -1;
  names = (char *) (s + count);
  nul_name = names;
  *names++ = 0;

  n = 0;
  for (i = 0; i < mdata->nsects; i++)
    {
      bfd_mach_o_section *sec = mdata->sections[i];
      unsigned int first, last;
      bfd_vma addr;
      bfd_vma entry_size;

      switch (sec->flags & BFD_MACH_O_SECTION_TYPE_MASK)
        {
        case BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS:
        case BFD_MACH_O_S_LAZY_SYMBOL_POINTERS:
        case BFD_MACH_O_S_SYMBOL_STUBS:
          /* Only these sections have indirect symbols.  */
          first = sec->reserved1;
          last = first + bfd_mach_o_section_get_nbr_indirect (abfd, sec);
          addr = sec->addr;
          entry_size = bfd_mach_o_section_get_entry_size (abfd, sec);
          for (j = first; j < last; j++)
            {
              unsigned int isym = dysymtab->indirect_syms[j];

              s->flags = BSF_GLOBAL | BSF_SYNTHETIC;
              s->section = sec->bfdsection;
              s->value = addr - sec->addr;
              s->udata.p = NULL;

              if (isym < symtab->nsyms
                  && symtab->symbols[isym].symbol.name)
                {
                  const char *sym = symtab->symbols[isym].symbol.name;
                  size_t len;

                  s->name = names;
                  len = strlen (sym);
                  memcpy (names, sym, len);
                  names += len;
                  memcpy (names, "$stub", sizeof ("$stub"));
                  names += sizeof ("$stub");
                }
              else
                s->name = nul_name;

              addr += entry_size;
              s++;
              n++;
            }
          break;
        default:
          break;
        }
    }

  return n;
}

void
bfd_mach_o_get_symbol_info (bfd *abfd ATTRIBUTE_UNUSED,
			    asymbol *symbol,
			    symbol_info *ret)
{
  bfd_symbol_info (symbol, ret);
}

void
bfd_mach_o_print_symbol (bfd *abfd,
			 void * afile,
			 asymbol *symbol,
			 bfd_print_symbol_type how)
{
  FILE *file = (FILE *) afile;
  const char *name;
  bfd_mach_o_asymbol *asym = (bfd_mach_o_asymbol *)symbol;

  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    default:
      bfd_print_symbol_vandf (abfd, (void *) file, symbol);
      if (asym->n_type & BFD_MACH_O_N_STAB)
	name = bfd_get_stab_name (asym->n_type);
      else
	switch (asym->n_type & BFD_MACH_O_N_TYPE)
	  {
	  case BFD_MACH_O_N_UNDF:
            if (symbol->value == 0)
              name = "UND";
            else
              name = "COM";
	    break;
	  case BFD_MACH_O_N_ABS:
	    name = "ABS";
	    break;
	  case BFD_MACH_O_N_INDR:
	    name = "INDR";
	    break;
	  case BFD_MACH_O_N_PBUD:
	    name = "PBUD";
	    break;
	  case BFD_MACH_O_N_SECT:
	    name = "SECT";
	    break;
	  default:
	    name = "???";
	    break;
	  }
      if (name == NULL)
	name = "";
      fprintf (file, " %02x %-6s %02x %04x",
               asym->n_type, name, asym->n_sect, asym->n_desc);
      if ((asym->n_type & BFD_MACH_O_N_STAB) == 0
	  && (asym->n_type & BFD_MACH_O_N_TYPE) == BFD_MACH_O_N_SECT)
	fprintf (file, " [%s]", symbol->section->name);
      fprintf (file, " %s", symbol->name);
    }
}

static void
bfd_mach_o_convert_architecture (bfd_mach_o_cpu_type mtype,
				 bfd_mach_o_cpu_subtype msubtype,
				 enum bfd_architecture *type,
				 unsigned long *subtype)
{
  *subtype = bfd_arch_unknown;

  switch (mtype)
    {
    case BFD_MACH_O_CPU_TYPE_VAX:
      *type = bfd_arch_vax;
      break;
    case BFD_MACH_O_CPU_TYPE_MC680x0:
      *type = bfd_arch_m68k;
      break;
    case BFD_MACH_O_CPU_TYPE_I386:
      *type = bfd_arch_i386;
      *subtype = bfd_mach_i386_i386;
      break;
    case BFD_MACH_O_CPU_TYPE_X86_64:
      *type = bfd_arch_i386;
      *subtype = bfd_mach_x86_64;
      break;
    case BFD_MACH_O_CPU_TYPE_MIPS:
      *type = bfd_arch_mips;
      break;
    case BFD_MACH_O_CPU_TYPE_MC98000:
      *type = bfd_arch_m98k;
      break;
    case BFD_MACH_O_CPU_TYPE_HPPA:
      *type = bfd_arch_hppa;
      break;
    case BFD_MACH_O_CPU_TYPE_ARM:
      *type = bfd_arch_arm;
      switch (msubtype)
        {
        case BFD_MACH_O_CPU_SUBTYPE_ARM_V4T:
          *subtype = bfd_mach_arm_4T;
          break;
        case BFD_MACH_O_CPU_SUBTYPE_ARM_V6:
          *subtype = bfd_mach_arm_4T;	/* Best fit ?  */
          break;
        case BFD_MACH_O_CPU_SUBTYPE_ARM_V5TEJ:
          *subtype = bfd_mach_arm_5TE;
          break;
        case BFD_MACH_O_CPU_SUBTYPE_ARM_XSCALE:
          *subtype = bfd_mach_arm_XScale;
          break;
        case BFD_MACH_O_CPU_SUBTYPE_ARM_V7:
          *subtype = bfd_mach_arm_5TE;	/* Best fit ?  */
          break;
        case BFD_MACH_O_CPU_SUBTYPE_ARM_ALL:
        default:
          break;
        }
      break;
    case BFD_MACH_O_CPU_TYPE_MC88000:
      *type = bfd_arch_m88k;
      break;
    case BFD_MACH_O_CPU_TYPE_SPARC:
      *type = bfd_arch_sparc;
      *subtype = bfd_mach_sparc;
      break;
    case BFD_MACH_O_CPU_TYPE_I860:
      *type = bfd_arch_i860;
      break;
    case BFD_MACH_O_CPU_TYPE_ALPHA:
      *type = bfd_arch_alpha;
      break;
    case BFD_MACH_O_CPU_TYPE_POWERPC:
      *type = bfd_arch_powerpc;
      *subtype = bfd_mach_ppc;
      break;
    case BFD_MACH_O_CPU_TYPE_POWERPC_64:
      *type = bfd_arch_powerpc;
      *subtype = bfd_mach_ppc64;
      break;
    default:
      *type = bfd_arch_unknown;
      break;
    }
}

static bfd_boolean
bfd_mach_o_write_header (bfd *abfd, bfd_mach_o_header *header)
{
  struct mach_o_header_external raw;
  unsigned int size;

  size = mach_o_wide_p (header) ?
    BFD_MACH_O_HEADER_64_SIZE : BFD_MACH_O_HEADER_SIZE;

  bfd_h_put_32 (abfd, header->magic, raw.magic);
  bfd_h_put_32 (abfd, header->cputype, raw.cputype);
  bfd_h_put_32 (abfd, header->cpusubtype, raw.cpusubtype);
  bfd_h_put_32 (abfd, header->filetype, raw.filetype);
  bfd_h_put_32 (abfd, header->ncmds, raw.ncmds);
  bfd_h_put_32 (abfd, header->sizeofcmds, raw.sizeofcmds);
  bfd_h_put_32 (abfd, header->flags, raw.flags);

  if (mach_o_wide_p (header))
    bfd_h_put_32 (abfd, header->reserved, raw.reserved);

  if (bfd_seek (abfd, 0, SEEK_SET) != 0
      || bfd_bwrite (&raw, size, abfd) != size)
    return FALSE;

  return TRUE;
}

static int
bfd_mach_o_write_thread (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_thread_command *cmd = &command->command.thread;
  unsigned int i;
  struct mach_o_thread_command_external raw;
  unsigned int offset;

  BFD_ASSERT ((command->type == BFD_MACH_O_LC_THREAD)
	      || (command->type == BFD_MACH_O_LC_UNIXTHREAD));

  offset = 8;
  for (i = 0; i < cmd->nflavours; i++)
    {
      BFD_ASSERT ((cmd->flavours[i].size % 4) == 0);
      BFD_ASSERT (cmd->flavours[i].offset ==
                  (command->offset + offset + BFD_MACH_O_LC_SIZE));

      bfd_h_put_32 (abfd, cmd->flavours[i].flavour, raw.flavour);
      bfd_h_put_32 (abfd, (cmd->flavours[i].size / 4), raw.count);

      if (bfd_seek (abfd, command->offset + offset, SEEK_SET) != 0
          || bfd_bwrite (&raw, sizeof (raw), abfd) != sizeof (raw))
	return -1;

      offset += cmd->flavours[i].size + sizeof (raw);
    }

  return 0;
}

long
bfd_mach_o_get_reloc_upper_bound (bfd *abfd ATTRIBUTE_UNUSED,
                                  asection *asect)
{
  return (asect->reloc_count + 1) * sizeof (arelent *);
}

/* In addition to the need to byte-swap the symbol number, the bit positions
   of the fields in the relocation information vary per target endian-ness.  */

static void
bfd_mach_o_swap_in_non_scattered_reloc (bfd *abfd, bfd_mach_o_reloc_info *rel,
				       unsigned char *fields)
{
  unsigned char info = fields[3];

  if (bfd_big_endian (abfd))
    {
      rel->r_value = (fields[0] << 16) | (fields[1] << 8) | fields[2];
      rel->r_type = (info >> BFD_MACH_O_BE_TYPE_SHIFT) & BFD_MACH_O_TYPE_MASK;
      rel->r_pcrel = (info & BFD_MACH_O_BE_PCREL) ? 1 : 0;
      rel->r_length = (info >> BFD_MACH_O_BE_LENGTH_SHIFT)
		      & BFD_MACH_O_LENGTH_MASK;
      rel->r_extern = (info & BFD_MACH_O_BE_EXTERN) ? 1 : 0;
    }
  else
    {
      rel->r_value = (fields[2] << 16) | (fields[1] << 8) | fields[0];
      rel->r_type = (info >> BFD_MACH_O_LE_TYPE_SHIFT) & BFD_MACH_O_TYPE_MASK;
      rel->r_pcrel = (info & BFD_MACH_O_LE_PCREL) ? 1 : 0;
      rel->r_length = (info >> BFD_MACH_O_LE_LENGTH_SHIFT)
		      & BFD_MACH_O_LENGTH_MASK;
      rel->r_extern = (info & BFD_MACH_O_LE_EXTERN) ? 1 : 0;
    }
}

static int
bfd_mach_o_canonicalize_one_reloc (bfd *abfd,
                                   struct mach_o_reloc_info_external *raw,
                                   arelent *res, asymbol **syms)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);
  bfd_mach_o_reloc_info reloc;
  bfd_vma addr;
  asymbol **sym;

  addr = bfd_get_32 (abfd, raw->r_address);
  res->sym_ptr_ptr = NULL;
  res->addend = 0;

  if (addr & BFD_MACH_O_SR_SCATTERED)
    {
      unsigned int j;
      bfd_vma symnum = bfd_get_32 (abfd, raw->r_symbolnum);

      /* Scattered relocation, can't be extern. */
      reloc.r_scattered = 1;
      reloc.r_extern = 0;

      /*   Extract section and offset from r_value (symnum).  */
      reloc.r_value = symnum;
      /* FIXME: This breaks when a symbol in a reloc exactly follows the
	 end of the data for the section (e.g. in a calculation of section
	 data length).  At present, the symbol will end up associated with
	 the following section or, if it falls within alignment padding, as
	 null - which will assert later.  */
      for (j = 0; j < mdata->nsects; j++)
        {
          bfd_mach_o_section *sect = mdata->sections[j];
          if (symnum >= sect->addr && symnum < sect->addr + sect->size)
            {
              res->sym_ptr_ptr = sect->bfdsection->symbol_ptr_ptr;
              res->addend = symnum - sect->addr;
              break;
            }
        }

      /* Extract the info and address fields from r_address.  */
      reloc.r_type = BFD_MACH_O_GET_SR_TYPE (addr);
      reloc.r_length = BFD_MACH_O_GET_SR_LENGTH (addr);
      reloc.r_pcrel = addr & BFD_MACH_O_SR_PCREL;
      reloc.r_address = BFD_MACH_O_GET_SR_TYPE (addr);
      res->address = BFD_MACH_O_GET_SR_ADDRESS (addr);
    }
  else
    {
      unsigned int num;

      /* Non-scattered relocation.  */
      reloc.r_scattered = 0;

      /* The value and info fields have to be extracted dependent on target
         endian-ness.  */
      bfd_mach_o_swap_in_non_scattered_reloc (abfd, &reloc, raw->r_symbolnum);
      num = reloc.r_value;

      if (reloc.r_extern)
	{
	  /* An external symbol number.  */
	  sym = syms + num;
	}
      else if (num == 0x00ffffff)
	{
	  /* The 'symnum' in a non-scattered PAIR is 0x00ffffff.  But as this
	     is generic code, we don't know wether this is really a PAIR.
	     This value is almost certainly not a valid section number, hence
	     this specific case to avoid an assertion failure.
	     Target specific swap_reloc_in routine should adjust that.  */
	  sym = bfd_abs_section_ptr->symbol_ptr_ptr;
	}
      else
        {
	  /* A section number.  */
          BFD_ASSERT (num != 0);
          BFD_ASSERT (num <= mdata->nsects);

          sym = mdata->sections[num - 1]->bfdsection->symbol_ptr_ptr;
          /* For a symbol defined in section S, the addend (stored in the
             binary) contains the address of the section.  To comply with
             bfd convention, subtract the section address.
             Use the address from the header, so that the user can modify
             the vma of the section.  */
          res->addend = -mdata->sections[num - 1]->addr;
        }
      /* Note: Pairs for PPC LO/HI/HA are not scattered, but contain the offset
	 in the lower 16bits of the address value.  So we have to find the
	 'symbol' from the preceding reloc.  We do this even though the
	 section symbol is probably not needed here, because NULL symbol
	 values cause an assert in generic BFD code.  This must be done in
	 the PPC swap_reloc_in routine.  */
      res->sym_ptr_ptr = sym;

      /* The 'address' is just r_address.
         ??? maybe this should be masked with  0xffffff for safety.  */
      res->address = addr;
      reloc.r_address = addr;
    }

  /* We have set up a reloc with all the information present, so the swapper
     can modify address, value and addend fields, if necessary, to convey
     information in the generic BFD reloc that is mach-o specific.  */

  if (!(*bed->_bfd_mach_o_swap_reloc_in)(res, &reloc))
    return -1;
  return 0;
}

static int
bfd_mach_o_canonicalize_relocs (bfd *abfd, unsigned long filepos,
                                unsigned long count,
                                arelent *res, asymbol **syms)
{
  unsigned long i;
  struct mach_o_reloc_info_external *native_relocs;
  bfd_size_type native_size;

  /* Allocate and read relocs.  */
  native_size = count * BFD_MACH_O_RELENT_SIZE;
  native_relocs =
    (struct mach_o_reloc_info_external *) bfd_malloc (native_size);
  if (native_relocs == NULL)
    return -1;

  if (bfd_seek (abfd, filepos, SEEK_SET) != 0
      || bfd_bread (native_relocs, native_size, abfd) != native_size)
    goto err;

  for (i = 0; i < count; i++)
    {
      if (bfd_mach_o_canonicalize_one_reloc (abfd, &native_relocs[i],
                                             &res[i], syms) < 0)
        goto err;
    }
  free (native_relocs);
  return i;
 err:
  free (native_relocs);
  return -1;
}

long
bfd_mach_o_canonicalize_reloc (bfd *abfd, asection *asect,
                               arelent **rels, asymbol **syms)
{
  bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);
  unsigned long i;
  arelent *res;

  if (asect->reloc_count == 0)
    return 0;

  /* No need to go further if we don't know how to read relocs.  */
  if (bed->_bfd_mach_o_swap_reloc_in == NULL)
    return 0;

  if (asect->relocation == NULL)
    {
      res = bfd_malloc (asect->reloc_count * sizeof (arelent));
      if (res == NULL)
        return -1;

      if (bfd_mach_o_canonicalize_relocs (abfd, asect->rel_filepos,
                                          asect->reloc_count, res, syms) < 0)
        {
          free (res);
          return -1;
        }
      asect->relocation = res;
    }

  res = asect->relocation;
  for (i = 0; i < asect->reloc_count; i++)
    rels[i] = &res[i];
  rels[i] = NULL;

  return i;
}

long
bfd_mach_o_get_dynamic_reloc_upper_bound (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);

  if (mdata->dysymtab == NULL)
    return 1;
  return (mdata->dysymtab->nextrel + mdata->dysymtab->nlocrel + 1)
    * sizeof (arelent *);
}

long
bfd_mach_o_canonicalize_dynamic_reloc (bfd *abfd, arelent **rels,
                                       struct bfd_symbol **syms)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  bfd_mach_o_dysymtab_command *dysymtab = mdata->dysymtab;
  bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);
  unsigned long i;
  arelent *res;

  if (dysymtab == NULL)
    return 0;
  if (dysymtab->nextrel == 0 && dysymtab->nlocrel == 0)
    return 0;

  /* No need to go further if we don't know how to read relocs.  */
  if (bed->_bfd_mach_o_swap_reloc_in == NULL)
    return 0;

  if (mdata->dyn_reloc_cache == NULL)
    {
      res = bfd_malloc ((dysymtab->nextrel + dysymtab->nlocrel)
                        * sizeof (arelent));
      if (res == NULL)
        return -1;

      if (bfd_mach_o_canonicalize_relocs (abfd, dysymtab->extreloff,
                                          dysymtab->nextrel, res, syms) < 0)
        {
          free (res);
          return -1;
        }

      if (bfd_mach_o_canonicalize_relocs (abfd, dysymtab->locreloff,
                                          dysymtab->nlocrel,
                                          res + dysymtab->nextrel, syms) < 0)
        {
          free (res);
          return -1;
        }

      mdata->dyn_reloc_cache = res;
    }

  res = mdata->dyn_reloc_cache;
  for (i = 0; i < dysymtab->nextrel + dysymtab->nlocrel; i++)
    rels[i] = &res[i];
  rels[i] = NULL;
  return i;
}

/* In addition to the need to byte-swap the symbol number, the bit positions
   of the fields in the relocation information vary per target endian-ness.  */

static void
bfd_mach_o_swap_out_non_scattered_reloc (bfd *abfd, unsigned char *fields,
				       bfd_mach_o_reloc_info *rel)
{
  unsigned char info = 0;

  BFD_ASSERT (rel->r_type <= 15);
  BFD_ASSERT (rel->r_length <= 3);

  if (bfd_big_endian (abfd))
    {
      fields[0] = (rel->r_value >> 16) & 0xff;
      fields[1] = (rel->r_value >> 8) & 0xff;
      fields[2] = rel->r_value & 0xff;
      info |= rel->r_type << BFD_MACH_O_BE_TYPE_SHIFT;
      info |= rel->r_pcrel ? BFD_MACH_O_BE_PCREL : 0;
      info |= rel->r_length << BFD_MACH_O_BE_LENGTH_SHIFT;
      info |= rel->r_extern ? BFD_MACH_O_BE_EXTERN : 0;
    }
  else
    {
      fields[2] = (rel->r_value >> 16) & 0xff;
      fields[1] = (rel->r_value >> 8) & 0xff;
      fields[0] = rel->r_value & 0xff;
      info |= rel->r_type << BFD_MACH_O_LE_TYPE_SHIFT;
      info |= rel->r_pcrel ? BFD_MACH_O_LE_PCREL : 0;
      info |= rel->r_length << BFD_MACH_O_LE_LENGTH_SHIFT;
      info |= rel->r_extern ? BFD_MACH_O_LE_EXTERN : 0;
    }
  fields[3] = info;
}

static bfd_boolean
bfd_mach_o_write_relocs (bfd *abfd, bfd_mach_o_section *section)
{
  unsigned int i;
  arelent **entries;
  asection *sec;
  bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);

  sec = section->bfdsection;
  if (sec->reloc_count == 0)
    return TRUE;

  if (bed->_bfd_mach_o_swap_reloc_out == NULL)
    return TRUE;

  if (bfd_seek (abfd, section->reloff, SEEK_SET) != 0)
    return FALSE;

  /* Convert and write.  */
  entries = section->bfdsection->orelocation;
  for (i = 0; i < section->nreloc; i++)
    {
      arelent *rel = entries[i];
      struct mach_o_reloc_info_external raw;
      bfd_mach_o_reloc_info info, *pinfo = &info;

      /* Convert relocation to an intermediate representation.  */
      if (!(*bed->_bfd_mach_o_swap_reloc_out) (rel, pinfo))
        return FALSE;

      /* Lower the relocation info.  */
      if (pinfo->r_scattered)
        {
          unsigned long v;

          v = BFD_MACH_O_SR_SCATTERED
            | (pinfo->r_pcrel ? BFD_MACH_O_SR_PCREL : 0)
            | BFD_MACH_O_SET_SR_LENGTH(pinfo->r_length)
            | BFD_MACH_O_SET_SR_TYPE(pinfo->r_type)
            | BFD_MACH_O_SET_SR_ADDRESS(pinfo->r_address);
          /* Note: scattered relocs have field in reverse order...  */
          bfd_put_32 (abfd, v, raw.r_address);
          bfd_put_32 (abfd, pinfo->r_value, raw.r_symbolnum);
        }
      else
        {
          bfd_put_32 (abfd, pinfo->r_address, raw.r_address);
          bfd_mach_o_swap_out_non_scattered_reloc (abfd, raw.r_symbolnum,
						   pinfo);
        }

      if (bfd_bwrite (&raw, BFD_MACH_O_RELENT_SIZE, abfd)
          != BFD_MACH_O_RELENT_SIZE)
        return FALSE;
    }
  return TRUE;
}

static int
bfd_mach_o_write_section_32 (bfd *abfd, bfd_mach_o_section *section)
{
  struct mach_o_section_32_external raw;

  memcpy (raw.sectname, section->sectname, 16);
  memcpy (raw.segname, section->segname, 16);
  bfd_h_put_32 (abfd, section->addr, raw.addr);
  bfd_h_put_32 (abfd, section->size, raw.size);
  bfd_h_put_32 (abfd, section->offset, raw.offset);
  bfd_h_put_32 (abfd, section->align, raw.align);
  bfd_h_put_32 (abfd, section->reloff, raw.reloff);
  bfd_h_put_32 (abfd, section->nreloc, raw.nreloc);
  bfd_h_put_32 (abfd, section->flags, raw.flags);
  bfd_h_put_32 (abfd, section->reserved1, raw.reserved1);
  bfd_h_put_32 (abfd, section->reserved2, raw.reserved2);

  if (bfd_bwrite (&raw, BFD_MACH_O_SECTION_SIZE, abfd)
      != BFD_MACH_O_SECTION_SIZE)
    return -1;

  return 0;
}

static int
bfd_mach_o_write_section_64 (bfd *abfd, bfd_mach_o_section *section)
{
  struct mach_o_section_64_external raw;

  memcpy (raw.sectname, section->sectname, 16);
  memcpy (raw.segname, section->segname, 16);
  bfd_h_put_64 (abfd, section->addr, raw.addr);
  bfd_h_put_64 (abfd, section->size, raw.size);
  bfd_h_put_32 (abfd, section->offset, raw.offset);
  bfd_h_put_32 (abfd, section->align, raw.align);
  bfd_h_put_32 (abfd, section->reloff, raw.reloff);
  bfd_h_put_32 (abfd, section->nreloc, raw.nreloc);
  bfd_h_put_32 (abfd, section->flags, raw.flags);
  bfd_h_put_32 (abfd, section->reserved1, raw.reserved1);
  bfd_h_put_32 (abfd, section->reserved2, raw.reserved2);
  bfd_h_put_32 (abfd, section->reserved3, raw.reserved3);

  if (bfd_bwrite (&raw, BFD_MACH_O_SECTION_64_SIZE, abfd)
      != BFD_MACH_O_SECTION_64_SIZE)
    return -1;

  return 0;
}

static int
bfd_mach_o_write_segment_32 (bfd *abfd, bfd_mach_o_load_command *command)
{
  struct mach_o_segment_command_32_external raw;
  bfd_mach_o_segment_command *seg = &command->command.segment;
  bfd_mach_o_section *sec;

  BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT);

  for (sec = seg->sect_head; sec != NULL; sec = sec->next)
    if (!bfd_mach_o_write_relocs (abfd, sec))
      return -1;

  memcpy (raw.segname, seg->segname, 16);
  bfd_h_put_32 (abfd, seg->vmaddr, raw.vmaddr);
  bfd_h_put_32 (abfd, seg->vmsize, raw.vmsize);
  bfd_h_put_32 (abfd, seg->fileoff, raw.fileoff);
  bfd_h_put_32 (abfd, seg->filesize, raw.filesize);
  bfd_h_put_32 (abfd, seg->maxprot, raw.maxprot);
  bfd_h_put_32 (abfd, seg->initprot, raw.initprot);
  bfd_h_put_32 (abfd, seg->nsects, raw.nsects);
  bfd_h_put_32 (abfd, seg->flags, raw.flags);

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bwrite (&raw, sizeof (raw), abfd) != sizeof (raw))
    return -1;

  for (sec = seg->sect_head; sec != NULL; sec = sec->next)
    if (bfd_mach_o_write_section_32 (abfd, sec))
      return -1;

  return 0;
}

static int
bfd_mach_o_write_segment_64 (bfd *abfd, bfd_mach_o_load_command *command)
{
  struct mach_o_segment_command_64_external raw;
  bfd_mach_o_segment_command *seg = &command->command.segment;
  bfd_mach_o_section *sec;

  BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT_64);

  for (sec = seg->sect_head; sec != NULL; sec = sec->next)
    if (!bfd_mach_o_write_relocs (abfd, sec))
      return -1;

  memcpy (raw.segname, seg->segname, 16);
  bfd_h_put_64 (abfd, seg->vmaddr, raw.vmaddr);
  bfd_h_put_64 (abfd, seg->vmsize, raw.vmsize);
  bfd_h_put_64 (abfd, seg->fileoff, raw.fileoff);
  bfd_h_put_64 (abfd, seg->filesize, raw.filesize);
  bfd_h_put_32 (abfd, seg->maxprot, raw.maxprot);
  bfd_h_put_32 (abfd, seg->initprot, raw.initprot);
  bfd_h_put_32 (abfd, seg->nsects, raw.nsects);
  bfd_h_put_32 (abfd, seg->flags, raw.flags);

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bwrite (&raw, sizeof (raw), abfd) != sizeof (raw))
    return -1;

  for (sec = seg->sect_head; sec != NULL; sec = sec->next)
    if (bfd_mach_o_write_section_64 (abfd, sec))
      return -1;

  return 0;
}

static bfd_boolean
bfd_mach_o_write_symtab (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  bfd_mach_o_symtab_command *sym = &command->command.symtab;
  unsigned long i;
  unsigned int wide = bfd_mach_o_wide_p (abfd);
  unsigned int symlen = wide ? BFD_MACH_O_NLIST_64_SIZE : BFD_MACH_O_NLIST_SIZE;
  struct bfd_strtab_hash *strtab;
  asymbol **symbols = bfd_get_outsymbols (abfd);

  BFD_ASSERT (command->type == BFD_MACH_O_LC_SYMTAB);

  /* Write the symbols first.  */
  mdata->filelen = FILE_ALIGN(mdata->filelen, wide ? 3 : 2);
  sym->symoff = mdata->filelen;
  if (bfd_seek (abfd, sym->symoff, SEEK_SET) != 0)
    return FALSE;

  sym->nsyms = bfd_get_symcount (abfd);
  mdata->filelen += sym->nsyms * symlen;

  strtab = _bfd_stringtab_init ();
  if (strtab == NULL)
    return FALSE;

  if (sym->nsyms > 0)
    /* Although we don't strictly need to do this, for compatibility with
       Darwin system tools, actually output an empty string for the index
       0 entry.  */
    _bfd_stringtab_add (strtab, "", TRUE, FALSE);

  for (i = 0; i < sym->nsyms; i++)
    {
      bfd_size_type str_index;
      bfd_mach_o_asymbol *s = (bfd_mach_o_asymbol *)symbols[i];

      if (s->symbol.name == 0 || s->symbol.name[0] == '\0')
	/* An index of 0 always means the empty string.  */
        str_index = 0;
      else
        {
          str_index = _bfd_stringtab_add (strtab, s->symbol.name, TRUE, FALSE);

          if (str_index == (bfd_size_type) -1)
            goto err;
        }

      if (wide)
        {
          struct mach_o_nlist_64_external raw;

          bfd_h_put_32 (abfd, str_index, raw.n_strx);
          bfd_h_put_8 (abfd, s->n_type, raw.n_type);
          bfd_h_put_8 (abfd, s->n_sect, raw.n_sect);
          bfd_h_put_16 (abfd, s->n_desc, raw.n_desc);
          bfd_h_put_64 (abfd, s->symbol.section->vma + s->symbol.value,
                        raw.n_value);

          if (bfd_bwrite (&raw, sizeof (raw), abfd) != sizeof (raw))
            goto err;
        }
      else
        {
          struct mach_o_nlist_external raw;

          bfd_h_put_32 (abfd, str_index, raw.n_strx);
          bfd_h_put_8 (abfd, s->n_type, raw.n_type);
          bfd_h_put_8 (abfd, s->n_sect, raw.n_sect);
          bfd_h_put_16 (abfd, s->n_desc, raw.n_desc);
          bfd_h_put_32 (abfd, s->symbol.section->vma + s->symbol.value,
                        raw.n_value);

          if (bfd_bwrite (&raw, sizeof (raw), abfd) != sizeof (raw))
            goto err;
        }
    }
  sym->strsize = _bfd_stringtab_size (strtab);
  sym->stroff = mdata->filelen;
  mdata->filelen += sym->strsize;

  if (_bfd_stringtab_emit (abfd, strtab) != TRUE)
    goto err;
  _bfd_stringtab_free (strtab);

  /* The command.  */
  {
    struct mach_o_symtab_command_external raw;

    bfd_h_put_32 (abfd, sym->symoff, raw.symoff);
    bfd_h_put_32 (abfd, sym->nsyms, raw.nsyms);
    bfd_h_put_32 (abfd, sym->stroff, raw.stroff);
    bfd_h_put_32 (abfd, sym->strsize, raw.strsize);

    if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
        || bfd_bwrite (&raw, sizeof (raw), abfd) != sizeof (raw))
      return FALSE;
  }

  return TRUE;

 err:
  _bfd_stringtab_free (strtab);
  return FALSE;
}

/* Write a dysymtab command.
   TODO: Possibly coalesce writes of smaller objects.  */

static bfd_boolean
bfd_mach_o_write_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_dysymtab_command *cmd = &command->command.dysymtab;

  BFD_ASSERT (command->type == BFD_MACH_O_LC_DYSYMTAB);

  if (cmd->nmodtab != 0)
    {
      unsigned int i;

      if (bfd_seek (abfd, cmd->modtaboff, SEEK_SET) != 0)
	return FALSE;

      for (i = 0; i < cmd->nmodtab; i++)
	{
	  bfd_mach_o_dylib_module *module = &cmd->dylib_module[i];
	  unsigned int iinit;
	  unsigned int ninit;

	  iinit = module->iinit & 0xffff;
	  iinit |= ((module->iterm & 0xffff) << 16);

	  ninit = module->ninit & 0xffff;
	  ninit |= ((module->nterm & 0xffff) << 16);

	  if (bfd_mach_o_wide_p (abfd))
	    {
	      struct mach_o_dylib_module_64_external w;

	      bfd_h_put_32 (abfd, module->module_name_idx, &w.module_name);
	      bfd_h_put_32 (abfd, module->iextdefsym, &w.iextdefsym);
	      bfd_h_put_32 (abfd, module->nextdefsym, &w.nextdefsym);
	      bfd_h_put_32 (abfd, module->irefsym, &w.irefsym);
	      bfd_h_put_32 (abfd, module->nrefsym, &w.nrefsym);
	      bfd_h_put_32 (abfd, module->ilocalsym, &w.ilocalsym);
	      bfd_h_put_32 (abfd, module->nlocalsym, &w.nlocalsym);
	      bfd_h_put_32 (abfd, module->iextrel, &w.iextrel);
	      bfd_h_put_32 (abfd, module->nextrel, &w.nextrel);
	      bfd_h_put_32 (abfd, iinit, &w.iinit_iterm);
	      bfd_h_put_32 (abfd, ninit, &w.ninit_nterm);
	      bfd_h_put_64 (abfd, module->objc_module_info_addr,
			    &w.objc_module_info_addr);
	      bfd_h_put_32 (abfd, module->objc_module_info_size,
			    &w.objc_module_info_size);

	      if (bfd_bwrite ((void *) &w, sizeof (w), abfd) != sizeof (w))
		return FALSE;
	    }
	  else
	    {
	      struct mach_o_dylib_module_external n;

	      bfd_h_put_32 (abfd, module->module_name_idx, &n.module_name);
	      bfd_h_put_32 (abfd, module->iextdefsym, &n.iextdefsym);
	      bfd_h_put_32 (abfd, module->nextdefsym, &n.nextdefsym);
	      bfd_h_put_32 (abfd, module->irefsym, &n.irefsym);
	      bfd_h_put_32 (abfd, module->nrefsym, &n.nrefsym);
	      bfd_h_put_32 (abfd, module->ilocalsym, &n.ilocalsym);
	      bfd_h_put_32 (abfd, module->nlocalsym, &n.nlocalsym);
	      bfd_h_put_32 (abfd, module->iextrel, &n.iextrel);
	      bfd_h_put_32 (abfd, module->nextrel, &n.nextrel);
	      bfd_h_put_32 (abfd, iinit, &n.iinit_iterm);
	      bfd_h_put_32 (abfd, ninit, &n.ninit_nterm);
	      bfd_h_put_32 (abfd, module->objc_module_info_addr,
			    &n.objc_module_info_addr);
	      bfd_h_put_32 (abfd, module->objc_module_info_size,
			    &n.objc_module_info_size);

	      if (bfd_bwrite ((void *) &n, sizeof (n), abfd) != sizeof (n))
		return FALSE;
	    }
	}
    }

  if (cmd->ntoc != 0)
    {
      unsigned int i;

      if (bfd_seek (abfd, cmd->tocoff, SEEK_SET) != 0)
	return FALSE;

      for (i = 0; i < cmd->ntoc; i++)
	{
	  struct mach_o_dylib_table_of_contents_external raw;
	  bfd_mach_o_dylib_table_of_content *toc = &cmd->dylib_toc[i];

	  bfd_h_put_32 (abfd, toc->symbol_index, &raw.symbol_index);
	  bfd_h_put_32 (abfd, toc->module_index, &raw.module_index);

	  if (bfd_bwrite (&raw, sizeof (raw), abfd) != sizeof (raw))
	    return FALSE;
	}
    }

  if (cmd->nindirectsyms > 0)
    {
      unsigned int i;

      if (bfd_seek (abfd, cmd->indirectsymoff, SEEK_SET) != 0)
	return FALSE;

      for (i = 0; i < cmd->nindirectsyms; ++i)
	{
	  unsigned char raw[4];

	  bfd_h_put_32 (abfd, cmd->indirect_syms[i], &raw);
	  if (bfd_bwrite (raw, sizeof (raw), abfd) != sizeof (raw))
	    return FALSE;
	}
    }

  if (cmd->nextrefsyms != 0)
    {
      unsigned int i;

      if (bfd_seek (abfd, cmd->extrefsymoff, SEEK_SET) != 0)
	return FALSE;

      for (i = 0; i < cmd->nextrefsyms; i++)
	{
	  unsigned long v;
	  unsigned char raw[4];
	  bfd_mach_o_dylib_reference *ref = &cmd->ext_refs[i];

	  /* Fields isym and flags are written as bit-fields, thus we need
	     a specific processing for endianness.  */

	  if (bfd_big_endian (abfd))
	    {
	      v = ((ref->isym & 0xffffff) << 8);
	      v |= ref->flags & 0xff;
	    }
	  else
	    {
	      v = ref->isym  & 0xffffff;
	      v |= ((ref->flags & 0xff) << 24);
	    }

	  bfd_h_put_32 (abfd, v, raw);
	  if (bfd_bwrite (raw, sizeof (raw), abfd) != sizeof (raw))
	    return FALSE;
	}
    }

  /* The command.  */
  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0)
    return FALSE;
  else
    {
      struct mach_o_dysymtab_command_external raw;

      bfd_h_put_32 (abfd, cmd->ilocalsym, &raw.ilocalsym);
      bfd_h_put_32 (abfd, cmd->nlocalsym, &raw.nlocalsym);
      bfd_h_put_32 (abfd, cmd->iextdefsym, &raw.iextdefsym);
      bfd_h_put_32 (abfd, cmd->nextdefsym, &raw.nextdefsym);
      bfd_h_put_32 (abfd, cmd->iundefsym, &raw.iundefsym);
      bfd_h_put_32 (abfd, cmd->nundefsym, &raw.nundefsym);
      bfd_h_put_32 (abfd, cmd->tocoff, &raw.tocoff);
      bfd_h_put_32 (abfd, cmd->ntoc, &raw.ntoc);
      bfd_h_put_32 (abfd, cmd->modtaboff, &raw.modtaboff);
      bfd_h_put_32 (abfd, cmd->nmodtab, &raw.nmodtab);
      bfd_h_put_32 (abfd, cmd->extrefsymoff, &raw.extrefsymoff);
      bfd_h_put_32 (abfd, cmd->nextrefsyms, &raw.nextrefsyms);
      bfd_h_put_32 (abfd, cmd->indirectsymoff, &raw.indirectsymoff);
      bfd_h_put_32 (abfd, cmd->nindirectsyms, &raw.nindirectsyms);
      bfd_h_put_32 (abfd, cmd->extreloff, &raw.extreloff);
      bfd_h_put_32 (abfd, cmd->nextrel, &raw.nextrel);
      bfd_h_put_32 (abfd, cmd->locreloff, &raw.locreloff);
      bfd_h_put_32 (abfd, cmd->nlocrel, &raw.nlocrel);

      if (bfd_bwrite (&raw, sizeof (raw), abfd) != sizeof (raw))
	return FALSE;
    }

  return TRUE;
}

static unsigned
bfd_mach_o_primary_symbol_sort_key (bfd_mach_o_asymbol *s)
{
  unsigned mtyp = s->n_type & BFD_MACH_O_N_TYPE;

  /* Just leave debug symbols where they are (pretend they are local, and
     then they will just be sorted on position).  */
  if (s->n_type & BFD_MACH_O_N_STAB)
    return 0;

  /* Local (we should never see an undefined local AFAICT).  */
  if (! (s->n_type & (BFD_MACH_O_N_EXT | BFD_MACH_O_N_PEXT)))
    return 0;

  /* Common symbols look like undefined externs.  */
  if (mtyp == BFD_MACH_O_N_UNDF)
    return 2;

  /* A defined non-local, non-debug symbol.  */
  return 1;
}

static int
bfd_mach_o_cf_symbols (const void *a, const void *b)
{
  bfd_mach_o_asymbol *sa = *(bfd_mach_o_asymbol **) a;
  bfd_mach_o_asymbol *sb = *(bfd_mach_o_asymbol **) b;
  unsigned int soa, sob;

  soa = bfd_mach_o_primary_symbol_sort_key (sa);
  sob = bfd_mach_o_primary_symbol_sort_key (sb);
  if (soa < sob)
    return -1;

  if (soa > sob)
    return 1;

  /* If it's local or stab, just preserve the input order.  */
  if (soa == 0)
    {
      if (sa->symbol.udata.i < sb->symbol.udata.i)
        return -1;
      if (sa->symbol.udata.i > sb->symbol.udata.i)
        return  1;

      /* This is probably an error.  */
      return 0;
    }

  /* The second sort key is name.  */
  return strcmp (sa->symbol.name, sb->symbol.name);
}

/* Process the symbols.

   This should be OK for single-module files - but it is not likely to work
   for multi-module shared libraries.

   (a) If the application has not filled in the relevant mach-o fields, make
       an estimate.

   (b) Order them, like this:
	(  i) local.
		(unsorted)
	( ii) external defined
		(by name)
	(iii) external undefined/common
		(by name)
	( iv) common
		(by name)
*/

static bfd_boolean
bfd_mach_o_mangle_symbols (bfd *abfd)
{
  unsigned long i;
  asymbol **symbols = bfd_get_outsymbols (abfd);

  if (symbols == NULL || bfd_get_symcount (abfd) == 0)
    return TRUE;

  for (i = 0; i < bfd_get_symcount (abfd); i++)
    {
      bfd_mach_o_asymbol *s = (bfd_mach_o_asymbol *)symbols[i];

      /* We use this value, which is out-of-range as a symbol index, to signal
	 that the mach-o-specific data are not filled in and need to be created
	 from the bfd values.  It is much preferable for the application to do
	 this, since more meaningful diagnostics can be made that way.  */

      if (s->symbol.udata.i == SYM_MACHO_FIELDS_UNSET)
        {
          /* No symbol information has been set - therefore determine
             it from the bfd symbol flags/info.  */
          if (s->symbol.section == bfd_abs_section_ptr)
            s->n_type = BFD_MACH_O_N_ABS;
          else if (s->symbol.section == bfd_und_section_ptr)
            {
              s->n_type = BFD_MACH_O_N_UNDF;
              if (s->symbol.flags & BSF_WEAK)
                s->n_desc |= BFD_MACH_O_N_WEAK_REF;
              /* mach-o automatically makes undefined symbols extern.  */
	      s->n_type |= BFD_MACH_O_N_EXT;
	      s->symbol.flags |= BSF_GLOBAL;
            }
          else if (s->symbol.section == bfd_com_section_ptr)
	    {
              s->n_type = BFD_MACH_O_N_UNDF | BFD_MACH_O_N_EXT;
              s->symbol.flags |= BSF_GLOBAL;
            }
          else
            s->n_type = BFD_MACH_O_N_SECT;

          if (s->symbol.flags & BSF_GLOBAL)
            s->n_type |= BFD_MACH_O_N_EXT;
        }

      /* Put the section index in, where required.  */
      if ((s->symbol.section != bfd_abs_section_ptr
          && s->symbol.section != bfd_und_section_ptr
          && s->symbol.section != bfd_com_section_ptr)
          || ((s->n_type & BFD_MACH_O_N_STAB) != 0
               && s->symbol.name == NULL))
	s->n_sect = s->symbol.section->target_index;

      /* Number to preserve order for local and debug syms.  */
      s->symbol.udata.i = i;
    }

  /* Sort the symbols.  */
  qsort ((void *) symbols, (size_t) bfd_get_symcount (abfd),
	 sizeof (asymbol *), bfd_mach_o_cf_symbols);

  for (i = 0; i < bfd_get_symcount (abfd); ++i)
    {
      bfd_mach_o_asymbol *s = (bfd_mach_o_asymbol *)symbols[i];
      s->symbol.udata.i = i;  /* renumber.  */
    }

  return TRUE;
}

/* We build a flat table of sections, which can be re-ordered if necessary.
   Fill in the section number and other mach-o-specific data.  */

static bfd_boolean
bfd_mach_o_mangle_sections (bfd *abfd, bfd_mach_o_data_struct *mdata)
{
  asection *sec;
  unsigned target_index;
  unsigned nsect;

  nsect = bfd_count_sections (abfd);

  /* Don't do it if it's already set - assume the application knows what it's
     doing.  */
  if (mdata->nsects == nsect
      && (mdata->nsects == 0 || mdata->sections != NULL))
    return TRUE;

  mdata->nsects = nsect;
  mdata->sections = bfd_alloc (abfd,
			       mdata->nsects * sizeof (bfd_mach_o_section *));
  if (mdata->sections == NULL)
    return FALSE;

  /* We need to check that this can be done...  */
  if (nsect > 255)
    (*_bfd_error_handler) (_("mach-o: there are too many sections (%d)"
			     " maximum is 255,\n"), nsect);

  /* Create Mach-O sections.
     Section type, attribute and align should have been set when the
     section was created - either read in or specified.  */
  target_index = 0;
  for (sec = abfd->sections; sec; sec = sec->next)
    {
      unsigned bfd_align = bfd_get_section_alignment (abfd, sec);
      bfd_mach_o_section *msect = bfd_mach_o_get_mach_o_section (sec);

      mdata->sections[target_index] = msect;

      msect->addr = bfd_get_section_vma (abfd, sec);
      msect->size = bfd_get_section_size (sec);

      /* Use the largest alignment set, in case it was bumped after the
	 section was created.  */
      msect->align = msect->align > bfd_align ? msect->align : bfd_align;

      msect->offset = 0;
      sec->target_index = ++target_index;
    }

  return TRUE;
}

bfd_boolean
bfd_mach_o_write_contents (bfd *abfd)
{
  unsigned int i;
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);

  /* Make the commands, if not already present.  */
  if (mdata->header.ncmds == 0)
    if (!bfd_mach_o_build_commands (abfd))
      return FALSE;

  if (!bfd_mach_o_write_header (abfd, &mdata->header))
    return FALSE;

  for (i = 0; i < mdata->header.ncmds; i++)
    {
      struct mach_o_load_command_external raw;
      bfd_mach_o_load_command *cur = &mdata->commands[i];
      unsigned long typeflag;

      typeflag = cur->type | (cur->type_required ? BFD_MACH_O_LC_REQ_DYLD : 0);

      bfd_h_put_32 (abfd, typeflag, raw.cmd);
      bfd_h_put_32 (abfd, cur->len, raw.cmdsize);

      if (bfd_seek (abfd, cur->offset, SEEK_SET) != 0
          || bfd_bwrite (&raw, BFD_MACH_O_LC_SIZE, abfd) != 8)
	return FALSE;

      switch (cur->type)
	{
	case BFD_MACH_O_LC_SEGMENT:
	  if (bfd_mach_o_write_segment_32 (abfd, cur) != 0)
	    return FALSE;
	  break;
	case BFD_MACH_O_LC_SEGMENT_64:
	  if (bfd_mach_o_write_segment_64 (abfd, cur) != 0)
	    return FALSE;
	  break;
	case BFD_MACH_O_LC_SYMTAB:
	  if (!bfd_mach_o_write_symtab (abfd, cur))
	    return FALSE;
	  break;
	case BFD_MACH_O_LC_DYSYMTAB:
	  if (!bfd_mach_o_write_dysymtab (abfd, cur))
	    return FALSE;
	  break;
	case BFD_MACH_O_LC_SYMSEG:
	  break;
	case BFD_MACH_O_LC_THREAD:
	case BFD_MACH_O_LC_UNIXTHREAD:
	  if (bfd_mach_o_write_thread (abfd, cur) != 0)
	    return FALSE;
	  break;
	case BFD_MACH_O_LC_LOADFVMLIB:
	case BFD_MACH_O_LC_IDFVMLIB:
	case BFD_MACH_O_LC_IDENT:
	case BFD_MACH_O_LC_FVMFILE:
	case BFD_MACH_O_LC_PREPAGE:
	case BFD_MACH_O_LC_LOAD_DYLIB:
	case BFD_MACH_O_LC_LOAD_WEAK_DYLIB:
	case BFD_MACH_O_LC_ID_DYLIB:
	case BFD_MACH_O_LC_REEXPORT_DYLIB:
        case BFD_MACH_O_LC_LOAD_UPWARD_DYLIB:
	case BFD_MACH_O_LC_LOAD_DYLINKER:
	case BFD_MACH_O_LC_ID_DYLINKER:
	case BFD_MACH_O_LC_PREBOUND_DYLIB:
	case BFD_MACH_O_LC_ROUTINES:
	case BFD_MACH_O_LC_SUB_FRAMEWORK:
	  break;
	default:
	  (*_bfd_error_handler) (_("unable to write unknown load command 0x%lx"),
				 (unsigned long) cur->type);
	  return FALSE;
	}
    }

  return TRUE;
}

static void
bfd_mach_o_append_section_to_segment (bfd_mach_o_segment_command *seg,
                                      asection *sec)
{
  bfd_mach_o_section *s = (bfd_mach_o_section *)sec->used_by_bfd;
  if (seg->sect_head == NULL)
    seg->sect_head = s;
  else
    seg->sect_tail->next = s;
  seg->sect_tail = s;
}

/* Create section Mach-O flags from BFD flags.  */

static void
bfd_mach_o_set_section_flags_from_bfd (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  flagword bfd_flags;
  bfd_mach_o_section *s = bfd_mach_o_get_mach_o_section (sec);

  /* Create default flags.  */
  bfd_flags = bfd_get_section_flags (abfd, sec);
  if ((bfd_flags & SEC_CODE) == SEC_CODE)
    s->flags = BFD_MACH_O_S_ATTR_PURE_INSTRUCTIONS
      | BFD_MACH_O_S_ATTR_SOME_INSTRUCTIONS
      | BFD_MACH_O_S_REGULAR;
  else if ((bfd_flags & (SEC_ALLOC | SEC_LOAD)) == SEC_ALLOC)
    s->flags = BFD_MACH_O_S_ZEROFILL;
  else if (bfd_flags & SEC_DEBUGGING)
    s->flags = BFD_MACH_O_S_REGULAR |  BFD_MACH_O_S_ATTR_DEBUG;
  else
    s->flags = BFD_MACH_O_S_REGULAR;
}

/* Count the number of sections in the list for the segment named.

   The special case of NULL or "" for the segment name is valid for
   an MH_OBJECT file and means 'all sections available'.

   Requires that the sections table in mdata be filled in.

   Returns the number of sections (0 is valid).
   Any number > 255 signals an invalid section count, although we will,
   perhaps, allow the file to be written (in line with Darwin tools up
   to XCode 4).

   A section count of (unsigned long) -1 signals a definite error.  */

static unsigned long
bfd_mach_o_count_sections_for_seg (const char *segment,
				   bfd_mach_o_data_struct *mdata)
{
  unsigned i,j;
  if (mdata == NULL || mdata->sections == NULL)
    return (unsigned long) -1;

  /* The MH_OBJECT case, all sections are considered; Although nsects is
     is an unsigned long, the maximum valid section count is 255 and this
     will have been checked already by mangle_sections.  */
  if (segment == NULL || segment[0] == '\0')
    return mdata->nsects;

  /* Count the number of sections we see in this segment.  */
  j = 0;
  for (i = 0; i < mdata->nsects; ++i)
    {
      bfd_mach_o_section *s = mdata->sections[i];
      if (strncmp (segment, s->segname, BFD_MACH_O_SEGNAME_SIZE) == 0)
        j++;
    }
  return j;
}

static bfd_boolean
bfd_mach_o_build_seg_command (const char *segment,
			      bfd_mach_o_data_struct *mdata,
			      bfd_mach_o_segment_command *seg)
{
  unsigned i;
  int is_mho = (segment == NULL || segment[0] == '\0');

  /* Fill segment command.  */
  if (is_mho)
    memset (seg->segname, 0, sizeof (seg->segname));
  else
    strncpy (seg->segname, segment, sizeof (seg->segname));

  /* TODO: fix this up for non-MH_OBJECT cases.  */
  seg->vmaddr = 0;
  seg->vmsize = 0;

  seg->fileoff = mdata->filelen;
  seg->filesize = 0;
  seg->maxprot = BFD_MACH_O_PROT_READ | BFD_MACH_O_PROT_WRITE
		 | BFD_MACH_O_PROT_EXECUTE;
  seg->initprot = seg->maxprot;
  seg->flags = 0;
  seg->sect_head = NULL;
  seg->sect_tail = NULL;

  /*  Append sections to the segment.

      This is a little tedious, we have to honor the need to account zerofill
      sections after all the rest.  This forces us to do the calculation of
      total vmsize in three passes so that any alignment increments are
      properly accounted.  */

  for (i = 0; i < mdata->nsects; ++i)
    {
      bfd_mach_o_section *s = mdata->sections[i];
      asection *sec = s->bfdsection;

      /* If we're not making an MH_OBJECT, check whether this section is from
	 our segment, and skip if not.  Otherwise, just add all sections.  */
      if (! is_mho
	  && strncmp (segment, s->segname, BFD_MACH_O_SEGNAME_SIZE) != 0)
	continue;

      /* Although we account for zerofill section sizes in vm order, they are
	 placed in the file in source sequence.  */
      bfd_mach_o_append_section_to_segment (seg, sec);
      s->offset = 0;

      /* Zerofill sections have zero file size & offset,
	 and are not written.  */
      if ((s->flags & BFD_MACH_O_SECTION_TYPE_MASK) == BFD_MACH_O_S_ZEROFILL
          || (s->flags & BFD_MACH_O_SECTION_TYPE_MASK)
	      == BFD_MACH_O_S_GB_ZEROFILL)
        continue;

      if (s->size > 0)
       {
	  seg->vmsize = FILE_ALIGN (seg->vmsize, s->align);
	  seg->vmsize += s->size;

	  seg->filesize = FILE_ALIGN (seg->filesize, s->align);
	  seg->filesize += s->size;

          mdata->filelen = FILE_ALIGN (mdata->filelen, s->align);
          s->offset = mdata->filelen;
        }

      sec->filepos = s->offset;
      mdata->filelen += s->size;
    }

  /* Now pass through again, for zerofill, only now we just update the vmsize.  */
  for (i = 0; i < mdata->nsects; ++i)
    {
      bfd_mach_o_section *s = mdata->sections[i];

      if ((s->flags & BFD_MACH_O_SECTION_TYPE_MASK) != BFD_MACH_O_S_ZEROFILL)
        continue;

      if (! is_mho
	  && strncmp (segment, s->segname, BFD_MACH_O_SEGNAME_SIZE) != 0)
	continue;

      if (s->size > 0)
	{
	  seg->vmsize = FILE_ALIGN (seg->vmsize, s->align);
	  seg->vmsize += s->size;
	}
    }

  /* Now pass through again, for zerofill_GB.  */
  for (i = 0; i < mdata->nsects; ++i)
    {
      bfd_mach_o_section *s = mdata->sections[i];

      if ((s->flags & BFD_MACH_O_SECTION_TYPE_MASK) != BFD_MACH_O_S_GB_ZEROFILL)
        continue;

      if (! is_mho
	  && strncmp (segment, s->segname, BFD_MACH_O_SEGNAME_SIZE) != 0)
	continue;

      if (s->size > 0)
	{
	  seg->vmsize = FILE_ALIGN (seg->vmsize, s->align);
	  seg->vmsize += s->size;
	}
    }

  /* Allocate space for the relocations.  */
  mdata->filelen = FILE_ALIGN(mdata->filelen, 2);

  for (i = 0; i < mdata->nsects; ++i)
    {
      bfd_mach_o_section *ms = mdata->sections[i];
      asection *sec = ms->bfdsection;

      if ((ms->nreloc = sec->reloc_count) == 0)
        {
	  ms->reloff = 0;
	  continue;
        }
      sec->rel_filepos = mdata->filelen;
      ms->reloff = sec->rel_filepos;
      mdata->filelen += sec->reloc_count * BFD_MACH_O_RELENT_SIZE;
    }

  return TRUE;
}

/* Count the number of indirect symbols in the image.
   Requires that the sections are in their final order.  */

static unsigned int
bfd_mach_o_count_indirect_symbols (bfd *abfd, bfd_mach_o_data_struct *mdata)
{
  unsigned int i;
  unsigned int nisyms = 0;

  for (i = 0; i < mdata->nsects; ++i)
    {
      bfd_mach_o_section *sec = mdata->sections[i];

      switch (sec->flags & BFD_MACH_O_SECTION_TYPE_MASK)
	{
	  case BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS:
	  case BFD_MACH_O_S_LAZY_SYMBOL_POINTERS:
	  case BFD_MACH_O_S_SYMBOL_STUBS:
	    nisyms += bfd_mach_o_section_get_nbr_indirect (abfd, sec);
	    break;
	  default:
	    break;
	}
    }
  return nisyms;
}

static bfd_boolean
bfd_mach_o_build_dysymtab_command (bfd *abfd,
				   bfd_mach_o_data_struct *mdata,
				   bfd_mach_o_load_command *cmd)
{
  bfd_mach_o_dysymtab_command *dsym = &cmd->command.dysymtab;

  /* TODO:
     We are not going to try and fill these in yet and, moreover, we are
     going to bail if they are already set.  */
  if (dsym->nmodtab != 0
      || dsym->ntoc != 0
      || dsym->nextrefsyms != 0)
    {
      (*_bfd_error_handler) (_("sorry: modtab, toc and extrefsyms are not yet"
				" implemented for dysymtab commands."));
      return FALSE;
    }

  dsym->ilocalsym = 0;

  if (bfd_get_symcount (abfd) > 0)
    {
      asymbol **symbols = bfd_get_outsymbols (abfd);
      unsigned long i;

       /* Count the number of each kind of symbol.  */
      for (i = 0; i < bfd_get_symcount (abfd); ++i)
	{
	  bfd_mach_o_asymbol *s = (bfd_mach_o_asymbol *)symbols[i];
	  if (s->n_type & (BFD_MACH_O_N_EXT | BFD_MACH_O_N_PEXT))
	    break;
	}
      dsym->nlocalsym = i;
      dsym->iextdefsym = i;
      for (; i < bfd_get_symcount (abfd); ++i)
	{
	  bfd_mach_o_asymbol *s = (bfd_mach_o_asymbol *)symbols[i];
	  if ((s->n_type & BFD_MACH_O_N_TYPE) == BFD_MACH_O_N_UNDF)
	    break;
	}
      dsym->nextdefsym = i - dsym->nlocalsym;
      dsym->iundefsym = dsym->nextdefsym + dsym->iextdefsym;
      dsym->nundefsym = bfd_get_symcount (abfd)
			- dsym->nlocalsym
			- dsym->nextdefsym;
    }
  else
    {
      dsym->nlocalsym = 0;
      dsym->iextdefsym = 0;
      dsym->nextdefsym = 0;
      dsym->iundefsym = 0;
      dsym->nundefsym = 0;
    }

  dsym->nindirectsyms = bfd_mach_o_count_indirect_symbols (abfd, mdata);
  if (dsym->nindirectsyms > 0)
    {
      unsigned i;
      unsigned n;

      mdata->filelen = FILE_ALIGN (mdata->filelen, 2);
      dsym->indirectsymoff = mdata->filelen;
      mdata->filelen += dsym->nindirectsyms * 4;

      dsym->indirect_syms = bfd_zalloc (abfd, dsym->nindirectsyms * 4);
      if (dsym->indirect_syms == NULL)
        return FALSE;

      n = 0;
      for (i = 0; i < mdata->nsects; ++i)
	{
	  bfd_mach_o_section *sec = mdata->sections[i];

	  switch (sec->flags & BFD_MACH_O_SECTION_TYPE_MASK)
	    {
	      case BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS:
	      case BFD_MACH_O_S_LAZY_SYMBOL_POINTERS:
	      case BFD_MACH_O_S_SYMBOL_STUBS:
		{
		  unsigned j, num;
		  bfd_mach_o_asymbol **isyms = sec->indirect_syms;

		  num = bfd_mach_o_section_get_nbr_indirect (abfd, sec);
		  if (isyms == NULL || num == 0)
		    break;
		  /* Record the starting index in the reserved1 field.  */
		  sec->reserved1 = n;
		  for (j = 0; j < num; j++, n++)
		    {
		      if (isyms[j] == NULL)
		        dsym->indirect_syms[n] = BFD_MACH_O_INDIRECT_SYM_LOCAL;
		      else if (isyms[j]->symbol.section == bfd_abs_section_ptr
			       && ! (isyms[j]->n_type & BFD_MACH_O_N_EXT))
		        dsym->indirect_syms[n] = BFD_MACH_O_INDIRECT_SYM_LOCAL
						 | BFD_MACH_O_INDIRECT_SYM_ABS;
		      else
		        dsym->indirect_syms[n] = isyms[j]->symbol.udata.i;
		    }
		}
		break;
	      default:
		break;
	    }
	}
    }

  return TRUE;
}

/* Build Mach-O load commands (currently assuming an MH_OBJECT file).
   TODO: Other file formats, rebuilding symtab/dysymtab commands for strip
   and copy functionality.  */

bfd_boolean
bfd_mach_o_build_commands (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  unsigned wide = mach_o_wide_p (&mdata->header);
  int segcmd_idx = -1;
  int symtab_idx = -1;
  int dysymtab_idx = -1;
  unsigned long base_offset = 0;

  /* Return now if commands are already present.  */
  if (mdata->header.ncmds)
    return FALSE;

  /* Fill in the file type, if not already set.  */

  if (mdata->header.filetype == 0)
    {
      if (abfd->flags & EXEC_P)
        mdata->header.filetype = BFD_MACH_O_MH_EXECUTE;
      else if (abfd->flags & DYNAMIC)
        mdata->header.filetype = BFD_MACH_O_MH_DYLIB;
      else
        mdata->header.filetype = BFD_MACH_O_MH_OBJECT;
    }

  /* If hasn't already been done, flatten sections list, and sort
     if/when required.  Must be done before the symbol table is adjusted,
     since that depends on properly numbered sections.  */
  if (mdata->nsects == 0 || mdata->sections == NULL)
    if (! bfd_mach_o_mangle_sections (abfd, mdata))
      return FALSE;

  /* Order the symbol table, fill-in/check mach-o specific fields and
     partition out any indirect symbols.  */
  if (!bfd_mach_o_mangle_symbols (abfd))
    return FALSE;

  /* Very simple command set (only really applicable to MH_OBJECTs):
     All the commands are optional - present only when there is suitable data.
     (i.e. it is valid to have an empty file)

	a command (segment) to contain all the sections,
	command for the symbol table,
	a command for the dysymtab.

     ??? maybe we should assert that this is an MH_OBJECT?  */

  if (mdata->nsects > 0)
    {
      segcmd_idx = 0;
      mdata->header.ncmds = 1;
    }

  if (bfd_get_symcount (abfd) > 0)
    {
      mdata->header.ncmds++;
      symtab_idx = segcmd_idx + 1; /* 0 if the seg command is absent.  */
    }

  /* FIXME:
     This is a rather crude test for whether we should build a dysymtab.  */
  if (bfd_mach_o_should_emit_dysymtab ()
      && bfd_get_symcount (abfd))
    {
      mdata->header.ncmds++;
      /* If there should be a case where a dysymtab could be emitted without
	 a symtab (seems improbable), this would need amending.  */
      dysymtab_idx = symtab_idx + 1;
    }

  if (wide)
    base_offset = BFD_MACH_O_HEADER_64_SIZE;
  else
    base_offset = BFD_MACH_O_HEADER_SIZE;

  /* Well, we must have a header, at least.  */
  mdata->filelen = base_offset;

  /* A bit unusual, but no content is valid;
     as -n empty.s -o empty.o  */
  if (mdata->header.ncmds == 0)
    return TRUE;

  mdata->commands = bfd_zalloc (abfd, mdata->header.ncmds
                                * sizeof (bfd_mach_o_load_command));
  if (mdata->commands == NULL)
    return FALSE;

  if (segcmd_idx >= 0)
    {
      bfd_mach_o_load_command *cmd = &mdata->commands[segcmd_idx];
      bfd_mach_o_segment_command *seg = &cmd->command.segment;

      /* Count the segctions in the special blank segment used for MH_OBJECT.  */
      seg->nsects = bfd_mach_o_count_sections_for_seg (NULL, mdata);
      if (seg->nsects == (unsigned long) -1)
	return FALSE;

      /* Init segment command.  */
      cmd->offset = base_offset;
      if (wide)
	{
	  cmd->type = BFD_MACH_O_LC_SEGMENT_64;
	  cmd->len = BFD_MACH_O_LC_SEGMENT_64_SIZE
			+ BFD_MACH_O_SECTION_64_SIZE * seg->nsects;
	}
      else
	{
	  cmd->type = BFD_MACH_O_LC_SEGMENT;
	  cmd->len = BFD_MACH_O_LC_SEGMENT_SIZE
			+ BFD_MACH_O_SECTION_SIZE * seg->nsects;
	}

      cmd->type_required = FALSE;
      mdata->header.sizeofcmds = cmd->len;
      mdata->filelen += cmd->len;
    }

  if (symtab_idx >= 0)
    {
      /* Init symtab command.  */
      bfd_mach_o_load_command *cmd = &mdata->commands[symtab_idx];

      cmd->type = BFD_MACH_O_LC_SYMTAB;
      cmd->offset = base_offset;
      if (segcmd_idx >= 0)
        cmd->offset += mdata->commands[segcmd_idx].len;

      cmd->len = sizeof (struct mach_o_symtab_command_external)
		 + BFD_MACH_O_LC_SIZE;
      cmd->type_required = FALSE;
      mdata->header.sizeofcmds += cmd->len;
      mdata->filelen += cmd->len;
    }

  /* If required, setup symtab command, see comment above about the quality
     of this test.  */
  if (dysymtab_idx >= 0)
    {
      bfd_mach_o_load_command *cmd = &mdata->commands[dysymtab_idx];

      cmd->type = BFD_MACH_O_LC_DYSYMTAB;
      if (symtab_idx >= 0)
        cmd->offset = mdata->commands[symtab_idx].offset
		    + mdata->commands[symtab_idx].len;
      else if (segcmd_idx >= 0)
        cmd->offset = mdata->commands[segcmd_idx].offset
		    + mdata->commands[segcmd_idx].len;
      else
	cmd->offset = base_offset;

      cmd->type_required = FALSE;
      cmd->len = sizeof (struct mach_o_dysymtab_command_external)
		 + BFD_MACH_O_LC_SIZE;

      mdata->header.sizeofcmds += cmd->len;
      mdata->filelen += cmd->len;
    }

  /* So, now we have sized the commands and the filelen set to that.
     Now we can build the segment command and set the section file offsets.  */
  if (segcmd_idx >= 0
      && ! bfd_mach_o_build_seg_command
		(NULL, mdata, &mdata->commands[segcmd_idx].command.segment))
    return FALSE;

  /* If we're doing a dysymtab, cmd points to its load command.  */
  if (dysymtab_idx >= 0
      && ! bfd_mach_o_build_dysymtab_command (abfd, mdata,
					      &mdata->commands[dysymtab_idx]))
    return FALSE;

  /* The symtab command is filled in when the symtab is written.  */
  return TRUE;
}

/* Set the contents of a section.  */

bfd_boolean
bfd_mach_o_set_section_contents (bfd *abfd,
				 asection *section,
				 const void * location,
				 file_ptr offset,
				 bfd_size_type count)
{
  file_ptr pos;

  /* Trying to write the first section contents will trigger the creation of
     the load commands if they are not already present.  */
  if (! abfd->output_has_begun && ! bfd_mach_o_build_commands (abfd))
    return FALSE;

  if (count == 0)
    return TRUE;

  pos = section->filepos + offset;
  if (bfd_seek (abfd, pos, SEEK_SET) != 0
      || bfd_bwrite (location, count, abfd) != count)
    return FALSE;

  return TRUE;
}

int
bfd_mach_o_sizeof_headers (bfd *a ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Make an empty symbol.  This is required only because
   bfd_make_section_anyway wants to create a symbol for the section.  */

asymbol *
bfd_mach_o_make_empty_symbol (bfd *abfd)
{
  asymbol *new_symbol;

  new_symbol = bfd_zalloc (abfd, sizeof (bfd_mach_o_asymbol));
  if (new_symbol == NULL)
    return new_symbol;
  new_symbol->the_bfd = abfd;
  new_symbol->udata.i = SYM_MACHO_FIELDS_UNSET;
  return new_symbol;
}

static bfd_boolean
bfd_mach_o_read_header (bfd *abfd, bfd_mach_o_header *header)
{
  struct mach_o_header_external raw;
  unsigned int size;
  bfd_vma (*get32) (const void *) = NULL;

  /* Just read the magic number.  */
  if (bfd_seek (abfd, 0, SEEK_SET) != 0
      || bfd_bread (raw.magic, sizeof (raw.magic), abfd) != 4)
    return FALSE;

  if (bfd_getb32 (raw.magic) == BFD_MACH_O_MH_MAGIC)
    {
      header->byteorder = BFD_ENDIAN_BIG;
      header->magic = BFD_MACH_O_MH_MAGIC;
      header->version = 1;
      get32 = bfd_getb32;
    }
  else if (bfd_getl32 (raw.magic) == BFD_MACH_O_MH_MAGIC)
    {
      header->byteorder = BFD_ENDIAN_LITTLE;
      header->magic = BFD_MACH_O_MH_MAGIC;
      header->version = 1;
      get32 = bfd_getl32;
    }
  else if (bfd_getb32 (raw.magic) == BFD_MACH_O_MH_MAGIC_64)
    {
      header->byteorder = BFD_ENDIAN_BIG;
      header->magic = BFD_MACH_O_MH_MAGIC_64;
      header->version = 2;
      get32 = bfd_getb32;
    }
  else if (bfd_getl32 (raw.magic) == BFD_MACH_O_MH_MAGIC_64)
    {
      header->byteorder = BFD_ENDIAN_LITTLE;
      header->magic = BFD_MACH_O_MH_MAGIC_64;
      header->version = 2;
      get32 = bfd_getl32;
    }
  else
    {
      header->byteorder = BFD_ENDIAN_UNKNOWN;
      return FALSE;
    }

  /* Once the size of the header is known, read the full header.  */
  size = mach_o_wide_p (header) ?
    BFD_MACH_O_HEADER_64_SIZE : BFD_MACH_O_HEADER_SIZE;

  if (bfd_seek (abfd, 0, SEEK_SET) != 0
      || bfd_bread (&raw, size, abfd) != size)
    return FALSE;

  header->cputype = (*get32) (raw.cputype);
  header->cpusubtype = (*get32) (raw.cpusubtype);
  header->filetype = (*get32) (raw.filetype);
  header->ncmds = (*get32) (raw.ncmds);
  header->sizeofcmds = (*get32) (raw.sizeofcmds);
  header->flags = (*get32) (raw.flags);

  if (mach_o_wide_p (header))
    header->reserved = (*get32) (raw.reserved);
  else
    header->reserved = 0;

  return TRUE;
}

bfd_boolean
bfd_mach_o_new_section_hook (bfd *abfd, asection *sec)
{
  bfd_mach_o_section *s;
  unsigned bfdalign = bfd_get_section_alignment (abfd, sec);

  s = bfd_mach_o_get_mach_o_section (sec);
  if (s == NULL)
    {
      flagword bfd_flags;
      static const mach_o_section_name_xlat * xlat;

      s = (bfd_mach_o_section *) bfd_zalloc (abfd, sizeof (*s));
      if (s == NULL)
	return FALSE;
      sec->used_by_bfd = s;
      s->bfdsection = sec;

      /* Create the Darwin seg/sect name pair from the bfd name.
	 If this is a canonical name for which a specific paiting exists
	 there will also be defined flags, type, attribute and alignment
	 values.  */
      xlat = bfd_mach_o_convert_section_name_to_mach_o (abfd, sec, s);
      if (xlat != NULL)
	{
	  s->flags = xlat->macho_sectype | xlat->macho_secattr;
	  s->align = xlat->sectalign > bfdalign ? xlat->sectalign
						: bfdalign;
	  (void) bfd_set_section_alignment (abfd, sec, s->align);
	  bfd_flags = bfd_get_section_flags (abfd, sec);
	  if (bfd_flags == SEC_NO_FLAGS)
	    bfd_set_section_flags (abfd, sec, xlat->bfd_flags);
	}
      else
	/* Create default flags.  */
	bfd_mach_o_set_section_flags_from_bfd (abfd, sec);
    }

  return _bfd_generic_new_section_hook (abfd, sec);
}

static void
bfd_mach_o_init_section_from_mach_o (bfd *abfd, asection *sec,
                                     unsigned long prot)
{
  flagword flags;
  bfd_mach_o_section *section;

  flags = bfd_get_section_flags (abfd, sec);
  section = bfd_mach_o_get_mach_o_section (sec);

  /* TODO: see if we should use the xlat system for doing this by
     preference and fall back to this for unknown sections.  */

  if (flags == SEC_NO_FLAGS)
    {
      /* Try to guess flags.  */
      if (section->flags & BFD_MACH_O_S_ATTR_DEBUG)
        flags = SEC_DEBUGGING;
      else
        {
          flags = SEC_ALLOC;
          if ((section->flags & BFD_MACH_O_SECTION_TYPE_MASK)
              != BFD_MACH_O_S_ZEROFILL)
            {
              flags |= SEC_LOAD;
              if (prot & BFD_MACH_O_PROT_EXECUTE)
                flags |= SEC_CODE;
              if (prot & BFD_MACH_O_PROT_WRITE)
                flags |= SEC_DATA;
              else if (prot & BFD_MACH_O_PROT_READ)
                flags |= SEC_READONLY;
            }
        }
    }
  else
    {
      if ((flags & SEC_DEBUGGING) == 0)
        flags |= SEC_ALLOC;
    }

  if (section->offset != 0)
    flags |= SEC_HAS_CONTENTS;
  if (section->nreloc != 0)
    flags |= SEC_RELOC;

  bfd_set_section_flags (abfd, sec, flags);

  sec->vma = section->addr;
  sec->lma = section->addr;
  sec->size = section->size;
  sec->filepos = section->offset;
  sec->alignment_power = section->align;
  sec->segment_mark = 0;
  sec->reloc_count = section->nreloc;
  sec->rel_filepos = section->reloff;
}

static asection *
bfd_mach_o_make_bfd_section (bfd *abfd,
                             const unsigned char *segname,
                             const unsigned char *sectname)
{
  const char *sname;
  flagword flags;

  bfd_mach_o_convert_section_name_to_bfd
    (abfd, (const char *)segname, (const char *)sectname, &sname, &flags);
  if (sname == NULL)
    return NULL;

  return bfd_make_section_anyway_with_flags (abfd, sname, flags);
}

static asection *
bfd_mach_o_read_section_32 (bfd *abfd,
                            unsigned int offset,
                            unsigned long prot)
{
  struct mach_o_section_32_external raw;
  asection *sec;
  bfd_mach_o_section *section;

  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || (bfd_bread (&raw, BFD_MACH_O_SECTION_SIZE, abfd)
          != BFD_MACH_O_SECTION_SIZE))
    return NULL;

  sec = bfd_mach_o_make_bfd_section (abfd, raw.segname, raw.sectname);
  if (sec == NULL)
    return NULL;

  section = bfd_mach_o_get_mach_o_section (sec);
  memcpy (section->segname, raw.segname, sizeof (raw.segname));
  section->segname[BFD_MACH_O_SEGNAME_SIZE] = 0;
  memcpy (section->sectname, raw.sectname, sizeof (raw.sectname));
  section->sectname[BFD_MACH_O_SECTNAME_SIZE] = 0;
  section->addr = bfd_h_get_32 (abfd, raw.addr);
  section->size = bfd_h_get_32 (abfd, raw.size);
  section->offset = bfd_h_get_32 (abfd, raw.offset);
  section->align = bfd_h_get_32 (abfd, raw.align);
  section->reloff = bfd_h_get_32 (abfd, raw.reloff);
  section->nreloc = bfd_h_get_32 (abfd, raw.nreloc);
  section->flags = bfd_h_get_32 (abfd, raw.flags);
  section->reserved1 = bfd_h_get_32 (abfd, raw.reserved1);
  section->reserved2 = bfd_h_get_32 (abfd, raw.reserved2);
  section->reserved3 = 0;

  bfd_mach_o_init_section_from_mach_o (abfd, sec, prot);

  return sec;
}

static asection *
bfd_mach_o_read_section_64 (bfd *abfd,
                            unsigned int offset,
                            unsigned long prot)
{
  struct mach_o_section_64_external raw;
  asection *sec;
  bfd_mach_o_section *section;

  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || (bfd_bread (&raw, BFD_MACH_O_SECTION_64_SIZE, abfd)
          != BFD_MACH_O_SECTION_64_SIZE))
    return NULL;

  sec = bfd_mach_o_make_bfd_section (abfd, raw.segname, raw.sectname);
  if (sec == NULL)
    return NULL;

  section = bfd_mach_o_get_mach_o_section (sec);
  memcpy (section->segname, raw.segname, sizeof (raw.segname));
  section->segname[BFD_MACH_O_SEGNAME_SIZE] = 0;
  memcpy (section->sectname, raw.sectname, sizeof (raw.sectname));
  section->sectname[BFD_MACH_O_SECTNAME_SIZE] = 0;
  section->addr = bfd_h_get_64 (abfd, raw.addr);
  section->size = bfd_h_get_64 (abfd, raw.size);
  section->offset = bfd_h_get_32 (abfd, raw.offset);
  section->align = bfd_h_get_32 (abfd, raw.align);
  section->reloff = bfd_h_get_32 (abfd, raw.reloff);
  section->nreloc = bfd_h_get_32 (abfd, raw.nreloc);
  section->flags = bfd_h_get_32 (abfd, raw.flags);
  section->reserved1 = bfd_h_get_32 (abfd, raw.reserved1);
  section->reserved2 = bfd_h_get_32 (abfd, raw.reserved2);
  section->reserved3 = bfd_h_get_32 (abfd, raw.reserved3);

  bfd_mach_o_init_section_from_mach_o (abfd, sec, prot);

  return sec;
}

static asection *
bfd_mach_o_read_section (bfd *abfd,
                         unsigned int offset,
                         unsigned long prot,
                         unsigned int wide)
{
  if (wide)
    return bfd_mach_o_read_section_64 (abfd, offset, prot);
  else
    return bfd_mach_o_read_section_32 (abfd, offset, prot);
}

static bfd_boolean
bfd_mach_o_read_symtab_symbol (bfd *abfd,
                               bfd_mach_o_symtab_command *sym,
                               bfd_mach_o_asymbol *s,
                               unsigned long i)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  unsigned int wide = mach_o_wide_p (&mdata->header);
  unsigned int symwidth =
    wide ? BFD_MACH_O_NLIST_64_SIZE : BFD_MACH_O_NLIST_SIZE;
  unsigned int symoff = sym->symoff + (i * symwidth);
  struct mach_o_nlist_64_external raw;
  unsigned char type = -1;
  unsigned char section = -1;
  short desc = -1;
  symvalue value = -1;
  unsigned long stroff = -1;
  unsigned int symtype = -1;

  BFD_ASSERT (sym->strtab != NULL);

  if (bfd_seek (abfd, symoff, SEEK_SET) != 0
      || bfd_bread (&raw, symwidth, abfd) != symwidth)
    {
      (*_bfd_error_handler)
        (_("bfd_mach_o_read_symtab_symbol: unable to read %d bytes at %lu"),
         symwidth, (unsigned long) symoff);
      return FALSE;
    }

  stroff = bfd_h_get_32 (abfd, raw.n_strx);
  type = bfd_h_get_8 (abfd, raw.n_type);
  symtype = type & BFD_MACH_O_N_TYPE;
  section = bfd_h_get_8 (abfd, raw.n_sect);
  desc = bfd_h_get_16 (abfd, raw.n_desc);
  if (wide)
    value = bfd_h_get_64 (abfd, raw.n_value);
  else
    value = bfd_h_get_32 (abfd, raw.n_value);

  if (stroff >= sym->strsize)
    {
      (*_bfd_error_handler)
        (_("bfd_mach_o_read_symtab_symbol: name out of range (%lu >= %lu)"),
         (unsigned long) stroff,
         (unsigned long) sym->strsize);
      return FALSE;
    }

  s->symbol.the_bfd = abfd;
  s->symbol.name = sym->strtab + stroff;
  s->symbol.value = value;
  s->symbol.flags = 0x0;
  s->symbol.udata.i = i;
  s->n_type = type;
  s->n_sect = section;
  s->n_desc = desc;

  if (type & BFD_MACH_O_N_STAB)
    {
      s->symbol.flags |= BSF_DEBUGGING;
      s->symbol.section = bfd_und_section_ptr;
      switch (type)
	{
	case N_FUN:
	case N_STSYM:
	case N_LCSYM:
	case N_BNSYM:
	case N_SLINE:
	case N_ENSYM:
	case N_ECOMM:
	case N_ECOML:
	case N_GSYM:
	  if ((section > 0) && (section <= mdata->nsects))
	    {
	      s->symbol.section = mdata->sections[section - 1]->bfdsection;
	      s->symbol.value =
                s->symbol.value - mdata->sections[section - 1]->addr;
	    }
	  break;
	}
    }
  else
    {
      if (type & (BFD_MACH_O_N_PEXT | BFD_MACH_O_N_EXT))
	s->symbol.flags |= BSF_GLOBAL;
      else
	s->symbol.flags |= BSF_LOCAL;

      switch (symtype)
	{
	case BFD_MACH_O_N_UNDF:
          if (type == (BFD_MACH_O_N_UNDF | BFD_MACH_O_N_EXT)
              && s->symbol.value != 0)
            {
              /* A common symbol.  */
              s->symbol.section = bfd_com_section_ptr;
              s->symbol.flags = BSF_NO_FLAGS;
            }
          else
            {
              s->symbol.section = bfd_und_section_ptr;
              if (s->n_desc & BFD_MACH_O_N_WEAK_REF)
                s->symbol.flags |= BSF_WEAK;
            }
	  break;
	case BFD_MACH_O_N_PBUD:
	  s->symbol.section = bfd_und_section_ptr;
	  break;
	case BFD_MACH_O_N_ABS:
	  s->symbol.section = bfd_abs_section_ptr;
	  break;
	case BFD_MACH_O_N_SECT:
	  if ((section > 0) && (section <= mdata->nsects))
	    {
	      s->symbol.section = mdata->sections[section - 1]->bfdsection;
	      s->symbol.value =
                s->symbol.value - mdata->sections[section - 1]->addr;
	    }
	  else
	    {
	      /* Mach-O uses 0 to mean "no section"; not an error.  */
	      if (section != 0)
		{
		  (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: "
					   "symbol \"%s\" specified invalid section %d (max %lu): setting to undefined"),
					 s->symbol.name, section, mdata->nsects);
		}
	      s->symbol.section = bfd_und_section_ptr;
	    }
	  break;
	case BFD_MACH_O_N_INDR:
	  /* FIXME: we don't follow the BFD convention as this indirect symbol
	     won't be followed by the referenced one.  This looks harmless
	     unless we start using the linker.	*/
	  s->symbol.flags |= BSF_INDIRECT;
	  s->symbol.section = bfd_ind_section_ptr;
	  s->symbol.value = 0;
	  break;
	default:
	  (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: "
				   "symbol \"%s\" specified invalid type field 0x%x: setting to undefined"),
				 s->symbol.name, symtype);
	  s->symbol.section = bfd_und_section_ptr;
	  break;
	}
    }

  return TRUE;
}

bfd_boolean
bfd_mach_o_read_symtab_strtab (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  bfd_mach_o_symtab_command *sym = mdata->symtab;

  /* Fail if there is no symtab.  */
  if (sym == NULL)
    return FALSE;

  /* Success if already loaded.  */
  if (sym->strtab)
    return TRUE;

  if (abfd->flags & BFD_IN_MEMORY)
    {
      struct bfd_in_memory *b;

      b = (struct bfd_in_memory *) abfd->iostream;

      if ((sym->stroff + sym->strsize) > b->size)
	{
	  bfd_set_error (bfd_error_file_truncated);
	  return FALSE;
	}
      sym->strtab = (char *) b->buffer + sym->stroff;
    }
  else
    {
      sym->strtab = bfd_alloc (abfd, sym->strsize);
      if (sym->strtab == NULL)
        return FALSE;

      if (bfd_seek (abfd, sym->stroff, SEEK_SET) != 0
          || bfd_bread (sym->strtab, sym->strsize, abfd) != sym->strsize)
        {
          bfd_set_error (bfd_error_file_truncated);
          return FALSE;
        }
    }

  return TRUE;
}

bfd_boolean
bfd_mach_o_read_symtab_symbols (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  bfd_mach_o_symtab_command *sym = mdata->symtab;
  unsigned long i;

  if (sym == NULL || sym->symbols)
    {
      /* Return now if there are no symbols or if already loaded.  */
      return TRUE;
    }

  sym->symbols = bfd_alloc (abfd, sym->nsyms * sizeof (bfd_mach_o_asymbol));

  if (sym->symbols == NULL)
    {
      (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbols: unable to allocate memory for symbols"));
      return FALSE;
    }

  if (!bfd_mach_o_read_symtab_strtab (abfd))
    return FALSE;

  for (i = 0; i < sym->nsyms; i++)
    {
      if (!bfd_mach_o_read_symtab_symbol (abfd, sym, &sym->symbols[i], i))
	return FALSE;
    }

  return TRUE;
}

static const char *
bfd_mach_o_i386_flavour_string (unsigned int flavour)
{
  switch ((int) flavour)
    {
    case BFD_MACH_O_x86_THREAD_STATE32:    return "x86_THREAD_STATE32";
    case BFD_MACH_O_x86_FLOAT_STATE32:     return "x86_FLOAT_STATE32";
    case BFD_MACH_O_x86_EXCEPTION_STATE32: return "x86_EXCEPTION_STATE32";
    case BFD_MACH_O_x86_THREAD_STATE64:    return "x86_THREAD_STATE64";
    case BFD_MACH_O_x86_FLOAT_STATE64:     return "x86_FLOAT_STATE64";
    case BFD_MACH_O_x86_EXCEPTION_STATE64: return "x86_EXCEPTION_STATE64";
    case BFD_MACH_O_x86_THREAD_STATE:      return "x86_THREAD_STATE";
    case BFD_MACH_O_x86_FLOAT_STATE:       return "x86_FLOAT_STATE";
    case BFD_MACH_O_x86_EXCEPTION_STATE:   return "x86_EXCEPTION_STATE";
    case BFD_MACH_O_x86_DEBUG_STATE32:     return "x86_DEBUG_STATE32";
    case BFD_MACH_O_x86_DEBUG_STATE64:     return "x86_DEBUG_STATE64";
    case BFD_MACH_O_x86_DEBUG_STATE:       return "x86_DEBUG_STATE";
    case BFD_MACH_O_x86_THREAD_STATE_NONE: return "x86_THREAD_STATE_NONE";
    default: return "UNKNOWN";
    }
}

static const char *
bfd_mach_o_ppc_flavour_string (unsigned int flavour)
{
  switch ((int) flavour)
    {
    case BFD_MACH_O_PPC_THREAD_STATE:      return "PPC_THREAD_STATE";
    case BFD_MACH_O_PPC_FLOAT_STATE:       return "PPC_FLOAT_STATE";
    case BFD_MACH_O_PPC_EXCEPTION_STATE:   return "PPC_EXCEPTION_STATE";
    case BFD_MACH_O_PPC_VECTOR_STATE:      return "PPC_VECTOR_STATE";
    case BFD_MACH_O_PPC_THREAD_STATE64:    return "PPC_THREAD_STATE64";
    case BFD_MACH_O_PPC_EXCEPTION_STATE64: return "PPC_EXCEPTION_STATE64";
    default: return "UNKNOWN";
    }
}

static int
bfd_mach_o_read_dylinker (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_dylinker_command *cmd = &command->command.dylinker;
  struct mach_o_str_command_external raw;
  unsigned int nameoff;

  BFD_ASSERT ((command->type == BFD_MACH_O_LC_ID_DYLINKER)
	      || (command->type == BFD_MACH_O_LC_LOAD_DYLINKER));

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return -1;

  nameoff = bfd_h_get_32 (abfd, raw.str);

  cmd->name_offset = command->offset + nameoff;
  cmd->name_len = command->len - nameoff;
  cmd->name_str = bfd_alloc (abfd, cmd->name_len);
  if (cmd->name_str == NULL)
    return -1;
  if (bfd_seek (abfd, cmd->name_offset, SEEK_SET) != 0
      || bfd_bread (cmd->name_str, cmd->name_len, abfd) != cmd->name_len)
    return -1;
  return 0;
}

static int
bfd_mach_o_read_dylib (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_dylib_command *cmd = &command->command.dylib;
  struct mach_o_dylib_command_external raw;
  unsigned int nameoff;

  switch (command->type)
    {
    case BFD_MACH_O_LC_LOAD_DYLIB:
    case BFD_MACH_O_LC_LOAD_WEAK_DYLIB:
    case BFD_MACH_O_LC_ID_DYLIB:
    case BFD_MACH_O_LC_REEXPORT_DYLIB:
    case BFD_MACH_O_LC_LOAD_UPWARD_DYLIB:
      break;
    default:
      BFD_FAIL ();
      return -1;
    }

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return -1;

  nameoff = bfd_h_get_32 (abfd, raw.name);
  cmd->timestamp = bfd_h_get_32 (abfd, raw.timestamp);
  cmd->current_version = bfd_h_get_32 (abfd, raw.current_version);
  cmd->compatibility_version = bfd_h_get_32 (abfd, raw.compatibility_version);

  cmd->name_offset = command->offset + nameoff;
  cmd->name_len = command->len - nameoff;
  cmd->name_str = bfd_alloc (abfd, cmd->name_len);
  if (cmd->name_str == NULL)
    return -1;
  if (bfd_seek (abfd, cmd->name_offset, SEEK_SET) != 0
      || bfd_bread (cmd->name_str, cmd->name_len, abfd) != cmd->name_len)
    return -1;
  return 0;
}

static int
bfd_mach_o_read_prebound_dylib (bfd *abfd ATTRIBUTE_UNUSED,
                                bfd_mach_o_load_command *command ATTRIBUTE_UNUSED)
{
  /* bfd_mach_o_prebound_dylib_command *cmd = &command->command.prebound_dylib; */

  BFD_ASSERT (command->type == BFD_MACH_O_LC_PREBOUND_DYLIB);
  return 0;
}

static int
bfd_mach_o_read_fvmlib (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_fvmlib_command *fvm = &command->command.fvmlib;
  struct mach_o_fvmlib_command_external raw;
  unsigned int nameoff;

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return -1;

  nameoff = bfd_h_get_32 (abfd, raw.name);
  fvm->minor_version = bfd_h_get_32 (abfd, raw.minor_version);
  fvm->header_addr = bfd_h_get_32 (abfd, raw.header_addr);

  fvm->name_offset = command->offset + nameoff;
  fvm->name_len = command->len - nameoff;
  fvm->name_str = bfd_alloc (abfd, fvm->name_len);
  if (fvm->name_str == NULL)
    return -1;
  if (bfd_seek (abfd, fvm->name_offset, SEEK_SET) != 0
      || bfd_bread (fvm->name_str, fvm->name_len, abfd) != fvm->name_len)
    return -1;
  return 0;
}

static int
bfd_mach_o_read_thread (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  bfd_mach_o_thread_command *cmd = &command->command.thread;
  unsigned int offset;
  unsigned int nflavours;
  unsigned int i;

  BFD_ASSERT ((command->type == BFD_MACH_O_LC_THREAD)
	      || (command->type == BFD_MACH_O_LC_UNIXTHREAD));

  /* Count the number of threads.  */
  offset = 8;
  nflavours = 0;
  while (offset != command->len)
    {
      struct mach_o_thread_command_external raw;

      if (offset >= command->len)
	return -1;

      if (bfd_seek (abfd, command->offset + offset, SEEK_SET) != 0
          || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
	return -1;

      offset += sizeof (raw) + bfd_h_get_32 (abfd, raw.count) * 4;
      nflavours++;
    }

  /* Allocate threads.  */
  cmd->flavours = bfd_alloc
    (abfd, nflavours * sizeof (bfd_mach_o_thread_flavour));
  if (cmd->flavours == NULL)
    return -1;
  cmd->nflavours = nflavours;

  offset = 8;
  nflavours = 0;
  while (offset != command->len)
    {
      struct mach_o_thread_command_external raw;

      if (offset >= command->len)
	return -1;

      if (nflavours >= cmd->nflavours)
	return -1;

      if (bfd_seek (abfd, command->offset + offset, SEEK_SET) != 0
          || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
	return -1;

      cmd->flavours[nflavours].flavour = bfd_h_get_32 (abfd, raw.flavour);
      cmd->flavours[nflavours].offset = command->offset + offset + sizeof (raw);
      cmd->flavours[nflavours].size = bfd_h_get_32 (abfd, raw.count) * 4;
      offset += cmd->flavours[nflavours].size + sizeof (raw);
      nflavours++;
    }

  for (i = 0; i < nflavours; i++)
    {
      asection *bfdsec;
      unsigned int snamelen;
      char *sname;
      const char *flavourstr;
      const char *prefix = "LC_THREAD";
      unsigned int j = 0;

      switch (mdata->header.cputype)
	{
	case BFD_MACH_O_CPU_TYPE_POWERPC:
	case BFD_MACH_O_CPU_TYPE_POWERPC_64:
	  flavourstr = bfd_mach_o_ppc_flavour_string (cmd->flavours[i].flavour);
	  break;
	case BFD_MACH_O_CPU_TYPE_I386:
	case BFD_MACH_O_CPU_TYPE_X86_64:
	  flavourstr = bfd_mach_o_i386_flavour_string (cmd->flavours[i].flavour);
	  break;
	default:
	  flavourstr = "UNKNOWN_ARCHITECTURE";
	  break;
	}

      snamelen = strlen (prefix) + 1 + 20 + 1 + strlen (flavourstr) + 1;
      sname = bfd_alloc (abfd, snamelen);
      if (sname == NULL)
	return -1;

      for (;;)
	{
	  sprintf (sname, "%s.%s.%u", prefix, flavourstr, j);
	  if (bfd_get_section_by_name (abfd, sname) == NULL)
	    break;
	  j++;
	}

      bfdsec = bfd_make_section_with_flags (abfd, sname, SEC_HAS_CONTENTS);

      bfdsec->vma = 0;
      bfdsec->lma = 0;
      bfdsec->size = cmd->flavours[i].size;
      bfdsec->filepos = cmd->flavours[i].offset;
      bfdsec->alignment_power = 0x0;

      cmd->section = bfdsec;
    }

  return 0;
}

static int
bfd_mach_o_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_dysymtab_command *cmd = &command->command.dysymtab;
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);

  BFD_ASSERT (command->type == BFD_MACH_O_LC_DYSYMTAB);

  {
    struct mach_o_dysymtab_command_external raw;

    if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
        || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
      return -1;

    cmd->ilocalsym = bfd_h_get_32 (abfd, raw.ilocalsym);
    cmd->nlocalsym = bfd_h_get_32 (abfd, raw.nlocalsym);
    cmd->iextdefsym = bfd_h_get_32 (abfd, raw.iextdefsym);
    cmd->nextdefsym = bfd_h_get_32 (abfd, raw.nextdefsym);
    cmd->iundefsym = bfd_h_get_32 (abfd, raw.iundefsym);
    cmd->nundefsym = bfd_h_get_32 (abfd, raw.nundefsym);
    cmd->tocoff = bfd_h_get_32 (abfd, raw.tocoff);
    cmd->ntoc = bfd_h_get_32 (abfd, raw.ntoc);
    cmd->modtaboff = bfd_h_get_32 (abfd, raw.modtaboff);
    cmd->nmodtab = bfd_h_get_32 (abfd, raw.nmodtab);
    cmd->extrefsymoff = bfd_h_get_32 (abfd, raw.extrefsymoff);
    cmd->nextrefsyms = bfd_h_get_32 (abfd, raw.nextrefsyms);
    cmd->indirectsymoff = bfd_h_get_32 (abfd, raw.indirectsymoff);
    cmd->nindirectsyms = bfd_h_get_32 (abfd, raw.nindirectsyms);
    cmd->extreloff = bfd_h_get_32 (abfd, raw.extreloff);
    cmd->nextrel = bfd_h_get_32 (abfd, raw.nextrel);
    cmd->locreloff = bfd_h_get_32 (abfd, raw.locreloff);
    cmd->nlocrel = bfd_h_get_32 (abfd, raw.nlocrel);
  }

  if (cmd->nmodtab != 0)
    {
      unsigned int i;
      int wide = bfd_mach_o_wide_p (abfd);
      unsigned int module_len = wide ? 56 : 52;

      cmd->dylib_module =
        bfd_alloc (abfd, cmd->nmodtab * sizeof (bfd_mach_o_dylib_module));
      if (cmd->dylib_module == NULL)
        return -1;

      if (bfd_seek (abfd, cmd->modtaboff, SEEK_SET) != 0)
        return -1;

      for (i = 0; i < cmd->nmodtab; i++)
        {
          bfd_mach_o_dylib_module *module = &cmd->dylib_module[i];
          unsigned long v;
          unsigned char buf[56];

          if (bfd_bread ((void *) buf, module_len, abfd) != module_len)
            return -1;

          module->module_name_idx = bfd_h_get_32 (abfd, buf + 0);
          module->iextdefsym = bfd_h_get_32 (abfd, buf + 4);
          module->nextdefsym = bfd_h_get_32 (abfd, buf + 8);
          module->irefsym = bfd_h_get_32 (abfd, buf + 12);
          module->nrefsym = bfd_h_get_32 (abfd, buf + 16);
          module->ilocalsym = bfd_h_get_32 (abfd, buf + 20);
          module->nlocalsym = bfd_h_get_32 (abfd, buf + 24);
          module->iextrel = bfd_h_get_32 (abfd, buf + 28);
          module->nextrel = bfd_h_get_32 (abfd, buf + 32);
          v = bfd_h_get_32 (abfd, buf +36);
          module->iinit = v & 0xffff;
          module->iterm = (v >> 16) & 0xffff;
          v = bfd_h_get_32 (abfd, buf + 40);
          module->ninit = v & 0xffff;
          module->nterm = (v >> 16) & 0xffff;
          if (wide)
            {
              module->objc_module_info_size = bfd_h_get_32 (abfd, buf + 44);
              module->objc_module_info_addr = bfd_h_get_64 (abfd, buf + 48);
            }
          else
            {
              module->objc_module_info_addr = bfd_h_get_32 (abfd, buf + 44);
              module->objc_module_info_size = bfd_h_get_32 (abfd, buf + 48);
            }
        }
    }

  if (cmd->ntoc != 0)
    {
      unsigned int i;

      cmd->dylib_toc = bfd_alloc
        (abfd, cmd->ntoc * sizeof (bfd_mach_o_dylib_table_of_content));
      if (cmd->dylib_toc == NULL)
        return -1;

      if (bfd_seek (abfd, cmd->tocoff, SEEK_SET) != 0)
        return -1;

      for (i = 0; i < cmd->ntoc; i++)
        {
          struct mach_o_dylib_table_of_contents_external raw;
          bfd_mach_o_dylib_table_of_content *toc = &cmd->dylib_toc[i];

          if (bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
            return -1;

          toc->symbol_index = bfd_h_get_32 (abfd, raw.symbol_index);
          toc->module_index = bfd_h_get_32 (abfd, raw.module_index);
        }
    }

  if (cmd->nindirectsyms != 0)
    {
      unsigned int i;

      cmd->indirect_syms = bfd_alloc
        (abfd, cmd->nindirectsyms * sizeof (unsigned int));
      if (cmd->indirect_syms == NULL)
        return -1;

      if (bfd_seek (abfd, cmd->indirectsymoff, SEEK_SET) != 0)
        return -1;

      for (i = 0; i < cmd->nindirectsyms; i++)
        {
          unsigned char raw[4];
          unsigned int *is = &cmd->indirect_syms[i];

          if (bfd_bread (raw, sizeof (raw), abfd) != sizeof (raw))
            return -1;

          *is = bfd_h_get_32 (abfd, raw);
        }
    }

  if (cmd->nextrefsyms != 0)
    {
      unsigned long v;
      unsigned int i;

      cmd->ext_refs = bfd_alloc
        (abfd, cmd->nextrefsyms * sizeof (bfd_mach_o_dylib_reference));
      if (cmd->ext_refs == NULL)
        return -1;

      if (bfd_seek (abfd, cmd->extrefsymoff, SEEK_SET) != 0)
        return -1;

      for (i = 0; i < cmd->nextrefsyms; i++)
        {
          unsigned char raw[4];
          bfd_mach_o_dylib_reference *ref = &cmd->ext_refs[i];

          if (bfd_bread (raw, sizeof (raw), abfd) != sizeof (raw))
            return -1;

          /* Fields isym and flags are written as bit-fields, thus we need
             a specific processing for endianness.  */
          v = bfd_h_get_32 (abfd, raw);
          if (bfd_big_endian (abfd))
            {
              ref->isym = (v >> 8) & 0xffffff;
              ref->flags = v & 0xff;
            }
          else
            {
              ref->isym = v & 0xffffff;
              ref->flags = (v >> 24) & 0xff;
            }
        }
    }

  if (mdata->dysymtab)
    return -1;
  mdata->dysymtab = cmd;

  return 0;
}

static int
bfd_mach_o_read_symtab (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_symtab_command *symtab = &command->command.symtab;
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  struct mach_o_symtab_command_external raw;

  BFD_ASSERT (command->type == BFD_MACH_O_LC_SYMTAB);

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return -1;

  symtab->symoff = bfd_h_get_32 (abfd, raw.symoff);
  symtab->nsyms = bfd_h_get_32 (abfd, raw.nsyms);
  symtab->stroff = bfd_h_get_32 (abfd, raw.stroff);
  symtab->strsize = bfd_h_get_32 (abfd, raw.strsize);
  symtab->symbols = NULL;
  symtab->strtab = NULL;

  if (symtab->nsyms != 0)
    abfd->flags |= HAS_SYMS;

  if (mdata->symtab)
    return -1;
  mdata->symtab = symtab;
  return 0;
}

static int
bfd_mach_o_read_uuid (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_uuid_command *cmd = &command->command.uuid;

  BFD_ASSERT (command->type == BFD_MACH_O_LC_UUID);

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (cmd->uuid, 16, abfd) != 16)
    return -1;

  return 0;
}

static int
bfd_mach_o_read_linkedit (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_linkedit_command *cmd = &command->command.linkedit;
  struct mach_o_linkedit_data_command_external raw;

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return -1;

  cmd->dataoff = bfd_get_32 (abfd, raw.dataoff);
  cmd->datasize = bfd_get_32 (abfd, raw.datasize);
  return 0;
}

static int
bfd_mach_o_read_str (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_str_command *cmd = &command->command.str;
  struct mach_o_str_command_external raw;
  unsigned long off;

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return -1;

  off = bfd_get_32 (abfd, raw.str);
  cmd->stroff = command->offset + off;
  cmd->str_len = command->len - off;
  cmd->str = bfd_alloc (abfd, cmd->str_len);
  if (cmd->str == NULL)
    return -1;
  if (bfd_seek (abfd, cmd->stroff, SEEK_SET) != 0
      || bfd_bread ((void *) cmd->str, cmd->str_len, abfd) != cmd->str_len)
    return -1;
  return 0;
}

static int
bfd_mach_o_read_dyld_info (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_dyld_info_command *cmd = &command->command.dyld_info;
  struct mach_o_dyld_info_command_external raw;

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return -1;

  cmd->rebase_off = bfd_get_32 (abfd, raw.rebase_off);
  cmd->rebase_size = bfd_get_32 (abfd, raw.rebase_size);
  cmd->bind_off = bfd_get_32 (abfd, raw.bind_off);
  cmd->bind_size = bfd_get_32 (abfd, raw.bind_size);
  cmd->weak_bind_off = bfd_get_32 (abfd, raw.weak_bind_off);
  cmd->weak_bind_size = bfd_get_32 (abfd, raw.weak_bind_size);
  cmd->lazy_bind_off = bfd_get_32 (abfd, raw.lazy_bind_off);
  cmd->lazy_bind_size = bfd_get_32 (abfd, raw.lazy_bind_size);
  cmd->export_off = bfd_get_32 (abfd, raw.export_off);
  cmd->export_size = bfd_get_32 (abfd, raw.export_size);
  return 0;
}

static bfd_boolean
bfd_mach_o_read_version_min (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_version_min_command *cmd = &command->command.version_min;
  struct mach_o_version_min_command_external raw;
  unsigned int ver;

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return FALSE;

  ver = bfd_get_32 (abfd, raw.version);
  cmd->rel = ver >> 16;
  cmd->maj = ver >> 8;
  cmd->min = ver;
  cmd->reserved = bfd_get_32 (abfd, raw.reserved);
  return TRUE;
}

static bfd_boolean
bfd_mach_o_read_encryption_info (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_encryption_info_command *cmd = &command->command.encryption_info;
  struct mach_o_encryption_info_command_external raw;

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return FALSE;

  cmd->cryptoff = bfd_get_32 (abfd, raw.cryptoff);
  cmd->cryptsize = bfd_get_32 (abfd, raw.cryptsize);
  cmd->cryptid = bfd_get_32 (abfd, raw.cryptid);
  return TRUE;
}

static bfd_boolean
bfd_mach_o_read_main (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_main_command *cmd = &command->command.main;
  struct mach_o_entry_point_command_external raw;

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return FALSE;

  cmd->entryoff = bfd_get_64 (abfd, raw.entryoff);
  cmd->stacksize = bfd_get_64 (abfd, raw.stacksize);
  return TRUE;
}

static bfd_boolean
bfd_mach_o_read_source_version (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_source_version_command *cmd = &command->command.source_version;
  struct mach_o_source_version_command_external raw;
  bfd_uint64_t ver;

  if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
      || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
    return FALSE;

  ver = bfd_get_64 (abfd, raw.version);
  /* Note: we use a serie of shift to avoid shift > 32 (for which gcc
     generates warnings) in case of the host doesn't support 64 bit
     integers.  */
  cmd->e = ver & 0x3ff;
  ver >>= 10;
  cmd->d = ver & 0x3ff;
  ver >>= 10;
  cmd->c = ver & 0x3ff;
  ver >>= 10;
  cmd->b = ver & 0x3ff;
  ver >>= 10;
  cmd->a = ver & 0xffffff;
  return TRUE;
}

static int
bfd_mach_o_read_segment (bfd *abfd,
                         bfd_mach_o_load_command *command,
                         unsigned int wide)
{
  bfd_mach_o_segment_command *seg = &command->command.segment;
  unsigned long i;

  if (wide)
    {
      struct mach_o_segment_command_64_external raw;

      BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT_64);

      if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
          || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
        return -1;

      memcpy (seg->segname, raw.segname, 16);
      seg->segname[16] = '\0';

      seg->vmaddr = bfd_h_get_64 (abfd, raw.vmaddr);
      seg->vmsize = bfd_h_get_64 (abfd, raw.vmsize);
      seg->fileoff = bfd_h_get_64 (abfd, raw.fileoff);
      seg->filesize = bfd_h_get_64 (abfd, raw.filesize);
      seg->maxprot = bfd_h_get_32 (abfd, raw.maxprot);
      seg->initprot = bfd_h_get_32 (abfd, raw.initprot);
      seg->nsects = bfd_h_get_32 (abfd, raw.nsects);
      seg->flags = bfd_h_get_32 (abfd, raw.flags);
    }
  else
    {
      struct mach_o_segment_command_32_external raw;

      BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT);

      if (bfd_seek (abfd, command->offset + BFD_MACH_O_LC_SIZE, SEEK_SET) != 0
          || bfd_bread (&raw, sizeof (raw), abfd) != sizeof (raw))
        return -1;

      memcpy (seg->segname, raw.segname, 16);
      seg->segname[16] = '\0';

      seg->vmaddr = bfd_h_get_32 (abfd, raw.vmaddr);
      seg->vmsize = bfd_h_get_32 (abfd, raw.vmsize);
      seg->fileoff = bfd_h_get_32 (abfd, raw.fileoff);
      seg->filesize = bfd_h_get_32 (abfd, raw.filesize);
      seg->maxprot = bfd_h_get_32 (abfd, raw.maxprot);
      seg->initprot = bfd_h_get_32 (abfd, raw.initprot);
      seg->nsects = bfd_h_get_32 (abfd, raw.nsects);
      seg->flags = bfd_h_get_32 (abfd, raw.flags);
    }
  seg->sect_head = NULL;
  seg->sect_tail = NULL;

  for (i = 0; i < seg->nsects; i++)
    {
      bfd_vma segoff;
      asection *sec;

      if (wide)
        segoff = command->offset + BFD_MACH_O_LC_SEGMENT_64_SIZE
          + (i * BFD_MACH_O_SECTION_64_SIZE);
      else
        segoff = command->offset + BFD_MACH_O_LC_SEGMENT_SIZE
          + (i * BFD_MACH_O_SECTION_SIZE);

      sec = bfd_mach_o_read_section (abfd, segoff, seg->initprot, wide);
      if (sec == NULL)
        return -1;

      bfd_mach_o_append_section_to_segment (seg, sec);
    }

  return 0;
}

static int
bfd_mach_o_read_segment_32 (bfd *abfd, bfd_mach_o_load_command *command)
{
  return bfd_mach_o_read_segment (abfd, command, 0);
}

static int
bfd_mach_o_read_segment_64 (bfd *abfd, bfd_mach_o_load_command *command)
{
  return bfd_mach_o_read_segment (abfd, command, 1);
}

static int
bfd_mach_o_read_command (bfd *abfd, bfd_mach_o_load_command *command)
{
  struct mach_o_load_command_external raw;
  unsigned int cmd;

  /* Read command type and length.  */
  if (bfd_seek (abfd, command->offset, SEEK_SET) != 0
      || bfd_bread (&raw, BFD_MACH_O_LC_SIZE, abfd) != BFD_MACH_O_LC_SIZE)
    return -1;

  cmd = bfd_h_get_32 (abfd, raw.cmd);
  command->type =  cmd & ~BFD_MACH_O_LC_REQ_DYLD;
  command->type_required = cmd & BFD_MACH_O_LC_REQ_DYLD ? TRUE : FALSE;
  command->len = bfd_h_get_32 (abfd, raw.cmdsize);

  switch (command->type)
    {
    case BFD_MACH_O_LC_SEGMENT:
      if (bfd_mach_o_read_segment_32 (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_SEGMENT_64:
      if (bfd_mach_o_read_segment_64 (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_SYMTAB:
      if (bfd_mach_o_read_symtab (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_SYMSEG:
      break;
    case BFD_MACH_O_LC_THREAD:
    case BFD_MACH_O_LC_UNIXTHREAD:
      if (bfd_mach_o_read_thread (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_LOAD_DYLINKER:
    case BFD_MACH_O_LC_ID_DYLINKER:
      if (bfd_mach_o_read_dylinker (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_LOAD_DYLIB:
    case BFD_MACH_O_LC_ID_DYLIB:
    case BFD_MACH_O_LC_LOAD_WEAK_DYLIB:
    case BFD_MACH_O_LC_REEXPORT_DYLIB:
    case BFD_MACH_O_LC_LOAD_UPWARD_DYLIB:
      if (bfd_mach_o_read_dylib (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_PREBOUND_DYLIB:
      if (bfd_mach_o_read_prebound_dylib (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_LOADFVMLIB:
    case BFD_MACH_O_LC_IDFVMLIB:
      if (bfd_mach_o_read_fvmlib (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_IDENT:
    case BFD_MACH_O_LC_FVMFILE:
    case BFD_MACH_O_LC_PREPAGE:
    case BFD_MACH_O_LC_ROUTINES:
    case BFD_MACH_O_LC_ROUTINES_64:
      break;
    case BFD_MACH_O_LC_SUB_FRAMEWORK:
    case BFD_MACH_O_LC_SUB_UMBRELLA:
    case BFD_MACH_O_LC_SUB_LIBRARY:
    case BFD_MACH_O_LC_SUB_CLIENT:
    case BFD_MACH_O_LC_RPATH:
      if (bfd_mach_o_read_str (abfd, command) != 0)
        return -1;
      break;
    case BFD_MACH_O_LC_DYSYMTAB:
      if (bfd_mach_o_read_dysymtab (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_TWOLEVEL_HINTS:
    case BFD_MACH_O_LC_PREBIND_CKSUM:
      break;
    case BFD_MACH_O_LC_UUID:
      if (bfd_mach_o_read_uuid (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_CODE_SIGNATURE:
    case BFD_MACH_O_LC_SEGMENT_SPLIT_INFO:
    case BFD_MACH_O_LC_FUNCTION_STARTS:
    case BFD_MACH_O_LC_DATA_IN_CODE:
    case BFD_MACH_O_LC_DYLIB_CODE_SIGN_DRS:
      if (bfd_mach_o_read_linkedit (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_ENCRYPTION_INFO:
      if (!bfd_mach_o_read_encryption_info (abfd, command))
	return -1;
      break;
    case BFD_MACH_O_LC_DYLD_INFO:
      if (bfd_mach_o_read_dyld_info (abfd, command) != 0)
	return -1;
      break;
    case BFD_MACH_O_LC_VERSION_MIN_MACOSX:
    case BFD_MACH_O_LC_VERSION_MIN_IPHONEOS:
      if (!bfd_mach_o_read_version_min (abfd, command))
	return -1;
      break;
    case BFD_MACH_O_LC_MAIN:
      if (!bfd_mach_o_read_main (abfd, command))
	return -1;
      break;
    case BFD_MACH_O_LC_SOURCE_VERSION:
      if (!bfd_mach_o_read_source_version (abfd, command))
	return -1;
      break;
    default:
      (*_bfd_error_handler)(_("%B: unknown load command 0x%lx"),
         abfd, (unsigned long) command->type);
      break;
    }

  return 0;
}

static void
bfd_mach_o_flatten_sections (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  long csect = 0;
  unsigned long i;

  /* Count total number of sections.  */
  mdata->nsects = 0;

  for (i = 0; i < mdata->header.ncmds; i++)
    {
      if (mdata->commands[i].type == BFD_MACH_O_LC_SEGMENT
	  || mdata->commands[i].type == BFD_MACH_O_LC_SEGMENT_64)
	{
	  bfd_mach_o_segment_command *seg;

	  seg = &mdata->commands[i].command.segment;
	  mdata->nsects += seg->nsects;
	}
    }

  /* Allocate sections array.  */
  mdata->sections = bfd_alloc (abfd,
			       mdata->nsects * sizeof (bfd_mach_o_section *));

  /* Fill the array.  */
  csect = 0;

  for (i = 0; i < mdata->header.ncmds; i++)
    {
      if (mdata->commands[i].type == BFD_MACH_O_LC_SEGMENT
	  || mdata->commands[i].type == BFD_MACH_O_LC_SEGMENT_64)
	{
	  bfd_mach_o_segment_command *seg;
          bfd_mach_o_section *sec;

	  seg = &mdata->commands[i].command.segment;
	  BFD_ASSERT (csect + seg->nsects <= mdata->nsects);

          for (sec = seg->sect_head; sec != NULL; sec = sec->next)
	    mdata->sections[csect++] = sec;
	}
    }
}

static bfd_boolean
bfd_mach_o_scan_start_address (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  bfd_mach_o_thread_command *cmd = NULL;
  unsigned long i;

  for (i = 0; i < mdata->header.ncmds; i++)
    if ((mdata->commands[i].type == BFD_MACH_O_LC_THREAD) ||
        (mdata->commands[i].type == BFD_MACH_O_LC_UNIXTHREAD))
      {
        cmd = &mdata->commands[i].command.thread;
        break;
      }
    else if (mdata->commands[i].type == BFD_MACH_O_LC_MAIN
	     && mdata->nsects > 1)
      {
	bfd_mach_o_main_command *main_cmd = &mdata->commands[i].command.main;
	bfd_mach_o_section *text_sect = mdata->sections[0];
	if (text_sect)
	  {
	    abfd->start_address = main_cmd->entryoff
	      + (text_sect->addr - text_sect->offset);
	    return TRUE;
	  }
      }

  /* An object file has no start address, so do not fail if not found.  */
  if (cmd == NULL)
    return TRUE;

  /* FIXME: create a subtarget hook ?  */
  for (i = 0; i < cmd->nflavours; i++)
    {
      if ((mdata->header.cputype == BFD_MACH_O_CPU_TYPE_I386)
	  && (cmd->flavours[i].flavour
	      == (unsigned long) BFD_MACH_O_x86_THREAD_STATE32))
	{
	  unsigned char buf[4];

	  if (bfd_seek (abfd, cmd->flavours[i].offset + 40, SEEK_SET) != 0
              || bfd_bread (buf, 4, abfd) != 4)
	    return FALSE;

	  abfd->start_address = bfd_h_get_32 (abfd, buf);
	}
      else if ((mdata->header.cputype == BFD_MACH_O_CPU_TYPE_POWERPC)
	       && (cmd->flavours[i].flavour == BFD_MACH_O_PPC_THREAD_STATE))
	{
	  unsigned char buf[4];

	  if (bfd_seek (abfd, cmd->flavours[i].offset + 0, SEEK_SET) != 0
              || bfd_bread (buf, 4, abfd) != 4)
	    return FALSE;

	  abfd->start_address = bfd_h_get_32 (abfd, buf);
	}
      else if ((mdata->header.cputype == BFD_MACH_O_CPU_TYPE_POWERPC_64)
               && (cmd->flavours[i].flavour == BFD_MACH_O_PPC_THREAD_STATE64))
        {
          unsigned char buf[8];

          if (bfd_seek (abfd, cmd->flavours[i].offset + 0, SEEK_SET) != 0
              || bfd_bread (buf, 8, abfd) != 8)
            return FALSE;

          abfd->start_address = bfd_h_get_64 (abfd, buf);
        }
      else if ((mdata->header.cputype == BFD_MACH_O_CPU_TYPE_X86_64)
               && (cmd->flavours[i].flavour == BFD_MACH_O_x86_THREAD_STATE64))
        {
          unsigned char buf[8];

          if (bfd_seek (abfd, cmd->flavours[i].offset + (16 * 8), SEEK_SET) != 0
              || bfd_bread (buf, 8, abfd) != 8)
            return FALSE;

          abfd->start_address = bfd_h_get_64 (abfd, buf);
        }
    }

  return TRUE;
}

bfd_boolean
bfd_mach_o_set_arch_mach (bfd *abfd,
                          enum bfd_architecture arch,
                          unsigned long machine)
{
  bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);

  /* If this isn't the right architecture for this backend, and this
     isn't the generic backend, fail.  */
  if (arch != bed->arch
      && arch != bfd_arch_unknown
      && bed->arch != bfd_arch_unknown)
    return FALSE;

  return bfd_default_set_arch_mach (abfd, arch, machine);
}

static bfd_boolean
bfd_mach_o_scan (bfd *abfd,
		 bfd_mach_o_header *header,
		 bfd_mach_o_data_struct *mdata)
{
  unsigned int i;
  enum bfd_architecture cputype;
  unsigned long cpusubtype;
  unsigned int hdrsize;

  hdrsize = mach_o_wide_p (header) ?
    BFD_MACH_O_HEADER_64_SIZE : BFD_MACH_O_HEADER_SIZE;

  mdata->header = *header;

  abfd->flags = abfd->flags & BFD_IN_MEMORY;
  switch (header->filetype)
    {
    case BFD_MACH_O_MH_OBJECT:
      abfd->flags |= HAS_RELOC;
      break;
    case BFD_MACH_O_MH_EXECUTE:
      abfd->flags |= EXEC_P;
      break;
    case BFD_MACH_O_MH_DYLIB:
    case BFD_MACH_O_MH_BUNDLE:
      abfd->flags |= DYNAMIC;
      break;
    }

  abfd->tdata.mach_o_data = mdata;

  bfd_mach_o_convert_architecture (header->cputype, header->cpusubtype,
				   &cputype, &cpusubtype);
  if (cputype == bfd_arch_unknown)
    {
      (*_bfd_error_handler)
        (_("bfd_mach_o_scan: unknown architecture 0x%lx/0x%lx"),
         header->cputype, header->cpusubtype);
      return FALSE;
    }

  bfd_set_arch_mach (abfd, cputype, cpusubtype);

  if (header->ncmds != 0)
    {
      mdata->commands = bfd_alloc
        (abfd, header->ncmds * sizeof (bfd_mach_o_load_command));
      if (mdata->commands == NULL)
	return FALSE;

      for (i = 0; i < header->ncmds; i++)
	{
	  bfd_mach_o_load_command *cur = &mdata->commands[i];

	  if (i == 0)
	    cur->offset = hdrsize;
	  else
	    {
	      bfd_mach_o_load_command *prev = &mdata->commands[i - 1];
	      cur->offset = prev->offset + prev->len;
	    }

	  if (bfd_mach_o_read_command (abfd, cur) < 0)
	    return FALSE;
	}
    }

  /* Sections should be flatten before scanning start address.  */
  bfd_mach_o_flatten_sections (abfd);
  if (!bfd_mach_o_scan_start_address (abfd))
    return FALSE;

  return TRUE;
}

bfd_boolean
bfd_mach_o_mkobject_init (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = NULL;

  mdata = bfd_alloc (abfd, sizeof (bfd_mach_o_data_struct));
  if (mdata == NULL)
    return FALSE;
  abfd->tdata.mach_o_data = mdata;

  mdata->header.magic = 0;
  mdata->header.cputype = 0;
  mdata->header.cpusubtype = 0;
  mdata->header.filetype = 0;
  mdata->header.ncmds = 0;
  mdata->header.sizeofcmds = 0;
  mdata->header.flags = 0;
  mdata->header.byteorder = BFD_ENDIAN_UNKNOWN;
  mdata->commands = NULL;
  mdata->nsects = 0;
  mdata->sections = NULL;
  mdata->dyn_reloc_cache = NULL;

  return TRUE;
}

static bfd_boolean
bfd_mach_o_gen_mkobject (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata;

  if (!bfd_mach_o_mkobject_init (abfd))
    return FALSE;

  mdata = bfd_mach_o_get_data (abfd);
  mdata->header.magic = BFD_MACH_O_MH_MAGIC;
  mdata->header.cputype = 0;
  mdata->header.cpusubtype = 0;
  mdata->header.byteorder = abfd->xvec->byteorder;
  mdata->header.version = 1;

  return TRUE;
}

const bfd_target *
bfd_mach_o_header_p (bfd *abfd,
                     bfd_mach_o_filetype filetype,
                     bfd_mach_o_cpu_type cputype)
{
  bfd_mach_o_header header;
  bfd_mach_o_data_struct *mdata;

  if (!bfd_mach_o_read_header (abfd, &header))
    goto wrong;

  if (! (header.byteorder == BFD_ENDIAN_BIG
	 || header.byteorder == BFD_ENDIAN_LITTLE))
    {
      (*_bfd_error_handler) (_("unknown header byte-order value 0x%lx"),
			     (unsigned long) header.byteorder);
      goto wrong;
    }

  if (! ((header.byteorder == BFD_ENDIAN_BIG
	  && abfd->xvec->byteorder == BFD_ENDIAN_BIG
	  && abfd->xvec->header_byteorder == BFD_ENDIAN_BIG)
	 || (header.byteorder == BFD_ENDIAN_LITTLE
	     && abfd->xvec->byteorder == BFD_ENDIAN_LITTLE
	     && abfd->xvec->header_byteorder == BFD_ENDIAN_LITTLE)))
    goto wrong;

  /* Check cputype and filetype.
     In case of wildcard, do not accept magics that are handled by existing
     targets.  */
  if (cputype)
    {
      if (header.cputype != cputype)
        goto wrong;
    }

  if (filetype)
    {
      if (header.filetype != filetype)
        goto wrong;
    }
  else
    {
      switch (header.filetype)
        {
        case BFD_MACH_O_MH_CORE:
          /* Handled by core_p */
          goto wrong;
        default:
          break;
        }
    }

  mdata = (bfd_mach_o_data_struct *) bfd_zalloc (abfd, sizeof (*mdata));
  if (mdata == NULL)
    goto fail;

  if (!bfd_mach_o_scan (abfd, &header, mdata))
    goto wrong;

  return abfd->xvec;

 wrong:
  bfd_set_error (bfd_error_wrong_format);

 fail:
  return NULL;
}

static const bfd_target *
bfd_mach_o_gen_object_p (bfd *abfd)
{
  return bfd_mach_o_header_p (abfd, 0, 0);
}

static const bfd_target *
bfd_mach_o_gen_core_p (bfd *abfd)
{
  return bfd_mach_o_header_p (abfd, BFD_MACH_O_MH_CORE, 0);
}

typedef struct mach_o_fat_archentry
{
  unsigned long cputype;
  unsigned long cpusubtype;
  unsigned long offset;
  unsigned long size;
  unsigned long align;
} mach_o_fat_archentry;

typedef struct mach_o_fat_data_struct
{
  unsigned long magic;
  unsigned long nfat_arch;
  mach_o_fat_archentry *archentries;
} mach_o_fat_data_struct;

const bfd_target *
bfd_mach_o_archive_p (bfd *abfd)
{
  mach_o_fat_data_struct *adata = NULL;
  struct mach_o_fat_header_external hdr;
  unsigned long i;

  if (bfd_seek (abfd, 0, SEEK_SET) != 0
      || bfd_bread (&hdr, sizeof (hdr), abfd) != sizeof (hdr))
    goto error;

  adata = bfd_alloc (abfd, sizeof (mach_o_fat_data_struct));
  if (adata == NULL)
    goto error;

  adata->magic = bfd_getb32 (hdr.magic);
  adata->nfat_arch = bfd_getb32 (hdr.nfat_arch);
  if (adata->magic != 0xcafebabe)
    goto error;
  /* Avoid matching Java bytecode files, which have the same magic number.
     In the Java bytecode file format this field contains the JVM version,
     which starts at 43.0.  */
  if (adata->nfat_arch > 30)
    goto error;

  adata->archentries =
    bfd_alloc (abfd, adata->nfat_arch * sizeof (mach_o_fat_archentry));
  if (adata->archentries == NULL)
    goto error;

  for (i = 0; i < adata->nfat_arch; i++)
    {
      struct mach_o_fat_arch_external arch;
      if (bfd_bread (&arch, sizeof (arch), abfd) != sizeof (arch))
	goto error;
      adata->archentries[i].cputype = bfd_getb32 (arch.cputype);
      adata->archentries[i].cpusubtype = bfd_getb32 (arch.cpusubtype);
      adata->archentries[i].offset = bfd_getb32 (arch.offset);
      adata->archentries[i].size = bfd_getb32 (arch.size);
      adata->archentries[i].align = bfd_getb32 (arch.align);
    }

  abfd->tdata.mach_o_fat_data = adata;
  return abfd->xvec;

 error:
  if (adata != NULL)
    bfd_release (abfd, adata);
  bfd_set_error (bfd_error_wrong_format);
  return NULL;
}

/* Set the filename for a fat binary member ABFD, whose bfd architecture is
   ARCH_TYPE/ARCH_SUBTYPE and corresponding entry in header is ENTRY.
   Set arelt_data and origin fields too.  */

static void
bfd_mach_o_fat_member_init (bfd *abfd,
                            enum bfd_architecture arch_type,
                            unsigned long arch_subtype,
                            mach_o_fat_archentry *entry)
{
  struct areltdata *areltdata;
  /* Create the member filename. Use ARCH_NAME.  */
  const bfd_arch_info_type *ap = bfd_lookup_arch (arch_type, arch_subtype);

  if (ap)
    {
      /* Use the architecture name if known.  */
      abfd->filename = ap->printable_name;
    }
  else
    {
      /* Forge a uniq id.  */
      const size_t namelen = 2 + 8 + 1 + 2 + 8 + 1;
      char *name = bfd_alloc (abfd, namelen);
      snprintf (name, namelen, "0x%lx-0x%lx",
                entry->cputype, entry->cpusubtype);
      abfd->filename = name;
    }

  areltdata = bfd_zmalloc (sizeof (struct areltdata));
  areltdata->parsed_size = entry->size;
  abfd->arelt_data = areltdata;
  abfd->iostream = NULL;
  abfd->origin = entry->offset;
}

bfd *
bfd_mach_o_openr_next_archived_file (bfd *archive, bfd *prev)
{
  mach_o_fat_data_struct *adata;
  mach_o_fat_archentry *entry = NULL;
  unsigned long i;
  bfd *nbfd;
  enum bfd_architecture arch_type;
  unsigned long arch_subtype;

  adata = (mach_o_fat_data_struct *) archive->tdata.mach_o_fat_data;
  BFD_ASSERT (adata != NULL);

  /* Find index of previous entry.  */
  if (prev == NULL)
    {
      /* Start at first one.  */
      i = 0;
    }
  else
    {
      /* Find index of PREV.  */
      for (i = 0; i < adata->nfat_arch; i++)
	{
	  if (adata->archentries[i].offset == prev->origin)
	    break;
	}

      if (i == adata->nfat_arch)
	{
	  /* Not found.  */
	  bfd_set_error (bfd_error_bad_value);
	  return NULL;
	}

      /* Get next entry.  */
      i++;
    }

  if (i >= adata->nfat_arch)
    {
      bfd_set_error (bfd_error_no_more_archived_files);
      return NULL;
    }

  entry = &adata->archentries[i];
  nbfd = _bfd_new_bfd_contained_in (archive);
  if (nbfd == NULL)
    return NULL;

  bfd_mach_o_convert_architecture (entry->cputype, entry->cpusubtype,
				   &arch_type, &arch_subtype);

  bfd_mach_o_fat_member_init (nbfd, arch_type, arch_subtype, entry);

  bfd_set_arch_mach (nbfd, arch_type, arch_subtype);

  return nbfd;
}

/* Analogous to stat call.  */

static int
bfd_mach_o_fat_stat_arch_elt (bfd *abfd, struct stat *buf)
{
  if (abfd->arelt_data == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return -1;
    }

  buf->st_mtime = 0;
  buf->st_uid = 0;
  buf->st_gid = 0;
  buf->st_mode = 0644;
  buf->st_size = arelt_size (abfd);

  return 0;
}

/* If ABFD format is FORMAT and architecture is ARCH, return it.
   If ABFD is a fat image containing a member that corresponds to FORMAT
   and ARCH, returns it.
   In other case, returns NULL.
   This function allows transparent uses of fat images.  */

bfd *
bfd_mach_o_fat_extract (bfd *abfd,
			bfd_format format,
			const bfd_arch_info_type *arch)
{
  bfd *res;
  mach_o_fat_data_struct *adata;
  unsigned int i;

  if (bfd_check_format (abfd, format))
    {
      if (bfd_get_arch_info (abfd) == arch)
	return abfd;
      return NULL;
    }
  if (!bfd_check_format (abfd, bfd_archive)
      || abfd->xvec != &mach_o_fat_vec)
    return NULL;

  /* This is a Mach-O fat image.  */
  adata = (mach_o_fat_data_struct *) abfd->tdata.mach_o_fat_data;
  BFD_ASSERT (adata != NULL);

  for (i = 0; i < adata->nfat_arch; i++)
    {
      struct mach_o_fat_archentry *e = &adata->archentries[i];
      enum bfd_architecture cpu_type;
      unsigned long cpu_subtype;

      bfd_mach_o_convert_architecture (e->cputype, e->cpusubtype,
				       &cpu_type, &cpu_subtype);
      if (cpu_type != arch->arch || cpu_subtype != arch->mach)
	continue;

      /* The architecture is found.  */
      res = _bfd_new_bfd_contained_in (abfd);
      if (res == NULL)
	return NULL;

      bfd_mach_o_fat_member_init (res, cpu_type, cpu_subtype, e);

      if (bfd_check_format (res, format))
	{
	  BFD_ASSERT (bfd_get_arch_info (res) == arch);
	  return res;
	}
      bfd_close (res);
      return NULL;
    }

  return NULL;
}

int
bfd_mach_o_lookup_command (bfd *abfd,
			   bfd_mach_o_load_command_type type,
			   bfd_mach_o_load_command **mcommand)
{
  struct mach_o_data_struct *md = bfd_mach_o_get_data (abfd);
  bfd_mach_o_load_command *ncmd = NULL;
  unsigned int i, num;

  BFD_ASSERT (md != NULL);
  BFD_ASSERT (mcommand != NULL);

  num = 0;
  for (i = 0; i < md->header.ncmds; i++)
    {
      struct bfd_mach_o_load_command *cmd = &md->commands[i];

      if (cmd->type != type)
	continue;

      if (num == 0)
	ncmd = cmd;
      num++;
    }

  *mcommand = ncmd;
  return num;
}

unsigned long
bfd_mach_o_stack_addr (enum bfd_mach_o_cpu_type type)
{
  switch (type)
    {
    case BFD_MACH_O_CPU_TYPE_MC680x0:
      return 0x04000000;
    case BFD_MACH_O_CPU_TYPE_MC88000:
      return 0xffffe000;
    case BFD_MACH_O_CPU_TYPE_POWERPC:
      return 0xc0000000;
    case BFD_MACH_O_CPU_TYPE_I386:
      return 0xc0000000;
    case BFD_MACH_O_CPU_TYPE_SPARC:
      return 0xf0000000;
    case BFD_MACH_O_CPU_TYPE_I860:
      return 0;
    case BFD_MACH_O_CPU_TYPE_HPPA:
      return 0xc0000000 - 0x04000000;
    default:
      return 0;
    }
}

/* The following two tables should be kept, as far as possible, in order of
   most frequently used entries to optimize their use from gas.  */

const bfd_mach_o_xlat_name bfd_mach_o_section_type_name[] =
{
  { "regular", BFD_MACH_O_S_REGULAR},
  { "coalesced", BFD_MACH_O_S_COALESCED},
  { "zerofill", BFD_MACH_O_S_ZEROFILL},
  { "cstring_literals", BFD_MACH_O_S_CSTRING_LITERALS},
  { "4byte_literals", BFD_MACH_O_S_4BYTE_LITERALS},
  { "8byte_literals", BFD_MACH_O_S_8BYTE_LITERALS},
  { "16byte_literals", BFD_MACH_O_S_16BYTE_LITERALS},
  { "literal_pointers", BFD_MACH_O_S_LITERAL_POINTERS},
  { "mod_init_func_pointers", BFD_MACH_O_S_MOD_INIT_FUNC_POINTERS},
  { "mod_fini_func_pointers", BFD_MACH_O_S_MOD_FINI_FUNC_POINTERS},
  { "gb_zerofill", BFD_MACH_O_S_GB_ZEROFILL},
  { "interposing", BFD_MACH_O_S_INTERPOSING},
  { "dtrace_dof", BFD_MACH_O_S_DTRACE_DOF},
  { "non_lazy_symbol_pointers", BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS},
  { "lazy_symbol_pointers", BFD_MACH_O_S_LAZY_SYMBOL_POINTERS},
  { "symbol_stubs", BFD_MACH_O_S_SYMBOL_STUBS},
  { "lazy_dylib_symbol_pointers", BFD_MACH_O_S_LAZY_DYLIB_SYMBOL_POINTERS},
  { NULL, 0}
};

const bfd_mach_o_xlat_name bfd_mach_o_section_attribute_name[] =
{
  { "pure_instructions", BFD_MACH_O_S_ATTR_PURE_INSTRUCTIONS },
  { "some_instructions", BFD_MACH_O_S_ATTR_SOME_INSTRUCTIONS },
  { "loc_reloc", BFD_MACH_O_S_ATTR_LOC_RELOC },
  { "ext_reloc", BFD_MACH_O_S_ATTR_EXT_RELOC },
  { "debug", BFD_MACH_O_S_ATTR_DEBUG },
  { "live_support", BFD_MACH_O_S_ATTR_LIVE_SUPPORT },
  { "no_dead_strip", BFD_MACH_O_S_ATTR_NO_DEAD_STRIP },
  { "strip_static_syms", BFD_MACH_O_S_ATTR_STRIP_STATIC_SYMS },
  { "no_toc", BFD_MACH_O_S_ATTR_NO_TOC },
  { "self_modifying_code", BFD_MACH_O_S_SELF_MODIFYING_CODE },
  { "modifying_code", BFD_MACH_O_S_SELF_MODIFYING_CODE },
  { NULL, 0}
};

/* Get the section type from NAME.  Return 256 if NAME is unknown.  */

unsigned int
bfd_mach_o_get_section_type_from_name (bfd *abfd, const char *name)
{
  const bfd_mach_o_xlat_name *x;
  bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);

  for (x = bfd_mach_o_section_type_name; x->name; x++)
    if (strcmp (x->name, name) == 0)
      {
	/* We found it... does the target support it?  */
	if (bed->bfd_mach_o_section_type_valid_for_target == NULL
	    || bed->bfd_mach_o_section_type_valid_for_target (x->val))
	  return x->val; /* OK.  */
	else
	  break; /* Not supported.  */
      }
  /* Maximum section ID = 0xff.  */
  return 256;
}

/* Get the section attribute from NAME.  Return -1 if NAME is unknown.  */

unsigned int
bfd_mach_o_get_section_attribute_from_name (const char *name)
{
  const bfd_mach_o_xlat_name *x;

  for (x = bfd_mach_o_section_attribute_name; x->name; x++)
    if (strcmp (x->name, name) == 0)
      return x->val;
  return (unsigned int)-1;
}

int
bfd_mach_o_core_fetch_environment (bfd *abfd,
				   unsigned char **rbuf,
				   unsigned int *rlen)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  unsigned long stackaddr = bfd_mach_o_stack_addr (mdata->header.cputype);
  unsigned int i = 0;

  for (i = 0; i < mdata->header.ncmds; i++)
    {
      bfd_mach_o_load_command *cur = &mdata->commands[i];
      bfd_mach_o_segment_command *seg = NULL;

      if (cur->type != BFD_MACH_O_LC_SEGMENT)
	continue;

      seg = &cur->command.segment;

      if ((seg->vmaddr + seg->vmsize) == stackaddr)
	{
	  unsigned long start = seg->fileoff;
	  unsigned long end = seg->fileoff + seg->filesize;
	  unsigned char *buf = bfd_malloc (1024);
	  unsigned long size = 1024;

	  for (;;)
	    {
	      bfd_size_type nread = 0;
	      unsigned long offset;
	      int found_nonnull = 0;

	      if (size > (end - start))
		size = (end - start);

	      buf = bfd_realloc_or_free (buf, size);
	      if (buf == NULL)
		return -1;

	      if (bfd_seek (abfd, end - size, SEEK_SET) != 0)
                {
                  free (buf);
                  return -1;
                }

	      nread = bfd_bread (buf, size, abfd);

	      if (nread != size)
		{
		  free (buf);
		  return -1;
		}

	      for (offset = 4; offset <= size; offset += 4)
		{
		  unsigned long val;

		  val = *((unsigned long *) (buf + size - offset));
		  if (! found_nonnull)
		    {
		      if (val != 0)
			found_nonnull = 1;
		    }
		  else if (val == 0x0)
		    {
		      unsigned long bottom;
		      unsigned long top;

		      bottom = seg->fileoff + seg->filesize - offset;
		      top = seg->fileoff + seg->filesize - 4;
		      *rbuf = bfd_malloc (top - bottom);
		      *rlen = top - bottom;

		      memcpy (*rbuf, buf + size - *rlen, *rlen);
		      free (buf);
		      return 0;
		    }
		}

	      if (size == (end - start))
		break;

	      size *= 2;
	    }

	  free (buf);
	}
    }

  return -1;
}

char *
bfd_mach_o_core_file_failing_command (bfd *abfd)
{
  unsigned char *buf = NULL;
  unsigned int len = 0;
  int ret = -1;

  ret = bfd_mach_o_core_fetch_environment (abfd, &buf, &len);
  if (ret < 0)
    return NULL;

  return (char *) buf;
}

int
bfd_mach_o_core_file_failing_signal (bfd *abfd ATTRIBUTE_UNUSED)
{
  return 0;
}

static bfd_mach_o_uuid_command *
bfd_mach_o_lookup_uuid_command (bfd *abfd)
{
  bfd_mach_o_load_command *uuid_cmd;
  int ncmd = bfd_mach_o_lookup_command (abfd, BFD_MACH_O_LC_UUID, &uuid_cmd);
  if (ncmd != 1)
    return FALSE;
  return &uuid_cmd->command.uuid;
}

/* Return true if ABFD is a dSYM file and its UUID matches UUID_CMD. */

static bfd_boolean
bfd_mach_o_dsym_for_uuid_p (bfd *abfd, const bfd_mach_o_uuid_command *uuid_cmd)
{
  bfd_mach_o_uuid_command *dsym_uuid_cmd;

  BFD_ASSERT (abfd);
  BFD_ASSERT (uuid_cmd);

  if (!bfd_check_format (abfd, bfd_object))
    return FALSE;

  if (bfd_get_flavour (abfd) != bfd_target_mach_o_flavour
      || bfd_mach_o_get_data (abfd) == NULL
      || bfd_mach_o_get_data (abfd)->header.filetype != BFD_MACH_O_MH_DSYM)
    return FALSE;

  dsym_uuid_cmd = bfd_mach_o_lookup_uuid_command (abfd);
  if (dsym_uuid_cmd == NULL)
    return FALSE;

  if (memcmp (uuid_cmd->uuid, dsym_uuid_cmd->uuid,
              sizeof (uuid_cmd->uuid)) != 0)
    return FALSE;

  return TRUE;
}

/* Find a BFD in DSYM_FILENAME which matches ARCH and UUID_CMD.
   The caller is responsible for closing the returned BFD object and
   its my_archive if the returned BFD is in a fat dSYM. */

static bfd *
bfd_mach_o_find_dsym (const char *dsym_filename,
                      const bfd_mach_o_uuid_command *uuid_cmd,
                      const bfd_arch_info_type *arch)
{
  bfd *base_dsym_bfd, *dsym_bfd;

  BFD_ASSERT (uuid_cmd);

  base_dsym_bfd = bfd_openr (dsym_filename, NULL);
  if (base_dsym_bfd == NULL)
    return NULL;

  dsym_bfd = bfd_mach_o_fat_extract (base_dsym_bfd, bfd_object, arch);
  if (bfd_mach_o_dsym_for_uuid_p (dsym_bfd, uuid_cmd))
    return dsym_bfd;

  bfd_close (dsym_bfd);
  if (base_dsym_bfd != dsym_bfd)
    bfd_close (base_dsym_bfd);

  return NULL;
}

/* Return a BFD created from a dSYM file for ABFD.
   The caller is responsible for closing the returned BFD object, its
   filename, and its my_archive if the returned BFD is in a fat dSYM. */

static bfd *
bfd_mach_o_follow_dsym (bfd *abfd)
{
  char *dsym_filename;
  bfd_mach_o_uuid_command *uuid_cmd;
  bfd *dsym_bfd, *base_bfd = abfd;
  const char *base_basename;

  if (abfd == NULL || bfd_get_flavour (abfd) != bfd_target_mach_o_flavour)
    return NULL;

  if (abfd->my_archive)
    base_bfd = abfd->my_archive;
  /* BFD may have been opened from a stream. */
  if (base_bfd->filename == NULL)
    {
      bfd_set_error (bfd_error_invalid_operation);
      return NULL;
    }
  base_basename = lbasename (base_bfd->filename);

  uuid_cmd = bfd_mach_o_lookup_uuid_command (abfd);
  if (uuid_cmd == NULL)
    return NULL;

  /* TODO: We assume the DWARF file has the same as the binary's.
     It seems apple's GDB checks all files in the dSYM bundle directory.
     http://opensource.apple.com/source/gdb/gdb-1708/src/gdb/macosx/macosx-tdep.c
  */
  dsym_filename = (char *)bfd_malloc (strlen (base_bfd->filename)
                                       + strlen (dsym_subdir) + 1
                                       + strlen (base_basename) + 1);
  sprintf (dsym_filename, "%s%s/%s",
           base_bfd->filename, dsym_subdir, base_basename);

  dsym_bfd = bfd_mach_o_find_dsym (dsym_filename, uuid_cmd,
                                   bfd_get_arch_info (abfd));
  if (dsym_bfd == NULL)
    free (dsym_filename);

  return dsym_bfd;
}

bfd_boolean
bfd_mach_o_find_nearest_line (bfd *abfd,
			      asection *section,
			      asymbol **symbols,
			      bfd_vma offset,
			      const char **filename_ptr,
			      const char **functionname_ptr,
			      unsigned int *line_ptr)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  if (mdata == NULL)
    return FALSE;
  switch (mdata->header.filetype)
    {
    case BFD_MACH_O_MH_OBJECT:
      break;
    case BFD_MACH_O_MH_EXECUTE:
    case BFD_MACH_O_MH_DYLIB:
    case BFD_MACH_O_MH_BUNDLE:
    case BFD_MACH_O_MH_KEXT_BUNDLE:
      if (mdata->dwarf2_find_line_info == NULL)
        {
          mdata->dsym_bfd = bfd_mach_o_follow_dsym (abfd);
          /* When we couldn't find dSYM for this binary, we look for
             the debug information in the binary itself. In this way,
             we won't try finding separated dSYM again because
             mdata->dwarf2_find_line_info will be filled. */
          if (! mdata->dsym_bfd)
            break;
          if (! _bfd_dwarf2_slurp_debug_info (abfd, mdata->dsym_bfd,
                                              dwarf_debug_sections, symbols,
                                              &mdata->dwarf2_find_line_info))
            return FALSE;
        }
      break;
    default:
      return FALSE;
    }
  if (_bfd_dwarf2_find_nearest_line (abfd, dwarf_debug_sections,
				     section, symbols, offset,
				     filename_ptr, functionname_ptr,
				     line_ptr, NULL, 0,
				     &mdata->dwarf2_find_line_info))
    return TRUE;
  return FALSE;
}

bfd_boolean
bfd_mach_o_close_and_cleanup (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  if (bfd_get_format (abfd) == bfd_object && mdata != NULL)
    {
      _bfd_dwarf2_cleanup_debug_info (abfd, &mdata->dwarf2_find_line_info);
      bfd_mach_o_free_cached_info (abfd);
      if (mdata->dsym_bfd != NULL)
        {
          bfd *fat_bfd = mdata->dsym_bfd->my_archive;
          char *dsym_filename = (char *)(fat_bfd
                                         ? fat_bfd->filename
                                         : mdata->dsym_bfd->filename);
          bfd_close (mdata->dsym_bfd);
          mdata->dsym_bfd = NULL;
          if (fat_bfd)
            bfd_close (fat_bfd);
          free (dsym_filename);
        }
    }

  if (bfd_get_format (abfd) == bfd_archive
      && abfd->xvec == &mach_o_fat_vec)
    return TRUE;
  return _bfd_generic_close_and_cleanup (abfd);
}

bfd_boolean bfd_mach_o_free_cached_info (bfd *abfd)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  asection *asect;
  free (mdata->dyn_reloc_cache);
  mdata->dyn_reloc_cache = NULL;
  for (asect = abfd->sections; asect != NULL; asect = asect->next)
    {
      free (asect->relocation);
      asect->relocation = NULL;
    }

  return TRUE;
}

#define bfd_mach_o_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup
#define bfd_mach_o_bfd_reloc_name_lookup _bfd_norelocs_bfd_reloc_name_lookup

#define bfd_mach_o_swap_reloc_in NULL
#define bfd_mach_o_swap_reloc_out NULL
#define bfd_mach_o_print_thread NULL
#define bfd_mach_o_tgt_seg_table NULL
#define bfd_mach_o_section_type_valid_for_tgt NULL

#define TARGET_NAME 		mach_o_be_vec
#define TARGET_STRING     	"mach-o-be"
#define TARGET_ARCHITECTURE	bfd_arch_unknown
#define TARGET_BIG_ENDIAN 	1
#define TARGET_ARCHIVE 		0
#define TARGET_PRIORITY		1
#include "mach-o-target.c"

#undef TARGET_NAME
#undef TARGET_STRING
#undef TARGET_ARCHITECTURE
#undef TARGET_BIG_ENDIAN
#undef TARGET_ARCHIVE
#undef TARGET_PRIORITY

#define TARGET_NAME 		mach_o_le_vec
#define TARGET_STRING 		"mach-o-le"
#define TARGET_ARCHITECTURE	bfd_arch_unknown
#define TARGET_BIG_ENDIAN 	0
#define TARGET_ARCHIVE 		0
#define TARGET_PRIORITY		1

#include "mach-o-target.c"

#undef TARGET_NAME
#undef TARGET_STRING
#undef TARGET_ARCHITECTURE
#undef TARGET_BIG_ENDIAN
#undef TARGET_ARCHIVE
#undef TARGET_PRIORITY

/* Not yet handled: creating an archive.  */
#define bfd_mach_o_mkarchive                      _bfd_noarchive_mkarchive

/* Not used.  */
#define bfd_mach_o_read_ar_hdr                    _bfd_noarchive_read_ar_hdr
#define bfd_mach_o_write_ar_hdr                   _bfd_noarchive_write_ar_hdr
#define bfd_mach_o_slurp_armap                    _bfd_noarchive_slurp_armap
#define bfd_mach_o_slurp_extended_name_table      _bfd_noarchive_slurp_extended_name_table
#define bfd_mach_o_construct_extended_name_table  _bfd_noarchive_construct_extended_name_table
#define bfd_mach_o_truncate_arname                _bfd_noarchive_truncate_arname
#define bfd_mach_o_write_armap                    _bfd_noarchive_write_armap
#define bfd_mach_o_get_elt_at_index               _bfd_noarchive_get_elt_at_index
#define bfd_mach_o_generic_stat_arch_elt          bfd_mach_o_fat_stat_arch_elt
#define bfd_mach_o_update_armap_timestamp         _bfd_noarchive_update_armap_timestamp

#define TARGET_NAME 		mach_o_fat_vec
#define TARGET_STRING 		"mach-o-fat"
#define TARGET_ARCHITECTURE	bfd_arch_unknown
#define TARGET_BIG_ENDIAN 	1
#define TARGET_ARCHIVE 		1
#define TARGET_PRIORITY		0

#include "mach-o-target.c"

#undef TARGET_NAME
#undef TARGET_STRING
#undef TARGET_ARCHITECTURE
#undef TARGET_BIG_ENDIAN
#undef TARGET_ARCHIVE
#undef TARGET_PRIORITY
@


1.112
log
@	* coffcode.h: Added a cast to void when a bfd_set_section_*()
	macro's return value is ignored.
	* elf32-hppa.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* mach-o.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* peicode.h: Likewise.
	* elf32-m32r.c: Check return value of bfd_set_section_*().
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* vms-alpha.c: Likewise.
@
text
@d198 3
@


1.111
log
@2013-02-04  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_scan_start_address): Do not fail if no
	start address.
@
text
@d2 1
a2 3
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
d2694 1
a2694 1
	  bfd_set_section_alignment (abfd, sec, s->align);
@


1.110
log
@2013-01-31  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_scan): Call bfd_mach_o_flatten_sections
	earlier.  Fix status checking of bfd_mach_o_scan_start_address.
	(bfd_mach_o_scan_start_address): Handle LC_MAIN.
@
text
@d3995 1
d3997 1
a3997 1
    return FALSE;
@


1.109
log
@	* bfd.c (struct bfd_preserve, bfd_preserve_save, bfd_preserve_restore,
	bfd_preserve_finish): Move to..
	* format.c: ..here, splitting out..
	(bfd_reinit): ..this.  New function.
	(bfd_check_format_matches): Use bfd_preserve_save/restore to
	keep bfd state for a match.
	* elfcode.h (elf_object_p): Don't use bfd_preserve_save/restore.
	* elfcore.h (elf_core_file_p): Likewise.
	* mach-o.c (bfd_mach_o_header_p): Likewise.
	* pef.c (bfd_pef_object_p, bfd_pef_xlib_object_p): Likewise.
	* xsym.c (bfd_sym_object_p): Likewise.
	* mmo.c (mmo_scan): Clear abfd->symcount.
	* opncls.c (_bfd_new_bfd): Use a smaller section hash table.
	* section.c (bfd_section_list_clear): Clear section_htab.count.
	* bfd-in2.h: Regenerate.
@
text
@d3982 12
d4136 3
a4138 1
  if (bfd_mach_o_scan_start_address (abfd) < 0)
a4140 1
  bfd_mach_o_flatten_sections (abfd);
@


1.108
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@a4179 1
  struct bfd_preserve preserve;
d4181 1
a4182 1
  preserve.marker = NULL;
d4228 2
a4229 3
  preserve.marker = bfd_zalloc (abfd, sizeof (bfd_mach_o_data_struct));
  if (preserve.marker == NULL
      || !bfd_preserve_save (abfd, &preserve))
d4232 1
a4232 2
  if (!bfd_mach_o_scan (abfd, &header,
                        (bfd_mach_o_data_struct *) preserve.marker))
a4234 1
  bfd_preserve_finish (abfd, &preserve);
a4240 2
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);
@


1.107
log
@bfd/
2012-11-14  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_read_main)
	(bfd_mach_o_read_source_version): New functions.
	(bfd_mach_o_read_command): Handle BFD_MACH_O_LC_DATA_IN_CODE,
	BFD_MACH_O_LC_DYLIB_CODE_SIGN_DRS, BFD_MACH_O_LC_MAIN,
	BFD_MACH_O_LC_SOURCE_VERSION.
	* mach-o.h (bfd_mach_o_main_command)
	(bfd_mach_o_source_version_command): New types.
	(bfd_mach_o_load_command): Add fields for these new types.

binutils/
2012-11-14  Tristan Gingold  <gingold@@adacore.com>

	* od-macho.c (bfd_mach_o_load_command_name): Add new definitions.
	(dump_load_command): Handle BFD_MACH_O_LC_SOURCE_VERSION
	and BFD_MACH_O_LC_MAIN.
@
text
@d87 1
a87 1
      
d95 1
a95 1
    {	".text",				"__text",	
d290 1
a290 1
   
d318 1
a318 1
  return NULL;  
d322 1
a322 1
   know the Mach-O data, return the segment name and the data for the 
d356 1
a356 1
  return NULL;  
d361 1
a361 1
   Try to use standard/canonical names, for which we have tables including 
d383 1
a383 1
  /* First search for a canonical name...  
d426 1
a426 1
   Otherwise, expand the bfd_name (assumed to be in the form 
d561 1
a561 1
  else 
d563 1
a563 1
      memcpy (osection->used_by_bfd, isection->used_by_bfd, 
d565 1
a565 1
 
d593 1
a593 1
   
d709 1
a709 1
  
d717 1
a717 1
      
d736 1
a736 1
              
d992 1
a992 1
      rel->r_length = (info >> BFD_MACH_O_BE_LENGTH_SHIFT) 
d1001 1
a1001 1
      rel->r_length = (info >> BFD_MACH_O_LE_LENGTH_SHIFT) 
d1416 1
a1416 1
  
d1498 1
a1498 1
     
d1665 1
a1665 1
  
d1680 1
a1680 1
	}    
d1861 1
a1861 1
          
d1902 1
a1902 1
  
d1910 1
a1910 1
  mdata->sections = bfd_alloc (abfd, 
d1921 1
a1921 1
     Section type, attribute and align should have been set when the 
d1934 1
a1934 1
      /* Use the largest alignment set, in case it was bumped after the 
d2062 3
a2064 3
   an MH_OBJECT file and means 'all sections available'.  
   
   Requires that the sections table in mdata be filled in.  
d2069 2
a2070 2
   to XCode 4). 
   
d2125 1
a2125 1
  /*  Append sections to the segment.  
d2129 1
a2129 1
      total vmsize in three passes so that any alignment increments are 
d2139 1
a2139 1
      if (! is_mho 
d2147 2
a2148 2
      
      /* Zerofill sections have zero file size & offset, 
d2151 1
a2151 1
          || (s->flags & BFD_MACH_O_SECTION_TYPE_MASK) 
d2179 1
a2179 1
      if (! is_mho 
d2194 1
a2194 1
 
d2198 1
a2198 1
      if (! is_mho 
d2216 1
a2216 1
        
d2300 2
a2301 2
      dsym->nundefsym = bfd_get_symcount (abfd) 
			- dsym->nlocalsym 
d2322 1
a2322 1
      
d2326 1
a2326 1
		  
d2340 1
a2340 1
		  
d2416 1
a2416 1
	a command for the dysymtab.  
d2462 1
a2462 1
    {  
d2495 1
a2495 1
  
d2516 1
a2516 1
        cmd->offset = mdata->commands[symtab_idx].offset 
d2519 1
a2519 1
        cmd->offset = mdata->commands[segcmd_idx].offset 
d2535 1
a2535 1
      && ! bfd_mach_o_build_seg_command 
d2541 1
a2541 1
      && ! bfd_mach_o_build_dysymtab_command (abfd, mdata, 
d2694 1
a2694 1
	  s->align = xlat->sectalign > bfdalign ? xlat->sectalign 
d4950 1
a4950 1
#define bfd_mach_o_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup 
@


1.106
log
@2012-11-14  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_canonicalize_one_reloc): Add a special
	handling for non-scattered pairs.  Update comments.
@
text
@d3669 42
d3887 2
d3905 8
@


1.105
log
@	* mach-o.c (bfd_mach_o_close_and_cleanup): Don't call
	_bfd_generic_close_and_cleanup for mach_o_fat archives.
@
text
@d1021 1
a1021 1
  
d1059 1
a1059 1
      
d1062 1
a1062 1
      
d1069 14
a1082 3
          sym = syms + num;
      else if (reloc.r_scattered
	       || (reloc.r_type != BFD_MACH_O_GENERIC_RELOC_PAIR))
d1084 1
d1087 1
d1096 6
a1101 9
      else /* ... The 'symnum' in a non-scattered PAIR will be 0x00ffffff.  */
        {
          /* Pairs for PPC LO/HI/HA are not scattered, but contain the offset
             in the lower 16bits of the address value.  So we have to find the
             'symbol' from the preceding reloc.  We do this even thoough the
             section symbol is probably not needed here, because NULL symbol
             values cause an assert in generic BFD code.  */
          sym = (res - 1)->sym_ptr_ptr;
        }
d1103 1
a1103 1
      
d1109 4
a1112 4
  
  /* We have set up a reloc with all the information present, so the swapper can
     modify address, value and addend fields, if necessary, to convey information
     in the generic BFD reloc that is mach-o specific.  */
@


1.104
log
@	* vms-lib.c (_bfd_vms_lib_get_module): Use bfd_zmalloc for
	areltdata.
	* opncls.c (_bfd_delete_bfd): Free arelt_data.
	* mach-o.c (bfd_mach_o_fat_member_init): Use bfd_zmalloc for
	areltdata.
	* ecoff.c (_bfd_ecoff_slurp_armap): Use free for mapdata.
	* coff-rs6000.c (_bfd_xcoff_read_ar_hdr): Use bfd_zmalloc for
	areltdata.
	(xcoff_write_archive_contents_old): Likewise.
	(xcoff_write_archive_contents_big): Likewise.
	* archive64.c (bfd_elf64_archive_slurp_armap): Use free for
	areltdata.
	* archive.c (_bfd_generic_read_ar_hdr_mag): Use bfd_zmalloc and
	free for areltdata.
	(_bfd_get_elt_at_filepos): Likewise.  Clear n_nfd->arelt_data on
	failure.
	(do_slurp_bsd_armap): Use bfd_zmalloc and free for areltdata.
	(do_slurp_coff_armap): Likewise.
	(_bfd_slurp_extended_name_table): Likewise.
	(bfd_slurp_bsd_armap_f2): Likewise.  Don't leak 'mapdata'.
@
text
@d4867 3
@


1.103
log
@2012-07-24  Teresa Johnson  <tejohnson@@google.com>

bfd/
	* bfd.c (bfd_find_nearest_line_discriminator): New macro.
	* coff-rs6000.c: Init _bfd_find_nearest_line_discriminator.
	* coff64-rs6000.c: Likewise.
	* dwarf2.c (struct line_info): Add discriminator field.
	(add_line_info): Fill in new discriminator field.
	(decode_line_info): Record discriminator information instead
        of ignoring it.
	(lookup_address_in_line_info_table): Return discriminator field if
        requested.
	(comp_unit_find_nearest_line): Add discriminator argument.
	(find_line): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(_bfd_dwarf2_find_line): Likewise.
	* elf-bfd.h (_bfd_elf_find_nearest_line_discriminator): New.
        (_bfd_elf_find_line_discriminator): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): Likewise. Defined.
	* elf.c (_bfd_elf_find_nearest_line): Change to a wrapper
        that invokes _bfd_elf_find_nearest_line_discriminator with correct
        arguments.
	(_bfd_elf_find_nearest_line_discriminator): New.
	(_bfd_elf_find_line): Change to a wrapper
        that invokes _bfd_elf_find_line_discriminator with correct
        arguments.
	(_bfd_elf_find_line_discriminator): New.
	* coffgen.c (coff_find_nearest_line_with_names): Handle
        new discriminator argument.
	* elf32-arm.c (elf32_arm_find_nearest_line): Likewise.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Likewise.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Add discriminator
        argument.
        (_bfd_dwarf2_find_line): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): New.
	* libbfd.c (_bfd_generic_find_nearest_line_discriminator): New.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize
        _bfd_find_nearest_line_discriminator with
        _bfd_generic_find_nearest_line_discriminator.
        (bfd_target): Add _bfd_find_nearest_line_discriminator.

binutils/
	* addr2line.c (find_address_in_section): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator.
	(find_offset_in_section): Likewise.
	(translate_addresses): Print discriminator if it is non-zero.
	* objdump.c (show_line): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator,
        and keep track of prev_discriminator. Print discriminator
        if it is non-zero.
	(disassemble_data): Initialize prev_discriminator.
	(dump_reloc_set): Invoke bfd_find_nearest_line_discriminator
        to get the discriminator, and keep track of last_discriminator.
        Print discriminator if it is non-zero.
@
text
@d4297 1
a4297 1
  areltdata = bfd_zalloc (abfd, sizeof (struct areltdata));
@


1.102
log
@deal with endian-ness in mach-o non-scattered relocs.

BFD:

	* mach-o.c (bfd_mach_o_swap_in_non_scattered_reloc): New.
	(bfd_mach_o_canonicalize_one_reloc):  Swap non-scattered reloc
	bit-fields when target and host differ in endian-ness.  When
	PAIRs are non-scattered	find the 'symbol' from the preceding
	reloc.  Add FIXME re. reloc symbols on section boundaries.
	(bfd_mach_o_swap_out_non_scattered_reloc): New.
	(bfd_mach_o_write_relocs): Use bfd_mach_o_encode_non_scattered_reloc.

include/mach-o:

	* external.h: Add comments about relocations fields.  Add macros
	for non-scattered relocations.  Move scattered relocation macros to here.
	* reloc.h: Remove macros related to external representation of reloc fields.
@
text
@d4839 1
a4839 1
				     line_ptr, 0,
@


1.101
log
@bfd:

	* mach-o.c (bfd_mach_o_build_seg_command): Count zerofill section
	vma additions in their logical, rather than physical order.
@
text
@d978 29
a1015 1
  bfd_vma symnum;
d1019 2
a1020 1
  symnum = bfd_get_32 (abfd, raw->r_symbolnum);
d1025 1
d1027 11
a1037 4
      /* Scattered relocation.
         Extract section and offset from r_value.  */
      res->sym_ptr_ptr = NULL;
      res->addend = 0;
d1048 2
a1049 1
      res->address = BFD_MACH_O_GET_SR_ADDRESS (addr);
d1053 2
a1054 1
      reloc.r_scattered = 1;
d1058 11
a1068 5
      unsigned int num = BFD_MACH_O_GET_R_SYMBOLNUM (symnum);
      res->addend = 0;
      res->address = addr;
      if (symnum & BFD_MACH_O_R_EXTERN)
        {
d1070 2
a1071 3
          reloc.r_extern = 1;
        }
      else
d1078 1
a1078 1
             bfd conventio, substract the section address.
d1082 9
a1090 1
          reloc.r_extern = 0;
d1093 5
a1097 4
      reloc.r_type = BFD_MACH_O_GET_R_TYPE (symnum);
      reloc.r_length = BFD_MACH_O_GET_R_LENGTH (symnum);
      reloc.r_pcrel = (symnum & BFD_MACH_O_R_PCREL) ? 1 : 0;
      reloc.r_scattered = 0;
d1100 4
d1242 35
a1322 2
          unsigned long v;

d1324 2
a1325 6
          v = BFD_MACH_O_SET_R_SYMBOLNUM (pinfo->r_value)
            | (pinfo->r_pcrel ? BFD_MACH_O_R_PCREL : 0)
            | BFD_MACH_O_SET_R_LENGTH (pinfo->r_length)
            | (pinfo->r_extern ? BFD_MACH_O_R_EXTERN : 0)
            | BFD_MACH_O_SET_R_TYPE (pinfo->r_type);
          bfd_put_32 (abfd, v, raw.r_symbolnum);
@


1.100
log
@correct some mach-o section specification nits.

bfd:

	* mach-o.c (mach_o_section_name_xlat): Correct eh-frame section
	parameters.
	* mach-o-x86-64.c (text_section_names_xlat): New.
	(mach_o_x86_64_segsec_names_xlat): New.
	(bfd_mach_o_tgt_seg_table): Define to mach_o_x86_64_segsec_names_xlat.
	* mach-o-i386.c (text_section_names_xlat): Correct section parameters.
@
text
@d2029 6
a2034 1
  /*  Append sections to the segment.  */
d2047 2
a2049 1

a2050 5
      if (s->size > 0)
       {
          seg->vmsize = FILE_ALIGN (seg->vmsize, s->align);
	  seg->vmsize += s->size;
        }
d2061 6
d2072 14
d2087 5
a2091 1
      mdata->filelen += s->size;
d2094 18
a2111 2
  seg->filesize = mdata->filelen - seg->fileoff;
  seg->filesize = FILE_ALIGN(seg->filesize, 2);
d2113 1
a2113 1
  /* Allocate relocation room.  */
@


1.99
log
@bfd/
2012-02-02  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_read_header): Silent uninitialized
	variable warning.

gas/
2012-02-02  Tristan Gingold  <gingold@@adacore.com>

	* config/obj-macho.c (obj_mach_o_zerofill): Silent
	uninitialized variable warning.
@
text
@d124 1
a124 1
	SEC_READONLY | SEC_LOAD,		BFD_MACH_O_S_COALESCED,
d127 1
a127 1
	| BFD_MACH_O_S_ATTR_NO_TOC,		3},
@


1.98
log
@
handle absolute indirect syms in mach-o

bfd:

	* mach-o.c (bfd_mach_o_build_dysymtab_command): Handle absolute
	indirect symbols.
gas:

	* config/obj-macho.c (obj_mach_o_set_indirect_symbols): Handle
	absolute indirect symbols.

gas/testsuite:

	* gas/mach-o/dysymtab-3.d: New.
	* gas/mach-o/symbols-7.s: New.
@
text
@d2525 2
@


1.97
log
@
order relocs after segments for mach-o

bfd:

	* mach-o.c (bfd_mach_o_write_relocs): Move compuation of relocs file
	position from here... to (bfd_mach_o_build_seg_command): Here.
@
text
@d2213 4
@


1.96
log
@
add indirect_symbol to mach-o port.

bfd:

	* mach-o.c (bfd_mach_o_count_indirect_symbols): New.
	(bfd_mach_o_build_dysymtab_command): Populate indirect symbol table.
	* mach-o.h (bfd_mach_o_asymbol): Move declaration to start of the
	file. (bfd_mach_o_section): Add indirect_syms field.

gas:

	* config/obj-macho.c (obj_mach_o_set_symbol_qualifier): Switch off
	lazy when the symbol is private_extern.
	(obj_mach_o_indirect_sym): New type.
	(obj_mach_o_indirect_symbol): New.
	(mach_o_pseudo_table): Use obj_mach_o_indirect_symbol.
	(obj_macho_frob_label): Adjust to avoid adding bsyms for locals.
	(obj_macho_frob_label): Likewise.  Adjust external and comm
	symbol tests.
	(obj_mach_o_set_indirect_symbols): New.
	(obj_mach_o_frob_file_after_relocs): New.
	*config/obj-macho.h (obj_frob_file_after_relocs): Define.
	(obj_mach_o_frob_file_after_relocs): Declare.

include/mach-o:

	* loader.h (BFD_MACH_O_INDIRECT_SYM_LOCAL): New.
	(BFD_MACH_O_INDIRECT_SYM_ABS): New

gas/testsuite:

	* gas/mach-o/dysymtab-2.d: New.
	* gas/mach-o/err-syms-4.s: New.
	* gas/mach-o/err-syms-5.s: New.
	* gas/mach-o/err-syms-6.s: New.
	* gas/mach-o/symbols-6-64.d: New.
	* gas/mach-o/symbols-6-64.s: New.
	* gas/mach-o/symbols-6.d: New.
	* gas/mach-o/symbols-6.s: New.
@
text
@a1187 1
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
a1199 7
  /* Allocate relocation room.  */
  mdata->filelen = FILE_ALIGN(mdata->filelen, 2);
  section->nreloc = sec->reloc_count;
  sec->rel_filepos = mdata->filelen;
  section->reloff = sec->rel_filepos;
  mdata->filelen += sec->reloc_count * BFD_MACH_O_RELENT_SIZE;

d2070 19
@


1.95
log
@
bfd:

	* mach-o.c (bfd_mach_o_build_seg_command): Separate computation of
	vmsize from filesize.  Don't compute offsets or file sizes for
	zerofill sections.
@
text
@d2082 27
d2165 1
d2169 1
d2178 3
a2180 3
      
      /* So fill in the indices.  */
      for (i = 0; i < dsym->nindirectsyms; ++i)
d2182 28
a2209 1
	  /* TODO: fill in the table.  */
@


1.94
log
@
bfd:

	* mach-o.c (bfd_mach_o_build_commands): Make the building of each
	command type independent.
@
text
@d2026 1
d2052 15
a2066 3
      if (s->size == 0)
         s->offset = 0;
      else
a2077 1
  seg->vmsize = seg->filesize;
@


1.93
log
@2012-01-10  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_build_commands): Avoid uninitialized false
	warning.
@
text
@d2156 5
a2160 5
  unsigned int wide = mach_o_wide_p (&mdata->header);
  bfd_mach_o_segment_command *seg = NULL;
  bfd_mach_o_load_command *cmd;
  bfd_mach_o_load_command *symtab_cmd;
  unsigned symcind;
d2190 10
a2199 1
  /* It's valid to have a file with only absolute symbols...  */
d2202 1
a2203 1
      symcind = 1;
a2204 2
  else
    symcind = 0;
a2205 1
  /* It's OK to have a file with only section statements.  */
d2207 4
a2210 1
    mdata->header.ncmds += 1;
d2212 10
a2221 4
  /* Very simple version (only really applicable to MH_OBJECTs):
	a command (segment) to contain all the sections,
	a command for the symbol table
	a n (optional) command for the dysymtab.  
d2223 4
a2226 1
     ??? maybe we should assert that this is an MH_OBJECT?  */
d2228 2
a2229 3
  if (bfd_mach_o_should_emit_dysymtab ()
      && bfd_get_symcount (abfd) > 0)
    mdata->header.ncmds += 1;
d2231 1
a2231 1
  /* A bit weird, but looks like no content;
d2241 1
a2241 1
  if (mdata->nsects > 0)
d2243 2
a2244 2
      cmd = &mdata->commands[0];
      seg = &cmd->command.segment;
d2252 1
a2255 1
	  cmd->offset = BFD_MACH_O_HEADER_64_SIZE;
a2261 1
	  cmd->offset = BFD_MACH_O_HEADER_SIZE;
d2265 1
d2268 1
a2268 1
      mdata->filelen = cmd->offset + cmd->len;
d2271 1
a2271 1
  if (bfd_get_symcount (abfd) > 0)
d2274 1
a2274 1
      symtab_cmd = &mdata->commands[symcind];
d2276 10
a2285 11
      symtab_cmd->type = BFD_MACH_O_LC_SYMTAB;
      if (symcind > 0)
        symtab_cmd->offset = mdata->commands[0].offset 
			     + mdata->commands[0].len;
      else
        symtab_cmd->offset = 0;
      symtab_cmd->len = 6 * 4;
      symtab_cmd->type_required = FALSE;
  
      mdata->header.sizeofcmds += symtab_cmd->len;
      mdata->filelen += symtab_cmd->len;
d2288 3
a2290 3
  /* If required, setup symtab command.  */
  if (bfd_mach_o_should_emit_dysymtab ()
      && bfd_get_symcount (abfd) > 0)
d2292 2
a2293 1
      cmd = &mdata->commands[symcind+1];
d2295 9
a2303 1
      cmd->offset = symtab_cmd->offset + symtab_cmd->len;
d2305 2
a2306 1
      cmd->len = 18 * 4 + BFD_MACH_O_LC_SIZE;
d2314 3
a2316 2
  if (mdata->nsects > 0
      && ! bfd_mach_o_build_seg_command (NULL, mdata, seg))
d2320 1
a2320 2
  if (bfd_mach_o_should_emit_dysymtab ()
      && bfd_get_symcount (abfd) > 0
d2322 1
a2322 1
					      &mdata->commands[symcind+1]))
@


1.92
log
@
add symbol qualifiers for mach-o to bfd/gas

bfd:

	* mach-o.c (bfd_mach_o_bfd_copy_private_symbol_data): Implement.
	(bfd_mach_o_write_symtab): Remove handling for indirect syms.
	(bfd_mach_o_primary_symbol_sort_key): Likewise.
	(bfd_mach_o_cf_symbols): Likewise.
	(bfd_mach_o_sort_symbol_table): Remove.
	(bfd_mach_o_mangle_symbols): Adjust arguments, remove handling
	for indirect and dysymtab counts.  Do the symbol sorting here.
	(bfd_mach_o_build_dysymtab_command): Count the symbol types here.
	Make the indirect symbols a TODO.
	(bfd_mach_o_build_commands): Adjust call to bfd_mach_o_mangle_symbols.
	(bfd_mach_o_make_empty_symbol): Specifically flag unset symbols with
	a non-zero value.
	(bfd_mach_o_read_symtab_symbol): Record the symbol index.
	(bfd_mach_o_read_symtab_symbol): Adjust recording of global status.
	* mach-o.h (mach_o_data_struct): Remove indirect and dysymtab entries.
	(IS_MACHO_INDIRECT): Remove.
	(SYM_MACHO_FIELDS_UNSET, SYM_MACHO_FIELDS_NOT_VALIDATED): New.

gas:

	* config/obj-macho.c (obj_mach_o_weak): Remove.
	(obj_mach_o_common_parse): Set symbol qualifiers.
	(LAZY, REFE): New macros.
	(obj_mach_o_symbol_type): New enum.
	(obj_mach_o_set_symbol_qualifier): New.
	(obj_mach_o_sym_qual): New.
	(mach_o_pseudo_table): Add symbol qualifiers, set indirect_symbol to
	a dummy function.
	(obj_mach_o_type_for_symbol): New.
	(obj_macho_frob_label): New.
	(obj_macho_frob_symbol): New.
	* config/obj-macho.h (S_SET_ALIGN): Amend temorary var name.
	(obj_frob_label, obj_macho_frob_label): Declare.
	(obj_frob_symbol, obj_macho_frob_symbol): Declare.

gas/testsuite:

	* gas/mach-o/err-syms-1.s: New.
	* gas/mach-o/err-syms-2.s: New.
	* gas/mach-o/err-syms-3.s: New.
	* gas/mach-o/symbols-2.d: New.
	* gas/mach-o/symbols-2.s: New.
	* gas/mach-o/symbols-3.s: New.
	* gas/mach-o/symbols-4.s: New.
	* gas/mach-o/symbols-5.d: New.
	* gas/mach-o/symbols-5.s: New.
@
text
@d2157 1
a2157 1
  bfd_mach_o_segment_command *seg;
@


1.91
log
@2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_fat_stat_arch_elt): New function.
	(bfd_mach_o_generic_stat_arch_elt): Adjust.
@
text
@d536 1
a536 1
					 asymbol *isymbol ATTRIBUTE_UNUSED,
d538 1
a538 1
					 asymbol *osymbol ATTRIBUTE_UNUSED)
d540 7
a1409 16

      /* For a bare indirect symbol, the system tools expect that the symbol
	 value will be the string table offset for its referenced counterpart.
	 
	 Normally, indirect syms will not be written this way, but rather as
	 part of the dysymtab command.
	 
	 In either case, correct operation depends on the symbol table being
	 sorted such that the indirect symbols are at the end (since the 
	 string table index is filled in below).  */

      if (IS_MACHO_INDIRECT (s->n_type))
	/* A pointer to the referenced symbol will be stored in the udata
	   field.  Use that to find the string index.  */
	s->symbol.value = 
	    ((bfd_mach_o_asymbol *)s->symbol.udata.p)->symbol.udata.i;
a1416 5
          /* Record the string index.  This can be looked up by an indirect sym
	     which retains a pointer to its referenced counterpart, until it is
	     actually output.  */
	  if (IS_MACHO_INDIRECT (s->n_type))
	    s->symbol.udata.i = str_index;
d1662 1
a1662 1
bfd_mach_o_primary_symbol_sort_key (unsigned type)
d1664 1
a1664 1
  unsigned mtyp = type & BFD_MACH_O_N_TYPE;
d1668 1
a1668 1
  if (type & BFD_MACH_O_N_STAB)
a1670 4
  /* Sort indirects to last.  */
  if (mtyp == BFD_MACH_O_N_INDR)
    return 3;

d1672 1
a1672 1
  if (! (type & (BFD_MACH_O_N_EXT | BFD_MACH_O_N_PEXT)))
d1679 1
a1679 1
  /* A defined symbol that's not indirect or extern.  */
d1690 2
a1691 2
  soa = bfd_mach_o_primary_symbol_sort_key (sa->n_type);
  sob = bfd_mach_o_primary_symbol_sort_key (sb->n_type);
d1705 2
d1710 2
a1711 46
  /* Unless it's an indirect the second sort key is name.  */
  if (soa < 3)
    return strcmp (sa->symbol.name, sb->symbol.name);

  /* Here be indirect symbols, which have different sort rules.  */

  /* Next sort key for indirect, is the section index.  */
  if (sa->n_sect < sb->n_sect)
    return -1;

  if (sa->n_sect > sb->n_sect)
    return  1;

  /* Last sort key is the order of definition - which should be in line with
     the value, since a stub size of 0 is meaninglesss.  */

  if (sa->symbol.value < sb->symbol.value)
    return -1;

  if (sa->symbol.value > sb->symbol.value)
    return 1;

  /* In the final analysis, this is probably an error ... but leave it alone
     for now.  */
  return 0;
}

/* When this is finished, return the number of non-indirect symbols.  */

static unsigned int
bfd_mach_o_sort_symbol_table (asymbol **symbols, unsigned int nin)
{
  qsort (symbols, (size_t) nin, sizeof (void *), bfd_mach_o_cf_symbols);
  
  /* Find the last non-indirect symbol.  
     There must be at least one non-indirect symbol otherwise there's
     nothing for the indirect(s) to refer to.  */
  do
    { 
      bfd_mach_o_asymbol *s = (bfd_mach_o_asymbol *)symbols[nin - 1];
      if (IS_MACHO_INDIRECT (s->n_type))
	nin--;
      else
	break;
    } while (nin - 1 > 0);
  return nin;
d1727 1
a1727 1
	(iii) external undefined
d1731 1
a1731 5
	(  v) indirect 
		(by section)
			(by position within section).

   (c) Indirect symbols are moved to the end of the list.  */
d1734 1
a1734 1
bfd_mach_o_mangle_symbols (bfd *abfd, bfd_mach_o_data_struct *mdata)
d1746 6
a1751 1
      if (s->n_type == BFD_MACH_O_N_UNDF && !(s->symbol.flags & BSF_DEBUGGING))
d1753 2
a1754 3
          /* As genuine Mach-O symbols type shouldn't be N_UNDF (undefined
             symbols should be N_UNDEF | N_EXT), we suppose the back-end
             values haven't been set.  */
d1764 1
d1767 4
a1770 1
            s->n_type = BFD_MACH_O_N_UNDF | BFD_MACH_O_N_EXT;
d1786 2
a1787 4
      /* Unless we're looking at an indirect sym, note the input ordering.
	 We use this to keep local symbols ordered as per the input.  */
      if (! IS_MACHO_INDIRECT (s->n_type))
	s->symbol.udata.i = i;
d1790 5
a1794 6
  /* Sort the symbols and determine how many will remain in the main symbol
     table, and how many will be emitted as indirect (assuming that we will
     be emitting a dysymtab).  Renumber the sorted symbols so that the right
     index will be found during indirection.  */
  i = bfd_mach_o_sort_symbol_table (symbols, bfd_get_symcount (abfd));
  if (bfd_mach_o_should_emit_dysymtab ())
d1796 2
a1797 35
      /* Point at the first indirect symbol.  */
      if (i < bfd_get_symcount (abfd))
	{
	  mdata->indirect_syms = &symbols[i];
	  mdata->nindirect = bfd_get_symcount (abfd) - i;
	  /* This is, essentially, local to the output section of mach-o,
	     and therefore should be safe.  */
	  abfd->symcount = i;
	}

      /* Now setup the counts for each type of symbol.  */
      for (i = 0; i < bfd_get_symcount (abfd); ++i)
	{
	  bfd_mach_o_asymbol *s = (bfd_mach_o_asymbol *)symbols[i];
	  s->symbol.udata.i = i;  /* renumber.  */
	  if (s->n_type & (BFD_MACH_O_N_EXT | BFD_MACH_O_N_PEXT))
	    break;
	}
      mdata->nlocal = i;
      for (; i < bfd_get_symcount (abfd); ++i)
	{
	  bfd_mach_o_asymbol *s = (bfd_mach_o_asymbol *)symbols[i];
	  s->symbol.udata.i = i;  /* renumber.  */
	  if ((s->n_type & BFD_MACH_O_N_TYPE) == BFD_MACH_O_N_UNDF)
	    break;
	}
      mdata->ndefext = i - mdata->nlocal;
      mdata->nundefext = bfd_get_symcount (abfd) 
			 - mdata->ndefext 
			 - mdata->nlocal;
      for (; i < bfd_get_symcount (abfd); ++i)
	{
	  bfd_mach_o_asymbol *s = (bfd_mach_o_asymbol *)symbols[i];
	  s->symbol.udata.i = i;  /* renumber.  */
	}
a2089 5
  dsym->nlocalsym = mdata->nlocal;
  dsym->iextdefsym = dsym->nlocalsym;
  dsym->nextdefsym = mdata->ndefext;
  dsym->iundefsym = dsym->nextdefsym + dsym->iextdefsym;
  dsym->nundefsym = mdata->nundefext;
d2091 36
a2126 1
  if (mdata->nindirect > 0)
d2128 1
a2128 1
      unsigned i, sect;
d2132 1
a2132 1
      mdata->filelen += mdata->nindirect * 4;
d2134 1
a2134 1
      dsym->indirect_syms = bfd_zalloc (abfd, mdata->nindirect * 4);
a2136 1
      dsym->nindirectsyms = mdata->nindirect;
d2138 2
a2139 4
      /* So fill in the indices, and point the section reserved1 fields
	 at the right one.  */
      sect = (unsigned) -1;
      for (i = 0; i < mdata->nindirect; ++i)
d2141 1
a2141 13
	  bfd_mach_o_asymbol *s = 
			(bfd_mach_o_asymbol *) mdata->indirect_syms[i];
	  /* Lookup the index of the referenced symbol.  */
	  dsym->indirect_syms[i] = 
		((bfd_mach_o_asymbol *) s->symbol.udata.p)->symbol.udata.i;
	  if (s->n_sect != sect)
	    {
	      /* Mach-o sections are 1-based, but the section table
		 is 0-based.  */
	      bfd_mach_o_section *sc = mdata->sections[s->n_sect-1];
	      sc->reserved1 = i;
	      sect = s->n_sect;
	    }
d2187 1
a2187 1
  if (!bfd_mach_o_mangle_symbols (abfd, mdata))
d2349 1
a2349 1
  new_symbol->udata.i = 0;
d2677 1
a2677 1
  s->symbol.udata.i = 0;
d2708 1
a2708 1
      if (type & BFD_MACH_O_N_PEXT)
d2710 1
a2710 5

      if (type & BFD_MACH_O_N_EXT)
	s->symbol.flags |= BSF_GLOBAL;

      if (!(type & (BFD_MACH_O_N_PEXT | BFD_MACH_O_N_EXT)))
d3911 1
@


1.90
log
@2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_fat_member_init): New function.
	(bfd_mach_o_openr_next_archived_file): Reindent.
	Adjust to call bfd_mach_o_fat_member_init.
	(bfd_mach_o_fat_extract): Adjust to call bfd_mach_o_fat_member_init.
@
text
@d4206 20
d4779 1
a4779 1
#define bfd_mach_o_generic_stat_arch_elt          _bfd_noarchive_generic_stat_arch_elt
@


1.89
log
@bfd/
2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h (bfd_mach_o_fvmlib_command): New structure.
	(bfd_mach_o_load_command): Add fvmlib field.

	* mach-o.c (bfd_mach_o_read_fvmlib): New function.
	(bfd_mach_o_read_command): Handle fvmlib.

binutils/
2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* od-macho.c (dump_load_command): Handle fvmlib.

include/mach-o/
2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* external.h (mach_o_fvmlib_command_external): New structure.
@
text
@d4110 36
d4161 4
a4164 1
    i = 0;	/* Start at first one.  */
d4167 1
d4180 4
a4183 2
    i++;	/* Get next entry.  */
  }
a4195 2
  nbfd->origin = entry->offset;

d4199 2
a4200 3
  /* Create the member filename. Use ARCH_NAME.  */
  nbfd->filename = bfd_printable_arch_mach (arch_type, arch_subtype);
  nbfd->iostream = NULL;
d4211 1
d4251 1
a4251 4
      res->origin = e->offset;

      res->filename = bfd_printable_arch_mach (cpu_type, cpu_subtype);
      res->iostream = NULL;
@


1.88
log
@bfd/
2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_convert_architecture): Reindent.
	Decode msubtype for ARM.

include/mach-o/
2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* loader.h: Update copyright year.
	(bfd_mach_o_cpu_subtype): Add ARM subtypes.
@
text
@d3048 26
d3647 3
@


1.87
log
@bfd/
2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_get_synthetic_symtab): Add comments.
@
text
@d824 1
a824 1
				 bfd_mach_o_cpu_subtype msubtype ATTRIBUTE_UNUSED,
d832 6
a837 2
    case BFD_MACH_O_CPU_TYPE_VAX: *type = bfd_arch_vax; break;
    case BFD_MACH_O_CPU_TYPE_MC680x0: *type = bfd_arch_m68k; break;
d846 36
a881 5
    case BFD_MACH_O_CPU_TYPE_MIPS: *type = bfd_arch_mips; break;
    case BFD_MACH_O_CPU_TYPE_MC98000: *type = bfd_arch_m98k; break;
    case BFD_MACH_O_CPU_TYPE_HPPA: *type = bfd_arch_hppa; break;
    case BFD_MACH_O_CPU_TYPE_ARM: *type = bfd_arch_arm; break;
    case BFD_MACH_O_CPU_TYPE_MC88000: *type = bfd_arch_m88k; break;
d886 6
a891 2
    case BFD_MACH_O_CPU_TYPE_I860: *type = bfd_arch_i860; break;
    case BFD_MACH_O_CPU_TYPE_ALPHA: *type = bfd_arch_alpha; break;
@


1.86
log
@bfd/
2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h: Reindent header.
	(bfd_mach_o_encryption_info_command): New structure.
	(bfd_mach_o_load_command): Add encryption_info field.

	* mach-o.c (bfd_mach_o_read_encryption_info): New function.
	(bfd_mach_o_read_command): Handle BFD_MACH_O_LC_ENCRYPTION_INFO.
	(bfd_mach_o_read_command): Adjust error message.

binutils/
2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* od-macho.c: Update copyright year.
	(dump_load_command): Handle BFD_MACH_O_LC_ENCRYPTION_INFO.

include/mach-o/
2012-01-04  Tristan Gingold  <gingold@@adacore.com>

	* external.h: Update copyright year.
	(mach_o_symtab_command_external): Add comments.
	(mach_o_encryption_info_command_external): New structure.
@
text
@d654 2
d675 1
d682 2
d690 2
a691 1
              
d716 1
@


1.85
log
@2012-01-04  Shinichiro Hamaji  <shinichiro.hamaji@@gmail.com>

	* dwarf2.c (_bfd_dwarf2_slurp_debug_info): Factor out the part
	which reads DWARF2 and stores in stash from find_line.
	(find_line) Call _bfd_dwarf2_slurp_debug_info.
	* libbfd-in.h (_bfd_dwarf2_slurp_debug_info): Add declaration.
	* libbfd.h (_bfd_dwarf2_slurp_debug_info): Regenerate.
	* mach-o.c (dsym_subdir): The name of subdir where debug
	information may be stored.
	(bfd_mach_o_lookup_uuid_command): New. Lookup a load command whose
	type is UUID.
	(bfd_mach_o_dsym_for_uuid_p): New. Check if the specified BFD is
	corresponding to the executable.
	(bfd_mach_o_find_dsym): New. Find a debug information BFD in the
	specified binary file.
	(bfd_mach_o_follow_dsym): New. Find a debug information BFD for
	the original BFD.
	(bfd_mach_o_find_nearest_line): Check dSYM files for Mach-O
	executables, dylibs, and bundles.
	(bfd_mach_o_close_and_cleanup): Clean up BFDs for the dSYM file.
	* mach-o.h (dsym_bfd): The BFD of the dSYM file.
@
text
@d3414 16
d3606 4
d3620 1
a3620 1
      (*_bfd_error_handler)(_("%B: unable to read unknown load command 0x%lx"),
@


1.84
log
@
support stabs on mach-o GAS.

bfd:

	* mach-o.c (bfd_mach_o_mangle_symbols): Put in the section index
	for stabd symbols.
	(bfd_mach_o_primary_symbol_sort_key): Adjust for stabs.
	(bfd_mach_o_cf_symbols): Likewise.

gas:

	* config/obj-macho.c (obj_macho_process_stab): New.
	* config/obj-macho.h (OBJ_PROCESS_STAB): Define.
	(obj_macho_process_stab): Declare.
@
text
@d282 2
d4374 114
d4498 1
a4498 2
  /* TODO: Handle executables and dylibs by using dSYMs. */
  if (mdata->header.filetype != BFD_MACH_O_MH_OBJECT)
d4500 26
d4543 12
@


1.83
log
@correct typo in previous commit.

bfd:

	* mach-o.c (bfd_mach_o_mangle_symbols): Correct typo.
@
text
@d1628 1
a1628 1
bfd_mach_o_primary_symbol_sort_key (unsigned type, unsigned ext)
d1630 9
a1638 3
  /* TODO: Determine the correct ordering of stabs symbols.  */
  /* We make indirect symbols a local/synthetic.  */
  if (type == BFD_MACH_O_N_INDR)
d1642 1
a1642 1
  if (! ext)
d1646 1
a1646 1
  if (type == BFD_MACH_O_N_UNDF)
d1660 2
a1661 6
  soa = bfd_mach_o_primary_symbol_sort_key 
  			(sa->n_type & BFD_MACH_O_N_TYPE,
			 sa->n_type & (BFD_MACH_O_N_PEXT | BFD_MACH_O_N_EXT));
  sob = bfd_mach_o_primary_symbol_sort_key
  			(sb->n_type & BFD_MACH_O_N_TYPE,
			 sb->n_type & (BFD_MACH_O_N_PEXT | BFD_MACH_O_N_EXT));
d1668 1
a1668 1
  /* If it's local, just preserve the input order.  */
d1787 1
a1787 1
      if (s->symbol.section != bfd_abs_section_ptr
d1790 3
a1792 1
        s->n_sect = s->symbol.section->target_index;
@


1.82
log
@add dysymtab write support to bfd/mach-o.

bfd:

	* mach-o.c (bfd_mach_o_write_symtab): Fill in the string table index
	as the value of an indirect symbol.  Keep the string table index in
	non-indirect syms for reference.
	(bfd_mach_o_write_dysymtab): New.
	(bfd_mach_o_primary_symbol_sort_key): New.
	(bfd_mach_o_cf_symbols): New.
	(bfd_mach_o_sort_symbol_table): New.
	(bfd_mach_o_mangle_symbols): Return early if no symbols.  Sort symbols.
	If we are emitting a dysymtab, process indirect symbols and count the
	number of each other kind.
	(bfd_mach_o_mangle_sections): New.
	(bfd_mach_o_write_contents): Split out some pre-requisite code into
	the command builder. Write dysymtab if the command is present.
	(bfd_mach_o_count_sections_for_seg): New.
	(bfd_mach_o_build_seg_command): New.
	(bfd_mach_o_build_dysymtab_command): New.
	(bfd_mach_o_build_commands): Reorganize to support the fact that some
	commands are optional and should not be emitted if there are no
	sections or symbols.
	(bfd_mach_o_set_section_contents): Amend comment.
	* mach-o.h: Amend and add to comments.
	(mach_o_data_struct): Add fields for dysymtab symbols counts and a
	pointer to the indirects, when present.
	(bfd_mach_o_should_emit_dysymtab): New macro.
	(IS_MACHO_INDIRECT): Likewise.

gas/testsuite:

	* gas/mach-o/dysymtab-1-64.d: New.
	* gas/mach-o/dysymtab-1.d: New.
	* gas/mach-o/symbols-1-64.d: New.
	* gas/mach-o/symbols-1.d: New.
	* gas/mach-o/symbols-base-64.s: New.
	* gas/mach-o/symbols-base.s: New.
@
text
@d1792 1
a1792 1
      if (IS_MACHO_INDIRECT (s->n_type))
@


1.81
log
@bfd:

	* mach-o-i386.c (bfd_mach_o_section_type_valid_for_tgt): Define NULL.
	* mach-o-target.c (bfd_mach_o_backend_data): Initialize bfd_mach_o_section_type_valid_for_tgt
	* mach-o-x86-64.c (bfd_mach_o_section_type_valid_for_x86_64): New.
	(bfd_mach_o_section_type_valid_for_tgt): Set to bfd_mach_o_section_type_valid_for_x86_64.
	* mach-o.c (bfd_mach_o_section_type_name): Reorder and eliminate dup.
	(bfd_mach_o_section_attribute_name): Reorder.
	(bfd_mach_o_get_section_type_from_name): If the target has defined a validator for section
	types, then use it.
	* mach-o.h (bfd_mach_o_get_section_type_from_name): Alter declaration to include the bfd.

gas:

	* config/obj-macho.c (obj_mach_o_section): Account for target-dependent section
	types.  Improve error handling when wrong section types/attributes are specified.

gas/testsuite:

	* gas/mach-o/err-sections-1.s: New.
	* gas/mach-o/err-sections-2.s: New.
	* gas/mach-o/sections-3.d: New.
	* gas/mach-o/sections-3.s: New.
@
text
@d3 1
a3 1
   2009, 2010, 2011
d32 2
d1356 16
a1371 2
      /* Compute name index.  */
      /* An index of 0 always means the empty string.  */
d1373 1
d1378 6
d1446 2
a1447 2
/* Process the symbols and generate Mach-O specific fields.
   Number them.  */
d1450 299
a1748 1
bfd_mach_o_mangle_symbols (bfd *abfd)
d1753 3
d1772 2
d1784 1
a1784 1
      /* Compute section index.  */
d1790 102
a1891 2
      /* Number symbols.  */
      s->symbol.udata.i = i;
d1893 1
d1903 1
a1907 10
  /* Now write header information.  */
  if (mdata->header.filetype == 0)
    {
      if (abfd->flags & EXEC_P)
        mdata->header.filetype = BFD_MACH_O_MH_EXECUTE;
      else if (abfd->flags & DYNAMIC)
        mdata->header.filetype = BFD_MACH_O_MH_DYLIB;
      else
        mdata->header.filetype = BFD_MACH_O_MH_OBJECT;
    }
a1910 4
  /* Assign a number to each symbols.  */
  if (!bfd_mach_o_mangle_symbols (abfd))
    return FALSE;

d1940 4
a1955 1
	case BFD_MACH_O_LC_DYSYMTAB:
d2011 165
a2175 1
/* Build Mach-O load commands from the sections.  */
a2182 1
  asection *sec;
d2185 1
a2185 1
  int target_index;
d2187 1
a2187 1
  /* Return now if commands are already built.  */
d2191 22
a2212 6
  /* Very simple version: a command (segment) to contain all the sections and
     a command for the symbol table.  */
  mdata->header.ncmds = 2;
  mdata->commands = bfd_alloc (abfd, mdata->header.ncmds
                               * sizeof (bfd_mach_o_load_command));
  if (mdata->commands == NULL)
a2213 2
  cmd = &mdata->commands[0];
  seg = &cmd->command.segment;
d2215 2
a2216 4
  seg->nsects = bfd_count_sections (abfd);

  /* Set segment command.  */
  if (wide)
d2218 2
a2219 4
      cmd->type = BFD_MACH_O_LC_SEGMENT_64;
      cmd->offset = BFD_MACH_O_HEADER_64_SIZE;
      cmd->len = BFD_MACH_O_LC_SEGMENT_64_SIZE
        + BFD_MACH_O_SECTION_64_SIZE * seg->nsects;
d2222 12
a2233 9
    {
      cmd->type = BFD_MACH_O_LC_SEGMENT;
      cmd->offset = BFD_MACH_O_HEADER_SIZE;
      cmd->len = BFD_MACH_O_LC_SEGMENT_SIZE
        + BFD_MACH_O_SECTION_SIZE * seg->nsects;
    }
  cmd->type_required = FALSE;
  mdata->header.sizeofcmds = cmd->len;
  mdata->filelen = cmd->offset + cmd->len;
d2235 3
a2237 10
  /* Set symtab command.  */
  symtab_cmd = &mdata->commands[1];
  
  symtab_cmd->type = BFD_MACH_O_LC_SYMTAB;
  symtab_cmd->offset = cmd->offset + cmd->len;
  symtab_cmd->len = 6 * 4;
  symtab_cmd->type_required = FALSE;
  
  mdata->header.sizeofcmds += symtab_cmd->len;
  mdata->filelen += symtab_cmd->len;
d2239 4
a2242 11
  /* Fill segment command.  */
  memset (seg->segname, 0, sizeof (seg->segname));
  seg->vmaddr = 0;
  seg->fileoff = mdata->filelen;
  seg->filesize = 0;
  seg->maxprot = BFD_MACH_O_PROT_READ | BFD_MACH_O_PROT_WRITE
    | BFD_MACH_O_PROT_EXECUTE;
  seg->initprot = seg->maxprot;
  seg->flags = 0;
  seg->sect_head = NULL;
  seg->sect_tail = NULL;
d2244 4
a2247 8
  /* Create Mach-O sections.
     Section type, attribute and align should have been set when the 
     section was created - either read in or specified.  */
  target_index = 0;
  for (sec = abfd->sections; sec; sec = sec->next)
    {
      unsigned bfd_align = bfd_get_section_alignment (abfd, sec);
      bfd_mach_o_section *msect = bfd_mach_o_get_mach_o_section (sec);
d2249 9
a2257 1
      bfd_mach_o_append_section_to_segment (seg, sec);
d2259 19
a2277 5
      msect->addr = bfd_get_section_vma (abfd, sec);
      msect->size = bfd_get_section_size (sec);
      /* Use the largest alignment set, in case it was bumped after the 
	 section was created.  */
      msect->align = msect->align > bfd_align ? msect->align : bfd_align;
d2279 9
a2287 5
      if (msect->size != 0)
        {
          mdata->filelen = FILE_ALIGN (mdata->filelen, msect->align);
          msect->offset = mdata->filelen;
        }
d2289 7
a2295 1
        msect->offset = 0;
d2297 9
a2305 2
      sec->filepos = msect->offset;
      sec->target_index = ++target_index;
d2307 2
a2308 1
      mdata->filelen += msect->size;
a2309 2
  seg->filesize = mdata->filelen - seg->fileoff;
  seg->vmsize = seg->filesize;
d2311 14
d2339 2
a2340 2
  /* This must be done first, because bfd_set_section_contents is
     going to set output_has_begun to TRUE.  */
@


1.80
log
@2011-12-16  Shinichiro Hamaji  <shinichiro.hamaji@@gmail.com>

	* mach-o-i386.c (TARGET_PRIORITY): Define as 0 (top priority)
	* mach-o-target.c (TARGET_NAME): Use TARGET_PRIORITY
	* mach-o-x86-64.c (TARGET_PRIORITY): Define as 0 (top priority)
	* mach-o.c (bfd_mach_o_header_p): Remove special handling for
	mach-o-i386.
	(TARGET_PRIORITY) Set 1 for mach-o-be and mach-o-le, and set 0 for
	mach-o-fat.
@
text
@d3553 3
d3559 1
d3564 1
a3565 3
  { "non_lazy_symbol_pointers", BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS},
  { "lazy_symbol_pointers", BFD_MACH_O_S_LAZY_SYMBOL_POINTERS},
  { "symbol_stubs", BFD_MACH_O_S_SYMBOL_STUBS},
a3567 1
  { "coalesced", BFD_MACH_O_S_COALESCED},
a3569 1
  { "16byte_literals", BFD_MACH_O_S_16BYTE_LITERALS},
d3571 2
d3580 2
a3583 1
  { "some_instructions", BFD_MACH_O_S_ATTR_SOME_INSTRUCTIONS },
a3584 1
  { "modifying_code", BFD_MACH_O_S_SELF_MODIFYING_CODE },
a3588 1
  { "pure_instructions", BFD_MACH_O_S_ATTR_PURE_INSTRUCTIONS },
d3590 1
d3597 1
a3597 1
bfd_mach_o_get_section_type_from_name (const char *name)
d3600 1
d3604 8
a3611 1
      return x->val;
d3798 1
@


1.79
log
@2011-12-15  Iain Sandoe  <iains@@gcc.gnu.org>

	* mach-o.c (bfd_mach_o_mkobject_init): Initialize dyn_reloc_cache.
	(bfd_mach_o_close_and_cleanup): Only cleanup Mach-O private data
	for object files.
@
text
@a3263 11
  else
    {
      switch (header.cputype)
        {
        case BFD_MACH_O_CPU_TYPE_I386:
          /* Handled by mach-o-i386 */
          goto wrong;
        default:
          break;
        }
    }
d3794 1
d3802 1
d3809 1
d3818 1
d3840 1
d3849 1
@


1.78
log
@2011-12-15  Shinichiro Hamaji  <shinichiro.hamaji@@gmail.com>

	* mach-o.c (bfd_mach_o_canonicalize_reloc): Update relocation
	table only when there isn't the cahce.
	(bfd_mach_o_get_dynamic_reloc_upper_bound): Need one more space
	for a pointer for the watchdog.
	(bfd_mach_o_canonicalize_dynamic_reloc): Utilize cache like
	bfd_mach_o_canonicalize_reloc.
	(bfd_mach_o_close_and_cleanup): Call bfd_mach_o_free_cached_info.
	(bfd_mach_o_free_cached_info): Free up cache data.
	* mach-o.h (reloc_cache): A place to store cache of dynamic relocs.
	(bfd_mach_o_free_cached_info): Add declaration.
@
text
@d3205 1
d3769 4
a3772 3
    _bfd_dwarf2_cleanup_debug_info (abfd, &mdata->dwarf2_find_line_info);

  bfd_mach_o_free_cached_info (abfd);
@


1.77
log
@bfd/
2011-12-15  Iain Sandoe  <iains@@gcc.gnu.org>

	* mach-o-target.c (bfd_mach_o_bfd_set_private_flags): Use
	bfd_mach_o_bfd_set_private_flags.
	* mach-o.c (bfd_mach_o_bfd_set_private_flags): New.
	* mach-o.h (bfd_mach_o_bfd_set_private_flags): Declare.

gas/
2011-12-15  Iain Sandoe  <iains@@gcc.gnu.org>

	* config/obj-macho.c (obj_mach_o_subsections_by_symbols): New global.
	(obj_mach_o_file_properties): New enum.
	(obj_mach_o_subsections_via_symbols):  Generalize name to...
	... (obj_mach_o_fileprop) and use to set subsections_via_symbols.

gas/testsuite/
2011-12-15  Iain Sandoe  <iains@@gcc.gnu.org>

	* gas/mach-o/subsect-via-symbols-0.d: New.
	* gas/mach-o/subsect-via-symbols-1.d: New.
	* gas/mach-o/subsect-via-symbols.s: New.
@
text
@d1043 5
a1047 3
  res = bfd_malloc (asect->reloc_count * sizeof (arelent));
  if (res == NULL)
    return -1;
d1049 7
a1055 5
  if (bfd_mach_o_canonicalize_relocs (abfd, asect->rel_filepos,
                                      asect->reloc_count, res, syms) < 0)
    {
      free (res);
      return -1;
d1058 1
a1061 1
  asect->relocation = res;
d1073 1
a1073 1
  return (mdata->dysymtab->nextrel + mdata->dysymtab->nlocrel)
d1096 13
a1108 3
  res = bfd_malloc ((dysymtab->nextrel + dysymtab->nlocrel) * sizeof (arelent));
  if (res == NULL)
    return -1;
d1110 7
a1116 6
  if (bfd_mach_o_canonicalize_relocs (abfd, dysymtab->extreloff,
                                      dysymtab->nextrel, res, syms) < 0)
    {
      free (res);
      return -1;
    }
d1118 1
a1118 6
  if (bfd_mach_o_canonicalize_relocs (abfd, dysymtab->locreloff,
                                      dysymtab->nlocrel,
                                      res + dysymtab->nextrel, syms) < 0)
    {
      free (res);
      return -1;
d1121 1
d3770 2
d3775 15
@


1.76
log
@bfd/
2011-12-14  Iain Sandoe  <iains@@gcc.gnu.org>

	* mach-o-i386.c (text_section_names_xlat): New table.
	(data_section_names_xlat): Likewise.
	(import_section_names_xlat): Likewise.
	(mach_o_i386_segsec_names_xlat): Likewise.
	(bfd_mach_o_tgt_seg_table): Use new tables.
	* mach-o-x86-64.c (bfd_mach_o_tgt_seg_table): Set NULL.
	* mach-o.c (mach_o_section_name_xlat, mach_o_segment_name_xlat):
	Move to mach-o.h as   typedefs.
	(text_section_names_xlat): Update for current GCC usage.
	(data_section_names_xlat): Likewise.
	(dwarf_section_names_xlat): Likewise.
	(objc_section_names_xlat): New table.
	(segsec_names_xlat): Add objc table.
	(bfd_mach_o_normalize_section_name):  Replace with...
	(bfd_mach_o_section_data_for_mach_sect): New.
	(bfd_mach_o_section_data_for_bfd_name): New.
	(bfd_mach_o_section_data_for_bfd_name): Update to use additional data.
	(bfd_mach_o_convert_section_name_to_mach_o): Likewise.
	(bfd_mach_o_bfd_copy_private_section_data): Implement.
	(bfd_mach_o_write_symtab): Write a zero-length string as the first entry
	for compatibility with system tools.
	(bfd_mach_o_build_commands): Update section alignment info.
	(bfd_mach_o_new_section_hook): Use translation table data to define
	default section flags, type, attributes and alignment, when available.
	(bfd_mach_o_init_section_from_mach_o): Add TODO comment.
	(bfd_mach_o_section_type_name): Add 'symbol_stubs'.
	(bfd_mach_o_section_attribute_name): Add 'self_modifying_code'.
	(bfd_mach_o_get_section_type_from_name): Change "not-found" return
	value.
	(bfd_mach_o_tgt_seg_table): Set default NULL.
	* mach-o.h (bfd_mach_o_segment_command):  Use define for name length.
	(bfd_mach_o_backend_data): Move until after contents are defined.
	(bfd_mach_o_normalize_section_name): Remove.
	(bfd_mach_o_convert_section_name_to_bfd): Declare.
	(mach_o_section_name_xlat): Declare.
	(mach_o_segment_name_xlat): Declare.
	(bfd_mach_o_section_data_for_mach_sect): Declare.
	(bfd_mach_o_section_data_for_bfd_name): Declare.

include/
2011-12-14  Iain Sandoe  <iains@@gcc.gnu.org>

	* mach-o/loader.h (bfd_mach_o_section_type): define
	BFD_MACH_O_S_ATTR_NONE to 0.


gas/
2011-12-14  Iain Sandoe  <iains@@gcc.gnu.org>

	* config/obj-macho.c: Add some more top-level comments.
	(collect_16char_name): New.
	(obj_mach_o_section): Amend to allow syntax compatible with existing system
	tools.  Use section translation data when available.
	(obj_mach_o_segT_from_bfd_name): New.
	(known_sections): Update.
	(obj_mach_o_known_section): Use obj_mach_o_segT_from_bfd_name.
	(objc_sections): New.
	(obj_mach_o_objc_section): New.
	(debug_sections): New.
	(obj_mach_o_debug_section): New.
	(tgt_sections): New.
	(obj_mach_o_opt_tgt_section): New.
	(obj_mach_o_base_section): New.
	(obj_mach_o_common_parse): Update to create BSS on demand and to handle
	lcomm optional alignment param.
	(obj_mach_o_comm): Update parameter name.
	(obj_mach_o_placeholder): New.
	(mach_o_pseudo_table): Update for GCC section directives.
	* config/obj-macho.h (_OBJ_MACH_O_H): New.
	(USE_ALIGN_PTWO): Define.
	(S_SET_ALIGN) Define.
@
text
@d579 16
@


1.75
log
@2011-12-13  Shinichiro Hamaji  <shinichiro.hamaji@@gmail.com>

	* dwarf2.c (bfd_dwarf2_cleanup_debug_info): Accept stash as an
	argument like other functions to support formats other than ELF.
	* elf-bfd.h (bfd_dwarf2_cleanup_debug_info): Move to bfd-in.h.
	* elf.c (_bfd_elf_close_and_cleanup): Pass dwarf2_find_line_info
	in tdata as a parameter.
	* libbfd-in.h (bfd_dwarf2_cleanup_debug_info): Move from
	elf-bfd.h.
	* libbfd.h (bfd_dwarf2_cleanup_debug_info): Regenerate.
	* mach-o-target.c (bfd_mach_o_close_and_cleanup): Remove the
	fallback macro.
	(bfd_mach_o_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Add the definition
	which calls _bfd_dwarf2_find_nearest_line.
	(bfd_mach_o_close_and_cleanup): Likewise.
	* mach-o.h (mach_o_data_struct): Add dwarf2_find_line_info.
	(bfd_mach_o_find_nearest_line): Add declaration.
	(bfd_mach_o_close_and_cleanup): Add declaration.
@
text
@d90 38
a127 6
struct mach_o_section_name_xlat
{
  const char *bfd_name;
  const char *mach_o_name;
  flagword flags;
};
d129 2
a130 1
static const struct mach_o_section_name_xlat dwarf_section_names_xlat[] =
d132 25
a156 12
    { ".debug_frame",    "__debug_frame",    SEC_DEBUGGING },
    { ".debug_info",     "__debug_info",     SEC_DEBUGGING },
    { ".debug_abbrev",   "__debug_abbrev",   SEC_DEBUGGING },
    { ".debug_aranges",  "__debug_aranges",  SEC_DEBUGGING },
    { ".debug_macinfo",  "__debug_macinfo",  SEC_DEBUGGING },
    { ".debug_line",     "__debug_line",     SEC_DEBUGGING },
    { ".debug_loc",      "__debug_loc",      SEC_DEBUGGING },
    { ".debug_pubnames", "__debug_pubnames", SEC_DEBUGGING },
    { ".debug_pubtypes", "__debug_pubtypes", SEC_DEBUGGING },
    { ".debug_str",      "__debug_str",      SEC_DEBUGGING },
    { ".debug_ranges",   "__debug_ranges",   SEC_DEBUGGING },
    { NULL, NULL, 0}
d159 2
a160 1
static const struct mach_o_section_name_xlat text_section_names_xlat[] =
d162 37
a198 5
    { ".text",     "__text",      SEC_CODE | SEC_LOAD },
    { ".const",    "__const",     SEC_READONLY | SEC_DATA | SEC_LOAD },
    { ".cstring",  "__cstring",   SEC_READONLY | SEC_DATA | SEC_LOAD },
    { ".eh_frame", "__eh_frame",  SEC_READONLY | SEC_LOAD },
    { NULL, NULL, 0}
d201 2
a202 1
static const struct mach_o_section_name_xlat data_section_names_xlat[] =
d204 65
a268 7
    { ".data",                "__data",          SEC_DATA | SEC_LOAD },
    { ".const_data",          "__const",         SEC_DATA | SEC_LOAD },
    { ".dyld",                "__dyld",          SEC_DATA | SEC_LOAD },
    { ".lazy_symbol_ptr",     "__la_symbol_ptr", SEC_DATA | SEC_LOAD },
    { ".non_lazy_symbol_ptr", "__nl_symbol_ptr", SEC_DATA | SEC_LOAD },
    { ".bss",                 "__bss",           SEC_NO_FLAGS },
    { NULL, NULL, 0}
d271 1
a271 12
struct mach_o_segment_name_xlat
{
  /* Segment name.  */
  const char *segname;

  /* List of known sections for the segment.  */
  const struct mach_o_section_name_xlat *sections;
};

/* List of known segment names.  */

static const struct mach_o_segment_name_xlat segsec_names_xlat[] =
d276 1
d280 16
a295 1
/* Mach-O to bfd names.  */
d297 27
a323 3
void
bfd_mach_o_normalize_section_name (const char *segname, const char *sectname,
                                   const char **name, flagword *flags)
d326 6
d333 9
a341 2
  *name = NULL;
  *flags = SEC_NO_FLAGS;
d343 1
d345 6
a350 4
    {
      if (strncmp (seg->segname, segname, BFD_MACH_O_SEGNAME_SIZE) == 0)
        {
          const struct mach_o_section_name_xlat *sec;
d352 1
a352 13
          for (sec = seg->sections; sec->mach_o_name; sec++)
            {
              if (strncmp (sec->mach_o_name, sectname,
                           BFD_MACH_O_SECTNAME_SIZE) == 0)
                {
                  *name = sec->bfd_name;
                  *flags = sec->flags;
                  return;
                }
            }
          return;
        }
    }
d355 10
a364 2
/* Convert Mach-O section name to BFD.  Try to use standard names, otherwise
   forge a new name.  SEGNAME and SECTNAME are 16 bytes strings.  */
d366 4
a369 4
static void
bfd_mach_o_convert_section_name_to_bfd
  (bfd *abfd, const char *segname, const char *sectname,
   const char **name, flagword *flags)
d371 1
d376 17
a392 2
  /* First search for a canonical name.  */
  bfd_mach_o_normalize_section_name (segname, sectname, name, flags);
d394 2
a395 3
  /* Return now if found.  */
  if (*name)
    return;
d412 1
a412 1
  snprintf (res, len, "%s%.16s.%.16s", pfx, segname, sectname);
a413 1
  *flags = SEC_NO_FLAGS;
d416 5
a420 1
/* Convert a bfd section name to a Mach-O segment + section name.  */
d422 4
a425 1
static void
d430 1
a430 1
  const struct mach_o_segment_name_xlat *seg;
d432 1
d438 2
a439 5
  /* List of well known names.  They all start with a dot.  */
  if (name[0] == '.')
    for (seg = segsec_names_xlat; seg->segname; seg++)
      {
        const struct mach_o_section_name_xlat *sec;
d441 8
a448 10
        for (sec = seg->sections; sec->mach_o_name; sec++)
          {
            if (strcmp (sec->bfd_name, name) == 0)
              {
                strcpy (section->segname, seg->segname);
                strcpy (section->sectname, sec->mach_o_name);
                return;
              }
          }
      }
d450 2
a451 1
  /* Strip LC_SEGMENT. prefix.  */
d471 1
a471 1
          return;
d475 6
d487 1
d544 1
a544 1
					  asection *isection ATTRIBUTE_UNUSED,
d546 1
a546 1
					  asection *osection ATTRIBUTE_UNUSED)
d548 10
d1316 6
d1638 3
a1640 1
  /* Create Mach-O sections.  */
d1644 1
a1648 5
      if (msect->flags == 0)
        {
          /* We suppose it hasn't been set.  Convert from BFD flags.  */
          bfd_mach_o_set_section_flags_from_bfd (abfd, sec);
        }
d1651 3
a1653 1
      msect->align = bfd_get_section_alignment (abfd, sec);
d1795 1
d1801 1
d1809 15
a1823 13
      /* Create default name.  */
      bfd_mach_o_convert_section_name_to_mach_o (abfd, sec, s);

      /* Create default flags.  */
      bfd_flags = bfd_get_section_flags (abfd, sec);
      if ((bfd_flags & SEC_CODE) == SEC_CODE)
        s->flags = BFD_MACH_O_S_ATTR_PURE_INSTRUCTIONS
          | BFD_MACH_O_S_ATTR_SOME_INSTRUCTIONS
          | BFD_MACH_O_S_REGULAR;
      else if ((bfd_flags & (SEC_ALLOC | SEC_LOAD)) == SEC_ALLOC)
        s->flags = BFD_MACH_O_S_ZEROFILL;
      else if (bfd_flags & SEC_DEBUGGING)
        s->flags = BFD_MACH_O_S_REGULAR |  BFD_MACH_O_S_ATTR_DEBUG;
d1825 2
a1826 1
        s->flags = BFD_MACH_O_S_REGULAR;
d1842 3
d3554 1
d3571 1
d3575 1
a3575 1
/* Get the section type from NAME.  Return -1 if NAME is unknown.  */
d3585 2
a3586 1
  return (unsigned int)-1;
d3752 1
@


1.74
log
@bfd/
2011-12-13  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_read_symtab_symbols): Make global.  Remove
	prototype.
	(bfd_mach_o_section_get_entry_size): Make global.
	(bfd_mach_o_section_get_nbr_indirect): Likewise.
	(bfd_mach_o_read_symtab_strtab): Likewise.
	(struct bfd_mach_o_xlat_name): Move to mach-o.h
	(bfd_mach_o_print_flags): Move to binutils/od-macho.c
	(bfd_mach_o_get_name_of_null, bfd_mach_o_get_name): Likewise.
	(bfd_mach_o_cpu_name, bfd_mach_o_filetype_name): Likewise.
	(bfd_mach_o_header_flags_name): Likewise.
	(bfd_mach_o_load_command_name): Likewise.
	(bfd_mach_o_print_private_header): Likewise.
	(bfd_mach_o_print_section_map, bfd_mach_o_print_section): Likwise.
	(bfd_mach_o_print_segment, bfd_mach_o_print_dysymtab): Likewise.
	(bfd_mach_o_print_dyld_info): Likewise.
	(bfd_mach_o_print_private_bfd_data): Remove.
	(bfd_mach_o_type_name): Make global.
	(bfd_mach_o_section_attribute_name): Likewise.
	* mach-o.h (bfd_mach_o_xlat_name): Added.
	(bfd_mach_o_section_get_nbr_indirect)
	(bfd_mach_o_section_get_entry_size)
	(bfd_mach_o_read_symtab_symbols)
	(bfd_mach_o_read_symtab_strtab)
	(bfd_mach_o_section_attribute_name)
	(bfd_mach_o_section_type_name): Likewise.
	* mach-o-target.c (bfd_mach_o_bfd_print_private_bfd_data): Define.

binutils/
2011-12-13  Tristan Gingold  <gingold@@adacore.com>

	* od-macho.c: New file.
	* objdump.h (objdump_private_desc_mach_o): Add.
	* configure.in: Add Mach-O od_vectors.
	* Makefile.am (CFILES): Add od-macho.c
	* configure: Regenerate.
	* Makefile.in: Regenerate.
@
text
@d3483 32
@


1.73
log
@2011-12-12  Iain Sandoe  <iains@@gcc.gnu.org>

	* mach-o.c (bfd_mach_o_read_section_32): Null-terminate sectname.
	(bfd_mach_o_read_section_64): Likewise.
@
text
@a39 2
static int bfd_mach_o_read_symtab_symbols (bfd *);

d290 1
a290 1
static unsigned int
d310 1
a310 1
static unsigned int
d1922 1
a1922 1
static bfd_boolean
d1966 1
a1966 1
static bfd_boolean
d3308 1
a3308 120
typedef struct bfd_mach_o_xlat_name
{
  const char *name;
  unsigned long val;
}
bfd_mach_o_xlat_name;

static void
bfd_mach_o_print_flags (const bfd_mach_o_xlat_name *table,
                        unsigned long val,
                        FILE *file)
{
  int first = 1;

  for (; table->name; table++)
    {
      if (table->val & val)
        {
          if (!first)
            fprintf (file, "+");
          fprintf (file, "%s", table->name);
          val &= ~table->val;
          first = 0;
        }
    }
  if (val)
    {
      if (!first)
        fprintf (file, "+");
      fprintf (file, "0x%lx", val);
      return;
    }
  if (first)
    fprintf (file, "-");
}

static const char *
bfd_mach_o_get_name_or_null (const bfd_mach_o_xlat_name *table,
                             unsigned long val)
{
  for (; table->name; table++)
    if (table->val == val)
      return table->name;
  return NULL;
}

static const char *
bfd_mach_o_get_name (const bfd_mach_o_xlat_name *table, unsigned long val)
{
  const char *res = bfd_mach_o_get_name_or_null (table, val);

  if (res == NULL)
    return "*UNKNOWN*";
  else
    return res;
}

static const bfd_mach_o_xlat_name bfd_mach_o_cpu_name[] =
{
  { "vax", BFD_MACH_O_CPU_TYPE_VAX },
  { "mc680x0", BFD_MACH_O_CPU_TYPE_MC680x0 },
  { "i386", BFD_MACH_O_CPU_TYPE_I386 },
  { "mips", BFD_MACH_O_CPU_TYPE_MIPS },
  { "mc98000", BFD_MACH_O_CPU_TYPE_MC98000 },
  { "hppa", BFD_MACH_O_CPU_TYPE_HPPA },
  { "arm", BFD_MACH_O_CPU_TYPE_ARM },
  { "mc88000", BFD_MACH_O_CPU_TYPE_MC88000 },
  { "sparc", BFD_MACH_O_CPU_TYPE_SPARC },
  { "i860", BFD_MACH_O_CPU_TYPE_I860 },
  { "alpha", BFD_MACH_O_CPU_TYPE_ALPHA },
  { "powerpc", BFD_MACH_O_CPU_TYPE_POWERPC },
  { "powerpc_64", BFD_MACH_O_CPU_TYPE_POWERPC_64 },
  { "x86_64", BFD_MACH_O_CPU_TYPE_X86_64 },
  { NULL, 0}
};

static const bfd_mach_o_xlat_name bfd_mach_o_filetype_name[] =
{
  { "object", BFD_MACH_O_MH_OBJECT },
  { "execute", BFD_MACH_O_MH_EXECUTE },
  { "fvmlib", BFD_MACH_O_MH_FVMLIB },
  { "core", BFD_MACH_O_MH_CORE },
  { "preload", BFD_MACH_O_MH_PRELOAD },
  { "dylib", BFD_MACH_O_MH_DYLIB },
  { "dylinker", BFD_MACH_O_MH_DYLINKER },
  { "bundle", BFD_MACH_O_MH_BUNDLE },
  { "dylib_stub", BFD_MACH_O_MH_DYLIB_STUB },
  { "dym", BFD_MACH_O_MH_DSYM },
  { "kext_bundle", BFD_MACH_O_MH_KEXT_BUNDLE },
  { NULL, 0}
};

static const bfd_mach_o_xlat_name bfd_mach_o_header_flags_name[] =
{
  { "noundefs", BFD_MACH_O_MH_NOUNDEFS },
  { "incrlink", BFD_MACH_O_MH_INCRLINK },
  { "dyldlink", BFD_MACH_O_MH_DYLDLINK },
  { "bindatload", BFD_MACH_O_MH_BINDATLOAD },
  { "prebound", BFD_MACH_O_MH_PREBOUND },
  { "split_segs", BFD_MACH_O_MH_SPLIT_SEGS },
  { "lazy_init", BFD_MACH_O_MH_LAZY_INIT },
  { "twolevel", BFD_MACH_O_MH_TWOLEVEL },
  { "force_flat", BFD_MACH_O_MH_FORCE_FLAT },
  { "nomultidefs", BFD_MACH_O_MH_NOMULTIDEFS },
  { "nofixprebinding", BFD_MACH_O_MH_NOFIXPREBINDING },
  { "prebindable", BFD_MACH_O_MH_PREBINDABLE },
  { "allmodsbound", BFD_MACH_O_MH_ALLMODSBOUND },
  { "subsections_via_symbols", BFD_MACH_O_MH_SUBSECTIONS_VIA_SYMBOLS },
  { "canonical", BFD_MACH_O_MH_CANONICAL },
  { "weak_defines", BFD_MACH_O_MH_WEAK_DEFINES },
  { "binds_to_weak", BFD_MACH_O_MH_BINDS_TO_WEAK },
  { "allow_stack_execution", BFD_MACH_O_MH_ALLOW_STACK_EXECUTION },
  { "root_safe", BFD_MACH_O_MH_ROOT_SAFE },
  { "setuid_safe", BFD_MACH_O_MH_SETUID_SAFE },
  { "no_reexported_dylibs", BFD_MACH_O_MH_NO_REEXPORTED_DYLIBS },
  { "pie", BFD_MACH_O_MH_PIE },
  { NULL, 0}
};

static const bfd_mach_o_xlat_name bfd_mach_o_section_type_name[] =
d3330 1
a3330 1
static const bfd_mach_o_xlat_name bfd_mach_o_section_attribute_name[] =
a3344 44
static const bfd_mach_o_xlat_name bfd_mach_o_load_command_name[] =
{
  { "segment", BFD_MACH_O_LC_SEGMENT},
  { "symtab", BFD_MACH_O_LC_SYMTAB},
  { "symseg", BFD_MACH_O_LC_SYMSEG},
  { "thread", BFD_MACH_O_LC_THREAD},
  { "unixthread", BFD_MACH_O_LC_UNIXTHREAD},
  { "loadfvmlib", BFD_MACH_O_LC_LOADFVMLIB},
  { "idfvmlib", BFD_MACH_O_LC_IDFVMLIB},
  { "ident", BFD_MACH_O_LC_IDENT},
  { "fvmfile", BFD_MACH_O_LC_FVMFILE},
  { "prepage", BFD_MACH_O_LC_PREPAGE},
  { "dysymtab", BFD_MACH_O_LC_DYSYMTAB},
  { "load_dylib", BFD_MACH_O_LC_LOAD_DYLIB},
  { "id_dylib", BFD_MACH_O_LC_ID_DYLIB},
  { "load_dylinker", BFD_MACH_O_LC_LOAD_DYLINKER},
  { "id_dylinker", BFD_MACH_O_LC_ID_DYLINKER},
  { "prebound_dylib", BFD_MACH_O_LC_PREBOUND_DYLIB},
  { "routines", BFD_MACH_O_LC_ROUTINES},
  { "sub_framework", BFD_MACH_O_LC_SUB_FRAMEWORK},
  { "sub_umbrella", BFD_MACH_O_LC_SUB_UMBRELLA},
  { "sub_client", BFD_MACH_O_LC_SUB_CLIENT},
  { "sub_library", BFD_MACH_O_LC_SUB_LIBRARY},
  { "twolevel_hints", BFD_MACH_O_LC_TWOLEVEL_HINTS},
  { "prebind_cksum", BFD_MACH_O_LC_PREBIND_CKSUM},
  { "load_weak_dylib", BFD_MACH_O_LC_LOAD_WEAK_DYLIB},
  { "segment_64", BFD_MACH_O_LC_SEGMENT_64},
  { "routines_64", BFD_MACH_O_LC_ROUTINES_64},
  { "uuid", BFD_MACH_O_LC_UUID},
  { "rpath", BFD_MACH_O_LC_RPATH},
  { "code_signature", BFD_MACH_O_LC_CODE_SIGNATURE},
  { "segment_split_info", BFD_MACH_O_LC_SEGMENT_SPLIT_INFO},
  { "reexport_dylib", BFD_MACH_O_LC_REEXPORT_DYLIB},
  { "lazy_load_dylib", BFD_MACH_O_LC_LAZY_LOAD_DYLIB},
  { "encryption_info", BFD_MACH_O_LC_ENCRYPTION_INFO},
  { "dyld_info", BFD_MACH_O_LC_DYLD_INFO},
  { "load_upward_lib", BFD_MACH_O_LC_LOAD_UPWARD_DYLIB},
  { "version_min_macosx", BFD_MACH_O_LC_VERSION_MIN_MACOSX},
  { "version_min_iphoneos", BFD_MACH_O_LC_VERSION_MIN_IPHONEOS},
  { "function_starts", BFD_MACH_O_LC_FUNCTION_STARTS},
  { "dyld_environment", BFD_MACH_O_LC_DYLD_ENVIRONMENT},
  { NULL, 0}
};

a3370 509
static void
bfd_mach_o_print_private_header (bfd *abfd, FILE *file)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  bfd_mach_o_header *h = &mdata->header;

  fputs (_("Mach-O header:\n"), file);
  fprintf (file, _(" magic     : %08lx\n"), h->magic);
  fprintf (file, _(" cputype   : %08lx (%s)\n"), h->cputype,
           bfd_mach_o_get_name (bfd_mach_o_cpu_name, h->cputype));
  fprintf (file, _(" cpusubtype: %08lx\n"), h->cpusubtype);
  fprintf (file, _(" filetype  : %08lx (%s)\n"),
           h->filetype,
           bfd_mach_o_get_name (bfd_mach_o_filetype_name, h->filetype));
  fprintf (file, _(" ncmds     : %08lx (%lu)\n"), h->ncmds, h->ncmds);
  fprintf (file, _(" sizeofcmds: %08lx\n"), h->sizeofcmds);
  fprintf (file, _(" flags     : %08lx ("), h->flags);
  bfd_mach_o_print_flags (bfd_mach_o_header_flags_name, h->flags, file);
  fputs (_(")\n"), file);
  fprintf (file, _(" reserved  : %08x\n"), h->reserved);
}

static void
bfd_mach_o_print_section_map (bfd *abfd, FILE *file)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  unsigned int i;
  unsigned int sec_nbr = 0;

  fputs (_("Segments and Sections:\n"), file);
  fputs (_(" #: Segment name     Section name     Address\n"), file);

  for (i = 0; i < mdata->header.ncmds; i++)
    {
      bfd_mach_o_segment_command *seg;
      bfd_mach_o_section *sec;

      if (mdata->commands[i].type != BFD_MACH_O_LC_SEGMENT
	  && mdata->commands[i].type != BFD_MACH_O_LC_SEGMENT_64)
	continue;

      seg = &mdata->commands[i].command.segment;

      fprintf (file, "[Segment %-16s ", seg->segname);
      fprintf_vma (file, seg->vmaddr);
      fprintf (file, "-");
      fprintf_vma  (file, seg->vmaddr + seg->vmsize - 1);
      fputc (' ', file);
      fputc (seg->initprot & BFD_MACH_O_PROT_READ ? 'r' : '-', file);
      fputc (seg->initprot & BFD_MACH_O_PROT_WRITE ? 'w' : '-', file);
      fputc (seg->initprot & BFD_MACH_O_PROT_EXECUTE ? 'x' : '-', file);
      fprintf (file, "]\n");

      for (sec = seg->sect_head; sec != NULL; sec = sec->next)
	{
	  fprintf (file, "%02u: %-16s %-16s ", ++sec_nbr,
		   sec->segname, sec->sectname);
	  fprintf_vma (file, sec->addr);
	  fprintf (file, " ");
	  fprintf_vma  (file, sec->size);
	  fprintf (file, " %08lx\n", sec->flags);
	}
    }
}

static void
bfd_mach_o_print_section (bfd *abfd ATTRIBUTE_UNUSED,
                          bfd_mach_o_section *sec, FILE *file)
{
  fprintf (file, " Section: %-16s %-16s (bfdname: %s)\n",
           sec->sectname, sec->segname, sec->bfdsection->name);
  fprintf (file, "  addr: ");
  fprintf_vma (file, sec->addr);
  fprintf (file, " size: ");
  fprintf_vma  (file, sec->size);
  fprintf (file, " offset: ");
  fprintf_vma (file, sec->offset);
  fprintf (file, "\n");
  fprintf (file, "  align: %ld", sec->align);
  fprintf (file, "  nreloc: %lu  reloff: ", sec->nreloc);
  fprintf_vma (file, sec->reloff);
  fprintf (file, "\n");
  fprintf (file, "  flags: %08lx (type: %s", sec->flags,
           bfd_mach_o_get_name (bfd_mach_o_section_type_name,
                                sec->flags & BFD_MACH_O_SECTION_TYPE_MASK));
  fprintf (file, " attr: ");
  bfd_mach_o_print_flags (bfd_mach_o_section_attribute_name,
                          sec->flags & BFD_MACH_O_SECTION_ATTRIBUTES_MASK,
                          file);
  fprintf (file, ")\n");
  switch (sec->flags & BFD_MACH_O_SECTION_TYPE_MASK)
    {
    case BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS:
    case BFD_MACH_O_S_LAZY_SYMBOL_POINTERS:
    case BFD_MACH_O_S_SYMBOL_STUBS:
      fprintf (file, "  first indirect sym: %lu", sec->reserved1);
      fprintf (file, " (%u entries)",
               bfd_mach_o_section_get_nbr_indirect (abfd, sec));
      break;
    default:
      fprintf (file, "  reserved1: 0x%lx", sec->reserved1);
      break;
    }
  switch (sec->flags & BFD_MACH_O_SECTION_TYPE_MASK)
    {
    case BFD_MACH_O_S_SYMBOL_STUBS:
      fprintf (file, "  stub size: %lu", sec->reserved2);
      break;
    default:
      fprintf (file, "  reserved2: 0x%lx", sec->reserved2);
      break;
    }
  fprintf (file, "  reserved3: 0x%lx\n", sec->reserved3);
}

static void
bfd_mach_o_print_segment (bfd *abfd ATTRIBUTE_UNUSED,
                          bfd_mach_o_load_command *cmd, FILE *file)
{
  bfd_mach_o_segment_command *seg = &cmd->command.segment;
  bfd_mach_o_section *sec;

  fprintf (file, " name: %s\n", *seg->segname ? seg->segname : "*none*");
  fprintf (file, "    vmaddr: ");
  fprintf_vma (file, seg->vmaddr);
  fprintf (file, "   vmsize: ");
  fprintf_vma  (file, seg->vmsize);
  fprintf (file, "\n");
  fprintf (file, "   fileoff: ");
  fprintf_vma (file, seg->fileoff);
  fprintf (file, " filesize: ");
  fprintf_vma (file, (bfd_vma)seg->filesize);
  fprintf (file, " endoff: ");
  fprintf_vma (file, (bfd_vma)(seg->fileoff + seg->filesize));
  fprintf (file, "\n");
  fprintf (file, "   nsects: %lu  ", seg->nsects);
  fprintf (file, " flags: %lx\n", seg->flags);
  for (sec = seg->sect_head; sec != NULL; sec = sec->next)
    bfd_mach_o_print_section (abfd, sec, file);
}

static void
bfd_mach_o_print_dysymtab (bfd *abfd ATTRIBUTE_UNUSED,
                           bfd_mach_o_load_command *cmd, FILE *file)
{
  bfd_mach_o_dysymtab_command *dysymtab = &cmd->command.dysymtab;
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  unsigned int i;

  fprintf (file, "              local symbols: idx: %10lu  num: %-8lu",
           dysymtab->ilocalsym, dysymtab->nlocalsym);
  fprintf (file, " (nxtidx: %lu)\n",
           dysymtab->ilocalsym + dysymtab->nlocalsym);
  fprintf (file, "           external symbols: idx: %10lu  num: %-8lu",
           dysymtab->iextdefsym, dysymtab->nextdefsym);
  fprintf (file, " (nxtidx: %lu)\n",
           dysymtab->iextdefsym + dysymtab->nextdefsym);
  fprintf (file, "          undefined symbols: idx: %10lu  num: %-8lu",
           dysymtab->iundefsym, dysymtab->nundefsym);
  fprintf (file, " (nxtidx: %lu)\n",
           dysymtab->iundefsym + dysymtab->nundefsym);
  fprintf (file, "           table of content: off: 0x%08lx  num: %-8lu",
           dysymtab->tocoff, dysymtab->ntoc);
  fprintf (file, " (endoff: 0x%08lx)\n",
           dysymtab->tocoff 
           + dysymtab->ntoc * BFD_MACH_O_TABLE_OF_CONTENT_SIZE); 
  fprintf (file, "               module table: off: 0x%08lx  num: %-8lu",
           dysymtab->modtaboff, dysymtab->nmodtab);
  fprintf (file, " (endoff: 0x%08lx)\n",
           dysymtab->modtaboff + dysymtab->nmodtab 
           * (mach_o_wide_p (&mdata->header) ? 
              BFD_MACH_O_DYLIB_MODULE_64_SIZE : BFD_MACH_O_DYLIB_MODULE_SIZE));
  fprintf (file, "   external reference table: off: 0x%08lx  num: %-8lu",
           dysymtab->extrefsymoff, dysymtab->nextrefsyms);
  fprintf (file, " (endoff: 0x%08lx)\n",
           dysymtab->extrefsymoff 
           + dysymtab->nextrefsyms * BFD_MACH_O_REFERENCE_SIZE);
  fprintf (file, "      indirect symbol table: off: 0x%08lx  num: %-8lu",
           dysymtab->indirectsymoff, dysymtab->nindirectsyms);
  fprintf (file, " (endoff: 0x%08lx)\n",
           dysymtab->indirectsymoff 
           + dysymtab->nindirectsyms * BFD_MACH_O_INDIRECT_SYMBOL_SIZE);
  fprintf (file, "  external relocation table: off: 0x%08lx  num: %-8lu",
           dysymtab->extreloff, dysymtab->nextrel);
  fprintf (file, " (endoff: 0x%08lx)\n",
           dysymtab->extreloff + dysymtab->nextrel * BFD_MACH_O_RELENT_SIZE);
  fprintf (file, "     local relocation table: off: 0x%08lx  num: %-8lu",
           dysymtab->locreloff, dysymtab->nlocrel);
  fprintf (file, " (endoff: 0x%08lx)\n",
           dysymtab->locreloff + dysymtab->nlocrel * BFD_MACH_O_RELENT_SIZE);
  
  if (dysymtab->ntoc > 0
      || dysymtab->nindirectsyms > 0
      || dysymtab->nextrefsyms > 0)
    {
      /* Try to read the symbols to display the toc or indirect symbols.  */
      bfd_mach_o_read_symtab_symbols (abfd);
    }
  else if (dysymtab->nmodtab > 0)
    {
      /* Try to read the strtab to display modules name.  */
      bfd_mach_o_read_symtab_strtab (abfd);
    }
  
  for (i = 0; i < dysymtab->nmodtab; i++)
    {
      bfd_mach_o_dylib_module *module = &dysymtab->dylib_module[i];
      fprintf (file, "  module %u:\n", i);
      fprintf (file, "   name: %lu", module->module_name_idx);
      if (mdata->symtab && mdata->symtab->strtab)
        fprintf (file, ": %s",
                 mdata->symtab->strtab + module->module_name_idx);
      fprintf (file, "\n");
      fprintf (file, "   extdefsym: idx: %8lu  num: %lu\n",
               module->iextdefsym, module->nextdefsym);
      fprintf (file, "      refsym: idx: %8lu  num: %lu\n",
               module->irefsym, module->nrefsym);
      fprintf (file, "    localsym: idx: %8lu  num: %lu\n",
               module->ilocalsym, module->nlocalsym);
      fprintf (file, "      extrel: idx: %8lu  num: %lu\n",
               module->iextrel, module->nextrel);
      fprintf (file, "        init: idx: %8u  num: %u\n",
               module->iinit, module->ninit);
      fprintf (file, "        term: idx: %8u  num: %u\n",
               module->iterm, module->nterm);
      fprintf (file, "   objc_module_info: addr: ");
      fprintf_vma (file, module->objc_module_info_addr);
      fprintf (file, "  size: %lu\n", module->objc_module_info_size);
    }

  if (dysymtab->ntoc > 0)
    {
      bfd_mach_o_symtab_command *symtab = mdata->symtab;
      
      fprintf (file, "  table of content: (symbol/module)\n");
      for (i = 0; i < dysymtab->ntoc; i++)
        {
          bfd_mach_o_dylib_table_of_content *toc = &dysymtab->dylib_toc[i];
          
          fprintf (file, "   %4u: ", i);
          if (symtab && symtab->symbols && toc->symbol_index < symtab->nsyms)
            {
              const char *name = symtab->symbols[toc->symbol_index].symbol.name;
              fprintf (file, "%s (%lu)", name ? name : "*invalid*",
                       toc->symbol_index);
            }
          else
            fprintf (file, "%lu", toc->symbol_index);
          
          fprintf (file, " / ");
          if (symtab && symtab->strtab
              && toc->module_index < dysymtab->nmodtab)
            {
              bfd_mach_o_dylib_module *mod;
              mod = &dysymtab->dylib_module[toc->module_index];
              fprintf (file, "%s (%lu)",
                       symtab->strtab + mod->module_name_idx,
                       toc->module_index);
            }
          else
            fprintf (file, "%lu", toc->module_index);
          
          fprintf (file, "\n");
        }
    }

  if (dysymtab->nindirectsyms != 0)
    {
      fprintf (file, "  indirect symbols:\n");

      for (i = 0; i < mdata->nsects; i++)
        {
          bfd_mach_o_section *sec = mdata->sections[i];
          unsigned int j, first, last;
          bfd_mach_o_symtab_command *symtab = mdata->symtab;
          bfd_vma addr;
          bfd_vma entry_size;
      
          switch (sec->flags & BFD_MACH_O_SECTION_TYPE_MASK)
            {
            case BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS:
            case BFD_MACH_O_S_LAZY_SYMBOL_POINTERS:
            case BFD_MACH_O_S_SYMBOL_STUBS:
              first = sec->reserved1;
              last = first + bfd_mach_o_section_get_nbr_indirect (abfd, sec);
              addr = sec->addr;
              entry_size = bfd_mach_o_section_get_entry_size (abfd, sec);
              fprintf (file, "  for section %s.%s:\n",
                       sec->segname, sec->sectname);
              for (j = first; j < last; j++)
                {
                  unsigned int isym = dysymtab->indirect_syms[j];
                  
                  fprintf (file, "   ");
                  fprintf_vma (file, addr);
                  fprintf (file, " %5u: 0x%08x", j, isym);
                  if (isym & BFD_MACH_O_INDIRECT_SYMBOL_LOCAL)
                    fprintf (file, " LOCAL");
                  if (isym & BFD_MACH_O_INDIRECT_SYMBOL_ABS)
                    fprintf (file, " ABSOLUTE");
                  if (symtab && symtab->symbols
                      && isym < symtab->nsyms
                      && symtab->symbols[isym].symbol.name)
                    fprintf (file, " %s", symtab->symbols[isym].symbol.name);
                  fprintf (file, "\n");
                  addr += entry_size;
                }
              break;
            default:
              break;
            }
        }
    }
  if (dysymtab->nextrefsyms > 0)
    {
      bfd_mach_o_symtab_command *symtab = mdata->symtab;
      
      fprintf (file, "  external reference table: (symbol flags)\n");
      for (i = 0; i < dysymtab->nextrefsyms; i++)
        {
          bfd_mach_o_dylib_reference *ref = &dysymtab->ext_refs[i];
          
          fprintf (file, "   %4u: %5lu 0x%02lx", i, ref->isym, ref->flags);
          if (symtab && symtab->symbols
              && ref->isym < symtab->nsyms
              && symtab->symbols[ref->isym].symbol.name)
            fprintf (file, " %s", symtab->symbols[ref->isym].symbol.name);
          fprintf (file, "\n");
        }
    }

}

static void
bfd_mach_o_print_dyld_info (bfd *abfd ATTRIBUTE_UNUSED,
                            bfd_mach_o_load_command *cmd, FILE *file)
{
  bfd_mach_o_dyld_info_command *info = &cmd->command.dyld_info;

  fprintf (file, "       rebase: off: 0x%08x  size: %-8u\n",
           info->rebase_off, info->rebase_size);
  fprintf (file, "         bind: off: 0x%08x  size: %-8u\n",
           info->bind_off, info->bind_size);
  fprintf (file, "    weak bind: off: 0x%08x  size: %-8u\n",
           info->weak_bind_off, info->weak_bind_size);
  fprintf (file, "    lazy bind: off: 0x%08x  size: %-8u\n",
           info->lazy_bind_off, info->lazy_bind_size);
  fprintf (file, "       export: off: 0x%08x  size: %-8u\n",
           info->export_off, info->export_size);
}

bfd_boolean
bfd_mach_o_bfd_print_private_bfd_data (bfd *abfd, void * ptr)
{
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
  FILE *file = (FILE *) ptr;
  unsigned int i;

  bfd_mach_o_print_private_header (abfd, file);
  fputc ('\n', file);

  for (i = 0; i < mdata->header.ncmds; i++)
    {
      bfd_mach_o_load_command *cmd = &mdata->commands[i];
      const char *cmd_name;
      
      cmd_name = bfd_mach_o_get_name_or_null
        (bfd_mach_o_load_command_name, cmd->type);
      fprintf (file, "Load command ");
      if (cmd_name == NULL)
        fprintf (file, "0x%02x:", cmd->type);
      else
        fprintf (file, "%s:", cmd_name);

      switch (cmd->type)
	{
	case BFD_MACH_O_LC_SEGMENT:
	case BFD_MACH_O_LC_SEGMENT_64:
          bfd_mach_o_print_segment (abfd, cmd, file);
	  break;
	case BFD_MACH_O_LC_UUID:
	  {
	    bfd_mach_o_uuid_command *uuid = &cmd->command.uuid;
	    unsigned int j;

	    for (j = 0; j < sizeof (uuid->uuid); j ++)
	      fprintf (file, " %02x", uuid->uuid[j]);
	    fputc ('\n', file);
	  }
	  break;
	case BFD_MACH_O_LC_LOAD_DYLIB:
	case BFD_MACH_O_LC_LOAD_WEAK_DYLIB:
	case BFD_MACH_O_LC_REEXPORT_DYLIB:
        case BFD_MACH_O_LC_LOAD_UPWARD_DYLIB:
	case BFD_MACH_O_LC_ID_DYLIB:
	  {
	    bfd_mach_o_dylib_command *dylib = &cmd->command.dylib;
	    fprintf (file, " %s\n", dylib->name_str);
	    fprintf (file, "            time stamp: 0x%08lx\n",
		     dylib->timestamp);
	    fprintf (file, "       current version: 0x%08lx\n",
		     dylib->current_version);
	    fprintf (file, "  comptibility version: 0x%08lx\n",
		     dylib->compatibility_version);
	    break;
	  }
	case BFD_MACH_O_LC_LOAD_DYLINKER:
	case BFD_MACH_O_LC_ID_DYLINKER:
          fprintf (file, " %s\n", cmd->command.dylinker.name_str);
          break;
	case BFD_MACH_O_LC_SYMTAB:
	  {
	    bfd_mach_o_symtab_command *symtab = &cmd->command.symtab;
	    fprintf (file,
                     "\n"
		     "   symoff: 0x%08x    nsyms: %8u  (endoff: 0x%08x)\n",
                     symtab->symoff, symtab->nsyms,
                     symtab->symoff + symtab->nsyms 
                     * (mach_o_wide_p (&mdata->header) 
                        ? BFD_MACH_O_NLIST_64_SIZE : BFD_MACH_O_NLIST_SIZE));
	    fprintf (file,
		     "   stroff: 0x%08x  strsize: %8u  (endoff: 0x%08x)\n",
		     symtab->stroff, symtab->strsize,
                     symtab->stroff + symtab->strsize);
	    break;
	  }
	case BFD_MACH_O_LC_DYSYMTAB:
          fprintf (file, "\n");
          bfd_mach_o_print_dysymtab (abfd, cmd, file);
          break;
        case BFD_MACH_O_LC_CODE_SIGNATURE:
        case BFD_MACH_O_LC_SEGMENT_SPLIT_INFO:
        case BFD_MACH_O_LC_FUNCTION_STARTS:
	  {
	    bfd_mach_o_linkedit_command *linkedit = &cmd->command.linkedit;
	    fprintf
              (file, "\n"
               "  dataoff: 0x%08lx  datasize: 0x%08lx  (endoff: 0x%08lx)\n",
               linkedit->dataoff, linkedit->datasize,
               linkedit->dataoff + linkedit->datasize);
            break;
          }
        case BFD_MACH_O_LC_SUB_FRAMEWORK:
        case BFD_MACH_O_LC_SUB_UMBRELLA:
        case BFD_MACH_O_LC_SUB_LIBRARY:
        case BFD_MACH_O_LC_SUB_CLIENT:
        case BFD_MACH_O_LC_RPATH:
	  {
	    bfd_mach_o_str_command *str = &cmd->command.str;
	    fprintf (file, " %s\n", str->str);
            break;
          }
        case BFD_MACH_O_LC_THREAD:
        case BFD_MACH_O_LC_UNIXTHREAD:
          {
            bfd_mach_o_thread_command *thread = &cmd->command.thread;
            unsigned int j;
            bfd_mach_o_backend_data *bed = bfd_mach_o_get_backend_data (abfd);

            fprintf (file, " nflavours: %lu\n", thread->nflavours);
            for (j = 0; j < thread->nflavours; j++)
              {
                bfd_mach_o_thread_flavour *flavour = &thread->flavours[j];

                fprintf (file, "  %2u: flavour: 0x%08lx  offset: 0x%08lx"
                         "  size: 0x%08lx\n",
                         j, flavour->flavour, flavour->offset,
                         flavour->size);
                if (bed->_bfd_mach_o_print_thread)
                  {
                    char *buf = bfd_malloc (flavour->size);

                    if (buf
                        && bfd_seek (abfd, flavour->offset, SEEK_SET) == 0
                        && (bfd_bread (buf, flavour->size, abfd) 
                            == flavour->size))
                      (*bed->_bfd_mach_o_print_thread)(abfd, flavour,
                                                       file, buf);
                    free (buf);
                  }
              }
            break;
          }
	case BFD_MACH_O_LC_DYLD_INFO:
          fprintf (file, "\n");
          bfd_mach_o_print_dyld_info (abfd, cmd, file);
          break;
	case BFD_MACH_O_LC_VERSION_MIN_MACOSX:
	case BFD_MACH_O_LC_VERSION_MIN_IPHONEOS:
          {
            bfd_mach_o_version_min_command *ver = &cmd->command.version_min;

            fprintf (file, " %u.%u.%u\n", ver->rel, ver->maj, ver->min);
          }
          break;
	default:
	  fprintf (file, "\n");
          fprintf (file, "  offset: 0x%08lx\n", (unsigned long)cmd->offset);
          fprintf (file, "    size: 0x%08lx\n", (unsigned long)cmd->len);
	  break;
	}
      fputc ('\n', file);
    }

  bfd_mach_o_print_section_map (abfd, file);

  return TRUE;
}

@


1.72
log
@2011-12-07  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_canonicalize_symtab): Fix indentation.
	Adjust the condition.
	(bfd_mach_o_read_symtab_symbol): Now returns a bfd_boolean.
	Adjust return statements.
	(bfd_mach_o_read_symtab_strtab): Likewise.
	(bfd_mach_o_read_symtab_symbols): Likewise.
	(bfd_mach_o_scan_start_address): Likewise.  Make it static.
	(bfd_mach_o_scan): Likewise.
	(bfd_mach_o_read_dysymtab_symbol): Remove unused function.
	(bfd_mach_o_header_p): Adjust call.
	(bfd_mach_o_cpu_name): Make it const.
	(bfd_mach_o_filetype_name): Likewise.
	(bfd_mach_o_header_flags_name): Likewise.
	(bfd_mach_o_section_type_name): Likewise.
	(bfd_mach_o_section_attribute_name): Likewise.
	(bfd_mach_o_load_command_name): Likewise.
	(bfd_mach_o_get_section_type_from_name): Add a const qualifier
	after above change.
	(bfd_mach_o_get_section_attribute_from_name): Likewise.
	* mach-o.h (bfd_mach_o_read_dysymtab_symbol)
	(bfd_mach_o_scan_start_address, bfd_mach_o_scan): Remove.
@
text
@d1701 1
a1701 1
  section->segname[BFD_MACH_O_SECTNAME_SIZE] = 0;
d1740 1
a1740 1
  section->segname[BFD_MACH_O_SECTNAME_SIZE] = 0;
@


1.71
log
@2011-12-05  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_read_symtab_symbol): Accept indirect symbols.
@
text
@d405 1
a405 1
  if (bfd_mach_o_read_symtab_symbols (abfd) != 0)
d407 2
a408 1
      (*_bfd_error_handler) (_("bfd_mach_o_canonicalize_symtab: unable to load symbols"));
d1769 1
a1769 1
static int
d1796 1
a1796 1
      return -1;
d1815 1
a1815 1
      return -1;
d1921 1
a1921 1
  return 0;
d1924 1
a1924 1
static int
d1932 1
a1932 1
    return -1;
d1936 1
a1936 1
    return 0;
d1947 1
a1947 1
	  return -1;
d1955 1
a1955 1
        return -1;
d1958 1
a1958 1
          || bfd_bread ((void *) sym->strtab, sym->strsize, abfd) != sym->strsize)
d1961 1
a1961 1
          return -1;
d1965 1
a1965 1
  return 0;
d1968 1
a1968 1
static int
a1973 1
  int ret;
d1978 1
a1978 1
      return 0;
d1986 1
a1986 1
      return -1;
d1989 2
a1990 3
  ret = bfd_mach_o_read_symtab_strtab (abfd);
  if (ret != 0)
    return ret;
d1994 2
a1995 3
      ret = bfd_mach_o_read_symtab_symbol (abfd, sym, &sym->symbols[i], i);
      if (ret != 0)
	return ret;
d1998 1
a1998 27
  return 0;
}

int
bfd_mach_o_read_dysymtab_symbol (bfd *abfd,
                                 bfd_mach_o_dysymtab_command *dysym,
                                 bfd_mach_o_symtab_command *sym,
                                 bfd_mach_o_asymbol *s,
                                 unsigned long i)
{
  unsigned long isymoff = dysym->indirectsymoff + (i * 4);
  unsigned long sym_index;
  unsigned char raw[4];

  BFD_ASSERT (i < dysym->nindirectsyms);

  if (bfd_seek (abfd, isymoff, SEEK_SET) != 0
      || bfd_bread (raw, sizeof (raw), abfd) != sizeof (raw))
    {
      (*_bfd_error_handler)
        (_("bfd_mach_o_read_dysymtab_symbol: unable to read %lu bytes at %lu"),
         (unsigned long) sizeof (raw), isymoff);
      return -1;
    }
  sym_index = bfd_h_get_32 (abfd, raw);

  return bfd_mach_o_read_symtab_symbol (abfd, sym, s, sym_index);
d2311 1
a2311 1
  
d2768 1
a2768 1
int
d2776 6
a2781 10
    {
      if ((mdata->commands[i].type == BFD_MACH_O_LC_THREAD) ||
	  (mdata->commands[i].type == BFD_MACH_O_LC_UNIXTHREAD))
	{
	  if (cmd == NULL)
	    cmd = &mdata->commands[i].command.thread;
	  else
	    return 0;
	}
    }
d2784 1
a2784 1
    return 0;
d2786 1
d2797 1
a2797 1
	    return -1;
d2808 1
a2808 1
	    return -1;
d2819 1
a2819 1
            return -1;
d2830 1
a2830 1
            return -1;
d2836 1
a2836 1
  return 0;
d2856 1
a2856 1
int
d2892 4
a2895 3
      (*_bfd_error_handler) (_("bfd_mach_o_scan: unknown architecture 0x%lx/0x%lx"),
			     header->cputype, header->cpusubtype);
      return -1;
d2905 1
a2905 1
	return -1;
d2920 1
a2920 1
	    return -1;
d2925 1
a2925 1
    return -1;
d2928 1
a2928 1
  return 0;
d3043 2
a3044 2
  if (bfd_mach_o_scan (abfd, &header,
		       (bfd_mach_o_data_struct *) preserve.marker) != 0)
d3367 1
a3367 1
static bfd_mach_o_xlat_name bfd_mach_o_cpu_name[] =
d3386 1
a3386 1
static bfd_mach_o_xlat_name bfd_mach_o_filetype_name[] = 
d3402 1
a3402 1
static bfd_mach_o_xlat_name bfd_mach_o_header_flags_name[] = 
d3429 1
a3429 1
static bfd_mach_o_xlat_name bfd_mach_o_section_type_name[] = 
d3451 1
a3451 1
static bfd_mach_o_xlat_name bfd_mach_o_section_attribute_name[] = 
d3466 1
a3466 1
static bfd_mach_o_xlat_name bfd_mach_o_load_command_name[] = 
d3515 1
a3515 1
  bfd_mach_o_xlat_name *x;
d3528 1
a3528 1
  bfd_mach_o_xlat_name *x;
@


1.70
log
@2011-12-05  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_write_contents): Handle LC_LOAD_UPWARD_DYLIB.
	(bfd_mach_o_read_dylib): Likewise.
	(bfd_mach_o_read_command): Likewise.
	(bfd_mach_o_bfd_print_private_bfd_data): Likewise.
@
text
@d1904 6
a1909 4
	  (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: "
				   "symbol \"%s\" is unsupported 'indirect' reference: setting to undefined"),
				 s->symbol.name);
	  s->symbol.section = bfd_und_section_ptr;
@


1.69
log
@2011-12-05  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_read_command): Add the bfd in the error
	message.
	(bfd_mach_o_openr_next_archived_file): Use arch name as member name.
	(bfd_mach_o_fat_extract): Ditto.
@
text
@d1297 1
d2104 1
d2689 1
d3957 1
@


1.68
log
@2011-11-22  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_print_symbol): Display COM for common
	symbols.  Print section name in brackets.
@
text
@d2737 2
a2738 2
      (*_bfd_error_handler) (_("unable to read unknown load command 0x%lx"),
			     (unsigned long) command->type);
d3212 3
a3214 16
  /* Create the member filename.
     Use FILENAME:ARCH_NAME.  */
  {
    char *s = NULL;
    const char *arch_name;
    size_t arch_file_len = strlen (bfd_get_filename (archive));

    arch_name = bfd_printable_arch_mach (arch_type, arch_subtype);
    s = bfd_malloc (arch_file_len + 1 + strlen (arch_name) + 1);
    if (s == NULL)
      return NULL;
    memcpy (s, bfd_get_filename (archive), arch_file_len);
    s[arch_file_len] = ':';
    strcpy (s + arch_file_len + 1, arch_name);
    nbfd->filename = s;
  }
d3267 1
a3267 1
      res->filename = strdup (abfd->filename);
@


1.67
log
@2011-09-21  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_convert_section_name_to_bfd): Add comment.
	Deals with size limited strings.
	(bfd_mach_o_build_commands): Initialize more fields.
@
text
@d550 4
a553 1
	    name = "UND";
d577 1
a577 1
	fprintf (file, " %-5s", symbol->section->name);
@


1.66
log
@2011-08-18  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_read_segment): Initialize list.
@
text
@d186 3
d205 1
a205 1
  len = strlen (segname) + 1 + strlen (sectname) + 1;
d220 1
a220 1
  snprintf (res, len, "%s%s.%s", pfx, segname, sectname);
d1412 2
@


1.65
log
@2011-08-17  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_write_section_32): Fix typo.
@
text
@d2596 2
@


1.64
log
@2011-08-08  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (struct mach_o_segment_name_xlat): Add comments.
	(segsec_names_xlat): Reorder elements.
	(bfd_mach_o_read_section_32): Fix typo.
	(bfd_mach_o_read_section_64): Fix typo.
@
text
@d960 1
a960 1
  memcpy (raw.segname + 16, section->segname, 16);
@


1.63
log
@2011-08-08  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h (BFD_MACH_O_SEGNAME_SIZE): New macro.
	(BFD_MACH_O_SECTNAME_SIZE): Ditto.
	(bfd_mach_o_section): Use them.  Add next field.
	(bfd_mach_o_segment_command): Replace sections array by
	sect_head and sect_tail.
	(bfd_mach_o_get_mach_o_section): New macro.
	(bfd_mach_o_lookup_section): Remove.
	(bfd_mach_o_new_section_hook): New function.
	* mach-o.c (bfd_mach_o_normalize_section_name): Use strncmp
	instead of strcmp.
	(bfd_mach_o_convert_section_name_to_bfd): Replaces section
	parameter with segname and sectname parameters.  Adjust.
	(bfd_mach_o_append_section_to_segment): New function.  Use a
	linked list for Mach-O sections.
	(bfd_mach_o_write_segment_32): Adjust.
	(bfd_mach_o_write_segment_64): Ditto.
	(bfd_mach_o_build_commands): Fix comment.  Adjust.
	(bfd_mach_o_flatten_sections): Adjust.
	(bfd_mach_o_print_section_map): Adjust.
	(bfd_mach_o_set_section_flags_from_bfd): Ditto.
	(bfd_mach_o_new_section_hook): New function.
	(bfd_mach_o_init_section_from_mach_o): Ditto.
	(bfd_mach_o_read_section_32): Remove section parameter.
	Return a section instead.
	(bfd_mach_o_read_section_64): Ditto.
	(bfd_mach_o_read_section): Ditto.
	(bfd_mach_o_make_bfd_section): Adjust.
	(bfd_mach_o_read_segment): Adjust for new profile of
	bfd_mach_o_read_section.
	(bfd_mach_o_lookup_section): Remove.
	* mach-o-target.c (bfd_mach_o_new_section_hook): Remove.
@
text
@d137 1
d139 2
d144 2
a147 1
    { "__DWARF", dwarf_section_names_xlat },
d150 1
d1683 1
a1683 1
  sec = bfd_mach_o_make_bfd_section (abfd, raw.sectname, raw.segname);
d1722 1
a1722 1
  sec = bfd_mach_o_make_bfd_section (abfd, raw.sectname, raw.segname);
@


1.62
log
@bfd/
2011-08-08  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h (bfd_mach_o_version_min_command): New structure.
	(bfd_mach_o_load_command): Add version_min.
	(mach_o_data_struct): Fix comment.
	* mach-o.c (bfd_mach_o_read_version_min): New function.
	(bfd_mach_o_read_command): Handle BFD_MACH_O_LC_FUNCTION_STARTS,
	BFD_MACH_O_LC_VERSION_MIN_MACOSX and
	BFD_MACH_O_LC_VERSION_MIN_IPHONEOS.
	(bfd_mach_o_get_name_or_null): New function.
	(bfd_mach_o_get_name): Use the above new one.
	(bfd_mach_o_load_command_name): Add the above new commands.
	(bfd_mach_o_bfd_print_private_bfd_data): Display numerically
	unknown commands.  Handle BFD_MACH_O_LC_FUNCTION_STARTS,
	BFD_MACH_O_LC_VERSION_MIN_MACOSX and
	BFD_MACH_O_LC_VERSION_MIN_IPHONEOS.

include/mach-o/
2011-08-08  Tristan Gingold  <gingold@@adacore.com>

	* loader.h (bfd_mach_o_load_command_type): Add
	BFD_MACH_O_LC_LOAD_UPWARD_DYLIB, BFD_MACH_O_LC_VERSION_MIN_MACOSX,
	BFD_MACH_O_LC_VERSION_MIN_IPHONEOS, BFD_MACH_O_LC_FUNCTION_STARTS,
	and BFD_MACH_O_LC_DYLD_ENVIRONMENT.
	* external.h (mach_o_version_min_command_external): New structure.
@
text
@d162 1
a162 1
      if (strcmp (seg->segname, segname) == 0)
d168 2
a169 1
              if (strcmp (sec->mach_o_name, sectname) == 0)
d182 3
a184 2
bfd_mach_o_convert_section_name_to_bfd (bfd *abfd, bfd_mach_o_section *section,
                                        const char **name, flagword *flags)
d191 1
a191 2
  bfd_mach_o_normalize_section_name (section->segname, section->sectname,
                                     name, flags);
d197 1
a197 2
  len = strlen (section->segname) + 1
    + strlen (section->sectname) + 1;
d201 1
a201 1
  if (section->segname[0] != '_')
d212 1
a212 1
  snprintf (res, len, "%s%s.%s", pfx, section->segname, section->sectname);
d1003 1
a1003 1
  unsigned long i;
d1007 2
a1008 2
  for (i = 0; i < seg->nsects; i++)
    if (!bfd_mach_o_write_relocs (abfd, &seg->sections[i]))
d1025 2
a1026 2
  for (i = 0; i < seg->nsects; i++)
    if (bfd_mach_o_write_section_32 (abfd, &seg->sections[i]))
d1037 1
a1037 1
  unsigned long i;
d1041 2
a1042 2
  for (i = 0; i < seg->nsects; i++)
    if (!bfd_mach_o_write_relocs (abfd, &seg->sections[i]))
d1059 2
a1060 2
  for (i = 0; i < seg->nsects; i++)
    if (bfd_mach_o_write_section_64 (abfd, &seg->sections[i]))
d1302 34
a1343 1
  bfd_mach_o_section *sections;
d1353 2
a1354 1
  /* Very simple version: 1 command (segment) containing all sections.  */
a1363 4
  sections = bfd_alloc (abfd, seg->nsects * sizeof (bfd_mach_o_section));
  if (sections == NULL)
    return FALSE;
  seg->sections = sections;
d1409 12
a1420 5
      sections->bfdsection = sec;
      bfd_mach_o_convert_section_name_to_mach_o (abfd, sec, sections);
      sections->addr = bfd_get_section_vma (abfd, sec);
      sections->size = bfd_get_section_size (sec);
      sections->align = bfd_get_section_alignment (abfd, sec);
d1422 1
a1422 1
      if (sections->size != 0)
d1424 2
a1425 2
          mdata->filelen = FILE_ALIGN (mdata->filelen, sections->align);
          sections->offset = mdata->filelen;
d1428 1
a1428 6
        sections->offset = 0;
      sections->reloff = 0;
      sections->nreloc = 0;
      sections->reserved1 = 0;
      sections->reserved2 = 0;
      sections->reserved3 = 0;
d1430 1
a1430 1
      sec->filepos = sections->offset;
d1433 1
a1433 2
      mdata->filelen += sections->size;
      sections++;
d1558 39
a1596 3
static asection *
bfd_mach_o_make_bfd_section (bfd *abfd, bfd_mach_o_section *section,
			     unsigned long prot)
a1597 2
  asection *bfdsec;
  const char *sname;
d1599 1
d1601 2
a1602 3
  bfd_mach_o_convert_section_name_to_bfd (abfd, section, &sname, &flags);
  if (sname == NULL)
    return NULL;
d1636 23
a1658 2
  bfdsec = bfd_make_section_anyway_with_flags (abfd, sname, flags);
  if (bfdsec == NULL)
d1661 1
a1661 10
  bfdsec->vma = section->addr;
  bfdsec->lma = section->addr;
  bfdsec->size = section->size;
  bfdsec->filepos = section->offset;
  bfdsec->alignment_power = section->align;
  bfdsec->segment_mark = 0;
  bfdsec->reloc_count = section->nreloc;
  bfdsec->rel_filepos = section->reloff;

  return bfdsec;
d1664 1
a1664 1
static int
a1665 1
                            bfd_mach_o_section *section,
d1670 2
d1676 5
a1680 1
    return -1;
d1682 5
a1686 4
  memcpy (section->sectname, raw.sectname, 16);
  section->sectname[16] = '\0';
  memcpy (section->segname, raw.segname, 16);
  section->segname[16] = '\0';
a1696 1
  section->bfdsection = bfd_mach_o_make_bfd_section (abfd, section, prot);
d1698 1
a1698 2
  if (section->bfdsection == NULL)
    return -1;
d1700 1
a1700 1
  return 0;
d1703 1
a1703 1
static int
a1704 1
                            bfd_mach_o_section *section,
d1709 2
d1715 5
a1719 1
    return -1;
d1721 5
a1725 4
  memcpy (section->sectname, raw.sectname, 16);
  section->sectname[16] = '\0';
  memcpy (section->segname, raw.segname, 16);
  section->segname[16] = '\0';
a1735 1
  section->bfdsection = bfd_mach_o_make_bfd_section (abfd, section, prot);
d1737 1
a1737 2
  if (section->bfdsection == NULL)
    return -1;
d1739 1
a1739 1
  return 0;
d1742 1
a1742 1
static int
a1743 1
                         bfd_mach_o_section *section,
d1749 1
a1749 1
    return bfd_mach_o_read_section_64 (abfd, section, offset, prot);
d1751 1
a1751 1
    return bfd_mach_o_read_section_32 (abfd, section, offset, prot);
d2592 1
a2592 1
  if (seg->nsects != 0)
d2594 9
a2602 4
      seg->sections = bfd_alloc (abfd, seg->nsects
                                 * sizeof (bfd_mach_o_section));
      if (seg->sections == NULL)
	return -1;
d2604 3
a2606 9
      for (i = 0; i < seg->nsects; i++)
	{
	  bfd_vma segoff;
          if (wide)
            segoff = command->offset + BFD_MACH_O_LC_SEGMENT_64_SIZE
              + (i * BFD_MACH_O_SECTION_64_SIZE);
          else
            segoff = command->offset + BFD_MACH_O_LC_SEGMENT_SIZE
              + (i * BFD_MACH_O_SECTION_SIZE);
d2608 1
a2608 4
	  if (bfd_mach_o_read_section
	      (abfd, &seg->sections[i], segoff, seg->initprot, wide) != 0)
	    return -1;
	}
d2735 1
a2735 1
  unsigned long i, j;
d2765 1
d2770 2
a2771 2
	  for (j = 0; j < seg->nsects; j++)
	    mdata->sections[csect++] = &seg->sections[j];
a3280 47
bfd_mach_o_lookup_section (bfd *abfd,
			   asection *section,
			   bfd_mach_o_load_command **mcommand,
			   bfd_mach_o_section **msection)
{
  struct mach_o_data_struct *md = bfd_mach_o_get_data (abfd);
  unsigned int i, j, num;

  bfd_mach_o_load_command *ncmd = NULL;
  bfd_mach_o_section *nsect = NULL;

  BFD_ASSERT (mcommand != NULL);
  BFD_ASSERT (msection != NULL);

  num = 0;
  for (i = 0; i < md->header.ncmds; i++)
    {
      struct bfd_mach_o_load_command *cmd = &md->commands[i];
      struct bfd_mach_o_segment_command *seg = NULL;

      if (cmd->type != BFD_MACH_O_LC_SEGMENT
	  || cmd->type != BFD_MACH_O_LC_SEGMENT_64)
	continue;
      seg = &cmd->command.segment;

      for (j = 0; j < seg->nsects; j++)
	{
	  struct bfd_mach_o_section *sect = &seg->sections[j];

	  if (sect->bfdsection == section)
	    {
	      if (num == 0)
                {
                  nsect = sect;
                  ncmd = cmd;
                }
	      num++;
	    }
	}
    }

  *mcommand = ncmd;
  *msection = nsect;
  return num;
}

int
d3585 1
a3585 1
  unsigned int i, j;
d3594 1
d3611 2
a3612 1
      for (j = 0; j < seg->nsects; j++)
a3613 1
	  bfd_mach_o_section *sec = &seg->sections[j];
d3679 1
a3679 1
  unsigned int i;
d3696 2
a3697 2
  for (i = 0; i < seg->nsects; i++)
    bfd_mach_o_print_section (abfd, &seg->sections[i], file);
@


1.61
log
@bfd/
2011-08-08  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h: Move size macros to external.h
	Move reloc macros to reloc.h and x86-64.h.
	* mach-o-i386.c: Includes mach-o/reloc.h
	* mach-o-x86-64.c: Ditto and includes mach-o/x86-64.h
	* mach-o.c: Add includes.
	(bfd_mach_o_write_header): Use structure from external.h to convert.
	(bfd_mach_o_write_thread): Ditto.
	(bfd_mach_o_write_relocs): Ditto.
	(bfd_mach_o_write_section_32): Ditto.
	(bfd_mach_o_write_section_64): Ditto.
	(bfd_mach_o_write_segment_32): Ditto.
	(bfd_mach_o_write_segment_64): Ditto.
	(bfd_mach_o_write_symtab): Ditto.
	(bfd_mach_o_write_contents): Ditto.
	(bfd_mach_o_read_header): Ditto.
	(bfd_mach_o_read_section_32): Ditto.
	(bfd_mach_o_read_section_64): Ditto.
	(bfd_mach_o_read_symtab_symbol): Ditto.
	(bfd_mach_o_read_dylinker): Ditto.
	(bfd_mach_o_read_dylib): Ditto.
	(bfd_mach_o_read_dysymtab): Ditto.
	(bfd_mach_o_read_symtab): Ditto.
	(bfd_mach_o_read_linkedit): Ditto.
	(bfd_mach_o_read_str): Ditto.
	(bfd_mach_o_read_dyld_info): Ditto.
	(bfd_mach_o_read_segment): Ditto.
	(bfd_mach_o_read_command): Ditto.
	(bfd_mach_o_archive_p): Ditto.
	(bfd_mach_o_canonicalize_one_reloc): Ditto. Change the BUF parameter.
	(bfd_mach_o_canonicalize_relocs): Adjust to call the above function.
	(bfd_mach_o_read_dysymtab_symbol): Rename BUF variable.
	(bfd_mach_o_read_uuid): Remove useless cast.  Use a macro instead
	of an hard-coded value.

include/mach-o
2011-08-08  Tristan Gingold  <gingold@@adacore.com>

	* loader.h: Reorder declarations.
	* x86-64.h: New file.
	* external.h: New file.
	* reloc.h: New file.
@
text
@d2436 19
d2628 1
d2636 5
d3336 2
a3337 1
bfd_mach_o_get_name (const bfd_mach_o_xlat_name *table, unsigned long val)
d3342 12
a3353 1
  return "*UNKNOWN*";
d3491 5
d3888 1
d3890 8
a3897 2
      fprintf (file, "Load command %s:",
               bfd_mach_o_get_name (bfd_mach_o_load_command_name, cmd->type));
d3955 1
d4010 8
d4020 2
@


1.60
log
@2011-08-08  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_normalize_section_name): New function.
	(bfd_mach_o_convert_section_name_to_bfd): Use it.
	(bfd_mach_o_get_section_type_from_name): New function.
	(bfd_mach_o_get_section_attribute_from_name): Ditto.
	* mach-o.h (bfd_mach_o_section): Move bfdsection field at the end.
	Add comments.  Add prototypes for the above new functions.
@
text
@d29 2
d619 1
a619 1
  unsigned char buf[32];
d625 7
a631 7
  bfd_h_put_32 (abfd, header->magic, buf + 0);
  bfd_h_put_32 (abfd, header->cputype, buf + 4);
  bfd_h_put_32 (abfd, header->cpusubtype, buf + 8);
  bfd_h_put_32 (abfd, header->filetype, buf + 12);
  bfd_h_put_32 (abfd, header->ncmds, buf + 16);
  bfd_h_put_32 (abfd, header->sizeofcmds, buf + 20);
  bfd_h_put_32 (abfd, header->flags, buf + 24);
d634 1
a634 1
    bfd_h_put_32 (abfd, header->reserved, buf + 28);
d637 1
a637 1
      || bfd_bwrite ((void *) buf, size, abfd) != size)
d648 1
a648 1
  unsigned char buf[8];
d658 2
a659 1
      BFD_ASSERT (cmd->flavours[i].offset == (command->offset + offset + 8));
d661 2
a662 2
      bfd_h_put_32 (abfd, cmd->flavours[i].flavour, buf);
      bfd_h_put_32 (abfd, (cmd->flavours[i].size / 4), buf + 4);
d665 1
a665 1
          || bfd_bwrite ((void *) buf, 8, abfd) != 8)
d668 1
a668 1
      offset += cmd->flavours[i].size + 8;
d682 2
a683 1
bfd_mach_o_canonicalize_one_reloc (bfd *abfd, char *buf,
d693 2
a694 2
  addr = bfd_get_32 (abfd, buf + 0);
  symnum = bfd_get_32 (abfd, buf + 4);
d761 1
a761 1
  char *native_relocs;
d766 2
a767 1
  native_relocs = bfd_malloc (native_size);
d777 2
a778 3
      char *buf = native_relocs + BFD_MACH_O_RELENT_SIZE * i;

      if (bfd_mach_o_canonicalize_one_reloc (abfd, buf, &res[i], syms) < 0)
d908 1
a908 1
      char buf[8];
d925 3
a927 2
          bfd_put_32 (abfd, v, buf);
          bfd_put_32 (abfd, pinfo->r_value, buf + 4);
d933 1
a933 1
          bfd_put_32 (abfd, pinfo->r_address, buf);
d939 1
a939 1
          bfd_put_32 (abfd, v, buf + 4);
d942 1
a942 1
      if (bfd_bwrite ((void *) buf, BFD_MACH_O_RELENT_SIZE, abfd)
d952 1
a952 1
  unsigned char buf[BFD_MACH_O_SECTION_SIZE];
d954 11
a964 11
  memcpy (buf, section->sectname, 16);
  memcpy (buf + 16, section->segname, 16);
  bfd_h_put_32 (abfd, section->addr, buf + 32);
  bfd_h_put_32 (abfd, section->size, buf + 36);
  bfd_h_put_32 (abfd, section->offset, buf + 40);
  bfd_h_put_32 (abfd, section->align, buf + 44);
  bfd_h_put_32 (abfd, section->reloff, buf + 48);
  bfd_h_put_32 (abfd, section->nreloc, buf + 52);
  bfd_h_put_32 (abfd, section->flags, buf + 56);
  bfd_h_put_32 (abfd, section->reserved1, buf + 60);
  bfd_h_put_32 (abfd, section->reserved2, buf + 64);
d966 1
a966 1
  if (bfd_bwrite ((void *) buf, BFD_MACH_O_SECTION_SIZE, abfd)
d976 1
a976 1
  unsigned char buf[BFD_MACH_O_SECTION_64_SIZE];
d978 12
a989 12
  memcpy (buf, section->sectname, 16);
  memcpy (buf + 16, section->segname, 16);
  bfd_h_put_64 (abfd, section->addr, buf + 32);
  bfd_h_put_64 (abfd, section->size, buf + 40);
  bfd_h_put_32 (abfd, section->offset, buf + 48);
  bfd_h_put_32 (abfd, section->align, buf + 52);
  bfd_h_put_32 (abfd, section->reloff, buf + 56);
  bfd_h_put_32 (abfd, section->nreloc, buf + 60);
  bfd_h_put_32 (abfd, section->flags, buf + 64);
  bfd_h_put_32 (abfd, section->reserved1, buf + 68);
  bfd_h_put_32 (abfd, section->reserved2, buf + 72);
  bfd_h_put_32 (abfd, section->reserved3, buf + 76);
d991 1
a991 1
  if (bfd_bwrite ((void *) buf, BFD_MACH_O_SECTION_64_SIZE, abfd)
d1001 1
a1001 1
  unsigned char buf[BFD_MACH_O_LC_SEGMENT_SIZE];
d1011 9
a1019 9
  memcpy (buf, seg->segname, 16);
  bfd_h_put_32 (abfd, seg->vmaddr, buf + 16);
  bfd_h_put_32 (abfd, seg->vmsize, buf + 20);
  bfd_h_put_32 (abfd, seg->fileoff, buf + 24);
  bfd_h_put_32 (abfd, seg->filesize, buf + 28);
  bfd_h_put_32 (abfd, seg->maxprot, buf + 32);
  bfd_h_put_32 (abfd, seg->initprot, buf + 36);
  bfd_h_put_32 (abfd, seg->nsects, buf + 40);
  bfd_h_put_32 (abfd, seg->flags, buf + 44);
d1021 2
a1022 3
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || (bfd_bwrite ((void *) buf, BFD_MACH_O_LC_SEGMENT_SIZE - 8, abfd) 
          != BFD_MACH_O_LC_SEGMENT_SIZE - 8))
d1035 1
a1035 1
  unsigned char buf[BFD_MACH_O_LC_SEGMENT_64_SIZE];
d1045 12
a1056 13
  memcpy (buf, seg->segname, 16);
  bfd_h_put_64 (abfd, seg->vmaddr, buf + 16);
  bfd_h_put_64 (abfd, seg->vmsize, buf + 24);
  bfd_h_put_64 (abfd, seg->fileoff, buf + 32);
  bfd_h_put_64 (abfd, seg->filesize, buf + 40);
  bfd_h_put_32 (abfd, seg->maxprot, buf + 48);
  bfd_h_put_32 (abfd, seg->initprot, buf + 52);
  bfd_h_put_32 (abfd, seg->nsects, buf + 56);
  bfd_h_put_32 (abfd, seg->flags, buf + 60);

  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || (bfd_bwrite ((void *) buf, BFD_MACH_O_LC_SEGMENT_64_SIZE - 8, abfd)
          != BFD_MACH_O_LC_SEGMENT_64_SIZE - 8))
a1070 1
  unsigned char buf[16];
d1107 1
a1107 4
      bfd_h_put_32 (abfd, str_index, buf);
      bfd_h_put_8 (abfd, s->n_type, buf + 4);
      bfd_h_put_8 (abfd, s->n_sect, buf + 5);
      bfd_h_put_16 (abfd, s->n_desc, buf + 6);
d1109 13
a1121 1
        bfd_h_put_64 (abfd, s->symbol.section->vma + s->symbol.value, buf + 8);
d1123 9
a1131 1
        bfd_h_put_32 (abfd, s->symbol.section->vma + s->symbol.value, buf + 8);
d1133 3
a1135 2
      if (bfd_bwrite ((void *) buf, symlen, abfd) != symlen)
        goto err;
d1146 2
a1147 4
  bfd_h_put_32 (abfd, sym->symoff, buf);
  bfd_h_put_32 (abfd, sym->nsyms, buf + 4);
  bfd_h_put_32 (abfd, sym->stroff, buf + 8);
  bfd_h_put_32 (abfd, sym->strsize, buf + 12);
d1149 9
a1157 3
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || bfd_bwrite ((void *) buf, 16, abfd) != 16)
    return FALSE;
d1242 1
a1242 1
      unsigned char buf[8];
d1248 2
a1249 2
      bfd_h_put_32 (abfd, typeflag, buf);
      bfd_h_put_32 (abfd, cur->len, buf + 4);
d1252 1
a1252 1
          || bfd_bwrite ((void *) buf, 8, abfd) != 8)
d1463 1
a1463 1
  unsigned char buf[32];
d1469 1
a1469 1
      || bfd_bread ((void *) buf, 4, abfd) != 4)
d1472 1
a1472 1
  if (bfd_getb32 (buf) == BFD_MACH_O_MH_MAGIC)
d1479 1
a1479 1
  else if (bfd_getl32 (buf) == BFD_MACH_O_MH_MAGIC)
d1486 1
a1486 1
  else if (bfd_getb32 (buf) == BFD_MACH_O_MH_MAGIC_64)
d1493 1
a1493 1
  else if (bfd_getl32 (buf) == BFD_MACH_O_MH_MAGIC_64)
d1511 1
a1511 1
      || bfd_bread ((void *) buf, size, abfd) != size)
d1514 6
a1519 6
  header->cputype = (*get32) (buf + 4);
  header->cpusubtype = (*get32) (buf + 8);
  header->filetype = (*get32) (buf + 12);
  header->ncmds = (*get32) (buf + 16);
  header->sizeofcmds = (*get32) (buf + 20);
  header->flags = (*get32) (buf + 24);
d1522 1
a1522 1
    header->reserved = (*get32) (buf + 28);
d1593 1
a1593 1
  unsigned char buf[BFD_MACH_O_SECTION_SIZE];
d1596 1
a1596 1
      || (bfd_bread ((void *) buf, BFD_MACH_O_SECTION_SIZE, abfd)
d1600 1
a1600 1
  memcpy (section->sectname, buf, 16);
d1602 1
a1602 1
  memcpy (section->segname, buf + 16, 16);
d1604 9
a1612 9
  section->addr = bfd_h_get_32 (abfd, buf + 32);
  section->size = bfd_h_get_32 (abfd, buf + 36);
  section->offset = bfd_h_get_32 (abfd, buf + 40);
  section->align = bfd_h_get_32 (abfd, buf + 44);
  section->reloff = bfd_h_get_32 (abfd, buf + 48);
  section->nreloc = bfd_h_get_32 (abfd, buf + 52);
  section->flags = bfd_h_get_32 (abfd, buf + 56);
  section->reserved1 = bfd_h_get_32 (abfd, buf + 60);
  section->reserved2 = bfd_h_get_32 (abfd, buf + 64);
d1628 1
a1628 1
  unsigned char buf[BFD_MACH_O_SECTION_64_SIZE];
d1631 1
a1631 1
      || (bfd_bread ((void *) buf, BFD_MACH_O_SECTION_64_SIZE, abfd)
d1635 1
a1635 1
  memcpy (section->sectname, buf, 16);
d1637 1
a1637 1
  memcpy (section->segname, buf + 16, 16);
d1639 10
a1648 10
  section->addr = bfd_h_get_64 (abfd, buf + 32);
  section->size = bfd_h_get_64 (abfd, buf + 40);
  section->offset = bfd_h_get_32 (abfd, buf + 48);
  section->align = bfd_h_get_32 (abfd, buf + 52);
  section->reloff = bfd_h_get_32 (abfd, buf + 56);
  section->nreloc = bfd_h_get_32 (abfd, buf + 60);
  section->flags = bfd_h_get_32 (abfd, buf + 64);
  section->reserved1 = bfd_h_get_32 (abfd, buf + 68);
  section->reserved2 = bfd_h_get_32 (abfd, buf + 72);
  section->reserved3 = bfd_h_get_32 (abfd, buf + 76);
d1681 1
a1681 1
  unsigned char buf[16];
d1692 1
a1692 1
      || bfd_bread ((void *) buf, symwidth, abfd) != symwidth)
d1694 3
a1696 2
      (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: unable to read %d bytes at %lu"),
			     symwidth, (unsigned long) symoff);
d1700 2
a1701 2
  stroff = bfd_h_get_32 (abfd, buf);
  type = bfd_h_get_8 (abfd, buf + 4);
d1703 2
a1704 2
  section = bfd_h_get_8 (abfd, buf + 5);
  desc = bfd_h_get_16 (abfd, buf + 6);
d1706 1
a1706 1
    value = bfd_h_get_64 (abfd, buf + 8);
d1708 1
a1708 1
    value = bfd_h_get_32 (abfd, buf + 8);
d1712 4
a1715 3
      (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: symbol name out of range (%lu >= %lu)"),
			     (unsigned long) stroff,
			     (unsigned long) sym->strsize);
d1912 1
a1912 1
  unsigned char buf[4];
d1917 1
a1917 1
      || bfd_bread ((void *) buf, 4, abfd) != 4)
d1919 3
a1921 2
      (*_bfd_error_handler) (_("bfd_mach_o_read_dysymtab_symbol: unable to read %lu bytes at %lu"),
			       (unsigned long) 4, isymoff);
d1924 1
a1924 1
  sym_index = bfd_h_get_32 (abfd, buf);
d1970 1
a1970 1
  unsigned char buf[4];
d1976 2
a1977 2
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || bfd_bread ((void *) buf, 4, abfd) != 4)
d1980 1
a1980 1
  nameoff = bfd_h_get_32 (abfd, buf + 0);
d1997 1
a1997 1
  unsigned char buf[16];
d2012 2
a2013 2
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || bfd_bread ((void *) buf, 16, abfd) != 16)
d2016 4
a2019 4
  nameoff = bfd_h_get_32 (abfd, buf + 0);
  cmd->timestamp = bfd_h_get_32 (abfd, buf + 4);
  cmd->current_version = bfd_h_get_32 (abfd, buf + 8);
  cmd->compatibility_version = bfd_h_get_32 (abfd, buf + 12);
a2046 1
  unsigned char buf[8];
d2059 2
d2065 1
a2065 1
          || bfd_bread ((void *) buf, 8, abfd) != 8)
d2068 1
a2068 1
      offset += 8 + bfd_h_get_32 (abfd, buf + 4) * 4;
d2083 2
d2092 1
a2092 1
          || bfd_bread ((void *) buf, 8, abfd) != 8)
d2095 4
a2098 4
      cmd->flavours[nflavours].flavour = bfd_h_get_32 (abfd, buf);
      cmd->flavours[nflavours].offset = command->offset + offset + 8;
      cmd->flavours[nflavours].size = bfd_h_get_32 (abfd, buf + 4) * 4;
      offset += cmd->flavours[nflavours].size + 8;
a2157 1
  unsigned char buf[72];
d2161 2
a2162 3
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || bfd_bread ((void *) buf, 72, abfd) != 72)
    return -1;
d2164 23
a2186 18
  cmd->ilocalsym = bfd_h_get_32 (abfd, buf + 0);
  cmd->nlocalsym = bfd_h_get_32 (abfd, buf + 4);
  cmd->iextdefsym = bfd_h_get_32 (abfd, buf + 8);
  cmd->nextdefsym = bfd_h_get_32 (abfd, buf + 12);
  cmd->iundefsym = bfd_h_get_32 (abfd, buf + 16);
  cmd->nundefsym = bfd_h_get_32 (abfd, buf + 20);
  cmd->tocoff = bfd_h_get_32 (abfd, buf + 24);
  cmd->ntoc = bfd_h_get_32 (abfd, buf + 28);
  cmd->modtaboff = bfd_h_get_32 (abfd, buf + 32);
  cmd->nmodtab = bfd_h_get_32 (abfd, buf + 36);
  cmd->extrefsymoff = bfd_h_get_32 (abfd, buf + 40);
  cmd->nextrefsyms = bfd_h_get_32 (abfd, buf + 44);
  cmd->indirectsymoff = bfd_h_get_32 (abfd, buf + 48);
  cmd->nindirectsyms = bfd_h_get_32 (abfd, buf + 52);
  cmd->extreloff = bfd_h_get_32 (abfd, buf + 56);
  cmd->nextrel = bfd_h_get_32 (abfd, buf + 60);
  cmd->locreloff = bfd_h_get_32 (abfd, buf + 64);
  cmd->nlocrel = bfd_h_get_32 (abfd, buf + 68);
d2206 1
d2253 1
d2256 1
a2256 1
          if (bfd_bread ((void *) buf, 8, abfd) != 8)
d2259 2
a2260 2
          toc->symbol_index = bfd_h_get_32 (abfd, buf + 0);
          toc->module_index = bfd_h_get_32 (abfd, buf + 4);
d2278 1
d2281 1
a2281 1
          if (bfd_bread ((void *) buf, 4, abfd) != 4)
d2284 1
a2284 1
          *is = bfd_h_get_32 (abfd, buf + 0);
d2303 1
d2306 1
a2306 1
          if (bfd_bread ((void *) buf, 4, abfd) != 4)
d2311 1
a2311 1
          v = bfd_h_get_32 (abfd, buf + 0);
d2337 1
a2337 1
  unsigned char buf[16];
d2341 2
a2342 2
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || bfd_bread ((void *) buf, 16, abfd) != 16)
d2345 4
a2348 4
  symtab->symoff = bfd_h_get_32 (abfd, buf);
  symtab->nsyms = bfd_h_get_32 (abfd, buf + 4);
  symtab->stroff = bfd_h_get_32 (abfd, buf + 8);
  symtab->strsize = bfd_h_get_32 (abfd, buf + 12);
d2368 2
a2369 2
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || bfd_bread ((void *) cmd->uuid, 16, abfd) != 16)
d2379 1
a2379 1
  char buf[8];
d2381 2
a2382 2
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || bfd_bread ((void *) buf, 8, abfd) != 8)
d2385 2
a2386 2
  cmd->dataoff = bfd_get_32 (abfd, buf + 0);
  cmd->datasize = bfd_get_32 (abfd, buf + 4);
d2394 1
a2394 1
  char buf[4];
d2397 2
a2398 2
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || bfd_bread ((void *) buf, 4, abfd) != 4)
d2401 1
a2401 1
  off = bfd_get_32 (abfd, buf + 0);
d2417 1
a2417 1
  char buf[40];
d2419 2
a2420 2
  if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
      || bfd_bread ((void *) buf, sizeof (buf), abfd) != sizeof (buf))
d2423 10
a2432 10
  cmd->rebase_off = bfd_get_32 (abfd, buf + 0);
  cmd->rebase_size = bfd_get_32 (abfd, buf + 4);
  cmd->bind_off = bfd_get_32 (abfd, buf + 8);
  cmd->bind_size = bfd_get_32 (abfd, buf + 12);
  cmd->weak_bind_off = bfd_get_32 (abfd, buf + 16);
  cmd->weak_bind_size = bfd_get_32 (abfd, buf + 20);
  cmd->lazy_bind_off = bfd_get_32 (abfd, buf + 24);
  cmd->lazy_bind_size = bfd_get_32 (abfd, buf + 28);
  cmd->export_off = bfd_get_32 (abfd, buf + 32);
  cmd->export_size = bfd_get_32 (abfd, buf + 36);
a2440 1
  unsigned char buf[64];
d2446 2
d2450 3
a2452 3
      if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
          || bfd_bread ((void *) buf, 64, abfd) != 64)
	return -1;
d2454 1
a2454 1
      memcpy (seg->segname, buf, 16);
d2457 8
a2464 8
      seg->vmaddr = bfd_h_get_64 (abfd, buf + 16);
      seg->vmsize = bfd_h_get_64 (abfd, buf + 24);
      seg->fileoff = bfd_h_get_64 (abfd, buf + 32);
      seg->filesize = bfd_h_get_64 (abfd, buf + 40);
      seg->maxprot = bfd_h_get_32 (abfd, buf + 48);
      seg->initprot = bfd_h_get_32 (abfd, buf + 52);
      seg->nsects = bfd_h_get_32 (abfd, buf + 56);
      seg->flags = bfd_h_get_32 (abfd, buf + 60);
d2468 2
d2472 3
a2474 3
      if (bfd_seek (abfd, command->offset + 8, SEEK_SET) != 0
          || bfd_bread ((void *) buf, 48, abfd) != 48)
	return -1;
d2476 1
a2476 1
      memcpy (seg->segname, buf, 16);
d2479 8
a2486 8
      seg->vmaddr = bfd_h_get_32 (abfd, buf + 16);
      seg->vmsize = bfd_h_get_32 (abfd, buf + 20);
      seg->fileoff = bfd_h_get_32 (abfd, buf + 24);
      seg->filesize = bfd_h_get_32 (abfd, buf +  28);
      seg->maxprot = bfd_h_get_32 (abfd, buf + 32);
      seg->initprot = bfd_h_get_32 (abfd, buf + 36);
      seg->nsects = bfd_h_get_32 (abfd, buf + 40);
      seg->flags = bfd_h_get_32 (abfd, buf + 44);
d2530 2
a2531 1
  unsigned char buf[8];
d2535 1
a2535 1
      || bfd_bread ((void *) buf, 8, abfd) != 8)
d2538 4
a2541 4
  command->type = bfd_h_get_32 (abfd, buf) & ~BFD_MACH_O_LC_REQ_DYLD;
  command->type_required = (bfd_h_get_32 (abfd, buf) & BFD_MACH_O_LC_REQ_DYLD
			    ? TRUE : FALSE);
  command->len = bfd_h_get_32 (abfd, buf + 4);
d2995 1
a2995 1
  unsigned char buf[20];
d2999 1
a2999 1
      || bfd_bread ((void *) buf, 8, abfd) != 8)
d3006 2
a3007 2
  adata->magic = bfd_getb32 (buf);
  adata->nfat_arch = bfd_getb32 (buf + 4);
d3023 2
a3024 2
      if (bfd_seek (abfd, 8 + 20 * i, SEEK_SET) != 0
          || bfd_bread ((void *) buf, 20, abfd) != 20)
d3026 5
a3030 5
      adata->archentries[i].cputype = bfd_getb32 (buf);
      adata->archentries[i].cpusubtype = bfd_getb32 (buf + 4);
      adata->archentries[i].offset = bfd_getb32 (buf + 8);
      adata->archentries[i].size = bfd_getb32 (buf + 12);
      adata->archentries[i].align = bfd_getb32 (buf + 16);
@


1.59
log
@2011-08-03  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_canonicalize_symtab): Handle no symbols case.
	(bfd_mach_o_read_symtab_symbols): Return if no symbols.
@
text
@a146 1

d149 3
a151 3
static void
bfd_mach_o_convert_section_name_to_bfd (bfd *abfd, bfd_mach_o_section *section,
                                        char **name, flagword *flags)
a153 3
  char *res;
  unsigned int len;
  const char *pfx = "";
d160 1
a160 1
      if (strcmp (seg->segname, section->segname) == 0)
d166 1
a166 1
              if (strcmp (sec->mach_o_name, section->sectname) == 0)
d168 1
a168 7
                  len = strlen (sec->bfd_name);
                  res = bfd_alloc (abfd, len + 1);

                  if (res == NULL)
                    return;
                  strcpy (res, sec->bfd_name);
                  *name = res;
d173 1
d176 17
d212 1
d1508 1
a1508 1
  char *sname;
d3416 26
@


1.58
log
@2011-06-28  Fawzi Mohamed <fawzi.mohamed@@nokia.com>

	* mach-o.c (bfd_mach_o_read_command): Also ignore
	BFD_MACH_O_LC_ROUTINES_64.
@
text
@d379 7
d1840 5
a1844 2
  if (sym->symbols)
    return 0;
@


1.57
log
@	* bfd.c (bfd_perror): Flush stdout before and stderr after printing
	error.
	(_bfd_default_error_handler): Likewise.
	* elf.c (print_segment_map): Likewise.
	* libbfd.c (warn_deprecated): Likewise.
	* som.c (som_sizeof_headers): No need to do so here.
	* coff-i860.c: Replace use of printf for error messages with
	_bfd_error_handler.
	* coff-ppc.c: Likewise.
	* coff-sh.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-mep.c: Likewise.
	* elf32-v850.c: Likewise.
	* mach-o.c: Likewise.
	* pef.c: Likewise.
@
text
@d2526 1
@


1.56
log
@fix set but unused variable warnings
@
text
@d3 1
a3 1
   2009, 2010
d381 1
a381 2
      fprintf (stderr,
               "bfd_mach_o_canonicalize_symtab: unable to load symbols\n");
d1253 2
a1254 3
	  fprintf (stderr,
		   "unable to write unknown load command 0x%lx\n",
		   (unsigned long) cur->type);
d1654 2
a1655 2
      fprintf (stderr, "bfd_mach_o_read_symtab_symbol: unable to read %d bytes at %lu\n",
	       symwidth, (unsigned long) symoff);
d1671 3
a1673 2
      fprintf (stderr, "bfd_mach_o_read_symtab_symbol: symbol name out of range (%lu >= %lu)\n",
	       (unsigned long) stroff, (unsigned long) sym->strsize);
d1756 3
a1758 3
		  fprintf (stderr, "bfd_mach_o_read_symtab_symbol: "
			   "symbol \"%s\" specified invalid section %d (max %lu): setting to undefined\n",
			   s->symbol.name, section, mdata->nsects);
d1764 3
a1766 3
	  fprintf (stderr, "bfd_mach_o_read_symtab_symbol: "
		   "symbol \"%s\" is unsupported 'indirect' reference: setting to undefined\n",
		   s->symbol.name);
d1770 3
a1772 3
	  fprintf (stderr, "bfd_mach_o_read_symtab_symbol: "
		   "symbol \"%s\" specified invalid type field 0x%x: setting to undefined\n",
		   s->symbol.name, symtype);
d1840 1
a1840 1
      fprintf (stderr, "bfd_mach_o_read_symtab_symbols: unable to allocate memory for symbols\n");
d1874 2
a1875 2
      fprintf (stderr, "bfd_mach_o_read_dysymtab_symbol: unable to read %lu bytes at %lu\n",
	       (unsigned long) 4, isymoff);
d2556 2
a2557 2
      fprintf (stderr, "unable to read unknown load command 0x%lx\n",
	       (unsigned long) command->type);
d2736 2
a2737 2
      fprintf (stderr, "bfd_mach_o_scan: unknown architecture 0x%lx/0x%lx\n",
	       header->cputype, header->cpusubtype);
d2832 2
a2833 2
      fprintf (stderr, "unknown header byte-order value 0x%lx\n",
	       (unsigned long) header.byteorder);
@


1.56.4.1
log
@backport from mainline
@
text
@d3 1
a3 1
   2009, 2010, 2011
d381 2
a382 1
      (*_bfd_error_handler) (_("bfd_mach_o_canonicalize_symtab: unable to load symbols"));
d1254 3
a1256 2
	  (*_bfd_error_handler) (_("unable to write unknown load command 0x%lx"),
				 (unsigned long) cur->type);
d1656 2
a1657 2
      (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: unable to read %d bytes at %lu"),
			     symwidth, (unsigned long) symoff);
d1673 2
a1674 3
      (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: symbol name out of range (%lu >= %lu)"),
			     (unsigned long) stroff,
			     (unsigned long) sym->strsize);
d1757 3
a1759 3
		  (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: "
					   "symbol \"%s\" specified invalid section %d (max %lu): setting to undefined"),
					 s->symbol.name, section, mdata->nsects);
d1765 3
a1767 3
	  (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: "
				   "symbol \"%s\" is unsupported 'indirect' reference: setting to undefined"),
				 s->symbol.name);
d1771 3
a1773 3
	  (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbol: "
				   "symbol \"%s\" specified invalid type field 0x%x: setting to undefined"),
				 s->symbol.name, symtype);
d1841 1
a1841 1
      (*_bfd_error_handler) (_("bfd_mach_o_read_symtab_symbols: unable to allocate memory for symbols"));
d1875 2
a1876 2
      (*_bfd_error_handler) (_("bfd_mach_o_read_dysymtab_symbol: unable to read %lu bytes at %lu"),
			       (unsigned long) 4, isymoff);
d2557 2
a2558 2
      (*_bfd_error_handler) (_("unable to read unknown load command 0x%lx"),
			     (unsigned long) command->type);
d2737 2
a2738 2
      (*_bfd_error_handler) (_("bfd_mach_o_scan: unknown architecture 0x%lx/0x%lx"),
			     header->cputype, header->cpusubtype);
d2833 2
a2834 2
      (*_bfd_error_handler) (_("unknown header byte-order value 0x%lx"),
			     (unsigned long) header.byteorder);
@


1.55
log
@Update copyright year.

2010-03-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-target.h: Update copyright year.
	* aout-tic30.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* elf64-mips.c: Likewise.
	* ieee.c: Likewise.
	* libecoff.h: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* oasys.c: Likewise.
	* targets.c: Likewise.
@
text
@a632 1
  unsigned int nflavours;
a637 1
  nflavours = 0;
@


1.54
log
@2010-02-09  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_canonicalize_one_reloc): Adjust addend for
	non-external relocation.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.53
log
@2010-02-08  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_canonicalize_one_reloc): Set reloc.r_extern
	for non-scattered relocations.
@
text
@d717 6
@


1.52
log
@2010-01-26  Tristan Gingold  <gingold@@adacore.com>

	* targets.c (BFD_JUMP_TABLE_ARCHIVE): Add initializer for write_ar_hdr.
	(bfd_target): Add _bfd_write_ar_hdr_fn field.
	* archive.c (is_bsd44_extended_name): New macro.
	(_bfd_generic_read_ar_hdr_mag): Use it.  Add extra_size.
	(bfd_slurp_armap): Also check for "__.SYMDEF" as a BSD4.4 extended
	name.
	(_bfd_archive_bsd44_construct_extended_name_table): New function.
	(_bfd_generic_write_ar_hdr): Ditto.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_archive_contents): Call _bfd_write_ar_hdr.
	(bsd_write_armap): Adjust firstreal computation.
	* libbfd-in.h (struct areltdata): Add extra_size field.
	(_bfd_generic_write_ar_hdr): Add prototype.
	(_bfd_bsd44_write_ar_hdr): Ditto.
	(_bfd_write_ar_hdr): Define.
	(_bfd_noarchive_write_ar_hdr): Ditto.
	(_bfd_archive_bsd_write_ar_hdr): Ditto.
	(_bfd_archive_coff_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_slurp_armap): Ditto.
	(_bfd_archive_bsd44_slurp_extended_name_table): Ditto.
	(_bfd_archive_bsd44_construct_extended_name_table): New prototype.
	(_bfd_archive_bsd44_truncate_arname): Ditto.
	(_bfd_archive_bsd44_write_armap): Ditto.
	(_bfd_archive_bsd44_read_ar_hdr): Ditto.
	(_bfd_archive_bsd44_write_ar_hdr): Ditto.
	(_bfd_archive_bsd44_openr_next_archived_file): Ditto.
	(_bfd_archive_bsd44_get_elt_at_index): Ditto.
	(_bfd_archive_bsd44_generic_stat_arch_elt): Ditto.
	(_bfd_archive_bsd44_update_armap_timestamp): Ditto.
	* libbfd.h: Regenerate.
	* oasys.c (oasys_write_ar_hdr): Define.
	* libecoff.h (_bfd_ecoff_write_ar_hdr): Define.
	* ieee.c (ieee_write_ar_hdr): Define.
	* elf64-mips.c (bfd_elf64_archive_write_ar_hdr): Define.
	* coff-rs6000.c (rs6000coff_vec): Adjust for write_ar_hdr field.
	(bfd_pmac_xcoff_backend_data): Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(bfd_xcoff_aix5_backend_data): Ditto.
	* coff-alpha.c (alpha_ecoff_write_ar_hdr): Define.
	* aout-target.h (MY_write_ar_hdr): Define it if not defined.
	* aout-tic30.c (MY_write_ar_hdr): Ditto.
	* mach-o-target.c (TARGET_NAME): Use _bfd_archive_bsd44 archive.
	(bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved to mach-o.c
	* mach-o.c (bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr)
	(bfd_mach_o_slurp_armap, bfd_mach_o_slurp_extended_name_table)
	(bfd_mach_o_construct_extended_name_table)
	(bfd_mach_o_truncate_arname, bfd_mach_o_write_armap)
	(bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt)
	(bfd_mach_o_update_armap_timestamp): Moved from mach-o-target.c
	* bfd-in2.h: Regenerate.
@
text
@d708 4
a711 1
        sym = syms + num;
d717 1
@


1.51
log
@2010-01-11  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h (bfd_mach_o_backend_data): Add arch field.
	(bfd_mach_o_set_arch_mach): New prototype.
	* mach-o.c (bfd_mach_o_mkobject): Define with bfd_mach_o_gen_mkobject.
	(bfd_mach_o_set_arch_mach): New function.
	(bfd_mach_o_gen_mkobject): New function.
	Set TARGET_ARCHITECTURE for the generic back-ends.
	* mach-o-target.c (bfd_mach_o_set_arch_mach): Remove define.
	Check that TARGET_ARCHITECTURE is defined.
	Add TARGET_ARCHITECTURE in TARGET_NAME_BACKEND structure.
	* mach-o-i386.c (TARGET_ARCHITECTURE): Define.
@
text
@d4023 15
@


1.50
log
@2009-12-15  Tristan Gingold  <gingold@@adacore.com>

        * mach-o.h (bfd_mach_o_uuid_command): Remove section field.
        * mach-o.c (bfd_mach_o_scan_read_uuid): Do not create a section
        from this command.
@
text
@d32 1
a32 1
#define bfd_mach_o_mkobject bfd_false
d2675 17
d2791 18
d3998 1
d4005 1
d4011 1
d4019 1
d4025 1
d4033 1
@


1.49
log
@2009-12-15  Tristan Gingold  <gingold@@adacore.com>

        * mach-o.c (struct mach_o_section_name_xlat): Add flags field.
        (dwarf_section_names_xlat): Add section flags.
        (text_section_names_xlat): Ditto.
        (data_section_names_xlat): Ditto.
        (bfd_mach_o_convert_section_name_to_bfd): Now return name and section
        flags by reference.
        (bfd_mach_o_make_bfd_section): Use section flags when know, otherwise
        try to guess.
@
text
@a2300 3
  asection *bfdsec;
  char *sname;
  static const char prefix[] = "LC_UUID";
a2307 17
  sname = bfd_alloc (abfd, strlen (prefix) + 1);
  if (sname == NULL)
    return -1;
  strcpy (sname, prefix);

  bfdsec = bfd_make_section_anyway_with_flags (abfd, sname, SEC_HAS_CONTENTS);
  if (bfdsec == NULL)
    return -1;

  bfdsec->vma = 0;
  bfdsec->lma = 0;
  bfdsec->size = command->len - 8;
  bfdsec->filepos = command->offset + 8;
  bfdsec->alignment_power = 0;

  cmd->section = bfdsec;

@


1.48
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d93 1
d98 12
a109 12
    { ".debug_frame", "__debug_frame" },
    { ".debug_info", "__debug_info" },
    { ".debug_abbrev", "__debug_abbrev" },
    { ".debug_aranges", "__debug_aranges" },
    { ".debug_macinfo", "__debug_macinfo" },
    { ".debug_line", "__debug_line" },
    { ".debug_loc", "__debug_loc" },
    { ".debug_pubnames", "__debug_pubnames" },
    { ".debug_pubtypes", "__debug_pubtypes" },
    { ".debug_str", "__debug_str" },
    { ".debug_ranges", "__debug_ranges" },
    { NULL, NULL}
d114 5
a118 5
    { ".text", "__text" },
    { ".const", "__const" },
    { ".cstring", "__cstring" },
    { ".eh_frame", "__eh_frame" },
    { NULL, NULL}
d123 7
a129 3
    { ".data", "__data" },
    { ".bss", "__bss" },
    { NULL, NULL}
d149 3
a151 2
static char *
bfd_mach_o_convert_section_name_to_bfd (bfd *abfd, bfd_mach_o_section *section)
d158 3
d175 1
a175 1
                    return NULL;
d177 3
a179 1
                  return res;
d200 1
a200 1
    return NULL;
d202 1
a202 1
  return res;
d1488 1
a1488 1
  sname = bfd_mach_o_convert_section_name_to_bfd (abfd, section);
d1492 1
a1492 2
  if ((section->flags & BFD_MACH_O_S_ATTR_DEBUG)
      || !strcmp (section->segname, "__DWARF"))
d1494 18
a1511 3
      /* Force flags for dwarf sections.  This looks weird but dsym files
         have no flags for them and this is important for gdb.  */
      flags = SEC_HAS_CONTENTS | SEC_DEBUGGING;
d1515 2
a1516 12
      flags = SEC_ALLOC;
      if ((section->flags & BFD_MACH_O_SECTION_TYPE_MASK)
	  != BFD_MACH_O_S_ZEROFILL)
	{
	  flags |= SEC_HAS_CONTENTS | SEC_LOAD;
	  if (prot & BFD_MACH_O_PROT_EXECUTE)
	    flags |= SEC_CODE;
	  if (prot & BFD_MACH_O_PROT_WRITE)
	    flags |= SEC_DATA;
	  else if (prot & BFD_MACH_O_PROT_READ)
	    flags |= SEC_READONLY;
	}
d1518 3
@


1.47
log
@2009-12-03  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_make_bfd_section): Force debug flags for
	all sections of the __DWARF segment.
@
text
@d431 1
a431 2
      unsigned int j, first, last;
      bfd_mach_o_symtab_command *symtab = mdata->symtab;
d492 1
a492 1
			 PTR afile,
d506 1
a506 1
      bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d608 1
a608 1
      || bfd_bwrite ((PTR) buf, size, abfd) != size)
d637 1
a637 1
          || bfd_bwrite ((PTR) buf, 8, abfd) != 8)
d902 1
a902 1
      if (bfd_bwrite ((PTR) buf, BFD_MACH_O_RELENT_SIZE, abfd)
d926 1
a926 1
  if (bfd_bwrite ((PTR) buf, BFD_MACH_O_SECTION_SIZE, abfd)
d951 1
a951 1
  if (bfd_bwrite ((PTR) buf, BFD_MACH_O_SECTION_64_SIZE, abfd)
d982 1
a982 1
      || (bfd_bwrite ((PTR) buf, BFD_MACH_O_LC_SEGMENT_SIZE - 8, abfd) 
d1017 1
a1017 1
      || (bfd_bwrite ((PTR) buf, BFD_MACH_O_LC_SEGMENT_64_SIZE - 8, abfd)
d1057 1
a1057 2
      unsigned char buf[16];
      bfd_size_type index;
d1063 1
a1063 1
        index = 0;
d1066 2
a1067 2
          index = _bfd_stringtab_add (strtab, s->symbol.name, TRUE, FALSE);
          if (index == (bfd_size_type) -1)
d1070 1
a1070 1
      bfd_h_put_32 (abfd, index, buf);
d1079 1
a1079 1
      if (bfd_bwrite ((PTR) buf, symlen, abfd) != symlen)
d1097 1
a1097 1
      || bfd_bwrite ((PTR) buf, 16, abfd) != 16)
d1193 1
a1193 1
          || bfd_bwrite ((PTR) buf, 8, abfd) != 8)
d1411 1
a1411 1
      || bfd_bread ((PTR) buf, 4, abfd) != 4)
d1453 1
a1453 1
      || bfd_bread ((PTR) buf, size, abfd) != size)
d1531 1
a1531 1
      || (bfd_bread ((PTR) buf, BFD_MACH_O_SECTION_SIZE, abfd)
d1566 1
a1566 1
      || (bfd_bread ((PTR) buf, BFD_MACH_O_SECTION_64_SIZE, abfd)
d1627 1
a1627 1
      || bfd_bread ((PTR) buf, symwidth, abfd) != symwidth)
d1789 1
a1789 1
          || bfd_bread ((PTR) sym->strtab, sym->strsize, abfd) != sym->strsize)
d1840 1
a1840 1
  unsigned long symindex;
d1846 1
a1846 1
      || bfd_bread ((PTR) buf, 4, abfd) != 4)
d1852 1
a1852 1
  symindex = bfd_h_get_32 (abfd, buf);
d1854 1
a1854 1
  return bfd_mach_o_read_symtab_symbol (abfd, sym, s, symindex);
d1905 1
a1905 1
      || bfd_bread ((PTR) buf, 4, abfd) != 4)
d1941 1
a1941 1
      || bfd_bread ((PTR) buf, 16, abfd) != 16)
d1992 1
a1992 1
          || bfd_bread ((PTR) buf, 8, abfd) != 8)
d2017 1
a2017 1
          || bfd_bread ((PTR) buf, 8, abfd) != 8)
d2088 1
a2088 1
      || bfd_bread ((PTR) buf, 72, abfd) != 72)
a2111 1
      char buf[56];
d2129 1
a2129 1
          if (bfd_bread ((PTR) buf, module_len, abfd) != module_len)
a2161 1
      char buf[8];
d2176 1
a2176 1
          if (bfd_bread ((PTR) buf, 8, abfd) != 8)
a2185 1
      char buf[4];
d2200 1
a2200 1
          if (bfd_bread ((PTR) buf, 4, abfd) != 4)
a2208 1
      char buf[4];
d2224 1
a2224 1
          if (bfd_bread ((PTR) buf, 4, abfd) != 4)
d2260 1
a2260 1
      || bfd_bread ((PTR) buf, 16, abfd) != 16)
d2290 1
a2290 1
      || bfd_bread ((PTR) cmd->uuid, 16, abfd) != 16)
d2320 1
a2320 1
      || bfd_bread ((PTR) buf, 8, abfd) != 8)
d2336 1
a2336 1
      || bfd_bread ((PTR) buf, 4, abfd) != 4)
d2346 1
a2346 1
      || bfd_bread ((PTR) cmd->str, cmd->str_len, abfd) != cmd->str_len)
d2358 1
a2358 1
      || bfd_bread ((PTR) buf, sizeof (buf), abfd) != sizeof (buf))
d2388 1
a2388 1
          || bfd_bread ((PTR) buf, 64, abfd) != 64)
d2408 1
a2408 1
          || bfd_bread ((PTR) buf, 48, abfd) != 48)
d2469 1
a2469 1
      || bfd_bread ((PTR) buf, 8, abfd) != 8)
d2897 1
a2897 1
      || bfd_bread ((PTR) buf, 8, abfd) != 8)
d2922 1
a2922 1
          || bfd_bread ((PTR) buf, 20, abfd) != 20)
d3706 1
a3706 1
bfd_mach_o_bfd_print_private_bfd_data (bfd *abfd, PTR ptr)
d3730 1
a3730 1
	    unsigned int i;
d3732 2
a3733 2
	    for (i = 0; i < sizeof (uuid->uuid); i++)
	      fprintf (file, " %02x", uuid->uuid[i]);
@


1.46
log
@bfd/
2009-10-09  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_read_command): Handle BFD_MACH_O_LC_RPATH.
	(bfd_mach_o_bfd_print_private_bfd_data): Ditto.
@
text
@d1483 7
a1489 2
  if (section->flags & BFD_MACH_O_S_ATTR_DEBUG)
    flags = SEC_HAS_CONTENTS | SEC_DEBUGGING;
@


1.45
log
@2009-10-09  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_scan_read_symtab_symbols): Rename to
	bfd_mach_o_read_symtab_symbols.
	(bfd_mach_o_scan_write_thread): Rename to bfd_mach_o_write_thread.
	(bfd_mach_o_scan_write_relocs): Rename to bfd_mach_o_write_relocs.
	(bfd_mach_o_scan_write_section_32): Rename to
	bfd_mach_o_write_section_32.
	(bfd_mach_o_scan_write_section_64): Rename to
	bfd_mach_o_write_section_64.
	(bfd_mach_o_scan_write_segment_32): Rename to
	bfd_mach_o_write_segment_32.
	(bfd_mach_o_scan_write_segment_64): Rename to
	bfd_mach_o_write_segment_64.
	(bfd_mach_o_scan_write_symtab): Rename to bfd_mach_o_write_symtab.
	(bfd_mach_o_scan_read_section_32): Rename to
	bfd_mach_o_read_section_32.
	(bfd_mach_o_scan_read_section_64): Rename to
	bfd_mach_o_read_section_64.
	(bfd_mach_o_scan_read_section): Rename to bfd_mach_o_read_section.
	(bfd_mach_o_scan_read_symtab_strtab): Rename to
	bfd_mach_o_read_symtab_strtab.
	(bfd_mach_o_scan_read_symtab_symbol): Rename to
	bfd_mach_o_read_symtab_symbol.
	(bfd_mach_o_scan_read_dysymtab_symbol): Rename to
	bfd_mach_o_read_dysymtab_symbol.
	(bfd_mach_o_scan_read_dylinker): Rename to bfd_mach_o_read_dylinker.
	(bfd_mach_o_scan_read_dylib): Rename to bfd_mach_o_read_dylib.
	(bfd_mach_o_scan_read_prebound_dylib): Rename to
	bfd_mach_o_read_prebound_dylib.
	(bfd_mach_o_scan_read_thread): Rename to bfd_mach_o_read_thread.
	(bfd_mach_o_scan_read_dysymtab): Rename to bfd_mach_o_read_dysymtab.
	(bfd_mach_o_scan_read_symtab): Rename to bfd_mach_o_read_symtab.
	(bfd_mach_o_scan_read_uuid): Rename to bfd_mach_o_read_uuid.
	(bfd_mach_o_scan_read_linkedit): Rename to bfd_mach_o_read_linkedit.
	(bfd_mach_o_scan_read_str): Rename to bfd_mach_o_read_str.
	(bfd_mach_o_scan_read_dyld_info): Rename to bfd_mach_o_read_dyld_info.
	(bfd_mach_o_scan_read_segment): Rename to bfd_mach_o_read_segment.
	(bfd_mach_o_scan_read_segment_32): Rename to
	bfd_mach_o_read_segment_32.
	(bfd_mach_o_scan_read_segment_64): Rename to
	bfd_mach_o_read_segment_64.
	(bfd_mach_o_scan_read_command): Rename to bfd_mach_o_read_command.
	* mach-o.h (bfd_mach_o_scan_read_dysymtab_symbol): Rename to
	bfd_mach_o_read_dysymtab_symbol.
@
text
@d2526 1
d3792 1
@


1.44
log
@2009-10-09  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_section_get_entry_size): Moved.
	(bfd_mach_o_section_get_nbr_indirect): Ditto.
	(bfd_mach_o_get_synthetic_symtab): New function.
	(bfd_mach_o_print_private_header): Print the number of commands
	in decimal.
	* mach-o.h (bfd_mach_o_get_synthetic_symtab): Add prototype.
	* mach-o-target.c: Do not defined bfd_mach_o_get_synthetic_symtab.
@
text
@d37 1
a37 1
static int bfd_mach_o_scan_read_symtab_symbols (bfd *);
d367 1
a367 1
  if (bfd_mach_o_scan_read_symtab_symbols (abfd) != 0)
d616 1
a616 1
bfd_mach_o_scan_write_thread (bfd *abfd, bfd_mach_o_load_command *command)
d840 1
a840 1
bfd_mach_o_scan_write_relocs (bfd *abfd, bfd_mach_o_section *section)
d911 1
a911 1
bfd_mach_o_scan_write_section_32 (bfd *abfd, bfd_mach_o_section *section)
d935 1
a935 1
bfd_mach_o_scan_write_section_64 (bfd *abfd, bfd_mach_o_section *section)
d960 1
a960 1
bfd_mach_o_scan_write_segment_32 (bfd *abfd, bfd_mach_o_load_command *command)
d969 1
a969 1
    if (!bfd_mach_o_scan_write_relocs (abfd, &seg->sections[i]))
d988 1
a988 1
    if (bfd_mach_o_scan_write_section_32 (abfd, &seg->sections[i]))
d995 1
a995 1
bfd_mach_o_scan_write_segment_64 (bfd *abfd, bfd_mach_o_load_command *command)
d1004 1
a1004 1
    if (!bfd_mach_o_scan_write_relocs (abfd, &seg->sections[i]))
d1023 1
a1023 1
    if (bfd_mach_o_scan_write_section_64 (abfd, &seg->sections[i]))
d1030 1
a1030 1
bfd_mach_o_scan_write_symtab (bfd *abfd, bfd_mach_o_load_command *command)
d1201 1
a1201 1
	  if (bfd_mach_o_scan_write_segment_32 (abfd, cur) != 0)
d1205 1
a1205 1
	  if (bfd_mach_o_scan_write_segment_64 (abfd, cur) != 0)
d1209 1
a1209 1
	  if (!bfd_mach_o_scan_write_symtab (abfd, cur))
d1216 1
a1216 1
	  if (bfd_mach_o_scan_write_thread (abfd, cur) != 0)
d1520 4
a1523 4
bfd_mach_o_scan_read_section_32 (bfd *abfd,
				 bfd_mach_o_section *section,
				 unsigned int offset,
				 unsigned long prot)
d1555 4
a1558 4
bfd_mach_o_scan_read_section_64 (bfd *abfd,
				 bfd_mach_o_section *section,
				 unsigned int offset,
				 unsigned long prot)
d1590 5
a1594 5
bfd_mach_o_scan_read_section (bfd *abfd,
			      bfd_mach_o_section *section,
			      unsigned int offset,
			      unsigned long prot,
			      unsigned int wide)
d1597 1
a1597 1
    return bfd_mach_o_scan_read_section_64 (abfd, section, offset, prot);
d1599 1
a1599 1
    return bfd_mach_o_scan_read_section_32 (abfd, section, offset, prot);
d1603 4
a1606 4
bfd_mach_o_scan_read_symtab_symbol (bfd *abfd,
				    bfd_mach_o_symtab_command *sym,
				    bfd_mach_o_asymbol *s,
				    unsigned long i)
d1626 1
a1626 1
      fprintf (stderr, "bfd_mach_o_scan_read_symtab_symbol: unable to read %d bytes at %lu\n",
d1643 1
a1643 1
      fprintf (stderr, "bfd_mach_o_scan_read_symtab_symbol: symbol name out of range (%lu >= %lu)\n",
d1727 1
a1727 1
		  fprintf (stderr, "bfd_mach_o_scan_read_symtab_symbol: "
d1735 1
a1735 1
	  fprintf (stderr, "bfd_mach_o_scan_read_symtab_symbol: "
d1741 1
a1741 1
	  fprintf (stderr, "bfd_mach_o_scan_read_symtab_symbol: "
d1753 1
a1753 1
bfd_mach_o_scan_read_symtab_strtab (bfd *abfd)
d1797 1
a1797 1
bfd_mach_o_scan_read_symtab_symbols (bfd *abfd)
d1811 1
a1811 1
      fprintf (stderr, "bfd_mach_o_scan_read_symtab_symbols: unable to allocate memory for symbols\n");
d1815 1
a1815 1
  ret = bfd_mach_o_scan_read_symtab_strtab (abfd);
d1821 1
a1821 1
      ret = bfd_mach_o_scan_read_symtab_symbol (abfd, sym, &sym->symbols[i], i);
d1830 5
a1834 5
bfd_mach_o_scan_read_dysymtab_symbol (bfd *abfd,
				      bfd_mach_o_dysymtab_command *dysym,
				      bfd_mach_o_symtab_command *sym,
				      bfd_mach_o_asymbol *s,
				      unsigned long i)
d1845 1
a1845 1
      fprintf (stderr, "bfd_mach_o_scan_read_dysymtab_symbol: unable to read %lu bytes at %lu\n",
d1851 1
a1851 1
  return bfd_mach_o_scan_read_symtab_symbol (abfd, sym, s, symindex);
d1892 1
a1892 2
bfd_mach_o_scan_read_dylinker (bfd *abfd,
			       bfd_mach_o_load_command *command)
d1919 1
a1919 1
bfd_mach_o_scan_read_dylib (bfd *abfd, bfd_mach_o_load_command *command)
d1958 2
a1959 2
bfd_mach_o_scan_read_prebound_dylib (bfd *abfd ATTRIBUTE_UNUSED,
				     bfd_mach_o_load_command *command ATTRIBUTE_UNUSED)
d1968 1
a1968 1
bfd_mach_o_scan_read_thread (bfd *abfd, bfd_mach_o_load_command *command)
d2076 1
a2076 1
bfd_mach_o_scan_read_dysymtab (bfd *abfd, bfd_mach_o_load_command *command)
d2252 1
a2252 1
bfd_mach_o_scan_read_symtab (bfd *abfd, bfd_mach_o_load_command *command)
d2281 1
a2281 1
bfd_mach_o_scan_read_uuid (bfd *abfd, bfd_mach_o_load_command *command)
d2315 1
a2315 1
bfd_mach_o_scan_read_linkedit (bfd *abfd, bfd_mach_o_load_command *command)
d2330 1
a2330 1
bfd_mach_o_scan_read_str (bfd *abfd, bfd_mach_o_load_command *command)
d2353 1
a2353 1
bfd_mach_o_scan_read_dyld_info (bfd *abfd, bfd_mach_o_load_command *command)
d2376 3
a2378 3
bfd_mach_o_scan_read_segment (bfd *abfd,
			      bfd_mach_o_load_command *command,
			      unsigned int wide)
d2442 1
a2442 1
	  if (bfd_mach_o_scan_read_section
d2452 1
a2452 1
bfd_mach_o_scan_read_segment_32 (bfd *abfd, bfd_mach_o_load_command *command)
d2454 1
a2454 1
  return bfd_mach_o_scan_read_segment (abfd, command, 0);
d2458 1
a2458 1
bfd_mach_o_scan_read_segment_64 (bfd *abfd, bfd_mach_o_load_command *command)
d2460 1
a2460 1
  return bfd_mach_o_scan_read_segment (abfd, command, 1);
d2464 1
a2464 1
bfd_mach_o_scan_read_command (bfd *abfd, bfd_mach_o_load_command *command)
d2481 1
a2481 1
      if (bfd_mach_o_scan_read_segment_32 (abfd, command) != 0)
d2485 1
a2485 1
      if (bfd_mach_o_scan_read_segment_64 (abfd, command) != 0)
d2489 1
a2489 1
      if (bfd_mach_o_scan_read_symtab (abfd, command) != 0)
d2496 1
a2496 1
      if (bfd_mach_o_scan_read_thread (abfd, command) != 0)
d2501 1
a2501 1
      if (bfd_mach_o_scan_read_dylinker (abfd, command) != 0)
d2508 1
a2508 1
      if (bfd_mach_o_scan_read_dylib (abfd, command) != 0)
d2512 1
a2512 1
      if (bfd_mach_o_scan_read_prebound_dylib (abfd, command) != 0)
d2526 1
a2526 1
      if (bfd_mach_o_scan_read_str (abfd, command) != 0)
d2530 1
a2530 1
      if (bfd_mach_o_scan_read_dysymtab (abfd, command) != 0)
d2537 1
a2537 1
      if (bfd_mach_o_scan_read_uuid (abfd, command) != 0)
d2542 1
a2542 1
      if (bfd_mach_o_scan_read_linkedit (abfd, command) != 0)
d2546 1
a2546 1
      if (bfd_mach_o_scan_read_dyld_info (abfd, command) != 0)
d2739 1
a2739 1
	  if (bfd_mach_o_scan_read_command (abfd, cur) < 0)
d3550 1
a3550 1
      bfd_mach_o_scan_read_symtab_symbols (abfd);
d3555 1
a3555 1
      bfd_mach_o_scan_read_symtab_strtab (abfd);
@


1.43
log
@2009-09-16  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h (bfd_mach_o_filetype): Add new constants from darwin10.
	Reindent.
	* mach-o.c (bfd_mach_o_cpu_name): Reindent.
	(bfd_mach_o_filetype_name): Complete with new constants.  Reindent.
	(bfd_mach_o_print_private_header): Use fputs instead of fprintf
	when possible to avoid warnings.
	(bfd_mach_o_print_section_map): Ditto.
	(bfd_mach_o_section_get_entry_size): New function.
	(bfd_mach_o_section_get_nbr_indirect): Simplify using the newly
	added function.
	(bfd_mach_o_print_dysymtab): Print address of indirect symbols.
@
text
@d257 37
d384 99
d3370 1
a3370 1
  fprintf (file, _(" ncmds     : %08lx\n"), h->ncmds);
a3419 36
/* Return the size of an entry for section SEC.
   Must be called only for symbol pointer section and symbol stubs
   sections.  */

static unsigned int
bfd_mach_o_section_get_entry_size (bfd *abfd, bfd_mach_o_section *sec)
{
  switch (sec->flags & BFD_MACH_O_SECTION_TYPE_MASK)
    {
    case BFD_MACH_O_S_NON_LAZY_SYMBOL_POINTERS:
    case BFD_MACH_O_S_LAZY_SYMBOL_POINTERS:
      return bfd_mach_o_wide_p (abfd) ? 8 : 4;
    case BFD_MACH_O_S_SYMBOL_STUBS:
      return sec->reserved2;
    default:
      BFD_FAIL ();
      return 0;
    }
}

/* Return the number of indirect symbols for a section.
   Must be called only for symbol pointer section and symbol stubs
   sections.  */

static unsigned int
bfd_mach_o_section_get_nbr_indirect (bfd *abfd, bfd_mach_o_section *sec)
{
  unsigned int elsz;

  elsz = bfd_mach_o_section_get_entry_size (abfd, sec);
  if (elsz == 0)
    return 0;
  else
    return sec->size / elsz;
}

@


1.42
log
@2009-09-09  Tristan Gingold  <gingold@@adacore.com>

	Handle DYLD_INFO introduced by Darwin10.
	* mach-o.h (bfd_mach_o_load_command_type): Add
	BFD_MACH_O_LC_DYLD_INFO.
	(bfd_mach_o_dyld_info_command): New type.
	(bfd_mach_o_load_command): Add dyld_info field.
	* mach-o.c (bfd_mach_o_scan_read_str): Reduce size of buf.
	(bfd_mach_o_scan_read_dyld_info): New function.
	(bfd_mach_o_scan_read_command): Handle BFD_MACH_O_LC_DYLD_INFO.
	(bfd_mach_o_bfd_print_private_bfd_data): Ditto.
	(bfd_mach_o_load_command_name): AddB FD_MACH_O_LC_DYLD_INFO.
	(bfd_mach_o_print_dyld_info): New function.
@
text
@d3084 14
a3097 14
  { "vax", BFD_MACH_O_CPU_TYPE_VAX},
  { "mc680x0", BFD_MACH_O_CPU_TYPE_MC680x0},
  { "i386", BFD_MACH_O_CPU_TYPE_I386},
  { "mips", BFD_MACH_O_CPU_TYPE_MIPS},
  { "mc98000", BFD_MACH_O_CPU_TYPE_MC98000},
  { "hppa", BFD_MACH_O_CPU_TYPE_HPPA},
  { "arm", BFD_MACH_O_CPU_TYPE_ARM},
  { "mc88000", BFD_MACH_O_CPU_TYPE_MC88000},
  { "sparc", BFD_MACH_O_CPU_TYPE_SPARC},
  { "i860", BFD_MACH_O_CPU_TYPE_I860},
  { "alpha", BFD_MACH_O_CPU_TYPE_ALPHA},
  { "powerpc", BFD_MACH_O_CPU_TYPE_POWERPC},
  { "powerpc_64", BFD_MACH_O_CPU_TYPE_POWERPC_64},
  { "x86_64", BFD_MACH_O_CPU_TYPE_X86_64},
d3103 11
a3113 8
  { "object", BFD_MACH_O_MH_OBJECT},
  { "execute", BFD_MACH_O_MH_EXECUTE},
  { "fvmlib", BFD_MACH_O_MH_FVMLIB},
  { "core", BFD_MACH_O_MH_CORE},
  { "preload", BFD_MACH_O_MH_PRELOAD},
  { "dylib", BFD_MACH_O_MH_DYLIB},
  { "dylinker", BFD_MACH_O_MH_DYLINKER},
  { "bundle", BFD_MACH_O_MH_BUNDLE},
d3226 1
a3226 1
  fprintf (file, _("Mach-O header:\n"));
d3238 1
a3238 1
  fprintf (file, _(")\n"));
d3249 2
a3250 2
  fprintf (file, _("Segments and Sections:\n"));
  fprintf (file, _(" #: Segment name     Section name     Address\n"));
d3284 1
a3284 1
/* Return the number of indirect symbols for a section.
d3289 1
a3289 1
bfd_mach_o_section_get_nbr_indirect (bfd *abfd, bfd_mach_o_section *sec)
a3290 2
  unsigned int elsz;

d3295 1
a3295 2
      elsz = bfd_mach_o_wide_p (abfd) ? 8 : 4;
      return sec->size / elsz;
d3297 1
a3297 5
      elsz = sec->reserved2;
      if (elsz)
        return sec->size / elsz;
      else
        return 0;
d3304 16
d3530 2
d3540 2
d3548 3
a3550 1
                  fprintf (file, "  %5u: 0x%08x (%u)", j, isym, isym);
d3560 1
@


1.41
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d2198 1
a2198 1
  char buf[8];
d2218 23
d2410 4
d3213 1
d3569 18
d3709 4
@


1.40
log
@2009-06-25  Tristan Gingold  <gingold@@adacore.com>

	* mach-o-target.c (bfd_mach_o_get_dynamic_symtab_upper_bound)
	(bfd_mach_o_canonicalize_dynamic_symtab)
	(bfd_mach_o_get_synthetic_symtab): Defines.
	(TARGET_NAME_BACKEND): Add bfd_mach_o_print_thread entry.
	(TARGET_NAME): Use Mach-O specific functions for dynamic.

	* mach-o-i386.c (bfd_mach_o_i386_swap_reloc_in): Fix howto indexes
	for scattered relocations.
	(bfd_mach_o_i386_print_thread): New function.
	(bfd_mach_o_print_thread): Define.

	* mach-o.c (text_section_names_xlat): Add an entry for __const.
	(bfd_mach_o_canonicalize_one_reloc, bfd_mach_o_canonicalize_relocs):
	New functions extracted from ...
	(bfd_mach_o_canonicalize_reloc): ... This.  Simplified.
	(bfd_mach_o_get_dynamic_reloc_upper_bound): New function.
	(bfd_mach_o_canonicalize_dynamic_reloc): New function.
	(bfd_mach_o_i386_flavour_string): Adjusted after enum renaming.
	(bfd_mach_o_ppc_flavour_string): Reindentation.  Add 64 bits cases.
	(bfd_mach_o_scan_read_dylinker): Do not create a section anymore.
	Set name_str field.
	(bfd_mach_o_scan_read_dylib): Ditto.
	(bfd_mach_o_scan_read_thread): Set mdata at declaration.  Add comments,
	reindent.
	(bfd_mach_o_scan_read_dysymtab): Set mdata at declaration.  Correctly
	decode isym and flags on little endian targets.  Set dysymtab field.
	(bfd_mach_o_scan_start_address): Adjust for enum names.
	(bfd_mach_o_lookup_section): Do not look for segments anymore.
	(bfd_mach_o_print_section): Display bfd section name.
	(bfd_mach_o_print_segment): Display none if no name.
	(bfd_mach_o_print_dysymtab): Display next index for local, external
	and undefined symbols.
	(bfd_mach_o_bfd_print_private_bfd_data): Adjust code by using name_str.
	Display dylinker name. Display thread and unixthread commands content.
	(bfd_mach_o_print_thread): New macro.

	* mach-o.h (bfd_mach_o_mach_header_magic): Align numbers.
	(bfd_mach_o_ppc_thread_flavour): Ditto.
	(bfd_mach_o_i386_thread_flavour): Ditto.
	(BFD_MACH_O_PPC_THREAD_STATE_NONE): New enum.
	(BFD_MACH_O_x86_THREAD_STATE_NONE): Replaces
	BFD_MACH_O_THREAD_STATE_NONE.
	(bfd_mach_o_segment_command): Remove segment field.
	(bfd_mach_o_thread_flavour): Field offset is now unsigned long.
	(bfd_mach_o_dylinker_command): Remove section field, add name_str.
	(bfd_mach_o_prebound_dylib_command): Ditto.
	(bfd_mach_o_dylib_command): Ditto.
	(bfd_mach_o_prebound_dylib_command): Remove section field.
	(mach_o_data_struct): Add dysymtab field.
	(bfd_mach_o_backend_data): Add _bfd_mach_o_print_thread field.
	(bfd_mach_o_get_reloc_upper_bound, bfd_mach_o_canonicalize_reloc)
	(bfd_mach_o_build_commands): Remove parameter names and attributes.
	(bfd_mach_o_get_dynamic_reloc_upper_bound)
	(bfd_mach_o_canonicalize_dynamic_reloc): New prototypes.
@
text
@d1258 1
a1258 1
  asymbol *new;
d1260 6
a1265 6
  new = bfd_zalloc (abfd, sizeof (bfd_mach_o_asymbol));
  if (new == NULL)
    return new;
  new->the_bfd = abfd;
  new->udata.i = 0;
  return new;
@


1.39
log
@2009-06-22  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_canonicalize_reloc): Append a sentinel to
	the relocs array.
@
text
@d114 1
d518 96
a617 1
  bfd_mach_o_data_struct *mdata = bfd_mach_o_get_data (abfd);
a620 2
  char *native_relocs;
  bfd_size_type native_size;
d629 2
a630 4
  /* Allocate and read relocs.  */
  native_size = asect->reloc_count * BFD_MACH_O_RELENT_SIZE;
  native_relocs = bfd_malloc (native_size);
  if (native_relocs == NULL)
d633 2
a634 2
  if (bfd_seek (abfd, asect->rel_filepos, SEEK_SET) != 0
      || bfd_bread (native_relocs, native_size, abfd) != native_size)
d636 1
a636 1
      free (native_relocs);
d640 39
a678 1
  res = bfd_malloc (asect->reloc_count * sizeof (arelent));
d680 4
d685 1
a685 1
      free (native_relocs);
d689 3
a691 1
  for (i = 0; i < asect->reloc_count; i++)
d693 3
a695 52
      char *buf = native_relocs + BFD_MACH_O_RELENT_SIZE * i;
      bfd_mach_o_reloc_info reloc;
      bfd_vma addr;
      bfd_vma symnum;
      asymbol **sym;

      addr = bfd_get_32 (abfd, buf + 0);
      symnum = bfd_get_32 (abfd, buf + 4);

      if (addr & BFD_MACH_O_SR_SCATTERED)
	{
          unsigned int j;

          /* Scattered relocation.
             Extract section and offset from r_value.  */
	  res[i].sym_ptr_ptr = NULL;
	  res[i].addend = 0;
          for (j = 0; j < mdata->nsects; j++)
            {
              bfd_mach_o_section *sect = mdata->sections[j];
              if (symnum >= sect->addr && symnum < sect->addr + sect->size)
                {
                  res[i].sym_ptr_ptr = sect->bfdsection->symbol_ptr_ptr;
                  res[i].addend = symnum - sect->addr;
                  break;
                }
            }
	  res[i].address = BFD_MACH_O_GET_SR_ADDRESS (addr);
	  reloc.r_type = BFD_MACH_O_GET_SR_TYPE (addr);
	  reloc.r_length = BFD_MACH_O_GET_SR_LENGTH (addr);
	  reloc.r_pcrel = addr & BFD_MACH_O_SR_PCREL;
          reloc.r_scattered = 1;
	}
      else
	{
	  unsigned int num = BFD_MACH_O_GET_R_SYMBOLNUM (symnum);
	  res[i].addend = 0;
	  res[i].address = addr;
	  if (symnum & BFD_MACH_O_R_EXTERN)
	    sym = syms + num;
	  else
            {
              BFD_ASSERT (num != 0);
              BFD_ASSERT (num <= mdata->nsects);
              sym = mdata->sections[num - 1]->bfdsection->symbol_ptr_ptr;
            }
	  res[i].sym_ptr_ptr = sym;
	  reloc.r_type = BFD_MACH_O_GET_R_TYPE (symnum);
	  reloc.r_length = BFD_MACH_O_GET_R_LENGTH (symnum);
	  reloc.r_pcrel = (symnum & BFD_MACH_O_R_PCREL) ? 1 : 0;
          reloc.r_scattered = 0;
	}
d697 3
a699 11
      if (!(*bed->_bfd_mach_o_swap_reloc_in)(&res[i], &reloc))
        {
          free (res);
          free (native_relocs);
          return -1;
        }
      rels[i] = &res[i];
    }
  rels[asect->reloc_count] = NULL;
  asect->relocation = res;
  free (native_relocs);
d1735 1
a1735 1
    case BFD_MACH_O_THREAD_STATE_NONE:     return "THREAD_STATE_NONE";
d1745 6
a1750 4
    case BFD_MACH_O_PPC_THREAD_STATE: return "PPC_THREAD_STATE";
    case BFD_MACH_O_PPC_FLOAT_STATE: return "PPC_FLOAT_STATE";
    case BFD_MACH_O_PPC_EXCEPTION_STATE: return "PPC_EXCEPTION_STATE";
    case BFD_MACH_O_PPC_VECTOR_STATE: return "PPC_VECTOR_STATE";
a1761 3
  asection *bfdsec;
  char *sname;
  const char *prefix;
d1774 2
a1775 10

  if (command->type == BFD_MACH_O_LC_LOAD_DYLINKER)
    prefix = "LC_LOAD_DYLINKER";
  else if (command->type == BFD_MACH_O_LC_ID_DYLINKER)
    prefix = "LC_ID_DYLINKER";
  else
    abort ();

  sname = bfd_alloc (abfd, strlen (prefix) + 1);
  if (sname == NULL)
d1777 2
a1778 4
  strcpy (sname, prefix);

  bfdsec = bfd_make_section_anyway_with_flags (abfd, sname, SEC_HAS_CONTENTS);
  if (bfdsec == NULL)
a1779 9

  bfdsec->vma = 0;
  bfdsec->lma = 0;
  bfdsec->size = command->len - nameoff;
  bfdsec->filepos = command->offset + nameoff;
  bfdsec->alignment_power = 0;

  cmd->section = bfdsec;

a1788 3
  asection *bfdsec;
  char *sname;
  const char *prefix;
a1792 2
      prefix = "LC_LOAD_DYLIB";
      break;
a1793 2
      prefix = "LC_LOAD_WEAK_DYLIB";
      break;
a1794 2
      prefix = "LC_ID_DYLIB";
      break;
a1795 1
      prefix = "LC_REEXPORT_DYLIB";
d1798 2
a1799 1
      abort ();
d1813 2
a1814 3

  sname = bfd_alloc (abfd, strlen (prefix) + 1);
  if (sname == NULL)
d1816 2
a1817 4
  strcpy (sname, prefix);

  bfdsec = bfd_make_section_anyway_with_flags (abfd, sname, SEC_HAS_CONTENTS);
  if (bfdsec == NULL)
a1818 9

  bfdsec->vma = 0;
  bfdsec->lma = 0;
  bfdsec->size = command->len - 8;
  bfdsec->filepos = command->offset + 8;
  bfdsec->alignment_power = 0;

  cmd->section = bfdsec;

d1835 1
a1835 1
  bfd_mach_o_data_struct *mdata = NULL;
d1845 1
a1845 3
  BFD_ASSERT (bfd_mach_o_valid (abfd));
  mdata = bfd_mach_o_get_data (abfd);

d1861 3
a1863 1
  cmd->flavours = bfd_alloc (abfd, nflavours * sizeof (bfd_mach_o_thread_flavour));
d1944 1
d2093 2
d2096 10
a2105 2
          ref->isym = (v >> 8) & 0xffffff;
          ref->flags = v & 0xff;
d2109 4
d2489 1
a2489 1
               && (cmd->flavours[i].flavour == BFD_MACH_O_PPC_THREAD_STATE_64))
a2935 7
      if (seg->segment == section)
	{
	  if (num == 0)
	    ncmd = cmd;
	  num++;
	}

d2943 4
a2946 1
		nsect = sect;
d3284 2
a3285 2
  fprintf (file, " Section: sectname: %-16s segname: %-16s\n",
           sec->sectname, sec->segname);
d3337 1
a3337 1
  fprintf (file, " name: %s\n", seg->segname);
d3364 1
a3364 1
  fprintf (file, "              local symbols: idx: %10lu  num: %lu\n",
d3366 3
a3368 1
  fprintf (file, "           external symbols: idx: %10lu  num: %lu\n",
d3370 3
a3372 1
  fprintf (file, "          undefined symbols: idx: %10lu  num: %lu\n",
d3374 2
d3579 1
a3579 11
	    bfd_byte *data = NULL;

	    if (! bfd_malloc_and_get_section (abfd, dylib->section, &data))
	      {
		if (data != NULL)
		  free (data);
		break;
	      }
	    fprintf (file,
		     " %s\n",
		     data + dylib->name_offset - cmd->offset - 8);
a3585 1
	    free (data);
d3589 3
a3591 16
	  {
	    bfd_mach_o_dylinker_command *linker = &cmd->command.dylinker;
	    bfd_byte *data = NULL;

	    if (! bfd_malloc_and_get_section (abfd, linker->section, &data))
	      {
		if (data != NULL)
		  free (data);
		break;
	      }
	    fprintf (file,
		     " %s\n",
		     data + linker->name_offset - cmd->offset - 8);
	    free (data);
	    break;
	  }
d3632 31
d3792 1
@


1.38
log
@2009-06-19  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_print_private_header): Fix format character.
@
text
@d618 1
@


1.37
log
@2009-06-19  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_scan_read_symtab_symbols): Add prototype.
	(bfd_mach_o_version): Use bfd_mach_o_get_data instead of direct access.
	(bfd_mach_o_valid): Ditto.
	(bfd_mach_o_wide_p): Ditto.
	(bfd_mach_o_canonicalize_reloc): Ditto.
	(bfd_mach_o_build_commands): Ditto.
	(bfd_mach_o_scan_read_thread): Ditto.
	(bfd_mach_o_flatten_sections): Ditto.
	(bfd_mach_o_scan_start_address): Ditto.
	(bfd_mach_o_lookup_section): Ditto.
	(bfd_mach_o_core_fetch_environment): Ditto.
	(bfd_mach_o_write_contents): Ditto.  Handle reexport_dylib.
	(bfd_mach_o_scan_write_relocs): Adjust for bfd_mach_o_get_data.
	(bfd_mach_o_scan_write_symtab): Ditto.
	Use macros instead of hard-coded values.
	(bfd_mach_o_scan_read_symtab_symbol): Make the function static.
	Use bfd_mach_o_get_data instead of direct access.  Use macros
	instead of hard-coded values.
	(bfd_mach_o_scan_read_symtab_strtab): Make the function static.
	Remove sym argument and get section from mdata.
	Move code into the else branch.
	(bfd_mach_o_scan_read_symtab_symbols): Make the function static.
	Remove sym argument and get section from mdata.  Adjust code.
	(bfd_mach_o_scan_read_dylib): Move assertion into the created
	switch (which replaces consecutive if statements).
	(bfd_mach_o_scan_read_dysymtab): Rename seg to cmd.  Load
	module table, table of content, indirect symbols and external
	referenced symbols.
	(bfd_mach_o_scan_read_symtab): Renames seg to symtab.  Set symtab
	field.
	(bfd_mach_o_scan_read_linkedit): New function.
	(bfd_mach_o_scan_read_str): Ditto.
	(bfd_mach_o_count_symbols): Simplify the code by using the symtab
	field of mdata.
	(bfd_mach_o_get_symtab_upper_bound): Remove check as
	bfd_mach_o_count_symbols never returns an error.
	(bfd_mach_o_canonicalize_symtab): Simplify the code by using the
	symtab field (there might be only one symtab).
	(bfd_mach_o_scan_read_command): Handle reexported dylib.
	Handle sub frameworks, sub umbrella, sub library and sub client.
	Read code signature and segment split info commands.
	(bfd_mach_o_scan): Reindent.
	(bfd_mach_o_xlat_name): New type.
	(bfd_mach_o_print_flags): New function.
	(bfd_mach_o_get_name): Ditto.
	(bfd_mach_o_cpu_name): New variable.
	(bfd_mach_o_filetype_name, bfd_mach_o_header_flags_name)
	(bfd_mach_o_section_type_name)
	(bfd_mach_o_section_attribute_name)
	(bfd_mach_o_load_command_name): New variables.
	(bfd_mach_o_print_private_header): New function.
	(bfd_mach_o_print_section_map): New function extracted from
	bfd_mach_o_print_private_bfd_data.
	(bfd_mach_o_print_section): Ditto.  Print more infos.
	(bfd_mach_o_print_segment): Ditto.
	(bfd_mach_o_print_dysymtab): Ditto.
	(bfd_mach_o_bfd_print_private_bfd_data): Reworked.  Handle
	load weak dylib, reexport dylib and id dylib.
	Handle code signature and segment_split info.
	Handle sub frameworks, sub umbrella, sub library and sub client.
	(bfd_mach_o_section_get_nbr_indirect): New function.

	* mach-o.h (BFD_MACH_O_REFERENCE_MASK): New macro.  Add comment.
	(bfd_mach_o_header_flags): New enum to define header flags.
	(bfd_mach_o_section_attribute): New enum to replace ...
	(BFD_MACH_O_S_ATTR_LOC_RELOC, BFD_MACH_O_S_ATTR_EXT_RELOC,
	BFD_MACH_O_S_ATTR_SOME_INSTRUCTIONS, BFD_MACH_O_S_ATTR_DEBUG,
	BFD_MACH_O_S_SELF_MODIFYING_CODE, BFD_MACH_O_S_ATTR_LIVE_SUPPORT,
	BFD_MACH_O_S_ATTR_NO_DEAD_STRIP, BFD_MACH_O_S_ATTR_STRIP_STATIC_SYMS,
	BFD_MACH_O_S_ATTR_NO_TOC, BFD_MACH_O_S_ATTR_PURE_INSTRUCTIONS): ...
	these removed macros.
	(BFD_MACH_O_NLIST_SIZE, BFD_MACH_O_NLIST_64_SIZE): New macros.
	(bfd_mach_o_dylib_module): New type.
	(BFD_MACH_O_DYLIB_MODULE_SIZE, BFD_MACH_O_DYLIB_MODULE_64_SIZE): New
	macros.
	(bfd_mach_o_dylib_table_of_content): New type.
	(BFD_MACH_O_TABLE_OF_CONTENT_SIZE): New macro.
	(bfd_mach_o_dylib_reference): New type.
	(BFD_MACH_O_REFERENCE_SIZE): New macro.
	(bfd_mach_o_dysymtab_command): Add fields for loaded and decoded
	modules, toc, references and indirect syms.
	(BFD_MACH_O_INDIRECT_SYMBOL_SIZE): New macro.
	(bfd_mach_o_dylinker_command): Remove cmd and cmdsize fields (were
	unused).  Add comment.
	(bfd_mach_o_dylib_command): Ditto.
	(bfd_mach_o_prebound_dylib_command): Ditto.
	(bfd_mach_o_linkedit_command): New type.
	(bfd_mach_o_str_command): New type.
	(bfd_mach_o_load_command): Add linkedit and str fields.
	(mach_o_data_struct): Add symtab field.
	(bfd_get_mach_o_data): Renamed to ...
	(bfd_mach_o_get_data): ... this new macro.
	(bfd_mach_o_scan_read_symtab_symbol,
	bfd_mach_o_scan_read_symtab_strtab,
	bfd_mach_o_scan_read_symtab_symbols): Prototypes removed.

	* mach-o-i386.c (bfd_mach_o_i386_mkobject): Use bfd_mach_o_get_data
	instead of direct access.
@
text
@d3158 1
a3158 1
  fprintf (file, _(" reserved  : %08lx\n"), h->reserved);
@


1.36
log
@2009-06-12  Tristan Gingold  <gingold@@adacore.com>

	* reloc.c: Add BFD_RELOC_MACH_O_SECTDIFF and BFD_RELOC_MACH_O_PAIR.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.

	* mach-o.c (FILE_ALIGN): New macro.
	(bfd_mach_o_canonicalize_symtab): Adjust for bfd_mach_o_asymbol.
	(bfd_mach_o_print_symbol): Ditto.
	(bfd_mach_o_scan_write_thread): Adjust type of variable offset.
	(bfd_mach_o_get_reloc_upper_bound): New function.
	(bfd_mach_o_canonicalize_reloc): Ditto.
	(bfd_mach_o_scan_write_relocs): Ditto.
	(bfd_mach_o_scan_write_section_32): Remove offset argument.
	(bfd_mach_o_scan_write_section_64): Ditto.
	(bfd_mach_o_scan_write_segment_32): Write relocs.  Fix size of data
	written for load command.  Do not compute section file offset.
	(bfd_mach_o_scan_write_segment_64): Ditto.
	(bfd_mach_o_scan_write_symtab): Compute file offset first.
	Adjust for bfd_mach_o_asymbol.  Move code to convert from BFD to
	Mach-O to ...
	(bfd_mach_o_mangle_symbols): ... this new function.
	(bfd_mach_o_write_contents): Be sure to habe load commands built.
	Call bfd_mach_o_mangle_symbols.
	(bfd_mach_o_build_commands): Adjust for filelen field.
	Use FILE_ALIGN macro.  Clear section file offset if section is empty.
	Do not set symtab file offset anymore here.
	(bfd_mach_o_make_empty_symbol): Allocate a bfd_mach_o_asymbol.
	(bfd_mach_o_make_bfd_section): Set SEC_RELOC if has reloc.
	Set reloc_count and rel_filepos section fields.
	(bfd_mach_o_scan_read_section_32): Type of argument offset is now
	unsigned int.
	(bfd_mach_o_scan_read_section_64): Ditto.
	(bfd_mach_o_scan_read_section): Ditto.
	(bfd_mach_o_scan_read_symtab_symbol): Typr of argument s is now
	bfd_mach_o_asymbol.  Use unsigned int for file offset type.
	(bfd_mach_o_scan_read_symtab_symbol): Adjust for bfd_mach_o_asymbol.
	Handle weak-ref symbols.
	(bfd_mach_o_scan_read_symtab_symbols): Adjust for bfd_mach_o_asymbol.
	(bfd_mach_o_scan_read_dysymtab_symbol): Ditto.
	(bfd_mach_o_scan): Remove assignment to removed field.
	(bfd_mach_o_mkobject_init): Ditto.
	(bfd_mach_o_bfd_print_private_bfd_data): Adjust printf formatter.
	(bfd_mach_o_bfd_reloc_type_lookup): New macro.
	(bfd_mach_o_bfd_reloc_name_lookup): Ditto.
	(bfd_mach_o_swap_reloc_in): Ditto.
	(bfd_mach_o_swap_reloc_out): Ditto.

	* mach-o.h (BFD_MACH_O_REFERENCE_FLAG_UNDEFINED_NON_LAZY)
	(BFD_MACH_O_REFERENCE_FLAG_UNDEFINED_LAZY)
	(BFD_MACH_O_REFERENCE_FLAG_DEFINED)
	(BFD_MACH_O_REFERENCE_FLAG_PRIVATE_DEFINED)
	(BFD_MACH_O_REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY)
	(BFD_MACH_O_REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY)
	(BFD_MACH_O_REFERENCED_DYNAMICALLY, BFD_MACH_O_N_DESC_DISCARDED)
	(BFD_MACH_O_N_NO_DEAD_STRIP, BFD_MACH_O_N_WEAK_REF)
	(BFD_MACH_O_N_WEAK_DEF): New macros.
	Add comments.
	(bfd_mach_o_section_type): Add new enumeration values.
	(BFD_MACH_O_S_SELF_MODIFYING_CODE)
	(BFD_MACH_O_S_ATTR_LIVE_SUPPORT)
	(BFD_MACH_O_S_ATTR_NO_DEAD_STRIP)
	(BFD_MACH_O_S_ATTR_STRIP_STATIC_SYMS, BFD_MACH_O_S_ATTR_NO_TOC): New
	macros.
	(BFD_MACH_O_GENERIC_RELOC_VANILLA)
	(BFD_MACH_O_GENERIC_RELOC_PAIR)
	(BFD_MACH_O_GENERIC_RELOC_SECTDIFF)
	(BFD_MACH_O_GENERIC_RELOC_PB_LA_PTR)
	(BFD_MACH_O_GENERIC_RELOC_LOCAL_SECTDIFF): Ditto.
	(BFD_MACH_O_RELENT_SIZE): Ditto.
	(BFD_MACH_O_R_PCREL, BFD_MACH_O_GET_R_LENGTH)
	(BFD_MACH_O_R_EXTERN, BFD_MACH_O_GET_R_TYPE)
	(BFD_MACH_O_GET_R_SYMBOLNUM, BFD_MACH_O_SET_R_LENGTH)
	(BFD_MACH_O_SET_R_TYPE, BFD_MACH_O_SET_R_SYMBOLNUM): Ditto.
	(BFD_MACH_O_SR_SCATTERED, BFD_MACH_O_SR_PCREL)
	(BFD_MACH_O_GET_SR_LENGTH, BFD_MACH_O_GET_SR_TYPE)
	(BFD_MACH_O_GET_SR_ADDRESS, BFD_MACH_O_SET_SR_LENGTH)
	(BFD_MACH_O_SET_SR_TYPE, BFD_MACH_O_SET_SR_ADDRESS): Ditto.
	(bfd_mach_o_reloc_info): New struct.
	(bfd_mach_o_asymbol): New struct.
	(bfd_mach_o_symtab_command): The symbols field is now of type
	bfd_mach_o_asymbol.
	(bfd_mach_o_load_command): The offset and len fields are now of type
	unsigned int.
	(mach_o_data_struct): Remove symbols, nsymbols and ibfd fields.
	Add a filelen field.  Add comments.
	(bfd_mach_o_backend_data): New struct.
	(bfd_mach_o_get_backend_data): New macro.
	(bfd_mach_o_scan_read_symtab_symbol): Parameter symbol now of type
	bfd_mach_o_asymbol.
	(bfd_mach_o_scan_read_dysymtab_symbol): Ditto.
	(bfd_mach_o_get_reloc_upper_bound): New prototype.
	(bfd_mach_o_canonicalize_reloc): Ditto.

	* mach-o-target.c (bfd_mach_o_bfd_is_local_label_name): Remove
	duplicated macro.  Now defined to _bfd_generic_is_local_label.
	(TARGET_NAME_BACKEND): New macro...
	(TARGET_NAME_BACKEND): ... used to name a new variable.
	(TARGET_NAME): Define relocs table using bfd_mach_o, reference
	Mach-O backend data.

	* mach-o-i386.c (i386_howto_table): New variable.
	(bfd_mach_o_i386_swap_reloc_in): New function.
	(bfd_mach_o_i386_swap_reloc_out): Ditto.
	(bfd_mach_o_i386_bfd_reloc_type_lookup): Ditto.
	(bfd_mach_o_i386_bfd_reloc_name_lookup): Ditto.
	(bfd_mach_o_swap_reloc_in, bfd_mach_o_swap_reloc_out): New macros.
	(bfd_mach_o_bfd_reloc_type_lookup)
	(bfd_mach_o_bfd_reloc_name_lookup): Ditto.
@
text
@d37 2
d45 1
a45 1
  mdata = abfd->tdata.mach_o_data;
d59 1
a59 1
  if (abfd->tdata.mach_o_data == NULL)
d82 1
a82 1
  return mach_o_wide_p (&abfd->tdata.mach_o_data->header);
d298 1
a298 1
/* Count the total number of symbols.  Traverse all sections.  */
d303 1
a303 3
  bfd_mach_o_data_struct *mdata = NULL;
  long nsyms = 0;
  unsigned long i;
d305 3
a307 11
  BFD_ASSERT (bfd_mach_o_valid (abfd));
  mdata = abfd->tdata.mach_o_data;

  for (i = 0; i < mdata->header.ncmds; i++)
    if (mdata->commands[i].type == BFD_MACH_O_LC_SYMTAB)
      {
	bfd_mach_o_symtab_command *sym = &mdata->commands[i].command.symtab;
	nsyms += sym->nsyms;
      }

  return nsyms;
a314 3
  if (nsyms < 0)
    return nsyms;

d321 1
a321 1
  bfd_mach_o_data_struct *mdata = abfd->tdata.mach_o_data;
d323 2
a324 2
  asymbol **csym = alocation;
  unsigned long i, j;
d329 1
a329 1
  for (i = 0; i < mdata->header.ncmds; i++)
d331 4
a334 3
      if (mdata->commands[i].type == BFD_MACH_O_LC_SYMTAB)
	{
	  bfd_mach_o_symtab_command *sym = &mdata->commands[i].command.symtab;
d336 1
a336 5
	  if (bfd_mach_o_scan_read_symtab_symbols (abfd, &mdata->commands[i].command.symtab) != 0)
	    {
	      fprintf (stderr, "bfd_mach_o_canonicalize_symtab: unable to load symbols for section %lu\n", i);
	      return 0;
	    }
d338 2
a339 1
	  BFD_ASSERT (sym->symbols != NULL);
d341 1
a341 9
	  for (j = 0; j < sym->nsyms; j++)
	    {
	      BFD_ASSERT (csym < (alocation + nsyms));
	      *csym++ = &sym->symbols[j].symbol;
	    }
	}
    }

  *csym++ = NULL;
d521 1
a521 1
  bfd_mach_o_data_struct *mdata = abfd->tdata.mach_o_data;
d626 1
a626 1
  bfd_mach_o_data_struct *mdata = bfd_get_mach_o_data (abfd);
d816 1
a816 1
  bfd_mach_o_data_struct *mdata = bfd_get_mach_o_data (abfd);
d821 1
a821 1
  unsigned int symlen = wide ? 16 : 12;
d944 1
a944 1
  bfd_mach_o_data_struct *mdata = abfd->tdata.mach_o_data;
d1012 1
d1035 1
a1035 1
  bfd_mach_o_data_struct *mdata = bfd_get_mach_o_data (abfd);
d1386 1
a1386 1
int
d1392 1
a1392 1
  bfd_mach_o_data_struct *mdata = abfd->tdata.mach_o_data;
d1394 2
a1395 1
  unsigned int symwidth = wide ? 16 : 12;
d1536 2
a1537 3
int
bfd_mach_o_scan_read_symtab_strtab (bfd *abfd,
				    bfd_mach_o_symtab_command *sym)
d1539 10
a1548 1
  BFD_ASSERT (sym->strtab == NULL);
a1561 1
      return 0;
d1563 5
d1569 6
a1574 9
  sym->strtab = bfd_alloc (abfd, sym->strsize);
  if (sym->strtab == NULL)
    return -1;

  if (bfd_seek (abfd, sym->stroff, SEEK_SET) != 0
      || bfd_bread ((PTR) sym->strtab, sym->strsize, abfd) != sym->strsize)
    {
      bfd_set_error (bfd_error_file_truncated);
      return -1;
d1580 2
a1581 3
int
bfd_mach_o_scan_read_symtab_symbols (bfd *abfd,
				     bfd_mach_o_symtab_command *sym)
d1583 2
d1588 3
a1590 1
  BFD_ASSERT (sym->symbols == NULL);
d1599 1
a1599 1
  ret = bfd_mach_o_scan_read_symtab_strtab (abfd, sym);
d1733 17
a1749 3
  BFD_ASSERT ((command->type == BFD_MACH_O_LC_ID_DYLIB)
	      || (command->type == BFD_MACH_O_LC_LOAD_DYLIB)
	      || (command->type == BFD_MACH_O_LC_LOAD_WEAK_DYLIB));
a1762 9
  if (command->type == BFD_MACH_O_LC_LOAD_DYLIB)
    prefix = "LC_LOAD_DYLIB";
  else if (command->type == BFD_MACH_O_LC_LOAD_WEAK_DYLIB)
    prefix = "LC_LOAD_WEAK_DYLIB";
  else if (command->type == BFD_MACH_O_LC_ID_DYLIB)
    prefix = "LC_ID_DYLIB";
  else
    abort ();

d1807 1
a1807 1
  mdata = abfd->tdata.mach_o_data;
d1904 1
a1904 1
  bfd_mach_o_dysymtab_command *seg = &command->command.dysymtab;
d1913 145
a2057 18
  seg->ilocalsym = bfd_h_get_32 (abfd, buf + 0);
  seg->nlocalsym = bfd_h_get_32 (abfd, buf + 4);
  seg->iextdefsym = bfd_h_get_32 (abfd, buf + 8);
  seg->nextdefsym = bfd_h_get_32 (abfd, buf + 12);
  seg->iundefsym = bfd_h_get_32 (abfd, buf + 16);
  seg->nundefsym = bfd_h_get_32 (abfd, buf + 20);
  seg->tocoff = bfd_h_get_32 (abfd, buf + 24);
  seg->ntoc = bfd_h_get_32 (abfd, buf + 28);
  seg->modtaboff = bfd_h_get_32 (abfd, buf + 32);
  seg->nmodtab = bfd_h_get_32 (abfd, buf + 36);
  seg->extrefsymoff = bfd_h_get_32 (abfd, buf + 40);
  seg->nextrefsyms = bfd_h_get_32 (abfd, buf + 44);
  seg->indirectsymoff = bfd_h_get_32 (abfd, buf + 48);
  seg->nindirectsyms = bfd_h_get_32 (abfd, buf + 52);
  seg->extreloff = bfd_h_get_32 (abfd, buf + 56);
  seg->nextrel = bfd_h_get_32 (abfd, buf + 60);
  seg->locreloff = bfd_h_get_32 (abfd, buf + 64);
  seg->nlocrel = bfd_h_get_32 (abfd, buf + 68);
d2065 2
a2066 1
  bfd_mach_o_symtab_command *seg = &command->command.symtab;
d2075 6
a2080 6
  seg->symoff = bfd_h_get_32 (abfd, buf);
  seg->nsyms = bfd_h_get_32 (abfd, buf + 4);
  seg->stroff = bfd_h_get_32 (abfd, buf + 8);
  seg->strsize = bfd_h_get_32 (abfd, buf + 12);
  seg->symbols = NULL;
  seg->strtab = NULL;
d2082 1
a2082 1
  if (seg->nsyms != 0)
d2085 3
d2126 38
d2256 1
d2295 1
d2309 1
d2311 5
a2320 3
    case BFD_MACH_O_LC_SUB_UMBRELLA:
    case BFD_MACH_O_LC_SUB_CLIENT:
    case BFD_MACH_O_LC_SUB_LIBRARY:
d2330 2
a2331 1
    case BFD_MACH_O_LC_REEXPORT_DYLIB:
d2345 1
a2345 1
  bfd_mach_o_data_struct *mdata = abfd->tdata.mach_o_data;
d2390 1
a2390 1
  bfd_mach_o_data_struct *mdata = abfd->tdata.mach_o_data;
d2506 2
a2507 1
      mdata->commands = bfd_alloc (abfd, header->ncmds * sizeof (bfd_mach_o_load_command));
d2862 1
a2862 1
  struct mach_o_data_struct *md = abfd->tdata.mach_o_data;
d2912 1
a2912 1
  struct mach_o_data_struct *md = NULL;
a2915 2
  md = abfd->tdata.mach_o_data;

d2960 203
a3162 2
bfd_boolean
bfd_mach_o_bfd_print_private_bfd_data (bfd *abfd, PTR ptr)
d3164 1
a3164 2
  bfd_mach_o_data_struct *mdata = abfd->tdata.mach_o_data;
  FILE *file = (FILE *) ptr;
d3201 293
d3498 3
a3500 1

d3505 1
a3511 2
	    fprintf (file, "\n"
		     "UUID:");
d3518 3
d3531 2
a3532 2
	    fprintf (file, "\n"
		     "LOAD_DYLIB: %s\n",
d3554 2
a3555 2
	    fprintf (file, "\n"
		     "LOAD_DYLINKER: %s\n",
d3563 11
a3573 3
	    fprintf (file, "\n"
		     "LC_SYMTAB: nsyms: %u, strsize: %u\n",
		     symtab->nsyms, symtab->strsize);
d3577 18
d3596 4
a3599 19
	    bfd_mach_o_dysymtab_command *dysymtab = &cmd->command.dysymtab;
	    fprintf (file, "\n"
		     "LC_DYSYMTAB:\n"
		     "      local symbols: index: %lu  number: %lu\n",
		     dysymtab->ilocalsym, dysymtab->nlocalsym);
	    fprintf (file,
		     "   external symbols: index: %lu  number: %lu\n",
		     dysymtab->iextdefsym, dysymtab->nextdefsym);
	    fprintf (file,
		     "  undefined symbols: index: %lu  number: %lu\n",
		     dysymtab->iundefsym, dysymtab->nundefsym);
	    fprintf (file,
		     "               ntoc: offset: %lu  number: %lu\n",
		     dysymtab->tocoff, dysymtab->ntoc);
	    fprintf (file,
		     "       module table: offset: %lu  number: %lu\n",
		     dysymtab->modtaboff, dysymtab->nmodtab);
	    break;
	  }
d3601 1
a3601 1
	  fprintf (file, "LC_%d\n", cmd->type);
d3604 1
d3607 2
d3617 1
a3617 1
  bfd_mach_o_data_struct *mdata = abfd->tdata.mach_o_data;
@


1.35
log
@2009-06-09  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h (bfd_mach_o_symtab_command): Remove stabs_segment
	and stabstr_segment fields.
	(mach_o_be_vec, mach_o_le_vec): Removed
	(bfd_mach_o_version): New prototype.

	* mach-o.c (bfd_mach_o_version): Make this function public.
	(mach_o_wide_p): New function.
	(bfd_mach_o_wide_p): Ditto.
	(bfd_mach_o_convert_section_name_to_bfd): Add prefix only for
	weird names.
	(bfd_mach_o_convert_section_name_to_mach_o): Fix typo in comment.
	Search in the list only if the name starts with a dot.
	(bfd_mach_o_write_header): Use mach_o_wide_p instead of hard-coded
	test.  Check bfd_seek status.
	(bfd_mach_o_scan_write_thread): Check bfd_seek status.
	(bfd_mach_o_scan_write_section_32): Ditto.
	(bfd_mach_o_scan_write_section_64): Ditto.
	(bfd_mach_o_scan_write_section): Removed.
	(bfd_mach_o_scan_write_segment): Split into ...
	(bfd_mach_o_scan_write_segment_32): ... this and ...
	(bfd_mach_o_scan_write_segment_64): ... this.  Check bfd_seek status.
	(bfd_mach_o_scan_write_symtab_symbols): Moved into ...
	(bfd_mach_o_scan_write_symtab): ... this.  Write symtab from BFD
	symbol table.  Now returns a boolean.
	(bfd_mach_o_write_contents): Set filetype.  Check bfd_seek status.
	Adjust for status type.
	(bfd_mach_o_build_commands): Use mach_o_wide_p instead of hard-coded
	test.  Write symbol table.  Numbers the sections.
	(bfd_mach_o_read_header): Check bfd_seek status.
	Use mach_o_wide_p instead of hard-coded test.
	(bfd_mach_o_scan_read_section_32): Check bfd_seek status.
	(bfd_mach_o_scan_read_section_64): Ditto.
	(bfd_mach_o_scan_read_symtab_symbol): Ditto.  Check bfd_seek status.
	Use BFD_MACH_O_N_TYPE instead of hard-coded value.  Correctly
	handled common symbols.
	(bfd_mach_o_scan_read_symtab_strtab): Check bfd_seek status.
	(bfd_mach_o_scan_read_dysymtab_symbol): Ditto.
	(bfd_mach_o_scan_read_dylinker): Ditto.
	(bfd_mach_o_scan_read_dylib): Ditto.
	(bfd_mach_o_scan_read_thread): Ditto.
	(bfd_mach_o_scan_read_symtab): Ditto.
	Do not create a section for the stabs.
	(bfd_mach_o_scan_read_uuid): Check bfd_seek status.
	(bfd_mach_o_scan_read_segment): Ditto.
	(bfd_mach_o_scan_read_command): Ditto.
	(bfd_mach_o_scan_start_address): Ditto.
	(bfd_mach_o_scan): Use mach_o_wide_p instead of hard-coded test.
	(bfd_mach_o_archive_p): Check bfd_seek status.
	(bfd_mach_o_core_fetch_environment): Ditto.

	* mach-o-i386.c (bfd_mach_o_i386_mkobject): Don't set filetype.
@
text
@d34 3
d357 1
a357 1
	      *csym++ = &sym->symbols[j];
a381 3
  unsigned char ntype;
  unsigned char nsect;
  unsigned int ndesc;
d383 1
d392 2
a393 5
      ntype = BFD_MACH_O_SYM_NTYPE (symbol);
      nsect = BFD_MACH_O_SYM_NSECT (symbol);
      ndesc = BFD_MACH_O_SYM_NDESC (symbol);
      if (ntype & BFD_MACH_O_N_STAB)
	name = bfd_get_stab_name (ntype);
d395 1
a395 1
	switch (ntype & BFD_MACH_O_N_TYPE)
d418 4
a421 3
      fprintf (file, " %02x %-6s %02x %04x", ntype, name, nsect, ndesc);
      if ((ntype & BFD_MACH_O_N_STAB) == 0
	  && (ntype & BFD_MACH_O_N_TYPE) == BFD_MACH_O_N_SECT)
d505 1
a505 1
  bfd_vma offset;
d531 184
d716 1
a716 3
bfd_mach_o_scan_write_section_32 (bfd *abfd,
				  bfd_mach_o_section *section,
				  bfd_vma offset)
d732 2
a733 3
  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || (bfd_bwrite ((PTR) buf, BFD_MACH_O_SECTION_SIZE, abfd)
          != BFD_MACH_O_SECTION_SIZE))
d740 1
a740 3
bfd_mach_o_scan_write_section_64 (bfd *abfd,
				  bfd_mach_o_section *section,
				  bfd_vma offset)
d757 2
a758 3
  if (bfd_seek (abfd, offset, SEEK_SET) != 0
      || (bfd_bwrite ((PTR) buf, BFD_MACH_O_SECTION_64_SIZE, abfd)
          != BFD_MACH_O_SECTION_64_SIZE))
d773 4
a777 1

d788 2
a789 2
      || (bfd_bwrite ((PTR) buf, BFD_MACH_O_LC_SEGMENT_SIZE, abfd) 
          != BFD_MACH_O_LC_SEGMENT_SIZE))
d793 2
a794 3
    {
      bfd_vma segoff = command->offset + BFD_MACH_O_LC_SEGMENT_SIZE
        + (i * BFD_MACH_O_SECTION_SIZE);
a795 3
      if (bfd_mach_o_scan_write_section_32 (abfd, &seg->sections[i], segoff))
	return -1;
    }
d808 4
a812 1

d823 2
a824 2
      || (bfd_bwrite ((PTR) buf, BFD_MACH_O_LC_SEGMENT_64_SIZE, abfd)
          != BFD_MACH_O_LC_SEGMENT_64_SIZE))
d828 2
a829 3
    {
      bfd_vma segoff = command->offset + BFD_MACH_O_LC_SEGMENT_64_SIZE
        + (i * BFD_MACH_O_SECTION_64_SIZE);
a830 3
      if (bfd_mach_o_scan_write_section_64 (abfd, &seg->sections[i], segoff))
	return -1;
    }
d837 1
d849 2
d855 1
a863 3
      unsigned char ntype;
      unsigned char nsect;
      short ndesc;
d865 1
a865 1
      asymbol *s = symbols[i];
d867 1
a867 1
      /* Compute index.  */
d869 1
a869 1
      if (s->name == 0 || s->name[0] == '\0')
d873 1
a873 1
          index = _bfd_stringtab_add (strtab, s->name, TRUE, FALSE);
a876 32

      /* Get back-end specific values.  */
      ntype = BFD_MACH_O_SYM_NTYPE (s);
      nsect = BFD_MACH_O_SYM_NSECT (s);
      ndesc = BFD_MACH_O_SYM_NDESC (s);

      if (ntype == BFD_MACH_O_N_UNDF && !(s->flags & BSF_DEBUGGING))
        {
          /* As genuine Mach-O symbols type shouldn't be N_UNDF (undefined
             symbols should be N_UNDEF | N_EXT), we suppose the back-end
             values haven't been set.  */
          if (s->flags & (BSF_LOCAL | BSF_GLOBAL))
            {
              if (s->section == bfd_abs_section_ptr)
                ntype = BFD_MACH_O_N_ABS;
              else if (s->section == bfd_und_section_ptr)
                ntype = BFD_MACH_O_N_UNDF;
              else if (s->section == bfd_com_section_ptr)
                ntype = BFD_MACH_O_N_UNDF | BFD_MACH_O_N_EXT;
              else
                ntype = BFD_MACH_O_N_SECT;

              ntype |= (s->flags & BSF_GLOBAL) ? BFD_MACH_O_N_EXT : 0;
            }
        }

      /* Compute section index.  */
      if (s->section != bfd_abs_section_ptr
          && s->section != bfd_und_section_ptr
          && s->section != bfd_com_section_ptr)
        nsect = s->section->target_index;

d878 3
a880 3
      bfd_h_put_8 (abfd, ntype, buf + 4);
      bfd_h_put_8 (abfd, nsect, buf + 5);
      bfd_h_put_16 (abfd, ndesc, buf + 6);
d882 1
a882 1
        bfd_h_put_64 (abfd, s->section->vma + s->value, buf + 8);
d884 1
a884 1
        bfd_h_put_32 (abfd, s->section->vma + s->value, buf + 8);
d890 2
a891 1
  sym->stroff = sym->symoff + sym->nsyms * symlen;
d914 47
d967 4
d984 4
a1059 1
  file_ptr filepos;
d1100 1
a1100 1
  filepos = cmd->offset + cmd->len;
d1111 1
a1111 1
  filepos += symtab_cmd->len;
d1116 1
a1116 1
  seg->fileoff = filepos;
d1133 7
a1139 3
      filepos = (filepos + ((file_ptr) 1 << sections->align) - 1)
        & ((file_ptr) -1 << sections->align);
      sections->offset = filepos;
d1146 1
a1146 1
      sec->filepos = filepos;
d1149 1
a1149 1
      filepos += sections->size;
d1152 1
a1152 1
  seg->filesize = filepos - seg->fileoff;
a1154 6
  /* Fill symtab command.
     Note: we don't know the number of symbols.
     Also, symtab is at the end since the length of the symbol table (and
     string table) is not known.  */
  symtab_cmd->command.symtab.symoff = filepos;
  
d1200 1
a1200 1
  new = bfd_zalloc (abfd, sizeof (* new));
d1204 1
d1304 3
d1317 2
d1326 1
a1326 1
				 bfd_vma offset,
d1361 1
a1361 1
				 bfd_vma offset,
d1396 1
a1396 1
			      bfd_vma offset,
d1409 1
a1409 1
				    asymbol *s,
d1415 1
a1415 1
  bfd_vma symoff = sym->symoff + (i * symwidth);
d1451 8
a1458 5
  s->the_bfd = abfd;
  s->name = sym->strtab + stroff;
  s->value = value;
  s->udata.i = (type << 24) | (section << 16) | desc;
  s->flags = 0x0;
d1462 2
a1463 2
      s->flags |= BSF_DEBUGGING;
      s->section = bfd_und_section_ptr;
d1477 3
a1479 2
	      s->section = mdata->sections[section - 1]->bfdsection;
	      s->value = s->value - mdata->sections[section - 1]->addr;
d1487 1
a1487 1
	s->flags |= BSF_GLOBAL;
d1490 1
a1490 1
	s->flags |= BSF_GLOBAL;
d1493 1
a1493 1
	s->flags |= BSF_LOCAL;
d1499 1
a1499 1
              && s->value != 0)
d1502 2
a1503 2
              s->section = bfd_com_section_ptr;
              s->flags = BSF_NO_FLAGS;
d1506 5
a1510 1
            s->section = bfd_und_section_ptr;
d1513 1
a1513 1
	  s->section = bfd_und_section_ptr;
d1516 1
a1516 1
	  s->section = bfd_abs_section_ptr;
d1521 3
a1523 2
	      s->section = mdata->sections[section - 1]->bfdsection;
	      s->value = s->value - mdata->sections[section - 1]->addr;
d1532 1
a1532 1
			   s->name, section, mdata->nsects);
d1534 1
a1534 1
	      s->section = bfd_und_section_ptr;
d1540 2
a1541 2
		   s->name);
	  s->section = bfd_und_section_ptr;
d1546 2
a1547 2
		   s->name, symtype);
	  s->section = bfd_und_section_ptr;
d1583 1
a1583 2
      fprintf (stderr, "bfd_mach_o_scan_read_symtab_strtab: unable to read %lu bytes at %lu\n",
	       sym->strsize, sym->stroff);
d1598 1
a1598 1
  sym->symbols = bfd_alloc (abfd, sym->nsyms * sizeof (asymbol));
d1624 1
a1624 1
				      asymbol *s,
d1801 1
a1801 1
  bfd_vma offset;
a2301 1
  mdata->symbols = NULL;
a2379 2
  mdata->nsymbols = 0;
  mdata->symbols = NULL;
a2381 1
  mdata->ibfd = NULL;
d2895 1
a2895 1
		     "LC_SYMTAB: nsyms: %lu, strsize: %lu\n",
d3041 6
a3050 1

@


1.34
log
@2009-06-05  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h: Update copyright year.
	(bfd_mach_o_mach_header_magic): New enum.
	(bfd_mach_o_cpu_subtype): Now an enum.
	(BFD_MACH_O_HEADER_SIZE, BFD_MACH_O_HEADER_64_SIZE): New macros.
	(BFD_MACH_O_SECTION_SIZE, BFD_MACH_O_SECTION_64_SIZE): Ditto.
	(BFD_MACH_O_LC_SEGMENT_SIZE, BFD_MACH_O_LC_SEGMENT_64_SIZE): Ditto.
	(bfd_mach_o_load_command): Field type_required is now a boolean.
	Reindent prototypes.
	(bfd_mach_o_object_p, bfd_mach_o_core_p): Remove.
	(bfd_mach_o_bfd_copy_private_symbol_data): Add a prototype.
	(bfd_mach_o_bfd_copy_private_section_data): Ditto.
	(bfd_mach_o_bfd_copy_private_bfd_data): Ditto.
	(bfd_mach_o_get_symtab_upper_bound): Ditto.
	(bfd_mach_o_canonicalize_symtab): Ditto.
	(bfd_mach_o_get_symbol_info): Ditto.
	(bfd_mach_o_print_symbol): Ditto.
	(bfd_mach_o_bfd_print_private_bfd_data): Ditto.
	(bfd_mach_o_make_empty_symbol): Ditto.
	(bfd_mach_o_write_contents): Ditto.

	* mach-o.c (bfd_mach_o_object_p, bfd_mach_o_core_p,
	bfd_mach_o_mkobject): Defines.
	(bfd_mach_o_valid): Returns FALSE/TRUE instead of 0/1.
	Do not check with target vector but with flavour.
	(struct mach_o_section_name_xlat): New declaration.
	(dwarf_section_names_xlat): Ditto.
	(text_section_names_xlat): Ditto.
	(data_section_names_xlat): Ditto.
	(struct mach_o_segment_name_xlat): Ditto.
	(segsec_names_xlat): Ditto.
	(bfd_mach_o_convert_section_name_to_bfd): New function.
	(bfd_mach_o_convert_section_name_to_mach_o): Ditto.
	(bfd_mach_o_bfd_copy_private_symbol_data): Make it public.
	(bfd_mach_o_bfd_copy_private_section_data): Ditto.
	(bfd_mach_o_bfd_copy_private_bfd_data): Ditto.
	Accept any input and output flavour.  Do not share private data
	anymore.
	(bfd_mach_o_count_symbols): Add a comment.
	(bfd_mach_o_get_symtab_upper_bound): Make it public.
	(bfd_mach_o_canonicalize_symtab): Ditto.
	(bfd_mach_o_get_symbol_info): Ditto.
	(bfd_mach_o_print_symbol): Ditto.
	(bfd_mach_o_write_header): Now returns a boolean instead of an int.
	Use constants instead of hard-coded values.
	(bfd_mach_o_scan_write_section_32): Use constants instead of hard-coded
	values.
	(bfd_mach_o_scan_write_section_64): Ditto.
	(bfd_mach_o_scan_write_segment): Ditto.
	Do not copy sections anymore.
	(bfd_mach_o_write_contents): Make it public.
	Remove dead code.  Rewrite typeflag assignment.
	(bfd_mach_o_build_commands): New function.
	(bfd_mach_o_set_section_contents): Ditto.
	(bfd_mach_o_make_empty_symbol): Make it public.
	(bfd_mach_o_read_header): Make it static.
	Convert to bfd_boolean.
	Use constants instead of hard-coded values.
	(bfd_mach_o_make_bfd_section): Call
	bfd_mach_o_convert_section_name_to_bfd to create name.
	(bfd_mach_o_scan_read_section_32): Use constants instead of hard-coded
	values.
	(bfd_mach_o_scan_read_section_64): Ditto.
	(bfd_mach_o_scan_read_segment): Do not create a bfd section for
	a segment anymore.  Use constants instead of hard-coded values.
	(bfd_mach_o_scan_read_command): Fix style.
	(bfd_mach_o_scan): Use constants instead of hard-coded values.
	Get rid of BFD_IO_FUNCS.
	(bfd_mach_o_mkobject_init): Renamed from bfd_mach_o_mkobject.
	(bfd_mach_o_header_p): Created from bfd_mach_o_object_p.
	(bfd_mach_o_gen_object_p): New function, replaces bfd_mach_o_object_p.
	(bfd_mach_o_object_p): Removed.
	(bfd_mach_o_gen_core_p): New function, replaces ...
	(bfd_mach_o_core_p): ... deleted.
	(bfd_mach_o_bfd_print_private_bfd_data): Make it public.

	* mach-o-i386.c: New file.
	* config.bfd: Use mach_o_i386_vec as targ_defvec for ix86-darwin.
	* configure.in (TDEFINES): Add mach_o_i386_vec.
	* configure: Regenerated.
	* targets.c: Add mach_o_i386_vec.

	* mach-o.c: Update copyright years.
	(BFD_IO_FUNCS): Remove (was not used).
	(bfd_mach_o_mkarchive, bfd_mach_o_read_ar_hdr, bfd_mach_o_slurp_armap
	bfd_mach_o_slurp_extended_name_table,
	bfd_mach_o_construct_extended_name_table,
	bfd_mach_o_truncate_arname, bfd_mach_o_write_armap,
	bfd_mach_o_get_elt_at_index, bfd_mach_o_generic_stat_arch_elt,
	bfd_mach_o_update_armap_timestamp, bfd_mach_o_close_and_cleanup,
	bfd_mach_o_bfd_free_cached_info, bfd_mach_o_new_section_hook,
	bfd_mach_o_get_section_contents_in_window,
	bfd_mach_o_bfd_is_local_label_name,
	bfd_mach_o_bfd_is_target_special_symbol,
	bfd_mach_o_bfd_is_local_label_name, bfd_mach_o_get_lineno,
	bfd_mach_o_find_nearest_line, bfd_mach_o_find_inliner_info,
	bfd_mach_o_bfd_make_debug_symbol, bfd_mach_o_read_minisymbols,
	bfd_mach_o_minisymbol_to_symbol,
	bfd_mach_o_bfd_get_relocated_section_contents,
	bfd_mach_o_bfd_relax_section, bfd_mach_o_bfd_link_hash_table_create,
	bfd_mach_o_bfd_link_hash_table_free, bfd_mach_o_bfd_link_add_symbols,
	bfd_mach_o_bfd_link_just_syms, bfd_mach_o_bfd_final_link,
	bfd_mach_o_bfd_link_split_section, bfd_mach_o_set_arch_mach,
	bfd_mach_o_bfd_merge_private_bfd_data,
	bfd_mach_o_bfd_set_private_flags, bfd_mach_o_get_section_contents,
	bfd_mach_o_bfd_gc_sections, bfd_mach_o_bfd_merge_sections,
	bfd_mach_o_bfd_is_group_section, bfd_mach_o_bfd_discard_group,
	bfd_mach_o_section_already_linked, bfd_mach_o_bfd_define_common_symbol,
	bfd_mach_o_bfd_copy_private_header_data,
	bfd_mach_o_core_file_matches_executable_p): Move these defines ...
	* mach-o-target.c: ... here.
	Update copyright years.
@
text
@d34 1
a34 1
static unsigned int 
d59 21
d127 1
a127 1
static const struct mach_o_segment_name_xlat segsec_names_xlat[] = 
d144 1
d158 1
a158 1
                  
d168 1
a168 2
  len = sizeof ("LC_SEGMENT") - 1 + 1
    + strlen (section->segname) + 1
d171 10
d184 1
a184 1
  snprintf (res, len, "LC_SEGMENT.%s.%s", section->segname, section->sectname);
d188 1
a188 1
/* Convert a bfd sectio name to a Mach-O segment + section name.  */
d202 5
a206 4
  /* List of well known names.  */
  for (seg = segsec_names_xlat; seg->segname; seg++)
    {
      const struct mach_o_section_name_xlat *sec;
d208 10
a217 10
      for (sec = seg->sections; sec->mach_o_name; sec++)
        {
          if (strcmp (sec->bfd_name, name) == 0)
            {
              strcpy (section->segname, seg->segname);
              strcpy (section->sectname, sec->mach_o_name);
              return;
            }
        }
    }
d461 1
a461 1
      *subtype = bfd_mach_ppc; 
d465 1
a465 1
      *subtype = bfd_mach_ppc64; 
d479 1
a479 1
  size = (header->version == 2) ? 
d490 1
a490 1
  if (header->version == 2)
d493 2
a494 2
  bfd_seek (abfd, 0, SEEK_SET);
  if (bfd_bwrite ((PTR) buf, size, abfd) != size)
d522 2
a523 2
      bfd_seek (abfd, command->offset + offset, SEEK_SET);
      if (bfd_bwrite ((PTR) buf, 8, abfd) != 8)
d551 3
a553 3
  bfd_seek (abfd, offset, SEEK_SET);
  if (bfd_bwrite ((PTR) buf, BFD_MACH_O_SECTION_SIZE, abfd)
      != BFD_MACH_O_SECTION_SIZE)
d579 3
a581 3
  bfd_seek (abfd, offset, SEEK_SET);
  if (bfd_bwrite ((PTR) buf, BFD_MACH_O_SECTION_64_SIZE, abfd)
      != BFD_MACH_O_SECTION_64_SIZE)
d588 1
a588 4
bfd_mach_o_scan_write_section (bfd *abfd, 
			       bfd_mach_o_section *section,
			       bfd_vma offset,
			       unsigned int wide)
d590 1
a590 12
  if (wide)
    return bfd_mach_o_scan_write_section_64 (abfd, section, offset);
  else
    return bfd_mach_o_scan_write_section_32 (abfd, section, offset);
}

static int
bfd_mach_o_scan_write_segment (bfd *abfd,
			       bfd_mach_o_load_command *command,
			       unsigned int wide)
{
  unsigned char buf[64];
d594 1
a594 5
  if (wide)
    {
      BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT_64);
      
      memcpy (buf, seg->segname, 16);
d596 1
a596 8
      bfd_h_put_64 (abfd, seg->vmaddr, buf + 16);
      bfd_h_put_64 (abfd, seg->vmsize, buf + 24);
      bfd_h_put_64 (abfd, seg->fileoff, buf + 32);
      bfd_h_put_64 (abfd, seg->filesize, buf + 40);
      bfd_h_put_32 (abfd, seg->maxprot, buf + 48);
      bfd_h_put_32 (abfd, seg->initprot, buf + 52);
      bfd_h_put_32 (abfd, seg->nsects, buf + 56);
      bfd_h_put_32 (abfd, seg->flags, buf + 60);
d598 13
a610 23
      bfd_seek (abfd, command->offset + 8, SEEK_SET);
      if (bfd_bwrite ((PTR) buf, 64, abfd) != 64)
	return -1;
    }
  else
    {
      BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT);
      
      memcpy (buf, seg->segname, 16);

      bfd_h_put_32 (abfd, seg->vmaddr, buf + 16);
      bfd_h_put_32 (abfd, seg->vmsize, buf + 20);
      bfd_h_put_32 (abfd, seg->fileoff, buf + 24);
      bfd_h_put_32 (abfd, seg->filesize, buf + 28);
      bfd_h_put_32 (abfd, seg->maxprot, buf + 32);
      bfd_h_put_32 (abfd, seg->initprot, buf + 36);
      bfd_h_put_32 (abfd, seg->nsects, buf + 40);
      bfd_h_put_32 (abfd, seg->flags, buf + 44);

      bfd_seek (abfd, command->offset + 8, SEEK_SET);
      if (bfd_bwrite ((PTR) buf, 48, abfd) != 48)
	return -1;
    }
d614 2
a615 7
      bfd_vma segoff;
      if (wide)
	segoff = command->offset + BFD_MACH_O_LC_SEGMENT_64_SIZE 
          + (i * BFD_MACH_O_SECTION_64_SIZE);
      else
	segoff = command->offset + BFD_MACH_O_LC_SEGMENT_SIZE 
          + (i * BFD_MACH_O_SECTION_SIZE);
d617 1
a617 2
      if (bfd_mach_o_scan_write_section
	  (abfd, &seg->sections[i], segoff, wide) != 0)
a619 1

d624 1
a624 1
bfd_mach_o_scan_write_segment_32 (bfd *abfd, bfd_mach_o_load_command *command)
d626 26
a651 2
  return bfd_mach_o_scan_write_segment (abfd, command, 0);
}
d653 4
a656 4
static int
bfd_mach_o_scan_write_segment_64 (bfd *abfd, bfd_mach_o_load_command *command)
{
  return bfd_mach_o_scan_write_segment (abfd, command, 1);
d659 2
a660 2
static int
bfd_mach_o_scan_write_symtab_symbols (bfd *abfd, bfd_mach_o_load_command *command)
d663 1
a663 1
  asymbol *s = NULL;
d665 16
d684 17
a700 7
      unsigned char buf[12];
      bfd_vma symoff = sym->symoff + (i * 12);
      unsigned char ntype = 0;
      unsigned char nsect = 0;
      short ndesc = 0;

      s = &sym->symbols[i];
d702 1
a702 1
      /* Instead just set from the stored values.  */
d707 27
a733 1
      bfd_h_put_32 (abfd, s->name - sym->strtab, buf);
d737 4
a740 1
      bfd_h_put_32 (abfd, s->section->vma + s->value, buf + 8);
d742 2
a743 7
      bfd_seek (abfd, symoff, SEEK_SET);
      if (bfd_bwrite ((PTR) buf, 12, abfd) != 12)
	{
	  fprintf (stderr, "bfd_mach_o_scan_write_symtab_symbols: unable to write %d bytes at %lu\n",
		   12, (unsigned long) symoff);
	  return -1;
	}
d745 2
d748 9
a756 8
  return 0;
}

static int
bfd_mach_o_scan_write_symtab (bfd *abfd, bfd_mach_o_load_command *command)
{
  bfd_mach_o_symtab_command *seg = &command->command.symtab;
  unsigned char buf[16];
d758 3
a760 1
  BFD_ASSERT (command->type == BFD_MACH_O_LC_SYMTAB);
d762 1
a762 4
  bfd_h_put_32 (abfd, seg->symoff, buf);
  bfd_h_put_32 (abfd, seg->nsyms, buf + 4);
  bfd_h_put_32 (abfd, seg->stroff, buf + 8);
  bfd_h_put_32 (abfd, seg->strsize, buf + 12);
d764 3
a766 8
  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bwrite ((PTR) buf, 16, abfd) != 16)
    return -1;

  if (bfd_mach_o_scan_write_symtab_symbols (abfd, command) != 0)
    return -1;

  return 0;
d776 9
d799 2
a800 2
      bfd_seek (abfd, cur->offset, SEEK_SET);
      if (bfd_bwrite ((PTR) buf, 8, abfd) != 8)
d814 1
a814 1
	  if (bfd_mach_o_scan_write_symtab (abfd, cur) != 0)
d856 1
a856 1
  unsigned int wide = (mdata->header.version == 2);
d861 3
d870 2
a871 2
  mdata->header.ncmds = 1;
  mdata->commands = bfd_alloc (abfd, mdata->header.ncmds 
d875 3
a877 1
  seg = &mdata->commands[0].command.segment;
d887 3
a889 3
      mdata->commands[0].type = BFD_MACH_O_LC_SEGMENT_64;
      mdata->commands[0].offset = BFD_MACH_O_HEADER_64_SIZE;
      mdata->commands[0].len = BFD_MACH_O_LC_SEGMENT_64_SIZE
d894 3
a896 3
      mdata->commands[0].type = BFD_MACH_O_LC_SEGMENT;
      mdata->commands[0].offset = BFD_MACH_O_HEADER_SIZE;
      mdata->commands[0].len = BFD_MACH_O_LC_SEGMENT_SIZE
d899 14
a912 4
  mdata->commands[0].type_required = FALSE;
  mdata->header.sizeofcmds = mdata->commands[0].len;
      
  filepos = mdata->commands[0].offset + mdata->commands[0].len;
d914 1
d925 1
d933 1
a933 1
      
d944 1
d952 6
d1018 2
a1019 2
  bfd_seek (abfd, 0, SEEK_SET);
  if (bfd_bread ((PTR) buf, 4, abfd) != 4)
d1057 1
a1057 1
  size = (header->version == 2) ?
d1060 2
a1061 2
  bfd_seek (abfd, 0, SEEK_SET);
  if (bfd_bread ((PTR) buf, size, abfd) != size)
d1071 1
a1071 1
  if (header->version == 2)
d1128 3
a1130 3
  bfd_seek (abfd, offset, SEEK_SET);
  if (bfd_bread ((PTR) buf, BFD_MACH_O_SECTION_SIZE, abfd)
      != BFD_MACH_O_SECTION_SIZE)
d1163 3
a1165 3
  bfd_seek (abfd, offset, SEEK_SET);
  if (bfd_bread ((PTR) buf, BFD_MACH_O_SECTION_64_SIZE, abfd)
      != BFD_MACH_O_SECTION_64_SIZE)
d1210 1
a1210 1
  unsigned int wide = (mdata->header.version == 2);
d1223 2
a1224 2
  bfd_seek (abfd, symoff, SEEK_SET);
  if (bfd_bread ((PTR) buf, symwidth, abfd) != symwidth)
d1233 1
a1233 1
  symtype = (type & 0x0e);
d1281 1
a1281 1
      
d1291 9
a1299 1
	  s->section = bfd_und_section_ptr;
d1368 2
a1369 2
  bfd_seek (abfd, sym->stroff, SEEK_SET);
  if (bfd_bread ((PTR) sym->strtab, sym->strsize, abfd) != sym->strsize)
d1422 2
a1423 2
  bfd_seek (abfd, isymoff, SEEK_SET);
  if (bfd_bread ((PTR) buf, 4, abfd) != 4)
d1483 2
a1484 2
  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bread ((PTR) buf, 4, abfd) != 4)
d1533 2
a1534 2
  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bread ((PTR) buf, 16, abfd) != 16)
d1607 2
a1608 3
      bfd_seek (abfd, command->offset + offset, SEEK_SET);

      if (bfd_bread ((PTR) buf, 8, abfd) != 8)
d1630 2
a1631 3
      bfd_seek (abfd, command->offset + offset, SEEK_SET);

      if (bfd_bread ((PTR) buf, 8, abfd) != 8)
d1700 2
a1701 2
  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bread ((PTR) buf, 72, abfd) != 72)
a1730 4
  asection *bfdsec;
  char *sname;
  const char *prefix = "LC_SYMTAB.stabs";
  int nlist_size = (bfd_mach_o_version (abfd) > 1) ? 16 : 12;
d1734 2
a1735 2
  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bread ((PTR) buf, 16, abfd) != 16)
a1744 17
  sname = bfd_alloc (abfd, strlen (prefix) + 1);
  if (sname == NULL)
    return -1;
  strcpy (sname, prefix);

  bfdsec = bfd_make_section_anyway_with_flags (abfd, sname, SEC_HAS_CONTENTS);
  if (bfdsec == NULL)
    return -1;

  bfdsec->vma = 0;
  bfdsec->lma = 0;
  bfdsec->size = seg->nsyms * nlist_size;
  bfdsec->filepos = seg->symoff;
  bfdsec->alignment_power = 0;

  seg->stabs_segment = bfdsec;

a1747 18
  prefix = "LC_SYMTAB.stabstr";
  sname = bfd_alloc (abfd, strlen (prefix) + 1);
  if (sname == NULL)
    return -1;
  strcpy (sname, prefix);

  bfdsec = bfd_make_section_anyway_with_flags (abfd, sname, SEC_HAS_CONTENTS);
  if (bfdsec == NULL)
    return -1;

  bfdsec->vma = 0;
  bfdsec->lma = 0;
  bfdsec->size = seg->strsize;
  bfdsec->filepos = seg->stroff;
  bfdsec->alignment_power = 0;

  seg->stabstr_segment = bfdsec;

d1761 2
a1762 2
  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bread ((PTR) cmd->uuid, 16, abfd) != 16)
d1798 2
a1799 2
      bfd_seek (abfd, command->offset + 8, SEEK_SET);
      if (bfd_bread ((PTR) buf, 64, abfd) != 64)
d1818 2
a1819 2
      bfd_seek (abfd, command->offset + 8, SEEK_SET);
      if (bfd_bread ((PTR) buf, 48, abfd) != 48)
d1846 1
a1846 1
            segoff = command->offset + BFD_MACH_O_LC_SEGMENT_64_SIZE 
d1849 1
a1849 1
            segoff = command->offset + BFD_MACH_O_LC_SEGMENT_SIZE 
d1878 2
a1879 2
  bfd_seek (abfd, command->offset, SEEK_SET);
  if (bfd_bread ((PTR) buf, 8, abfd) != 8)
d2033 2
a2034 3
	  bfd_seek (abfd, cmd->flavours[i].offset + 40, SEEK_SET);

	  if (bfd_bread (buf, 4, abfd) != 4)
d2044 2
a2045 3
	  bfd_seek (abfd, cmd->flavours[i].offset + 0, SEEK_SET);

	  if (bfd_bread (buf, 4, abfd) != 4)
d2055 2
a2056 3
          bfd_seek (abfd, cmd->flavours[i].offset + 0, SEEK_SET);

          if (bfd_bread (buf, 8, abfd) != 8)
d2066 2
a2067 3
          bfd_seek (abfd, cmd->flavours[i].offset + (16 * 8), SEEK_SET);

          if (bfd_bread (buf, 8, abfd) != 8)
d2087 1
a2087 1
  hdrsize = (header->version == 2) ? 
d2299 2
a2300 2
  bfd_seek (abfd, 0, SEEK_SET);
  if (bfd_bread ((PTR) buf, 8, abfd) != 8)
d2317 1
a2317 1
  adata->archentries = 
d2324 2
a2325 3
      bfd_seek (abfd, 8 + 20 * i, SEEK_SET);

      if (bfd_bread ((PTR) buf, 20, abfd) != 20)
d2437 1
a2437 1
  
d2760 7
a2766 2
	      
	      bfd_seek (abfd, end - size, SEEK_SET);
@


1.33
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d30 3
a32 48
#ifndef BFD_IO_FUNCS
#define BFD_IO_FUNCS 0
#endif

#define bfd_mach_o_mkarchive                          _bfd_noarchive_mkarchive
#define bfd_mach_o_read_ar_hdr                        _bfd_noarchive_read_ar_hdr
#define bfd_mach_o_slurp_armap                        _bfd_noarchive_slurp_armap
#define bfd_mach_o_slurp_extended_name_table          _bfd_noarchive_slurp_extended_name_table
#define bfd_mach_o_construct_extended_name_table      _bfd_noarchive_construct_extended_name_table
#define bfd_mach_o_truncate_arname                    _bfd_noarchive_truncate_arname
#define bfd_mach_o_write_armap                        _bfd_noarchive_write_armap
#define bfd_mach_o_get_elt_at_index                   _bfd_noarchive_get_elt_at_index
#define bfd_mach_o_generic_stat_arch_elt              _bfd_noarchive_generic_stat_arch_elt
#define bfd_mach_o_update_armap_timestamp             _bfd_noarchive_update_armap_timestamp
#define	bfd_mach_o_close_and_cleanup                  _bfd_generic_close_and_cleanup
#define bfd_mach_o_bfd_free_cached_info               _bfd_generic_bfd_free_cached_info
#define bfd_mach_o_new_section_hook                   _bfd_generic_new_section_hook
#define bfd_mach_o_get_section_contents_in_window     _bfd_generic_get_section_contents_in_window
#define bfd_mach_o_bfd_is_local_label_name            _bfd_nosymbols_bfd_is_local_label_name
#define bfd_mach_o_bfd_is_target_special_symbol       ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
#define bfd_mach_o_bfd_is_local_label_name            _bfd_nosymbols_bfd_is_local_label_name
#define bfd_mach_o_get_lineno                         _bfd_nosymbols_get_lineno
#define bfd_mach_o_find_nearest_line                  _bfd_nosymbols_find_nearest_line
#define bfd_mach_o_find_inliner_info                  _bfd_nosymbols_find_inliner_info
#define bfd_mach_o_bfd_make_debug_symbol              _bfd_nosymbols_bfd_make_debug_symbol
#define bfd_mach_o_read_minisymbols                   _bfd_generic_read_minisymbols
#define bfd_mach_o_minisymbol_to_symbol               _bfd_generic_minisymbol_to_symbol
#define bfd_mach_o_bfd_get_relocated_section_contents bfd_generic_get_relocated_section_contents
#define bfd_mach_o_bfd_relax_section                  bfd_generic_relax_section
#define bfd_mach_o_bfd_link_hash_table_create         _bfd_generic_link_hash_table_create
#define bfd_mach_o_bfd_link_hash_table_free           _bfd_generic_link_hash_table_free
#define bfd_mach_o_bfd_link_add_symbols               _bfd_generic_link_add_symbols
#define bfd_mach_o_bfd_link_just_syms                 _bfd_generic_link_just_syms
#define bfd_mach_o_bfd_final_link                     _bfd_generic_final_link
#define bfd_mach_o_bfd_link_split_section             _bfd_generic_link_split_section
#define bfd_mach_o_set_arch_mach                      bfd_default_set_arch_mach
#define bfd_mach_o_bfd_merge_private_bfd_data         _bfd_generic_bfd_merge_private_bfd_data
#define bfd_mach_o_bfd_set_private_flags              _bfd_generic_bfd_set_private_flags
#define bfd_mach_o_get_section_contents               _bfd_generic_get_section_contents
#define bfd_mach_o_set_section_contents               _bfd_generic_set_section_contents
#define bfd_mach_o_bfd_gc_sections                    bfd_generic_gc_sections
#define bfd_mach_o_bfd_merge_sections                 bfd_generic_merge_sections
#define bfd_mach_o_bfd_is_group_section               bfd_generic_is_group_section
#define bfd_mach_o_bfd_discard_group                  bfd_generic_discard_group
#define bfd_mach_o_section_already_linked             _bfd_generic_section_already_linked
#define bfd_mach_o_bfd_define_common_symbol           bfd_generic_define_common_symbol
#define bfd_mach_o_bfd_copy_private_header_data       _bfd_generic_bfd_copy_private_header_data
#define bfd_mach_o_core_file_matches_executable_p     generic_core_file_matches_executable_p
d49 1
a49 1
    return 0;
d51 2
a52 4
  if (! ((abfd->xvec == &mach_o_be_vec)
	 || (abfd->xvec == &mach_o_le_vec)
	 || (abfd->xvec == &mach_o_fat_vec)))
    return 0;
d55 162
a216 2
    return 0;
  return 1;
d222 1
a222 1
static bfd_boolean
d234 1
a234 1
static bfd_boolean
d246 1
a246 1
static bfd_boolean
d249 4
d256 2
a257 2
  obfd->tdata.mach_o_data = ibfd->tdata.mach_o_data;
  obfd->tdata.mach_o_data->ibfd = ibfd;
d261 2
d283 1
a283 1
static long
d294 1
a294 1
static long
d332 1
a332 1
static void
d340 1
a340 1
static void
d441 1
a441 1
static int
d447 2
a448 1
  size = (header->version == 2) ? 32 : 28;
d463 1
a463 1
    return -1;
d465 1
a465 1
  return 0;
d505 1
a505 1
  unsigned char buf[68];
d520 2
a521 1
  if (bfd_bwrite ((PTR) buf, 68, abfd) != 68)
d532 1
a532 1
  unsigned char buf[80];
d548 2
a549 1
  if (bfd_bwrite ((PTR) buf, 80, abfd) != 80)
a614 25
  {
    char buf[1024];
    bfd_vma nbytes = seg->filesize;
    bfd_vma curoff = seg->fileoff;

    while (nbytes > 0)
      {
	bfd_vma thiswrite = nbytes;

	if (thiswrite > 1024)
	  thiswrite = 1024;

	bfd_seek (abfd, curoff, SEEK_SET);
	if (bfd_bread ((PTR) buf, thiswrite, abfd) != thiswrite)
	  return -1;

	bfd_seek (abfd, curoff, SEEK_SET);
	if (bfd_bwrite ((PTR) buf, thiswrite, abfd) != thiswrite)
	  return -1;

	nbytes -= thiswrite;
	curoff += thiswrite;
      }
  }

d619 2
a620 1
	segoff = command->offset + 64 + 8 + (i * 80);
d622 2
a623 1
	segoff = command->offset + 48 + 8 + (i * 68);
d708 1
a708 1
static bfd_boolean
a711 2
  asection *s;

a713 6
  /* Write data sections first in case they overlap header data to be
     written later.  */

  for (s = abfd->sections; s != (asection *) NULL; s = s->next)
    ;

d715 1
a715 1
  if (bfd_mach_o_write_header (abfd, &mdata->header) != 0)
d724 1
a724 1
      typeflag = cur->type_required ? cur->type & BFD_MACH_O_LC_REQ_DYLD : cur->type;
d780 115
a894 1
static int
d904 1
a904 1
static asymbol *
d916 1
a916 1
static int
d923 1
a924 2

  /* Just read the magic number.  */
d926 1
a926 1
    return -1;
d928 1
a928 1
  if (bfd_getb32 (buf) == 0xfeedface)
d931 1
a931 1
      header->magic = 0xfeedface;
d935 1
a935 1
  else if (bfd_getl32 (buf) == 0xfeedface)
d938 1
a938 1
      header->magic = 0xfeedface;
d942 1
a942 1
  else if (bfd_getb32 (buf) == 0xfeedfacf)
d945 1
a945 1
      header->magic = 0xfeedfacf;
d949 1
a949 1
  else if (bfd_getl32 (buf) == 0xfeedfacf)
d952 1
a952 1
      header->magic = 0xfeedfacf;
d959 1
a959 1
      return -1;
d963 2
a964 1
  size = (header->version == 2) ? 32 : 28;
d968 1
a968 1
    return -1;
d980 1
a980 1
  return 0;
a988 2
  const char *prefix = "LC_SEGMENT";
  unsigned int snamelen;
d991 1
a991 5
  snamelen = strlen (prefix) + 1
    + strlen (section->segname) + 1
    + strlen (section->sectname) + 1;

  sname = bfd_alloc (abfd, snamelen);
a994 23
  /* Use canonical dwarf section names for dwarf sections.  */
  if (strcmp (section->segname, "__DWARF") == 0
      && strncmp (section->sectname, "__", 2) == 0)
    sprintf (sname, ".%s", section->sectname + 2);
  else if (strcmp (section->segname, "__TEXT") == 0)
    {
      if (strcmp (section->sectname, "__eh_frame") == 0)
	strcpy (sname, ".eh_frame");
      else if (section->sectname[0])
	sprintf (sname, "%s.%s", section->segname, section->sectname);
      else
	strcpy (sname, section->segname);
    }
  else if (strcmp (section->segname, "__DATA") == 0)
    {
      if (section->sectname[0])
	sprintf (sname, "%s.%s", section->segname, section->sectname);
      else
	strcpy (sname, section->segname);
    }
  else
    sprintf (sname, "%s.%s.%s", prefix, section->segname, section->sectname);

d1032 1
a1032 1
  unsigned char buf[68];
d1035 2
a1036 1
  if (bfd_bread ((PTR) buf, 68, abfd) != 68)
d1067 1
a1067 1
  unsigned char buf[80];
d1070 2
a1071 1
  if (bfd_bread ((PTR) buf, 80, abfd) != 80)
a1731 4
  asection *bfdsec;
  char *sname;
  const char *prefix = "LC_SEGMENT";
  unsigned int snamelen;
a1773 26
  snamelen = strlen (prefix) + 1 + strlen (seg->segname) + 1;
  sname = bfd_alloc (abfd, snamelen);
  if (sname == NULL)
    return -1;
  if (strcmp (seg->segname, "__TEXT") == 0
      || strcmp (seg->segname, "__DATA") == 0
      || strcmp (seg->segname, "__IMPORT") == 0
      || strcmp (seg->segname, "__LINKEDIT") == 0)
    strcpy (sname, seg->segname);
  else
    sprintf (sname, "%s.%s", prefix, seg->segname);

  bfdsec = bfd_make_section_anyway (abfd, sname);
  if (bfdsec == NULL)
    return -1;

  bfdsec->vma = seg->vmaddr;
  bfdsec->lma = seg->vmaddr;
  bfdsec->size = seg->filesize;
  bfdsec->filepos = seg->fileoff;
  bfdsec->alignment_power = 0x0;
  bfdsec->flags = SEC_HAS_CONTENTS;
  bfdsec->segment_mark = 1;

  seg->segment = bfdsec;

d1776 2
a1777 1
      seg->sections = bfd_alloc (abfd, seg->nsects * sizeof (bfd_mach_o_section));
d1784 6
a1789 4
	  if (wide)
	    segoff = command->offset + 64 + 8 + (i * 80);
	  else
	    segoff = command->offset + 48 + 8 + (i * 68);
d1821 1
a1821 1
  command->type = (bfd_h_get_32 (abfd, buf) & ~BFD_MACH_O_LC_REQ_DYLD);
d1823 1
a1823 1
			    ? 1 : 0);
d2030 2
a2031 1
  hdrsize = (header->version == 2) ? 32 : 28;
d2036 1
a2036 1
  abfd->flags = abfd->flags & (BFD_IN_MEMORY | BFD_IO_FUNCS);
d2095 1
a2095 1
bfd_mach_o_mkobject (bfd *abfd)
d2123 3
a2125 1
bfd_mach_o_object_p (bfd *abfd)
d2131 1
a2131 1
  if (bfd_mach_o_read_header (abfd, &header) != 0)
d2150 36
d2207 2
a2208 2
const bfd_target *
bfd_mach_o_core_p (bfd *abfd)
d2210 2
a2211 2
  struct bfd_preserve preserve;
  bfd_mach_o_header header;
d2213 4
a2216 42
  preserve.marker = NULL;
  if (bfd_mach_o_read_header (abfd, &header) != 0)
    goto wrong;

  if (! (header.byteorder == BFD_ENDIAN_BIG
	 || header.byteorder == BFD_ENDIAN_LITTLE))
    {
      fprintf (stderr, "unknown header byte-order value 0x%lx\n",
	       (unsigned long) header.byteorder);
      abort ();
    }

  if (! ((header.byteorder == BFD_ENDIAN_BIG
	  && abfd->xvec->byteorder == BFD_ENDIAN_BIG
	  && abfd->xvec->header_byteorder == BFD_ENDIAN_BIG)
	 || (header.byteorder == BFD_ENDIAN_LITTLE
	     && abfd->xvec->byteorder == BFD_ENDIAN_LITTLE
	     && abfd->xvec->header_byteorder == BFD_ENDIAN_LITTLE)))
    goto wrong;

  if (header.filetype != BFD_MACH_O_MH_CORE)
    goto wrong;

  preserve.marker = bfd_zalloc (abfd, sizeof (bfd_mach_o_data_struct));
  if (preserve.marker == NULL
      || !bfd_preserve_save (abfd, &preserve))
    goto fail;

  if (bfd_mach_o_scan (abfd, &header,
		       (bfd_mach_o_data_struct *) preserve.marker) != 0)
    goto wrong;

  bfd_preserve_finish (abfd, &preserve);
  return abfd->xvec;

 wrong:
  bfd_set_error (bfd_error_wrong_format);

 fail:
  if (preserve.marker != NULL)
    bfd_preserve_restore (abfd, &preserve);
  return NULL;
d2525 1
a2525 1
static bfd_boolean
@


1.32
log
@* mach-o.c (bfd_mach_o_archive_p): Restrict the number of
architectures in the archive.
@
text
@d75 1
@


1.31
log
@2008-12-23  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.c (bfd_mach_o_make_bfd_section): Use the standard ELF name
	.eh_frame for __TEXT.__eh_frame so that it is recognized by gdb.
	Use shorter sections name for well known sections.
	(bfd_mach_o_scan_read_dylinker): Only put dylinker name in the
	section content.
	(bfd_mach_o_scan_read_segment): Use shorter sections name for
	well known segments.
	(bfd_mach_o_scan_read_command): Ignore some new commands.
	(bfd_mach_o_openr_next_archived_file): Use more descriptive names
	for members filename.
	(bfd_mach_o_fat_extract): New function to easily extract members
	of a fat binary.
	* mach-o.h (bfd_mach_o_load_command_type): Add new constants.
	(bfd_mach_o_dylinker_command): Fix comment and reindent.
	(bfd_mach_o_fat_extract): New prototype.
@
text
@d2101 5
@


1.30
log
@2008-11-06  Tristan Gingold  <gingold@@adacore.com>

	* mach-o.h (BFD_MACH_O_NO_SECT): Add; reorders the macros.
	(BFD_MACH_O_SYM_NTYPE, BFD_MACH_O_SYM_NSECT,
	BFD_MACH_O_SYM_NDESC): New macros.
	(bfd_mach_o_i386_thread_flavour): Define according to the latest
	definition from system header.
	(bfd_mach_o_load_command_type): Add BFD_MACH_O_LC_RPATH,
	BFD_MACH_O_LC_CODE_SIGNATURE.
	(BFD_MACH_O_SECTION_TYPE_MASK, BFD_MACH_O_SECTION_ATTRIBUTES_MASK,
	BFD_MACH_O_SECTION_ATTRIBUTES_SYS, BFD_MACH_O_SECTION_ATTRIBUTES_USR,
	BFD_MACH_O_S_ATTR_LOC_RELOC, BFD_MACH_O_S_ATTR_EXT_RELOC,
	BFD_MACH_O_S_ATTR_SOME_INSTRUCTIONS, BFD_MACH_O_S_ATTR_DEBUG,
	BFD_MACH_O_S_ATTR_PURE_INSTRUCTIONS): Add.
	(bfd_mach_o_segment_command): Add room for a nul terminator in
	segname field.
	(BFD_MACH_O_PROT_READ, BFD_MACH_O_PROT_WRITE,
	BFD_MACH_O_PROT_EXECUTE): Add.
	(INDIRECT_SYMBOL_LOCAL): Renames to BFD_MACH_O_INDIRECT_SYMBOL_LOCAL.
	(INDIRECT_SYMBOL_ABS): Renames to BFD_MACH_O_INDIRECT_SYMBOL_ABS.
	(bfd_mach_o_uuid_command): Add the structure.
	(bfd_mach_o_load_command): Add uuid field.
	(bfd_get_mach_o_data): New macro.
	* mach-o.c (bfd_mach_o_bfd_print_private_bfd_data): New function which
	replaces the macro.
	(SECTION_TYPE, SECTION_ATTRIBUTES, SECTION_ATTRIBUTES_USR,
	S_ATTR_PURE_INSTRUCTIONS, SECTION_ATTRIBUTES_SYS,
	S_ATTR_SOME_INSTRUCTIONS, S_ATTR_EXT_RELOC, S_ATTR_LOC_RELOC): Renamed
	and moved to mach-o.h.
	(N_STAB, N_TYPE, N_EXT, N_UNDF, N_ABS, N_TEXT, N_DATA, N_BSS,
	N_SECT, N_INDR): Removed as they duplicated macros in mach-o.h.
	(bfd_mach_o_print_symbol): Print much more details.
	(bfd_mach_o_make_bfd_section): Add prot argument, use canonical
	dwarf name for dwarf sections.  Precisely set section flags.
	(bfd_mach_o_scan_read_section_32): Add prot argument.
	(bfd_mach_o_scan_read_section_64): Ditto.
	(bfd_mach_o_scan_read_section): Ditto.
	(bfd_mach_o_scan_read_symtab_symbol): Set section for debugging
	stabs, set BSF_GLOBAL and LOCAL flags correctly.  Fix section
	for N_SECT symbols.
	(bfd_mach_o_i386_flavour_string): Reindent and adjust for new
	names.
	(bfd_mach_o_scan_read_symtab): Set HAS_SYMS flags on bfd if there
	are symbols.
	(bfd_mach_o_scan_read_uuid): New function.
	(bfd_mach_o_scan_read_segment): Add a trailing nul.  Segments
	flags are now simply HAS_CONTENTS.  Pass protection to
	bfd_mach_o_scan_read_section.
	(bfd_mach_o_scan_read_command): Decode UUID command.
	(bfd_mach_o_flatten_sections): Add comments.  Fix flavour names.
	(bfd_mach_o_scan): Set flags according to file type.
	(mach_o_fat_archentry): Remove abfd field.
	(bfd_mach_o_archive_p): Remove initialization of abfd field.
	(bfd_mach_o_openr_next_archived_file): Find previous archive
	by position and not by bfd (as former bfds may have been freed).
	Give architecture name to archived file.
	* mach-o-target.c (TARGET_NAME): Use generic archive for non fat
	targets.
@
text
@d799 16
d1229 2
a1230 2
  bfdsec->size = command->len - 8;
  bfdsec->filepos = command->offset + 8;
d1603 7
a1609 1
  sprintf (sname, "%s.%s", prefix, seg->segname);
d1733 2
a2136 1
  const char *arch_name;
a2138 1
  char *s = NULL;
d2178 16
a2193 6
  arch_name = bfd_printable_arch_mach (arch_type, arch_subtype);
  s = bfd_malloc (strlen (arch_name) + 1);
  if (s == NULL)
    return NULL;
  strcpy (s, arch_name);
  nbfd->filename = s;
d2195 1
d2200 61
@


1.29
log
@2008-09-05  Tristan Gingold  <gingold@@adacore.com>

	Add MacOSX 64 bits support.
	* mach-o.h (bfd_mach_o_ppc_thread_flavour): Add
	BFD_MACH_O_PPC_THREAD_STATE_64.
	(bfd_mach_o_i386_thread_flavour): Add BFD_MACH_O_x86_THREAD_STATE64,
	BFD_MACH_O_x86_FLOAT_STATE64, BFD_MACH_O_x86_EXCEPTION_STATE64,
	BFD_MACH_O_x86_THREAD_STATE, BFD_MACH_O_x86_FLOAT_STATE,
	BFD_MACH_O_x86_EXCEPTION_STATE.
	(bfd_mach_o_load_command_type): Add
	BFD_MACH_O_LC_SEGMENT_64, BFD_MACH_O_LC_ROUTINES_64,
	BFD_MACH_O_LC_UUID.
	(BFD_MACH_O_CPU_IS64BIT): Added.
	(bfd_mach_o_cpu_type): Add BFD_MACH_O_CPU_TYPE_POWERPC_64,
	BFD_MACH_O_CPU_TYPE_X86_64.
	(bfd_mach_o_header): Add version field.
	(bfd_mach_o_section) Add reserved3 field.
	(bfd_mach_o_segment_command): Add initprot and maxprot fields.

	* mach-o.c (N_TEXT, N_DATA, N_BSS): Added.
	(bfd_mach_o_version): New function.
	(bfd_mach_o_valid): Handle 64bits cpus.
	(bfd_mach_o_write_header): handler 64bits headers.
	(bfd_mach_o_scan_write_section_32, bfd_mach_o_scan_write_section_64):
	New functions (from bfd_mach_o_scan_write_section) to handle both
	flavors.
	(bfd_mach_o_scan_write_segment): Parameter wide added to support
	both flavors.
	(bfd_mach_o_write_contents): Support both flavors.
	(bfd_mach_o_read_header): Ditto.
	(bfd_mach_o_scan_read_section_32, bfd_mach_o_scan_read_section_64):
	New functions (from bfd_mach_o_scan_read_section) to support both
	flavors.
	(bfd_mach_o_scan_read_symtab_symbol): Support both flavors.
	(bfd_mach_o_scan_read_symtab): Ditto.
	(bfd_mach_o_scan_read_segment): Parameter wide added to support
	both flavors.
	(bfd_mach_o_scan_read_segment_32, bfd_mach_o_scan_read_segment_64):
	New functions to call bfd_mach_o_scan_read_segment.
	(bfd_mach_o_flatten_sections): Support both flavors.
	(bfd_mach_o_scan_start_address): Ditto.
	(bfd_mach_o_scan): Ditto.
	(bfd_mach_o_lookup_section): Ditto.
@
text
@d27 1
a67 1
#define bfd_mach_o_bfd_print_private_bfd_data         _bfd_generic_bfd_print_private_bfd_data
a77 31

/* The flags field of a section structure is separated into two parts a section
   type and section attributes.  The section types are mutually exclusive (it
   can only have one type) but the section attributes are not (it may have more
   than one attribute).  */

#define SECTION_TYPE             0x000000ff     /* 256 section types.  */
#define SECTION_ATTRIBUTES       0xffffff00     /*  24 section attributes.  */

/* Constants for the section attributes part of the flags field of a section
   structure.  */

#define SECTION_ATTRIBUTES_USR   0xff000000     /* User-settable attributes.  */
#define S_ATTR_PURE_INSTRUCTIONS 0x80000000     /* Section contains only true machine instructions.  */
#define SECTION_ATTRIBUTES_SYS   0x00ffff00     /* System setable attributes.  */
#define S_ATTR_SOME_INSTRUCTIONS 0x00000400     /* Section contains some machine instructions.  */
#define S_ATTR_EXT_RELOC         0x00000200     /* Section has external relocation entries.  */
#define S_ATTR_LOC_RELOC         0x00000100     /* Section has local relocation entries.  */

#define N_STAB 0xe0
#define N_TYPE 0x1e
#define N_EXT  0x01

#define N_UNDF 0x0
#define N_ABS  0x2
#define N_TEXT 0x4
#define N_DATA 0x6
#define N_BSS  0x8
#define N_SECT 0xe
#define N_INDR 0xa

d227 4
d239 34
a272 1
      fprintf (file, " %-5s %s", symbol->section->name, symbol->name);
d563 3
a565 3
      ntype = (s->udata.i >> 24) & 0xff;
      nsect = (s->udata.i >> 16) & 0xff;
      ndesc = s->udata.i & 0xffff;
d778 2
a779 1
bfd_mach_o_make_bfd_section (bfd *abfd, bfd_mach_o_section *section)
a793 1
  sprintf (sname, "%s.%s.%s", prefix, section->segname, section->sectname);
d795 24
a818 3
  flags = SEC_ALLOC;
  if ((section->flags & SECTION_TYPE) != BFD_MACH_O_S_ZEROFILL)
    flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC | SEC_CODE;
d836 2
a837 1
				 bfd_vma offset)
d859 1
a859 1
  section->bfdsection = bfd_mach_o_make_bfd_section (abfd, section);
d870 2
a871 1
				 bfd_vma offset)
d893 1
a893 1
  section->bfdsection = bfd_mach_o_make_bfd_section (abfd, section);
d905 1
d909 1
a909 1
    return bfd_mach_o_scan_read_section_64 (abfd, section, offset);
d911 1
a911 1
    return bfd_mach_o_scan_read_section_32 (abfd, section, offset);
d945 1
a945 1
  section = bfd_h_get_8 (abfd, buf + 5) - 1;
d969 18
d991 4
a994 4
	{
	  type &= ~BFD_MACH_O_N_PEXT;
	  s->flags |= BSF_GLOBAL;
	}
d996 2
a997 5
      if (type & BFD_MACH_O_N_EXT)
	{
	  type &= ~BFD_MACH_O_N_EXT;
	  s->flags |= BSF_GLOBAL;
	}
d1013 2
a1014 2
	      s->section = mdata->sections[section]->bfdsection;
	      s->value = s->value - mdata->sections[section]->addr;
d1142 13
a1154 12
    case BFD_MACH_O_i386_NEW_THREAD_STATE: return "i386_NEW_THREAD_STATE";
    case BFD_MACH_O_i386_FLOAT_STATE: return "i386_FLOAT_STATE";
    case BFD_MACH_O_i386_ISA_PORT_MAP_STATE: return "i386_ISA_PORT_MAP_STATE";
    case BFD_MACH_O_i386_V86_ASSIST_STATE: return "i386_V86_ASSIST_STATE";
    case BFD_MACH_O_i386_REGS_SEGS_STATE: return "i386_REGS_SEGS_STATE";
    case BFD_MACH_O_i386_THREAD_SYSCALL_STATE: return "i386_THREAD_SYSCALL_STATE";
    case BFD_MACH_O_i386_THREAD_STATE_NONE: return "i386_THREAD_STATE_NONE";
    case BFD_MACH_O_i386_SAVED_STATE: return "i386_SAVED_STATE";
    case BFD_MACH_O_i386_THREAD_STATE: return "i386_THREAD_STATE";
    case BFD_MACH_O_i386_THREAD_FPSTATE: return "i386_THREAD_FPSTATE";
    case BFD_MACH_O_i386_THREAD_EXCEPTSTATE: return "i386_THREAD_EXCEPTSTATE";
    case BFD_MACH_O_i386_THREAD_CTHREADSTATE: return "i386_THREAD_CTHREADSTATE";
d1471 3
d1496 34
d1551 1
d1571 1
d1598 1
a1598 1
  bfdsec->flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC | SEC_CODE;
d1618 1
a1618 1
	      (abfd, &seg->sections[i], segoff, wide) != 0)
d1706 6
d1728 1
d1743 1
d1746 2
d1792 1
a1792 1
	      == (unsigned long) BFD_MACH_O_i386_THREAD_STATE))
d1859 15
a1873 2
  abfd->flags = (abfd->xvec->object_flags
		 | (abfd->flags & (BFD_IN_MEMORY | BFD_IO_FUNCS)));
a2048 1
  bfd *abfd;
a2093 1
      adata->archentries[i].abfd = NULL;
d2112 5
d2128 1
a2128 1
	  if (adata->archentries[i].abfd == prev)
d2148 3
a2150 4
  if (entry->abfd == NULL)
    {
      bfd *nbfd = _bfd_new_bfd_contained_in (archive);
      char *s = NULL;
d2152 1
a2152 2
      if (nbfd == NULL)
	return NULL;
d2154 9
a2162 9
      nbfd->origin = entry->offset;
      s = bfd_malloc (strlen (archive->filename) + 1);
      if (s == NULL)
	return NULL;
      strcpy (s, archive->filename);
      nbfd->filename = s;
      nbfd->iostream = NULL;
      entry->abfd = nbfd;
    }
d2164 1
a2164 1
  return entry->abfd;
d2273 141
@


1.28
log
@Silence gcc printf warnings
@
text
@d100 1
d103 3
d109 11
d282 8
a289 1
    case BFD_MACH_O_CPU_TYPE_I386: *type = bfd_arch_i386; break;
d295 4
a298 1
    case BFD_MACH_O_CPU_TYPE_SPARC: *type = bfd_arch_sparc; break;
d301 8
a308 8
    case BFD_MACH_O_CPU_TYPE_POWERPC: *type = bfd_arch_powerpc; break;
    default: *type = bfd_arch_unknown; break;
    }

  switch (*type)
    {
    case bfd_arch_i386: *subtype = bfd_mach_i386_i386; break;
    case bfd_arch_sparc: *subtype = bfd_mach_sparc; break;
d310 2
a311 1
      *subtype = bfd_arch_unknown;
d318 4
a321 1
  unsigned char buf[28];
d331 3
d335 1
a335 1
  if (bfd_bwrite ((PTR) buf, 28, abfd) != 28)
d342 1
a342 2
bfd_mach_o_scan_write_thread (bfd *abfd,
			      bfd_mach_o_load_command *command)
d374 3
a376 3
bfd_mach_o_scan_write_section (bfd *abfd,
			       bfd_mach_o_section *section,
			       bfd_vma offset)
d389 2
a390 2
  /* bfd_h_put_32 (abfd, section->reserved1, buf + 60); */
  /* bfd_h_put_32 (abfd, section->reserved2, buf + 64); */
d400 3
a402 1
bfd_mach_o_scan_write_segment (bfd *abfd, bfd_mach_o_load_command *command)
d404 40
a443 1
  unsigned char buf[48];
d447 14
a460 1
  BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT);
d462 18
a479 9
  memcpy (buf, seg->segname, 16);
  bfd_h_put_32 (abfd, seg->vmaddr, buf + 16);
  bfd_h_put_32 (abfd, seg->vmsize, buf + 20);
  bfd_h_put_32 (abfd, seg->fileoff, buf + 24);
  bfd_h_put_32 (abfd, seg->filesize, buf + 28);
  bfd_h_put_32 (abfd, 0 /* seg->maxprot */, buf + 32);
  bfd_h_put_32 (abfd, 0 /* seg->initprot */, buf + 36);
  bfd_h_put_32 (abfd, seg->nsects, buf + 40);
  bfd_h_put_32 (abfd, seg->flags, buf + 44);
d481 4
a484 3
  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bwrite ((PTR) buf, 48, abfd) != 48)
    return -1;
d493 1
a493 1
	bfd_vma thisread = nbytes;
d495 2
a496 2
	if (thisread > 1024)
	  thisread = 1024;
d499 1
a499 1
	if (bfd_bread ((PTR) buf, thisread, abfd) != thisread)
d503 1
a503 1
	if (bfd_bwrite ((PTR) buf, thisread, abfd) != thisread)
d506 2
a507 2
	nbytes -= thisread;
	curoff += thisread;
d513 5
a517 1
      bfd_vma segoff = command->offset + 48 + 8 + (i * 68);
d519 2
a520 1
      if (bfd_mach_o_scan_write_section (abfd, &seg->sections[i], segoff) != 0)
d528 13
a540 2
bfd_mach_o_scan_write_symtab_symbols (bfd *abfd,
				      bfd_mach_o_load_command *command)
d638 5
a642 1
	  if (bfd_mach_o_scan_write_segment (abfd, cur) != 0)
d707 2
a708 1
  unsigned char buf[28];
d713 2
a714 1
  if (bfd_bread ((PTR) buf, 28, abfd) != 28)
d721 1
d728 15
d751 7
d765 3
d801 1
d807 3
a809 3
bfd_mach_o_scan_read_section (bfd *abfd,
			      bfd_mach_o_section *section,
			      bfd_vma offset)
d830 34
d872 12
d891 4
a894 2
  bfd_vma symoff = sym->symoff + (i * 12);
  unsigned char buf[12];
d898 1
a898 1
  unsigned long value = -1;
d905 1
a905 1
  if (bfd_bread ((PTR) buf, 12, abfd) != 12)
d908 1
a908 1
	       12, (unsigned long) symoff);
d917 4
a920 1
  value = bfd_h_get_32 (abfd, buf + 8);
d968 2
a969 2
	      s->section = mdata->sections[section - 1]->bfdsection;
	      s->value = s->value - mdata->sections[section - 1]->addr;
d1312 1
d1316 1
d1393 1
d1419 1
a1419 1
  bfdsec->size = seg->nsyms * 12;
d1447 3
a1449 1
bfd_mach_o_scan_read_segment (bfd *abfd, bfd_mach_o_load_command *command)
d1451 1
a1451 1
  unsigned char buf[48];
a1457 1
  flagword flags;
d1459 26
a1484 1
  BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT);
d1486 1
a1486 3
  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bread ((PTR) buf, 48, abfd) != 48)
    return -1;
d1488 9
a1496 9
  memcpy (seg->segname, buf, 16);
  seg->vmaddr = bfd_h_get_32 (abfd, buf + 16);
  seg->vmsize = bfd_h_get_32 (abfd, buf + 20);
  seg->fileoff = bfd_h_get_32 (abfd, buf + 24);
  seg->filesize = bfd_h_get_32 (abfd, buf +  28);
  /* seg->maxprot = bfd_h_get_32 (abfd, buf + 32); */
  /* seg->initprot = bfd_h_get_32 (abfd, buf + 36); */
  seg->nsects = bfd_h_get_32 (abfd, buf + 40);
  seg->flags = bfd_h_get_32 (abfd, buf + 44);
d1504 1
a1504 2
  flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC | SEC_CODE;
  bfdsec = bfd_make_section_anyway_with_flags (abfd, sname, flags);
d1513 2
d1526 5
a1530 1
	  bfd_vma segoff = command->offset + 48 + 8 + (i * 68);
d1532 2
a1533 2
	  if (bfd_mach_o_scan_read_section (abfd, &seg->sections[i],
					    segoff) != 0)
d1542 12
d1570 5
a1574 1
      if (bfd_mach_o_scan_read_segment (abfd, command) != 0)
d1641 2
a1642 1
      if (mdata->commands[i].type == BFD_MACH_O_LC_SEGMENT)
d1657 2
a1658 1
      if (mdata->commands[i].type == BFD_MACH_O_LC_SEGMENT)
d1720 24
d1757 3
d1790 1
a1790 1
	    cur->offset = 28;
d2079 2
a2080 1
      if (cmd->type != BFD_MACH_O_LC_SEGMENT)
@


1.27
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d559 1
a559 1
		   (long) cur->type);
d1579 1
a1579 1
	       (long) header.byteorder);
d1626 1
a1626 1
	       (long) header.byteorder);
@


1.26
log
@* mach-o.c (bfd_mach_o_make_bfd_section): Fix test for non zerofill sections.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d1926 4
a1929 2
	      buf = bfd_realloc (buf, size);

d1934 4
a1937 1
		return -1;
d1960 1
d1970 2
@


1.25
log
@Switch sources over to use the GPL version 3
@
text
@d647 1
a647 1
  if (!(section->flags & BFD_MACH_O_S_ZEROFILL))
@


1.24
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.23
log
@	* libbfd-in.h (_bfd_norelocs_get_reloc_upper_bound): Don't define,
	declare.
	(_bfd_norelocs_canonicalize_reloc): Likewise.
	* libbfd.h: Regenerate.
	* libbfd.c (_bfd_norelocs_get_reloc_upper_bound): New function.
	(_bfd_norelocs_canonicalize_reloc): Likewise.
	* binary.c (binary_bfd_reloc_type_lookup): Don't define.
	(binary_get_reloc_upper_bound, binary_canonicalize_reloc): Likewise.
	(binary_vec): Use _bfd_norelocs in BFD_JUMP_TABLE_RELOCS.
	* ihex.c: Similarly.
	* mach-o-target.c: Similarly.
	* mach-o.c: Similarly.
	* mmo.c: Similarly.
	* pef.c: Similarly.
	* ppcboot.c: Similarly.
	* srec.c: Similarly.
	* xsym.c: Similarly.
@
text
@d21 1
a23 1
#include "sysdep.h"
@


1.22
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
a54 3
#define bfd_mach_o_get_reloc_upper_bound              _bfd_norelocs_get_reloc_upper_bound
#define bfd_mach_o_canonicalize_reloc                 _bfd_norelocs_canonicalize_reloc
#define bfd_mach_o_bfd_reloc_type_lookup              _bfd_norelocs_bfd_reloc_type_lookup
@


1.21
log
@	* stabs.c (_bfd_link_section_stabs): Use bfd_make_section*_with_flags
	instead of bfd_make_section*.
	* aix386-core.c: Likewise.
	* aix5ppc-core.c: Likewise.
	* aout-adobe.c: Likewise.
	* aoutf1.h: Likewise.
	* binary.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* elf.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-m32c.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlmcode.h: Likewise.
	* opncls.c: Likewise.
	* osf-core.c: Likewise.
	* peXXigen.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* rs6000-core.c: Likewise.
	* sco5-core.c: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* sunos.c: Likewise.
	* trad-core.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.c: Likewise.
@
text
@d571 1
a571 1
			   bfd_boolean b ATTRIBUTE_UNUSED)
@


1.20
log
@        * corefile.c (generic_core_file_matches_executable_p): New function.
        * libbfd-in.h (generic_core_file_matches_executable_p): Add
        declaration.
        * libbfd.h: Regenerate.
        * hpux-core.c: ANSIfy function declarations and prototypes.
        (thread_section_p): Manually expand bfd_section_name macro
        to make it clear that parameter ABFD is not used.
        (hpux_core_core_file_matches_executable_p): Delete, replaced
        by macro pointing to generic_core_file_matches_executable_p.

        * aix386-core.c: Replace core_file_matches_executable_p null
        implementation by generic_core_file_matches_executable_p by
        using a macro.
        * aix5ppc-core.c: Likewise.
        * cisco-core.c: Likewise.
        * hppabsd-core.c: Likewise.
        * irix-core.c: Likewise.
        * lynx-core.c: Likewise.
        * mach-o.c: Likewise.
        * netbsd-core.c: Likewise.
        * osf-core.c: Likewise.
        * ptrace-core.c: Likewise.
        * sco5-core.c: Likewise.
        * trad-core.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
d637 1
d648 4
a651 1
  bfdsec = bfd_make_section_anyway (abfd, sname);
a660 5
  if (section->flags & BFD_MACH_O_S_ZEROFILL)
    bfdsec->flags = SEC_ALLOC;
  else
    bfdsec->flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC | SEC_CODE;

d968 1
a968 1
  bfdsec = bfd_make_section_anyway (abfd, sname);
a976 1
  bfdsec->flags = SEC_HAS_CONTENTS;
d1023 1
a1023 1
  bfdsec = bfd_make_section_anyway (abfd, sname);
a1031 1
  bfdsec->flags = SEC_HAS_CONTENTS;
d1142 1
a1142 1
      bfdsec = bfd_make_section (abfd, sname);
a1148 1
      bfdsec->flags = SEC_HAS_CONTENTS;
d1217 1
a1217 1
  bfdsec = bfd_make_section_anyway (abfd, sname);
a1225 1
  bfdsec->flags = SEC_HAS_CONTENTS;
d1235 1
a1235 1
  bfdsec = bfd_make_section_anyway (abfd, sname);
a1243 1
  bfdsec->flags = SEC_HAS_CONTENTS;
d1260 1
d1284 2
a1285 1
  bfdsec = bfd_make_section_anyway (abfd, sname);
a1293 1
  bfdsec->flags = SEC_HAS_CONTENTS | SEC_LOAD | SEC_ALLOC | SEC_CODE;
@


1.19
log
@Approved by nickc@@redhat.com

	2005-05-23  Fred Fish  <fnf@@specifixinc.com>
	* dwarf2.c (struct dwarf2_debug): Add inliner_chain member.
	(struct funcinfo): Add caller_func, caller_file, caller_line.
	tag, and nesting_level members.
	(lookup_address_in_function_table): Change first passed parameter
	from "struct funcinfo *" to "struct comp_unit *".
	(lookup_address_in_function_table): Dereference unit to find function
	table.
	(lookup_address_in_function_table): Traverse the function list to
	create a chain of inlined functions back to the first non inlined
	function.
	(scan_unit_for_functions): Remember tag and nesting level.  Handle
	DW_AT_call_file and DW_AT_call_line.
	(comp_unit_find_nearest_line): Adjust lookup_address_in_function_table
	call to pass unit pointer instead of function table pointer.  For
	inlined functions, save pointer to the inliner chain.
	(_bfd_dwarf2_find_nearest_line): Initialize inliner_chain to NULL.
	(_bfd_dwarf2_find_inliner_info): New function that returns information
	from the inliner chain after a call to bfd_find_nearest_line.

	* bfd.c (bfd_find_inliner_info): Define using BFD_SEND.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Add entry for
	NAME##_find_inliner_info.
	(bfd_target): Add _bfd_find_inliner_info.
	* bfd-in2.h: Regenerate.

	* libbfd-in.h (_bfd_nosymbols_find_inliner_info): Define as
	macro that always returns bfd_false.
	(_bfd_dwarf2_find_inliner_info): Declare.
	* libbfd.h: Regenerate.

	* elf32-arm.c (elf32_arm_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	(bfd_elf32_find_inliner_info): Define to elf32_arm_find_inliner_info.

	* elfxx-mips.c (_bfd_mips_elf_find_inliner_info): New function
	that calls _bfd_dwarf2_find_inliner_info.
	* elfxx-mips.h (_bfd_mips_elf_find_inliner_info): Declare.
	* elfn32-mips.c (bfd_elf32_find_inliner_info): Define to
	_bfd_mips_elf_find_inliner_info.
	* elf64-mips.c (bfd_elf64_find_inliner_info): Ditto.
	* elf32-mips.c (bfd_elf32_find_inliner_info): Ditto.

	* elf.c (_bfd_elf_find_inliner_info): New function that calls
	_bfd_dwarf2_find_inliner_info.
	* elf-bfd.h (_bfd_elf_find_inliner_info): Declare.
	* elfxx-target.h (bfd_elfNN_find_inliner_info): Define to
	_bfd_elf_find_inliner_info.

	* coffgen.c (coff_find_inliner_info): New function that
	calls _bfd_dwarf2_find_inliner_info.
	* libcoff-in.h (coff_find_inliner_info): Declare.
	* libcoff.h: Regenerate.
	* coff-rs6000.c (rs6000coff_vec): Add coff_find_inliner_info.
	(pmac_xcoff_vec) Ditto.
	* coff64-rs6000.c (rs6000coff64_vec): Ditto.
	(aix5coff64_vec): Ditto.

	* aout-target.h (MY_find_inliner_info): Define as
	_bfd_nosymbols_find_inliner_info.
	* aout-tic30.c (MY_find_inliner_info): Ditto.
	* binary.c (binary_find_inliner_info): Ditto.
	* i386msdos.c (msdos_find_inliner_info): Ditto.
	* ihex.c (ihex_find_inliner_info): Ditto.
	* libaout.h (aout_32_find_inliner_info): Ditto.
	* libecoff.h (_bfd_ecoff_find_inliner_info): Ditto.
	* mach-o.c (bfd_mach_o_find_inliner_info): Ditto.
	* mmo.c (mmo_find_inliner_info): Ditto.
	* nlm-target.h (nlm_find_inliner_info): Ditto.
	* pef.c (bfd_pef_find_inliner_info): Ditto.
	* ppcboot.c (ppcboot_find_inliner_info): Ditto.
	* srec.c (srec_find_inliner_info): Ditto.
	* tekhex.c (tekhex_find_inliner_info): Ditto.
	* versados.c (versados_find_inliner_info): Ditto.
	* xsym.c (bfd_sym_find_inliner_info): Ditto.

	* ieee.c (ieee_find_inliner_info): New function that always
	returns FALSE.
	* oasys.c (oasys_find_inliner_info): Ditto.
	* vms.c (vms_find_inliner_info): Ditto.
@
text
@d78 1
a1996 7
bfd_boolean
bfd_mach_o_core_file_matches_executable_p (bfd *core_bfd ATTRIBUTE_UNUSED,
					   bfd *exec_bfd ATTRIBUTE_UNUSED)
{
  return TRUE;
}

@


1.18
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d51 1
@


1.17
log
@Update the FSF address in the copyright/GPL notice
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.16
log
@Convert to ISO C90 formatting
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.15
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d32 25
a56 25
#define bfd_mach_o_mkarchive _bfd_noarchive_mkarchive
#define bfd_mach_o_read_ar_hdr _bfd_noarchive_read_ar_hdr
#define bfd_mach_o_slurp_armap _bfd_noarchive_slurp_armap
#define bfd_mach_o_slurp_extended_name_table _bfd_noarchive_slurp_extended_name_table
#define bfd_mach_o_construct_extended_name_table _bfd_noarchive_construct_extended_name_table
#define bfd_mach_o_truncate_arname _bfd_noarchive_truncate_arname
#define bfd_mach_o_write_armap _bfd_noarchive_write_armap
#define bfd_mach_o_get_elt_at_index _bfd_noarchive_get_elt_at_index
#define bfd_mach_o_generic_stat_arch_elt _bfd_noarchive_generic_stat_arch_elt
#define bfd_mach_o_update_armap_timestamp _bfd_noarchive_update_armap_timestamp
#define	bfd_mach_o_close_and_cleanup _bfd_generic_close_and_cleanup
#define bfd_mach_o_bfd_free_cached_info _bfd_generic_bfd_free_cached_info
#define bfd_mach_o_new_section_hook _bfd_generic_new_section_hook
#define bfd_mach_o_get_section_contents_in_window _bfd_generic_get_section_contents_in_window
#define bfd_mach_o_bfd_is_local_label_name _bfd_nosymbols_bfd_is_local_label_name
#define bfd_mach_o_bfd_is_target_special_symbol ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
#define bfd_mach_o_bfd_is_local_label_name _bfd_nosymbols_bfd_is_local_label_name
#define bfd_mach_o_get_lineno _bfd_nosymbols_get_lineno
#define bfd_mach_o_find_nearest_line _bfd_nosymbols_find_nearest_line
#define bfd_mach_o_bfd_make_debug_symbol _bfd_nosymbols_bfd_make_debug_symbol
#define bfd_mach_o_read_minisymbols _bfd_generic_read_minisymbols
#define bfd_mach_o_minisymbol_to_symbol _bfd_generic_minisymbol_to_symbol
#define bfd_mach_o_get_reloc_upper_bound _bfd_norelocs_get_reloc_upper_bound
#define bfd_mach_o_canonicalize_reloc _bfd_norelocs_canonicalize_reloc
#define bfd_mach_o_bfd_reloc_type_lookup _bfd_norelocs_bfd_reloc_type_lookup
d58 20
a77 86
#define bfd_mach_o_bfd_relax_section bfd_generic_relax_section
#define bfd_mach_o_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define bfd_mach_o_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define bfd_mach_o_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define bfd_mach_o_bfd_link_just_syms _bfd_generic_link_just_syms
#define bfd_mach_o_bfd_final_link _bfd_generic_final_link
#define bfd_mach_o_bfd_link_split_section _bfd_generic_link_split_section
#define bfd_mach_o_set_arch_mach bfd_default_set_arch_mach
#define bfd_mach_o_bfd_merge_private_bfd_data _bfd_generic_bfd_merge_private_bfd_data
#define bfd_mach_o_bfd_set_private_flags _bfd_generic_bfd_set_private_flags
#define bfd_mach_o_bfd_print_private_bfd_data _bfd_generic_bfd_print_private_bfd_data
#define bfd_mach_o_get_section_contents _bfd_generic_get_section_contents
#define bfd_mach_o_set_section_contents _bfd_generic_set_section_contents
#define bfd_mach_o_bfd_gc_sections bfd_generic_gc_sections
#define bfd_mach_o_bfd_merge_sections bfd_generic_merge_sections
#define bfd_mach_o_bfd_is_group_section bfd_generic_is_group_section
#define bfd_mach_o_bfd_discard_group bfd_generic_discard_group
#define bfd_mach_o_section_already_linked \
  _bfd_generic_section_already_linked
#define bfd_mach_o_bfd_copy_private_header_data _bfd_generic_bfd_copy_private_header_data

static bfd_boolean bfd_mach_o_bfd_copy_private_symbol_data
  PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
static bfd_boolean bfd_mach_o_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));
static bfd_boolean bfd_mach_o_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static long bfd_mach_o_count_symbols
  PARAMS ((bfd *));
static long bfd_mach_o_get_symtab_upper_bound
  PARAMS ((bfd *));
static long bfd_mach_o_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
static void bfd_mach_o_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void bfd_mach_o_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static void bfd_mach_o_convert_architecture
  PARAMS ((bfd_mach_o_cpu_type, bfd_mach_o_cpu_subtype,
	   enum bfd_architecture *, unsigned long *));
static bfd_boolean bfd_mach_o_write_contents
  PARAMS ((bfd *));
static int bfd_mach_o_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static asymbol * bfd_mach_o_make_empty_symbol
  PARAMS ((bfd *));
static int bfd_mach_o_write_header
  PARAMS ((bfd *, bfd_mach_o_header *));
static int bfd_mach_o_read_header
  PARAMS ((bfd *, bfd_mach_o_header *));
static asection * bfd_mach_o_make_bfd_section
  PARAMS ((bfd *, bfd_mach_o_section *));
static int bfd_mach_o_scan_read_section
  PARAMS ((bfd *, bfd_mach_o_section *, bfd_vma));
static int bfd_mach_o_scan_write_section
  PARAMS ((bfd *, bfd_mach_o_section *, bfd_vma));
static int bfd_mach_o_scan_write_symtab_symbols
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_write_thread
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_dylinker
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_dylib
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_prebound_dylib
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_thread
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_write_symtab
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_dysymtab
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_symtab
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_segment
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_write_segment
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_command
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static void bfd_mach_o_flatten_sections
  PARAMS ((bfd *));
static const char * bfd_mach_o_i386_flavour_string
  PARAMS ((unsigned int));
static const char * bfd_mach_o_ppc_flavour_string
  PARAMS ((unsigned int));
d106 1
a106 2
bfd_mach_o_valid (abfd)
     bfd *abfd;
d125 4
a128 5
bfd_mach_o_bfd_copy_private_symbol_data (ibfd, isymbol, obfd, osymbol)
     bfd *ibfd ATTRIBUTE_UNUSED;
     asymbol *isymbol ATTRIBUTE_UNUSED;
     bfd *obfd ATTRIBUTE_UNUSED;
     asymbol *osymbol ATTRIBUTE_UNUSED;
d137 4
a140 5
bfd_mach_o_bfd_copy_private_section_data (ibfd, isection, obfd, osection)
     bfd *ibfd ATTRIBUTE_UNUSED;
     asection *isection ATTRIBUTE_UNUSED;
     bfd *obfd ATTRIBUTE_UNUSED;
     asection *osection ATTRIBUTE_UNUSED;
d149 1
a149 3
bfd_mach_o_bfd_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d160 1
a160 2
bfd_mach_o_count_symbols (abfd)
     bfd *abfd;
d180 1
a180 2
bfd_mach_o_get_symtab_upper_bound (abfd)
     bfd *abfd;
d191 1
a191 3
bfd_mach_o_canonicalize_symtab (abfd, alocation)
     bfd *abfd;
     asymbol **alocation;
d229 3
a231 4
bfd_mach_o_get_symbol_info (abfd, symbol, ret)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
d237 4
a240 5
bfd_mach_o_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
d256 4
a259 5
bfd_mach_o_convert_architecture (mtype, msubtype, type, subtype)
     bfd_mach_o_cpu_type mtype;
     bfd_mach_o_cpu_subtype msubtype ATTRIBUTE_UNUSED;
     enum bfd_architecture *type;
     unsigned long *subtype;
d289 202
d492 1
a492 2
bfd_mach_o_write_contents (abfd)
     bfd *abfd;
d568 2
a569 3
bfd_mach_o_sizeof_headers (a, b)
     bfd *a ATTRIBUTE_UNUSED;
     bfd_boolean b ATTRIBUTE_UNUSED;
d578 1
a578 2
bfd_mach_o_make_empty_symbol (abfd)
     bfd *abfd;
d582 1
a582 1
  new = (asymbol *) bfd_zalloc (abfd, sizeof (asymbol));
d590 1
a590 25
bfd_mach_o_write_header (abfd, header)
     bfd *abfd;
     bfd_mach_o_header *header;
{
  unsigned char buf[28];

  bfd_h_put_32 (abfd, header->magic, buf + 0);
  bfd_h_put_32 (abfd, header->cputype, buf + 4);
  bfd_h_put_32 (abfd, header->cpusubtype, buf + 8);
  bfd_h_put_32 (abfd, header->filetype, buf + 12);
  bfd_h_put_32 (abfd, header->ncmds, buf + 16);
  bfd_h_put_32 (abfd, header->sizeofcmds, buf + 20);
  bfd_h_put_32 (abfd, header->flags, buf + 24);

  bfd_seek (abfd, 0, SEEK_SET);
  if (bfd_bwrite ((PTR) buf, 28, abfd) != 28)
    return -1;

  return 0;
}

static int
bfd_mach_o_read_header (abfd, header)
     bfd *abfd;
     bfd_mach_o_header *header;
d629 1
a629 3
bfd_mach_o_make_bfd_section (abfd, section)
     bfd *abfd;
     bfd_mach_o_section *section;
d640 1
a640 1
  sname = (char *) bfd_alloc (abfd, snamelen);
d664 3
a666 4
bfd_mach_o_scan_read_section (abfd, section, offset)
     bfd *abfd;
     bfd_mach_o_section *section;
     bfd_vma offset;
a694 69
static int
bfd_mach_o_scan_write_section (abfd, section, offset)
     bfd *abfd;
     bfd_mach_o_section *section;
     bfd_vma offset;
{
  unsigned char buf[68];

  memcpy (buf, section->sectname, 16);
  memcpy (buf + 16, section->segname, 16);
  bfd_h_put_32 (abfd, section->addr, buf + 32);
  bfd_h_put_32 (abfd, section->size, buf + 36);
  bfd_h_put_32 (abfd, section->offset, buf + 40);
  bfd_h_put_32 (abfd, section->align, buf + 44);
  bfd_h_put_32 (abfd, section->reloff, buf + 48);
  bfd_h_put_32 (abfd, section->nreloc, buf + 52);
  bfd_h_put_32 (abfd, section->flags, buf + 56);
  /* bfd_h_put_32 (abfd, section->reserved1, buf + 60); */
  /* bfd_h_put_32 (abfd, section->reserved2, buf + 64); */

  bfd_seek (abfd, offset, SEEK_SET);
  if (bfd_bwrite ((PTR) buf, 68, abfd) != 68)
    return -1;

  return 0;
}

static int
bfd_mach_o_scan_write_symtab_symbols (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
{
  bfd_mach_o_symtab_command *sym = &command->command.symtab;
  asymbol *s = NULL;
  unsigned long i;

  for (i = 0; i < sym->nsyms; i++)
    {
      unsigned char buf[12];
      bfd_vma symoff = sym->symoff + (i * 12);
      unsigned char ntype = 0;
      unsigned char nsect = 0;
      short ndesc = 0;

      s = &sym->symbols[i];

      /* Instead just set from the stored values.  */
      ntype = (s->udata.i >> 24) & 0xff;
      nsect = (s->udata.i >> 16) & 0xff;
      ndesc = s->udata.i & 0xffff;

      bfd_h_put_32 (abfd, s->name - sym->strtab, buf);
      bfd_h_put_8 (abfd, ntype, buf + 4);
      bfd_h_put_8 (abfd, nsect, buf + 5);
      bfd_h_put_16 (abfd, ndesc, buf + 6);
      bfd_h_put_32 (abfd, s->section->vma + s->value, buf + 8);

      bfd_seek (abfd, symoff, SEEK_SET);
      if (bfd_bwrite ((PTR) buf, 12, abfd) != 12)
	{
	  fprintf (stderr, "bfd_mach_o_scan_write_symtab_symbols: unable to write %d bytes at %lu\n",
		   12, (unsigned long) symoff);
	  return -1;
	}
    }

  return 0;
}

d696 4
a699 5
bfd_mach_o_scan_read_symtab_symbol (abfd, sym, s, i)
     bfd *abfd;
     bfd_mach_o_symtab_command *sym;
     asymbol *s;
     unsigned long i;
d808 2
a809 3
bfd_mach_o_scan_read_symtab_strtab (abfd, sym)
     bfd *abfd;
     bfd_mach_o_symtab_command *sym;
d844 2
a845 3
bfd_mach_o_scan_read_symtab_symbols (abfd, sym)
     bfd *abfd;
     bfd_mach_o_symtab_command *sym;
d874 5
a878 6
bfd_mach_o_scan_read_dysymtab_symbol (abfd, dysym, sym, s, i)
     bfd *abfd;
     bfd_mach_o_dysymtab_command *dysym;
     bfd_mach_o_symtab_command *sym;
     asymbol *s;
     unsigned long i;
d899 1
a899 2
bfd_mach_o_i386_flavour_string (flavour)
     unsigned int flavour;
d920 1
a920 2
bfd_mach_o_ppc_flavour_string (flavour)
     unsigned int flavour;
d933 2
a934 37
bfd_mach_o_scan_write_thread (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
{
  bfd_mach_o_thread_command *cmd = &command->command.thread;
  unsigned int i;
  unsigned char buf[8];
  bfd_vma offset;
  unsigned int nflavours;

  BFD_ASSERT ((command->type == BFD_MACH_O_LC_THREAD)
	      || (command->type == BFD_MACH_O_LC_UNIXTHREAD));

  offset = 8;
  nflavours = 0;
  for (i = 0; i < cmd->nflavours; i++)
    {
      BFD_ASSERT ((cmd->flavours[i].size % 4) == 0);
      BFD_ASSERT (cmd->flavours[i].offset == (command->offset + offset + 8));

      bfd_h_put_32 (abfd, cmd->flavours[i].flavour, buf);
      bfd_h_put_32 (abfd, (cmd->flavours[i].size / 4), buf + 4);

      bfd_seek (abfd, command->offset + offset, SEEK_SET);
      if (bfd_bwrite ((PTR) buf, 8, abfd) != 8)
	return -1;

      offset += cmd->flavours[i].size + 8;
    }

  return 0;
}

static int
bfd_mach_o_scan_read_dylinker (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
d962 1
a962 1
  sname = (char *) bfd_alloc (abfd, strlen (prefix) + 1);
d984 1
a984 3
bfd_mach_o_scan_read_dylib (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
d1018 1
a1018 1
  sname = (char *) bfd_alloc (abfd, strlen (prefix) + 1);
d1040 2
a1041 3
bfd_mach_o_scan_read_prebound_dylib (abfd, command)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_mach_o_load_command *command ATTRIBUTE_UNUSED;
d1050 1
a1050 3
bfd_mach_o_scan_read_thread (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
d1081 1
a1081 3
  cmd->flavours =
    ((bfd_mach_o_thread_flavour *)
     bfd_alloc (abfd, nflavours * sizeof (bfd_mach_o_thread_flavour)));
d1131 1
a1131 1
      sname = (char *) bfd_alloc (abfd, snamelen);
d1159 1
a1159 28
bfd_mach_o_scan_write_symtab (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
{
  bfd_mach_o_symtab_command *seg = &command->command.symtab;
  unsigned char buf[16];

  BFD_ASSERT (command->type == BFD_MACH_O_LC_SYMTAB);

  bfd_h_put_32 (abfd, seg->symoff, buf);
  bfd_h_put_32 (abfd, seg->nsyms, buf + 4);
  bfd_h_put_32 (abfd, seg->stroff, buf + 8);
  bfd_h_put_32 (abfd, seg->strsize, buf + 12);

  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bwrite ((PTR) buf, 16, abfd) != 16)
    return -1;

  if (bfd_mach_o_scan_write_symtab_symbols (abfd, command) != 0)
    return -1;

  return 0;
}

static int
bfd_mach_o_scan_read_dysymtab (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
d1193 1
a1193 3
bfd_mach_o_scan_read_symtab (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
d1214 1
a1214 1
  sname = (char *) bfd_alloc (abfd, strlen (prefix) + 1);
d1233 1
a1233 1
  sname = (char *) bfd_alloc (abfd, strlen (prefix) + 1);
d1255 1
a1255 3
bfd_mach_o_scan_read_segment (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
d1282 1
a1282 1
  sname = (char *) bfd_alloc (abfd, snamelen);
d1302 1
a1302 3
      seg->sections =
	((bfd_mach_o_section *)
	 bfd_alloc (abfd, seg->nsects * sizeof (bfd_mach_o_section)));
d1320 1
a1320 64
bfd_mach_o_scan_write_segment (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
{
  unsigned char buf[48];
  bfd_mach_o_segment_command *seg = &command->command.segment;
  unsigned long i;

  BFD_ASSERT (command->type == BFD_MACH_O_LC_SEGMENT);

  memcpy (buf, seg->segname, 16);
  bfd_h_put_32 (abfd, seg->vmaddr, buf + 16);
  bfd_h_put_32 (abfd, seg->vmsize, buf + 20);
  bfd_h_put_32 (abfd, seg->fileoff, buf + 24);
  bfd_h_put_32 (abfd, seg->filesize, buf + 28);
  bfd_h_put_32 (abfd, 0 /* seg->maxprot */, buf + 32);
  bfd_h_put_32 (abfd, 0 /* seg->initprot */, buf + 36);
  bfd_h_put_32 (abfd, seg->nsects, buf + 40);
  bfd_h_put_32 (abfd, seg->flags, buf + 44);

  bfd_seek (abfd, command->offset + 8, SEEK_SET);
  if (bfd_bwrite ((PTR) buf, 48, abfd) != 48)
    return -1;

  {
    char buf[1024];
    bfd_vma nbytes = seg->filesize;
    bfd_vma curoff = seg->fileoff;

    while (nbytes > 0)
      {
	bfd_vma thisread = nbytes;

	if (thisread > 1024)
	  thisread = 1024;

	bfd_seek (abfd, curoff, SEEK_SET);
	if (bfd_bread ((PTR) buf, thisread, abfd) != thisread)
	  return -1;

	bfd_seek (abfd, curoff, SEEK_SET);
	if (bfd_bwrite ((PTR) buf, thisread, abfd) != thisread)
	  return -1;

	nbytes -= thisread;
	curoff += thisread;
      }
  }

  for (i = 0; i < seg->nsects; i++)
    {
      bfd_vma segoff = command->offset + 48 + 8 + (i * 68);

      if (bfd_mach_o_scan_write_section (abfd, &seg->sections[i], segoff) != 0)
	return -1;
    }

  return 0;
}

static int
bfd_mach_o_scan_read_command (abfd, command)
     bfd *abfd;
     bfd_mach_o_load_command *command;
d1393 1
a1393 2
bfd_mach_o_flatten_sections (abfd)
     bfd *abfd;
d1432 1
a1432 2
bfd_mach_o_scan_start_address (abfd)
     bfd *abfd;
d1486 3
a1488 4
bfd_mach_o_scan (abfd, header, mdata)
     bfd *abfd;
     bfd_mach_o_header *header;
     bfd_mach_o_data_struct *mdata;
d1514 1
a1514 3
      mdata->commands =
	((bfd_mach_o_load_command *)
	 bfd_alloc (abfd, header->ncmds * sizeof (bfd_mach_o_load_command)));
d1543 1
a1543 2
bfd_mach_o_mkobject (abfd)
     bfd *abfd;
d1547 1
a1547 2
  mdata = ((bfd_mach_o_data_struct *)
	   bfd_alloc (abfd, sizeof (bfd_mach_o_data_struct)));
d1571 1
a1571 2
bfd_mach_o_object_p (abfd)
     bfd *abfd;
d1618 1
a1618 2
bfd_mach_o_core_p (abfd)
     bfd *abfd;
d1685 1
a1685 2
bfd_mach_o_archive_p (abfd)
     bfd *abfd;
d1695 1
a1695 2
  adata = (mach_o_fat_data_struct *)
    bfd_alloc (abfd, sizeof (mach_o_fat_data_struct));
d1704 1
a1704 1
  adata->archentries = (mach_o_fat_archentry *)
d1734 1
a1734 3
bfd_mach_o_openr_next_archived_file (archive, prev)
  bfd *archive;
  bfd *prev;
d1792 4
a1795 5
bfd_mach_o_lookup_section (abfd, section, mcommand, msection)
     bfd *abfd;
     asection *section;
     bfd_mach_o_load_command **mcommand;
     bfd_mach_o_section **msection;
d1842 3
a1844 4
bfd_mach_o_lookup_command (abfd, type, mcommand)
     bfd *abfd;
     bfd_mach_o_load_command_type type;
     bfd_mach_o_load_command **mcommand;
d1873 1
a1873 2
bfd_mach_o_stack_addr (type)
     enum bfd_mach_o_cpu_type type;
d1897 3
a1899 4
bfd_mach_o_core_fetch_environment (abfd, rbuf, rlen)
     bfd *abfd;
     unsigned char **rbuf;
     unsigned int *rlen;
d1976 1
a1976 2
bfd_mach_o_core_file_failing_command (abfd)
     bfd *abfd;
d1990 1
a1990 2
bfd_mach_o_core_file_failing_signal (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d1996 2
a1997 3
bfd_mach_o_core_file_matches_executable_p (core_bfd, exec_bfd)
     bfd *core_bfd ATTRIBUTE_UNUSED;
     bfd *exec_bfd ATTRIBUTE_UNUSED;
d2002 4
a2005 4
#define TARGET_NAME mach_o_be_vec
#define TARGET_STRING "mach-o-be"
#define TARGET_BIG_ENDIAN 1
#define TARGET_ARCHIVE 0
d2014 4
a2017 4
#define TARGET_NAME mach_o_le_vec
#define TARGET_STRING "mach-o-le"
#define TARGET_BIG_ENDIAN 0
#define TARGET_ARCHIVE 0
d2026 4
a2029 4
#define TARGET_NAME mach_o_fat_vec
#define TARGET_STRING "mach-o-fat"
#define TARGET_BIG_ENDIAN 1
#define TARGET_ARCHIVE 1
@


1.14
log
@	* mach-o.c (bfd_mach_o_scan): Don't ignore return value of
	bfd_mach_o_scan_start_address.
	* elfxx-ia64.c (elfNN_ia64_relax_brl): Rewrite for 32-bit bfd_vma.
	* elfxx-mips.c: Remove unnecessary prototypes.
	(sort_dynamic_relocs_64): Abort if not BFD64.
@
text
@d801 1
a801 1
      sym->strtab = b->buffer + sym->stroff;
d2123 1
a2123 1
  return buf;
@


1.13
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
d1660 1
a1660 1
    ;
@


1.12
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@a381 35
#if 0
  for (i = 0; i < mdata->header.ncmds; i++)
    {
      bfd_mach_o_load_command *cur = &mdata->commands[i];
      if (cur->type != BFD_MACH_O_LC_SEGMENT)
	break;

      {
	bfd_mach_o_segment_command *seg = &cur->command.segment;
	char buf[1024];
	bfd_vma nbytes = seg->filesize;
	bfd_vma curoff = seg->fileoff;

	while (nbytes > 0)
	  {
	    bfd_vma thisread = nbytes;

	    if (thisread > 1024)
	      thisread = 1024;

	    bfd_seek (abfd, curoff, SEEK_SET);
	    if (bfd_bread ((PTR) buf, thisread, abfd) != thisread)
	      return FALSE;

	    bfd_seek (abfd, curoff, SEEK_SET);
	    if (bfd_bwrite ((PTR) buf, thisread, abfd) != thisread)
	      return FALSE;

	    nbytes -= thisread;
	    curoff += thisread;
	  }
      }
  }
#endif

a646 15
      /* Don't set this from the symbol information; use stored values.  */
#if 0
      if (s->flags & BSF_GLOBAL)
	ntype |= N_EXT;
      if (s->flags & BSF_DEBUGGING)
	ntype |= N_STAB;

      if (s->section == bfd_und_section_ptr)
	ntype |= N_UNDF;
      else if (s->section == bfd_abs_section_ptr)
	ntype |= N_ABS;
      else
	ntype |= N_SECT;
#endif

d1660 1
a1660 8
    {
#if 0
      fprintf (stderr, "bfd_mach_o_scan: unable to scan start address: %s\n",
	       bfd_errmsg (bfd_get_error ()));
      abfd->tdata.mach_o_data = NULL;
      return -1;
#endif
    }
a1662 1

@


1.11
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d47 2
@


1.10
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d73 2
@


1.9
log
@binutils ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* objcopy.c (setup_bfd_headers): New function.
	(copy_object): Call setup_bfd_headers.
bfd ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* aout-target.h (MY_bfd_copy_private_header_data): Define.
	* aout-tic30.c (MY_bfd_copy_private_header_data): Define.
	* bfd.c (bfd_copy_private_header_data): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add entries for new
	interface.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_copy_private_header_data): Define.
	* elf-bfd.h (_bfd_elf_copy_private_header_data): Declare.
	* elf.c (_bfd_elf_copy_private_section_data): Remove code to set up
	segments by calling copy_private_bfd_data.
	(_bfd_elf_copy_private_header_data): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_private_header_data): Define.
	* libbfd-in.h (_bfd_generic_bfd_copy_private_header_data): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_private_header_data): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_private_header_data): Define.
	* mmo.c (mmo_bfd_copy_private_header_data): Define.
	* ppcboot.c (ppcboot_bfd_copy_private_header_data): Define.
	* som.c (som_bfd_copy_private_header_data): Define.
	* targets.c (BFD_JUMP_TABLE_COPY): Add _bfd_copy_private_header_data.
	* vms.c (vms_bfd_copy_private_header_data): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d587 1
a587 1
  bfdsec->_raw_size = section->size;
d1035 1
a1035 1
  bfdsec->_raw_size = command->len - 8;
d1093 1
a1093 1
  bfdsec->_raw_size = command->len - 8;
d1216 1
a1216 1
      bfdsec->_raw_size = cmd->flavours[i].size;
d1323 1
a1323 1
  bfdsec->_raw_size = seg->nsyms * 12;
d1342 1
a1342 1
  bfdsec->_raw_size = seg->strsize;
d1393 1
a1393 1
  bfdsec->_raw_size = seg->filesize;
@


1.8
log
@	* section.c (bfd_make_section_anyway): Add all sections to hash tab.

	* elf-bfd.h (bfd_elf_is_group_section): Declare.
	* elf.c (bfd_elf_is_group_section): New function.
	* elfxx-target.h (bfd_elfNN_bfd_is_group_section
	* section.c (bfd_generic_is_group_section): New function.
	* targets.c (struct bfd_target): Add _bfd_is_group_section field.
	(BFD_JUMP_TABLE_LINK): Adjust.
	* aout-adobe.c (aout_32_bfd_is_group_section): Define.
	* aout-target.h (MY_bfd_is_group_section): Define.
	* aout-tic30.c (MY_bfd_is_group_section): Define.
	* bfd.c (bfd_is_group_section): Define.
	* binary.c (binary_bfd_is_group_section): Define.
	* bout.c (b_out_bfd_is_group_section): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-mips.c (_bfd_ecoff_bfd_is_group_section): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Adjust.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Adjust.
	* coffcode.h (coff_bfd_is_group_section): Define.
	* i386msdos.c (msdos_bfd_is_group_section): Define.
	* i386os9k.c (os9k_bfd_is_group_section): Define.
	* ieee.c (ieee_bfd_is_group_section): Define.
	* ihex.c (ihex_bfd_is_group_section): Define.
	* libbfd-in.h (_bfd_nolink_bfd_is_group_section): Define.
	* mach-o.c (bfd_mach_o_bfd_is_group_section): Define.
	* mmo.c (mmo_bfd_is_group_section): Define.
	* nlm-target.h (nlm_bfd_is_group_section): Define.
	* oasys.c (oasys_bfd_is_group_section): Define.
	* pef.c (bfd_pef_bfd_is_group_section): Define.
	* ppcboot.c (ppcboot_bfd_is_group_section): Define.
	* srec.c (srec_bfd_is_group_section): Define.
	* tekhex.c (tekhex_bfd_is_group_section): Define.
	* versados.c (versados_bfd_is_group_section): Define.
	* vms.c (vms_bfd_is_group_section): Define.
	* xsym.c (bfd_sym_bfd_is_group_section): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d73 1
@


1.7
log
@	* bfd-in.h (bfd_getb64, bfd_getl64): Replace bfd_byte* with void*.
	(bfd_getb32, bfd_getl32, bfd_getb16, bfd_getl16): Likewise.
	(bfd_getb_signed_64, bfd_getl_signed_64): Likewise.
	(bfd_getb_signed_32, bfd_getl_signed_32): Likewise.
	(bfd_getb_signed_16, bfd_getl_signed_16): Likewise.
	(bfd_putb64, bfd_putl64, bfd_putb32, bfd_putl32): Likewise.
	(bfd_putb16, bfd_putl16, bfd_get_bits, bfd_put_bits): Likewise.
	* libbfd.c: Likewise in function definitions.
	(bfd_put_8): Mask with 0xff rather than casting to char.
	(bfd_putb16, bfd_putl16, bfd_putb32, bfd_putl32): Likewise.
	(bfd_putb64, bfd_putl64, bfd_put_bits): Likewise.
	(H_PUT_64, H_PUT_32, H_PUT_16, H_PUT_8): Remove casts, simplify.
	(H_PUT_S64, H_PUT_S32, H_PUT_S16, H_PUT_S8): Likewise.
	(H_GET_64, H_GET_32, H_GET_16, H_GET_8): Likewise.
	(H_GET_S64, H_GET_S32, H_GET_S16, H_GET_S8): Likewise.
	* libaout.h (H_PUT_64 H_PUT_32, H_PUT_16): Remove casts, simplify.
	(H_PUT_S64, H_PUT_S32, H_PUT_S16): Likewise.
	(H_GET_64, H_GET_32, H_GET_16): Likewise.
	(H_GET_S64, H_GET_S32, H_GET_S16): Likewise.
	* archive.c (do_slurp_coff_armap): Update swap prototype.
	* coff-tic54x.c (tic54x_getl32): Replace bfd_byte* with void*.
	(tic54x_getl_signed_32): Likewise.
	(tic54x_putl32): Likewise.  Mask with 0xff rather than casting to char.
	* mach-o.c (bfd_mach_o_read_header): Update get32 prototype.
	* pdp11.c (bfd_getp32): Make static, replace bfd_byte* with void*.
	(bfd_getp_signed_32, bfd_putp32): Likewise.
	* targets.c (struct bfd_target): Use void* in place of bfd_byte* for
	bfd_getx64, bfd_getx_signed_64, bfd_putx64, bfd_getx32,
	bfd_getx_signed_32, bfd_putx32, bfd_getx16, bfd_getx_signed_16,
	bfd_putx16, bfd_h_getx64, bfd_h_getx_signed_64, bfd_h_putx64,
	bfd_h_getx32, bfd_h_getx_signed_32, bfd_h_putx32, bfd_h_getx16,
	bfd_h_getx_signed_16, bfd_h_putx16.
	* aix386-core.c (NO_GET, NO_GETS, NO_PUT): Update prototypes.
	* hppabsd-core.c: Similarly.  Rename NO_SIGNED_GET to NO_GETS.
	* hpux-core.c: Likewise.
	* irix-core.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* trad-core.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003
d71 1
@


1.6
log
@	* aout-target.h, aoutf1.h, bfdio.c, bfdwin.c: Update copyright date.
	* coff-apollo.c, coff-sparc.c, coff-w65.c, coff-we32k.c: Ditto.
	* coff-z8k.c, coffgen.c, cpu-frv.c, cpu-h8500.c, cpu-hppa.c: Ditto.
	* cpu-ia64-opc.c, cpu-m10300.c, cpu-mips.c, cpu-msp430.c: Ditto.
	* cpu-rs6000.c, cpu-z8k.c, efi-app-ia32.c, elf32-am33lin.c: Ditto.
	* gen-aout.c, hash.c, hp300hpux.c, init.c, mach-o.c: Ditto.
	* nlm-target.h, nlm.c, som.h, stabs.c, sysdep.h, xsym.h: Ditto.
@
text
@d525 1
a525 1
  bfd_vma (*get32) PARAMS ((const bfd_byte *)) = NULL;
@


1.6.10.1
log
@Merge mainline to intercu branch.
@
text
@d525 1
a525 1
  bfd_vma (*get32) (const void *) = NULL;
@


1.6.10.2
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
a70 1
#define bfd_mach_o_bfd_is_group_section bfd_generic_is_group_section
a71 3
#define bfd_mach_o_section_already_linked \
  _bfd_generic_section_already_linked
#define bfd_mach_o_bfd_copy_private_header_data _bfd_generic_bfd_copy_private_header_data
d585 1
a585 1
  bfdsec->size = section->size;
d1033 1
a1033 1
  bfdsec->size = command->len - 8;
d1091 1
a1091 1
  bfdsec->size = command->len - 8;
d1214 1
a1214 1
      bfdsec->size = cmd->flavours[i].size;
d1321 1
a1321 1
  bfdsec->size = seg->nsyms * 12;
d1340 1
a1340 1
  bfdsec->size = seg->strsize;
d1391 1
a1391 1
  bfdsec->size = seg->filesize;
@


1.6.14.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d525 1
a525 1
  bfd_vma (*get32) (const void *) = NULL;
@


1.6.8.1
log
@	* bfd-in.h (bfd_getb64, bfd_getl64): Replace bfd_byte* with void*.
	(bfd_getb32, bfd_getl32, bfd_getb16, bfd_getl16): Likewise.
	(bfd_getb_signed_64, bfd_getl_signed_64): Likewise.
	(bfd_getb_signed_32, bfd_getl_signed_32): Likewise.
	(bfd_getb_signed_16, bfd_getl_signed_16): Likewise.
	(bfd_putb64, bfd_putl64, bfd_putb32, bfd_putl32): Likewise.
	(bfd_putb16, bfd_putl16, bfd_get_bits, bfd_put_bits): Likewise.
	* libbfd.c: Likewise in function definitions.
	(bfd_put_8): Mask with 0xff rather than casting to char.
	(bfd_putb16, bfd_putl16, bfd_putb32, bfd_putl32): Likewise.
	(bfd_putb64, bfd_putl64, bfd_put_bits): Likewise.
	(H_PUT_64, H_PUT_32, H_PUT_16, H_PUT_8): Remove casts, simplify.
	(H_PUT_S64, H_PUT_S32, H_PUT_S16, H_PUT_S8): Likewise.
	(H_GET_64, H_GET_32, H_GET_16, H_GET_8): Likewise.
	(H_GET_S64, H_GET_S32, H_GET_S16, H_GET_S8): Likewise.
	* libaout.h (H_PUT_64 H_PUT_32, H_PUT_16): Remove casts, simplify.
	(H_PUT_S64, H_PUT_S32, H_PUT_S16): Likewise.
	(H_GET_64, H_GET_32, H_GET_16): Likewise.
	(H_GET_S64, H_GET_S32, H_GET_S16): Likewise.
	* archive.c (do_slurp_coff_armap): Update swap prototype.
	* coff-tic54x.c (tic54x_getl32): Replace bfd_byte* with void*.
	(tic54x_getl_signed_32): Likewise.
	(tic54x_putl32): Likewise.  Mask with 0xff rather than casting to char.
	* mach-o.c (bfd_mach_o_read_header): Update get32 prototype.
	* pdp11.c (bfd_getp32): Make static, replace bfd_byte* with void*.
	(bfd_getp_signed_32, bfd_putp32): Likewise.
	* targets.c (struct bfd_target): Use void* in place of bfd_byte* for
	bfd_getx64, bfd_getx_signed_64, bfd_putx64, bfd_getx32,
	bfd_getx_signed_32, bfd_putx32, bfd_getx16, bfd_getx_signed_16,
	bfd_putx16, bfd_h_getx64, bfd_h_getx_signed_64, bfd_h_putx64,
	bfd_h_getx32, bfd_h_getx_signed_32, bfd_h_putx32, bfd_h_getx16,
	bfd_h_getx_signed_16, bfd_h_putx16.
	* aix386-core.c (NO_GET, NO_GETS, NO_PUT): Update prototypes.
	* hppabsd-core.c: Similarly.  Rename NO_SIGNED_GET to NO_GETS.
	* hpux-core.c: Likewise.
	* irix-core.c: Likewise.
	* netbsd-core.c: Likewise.
	* osf-core.c: Likewise.
	* ptrace-core.c: Likewise.
	* sco5-core.c: Likewise.
	* trad-core.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d525 1
a525 1
  bfd_vma (*get32) (const void *) = NULL;
@


1.6.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.5
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002
@


1.4
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d83 1
a83 1
static long bfd_mach_o_get_symtab
d258 1
a258 1
bfd_mach_o_get_symtab (abfd, alocation)
d278 1
a278 1
	      fprintf (stderr, "bfd_mach_o_get_symtab: unable to load symbols for section %lu\n", i);
@


1.3
log
@	* bfd.c (struct bfd_preserve): New.
	(bfd_preserve_save): New function.
	(bfd_preserve_restore): Ditto.
	(bfd_preserve_finish): Ditto.
	* bfd-in2.h: Regenerate.
	* mach-o.c: Formatting.
	(bfd_mach_o_scan_read_symtab_symbol): Make "value" unsigned.
	(bfd_mach_o_object_p): Use bfd_preserve_save/restore/finish.
	(bfd_mach_o_core_p): Ditto.
	(bfd_mach_o_scan): Pass in mdata.
	* mach-o.h (bfd_mach_o_scan): Update prototype.
	* pef.c: Formatting.
	(bfd_pef_object_p): Use bfd_preserve_save/restore/finish.
	(bfd_pef_xlib_object_p): Ditto.
	(bfd_pef_scan): Pass in mdata.  Move version check to bfd_pef_object_p.
	* pef.h (bfd_pef_scan): Update prototype.
	* xsym.c: Formatting, K&R fixes.
	(bfd_sym_object_p): Use bfd_preserve_save/restore/finish.
	(bfd_sym_scan): New function split out from bfd_sym_object_p.
	* xsym.h (bfd_sym_scan): Declare.
	* elfcode.h (elf_object_p): Use bfd_preserve_save/restore/finish.
	(elf_core_file_p): Likewise.
	* targets.c (_bfd_target_vector): Revert 2002-11-08 change.
@
text
@d73 65
a137 32
static boolean  bfd_mach_o_bfd_copy_private_symbol_data  PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
static boolean  bfd_mach_o_bfd_copy_private_section_data PARAMS ((bfd *, asection *, bfd *, asection *));
static boolean  bfd_mach_o_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
static long     bfd_mach_o_count_symbols             PARAMS ((bfd *));
static long     bfd_mach_o_get_symtab_upper_bound    PARAMS ((bfd *));
static long     bfd_mach_o_get_symtab                PARAMS ((bfd *, asymbol **));
static void     bfd_mach_o_get_symbol_info           PARAMS ((bfd *, asymbol *, symbol_info *));
static void     bfd_mach_o_print_symbol              PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static void     bfd_mach_o_convert_architecture      PARAMS ((bfd_mach_o_cpu_type, bfd_mach_o_cpu_subtype, enum bfd_architecture *, unsigned long *));
static boolean  bfd_mach_o_write_contents            PARAMS ((bfd *));
static int      bfd_mach_o_sizeof_headers            PARAMS ((bfd *, boolean));
static asymbol *   bfd_mach_o_make_empty_symbol      PARAMS ((bfd *));
static int      bfd_mach_o_write_header              PARAMS ((bfd *, bfd_mach_o_header *));
static int      bfd_mach_o_read_header               PARAMS ((bfd *, bfd_mach_o_header *));
static asection *  bfd_mach_o_make_bfd_section       PARAMS ((bfd *, bfd_mach_o_section *));
static int      bfd_mach_o_scan_read_section         PARAMS ((bfd *, bfd_mach_o_section *, bfd_vma));
static int      bfd_mach_o_scan_write_section        PARAMS ((bfd *, bfd_mach_o_section *, bfd_vma));
static int      bfd_mach_o_scan_write_symtab_symbols PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_write_thread         PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_read_dylinker        PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_read_dylib           PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_read_prebound_dylib  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_read_thread          PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_write_symtab         PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_read_dysymtab        PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_read_symtab          PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_read_segment         PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_write_segment        PARAMS ((bfd *, bfd_mach_o_load_command *));
static int      bfd_mach_o_scan_read_command         PARAMS ((bfd *, bfd_mach_o_load_command *));
static void     bfd_mach_o_flatten_sections          PARAMS ((bfd *));
static const char * bfd_mach_o_i386_flavour_string   PARAMS ((unsigned int));
static const char * bfd_mach_o_ppc_flavour_string    PARAMS ((unsigned int));
d165 1
a165 1
boolean
d185 1
a185 1
static boolean
d192 1
a192 1
  return true;
d198 1
a198 1
static boolean
d205 1
a205 1
  return true;
d211 1
a211 1
static boolean
d221 1
a221 1
  return true;
d361 1
a361 1
static boolean
d398 1
a398 1
	      return false;
d402 1
a402 1
	      return false;
d413 1
a413 1
    return false;
d428 1
a428 1
	return false;
d434 1
a434 1
	    return false;
d438 1
a438 1
	    return false;
d445 1
a445 1
	    return false;
d466 1
a466 1
	  return false;
d470 1
a470 1
  return true;
d476 1
a476 1
     boolean b ATTRIBUTE_UNUSED;
d1718 1
a1718 1
boolean
d1727 1
a1727 1
    return false;
d1745 1
a1745 1
  return true;
d2185 1
a2185 1
boolean
d2190 1
a2190 1
  return true;
@


1.3.2.1
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@@


1.3.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d73 32
a104 65
static bfd_boolean bfd_mach_o_bfd_copy_private_symbol_data
  PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
static bfd_boolean bfd_mach_o_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));
static bfd_boolean bfd_mach_o_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
static long bfd_mach_o_count_symbols
  PARAMS ((bfd *));
static long bfd_mach_o_get_symtab_upper_bound
  PARAMS ((bfd *));
static long bfd_mach_o_get_symtab
  PARAMS ((bfd *, asymbol **));
static void bfd_mach_o_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static void bfd_mach_o_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static void bfd_mach_o_convert_architecture
  PARAMS ((bfd_mach_o_cpu_type, bfd_mach_o_cpu_subtype,
	   enum bfd_architecture *, unsigned long *));
static bfd_boolean bfd_mach_o_write_contents
  PARAMS ((bfd *));
static int bfd_mach_o_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static asymbol * bfd_mach_o_make_empty_symbol
  PARAMS ((bfd *));
static int bfd_mach_o_write_header
  PARAMS ((bfd *, bfd_mach_o_header *));
static int bfd_mach_o_read_header
  PARAMS ((bfd *, bfd_mach_o_header *));
static asection * bfd_mach_o_make_bfd_section
  PARAMS ((bfd *, bfd_mach_o_section *));
static int bfd_mach_o_scan_read_section
  PARAMS ((bfd *, bfd_mach_o_section *, bfd_vma));
static int bfd_mach_o_scan_write_section
  PARAMS ((bfd *, bfd_mach_o_section *, bfd_vma));
static int bfd_mach_o_scan_write_symtab_symbols
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_write_thread
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_dylinker
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_dylib
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_prebound_dylib
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_thread
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_write_symtab
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_dysymtab
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_symtab
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_segment
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_write_segment
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static int bfd_mach_o_scan_read_command
  PARAMS ((bfd *, bfd_mach_o_load_command *));
static void bfd_mach_o_flatten_sections
  PARAMS ((bfd *));
static const char * bfd_mach_o_i386_flavour_string
  PARAMS ((unsigned int));
static const char * bfd_mach_o_ppc_flavour_string
  PARAMS ((unsigned int));
d132 1
a132 1
bfd_boolean
d152 1
a152 1
static bfd_boolean
d159 1
a159 1
  return TRUE;
d165 1
a165 1
static bfd_boolean
d172 1
a172 1
  return TRUE;
d178 1
a178 1
static bfd_boolean
d188 1
a188 1
  return TRUE;
d328 1
a328 1
static bfd_boolean
d365 1
a365 1
	      return FALSE;
d369 1
a369 1
	      return FALSE;
d380 1
a380 1
    return FALSE;
d395 1
a395 1
	return FALSE;
d401 1
a401 1
	    return FALSE;
d405 1
a405 1
	    return FALSE;
d412 1
a412 1
	    return FALSE;
d433 1
a433 1
	  return FALSE;
d437 1
a437 1
  return TRUE;
d443 1
a443 1
     bfd_boolean b ATTRIBUTE_UNUSED;
d1685 1
a1685 1
bfd_boolean
d1694 1
a1694 1
    return FALSE;
d1712 1
a1712 1
  return TRUE;
d2152 1
a2152 1
bfd_boolean
d2157 1
a2157 1
  return TRUE;
@


1.3.2.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003
d83 1
a83 1
static long bfd_mach_o_canonicalize_symtab
d258 1
a258 1
bfd_mach_o_canonicalize_symtab (abfd, alocation)
d278 1
a278 1
	      fprintf (stderr, "bfd_mach_o_canonicalize_symtab: unable to load symbols for section %lu\n", i);
@


1.2
log
@	* mach-o.c (bfd_mach_o_scan_read_thread): Don't re-use 'i' when
	looking for an unused section name.
@
text
@d694 1
a694 1
  long value = -1;
d1377 2
a1378 1
	  if (bfd_mach_o_scan_read_section (abfd, &seg->sections[i], segoff) != 0)
d1459 2
a1460 1
  command->type_required = (bfd_h_get_32 (abfd, buf) & BFD_MACH_O_LC_REQ_DYLD) ? 1 : 0;
d1536 3
a1538 1
	  bfd_mach_o_segment_command *seg = &mdata->commands[i].command.segment;
d1543 2
a1544 1
  mdata->sections = bfd_alloc (abfd, mdata->nsects * sizeof (bfd_mach_o_section *));
d1551 1
a1551 1
	  bfd_mach_o_segment_command *seg = &mdata->commands[i].command.segment;
d1553 1
d1588 2
a1589 1
	  && (cmd->flavours[i].flavour == (unsigned long) BFD_MACH_O_i386_THREAD_STATE))
d1618 1
a1618 1
bfd_mach_o_scan (abfd, header)
d1621 1
a1623 1
  bfd_mach_o_data_struct *mdata = NULL;
a1626 5
  mdata = ((bfd_mach_o_data_struct *)
	   bfd_alloc (abfd, sizeof (bfd_mach_o_data_struct)));
  if (mdata == NULL)
    return -1;

d1630 2
a1631 1
  abfd->flags = abfd->xvec->object_flags | (abfd->flags & (BFD_IN_MEMORY | BFD_IO_FUNCS));
d1634 2
a1635 1
  bfd_mach_o_convert_architecture (header->cputype, header->cpusubtype, &cputype, &cpusubtype);
d1719 1
d1722 1
d1724 1
a1724 12
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (! ((header.byteorder == BFD_ENDIAN_BIG)
	 || (header.byteorder == BFD_ENDIAN_LITTLE)))
    {
      fprintf (stderr, "unknown header byte-order value 0x%lx\n", (long) header.byteorder);
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
d1726 2
a1727 7
  if (! (((header.byteorder == BFD_ENDIAN_BIG)
	  && (abfd->xvec->byteorder == BFD_ENDIAN_BIG)
	  && (abfd->xvec->header_byteorder == BFD_ENDIAN_BIG))
	 ||
	 ((header.byteorder == BFD_ENDIAN_LITTLE)
	  && (abfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
	  && (abfd->xvec->header_byteorder == BFD_ENDIAN_LITTLE))))
d1729 21
a1749 3
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
d1751 2
a1752 1
  abfd->tdata.mach_o_data = NULL;
d1754 2
a1755 6
  if (bfd_mach_o_scan (abfd, &header) != 0)
    {
      abfd->tdata.mach_o_data = NULL;
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }
d1757 4
a1760 1
  return abfd->xvec;
d1767 1
d1770 1
a1770 2
  bfd_set_error (bfd_error_wrong_format);

d1772 1
a1772 1
    return NULL;
d1774 2
a1775 2
  if (! ((header.byteorder == BFD_ENDIAN_BIG)
	 || (header.byteorder == BFD_ENDIAN_LITTLE)))
d1777 2
a1778 1
      fprintf (stderr, "unknown header byte-order value 0x%lx\n", (long) header.byteorder);
d1782 7
a1788 8
  if (! (((header.byteorder == BFD_ENDIAN_BIG)
	  && (abfd->xvec->byteorder == BFD_ENDIAN_BIG)
	  && (abfd->xvec->header_byteorder == BFD_ENDIAN_BIG))
	 ||
	 ((header.byteorder == BFD_ENDIAN_LITTLE)
	  && (abfd->xvec->byteorder == BFD_ENDIAN_LITTLE)
	  && (abfd->xvec->header_byteorder == BFD_ENDIAN_LITTLE))))
    return NULL;
d1791 1
a1791 1
    return NULL;
d1793 8
a1800 6
  abfd->tdata.mach_o_data = NULL;
  if (bfd_mach_o_scan (abfd, &header) != 0)
    {
      abfd->tdata.mach_o_data = NULL;
      return NULL;
    }
d1802 1
d1804 8
d1835 1
a1835 1
  mach_o_fat_data_struct *adata;
d1841 1
a1841 1
    return NULL;
d1846 1
a1846 1
    return NULL;
d1851 1
a1851 1
    return NULL;
d1856 1
a1856 1
    return NULL;
d1863 1
a1863 1
	return NULL;
d1874 6
d1887 1
a1887 1
  mach_o_fat_data_struct *adata = (mach_o_fat_data_struct *) archive->tdata.mach_o_fat_data;
d1891 1
d1942 6
a1947 3
int bfd_mach_o_lookup_section
  (bfd *abfd, asection *section,
   bfd_mach_o_load_command **mcommand, bfd_mach_o_section **msection)
d1994 4
a1997 3
bfd_mach_o_lookup_command
  (bfd *abfd, bfd_mach_o_load_command_type type,
   bfd_mach_o_load_command **mcommand)
d2044 1
a2044 1
      return (0xc0000000-0x04000000);
d2096 1
a2096 1
		  unsigned long val =  *((unsigned long *) (buf + size - offset));
d2098 1
d2106 2
a2107 2
		      unsigned long bottom = seg->fileoff + seg->filesize - offset;
		      unsigned long top = seg->fileoff + seg->filesize - 4;
d2109 2
a2194 1

@


1.1
log
@Add support for PEF, Mach-O, xSYM
@
text
@d18 1
a18 1
   along with this program; if not, write to the Free Software 
d198 1
a198 1
  
d260 1
a260 1
  
d327 1
a327 1
  
d478 1
a478 1
      
d507 1
a507 1
      header->byteorder = BFD_ENDIAN_LITTLE; 
d516 1
a516 1
      
d549 1
a549 1
  
d575 1
a575 1
  
d620 1
a620 1
  
d644 1
a644 1
#if 0 
d657 1
a657 1
      
d672 1
a672 1
	  fprintf (stderr, "bfd_mach_o_scan_write_symtab_symbols: unable to write %d bytes at %lu\n", 
d674 1
a674 1
	  return -1; 
d719 1
a719 1
      return -1; 
d770 1
a770 1
			   "symbol \"%s\" specified invalid section %d (max %lu): setting to undefined\n", 
d778 1
a778 1
		   "symbol \"%s\" is unsupported 'indirect' reference: setting to undefined\n", 
d784 1
a784 1
		   "symbol \"%s\" specified invalid type field 0x%x: setting to undefined\n", 
d825 1
a825 1
      return -1; 
d831 1
a831 1
int 
d845 1
a845 1
      return -1; 
d847 1
a847 1
  
d858 1
a858 1
  
d875 1
a875 1
  
d884 1
a884 1
  
d997 1
a997 1
  
d1055 1
a1055 1
  
d1096 1
a1096 1
  
d1149 2
a1150 2
      unsigned int i = 0;
    
d1163 1
a1163 1
    
d1171 2
a1172 2
	  sprintf (sname, "%s.%s.%u", prefix, flavourstr, i);
	  if (bfd_get_section_by_name (abfd, sname) == NULL) {
d1174 1
a1174 2
	  }
	  i++;
d1178 1
a1178 1
  
d1192 1
a1192 1
static int 
d1210 1
a1210 1
  
d1217 1
a1217 1
static int 
d1253 1
a1253 1
static int 
d1269 1
a1269 1
  
d1285 1
a1285 1
  
d1304 1
a1304 1
  
d1329 1
a1329 1
 
d1367 1
a1367 1
      seg->sections = 
d1372 1
a1372 1
    
d1379 1
a1379 1
	}    
d1393 1
a1393 1
  
d1414 1
a1414 1
    
d1527 1
a1527 1
  
d1581 1
a1581 1
      if ((mdata->header.cputype == BFD_MACH_O_CPU_TYPE_I386) 
d1593 1
a1593 1
      else if ((mdata->header.cputype == BFD_MACH_O_CPU_TYPE_POWERPC) 
d1620 1
a1620 1
  mdata = ((bfd_mach_o_data_struct *) 
d1628 1
a1628 1
  abfd->flags = abfd->xvec->object_flags | (abfd->flags & (BFD_IN_MEMORY | BFD_IO_FUNCS));  
d1640 1
a1640 1
  
d1643 1
a1643 1
      mdata->commands = 
d1648 1
a1648 1
    
d1663 1
a1663 1
	} 
d1687 1
a1687 1
  mdata = ((bfd_mach_o_data_struct *) 
d1731 1
a1731 1
  if (! (((header.byteorder == BFD_ENDIAN_BIG) 
d1735 2
a1736 2
	 ((header.byteorder == BFD_ENDIAN_LITTLE) 
	  && (abfd->xvec->byteorder == BFD_ENDIAN_LITTLE) 
d1751 1
a1751 1
  
d1773 1
a1773 1
  if (! (((header.byteorder == BFD_ENDIAN_BIG) 
d1777 2
a1778 2
	 ((header.byteorder == BFD_ENDIAN_LITTLE) 
	  && (abfd->xvec->byteorder == BFD_ENDIAN_LITTLE) 
d1791 1
a1791 1
  
d1824 1
a1824 1
  adata = (mach_o_fat_data_struct *) 
d1828 1
a1828 1
  
d1834 1
a1834 1
  adata->archentries = (mach_o_fat_archentry *) 
d1883 1
a1883 1
	  return NULL; 
d1887 1
a1887 1
  
d1916 2
a1917 2
int bfd_mach_o_lookup_section 
  (bfd *abfd, asection *section, 
d1938 1
a1938 1
    
d1958 1
a1958 1
  
d1965 1
a1965 1
bfd_mach_o_lookup_command 
d2060 1
a2060 1
	
d2063 1
a2063 1
      
@

