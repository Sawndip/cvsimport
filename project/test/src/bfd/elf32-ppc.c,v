head	1.332;
access;
symbols
	sid-snapshot-20180601:1.332
	sid-snapshot-20180501:1.332
	sid-snapshot-20180401:1.332
	sid-snapshot-20180301:1.332
	sid-snapshot-20180201:1.332
	sid-snapshot-20180101:1.332
	sid-snapshot-20171201:1.332
	sid-snapshot-20171101:1.332
	sid-snapshot-20171001:1.332
	sid-snapshot-20170901:1.332
	sid-snapshot-20170801:1.332
	sid-snapshot-20170701:1.332
	sid-snapshot-20170601:1.332
	sid-snapshot-20170501:1.332
	sid-snapshot-20170401:1.332
	sid-snapshot-20170301:1.332
	sid-snapshot-20170201:1.332
	sid-snapshot-20170101:1.332
	sid-snapshot-20161201:1.332
	sid-snapshot-20161101:1.332
	sid-snapshot-20160901:1.332
	sid-snapshot-20160801:1.332
	sid-snapshot-20160701:1.332
	sid-snapshot-20160601:1.332
	sid-snapshot-20160501:1.332
	sid-snapshot-20160401:1.332
	sid-snapshot-20160301:1.332
	sid-snapshot-20160201:1.332
	sid-snapshot-20160101:1.332
	sid-snapshot-20151201:1.332
	sid-snapshot-20151101:1.332
	sid-snapshot-20151001:1.332
	sid-snapshot-20150901:1.332
	sid-snapshot-20150801:1.332
	sid-snapshot-20150701:1.332
	sid-snapshot-20150601:1.332
	sid-snapshot-20150501:1.332
	sid-snapshot-20150401:1.332
	sid-snapshot-20150301:1.332
	sid-snapshot-20150201:1.332
	sid-snapshot-20150101:1.332
	sid-snapshot-20141201:1.332
	sid-snapshot-20141101:1.332
	sid-snapshot-20141001:1.332
	sid-snapshot-20140901:1.332
	sid-snapshot-20140801:1.332
	sid-snapshot-20140701:1.332
	sid-snapshot-20140601:1.332
	sid-snapshot-20140501:1.332
	sid-snapshot-20140401:1.332
	sid-snapshot-20140301:1.332
	sid-snapshot-20140201:1.332
	sid-snapshot-20140101:1.332
	sid-snapshot-20131201:1.332
	sid-snapshot-20131101:1.332
	sid-snapshot-20131001:1.332
	binutils-2_24-branch:1.332.0.2
	binutils-2_24-branchpoint:1.332
	binutils-2_21_1:1.290.2.4
	sid-snapshot-20130901:1.332
	gdb_7_6_1-2013-08-30-release:1.327
	sid-snapshot-20130801:1.332
	sid-snapshot-20130701:1.332
	sid-snapshot-20130601:1.332
	sid-snapshot-20130501:1.332
	gdb_7_6-2013-04-26-release:1.327
	sid-snapshot-20130401:1.331
	binutils-2_23_2:1.318.4.3
	gdb_7_6-branch:1.327.0.2
	gdb_7_6-2013-03-12-branchpoint:1.327
	sid-snapshot-20130301:1.326
	sid-snapshot-20130201:1.323
	sid-snapshot-20130101:1.322
	sid-snapshot-20121201:1.322
	gdb_7_5_1-2012-11-29-release:1.318
	binutils-2_23_1:1.318.4.1
	sid-snapshot-20121101:1.322
	binutils-2_23:1.318.4.1
	sid-snapshot-20121001:1.320
	sid-snapshot-20120901:1.320
	gdb_7_5-2012-08-17-release:1.318
	sid-snapshot-20120801:1.318
	binutils-2_23-branch:1.318.0.4
	binutils-2_23-branchpoint:1.318
	gdb_7_5-branch:1.318.0.2
	gdb_7_5-2012-07-18-branchpoint:1.318
	sid-snapshot-20120701:1.318
	sid-snapshot-20120601:1.317
	sid-snapshot-20120501:1.309
	binutils-2_22_branch:1.302.2.1.0.2
	gdb_7_4_1-2012-04-26-release:1.306
	sid-snapshot-20120401:1.308
	sid-snapshot-20120301:1.307
	sid-snapshot-20120201:1.307
	gdb_7_4-2012-01-24-release:1.306
	sid-snapshot-20120101:1.306
	gdb_7_4-branch:1.306.0.2
	gdb_7_4-2011-12-13-branchpoint:1.306
	sid-snapshot-20111201:1.305
	binutils-2_22:1.302.2.1
	sid-snapshot-20111101:1.303
	sid-snapshot-20111001:1.302
	binutils-2_22-branch:1.302.0.2
	binutils-2_22-branchpoint:1.302
	gdb_7_3_1-2011-09-04-release:1.292
	sid-snapshot-20110901:1.302
	sid-snapshot-20110801:1.299
	gdb_7_3-2011-07-26-release:1.292
	sid-snapshot-20110701:1.299
	sid-snapshot-20110601:1.296
	sid-snapshot-20110501:1.293
	gdb_7_3-branch:1.292.0.2
	gdb_7_3-2011-04-01-branchpoint:1.292
	sid-snapshot-20110401:1.292
	sid-snapshot-20110301:1.291
	sid-snapshot-20110201:1.291
	sid-snapshot-20110101:1.290
	binutils-2_21:1.290
	sid-snapshot-20101201:1.290
	binutils-2_21-branch:1.290.0.2
	binutils-2_21-branchpoint:1.290
	sid-snapshot-20101101:1.290
	sid-snapshot-20101001:1.288
	binutils-2_20_1:1.267.2.6
	gdb_7_2-2010-09-02-release:1.285
	sid-snapshot-20100901:1.287
	sid-snapshot-20100801:1.285
	gdb_7_2-branch:1.285.0.2
	gdb_7_2-2010-07-07-branchpoint:1.285
	sid-snapshot-20100701:1.283
	sid-snapshot-20100601:1.282
	sid-snapshot-20100501:1.281
	sid-snapshot-20100401:1.281
	gdb_7_1-2010-03-18-release:1.278
	sid-snapshot-20100301:1.279
	gdb_7_1-branch:1.278.0.2
	gdb_7_1-2010-02-18-branchpoint:1.278
	sid-snapshot-20100201:1.274
	sid-snapshot-20100101:1.273
	gdb_7_0_1-2009-12-22-release:1.267
	sid-snapshot-20091201:1.270
	sid-snapshot-20091101:1.269
	binutils-2_20:1.267.2.2
	gdb_7_0-2009-10-06-release:1.267
	sid-snapshot-20091001:1.269
	gdb_7_0-branch:1.267.0.4
	gdb_7_0-2009-09-16-branchpoint:1.267
	arc-sim-20090309:1.232
	binutils-arc-20081103-branch:1.247.0.6
	binutils-arc-20081103-branchpoint:1.247
	binutils-2_20-branch:1.267.0.2
	binutils-2_20-branchpoint:1.267
	sid-snapshot-20090901:1.267
	sid-snapshot-20090801:1.261
	msnyder-checkpoint-072509-branch:1.260.0.2
	msnyder-checkpoint-072509-branchpoint:1.260
	sid-snapshot-20090701:1.259
	dje-cgen-play1-branch:1.259.0.2
	dje-cgen-play1-branchpoint:1.259
	sid-snapshot-20090601:1.254
	sid-snapshot-20090501:1.253
	sid-snapshot-20090401:1.253
	arc-20081103-branch:1.247.0.4
	arc-20081103-branchpoint:1.247
	arc-insight_6_8-branch:1.232.0.6
	arc-insight_6_8-branchpoint:1.232
	insight_6_8-branch:1.232.0.4
	insight_6_8-branchpoint:1.232
	sid-snapshot-20090301:1.251
	binutils-2_19_1:1.243.2.4
	sid-snapshot-20090201:1.250
	sid-snapshot-20090101:1.249
	reverse-20081226-branch:1.249.0.2
	reverse-20081226-branchpoint:1.249
	sid-snapshot-20081201:1.249
	multiprocess-20081120-branch:1.247.0.2
	multiprocess-20081120-branchpoint:1.247
	sid-snapshot-20081101:1.247
	binutils-2_19:1.243.2.3
	sid-snapshot-20081001:1.246
	reverse-20080930-branch:1.246.0.2
	reverse-20080930-branchpoint:1.246
	binutils-2_19-branch:1.243.0.2
	binutils-2_19-branchpoint:1.243
	sid-snapshot-20080901:1.243
	sid-snapshot-20080801:1.241
	reverse-20080717-branch:1.240.0.2
	reverse-20080717-branchpoint:1.240
	sid-snapshot-20080701:1.239
	msnyder-reverse-20080609-branch:1.238.0.2
	msnyder-reverse-20080609-branchpoint:1.238
	drow-reverse-20070409-branch:1.212.0.2
	drow-reverse-20070409-branchpoint:1.212
	sid-snapshot-20080601:1.238
	sid-snapshot-20080501:1.235
	sid-snapshot-20080403:1.235
	sid-snapshot-20080401:1.235
	gdb_6_8-2008-03-27-release:1.232
	sid-snapshot-20080301:1.233
	gdb_6_8-branch:1.232.0.2
	gdb_6_8-2008-02-26-branchpoint:1.232
	sid-snapshot-20080201:1.225
	sid-snapshot-20080101:1.224
	sid-snapshot-20071201:1.224
	sid-snapshot-20071101:1.222
	gdb_6_7_1-2007-10-29-release:1.220
	gdb_6_7-2007-10-10-release:1.220
	sid-snapshot-20071001:1.221
	gdb_6_7-branch:1.220.0.4
	gdb_6_7-2007-09-07-branchpoint:1.220
	binutils-2_18:1.220
	binutils-2_18-branch:1.220.0.2
	binutils-2_18-branchpoint:1.220
	insight_6_6-20070208-release:1.206
	binutils-csl-coldfire-4_1-32:1.196.2.1
	binutils-csl-sourcerygxx-4_1-32:1.196.2.1
	gdb_6_6-2006-12-18-release:1.206
	binutils-csl-innovasic-fido-3_4_4-33:1.196.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.136.2.3
	binutils-csl-coldfire-4_1-30:1.196.2.1
	binutils-csl-sourcerygxx-4_1-30:1.196.2.1
	binutils-csl-coldfire-4_1-28:1.196.2.1
	binutils-csl-sourcerygxx-4_1-29:1.196.2.1
	binutils-csl-sourcerygxx-4_1-28:1.196.2.1
	gdb_6_6-branch:1.206.0.2
	gdb_6_6-2006-11-15-branchpoint:1.206
	binutils-csl-arm-2006q3-27:1.196.2.1
	binutils-csl-sourcerygxx-4_1-27:1.196.2.1
	binutils-csl-arm-2006q3-26:1.196.2.1
	binutils-csl-sourcerygxx-4_1-26:1.196.2.1
	binutils-csl-sourcerygxx-4_1-25:1.196.2.1
	binutils-csl-sourcerygxx-4_1-24:1.196.2.1
	binutils-csl-sourcerygxx-4_1-23:1.196.2.1
	insight_6_5-20061003-release:1.197
	gdb-csl-symbian-6_4_50_20060226-12:1.188
	binutils-csl-sourcerygxx-4_1-21:1.196.2.1
	binutils-csl-arm-2006q3-21:1.196.2.1
	binutils-csl-sourcerygxx-4_1-22:1.196.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.196.2.1
	binutils-csl-sourcerygxx-4_1-20:1.196.2.1
	binutils-csl-arm-2006q3-19:1.196.2.1
	binutils-csl-sourcerygxx-4_1-19:1.196.2.1
	binutils-csl-sourcerygxx-4_1-18:1.196.2.1
	binutils-csl-renesas-4_1-9:1.196.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.183
	binutils-csl-sourcerygxx-3_4_4-25:1.136.2.3
	nickrob-async-20060828-mergepoint:1.202
	gdb-csl-symbian-6_4_50_20060226-11:1.188
	binutils-csl-renesas-4_1-8:1.196
	binutils-csl-renesas-4_1-7:1.196
	binutils-csl-renesas-4_1-6:1.196
	gdb-csl-sourcerygxx-4_1-17:1.188
	binutils-csl-sourcerygxx-4_1-17:1.196
	gdb-csl-20060226-branch-local-2:1.188
	gdb-csl-sourcerygxx-4_1-14:1.188
	binutils-csl-sourcerygxx-4_1-14:1.196
	binutils-csl-sourcerygxx-4_1-15:1.196
	gdb-csl-sourcerygxx-4_1-13:1.188
	binutils-csl-sourcerygxx-4_1-13:1.196
	binutils-2_17:1.196.6.1
	gdb-csl-sourcerygxx-4_1-12:1.188
	binutils-csl-sourcerygxx-4_1-12:1.196
	gdb-csl-sourcerygxx-3_4_4-21:1.188
	binutils-csl-sourcerygxx-3_4_4-21:1.196
	gdb_6_5-20060621-release:1.197
	binutils-csl-wrs-linux-3_4_4-24:1.136.2.2
	binutils-csl-wrs-linux-3_4_4-23:1.136.2.2
	gdb-csl-sourcerygxx-4_1-9:1.188
	binutils-csl-sourcerygxx-4_1-9:1.196
	gdb-csl-sourcerygxx-4_1-8:1.188
	binutils-csl-sourcerygxx-4_1-8:1.196
	gdb-csl-sourcerygxx-4_1-7:1.188
	binutils-csl-sourcerygxx-4_1-7:1.196
	gdb-csl-arm-2006q1-6:1.188
	binutils-csl-arm-2006q1-6:1.196
	gdb-csl-sourcerygxx-4_1-6:1.188
	binutils-csl-sourcerygxx-4_1-6:1.196
	binutils-csl-wrs-linux-3_4_4-22:1.136.2.2
	gdb-csl-symbian-6_4_50_20060226-10:1.188
	gdb-csl-symbian-6_4_50_20060226-9:1.188
	gdb-csl-symbian-6_4_50_20060226-8:1.188
	gdb-csl-coldfire-4_1-11:1.188
	binutils-csl-coldfire-4_1-11:1.196
	gdb-csl-sourcerygxx-3_4_4-19:1.188
	binutils-csl-sourcerygxx-3_4_4-19:1.196
	gdb-csl-coldfire-4_1-10:1.188
	gdb_6_5-branch:1.197.0.4
	gdb_6_5-2006-05-14-branchpoint:1.197
	binutils-csl-coldfire-4_1-10:1.196
	gdb-csl-sourcerygxx-4_1-5:1.188
	binutils-csl-sourcerygxx-4_1-5:1.196
	nickrob-async-20060513-branch:1.197.0.2
	nickrob-async-20060513-branchpoint:1.197
	gdb-csl-sourcerygxx-4_1-4:1.188
	binutils-csl-sourcerygxx-4_1-4:1.196
	msnyder-reverse-20060502-branch:1.196.0.10
	msnyder-reverse-20060502-branchpoint:1.196
	binutils-csl-wrs-linux-3_4_4-21:1.136.2.2
	gdb-csl-morpho-4_1-4:1.188
	binutils-csl-morpho-4_1-4:1.196
	gdb-csl-sourcerygxx-3_4_4-17:1.188
	binutils-csl-sourcerygxx-3_4_4-17:1.196
	binutils-csl-wrs-linux-3_4_4-20:1.136.2.2
	readline_5_1-import-branch:1.196.0.8
	readline_5_1-import-branchpoint:1.196
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.188
	binutils-2_17-branch:1.196.0.6
	binutils-2_17-branchpoint:1.196
	gdb-csl-symbian-20060226-branch:1.188.0.4
	gdb-csl-symbian-20060226-branchpoint:1.188
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.188
	msnyder-reverse-20060331-branch:1.196.0.4
	msnyder-reverse-20060331-branchpoint:1.196
	binutils-csl-2_17-branch:1.196.0.2
	binutils-csl-2_17-branchpoint:1.196
	gdb-csl-available-20060303-branch:1.192.0.2
	gdb-csl-available-20060303-branchpoint:1.192
	gdb-csl-20060226-branch:1.188.0.2
	gdb-csl-20060226-branchpoint:1.188
	gdb_6_4-20051202-release:1.183
	msnyder-fork-checkpoint-branch:1.183.0.6
	msnyder-fork-checkpoint-branchpoint:1.183
	gdb-csl-gxxpro-6_3-branch:1.183.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.183
	gdb_6_4-branch:1.183.0.2
	gdb_6_4-2005-11-01-branchpoint:1.183
	gdb-csl-arm-20051020-branch:1.181.0.2
	gdb-csl-arm-20051020-branchpoint:1.181
	binutils-csl-gxxpro-3_4-branch:1.136.2.3.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.136.2.3
	binutils-2_16_1:1.136.2.3
	msnyder-tracepoint-checkpoint-branch:1.163.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.163
	gdb-csl-arm-20050325-2005-q1b:1.147
	binutils-csl-arm-2005q1b:1.136.2.2
	binutils-2_16:1.136.2.3
	gdb-csl-arm-20050325-2005-q1a:1.147
	binutils-csl-arm-2005q1a:1.136.2.2
	csl-arm-20050325-branch:1.147.0.2
	csl-arm-20050325-branchpoint:1.147
	binutils-csl-arm-2005q1-branch:1.136.2.2.0.2
	binutils-csl-arm-2005q1-branchpoint:1.136.2.2
	binutils-2_16-branch:1.136.0.2
	binutils-2_16-branchpoint:1.136
	csl-arm-2004-q3d:1.129
	gdb_6_3-20041109-release:1.128
	gdb_6_3-branch:1.128.0.2
	gdb_6_3-20041019-branchpoint:1.128
	csl-arm-2004-q3:1.127
	drow_intercu-merge-20040921:1.126
	drow_intercu-merge-20040915:1.124
	jimb-gdb_6_2-e500-branch:1.123.0.6
	jimb-gdb_6_2-e500-branchpoint:1.123
	gdb_6_2-20040730-release:1.123
	gdb_6_2-branch:1.123.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.123
	gdb_6_1_1-20040616-release:1.111
	binutils-2_15:1.110.6.2
	binutils-2_15-branchpoint:1.110
	csl-arm-2004-q1a:1.118
	csl-arm-2004-q1:1.117
	gdb_6_1-2004-04-05-release:1.111
	drow_intercu-merge-20040402:1.117
	drow_intercu-merge-20040327:1.116
	ezannoni_pie-20040323-branch:1.114.0.2
	ezannoni_pie-20040323-branchpoint:1.114
	cagney_tramp-20040321-mergepoint:1.113
	cagney_tramp-20040309-branch:1.111.0.6
	cagney_tramp-20040309-branchpoint:1.111
	gdb_6_1-branch:1.111.0.4
	gdb_6_1-2004-03-01-gmt-branchpoint:1.111
	drow_intercu-20040221-branch:1.111.0.2
	drow_intercu-20040221-branchpoint:1.111
	binutils-2_15-branch:1.110.0.6
	cagney_bfdfile-20040213-branch:1.110.0.4
	cagney_bfdfile-20040213-branchpoint:1.110
	drow-cplus-merge-20040208:1.110
	carlton_dictionary-20040126-merge:1.110
	cagney_bigcore-20040122-branch:1.110.0.2
	cagney_bigcore-20040122-branchpoint:1.110
	drow-cplus-merge-20040113:1.110
	csl-arm-2003-q4:1.110
	drow-cplus-merge-20031224:1.110
	drow-cplus-merge-20031220:1.110
	carlton_dictionary-20031215-merge:1.110
	drow-cplus-merge-20031214:1.110
	carlton-dictionary-20031111-merge:1.106
	gdb_6_0-2003-10-04-release:1.83
	kettenis_sparc-20030918-branch:1.100.0.6
	kettenis_sparc-20030918-branchpoint:1.100
	carlton_dictionary-20030917-merge:1.100
	ezannoni_pie-20030916-branchpoint:1.100
	ezannoni_pie-20030916-branch:1.100.0.4
	cagney_x86i386-20030821-branch:1.100.0.2
	cagney_x86i386-20030821-branchpoint:1.100
	carlton_dictionary-20030805-merge:1.97
	carlton_dictionary-20030627-merge:1.88
	gdb_6_0-branch:1.83.0.6
	gdb_6_0-2003-06-23-branchpoint:1.83
	jimb-ppc64-linux-20030613-branch:1.83.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.83
	binutils-2_14:1.75.2.2
	cagney_convert-20030606-branch:1.83.0.2
	cagney_convert-20030606-branchpoint:1.83
	cagney_writestrings-20030508-branch:1.78.0.4
	cagney_writestrings-20030508-branchpoint:1.78
	jimb-ppc64-linux-20030528-branch:1.81.0.4
	jimb-ppc64-linux-20030528-branchpoint:1.81
	carlton_dictionary-20030523-merge:1.81
	cagney_fileio-20030521-branch:1.81.0.2
	cagney_fileio-20030521-branchpoint:1.81
	kettenis_i386newframe-20030517-mergepoint:1.81
	jimb-ppc64-linux-20030509-branch:1.78.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.78
	kettenis_i386newframe-20030504-mergepoint:1.76
	carlton_dictionary-20030430-merge:1.75
	binutils-2_14-branch:1.75.0.2
	binutils-2_14-branchpoint:1.75
	kettenis_i386newframe-20030419-branch:1.74.0.6
	kettenis_i386newframe-20030419-branchpoint:1.74
	carlton_dictionary-20030416-merge:1.74
	cagney_frameaddr-20030409-mergepoint:1.74
	kettenis_i386newframe-20030406-branch:1.74.0.4
	kettenis_i386newframe-20030406-branchpoint:1.74
	cagney_frameaddr-20030403-branchpoint:1.74
	cagney_frameaddr-20030403-branch:1.74.0.2
	cagney_framebase-20030330-mergepoint:1.72
	cagney_framebase-20030326-branch:1.72.0.6
	cagney_framebase-20030326-branchpoint:1.72
	cagney_lazyid-20030317-branch:1.72.0.4
	cagney_lazyid-20030317-branchpoint:1.72
	kettenis-i386newframe-20030316-mergepoint:1.72
	offbyone-20030313-branch:1.72.0.2
	offbyone-20030313-branchpoint:1.72
	kettenis-i386newframe-20030308-branch:1.71.0.2
	kettenis-i386newframe-20030308-branchpoint:1.71
	carlton_dictionary-20030305-merge:1.68
	cagney_offbyone-20030303-branch:1.68.0.2
	cagney_offbyone-20030303-branchpoint:1.68
	carlton_dictionary-20030207-merge:1.63
	interps-20030202-branch:1.63.0.2
	interps-20030202-branchpoint:1.63
	cagney-unwind-20030108-branch:1.60.0.2
	cagney-unwind-20030108-branchpoint:1.60
	binutils-2_13_2_1:1.48.2.1
	binutils-2_13_2:1.48.2.1
	carlton_dictionary-20021223-merge:1.60
	gdb_5_3-2002-12-12-release:1.50
	carlton_dictionary-20021115-merge:1.54
	binutils-2_13_1:1.48.2.1
	kseitz_interps-20021105-merge:1.53
	kseitz_interps-20021103-merge:1.53
	drow-cplus-merge-20021020:1.53
	drow-cplus-merge-20021025:1.53
	carlton_dictionary-20021025-merge:1.53
	carlton_dictionary-20021011-merge:1.52
	drow-cplus-branch:1.52.0.2
	drow-cplus-branchpoint:1.52
	kseitz_interps-20020930-merge:1.52
	carlton_dictionary-20020927-merge:1.52
	carlton_dictionary-branch:1.51.0.2
	carlton_dictionary-20020920-branchpoint:1.51
	sid-20020905-branchpoint:1.50
	sid-20020905-branch:1.50.0.8
	gdb_5_3-branch:1.50.0.6
	gdb_5_3-2002-09-04-branchpoint:1.50
	kseitz_interps-20020829-merge:1.50
	cagney_sysregs-20020825-branch:1.50.0.4
	cagney_sysregs-20020825-branchpoint:1.50
	readline_4_3-import-branch:1.50.0.2
	readline_4_3-import-branchpoint:1.50
	binutils-2_13:1.48
	gdb_5_2_1-2002-07-23-release:1.40
	binutils-2_13-branchpoint:1.48
	binutils-2_13-branch:1.48.0.2
	kseitz_interps-20020528-branch:1.44.0.4
	kseitz_interps-20020528-branchpoint:1.44
	cagney_regbuf-20020515-branch:1.44.0.2
	cagney_regbuf-20020515-branchpoint:1.44
	binutils-2_12_1:1.39.2.3
	jimb-macro-020506-branch:1.42.0.2
	jimb-macro-020506-branchpoint:1.42
	gdb_5_2-2002-04-29-release:1.40
	binutils-2_12:1.39.2.1
	gdb_5_2-branch:1.40.0.2
	gdb_5_2-2002-03-03-branchpoint:1.40
	binutils-2_12-branch:1.39.0.2
	binutils-2_12-branchpoint:1.39
	gdb_5_1_1-2002-01-24-release:1.22
	gdb_5_1_0_1-2002-01-03-release:1.22
	cygnus_cvs_20020108_pre:1.39
	gdb_5_1_0_1-2002-01-03-branch:1.22.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.22
	gdb_5_1-2001-11-21-release:1.22
	gdb_s390-2001-09-26-branch:1.22.0.4
	gdb_s390-2001-09-26-branchpoint:1.22
	gdb_5_1-2001-07-29-branch:1.22.0.2
	gdb_5_1-2001-07-29-branchpoint:1.22
	binutils-2_11_2:1.21.2.1
	binutils-2_11_1:1.21.2.1
	binutils-2_11:1.21
	x86_64versiong3:1.21
	binutils-2_11-branch:1.21.0.2
	insight-precleanup-2001-01-01:1.20
	binutils-2_10_1:1.9.2.3
	binutils-2_10:1.9
	gdb-premipsmulti-2000-06-06-branch:1.14.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.14
	gdb_5_0-2000-05-19-release:1.9
	gdb_4_18_2-2000-05-18-release:1.9
	gdb_4_95_1-2000-05-11-snapshot:1.9
	gdb_4_95_0-2000-04-27-snapshot:1.9
	gdb_5_0-2000-04-10-branch:1.9.0.4
	gdb_5_0-2000-04-10-branchpoint:1.9
	binutils-2_10-branch:1.9.0.2
	binutils-2_10-branchpoint:1.9
	binutils_latest_snapshot:1.332
	repo-unification-2000-02-06:1.7
	binu_ss_19990721:1.6
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.332
date	2013.04.06.06.44.45;	author amodra;	state Exp;
branches;
next	1.331;

1.331
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.330;

1.330
date	2013.03.28.07.07.25;	author amodra;	state Exp;
branches;
next	1.329;

1.329
date	2013.03.27.13.37.50;	author amodra;	state Exp;
branches;
next	1.328;

1.328
date	2013.03.27.13.25.48;	author amodra;	state Exp;
branches;
next	1.327;

1.327
date	2013.03.04.12.12.11;	author amodra;	state Exp;
branches;
next	1.326;

1.326
date	2013.02.21.03.02.29;	author amodra;	state Exp;
branches;
next	1.325;

1.325
date	2013.02.21.02.29.09;	author amodra;	state Exp;
branches;
next	1.324;

1.324
date	2013.02.04.18.26.34;	author sergiodj;	state Exp;
branches;
next	1.323;

1.323
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.322;

1.322
date	2012.10.29.09.51.10;	author amodra;	state Exp;
branches;
next	1.321;

1.321
date	2012.10.26.03.40.36;	author amodra;	state Exp;
branches;
next	1.320;

1.320
date	2012.08.28.20.17.55;	author macro;	state Exp;
branches;
next	1.319;

1.319
date	2012.08.17.02.39.26;	author amodra;	state Exp;
branches;
next	1.318;

1.318
date	2012.06.29.14.45.59;	author amodra;	state Exp;
branches
	1.318.4.1;
next	1.317;

1.317
date	2012.05.25.01.12.20;	author amodra;	state Exp;
branches;
next	1.316;

1.316
date	2012.05.22.14.58.15;	author amodra;	state Exp;
branches;
next	1.315;

1.315
date	2012.05.19.06.58.45;	author amodra;	state Exp;
branches;
next	1.314;

1.314
date	2012.05.17.02.43.34;	author amodra;	state Exp;
branches;
next	1.313;

1.313
date	2012.05.17.02.24.49;	author amodra;	state Exp;
branches;
next	1.312;

1.312
date	2012.05.16.16.38.29;	author nickc;	state Exp;
branches;
next	1.311;

1.311
date	2012.05.14.19.45.17;	author jwlemke;	state Exp;
branches;
next	1.310;

1.310
date	2012.05.07.03.27.50;	author macro;	state Exp;
branches;
next	1.309;

1.309
date	2012.04.24.05.12.34;	author amodra;	state Exp;
branches;
next	1.308;

1.308
date	2012.03.13.06.04.34;	author amodra;	state Exp;
branches;
next	1.307;

1.307
date	2012.01.16.22.30.19;	author amodra;	state Exp;
branches;
next	1.306;

1.306
date	2011.12.03.00.55.49;	author amodra;	state Exp;
branches;
next	1.305;

1.305
date	2011.11.21.13.18.07;	author amodra;	state Exp;
branches;
next	1.304;

1.304
date	2011.11.15.11.33.57;	author amodra;	state Exp;
branches;
next	1.303;

1.303
date	2011.10.19.07.17.14;	author amodra;	state Exp;
branches;
next	1.302;

1.302
date	2011.08.14.09.17.17;	author amodra;	state Exp;
branches
	1.302.2.1;
next	1.301;

1.301
date	2011.08.14.08.11.54;	author amodra;	state Exp;
branches;
next	1.300;

1.300
date	2011.08.05.02.24.08;	author amodra;	state Exp;
branches;
next	1.299;

1.299
date	2011.07.01.07.49.07;	author amodra;	state Exp;
branches;
next	1.298;

1.298
date	2011.06.13.00.59.10;	author amodra;	state Exp;
branches;
next	1.297;

1.297
date	2011.06.02.13.43.14;	author nickc;	state Exp;
branches;
next	1.296;

1.296
date	2011.05.23.06.22.50;	author amodra;	state Exp;
branches;
next	1.295;

1.295
date	2011.05.23.06.14.21;	author amodra;	state Exp;
branches;
next	1.294;

1.294
date	2011.05.10.06.13.07;	author jkratoch;	state Exp;
branches;
next	1.293;

1.293
date	2011.04.11.08.13.17;	author nickc;	state Exp;
branches;
next	1.292;

1.292
date	2011.03.23.15.25.02;	author amodra;	state Exp;
branches;
next	1.291;

1.291
date	2011.01.29.00.12.52;	author jsm28;	state Exp;
branches;
next	1.290;

1.290
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches
	1.290.2.1;
next	1.289;

1.289
date	2010.10.04.14.13.09;	author bernds;	state Exp;
branches;
next	1.288;

1.288
date	2010.09.24.12.14.24;	author tschwinge;	state Exp;
branches;
next	1.287;

1.287
date	2010.08.25.14.53.43;	author hjl;	state Exp;
branches;
next	1.286;

1.286
date	2010.08.18.12.24.06;	author palves;	state Exp;
branches;
next	1.285;

1.285
date	2010.07.06.09.29.46;	author amodra;	state Exp;
branches;
next	1.284;

1.284
date	2010.07.05.13.34.27;	author amodra;	state Exp;
branches;
next	1.283;

1.283
date	2010.06.27.04.07.51;	author amodra;	state Exp;
branches;
next	1.282;

1.282
date	2010.05.18.03.31.05;	author hjl;	state Exp;
branches;
next	1.281;

1.281
date	2010.04.01.10.02.27;	author nathan;	state Exp;
branches;
next	1.280;

1.280
date	2010.03.26.08.34.24;	author amodra;	state Exp;
branches;
next	1.279;

1.279
date	2010.02.19.05.07.49;	author hjl;	state Exp;
branches;
next	1.278;

1.278
date	2010.02.08.13.16.24;	author amodra;	state Exp;
branches;
next	1.277;

1.277
date	2010.02.08.07.09.39;	author nathan;	state Exp;
branches;
next	1.276;

1.276
date	2010.02.08.00.48.27;	author amodra;	state Exp;
branches;
next	1.275;

1.275
date	2010.02.04.09.16.39;	author nickc;	state Exp;
branches;
next	1.274;

1.274
date	2010.01.25.06.47.16;	author amodra;	state Exp;
branches;
next	1.273;

1.273
date	2009.12.17.05.45.25;	author amodra;	state Exp;
branches;
next	1.272;

1.272
date	2009.12.11.13.42.02;	author nickc;	state Exp;
branches;
next	1.271;

1.271
date	2009.12.03.08.31.29;	author amodra;	state Exp;
branches;
next	1.270;

1.270
date	2009.11.18.12.42.51;	author amodra;	state Exp;
branches;
next	1.269;

1.269
date	2009.09.21.11.51.01;	author amodra;	state Exp;
branches;
next	1.268;

1.268
date	2009.09.18.12.41.52;	author amodra;	state Exp;
branches;
next	1.267;

1.267
date	2009.08.10.13.38.44;	author nathan;	state Exp;
branches
	1.267.2.1;
next	1.266;

1.266
date	2009.08.10.07.24.33;	author amodra;	state Exp;
branches;
next	1.265;

1.265
date	2009.08.10.06.14.04;	author amodra;	state Exp;
branches;
next	1.264;

1.264
date	2009.08.04.08.03.35;	author amodra;	state Exp;
branches;
next	1.263;

1.263
date	2009.08.03.12.10.46;	author amodra;	state Exp;
branches;
next	1.262;

1.262
date	2009.08.03.10.23.18;	author amodra;	state Exp;
branches;
next	1.261;

1.261
date	2009.07.29.14.56.37;	author amodra;	state Exp;
branches;
next	1.260;

1.260
date	2009.07.10.12.19.57;	author amodra;	state Exp;
branches;
next	1.259;

1.259
date	2009.06.22.00.52.20;	author amodra;	state Exp;
branches;
next	1.258;

1.258
date	2009.06.19.03.30.45;	author amodra;	state Exp;
branches;
next	1.257;

1.257
date	2009.06.19.00.41.28;	author amodra;	state Exp;
branches;
next	1.256;

1.256
date	2009.06.18.14.18.29;	author amodra;	state Exp;
branches;
next	1.255;

1.255
date	2009.06.17.18.08.34;	author hjl;	state Exp;
branches;
next	1.254;

1.254
date	2009.05.27.13.31.23;	author nathan;	state Exp;
branches;
next	1.253;

1.253
date	2009.03.21.02.35.27;	author amodra;	state Exp;
branches;
next	1.252;

1.252
date	2009.03.04.05.50.49;	author amodra;	state Exp;
branches;
next	1.251;

1.251
date	2009.02.15.12.14.14;	author amodra;	state Exp;
branches;
next	1.250;

1.250
date	2009.01.26.15.27.03;	author nathan;	state Exp;
branches;
next	1.249;

1.249
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.248;

1.248
date	2008.11.20.08.47.10;	author amodra;	state Exp;
branches;
next	1.247;

1.247
date	2008.10.10.20.55.35;	author froydnj;	state Exp;
branches;
next	1.246;

1.246
date	2008.09.19.09.51.32;	author amodra;	state Exp;
branches;
next	1.245;

1.245
date	2008.09.16.13.43.36;	author amodra;	state Exp;
branches;
next	1.244;

1.244
date	2008.09.15.23.41.55;	author amodra;	state Exp;
branches;
next	1.243;

1.243
date	2008.08.12.13.12.49;	author amodra;	state Exp;
branches
	1.243.2.1;
next	1.242;

1.242
date	2008.08.06.07.29.31;	author amodra;	state Exp;
branches;
next	1.241;

1.241
date	2008.07.26.13.10.47;	author amodra;	state Exp;
branches;
next	1.240;

1.240
date	2008.07.02.13.31.53;	author amodra;	state Exp;
branches;
next	1.239;

1.239
date	2008.06.30.20.51.58;	author rsandifo;	state Exp;
branches;
next	1.238;

1.238
date	2008.05.14.16.00.38;	author uweigand;	state Exp;
branches;
next	1.237;

1.237
date	2008.05.14.02.21.19;	author amodra;	state Exp;
branches;
next	1.236;

1.236
date	2008.05.12.12.47.47;	author amodra;	state Exp;
branches;
next	1.235;

1.235
date	2008.03.25.18.56.01;	author nathan;	state Exp;
branches;
next	1.234;

1.234
date	2008.03.02.22.15.39;	author amodra;	state Exp;
branches;
next	1.233;

1.233
date	2008.03.01.06.52.32;	author amodra;	state Exp;
branches;
next	1.232;

1.232
date	2008.02.26.08.36.03;	author amodra;	state Exp;
branches;
next	1.231;

1.231
date	2008.02.23.05.50.28;	author amodra;	state Exp;
branches;
next	1.230;

1.230
date	2008.02.23.01.56.21;	author amodra;	state Exp;
branches;
next	1.229;

1.229
date	2008.02.20.17.42.35;	author nickc;	state Exp;
branches;
next	1.228;

1.228
date	2008.02.15.08.27.18;	author amodra;	state Exp;
branches;
next	1.227;

1.227
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.226;

1.226
date	2008.02.12.11.32.30;	author nickc;	state Exp;
branches;
next	1.225;

1.225
date	2008.01.11.09.07.03;	author gingold;	state Exp;
branches;
next	1.224;

1.224
date	2007.11.08.13.51.06;	author nathan;	state Exp;
branches;
next	1.223;

1.223
date	2007.11.06.03.59.14;	author amodra;	state Exp;
branches;
next	1.222;

1.222
date	2007.10.25.15.20.23;	author drow;	state Exp;
branches;
next	1.221;

1.221
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.220;

1.220
date	2007.07.10.07.42.30;	author nathan;	state Exp;
branches;
next	1.219;

1.219
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.218;

1.218
date	2007.06.30.00.03.39;	author jsm28;	state Exp;
branches;
next	1.217;

1.217
date	2007.06.29.01.51.55;	author amodra;	state Exp;
branches;
next	1.216;

1.216
date	2007.06.27.06.42.14;	author amodra;	state Exp;
branches;
next	1.215;

1.215
date	2007.05.15.13.55.53;	author hjl;	state Exp;
branches;
next	1.214;

1.214
date	2007.05.11.06.39.05;	author amodra;	state Exp;
branches;
next	1.213;

1.213
date	2007.04.26.14.46.56;	author amodra;	state Exp;
branches;
next	1.212;

1.212
date	2007.03.29.01.11.30;	author amodra;	state Exp;
branches;
next	1.211;

1.211
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.210;

1.210
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.209;

1.209
date	2007.02.01.05.35.58;	author amodra;	state Exp;
branches;
next	1.208;

1.208
date	2007.01.29.16.29.21;	author jules;	state Exp;
branches;
next	1.207;

1.207
date	2006.11.22.00.12.30;	author gkm;	state Exp;
branches;
next	1.206;

1.206
date	2006.11.03.00.58.09;	author drow;	state Exp;
branches;
next	1.205;

1.205
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.204;

1.204
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.203;

1.203
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.202;

1.202
date	2006.08.22.12.06.10;	author amodra;	state Exp;
branches;
next	1.201;

1.201
date	2006.06.23.02.58.00;	author amodra;	state Exp;
branches;
next	1.200;

1.200
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.199;

1.199
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.198;

1.198
date	2006.05.15.02.22.20;	author amodra;	state Exp;
branches;
next	1.197;

1.197
date	2006.05.02.01.41.20;	author amodra;	state Exp;
branches;
next	1.196;

1.196
date	2006.03.17.06.44.37;	author aoliva;	state Exp;
branches
	1.196.2.1
	1.196.6.1;
next	1.195;

1.195
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.194;

1.194
date	2006.03.15.14.30.18;	author amodra;	state Exp;
branches;
next	1.193;

1.193
date	2006.03.15.13.52.58;	author amodra;	state Exp;
branches;
next	1.192;

1.192
date	2006.03.02.09.44.23;	author rsandifo;	state Exp;
branches;
next	1.191;

1.191
date	2006.03.02.08.56.59;	author rsandifo;	state Exp;
branches;
next	1.190;

1.190
date	2006.03.02.08.52.49;	author rsandifo;	state Exp;
branches;
next	1.189;

1.189
date	2006.03.02.08.50.04;	author rsandifo;	state Exp;
branches;
next	1.188;

1.188
date	2006.02.25.09.23.30;	author rsandifo;	state Exp;
branches;
next	1.187;

1.187
date	2006.02.17.12.52.58;	author amodra;	state Exp;
branches;
next	1.186;

1.186
date	2006.02.17.04.49.34;	author amodra;	state Exp;
branches;
next	1.185;

1.185
date	2005.12.27.03.54.33;	author amodra;	state Exp;
branches;
next	1.184;

1.184
date	2005.12.08.11.41.11;	author amodra;	state Exp;
branches;
next	1.183;

1.183
date	2005.10.25.16.19.06;	author amodra;	state Exp;
branches;
next	1.182;

1.182
date	2005.10.24.04.32.50;	author amodra;	state Exp;
branches;
next	1.181;

1.181
date	2005.10.06.19.21.14;	author drow;	state Exp;
branches;
next	1.180;

1.180
date	2005.08.18.01.28.23;	author amodra;	state Exp;
branches;
next	1.179;

1.179
date	2005.08.04.06.22.05;	author amodra;	state Exp;
branches;
next	1.178;

1.178
date	2005.08.02.23.32.52;	author amodra;	state Exp;
branches;
next	1.177;

1.177
date	2005.08.02.23.09.16;	author amodra;	state Exp;
branches;
next	1.176;

1.176
date	2005.07.29.02.46.03;	author amodra;	state Exp;
branches;
next	1.175;

1.175
date	2005.07.26.12.06.38;	author amodra;	state Exp;
branches;
next	1.174;

1.174
date	2005.07.16.03.30.23;	author amodra;	state Exp;
branches;
next	1.173;

1.173
date	2005.07.14.13.54.16;	author amodra;	state Exp;
branches;
next	1.172;

1.172
date	2005.07.12.11.39.42;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2005.07.08.06.19.59;	author amodra;	state Exp;
branches;
next	1.170;

1.170
date	2005.07.05.16.52.48;	author pbrook;	state Exp;
branches;
next	1.169;

1.169
date	2005.07.05.13.25.47;	author pbrook;	state Exp;
branches;
next	1.168;

1.168
date	2005.07.05.06.23.36;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2005.07.04.01.53.39;	author amodra;	state Exp;
branches;
next	1.166;

1.166
date	2005.06.30.08.11.13;	author amodra;	state Exp;
branches;
next	1.165;

1.165
date	2005.06.29.13.16.43;	author pbrook;	state Exp;
branches;
next	1.164;

1.164
date	2005.06.20.18.12.07;	author hjl;	state Exp;
branches;
next	1.163;

1.163
date	2005.05.23.16.22.25;	author amodra;	state Exp;
branches;
next	1.162;

1.162
date	2005.05.20.21.57.10;	author drow;	state Exp;
branches;
next	1.161;

1.161
date	2005.05.20.02.37.21;	author amodra;	state Exp;
branches;
next	1.160;

1.160
date	2005.05.19.08.26.56;	author amodra;	state Exp;
branches;
next	1.159;

1.159
date	2005.05.17.13.55.02;	author amodra;	state Exp;
branches;
next	1.158;

1.158
date	2005.05.14.05.07.18;	author amodra;	state Exp;
branches;
next	1.157;

1.157
date	2005.05.12.15.24.51;	author amodra;	state Exp;
branches;
next	1.156;

1.156
date	2005.05.11.14.09.42;	author amodra;	state Exp;
branches;
next	1.155;

1.155
date	2005.05.07.13.22.49;	author hjl;	state Exp;
branches;
next	1.154;

1.154
date	2005.05.07.02.55.54;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2005.05.05.14.33.49;	author hjl;	state Exp;
branches;
next	1.152;

1.152
date	2005.05.04.15.53.18;	author nickc;	state Exp;
branches;
next	1.151;

1.151
date	2005.05.04.11.00.13;	author amodra;	state Exp;
branches;
next	1.150;

1.150
date	2005.05.04.07.19.23;	author nickc;	state Exp;
branches;
next	1.149;

1.149
date	2005.04.27.20.16.07;	author hjl;	state Exp;
branches;
next	1.148;

1.148
date	2005.04.19.05.44.54;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2005.03.23.04.14.43;	author hjl;	state Exp;
branches;
next	1.146;

1.146
date	2005.03.22.13.32.57;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2005.03.22.03.23.51;	author amodra;	state Exp;
branches;
next	1.144;

1.144
date	2005.03.21.13.56.47;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2005.03.21.13.23.13;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2005.03.21.12.24.10;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2005.03.21.12.09.13;	author amodra;	state Exp;
branches;
next	1.140;

1.140
date	2005.03.21.11.22.24;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2005.03.20.23.36.16;	author hjl;	state Exp;
branches;
next	1.138;

1.138
date	2005.03.16.06.11.51;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2005.03.16.02.41.25;	author amodra;	state Exp;
branches;
next	1.136;

1.136
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2005.01.28.17.58.24;	author drow;	state Exp;
branches;
next	1.134;

1.134
date	2005.01.12.11.28.28;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2005.01.11.09.32.49;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2005.01.11.08.30.35;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2004.12.10.14.04.56;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2004.12.10.13.18.38;	author amodra;	state Exp;
branches;
next	1.129;

1.129
date	2004.10.21.15.28.23;	author hjl;	state Exp;
branches;
next	1.128;

1.128
date	2004.10.10.13.58.05;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2004.09.22.06.57.35;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2004.09.17.07.14.27;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2004.09.16.14.52.04;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2004.08.13.03.15.57;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2004.06.29.13.46.31;	author amodra;	state Exp;
branches;
next	1.122;

1.122
date	2004.06.24.04.46.20;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2004.06.22.05.35.36;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2004.06.17.02.27.12;	author drow;	state Exp;
branches;
next	1.119;

1.119
date	2004.05.22.01.56.30;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2004.04.22.14.45.31;	author jakub;	state Exp;
branches;
next	1.117;

1.117
date	2004.03.27.10.58.06;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2004.03.26.06.13.39;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2004.03.25.12.48.35;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2004.03.22.02.28.16;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2004.03.16.10.31.18;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2004.03.16.10.29.12;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2004.02.20.17.36.36;	author jakub;	state Exp;
branches
	1.111.2.1
	1.111.6.1;
next	1.110;

1.110
date	2003.12.04.22.48.20;	author hjl;	state Exp;
branches
	1.110.6.1;
next	1.109;

1.109
date	2003.11.27.18.49.37;	author kazu;	state Exp;
branches;
next	1.108;

1.108
date	2003.11.27.16.43.24;	author aoliva;	state Exp;
branches;
next	1.107;

1.107
date	2003.11.17.21.31.10;	author drow;	state Exp;
branches;
next	1.106;

1.106
date	2003.11.06.14.30.11;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2003.11.06.02.58.40;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2003.11.04.06.16.35;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.101;

1.101
date	2003.09.23.00.40.48;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2003.08.20.08.37.17;	author nickc;	state Exp;
branches;
next	1.99;

1.99
date	2003.08.11.14.26.10;	author jakub;	state Exp;
branches;
next	1.98;

1.98
date	2003.08.07.08.38.07;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2003.07.31.14.38.15;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2003.07.29.06.42.51;	author echristo;	state Exp;
branches;
next	1.95;

1.95
date	2003.07.25.14.35.55;	author hjl;	state Exp;
branches;
next	1.94;

1.94
date	2003.07.21.00.24.10;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2003.07.12.11.16.46;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	2003.07.08.13.10.51;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2003.07.07.15.51.57;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2003.07.04.13.53.37;	author jakub;	state Exp;
branches;
next	1.89;

1.89
date	2003.07.04.01.50.12;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2003.06.25.11.05.58;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2003.06.25.06.40.19;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2003.06.24.14.17.22;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2003.06.24.14.03.53;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2003.06.24.06.41.36;	author mmitchel;	state Exp;
branches;
next	1.83;

1.83
date	2003.05.31.07.55.10;	author jakub;	state Exp;
branches;
next	1.82;

1.82
date	2003.05.30.15.50.10;	author jakub;	state Exp;
branches;
next	1.81;

1.81
date	2003.05.17.06.16.02;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2003.05.15.06.35.43;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2003.05.13.14.09.50;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2003.05.09.02.27.04;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2003.05.05.14.12.05;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2003.05.01.10.22.46;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2003.04.24.13.44.10;	author amodra;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2003.04.03.04.02.02;	author amodra;	state Exp;
branches
	1.74.6.1;
next	1.73;

1.73
date	2003.04.03.02.54.52;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2003.03.10.23.25.13;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2003.03.07.01.09.01;	author amodra;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2003.03.06.23.26.20;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2003.03.06.11.32.43;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2003.02.20.09.10.18;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2003.02.19.11.26.50;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2003.02.18.12.54.15;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2003.02.18.06.06.17;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2003.02.17.18.24.39;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2003.01.21.12.55.11;	author schwab;	state Exp;
branches;
next	1.62;

1.62
date	2003.01.15.15.54.51;	author schwab;	state Exp;
branches;
next	1.61;

1.61
date	2003.01.09.22.51.37;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2002.12.18.13.16.35;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2002.12.12.10.26.01;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2002.12.03.18.52.44;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2002.12.03.18.24.28;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2002.11.28.11.55.40;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2002.11.06.11.38.35;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2002.10.16.08.39.37;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2002.09.21.10.09.13;	author amodra;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2002.09.20.05.54.41;	author hjl;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2002.08.09.15.38.22;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2002.07.01.08.06.44;	author amodra;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2002.06.27.11.29.15;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.25.06.21.52;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.04.00.51.07;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2002.05.08.05.12.54;	author amodra;	state Exp;
branches
	1.44.2.1
	1.44.4.1;
next	1.43;

1.43
date	2002.05.07.00.16.51;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.02.12.35.25;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2002.04.15.08.47.03;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2002.02.19.12.40.25;	author jakub;	state Exp;
branches;
next	1.39;

1.39
date	2001.12.18.17.59.59;	author hjl;	state Exp;
branches
	1.39.2.1;
next	1.38;

1.38
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.23.12.17.16;	author jakub;	state Exp;
branches;
next	1.35;

1.35
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2001.10.19.02.11.04;	author hjl;	state Exp;
branches;
next	1.33;

1.33
date	2001.10.15.07.28.45;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2001.09.29.06.21.59;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2001.09.20.23.30.35;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.27.18.04.37;	author drow;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.27.17.36.32;	author drow;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.27.08.59.06;	author aj;	state Exp;
branches;
next	1.24;

1.24
date	2001.08.17.15.56.58;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.09.14.38.04;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.08.21.04.00;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.23.11.45.53;	author kazu;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2000.12.08.18.34.31;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2000.12.07.19.31.48;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2000.12.06.18.59.48;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.16.19.52.26;	author geoffk;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.14.23.30.12;	author geoffk;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.20.03.21.59;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2000.05.23.14.20.57;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.23.14.05.50;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.22.18.44.02;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.27.00.31.17;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.20.05.37.05;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.01.19.40.54;	author hjl;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.02.13.22.45.29;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.08.03.16.40.25;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.07.13.18.21.22;	author rth;	state Exp;
branches;
next	1.5;

1.5
date	99.07.12.10.29.28;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.26.08.57.54;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.22.21.01.24;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.04.13.25.20;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.318.4.1
date	2012.09.04.14.37.51;	author gingold;	state Exp;
branches;
next	1.318.4.2;

1.318.4.2
date	2013.01.21.13.48.36;	author amodra;	state Exp;
branches;
next	1.318.4.3;

1.318.4.3
date	2013.03.04.12.12.51;	author amodra;	state Exp;
branches;
next	;

1.302.2.1
date	2011.11.15.11.36.52;	author amodra;	state Exp;
branches;
next	1.302.2.2;

1.302.2.2
date	2011.12.03.00.58.01;	author amodra;	state Exp;
branches;
next	1.302.2.3;

1.302.2.3
date	2012.05.11.12.24.26;	author nickc;	state Exp;
branches;
next	;

1.290.2.1
date	2011.01.29.00.17.06;	author jsm28;	state Exp;
branches;
next	1.290.2.2;

1.290.2.2
date	2011.03.23.15.26.18;	author amodra;	state Exp;
branches;
next	1.290.2.3;

1.290.2.3
date	2011.04.27.07.17.37;	author amodra;	state Exp;
branches;
next	1.290.2.4;

1.290.2.4
date	2011.05.29.04.51.07;	author amodra;	state Exp;
branches;
next	;

1.267.2.1
date	2009.09.18.12.43.28;	author amodra;	state Exp;
branches;
next	1.267.2.2;

1.267.2.2
date	2009.09.21.11.55.16;	author amodra;	state Exp;
branches;
next	1.267.2.3;

1.267.2.3
date	2009.12.03.08.32.06;	author amodra;	state Exp;
branches;
next	1.267.2.4;

1.267.2.4
date	2009.12.17.05.46.06;	author amodra;	state Exp;
branches;
next	1.267.2.5;

1.267.2.5
date	2010.01.25.12.12.47;	author amodra;	state Exp;
branches;
next	1.267.2.6;

1.267.2.6
date	2010.01.25.13.06.23;	author amodra;	state Exp;
branches;
next	;

1.243.2.1
date	2008.09.15.23.44.02;	author amodra;	state Exp;
branches;
next	1.243.2.2;

1.243.2.2
date	2008.09.16.13.44.24;	author amodra;	state Exp;
branches;
next	1.243.2.3;

1.243.2.3
date	2008.09.19.10.03.31;	author amodra;	state Exp;
branches;
next	1.243.2.4;

1.243.2.4
date	2008.11.20.11.50.22;	author amodra;	state Exp;
branches;
next	1.243.2.5;

1.243.2.5
date	2009.03.02.13.35.24;	author amodra;	state Exp;
branches;
next	1.243.2.6;

1.243.2.6
date	2009.03.02.13.52.33;	author amodra;	state Exp;
branches;
next	1.243.2.7;

1.243.2.7
date	2009.03.02.13.55.19;	author amodra;	state Exp;
branches;
next	;

1.196.2.1
date	2006.08.22.15.08.28;	author jsm28;	state Exp;
branches;
next	;

1.196.6.1
date	2006.05.15.02.21.40;	author amodra;	state Exp;
branches;
next	;

1.136.2.1
date	2005.03.16.02.42.26;	author amodra;	state Exp;
branches;
next	1.136.2.2;

1.136.2.2
date	2005.03.21.11.22.37;	author amodra;	state Exp;
branches;
next	1.136.2.3;

1.136.2.3
date	2005.04.19.05.59.01;	author amodra;	state Exp;
branches;
next	;

1.111.2.1
date	2004.03.27.17.37.33;	author drow;	state Exp;
branches;
next	1.111.2.2;

1.111.2.2
date	2004.04.02.16.47.35;	author drow;	state Exp;
branches;
next	1.111.2.3;

1.111.2.3
date	2004.09.16.17.00.25;	author drow;	state Exp;
branches;
next	1.111.2.4;

1.111.2.4
date	2004.09.21.20.44.02;	author drow;	state Exp;
branches;
next	;

1.111.6.1
date	2004.03.21.23.57.27;	author cagney;	state Exp;
branches;
next	;

1.110.6.1
date	2004.03.16.10.35.20;	author amodra;	state Exp;
branches;
next	1.110.6.2;

1.110.6.2
date	2004.04.08.12.41.42;	author amodra;	state Exp;
branches;
next	;

1.75.2.1
date	2003.05.01.10.27.44;	author amodra;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	2003.05.31.07.56.41;	author jakub;	state Exp;
branches;
next	;

1.74.6.1
date	2003.05.04.11.37.36;	author kettenis;	state Exp;
branches;
next	1.74.6.2;

1.74.6.2
date	2003.05.18.09.43.42;	author kettenis;	state Exp;
branches;
next	;

1.71.2.1
date	2003.03.16.14.01.43;	author kettenis;	state Exp;
branches;
next	;

1.52.2.1
date	2002.10.26.17.11.58;	author drow;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	2003.12.14.20.26.40;	author drow;	state Exp;
branches;
next	;

1.51.2.1
date	2002.09.27.20.02.53;	author carlton;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2002.10.25.23.49.48;	author carlton;	state Exp;
branches;
next	1.51.2.3;

1.51.2.3
date	2002.11.15.19.18.26;	author carlton;	state Exp;
branches;
next	1.51.2.4;

1.51.2.4
date	2002.12.23.19.37.44;	author carlton;	state Exp;
branches;
next	1.51.2.5;

1.51.2.5
date	2003.02.07.19.17.38;	author carlton;	state Exp;
branches;
next	1.51.2.6;

1.51.2.6
date	2003.03.06.00.56.15;	author carlton;	state Exp;
branches;
next	1.51.2.7;

1.51.2.7
date	2003.04.16.19.56.43;	author carlton;	state Exp;
branches;
next	1.51.2.8;

1.51.2.8
date	2003.05.01.00.46.41;	author carlton;	state Exp;
branches;
next	1.51.2.9;

1.51.2.9
date	2003.05.23.18.40.24;	author carlton;	state Exp;
branches;
next	1.51.2.10;

1.51.2.10
date	2003.06.27.21.49.15;	author carlton;	state Exp;
branches;
next	1.51.2.11;

1.51.2.11
date	2003.08.05.17.12.46;	author carlton;	state Exp;
branches;
next	1.51.2.12;

1.51.2.12
date	2003.09.17.21.27.52;	author carlton;	state Exp;
branches;
next	1.51.2.13;

1.51.2.13
date	2003.11.11.23.50.18;	author carlton;	state Exp;
branches;
next	1.51.2.14;

1.51.2.14
date	2003.12.15.23.59.26;	author carlton;	state Exp;
branches;
next	;

1.48.2.1
date	2002.09.23.22.12.40;	author drow;	state Exp;
branches;
next	;

1.44.2.1
date	2002.06.15.16.42.37;	author cagney;	state Exp;
branches;
next	;

1.44.4.1
date	2002.06.20.01.30.20;	author kseitz;	state Exp;
branches;
next	1.44.4.2;

1.44.4.2
date	2002.07.22.21.46.44;	author kseitz;	state Exp;
branches;
next	1.44.4.3;

1.44.4.3
date	2002.08.09.18.34.14;	author kseitz;	state Exp;
branches;
next	1.44.4.4;

1.44.4.4
date	2002.10.01.00.45.46;	author kseitz;	state Exp;
branches;
next	1.44.4.5;

1.44.4.5
date	2002.11.03.22.01.35;	author ezannoni;	state Exp;
branches;
next	;

1.39.2.1
date	2002.02.19.13.10.21;	author jakub;	state Exp;
branches;
next	1.39.2.2;

1.39.2.2
date	2002.04.27.08.30.11;	author amodra;	state Exp;
branches;
next	1.39.2.3;

1.39.2.3
date	2002.05.09.11.50.25;	author amodra;	state Exp;
branches;
next	;

1.21.2.1
date	2001.06.07.03.08.25;	author amodra;	state Exp;
branches;
next	;

1.9.2.1
date	2000.10.16.18.08.29;	author geoffk;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2000.10.22.15.19.57;	author pb;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2000.10.31.22.56.17;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.56;	author rth;	state Exp;
branches;
next	;


desc
@@


1.332
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Use SYMBOLIC_BIND.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count): Likewise.
@
text
@/* PowerPC-specific support for 32-bit ELF
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the
   Free Software Foundation, Inc., 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */


/* This file is based on a preliminary PowerPC ELF ABI.  The
   information may not match the final PowerPC ELF ABI.  It includes
   suggestions from the in-progress Embedded PowerPC ABI, and that
   information may also not match.  */

#include "sysdep.h"
#include <stdarg.h>
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/ppc.h"
#include "elf32-ppc.h"
#include "elf-vxworks.h"
#include "dwarf2.h"
#include "elf-linux-psinfo.h"

typedef enum split16_format_type
{
  split16a_type = 0,
  split16d_type
}
split16_format_type;

/* RELA relocations are used here.  */

static bfd_reloc_status_type ppc_elf_addr16_ha_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc_elf_unhandled_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static void ppc_elf_vle_split16
  (bfd *, bfd_byte *, bfd_vma, bfd_vma, split16_format_type);

/* Branch prediction bit for branch taken relocs.  */
#define BRANCH_PREDICT_BIT 0x200000
/* Mask to set RA in memory instructions.  */
#define RA_REGISTER_MASK 0x001f0000
/* Value to shift register by to insert RA.  */
#define RA_REGISTER_SHIFT 16

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so.1"

/* For old-style PLT.  */
/* The number of single-slot PLT entries (the rest use two slots).  */
#define PLT_NUM_SINGLE_ENTRIES 8192

/* For new-style .glink and .plt.  */
#define GLINK_PLTRESOLVE 16*4
#define GLINK_ENTRY_SIZE 4*4
#define TLS_GET_ADDR_GLINK_SIZE 12*4

/* VxWorks uses its own plt layout, filled in by the static linker.  */

/* The standard VxWorks PLT entry.  */
#define VXWORKS_PLT_ENTRY_SIZE 32
static const bfd_vma ppc_elf_vxworks_plt_entry
    [VXWORKS_PLT_ENTRY_SIZE / 4] =
  {
    0x3d800000, /* lis     r12,0                 */
    0x818c0000, /* lwz     r12,0(r12)            */
    0x7d8903a6, /* mtctr   r12                   */
    0x4e800420, /* bctr                          */
    0x39600000, /* li      r11,0                 */
    0x48000000, /* b       14 <.PLT0resolve+0x4> */
    0x60000000, /* nop                           */
    0x60000000, /* nop                           */
  };
static const bfd_vma ppc_elf_vxworks_pic_plt_entry
    [VXWORKS_PLT_ENTRY_SIZE / 4] =
  {
    0x3d9e0000, /* addis r12,r30,0 */
    0x818c0000, /* lwz	 r12,0(r12) */
    0x7d8903a6, /* mtctr r12 */
    0x4e800420, /* bctr */
    0x39600000, /* li	 r11,0 */
    0x48000000, /* b	 14 <.PLT0resolve+0x4> 14: R_PPC_REL24 .PLTresolve */
    0x60000000, /* nop */
    0x60000000, /* nop */
  };

/* The initial VxWorks PLT entry.  */
#define VXWORKS_PLT_INITIAL_ENTRY_SIZE 32
static const bfd_vma ppc_elf_vxworks_plt0_entry
    [VXWORKS_PLT_INITIAL_ENTRY_SIZE / 4] =
  {
    0x3d800000, /* lis     r12,0        */
    0x398c0000, /* addi    r12,r12,0    */
    0x800c0008, /* lwz     r0,8(r12)    */
    0x7c0903a6, /* mtctr   r0           */
    0x818c0004, /* lwz     r12,4(r12)   */
    0x4e800420, /* bctr                 */
    0x60000000, /* nop                  */
    0x60000000, /* nop                  */
  };
static const bfd_vma ppc_elf_vxworks_pic_plt0_entry
    [VXWORKS_PLT_INITIAL_ENTRY_SIZE / 4] =
  {
    0x819e0008, /* lwz	 r12,8(r30) */
    0x7d8903a6, /* mtctr r12        */
    0x819e0004, /* lwz	 r12,4(r30) */
    0x4e800420, /* bctr             */
    0x60000000, /* nop              */
    0x60000000, /* nop              */
    0x60000000, /* nop              */
    0x60000000, /* nop              */
  };

/* For executables, we have some additional relocations in
   .rela.plt.unloaded, for the kernel loader.  */

/* The number of non-JMP_SLOT relocations per PLT0 slot. */
#define VXWORKS_PLT_NON_JMP_SLOT_RELOCS 3
/* The number of relocations in the PLTResolve slot. */
#define VXWORKS_PLTRESOLVE_RELOCS 2
/* The number of relocations in the PLTResolve slot when when creating
   a shared library. */
#define VXWORKS_PLTRESOLVE_RELOCS_SHLIB 0

/* Some instructions.  */
#define ADDIS_11_11	0x3d6b0000
#define ADDIS_11_30	0x3d7e0000
#define ADDIS_12_12	0x3d8c0000
#define ADDI_11_11	0x396b0000
#define ADD_0_11_11	0x7c0b5a14
#define ADD_3_12_2	0x7c6c1214
#define ADD_11_0_11	0x7d605a14
#define B		0x48000000
#define BCL_20_31	0x429f0005
#define BCTR		0x4e800420
#define BEQLR		0x4d820020
#define CMPWI_11_0	0x2c0b0000
#define LIS_11		0x3d600000
#define LIS_12		0x3d800000
#define LWZU_0_12	0x840c0000
#define LWZ_0_12	0x800c0000
#define LWZ_11_3	0x81630000
#define LWZ_11_11	0x816b0000
#define LWZ_11_30	0x817e0000
#define LWZ_12_3	0x81830000
#define LWZ_12_12	0x818c0000
#define MR_0_3		0x7c601b78
#define MR_3_0		0x7c030378
#define MFLR_0		0x7c0802a6
#define MFLR_12		0x7d8802a6
#define MTCTR_0		0x7c0903a6
#define MTCTR_11	0x7d6903a6
#define MTLR_0		0x7c0803a6
#define NOP		0x60000000
#define SUB_11_11_12	0x7d6c5850

/* Offset of tp and dtp pointers from start of TLS block.  */
#define TP_OFFSET	0x7000
#define DTP_OFFSET	0x8000

/* The value of a defined global symbol.  */
#define SYM_VAL(SYM) \
  ((SYM)->root.u.def.section->output_section->vma	\
   + (SYM)->root.u.def.section->output_offset		\
   + (SYM)->root.u.def.value)

static reloc_howto_type *ppc_elf_howto_table[R_PPC_max];

static reloc_howto_type ppc_elf_howto_raw[] = {
  /* This reloc does nothing.  */
  HOWTO (R_PPC_NONE,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A standard 32 bit relocation.  */
  HOWTO (R_PPC_ADDR32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 26 bit branch; the lower two bits must be zero.
     FIXME: we don't check that, we just clear them.  */
  HOWTO (R_PPC_ADDR24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR24",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A standard 16 bit relocation.  */
  HOWTO (R_PPC_ADDR16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit relocation without overflow.  */
  HOWTO (R_PPC_ADDR16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of an address.  */
  HOWTO (R_PPC_ADDR16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of an address, plus 1 if the contents of
     the low 16 bits, treated as a signed number, is negative.  */
  HOWTO (R_PPC_ADDR16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_ADDR16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 16 bit branch; the lower two bits must be zero.
     FIXME: we don't check that, we just clear them.  */
  HOWTO (R_PPC_ADDR14,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR14",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 16 bit branch, for which bit 10 should be set to
     indicate that the branch is expected to be taken.	The lower two
     bits must be zero.  */
  HOWTO (R_PPC_ADDR14_BRTAKEN,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR14_BRTAKEN",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 16 bit branch, for which bit 10 should be set to
     indicate that the branch is not expected to be taken.  The lower
     two bits must be zero.  */
  HOWTO (R_PPC_ADDR14_BRNTAKEN, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR14_BRNTAKEN",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A relative 26 bit branch; the lower two bits must be zero.  */
  HOWTO (R_PPC_REL24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL24",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 16 bit branch; the lower two bits must be zero.  */
  HOWTO (R_PPC_REL14,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL14",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 16 bit branch.  Bit 10 should be set to indicate that
     the branch is expected to be taken.  The lower two bits must be
     zero.  */
  HOWTO (R_PPC_REL14_BRTAKEN,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL14_BRTAKEN",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 16 bit branch.  Bit 10 should be set to indicate that
     the branch is not expected to be taken.  The lower two bits must
     be zero.  */
  HOWTO (R_PPC_REL14_BRNTAKEN,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL14_BRNTAKEN",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Like R_PPC_ADDR16, but referring to the GOT table entry for the
     symbol.  */
  HOWTO (R_PPC_GOT16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_GOT16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC_ADDR16_LO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_PPC_GOT16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_GOT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC_ADDR16_HI, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_PPC_GOT16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_GOT16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		 /* pcrel_offset */

  /* Like R_PPC_ADDR16_HA, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_PPC_GOT16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_GOT16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC_REL24, but referring to the procedure linkage table
     entry for the symbol.  */
  HOWTO (R_PPC_PLTREL24,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed,  /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_PLTREL24",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* This is used only by the dynamic linker.  The symbol should exist
     both in the object being run and in some shared library.  The
     dynamic linker copies the data addressed by the symbol from the
     shared library into the object, because the object being
     run has to have the data at some particular address.  */
  HOWTO (R_PPC_COPY,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_COPY",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC_ADDR32, but used when setting global offset table
     entries.  */
  HOWTO (R_PPC_GLOB_DAT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_GLOB_DAT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Marks a procedure linkage table entry for a symbol.  */
  HOWTO (R_PPC_JMP_SLOT,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_JMP_SLOT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Used only by the dynamic linker.  When the object is run, this
     longword is set to the load address of the object, plus the
     addend.  */
  HOWTO (R_PPC_RELATIVE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_RELATIVE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC_REL24, but uses the value of the symbol within the
     object rather than the final value.  Normally used for
     _GLOBAL_OFFSET_TABLE_.  */
  HOWTO (R_PPC_LOCAL24PC,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_LOCAL24PC",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Like R_PPC_ADDR32, but may be unaligned.  */
  HOWTO (R_PPC_UADDR32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_UADDR32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC_ADDR16, but may be unaligned.  */
  HOWTO (R_PPC_UADDR16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_UADDR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32-bit PC relative */
  HOWTO (R_PPC_REL32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* 32-bit relocation to the symbol's procedure linkage table.
     FIXME: not supported.  */
  HOWTO (R_PPC_PLT32,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_PLT32",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 32-bit PC relative relocation to the symbol's procedure linkage table.
     FIXME: not supported.  */
  HOWTO (R_PPC_PLTREL32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_PLTREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Like R_PPC_ADDR16_LO, but referring to the PLT table entry for
     the symbol.  */
  HOWTO (R_PPC_PLT16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_PLT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC_ADDR16_HI, but referring to the PLT table entry for
     the symbol.  */
  HOWTO (R_PPC_PLT16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_PLT16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		 /* pcrel_offset */

  /* Like R_PPC_ADDR16_HA, but referring to the PLT table entry for
     the symbol.  */
  HOWTO (R_PPC_PLT16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_PLT16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A sign-extended 16 bit value relative to _SDA_BASE_, for use with
     small data items.  */
  HOWTO (R_PPC_SDAREL16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_SDAREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16-bit section relative relocation.  */
  HOWTO (R_PPC_SECTOFF,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_SECTOFF",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16-bit lower half section relative relocation.  */
  HOWTO (R_PPC_SECTOFF_LO,	  /* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_SECTOFF_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16-bit upper half section relative relocation.  */
  HOWTO (R_PPC_SECTOFF_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_SECTOFF_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		 /* pcrel_offset */

  /* 16-bit upper half adjusted section relative relocation.  */
  HOWTO (R_PPC_SECTOFF_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_SECTOFF_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Marker relocs for TLS.  */
  HOWTO (R_PPC_TLS,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_TLS",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC_TLSGD,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_PPC_TLSGD",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC_TLSLD,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_PPC_TLSLD",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes the load module index of the load module that contains the
     definition of its TLS sym.  */
  HOWTO (R_PPC_DTPMOD32,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPMOD32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes a dtv-relative displacement, the difference between the value
     of sym+add and the base address of the thread-local storage block that
     contains the definition of sym, minus 0x8000.  */
  HOWTO (R_PPC_DTPREL32,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit dtprel reloc.  */
  HOWTO (R_PPC_DTPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16, but no overflow.  */
  HOWTO (R_PPC_DTPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_DTPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes a tp-relative displacement, the difference between the value of
     sym+add and the value of the thread pointer (r13).  */
  HOWTO (R_PPC_TPREL32,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit tprel reloc.  */
  HOWTO (R_PPC_TPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16, but no overflow.  */
  HOWTO (R_PPC_TPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and (sym+add)@@dtprel, and computes the offset
     to the first entry.  */
  HOWTO (R_PPC_GOT_TLSGD16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSGD16, but no overflow.  */
  HOWTO (R_PPC_GOT_TLSGD16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_TLSGD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_TLSGD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and zero, and computes the offset to the
     first entry.  */
  HOWTO (R_PPC_GOT_TLSLD16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSLD16, but no overflow.  */
  HOWTO (R_PPC_GOT_TLSLD16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_TLSLD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_TLSLD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@dtprel, and computes
     the offset to the entry.  */
  HOWTO (R_PPC_GOT_DTPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_DTPREL16, but no overflow.  */
  HOWTO (R_PPC_GOT_DTPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_DTPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_DTPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@tprel, and computes the
     offset to the entry.  */
  HOWTO (R_PPC_GOT_TPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16, but no overflow.  */
  HOWTO (R_PPC_GOT_TPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The remaining relocs are from the Embedded ELF ABI, and are not
     in the SVR4 ELF ABI.  */

  /* 32 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_ADDR16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of the result of the addend minus the address,
     plus 1 if the contents of the low 16 bits, treated as a signed number,
     is negative.  */
  HOWTO (R_PPC_EMB_NADDR16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_EMB_NADDR16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from allocating a 4 byte word to hold an
     address in the .sdata section, and returning the offset from
     _SDA_BASE_ for that relocation.  */
  HOWTO (R_PPC_EMB_SDAI16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDAI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from allocating a 4 byte word to hold an
     address in the .sdata2 section, and returning the offset from
     _SDA2_BASE_ for that relocation.  */
  HOWTO (R_PPC_EMB_SDA2I16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA2I16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A sign-extended 16 bit value relative to _SDA2_BASE_, for use with
     small data items.	 */
  HOWTO (R_PPC_EMB_SDA2REL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA2REL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Relocate against either _SDA_BASE_ or _SDA2_BASE_, filling in the 16 bit
     signed offset from the appropriate base, and filling in the register
     field with the appropriate register (0, 2, or 13).  */
  HOWTO (R_PPC_EMB_SDA21,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA21",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Relocation not handled: R_PPC_EMB_MRKREF */
  /* Relocation not handled: R_PPC_EMB_RELSEC16 */
  /* Relocation not handled: R_PPC_EMB_RELST_LO */
  /* Relocation not handled: R_PPC_EMB_RELST_HI */
  /* Relocation not handled: R_PPC_EMB_RELST_HA */
  /* Relocation not handled: R_PPC_EMB_BIT_FLD */

  /* PC relative relocation against either _SDA_BASE_ or _SDA2_BASE_, filling
     in the 16 bit signed offset from the appropriate base, and filling in the
     register field with the appropriate register (0, 2, or 13).  */
  HOWTO (R_PPC_EMB_RELSDA,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_RELSDA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A relative 8 bit branch.  */
  HOWTO (R_PPC_VLE_REL8,	/* type */
	 1,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 8,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_VLE_REL8",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xff,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 15 bit branch.  */
  HOWTO (R_PPC_VLE_REL15,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 15,			/* bitsize */
	 TRUE,			/* pc_relative */
	 1,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_VLE_REL15",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfe,			/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 24 bit branch.  */
  HOWTO (R_PPC_VLE_REL24,	/* type */
	 1,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 24,			/* bitsize */
	 TRUE,			/* pc_relative */
	 1,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_VLE_REL24",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1fffffe,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The 16 LSBS in split16a format.  */
  HOWTO (R_PPC_VLE_LO16A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_LO16A",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f007ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The 16 LSBS in split16d format.  */
  HOWTO (R_PPC_VLE_LO16D,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_LO16D",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 split16a format.  */
  HOWTO (R_PPC_VLE_HI16A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_HI16A",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f007ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 split16d format.  */
  HOWTO (R_PPC_VLE_HI16D,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_HI16D",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 (High Adjusted) in split16a format.  */
  HOWTO (R_PPC_VLE_HA16A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_HA16A",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f007ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 (High Adjusted) in split16d format.  */
  HOWTO (R_PPC_VLE_HA16D,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_HA16D",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* This reloc does nothing.  */
  HOWTO (R_PPC_VLE_SDA21,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_VLE_SDA21",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* This reloc does nothing.  */
  HOWTO (R_PPC_VLE_SDA21_LO,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_VLE_SDA21_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The 16 LSBS relative to _SDA_BASE_ in split16a format.  */
  HOWTO (R_PPC_VLE_SDAREL_LO16A,/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_SDAREL_LO16A",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f007ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The 16 LSBS relative to _SDA_BASE_ in split16d format.  */
  /* This reloc does nothing.  */
  HOWTO (R_PPC_VLE_SDAREL_LO16D, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_SDAREL_LO16D",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 relative to _SDA_BASE_ in split16a format.  */
  HOWTO (R_PPC_VLE_SDAREL_HI16A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_SDAREL_HI16A",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f007ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 relative to _SDA_BASE_ in split16d format.  */
  HOWTO (R_PPC_VLE_SDAREL_HI16D,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_SDAREL_HI16D",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 (HA) relative to _SDA_BASE split16a format.  */
  HOWTO (R_PPC_VLE_SDAREL_HA16A,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_SDAREL_HA16A",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f007ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Bits 16-31 (HA) relative to _SDA_BASE split16d format.  */
  HOWTO (R_PPC_VLE_SDAREL_HA16D,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield,	/* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_VLE_SDAREL_HA16D",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x1f07ff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC_IRELATIVE,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	 /* special_function */
	 "R_PPC_IRELATIVE",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit relative relocation.  */
  HOWTO (R_PPC_REL16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A 16 bit relative relocation without overflow.  */
  HOWTO (R_PPC_REL16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The high order 16 bits of a relative address.  */
  HOWTO (R_PPC_REL16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* The high order 16 bits of a relative address, plus 1 if the contents of
     the low 16 bits, treated as a signed number, is negative.  */
  HOWTO (R_PPC_REL16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_REL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_PPC_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC_GNU_VTINHERIT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_PPC_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Phony reloc to handle AIX style TOC entries.  */
  HOWTO (R_PPC_TOC16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_TOC16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* External 32-bit PPC structure for PRPSINFO.  This structure is
   ABI-defined, thus we choose to use char arrays here in order to
   avoid dealing with different types in different architectures.

   The PPC 32-bit structure uses int for `pr_uid' and `pr_gid' while
   most non-PPC architectures use `short int'.

   This structure will ultimately be written in the corefile's note
   section, as the PRPSINFO.  */

struct elf_external_ppc_linux_prpsinfo32
  {
    char pr_state;			/* Numeric process state.  */
    char pr_sname;			/* Char for pr_state.  */
    char pr_zomb;			/* Zombie.  */
    char pr_nice;			/* Nice val.  */
    char pr_flag[4];			/* Flags.  */
    char pr_uid[4];
    char pr_gid[4];
    char pr_pid[4];
    char pr_ppid[4];
    char pr_pgrp[4];
    char pr_sid[4];
    char pr_fname[16];			/* Filename of executable.  */
    char pr_psargs[80];			/* Initial part of arg list.  */
  };

/* Helper macro to swap (properly handling endianess) things from the
   `elf_internal_prpsinfo' structure to the `elf_external_ppc_prpsinfo32'
   structure.

   Note that FROM should be a pointer, and TO should be the explicit type.  */

#define PPC_LINUX_PRPSINFO32_SWAP_FIELDS(abfd, from, to)	      \
  do								      \
    {								      \
      H_PUT_8 (abfd, from->pr_state, &to.pr_state);		      \
      H_PUT_8 (abfd, from->pr_sname, &to.pr_sname);		      \
      H_PUT_8 (abfd, from->pr_zomb, &to.pr_zomb);		      \
      H_PUT_8 (abfd, from->pr_nice, &to.pr_nice);		      \
      H_PUT_32 (abfd, from->pr_flag, to.pr_flag);		      \
      H_PUT_32 (abfd, from->pr_uid, to.pr_uid);			      \
      H_PUT_32 (abfd, from->pr_gid, to.pr_gid);			      \
      H_PUT_32 (abfd, from->pr_pid, to.pr_pid);			      \
      H_PUT_32 (abfd, from->pr_ppid, to.pr_ppid);		      \
      H_PUT_32 (abfd, from->pr_pgrp, to.pr_pgrp);		      \
      H_PUT_32 (abfd, from->pr_sid, to.pr_sid);			      \
      strncpy (to.pr_fname, from->pr_fname, sizeof (to.pr_fname));    \
      strncpy (to.pr_psargs, from->pr_psargs, sizeof (to.pr_psargs)); \
    } while (0)


/* Initialize the ppc_elf_howto_table, so that linear accesses can be done.  */

static void
ppc_elf_howto_init (void)
{
  unsigned int i, type;

  for (i = 0;
       i < sizeof (ppc_elf_howto_raw) / sizeof (ppc_elf_howto_raw[0]);
       i++)
    {
      type = ppc_elf_howto_raw[i].type;
      if (type >= (sizeof (ppc_elf_howto_table)
		   / sizeof (ppc_elf_howto_table[0])))
	abort ();
      ppc_elf_howto_table[type] = &ppc_elf_howto_raw[i];
    }
}

static reloc_howto_type *
ppc_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   bfd_reloc_code_real_type code)
{
  enum elf_ppc_reloc_type r;

  /* Initialize howto table if not already done.  */
  if (!ppc_elf_howto_table[R_PPC_ADDR32])
    ppc_elf_howto_init ();

  switch (code)
    {
    default:
      return NULL;

    case BFD_RELOC_NONE:		r = R_PPC_NONE;			break;
    case BFD_RELOC_32:			r = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC_BA26:		r = R_PPC_ADDR24;		break;
    case BFD_RELOC_PPC64_ADDR16_DS:
    case BFD_RELOC_16:			r = R_PPC_ADDR16;		break;
    case BFD_RELOC_PPC64_ADDR16_LO_DS:
    case BFD_RELOC_LO16:		r = R_PPC_ADDR16_LO;		break;
    case BFD_RELOC_HI16:		r = R_PPC_ADDR16_HI;		break;
    case BFD_RELOC_HI16_S:		r = R_PPC_ADDR16_HA;		break;
    case BFD_RELOC_PPC_BA16:		r = R_PPC_ADDR14;		break;
    case BFD_RELOC_PPC_BA16_BRTAKEN:	r = R_PPC_ADDR14_BRTAKEN;	break;
    case BFD_RELOC_PPC_BA16_BRNTAKEN:	r = R_PPC_ADDR14_BRNTAKEN;	break;
    case BFD_RELOC_PPC_B26:		r = R_PPC_REL24;		break;
    case BFD_RELOC_PPC_B16:		r = R_PPC_REL14;		break;
    case BFD_RELOC_PPC_B16_BRTAKEN:	r = R_PPC_REL14_BRTAKEN;	break;
    case BFD_RELOC_PPC_B16_BRNTAKEN:	r = R_PPC_REL14_BRNTAKEN;	break;
    case BFD_RELOC_PPC64_GOT16_DS:
    case BFD_RELOC_16_GOTOFF:		r = R_PPC_GOT16;		break;
    case BFD_RELOC_PPC64_GOT16_LO_DS:
    case BFD_RELOC_LO16_GOTOFF:		r = R_PPC_GOT16_LO;		break;
    case BFD_RELOC_HI16_GOTOFF:		r = R_PPC_GOT16_HI;		break;
    case BFD_RELOC_HI16_S_GOTOFF:	r = R_PPC_GOT16_HA;		break;
    case BFD_RELOC_24_PLT_PCREL:	r = R_PPC_PLTREL24;		break;
    case BFD_RELOC_PPC_COPY:		r = R_PPC_COPY;			break;
    case BFD_RELOC_PPC_GLOB_DAT:	r = R_PPC_GLOB_DAT;		break;
    case BFD_RELOC_PPC_LOCAL24PC:	r = R_PPC_LOCAL24PC;		break;
    case BFD_RELOC_32_PCREL:		r = R_PPC_REL32;		break;
    case BFD_RELOC_32_PLTOFF:		r = R_PPC_PLT32;		break;
    case BFD_RELOC_32_PLT_PCREL:	r = R_PPC_PLTREL32;		break;
    case BFD_RELOC_PPC64_PLT16_LO_DS:
    case BFD_RELOC_LO16_PLTOFF:		r = R_PPC_PLT16_LO;		break;
    case BFD_RELOC_HI16_PLTOFF:		r = R_PPC_PLT16_HI;		break;
    case BFD_RELOC_HI16_S_PLTOFF:	r = R_PPC_PLT16_HA;		break;
    case BFD_RELOC_GPREL16:		r = R_PPC_SDAREL16;		break;
    case BFD_RELOC_PPC64_SECTOFF_DS:
    case BFD_RELOC_16_BASEREL:		r = R_PPC_SECTOFF;		break;
    case BFD_RELOC_PPC64_SECTOFF_LO_DS:
    case BFD_RELOC_LO16_BASEREL:	r = R_PPC_SECTOFF_LO;		break;
    case BFD_RELOC_HI16_BASEREL:	r = R_PPC_SECTOFF_HI;		break;
    case BFD_RELOC_HI16_S_BASEREL:	r = R_PPC_SECTOFF_HA;		break;
    case BFD_RELOC_CTOR:		r = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC64_TOC16_DS:
    case BFD_RELOC_PPC_TOC16:		r = R_PPC_TOC16;		break;
    case BFD_RELOC_PPC_TLS:		r = R_PPC_TLS;			break;
    case BFD_RELOC_PPC_TLSGD:		r = R_PPC_TLSGD;		break;
    case BFD_RELOC_PPC_TLSLD:		r = R_PPC_TLSLD;		break;
    case BFD_RELOC_PPC_DTPMOD:		r = R_PPC_DTPMOD32;		break;
    case BFD_RELOC_PPC64_TPREL16_DS:
    case BFD_RELOC_PPC_TPREL16:		r = R_PPC_TPREL16;		break;
    case BFD_RELOC_PPC64_TPREL16_LO_DS:
    case BFD_RELOC_PPC_TPREL16_LO:	r = R_PPC_TPREL16_LO;		break;
    case BFD_RELOC_PPC_TPREL16_HI:	r = R_PPC_TPREL16_HI;		break;
    case BFD_RELOC_PPC_TPREL16_HA:	r = R_PPC_TPREL16_HA;		break;
    case BFD_RELOC_PPC_TPREL:		r = R_PPC_TPREL32;		break;
    case BFD_RELOC_PPC64_DTPREL16_DS:
    case BFD_RELOC_PPC_DTPREL16:	r = R_PPC_DTPREL16;		break;
    case BFD_RELOC_PPC64_DTPREL16_LO_DS:
    case BFD_RELOC_PPC_DTPREL16_LO:	r = R_PPC_DTPREL16_LO;		break;
    case BFD_RELOC_PPC_DTPREL16_HI:	r = R_PPC_DTPREL16_HI;		break;
    case BFD_RELOC_PPC_DTPREL16_HA:	r = R_PPC_DTPREL16_HA;		break;
    case BFD_RELOC_PPC_DTPREL:		r = R_PPC_DTPREL32;		break;
    case BFD_RELOC_PPC_GOT_TLSGD16:	r = R_PPC_GOT_TLSGD16;		break;
    case BFD_RELOC_PPC_GOT_TLSGD16_LO:	r = R_PPC_GOT_TLSGD16_LO;	break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HI:	r = R_PPC_GOT_TLSGD16_HI;	break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HA:	r = R_PPC_GOT_TLSGD16_HA;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16:	r = R_PPC_GOT_TLSLD16;		break;
    case BFD_RELOC_PPC_GOT_TLSLD16_LO:	r = R_PPC_GOT_TLSLD16_LO;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HI:	r = R_PPC_GOT_TLSLD16_HI;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HA:	r = R_PPC_GOT_TLSLD16_HA;	break;
    case BFD_RELOC_PPC_GOT_TPREL16:	r = R_PPC_GOT_TPREL16;		break;
    case BFD_RELOC_PPC_GOT_TPREL16_LO:	r = R_PPC_GOT_TPREL16_LO;	break;
    case BFD_RELOC_PPC_GOT_TPREL16_HI:	r = R_PPC_GOT_TPREL16_HI;	break;
    case BFD_RELOC_PPC_GOT_TPREL16_HA:	r = R_PPC_GOT_TPREL16_HA;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16:	r = R_PPC_GOT_DTPREL16;		break;
    case BFD_RELOC_PPC_GOT_DTPREL16_LO:	r = R_PPC_GOT_DTPREL16_LO;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HI:	r = R_PPC_GOT_DTPREL16_HI;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HA:	r = R_PPC_GOT_DTPREL16_HA;	break;
    case BFD_RELOC_PPC_EMB_NADDR32:	r = R_PPC_EMB_NADDR32;		break;
    case BFD_RELOC_PPC_EMB_NADDR16:	r = R_PPC_EMB_NADDR16;		break;
    case BFD_RELOC_PPC_EMB_NADDR16_LO:	r = R_PPC_EMB_NADDR16_LO;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HI:	r = R_PPC_EMB_NADDR16_HI;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HA:	r = R_PPC_EMB_NADDR16_HA;	break;
    case BFD_RELOC_PPC_EMB_SDAI16:	r = R_PPC_EMB_SDAI16;		break;
    case BFD_RELOC_PPC_EMB_SDA2I16:	r = R_PPC_EMB_SDA2I16;		break;
    case BFD_RELOC_PPC_EMB_SDA2REL:	r = R_PPC_EMB_SDA2REL;		break;
    case BFD_RELOC_PPC_EMB_SDA21:	r = R_PPC_EMB_SDA21;		break;
    case BFD_RELOC_PPC_EMB_MRKREF:	r = R_PPC_EMB_MRKREF;		break;
    case BFD_RELOC_PPC_EMB_RELSEC16:	r = R_PPC_EMB_RELSEC16;		break;
    case BFD_RELOC_PPC_EMB_RELST_LO:	r = R_PPC_EMB_RELST_LO;		break;
    case BFD_RELOC_PPC_EMB_RELST_HI:	r = R_PPC_EMB_RELST_HI;		break;
    case BFD_RELOC_PPC_EMB_RELST_HA:	r = R_PPC_EMB_RELST_HA;		break;
    case BFD_RELOC_PPC_EMB_BIT_FLD:	r = R_PPC_EMB_BIT_FLD;		break;
    case BFD_RELOC_PPC_EMB_RELSDA:	r = R_PPC_EMB_RELSDA;		break;
    case BFD_RELOC_PPC_VLE_REL8:	r = R_PPC_VLE_REL8;		break;
    case BFD_RELOC_PPC_VLE_REL15:	r = R_PPC_VLE_REL15;		break;
    case BFD_RELOC_PPC_VLE_REL24:	r = R_PPC_VLE_REL24;		break;
    case BFD_RELOC_PPC_VLE_LO16A:	r = R_PPC_VLE_LO16A;		break;
    case BFD_RELOC_PPC_VLE_LO16D:	r = R_PPC_VLE_LO16D;		break;
    case BFD_RELOC_PPC_VLE_HI16A:	r = R_PPC_VLE_HI16A;		break;
    case BFD_RELOC_PPC_VLE_HI16D:	r = R_PPC_VLE_HI16D;		break;
    case BFD_RELOC_PPC_VLE_HA16A:	r = R_PPC_VLE_HA16A;		break;
    case BFD_RELOC_PPC_VLE_HA16D:	r = R_PPC_VLE_HA16D;		break;
    case BFD_RELOC_PPC_VLE_SDA21:	r = R_PPC_VLE_SDA21;		break;
    case BFD_RELOC_PPC_VLE_SDA21_LO:	r = R_PPC_VLE_SDA21_LO;		break;
    case BFD_RELOC_PPC_VLE_SDAREL_LO16A:
      r = R_PPC_VLE_SDAREL_LO16A;
      break;
    case BFD_RELOC_PPC_VLE_SDAREL_LO16D:
      r = R_PPC_VLE_SDAREL_LO16D;
      break;
    case BFD_RELOC_PPC_VLE_SDAREL_HI16A:
      r = R_PPC_VLE_SDAREL_HI16A;
      break;
    case BFD_RELOC_PPC_VLE_SDAREL_HI16D:
      r = R_PPC_VLE_SDAREL_HI16D;
      break;
    case BFD_RELOC_PPC_VLE_SDAREL_HA16A:
      r = R_PPC_VLE_SDAREL_HA16A;
      break;
    case BFD_RELOC_PPC_VLE_SDAREL_HA16D:
      r = R_PPC_VLE_SDAREL_HA16D;
      break;
    case BFD_RELOC_16_PCREL:		r = R_PPC_REL16;		break;
    case BFD_RELOC_LO16_PCREL:		r = R_PPC_REL16_LO;		break;
    case BFD_RELOC_HI16_PCREL:		r = R_PPC_REL16_HI;		break;
    case BFD_RELOC_HI16_S_PCREL:	r = R_PPC_REL16_HA;		break;
    case BFD_RELOC_VTABLE_INHERIT:	r = R_PPC_GNU_VTINHERIT;	break;
    case BFD_RELOC_VTABLE_ENTRY:	r = R_PPC_GNU_VTENTRY;		break;
    }

  return ppc_elf_howto_table[r];
};

static reloc_howto_type *
ppc_elf_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (ppc_elf_howto_raw) / sizeof (ppc_elf_howto_raw[0]);
       i++)
    if (ppc_elf_howto_raw[i].name != NULL
	&& strcasecmp (ppc_elf_howto_raw[i].name, r_name) == 0)
      return &ppc_elf_howto_raw[i];

  return NULL;
}

/* Set the howto pointer for a PowerPC ELF reloc.  */

static void
ppc_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *cache_ptr,
		       Elf_Internal_Rela *dst)
{
  /* Initialize howto table if not already done.  */
  if (!ppc_elf_howto_table[R_PPC_ADDR32])
    ppc_elf_howto_init ();

  BFD_ASSERT (ELF32_R_TYPE (dst->r_info) < (unsigned int) R_PPC_max);
  cache_ptr->howto = ppc_elf_howto_table[ELF32_R_TYPE (dst->r_info)];

  /* Just because the above assert didn't trigger doesn't mean that
     ELF32_R_TYPE (dst->r_info) is necessarily a valid relocation.  */
  if (!cache_ptr->howto)
    {
      (*_bfd_error_handler) (_("%B: invalid relocation type %d"),
                             abfd, ELF32_R_TYPE (dst->r_info));
      bfd_set_error (bfd_error_bad_value);

      cache_ptr->howto = ppc_elf_howto_table[R_PPC_NONE];
    }
}

/* Handle the R_PPC_ADDR16_HA and R_PPC_REL16_HA relocs.  */

static bfd_reloc_status_type
ppc_elf_addr16_ha_reloc (bfd *abfd ATTRIBUTE_UNUSED,
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void *data ATTRIBUTE_UNUSED,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message ATTRIBUTE_UNUSED)
{
  bfd_vma relocation;

  if (output_bfd != NULL)
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;

  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
  if (reloc_entry->howto->pc_relative)
    relocation -= reloc_entry->address;

  reloc_entry->addend += (relocation & 0x8000) << 1;

  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc_elf_unhandled_reloc (bfd *abfd,
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void *data,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message)
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  if (error_message != NULL)
    {
      static char buf[60];
      sprintf (buf, _("generic linker can't handle %s"),
	       reloc_entry->howto->name);
      *error_message = buf;
    }
  return bfd_reloc_dangerous;
}

/* Sections created by the linker.  */

typedef struct elf_linker_section
{
  /* Pointer to the bfd section.  */
  asection *section;
  /* Section name.  */
  const char *name;
  /* Associated bss section name.  */
  const char *bss_name;
  /* Associated symbol name.  */
  const char *sym_name;
  /* Associated symbol.  */
  struct elf_link_hash_entry *sym;
} elf_linker_section_t;

/* Linked list of allocated pointer entries.  This hangs off of the
   symbol lists, and provides allows us to return different pointers,
   based on different addend's.  */

typedef struct elf_linker_section_pointers
{
  /* next allocated pointer for this symbol */
  struct elf_linker_section_pointers *next;
  /* offset of pointer from beginning of section */
  bfd_vma offset;
  /* addend used */
  bfd_vma addend;
  /* which linker section this is */
  elf_linker_section_t *lsect;
} elf_linker_section_pointers_t;

struct ppc_elf_obj_tdata
{
  struct elf_obj_tdata elf;

  /* A mapping from local symbols to offsets into the various linker
     sections added.  This is index by the symbol index.  */
  elf_linker_section_pointers_t **linker_section_pointers;

  /* Flags used to auto-detect plt type.  */
  unsigned int makes_plt_call : 1;
  unsigned int has_rel16 : 1;
};

#define ppc_elf_tdata(bfd) \
  ((struct ppc_elf_obj_tdata *) (bfd)->tdata.any)

#define elf_local_ptr_offsets(bfd) \
  (ppc_elf_tdata (bfd)->linker_section_pointers)

#define is_ppc_elf(bfd) \
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour \
   && elf_object_id (bfd) == PPC32_ELF_DATA)

/* Override the generic function because we store some extras.  */

static bfd_boolean
ppc_elf_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct ppc_elf_obj_tdata),
				  PPC32_ELF_DATA);
}

/* Fix bad default arch selected for a 32 bit input bfd when the
   default is 64 bit.  */

static bfd_boolean
ppc_elf_object_p (bfd *abfd)
{
  if (abfd->arch_info->the_default && abfd->arch_info->bits_per_word == 64)
    {
      Elf_Internal_Ehdr *i_ehdr = elf_elfheader (abfd);

      if (i_ehdr->e_ident[EI_CLASS] == ELFCLASS32)
	{
	  /* Relies on arch after 64 bit default being 32 bit default.  */
	  abfd->arch_info = abfd->arch_info->next;
	  BFD_ASSERT (abfd->arch_info->bits_per_word == 32);
	}
    }
  return TRUE;
}

/* Function to set whether a module needs the -mrelocatable bit set.  */

static bfd_boolean
ppc_elf_set_private_flags (bfd *abfd, flagword flags)
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);

  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}

/* Support for core dump NOTE sections.  */

static bfd_boolean
ppc_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  unsigned int size;

  switch (note->descsz)
    {
    default:
      return FALSE;

    case 268:		/* Linux/PPC.  */
      /* pr_cursig */
      elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

      /* pr_pid */
      elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 24);

      /* pr_reg */
      offset = 72;
      size = 192;

      break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
ppc_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
    default:
      return FALSE;

    case 128:		/* Linux/PPC elf_prpsinfo.  */
      elf_tdata (abfd)->core->pid
	= bfd_get_32 (abfd, note->descdata + 16);
      elf_tdata (abfd)->core->program
	= _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
      elf_tdata (abfd)->core->command
	= _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

char *
elfcore_write_ppc_linux_prpsinfo32 (bfd *abfd, char *buf, int *bufsiz,
				      const struct elf_internal_linux_prpsinfo *prpsinfo)
{
  struct elf_external_ppc_linux_prpsinfo32 data;

  memset (&data, 0, sizeof (data));
  PPC_LINUX_PRPSINFO32_SWAP_FIELDS (abfd, prpsinfo, data);

  return elfcore_write_note (abfd, buf, bufsiz,
			     "CORE", NT_PRPSINFO, &data, sizeof (data));
}

static char *
ppc_elf_write_core_note (bfd *abfd, char *buf, int *bufsiz, int note_type, ...)
{
  switch (note_type)
    {
    default:
      return NULL;

    case NT_PRPSINFO:
      {
	char data[128];
	va_list ap;

	va_start (ap, note_type);
	memset (data, 0, sizeof (data));
	strncpy (data + 32, va_arg (ap, const char *), 16);
	strncpy (data + 48, va_arg (ap, const char *), 80);
	va_end (ap);
	return elfcore_write_note (abfd, buf, bufsiz,
				   "CORE", note_type, data, sizeof (data));
      }

    case NT_PRSTATUS:
      {
	char data[268];
	va_list ap;
	long pid;
	int cursig;
	const void *greg;

	va_start (ap, note_type);
	memset (data, 0, 72);
	pid = va_arg (ap, long);
	bfd_put_32 (abfd, pid, data + 24);
	cursig = va_arg (ap, int);
	bfd_put_16 (abfd, cursig, data + 12);
	greg = va_arg (ap, const void *);
	memcpy (data + 72, greg, 192);
	memset (data + 264, 0, 4);
	va_end (ap);
	return elfcore_write_note (abfd, buf, bufsiz,
				   "CORE", note_type, data, sizeof (data));
      }
    }
}

static flagword
ppc_elf_lookup_section_flags (char *flag_name)
{

  if (!strcmp (flag_name, "SHF_PPC_VLE"))
    return SHF_PPC_VLE;

  return 0;
}

/* Add the VLE flag if required.  */

bfd_boolean
ppc_elf_section_processing (bfd *abfd, Elf_Internal_Shdr *shdr)
{
  if (bfd_get_mach (abfd) == bfd_mach_ppc_vle
      && (shdr->sh_flags & SHF_EXECINSTR) != 0)
    shdr->sh_flags |= SHF_PPC_VLE;

  return TRUE;
}

/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
ppc_elf_plt_sym_val (bfd_vma i ATTRIBUTE_UNUSED,
		     const asection *plt ATTRIBUTE_UNUSED,
		     const arelent *rel)
{
  return rel->address;
}

/* Handle a PowerPC specific section when reading an object file.  This
   is called when bfd_section_from_shdr finds a section with an unknown
   type.  */

static bfd_boolean
ppc_elf_section_from_shdr (bfd *abfd,
			   Elf_Internal_Shdr *hdr,
			   const char *name,
			   int shindex)
{
  asection *newsect;
  flagword flags;

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;

  newsect = hdr->bfd_section;
  flags = bfd_get_section_flags (abfd, newsect);
  if (hdr->sh_flags & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;

  if (hdr->sh_type == SHT_ORDERED)
    flags |= SEC_SORT_ENTRIES;

  bfd_set_section_flags (abfd, newsect, flags);
  return TRUE;
}

/* Set up any other section flags and such that may be necessary.  */

static bfd_boolean
ppc_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
		       Elf_Internal_Shdr *shdr,
		       asection *asect)
{
  if ((asect->flags & SEC_SORT_ENTRIES) != 0)
    shdr->sh_type = SHT_ORDERED;

  return TRUE;
}

/* If we have .sbss2 or .PPC.EMB.sbss0 output sections, we
   need to bump up the number of section headers.  */

static int
ppc_elf_additional_program_headers (bfd *abfd,
				    struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  asection *s;
  int ret = 0;

  s = bfd_get_section_by_name (abfd, ".sbss2");
  if (s != NULL && (s->flags & SEC_ALLOC) != 0)
    ++ret;

  s = bfd_get_section_by_name (abfd, ".PPC.EMB.sbss0");
  if (s != NULL && (s->flags & SEC_ALLOC) != 0)
    ++ret;

  return ret;
}

/* Modify the segment map for VLE executables.  */

bfd_boolean
ppc_elf_modify_segment_map (bfd *abfd,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  struct elf_segment_map *m, *n;
  bfd_size_type amt;
  unsigned int j, k;
  bfd_boolean sect0_vle, sectj_vle;

  /* At this point in the link, output sections have already been sorted by
     LMA and assigned to segments.  All that is left to do is to ensure
     there is no mixing of VLE & non-VLE sections in a text segment.
     If we find that case, we split the segment.
     We maintain the original output section order.  */

  for (m = elf_seg_map (abfd); m != NULL; m = m->next)
    {
      if (m->count == 0)
	continue;

      sect0_vle = (elf_section_flags (m->sections[0]) & SHF_PPC_VLE) != 0;
      for (j = 1; j < m->count; ++j)
	{
	  sectj_vle = (elf_section_flags (m->sections[j]) & SHF_PPC_VLE) != 0;

	  if (sectj_vle != sect0_vle)
	    break;
        }
      if (j >= m->count)
	continue;

      /* sections 0..j-1 stay in this (current) segment,
	 the remainder are put in a new segment.
	 The scan resumes with the new segment.  */

      /* Fix the new segment.  */
      amt = sizeof (struct elf_segment_map);
      amt += (m->count - j - 1) * sizeof (asection *);
      n = (struct elf_segment_map *) bfd_zalloc (abfd, amt);
      if (n == NULL)
        return FALSE;

      n->p_type = PT_LOAD;
      n->p_flags = PF_X | PF_R;
      if (sectj_vle)
        n->p_flags |= PF_PPC_VLE;
      n->count = m->count - j;
      for (k = 0; k < n->count; ++k)
        {
          n->sections[k] = m->sections[j+k];
          m->sections[j+k] = NULL;
	}
      n->next = m->next;
      m->next = n;

      /* Fix the current segment  */
      m->count = j;
    }

  return TRUE;
}

/* Add extra PPC sections -- Note, for now, make .sbss2 and
   .PPC.EMB.sbss0 a normal section, and not a bss section so
   that the linker doesn't crater when trying to make more than
   2 sections.  */

static const struct bfd_elf_special_section ppc_elf_special_sections[] =
{
  { STRING_COMMA_LEN (".plt"),             0, SHT_NOBITS,   SHF_ALLOC + SHF_EXECINSTR },
  { STRING_COMMA_LEN (".sbss"),           -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".sbss2"),          -2, SHT_PROGBITS, SHF_ALLOC },
  { STRING_COMMA_LEN (".sdata"),          -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { STRING_COMMA_LEN (".sdata2"),         -2, SHT_PROGBITS, SHF_ALLOC },
  { STRING_COMMA_LEN (".tags"),            0, SHT_ORDERED,  SHF_ALLOC },
  { STRING_COMMA_LEN (".PPC.EMB.apuinfo"), 0, SHT_NOTE,     0 },
  { STRING_COMMA_LEN (".PPC.EMB.sbss0"),   0, SHT_PROGBITS, SHF_ALLOC },
  { STRING_COMMA_LEN (".PPC.EMB.sdata0"),  0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,                              0,  0, 0,            0 }
};

/* This is what we want for new plt/got.  */
static struct bfd_elf_special_section ppc_alt_plt =
  { STRING_COMMA_LEN (".plt"),             0, SHT_PROGBITS, SHF_ALLOC };

static const struct bfd_elf_special_section *
ppc_elf_get_sec_type_attr (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  const struct bfd_elf_special_section *ssect;

  /* See if this is one of the special sections.  */
  if (sec->name == NULL)
    return NULL;

  ssect = _bfd_elf_get_special_section (sec->name, ppc_elf_special_sections,
					sec->use_rela_p);
  if (ssect != NULL)
    {
      if (ssect == ppc_elf_special_sections && (sec->flags & SEC_LOAD) != 0)
	ssect = &ppc_alt_plt;
      return ssect;
    }

  return _bfd_elf_get_sec_type_attr (abfd, sec);
}

/* Very simple linked list structure for recording apuinfo values.  */
typedef struct apuinfo_list
{
  struct apuinfo_list *next;
  unsigned long value;
}
apuinfo_list;

static apuinfo_list *head;
static bfd_boolean apuinfo_set;

static void
apuinfo_list_init (void)
{
  head = NULL;
  apuinfo_set = FALSE;
}

static void
apuinfo_list_add (unsigned long value)
{
  apuinfo_list *entry = head;

  while (entry != NULL)
    {
      if (entry->value == value)
	return;
      entry = entry->next;
    }

  entry = bfd_malloc (sizeof (* entry));
  if (entry == NULL)
    return;

  entry->value = value;
  entry->next  = head;
  head = entry;
}

static unsigned
apuinfo_list_length (void)
{
  apuinfo_list *entry;
  unsigned long count;

  for (entry = head, count = 0;
       entry;
       entry = entry->next)
    ++ count;

  return count;
}

static inline unsigned long
apuinfo_list_element (unsigned long number)
{
  apuinfo_list * entry;

  for (entry = head;
       entry && number --;
       entry = entry->next)
    ;

  return entry ? entry->value : 0;
}

static void
apuinfo_list_finish (void)
{
  apuinfo_list *entry;

  for (entry = head; entry;)
    {
      apuinfo_list *next = entry->next;
      free (entry);
      entry = next;
    }

  head = NULL;
}

#define APUINFO_SECTION_NAME	".PPC.EMB.apuinfo"
#define APUINFO_LABEL		"APUinfo"

/* Scan the input BFDs and create a linked list of
   the APUinfo values that will need to be emitted.  */

static void
ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)
{
  bfd *ibfd;
  asection *asec;
  char *buffer = NULL;
  bfd_size_type largest_input_size = 0;
  unsigned i;
  unsigned long length;
  const char *error_message = NULL;

  if (link_info == NULL)
    return;

  apuinfo_list_init ();

  /* Read in the input sections contents.  */
  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      unsigned long datum;

      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);
      if (asec == NULL)
	continue;

      error_message = _("corrupt %s section in %B");
      length = asec->size;
      if (length < 20)
	goto fail;

      apuinfo_set = TRUE;
      if (largest_input_size < asec->size)
	{
	  if (buffer)
	    free (buffer);
	  largest_input_size = asec->size;
	  buffer = bfd_malloc (largest_input_size);
	  if (!buffer)
	    return;
	}

      if (bfd_seek (ibfd, asec->filepos, SEEK_SET) != 0
	  || (bfd_bread (buffer, length, ibfd) != length))
	{
	  error_message = _("unable to read in %s section from %B");
	  goto fail;
	}

      /* Verify the contents of the header.  Note - we have to
	 extract the values this way in order to allow for a
	 host whose endian-ness is different from the target.  */
      datum = bfd_get_32 (ibfd, buffer);
      if (datum != sizeof APUINFO_LABEL)
	goto fail;

      datum = bfd_get_32 (ibfd, buffer + 8);
      if (datum != 0x2)
	goto fail;

      if (strcmp (buffer + 12, APUINFO_LABEL) != 0)
	goto fail;

      /* Get the number of bytes used for apuinfo entries.  */
      datum = bfd_get_32 (ibfd, buffer + 4);
      if (datum + 20 != length)
	goto fail;

      /* Scan the apuinfo section, building a list of apuinfo numbers.  */
      for (i = 0; i < datum; i += 4)
	apuinfo_list_add (bfd_get_32 (ibfd, buffer + 20 + i));
    }

  error_message = NULL;

  if (apuinfo_set)
    {
      /* Compute the size of the output section.  */
      unsigned num_entries = apuinfo_list_length ();

      /* Set the output section size, if it exists.  */
      asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);

      if (asec && ! bfd_set_section_size (abfd, asec, 20 + num_entries * 4))
	{
	  ibfd = abfd;
	  error_message = _("warning: unable to set size of %s section in %B");
	}
    }

 fail:
  if (buffer)
    free (buffer);

  if (error_message)
    (*_bfd_error_handler) (error_message, ibfd, APUINFO_SECTION_NAME);
}

/* Prevent the output section from accumulating the input sections'
   contents.  We have already stored this in our linked list structure.  */

static bfd_boolean
ppc_elf_write_section (bfd *abfd ATTRIBUTE_UNUSED,
		       struct bfd_link_info *link_info ATTRIBUTE_UNUSED,
		       asection *asec,
		       bfd_byte *contents ATTRIBUTE_UNUSED)
{
  return apuinfo_set && strcmp (asec->name, APUINFO_SECTION_NAME) == 0;
}

/* Finally we can generate the output section.  */

static void
ppc_elf_final_write_processing (bfd *abfd, bfd_boolean linker ATTRIBUTE_UNUSED)
{
  bfd_byte *buffer;
  asection *asec;
  unsigned i;
  unsigned num_entries;
  bfd_size_type length;

  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);
  if (asec == NULL)
    return;

  if (!apuinfo_set)
    return;

  length = asec->size;
  if (length < 20)
    return;

  buffer = bfd_malloc (length);
  if (buffer == NULL)
    {
      (*_bfd_error_handler)
	(_("failed to allocate space for new APUinfo section."));
      return;
    }

  /* Create the apuinfo header.  */
  num_entries = apuinfo_list_length ();
  bfd_put_32 (abfd, sizeof APUINFO_LABEL, buffer);
  bfd_put_32 (abfd, num_entries * 4, buffer + 4);
  bfd_put_32 (abfd, 0x2, buffer + 8);
  strcpy ((char *) buffer + 12, APUINFO_LABEL);

  length = 20;
  for (i = 0; i < num_entries; i++)
    {
      bfd_put_32 (abfd, apuinfo_list_element (i), buffer + length);
      length += 4;
    }

  if (length != asec->size)
    (*_bfd_error_handler) (_("failed to compute new APUinfo section."));

  if (! bfd_set_section_contents (abfd, asec, buffer, (file_ptr) 0, length))
    (*_bfd_error_handler) (_("failed to install new APUinfo section."));

  free (buffer);

  apuinfo_list_finish ();
}

static bfd_boolean
is_nonpic_glink_stub (bfd *abfd, asection *glink, bfd_vma off)
{
  bfd_byte buf[GLINK_ENTRY_SIZE];

  if (!bfd_get_section_contents (abfd, glink, buf, off, GLINK_ENTRY_SIZE))
    return FALSE;

  return ((bfd_get_32 (abfd, buf + 0) & 0xffff0000) == LIS_11
	  && (bfd_get_32 (abfd, buf + 4) & 0xffff0000) == LWZ_11_11
	  && bfd_get_32 (abfd, buf + 8) == MTCTR_11
	  && bfd_get_32 (abfd, buf + 12) == BCTR);
}

static bfd_boolean
section_covers_vma (bfd *abfd ATTRIBUTE_UNUSED, asection *section, void *ptr)
{
  bfd_vma vma = *(bfd_vma *) ptr;
  return ((section->flags & SEC_ALLOC) != 0
	  && section->vma <= vma
	  && vma < section->vma + section->size);
}

static long
ppc_elf_get_synthetic_symtab (bfd *abfd, long symcount, asymbol **syms,
			      long dynsymcount, asymbol **dynsyms,
			      asymbol **ret)
{
  bfd_boolean (*slurp_relocs) (bfd *, asection *, asymbol **, bfd_boolean);
  asection *plt, *relplt, *dynamic, *glink;
  bfd_vma glink_vma = 0;
  bfd_vma resolv_vma = 0;
  bfd_vma stub_vma;
  asymbol *s;
  arelent *p;
  long count, i;
  size_t size;
  char *names;
  bfd_byte buf[4];

  *ret = NULL;

  if ((abfd->flags & (DYNAMIC | EXEC_P)) == 0)
    return 0;

  if (dynsymcount <= 0)
    return 0;

  relplt = bfd_get_section_by_name (abfd, ".rela.plt");
  if (relplt == NULL)
    return 0;

  plt = bfd_get_section_by_name (abfd, ".plt");
  if (plt == NULL)
    return 0;

  /* Call common code to handle old-style executable PLTs.  */
  if (elf_section_flags (plt) & SHF_EXECINSTR)
    return _bfd_elf_get_synthetic_symtab (abfd, symcount, syms,
					  dynsymcount, dynsyms, ret);

  /* If this object was prelinked, the prelinker stored the address
     of .glink at got[1].  If it wasn't prelinked, got[1] will be zero.  */
  dynamic = bfd_get_section_by_name (abfd, ".dynamic");
  if (dynamic != NULL)
    {
      bfd_byte *dynbuf, *extdyn, *extdynend;
      size_t extdynsize;
      void (*swap_dyn_in) (bfd *, const void *, Elf_Internal_Dyn *);

      if (!bfd_malloc_and_get_section (abfd, dynamic, &dynbuf))
	return -1;

      extdynsize = get_elf_backend_data (abfd)->s->sizeof_dyn;
      swap_dyn_in = get_elf_backend_data (abfd)->s->swap_dyn_in;

      extdyn = dynbuf;
      extdynend = extdyn + dynamic->size;
      for (; extdyn < extdynend; extdyn += extdynsize)
	{
	  Elf_Internal_Dyn dyn;
	  (*swap_dyn_in) (abfd, extdyn, &dyn);

	  if (dyn.d_tag == DT_NULL)
	    break;

	  if (dyn.d_tag == DT_PPC_GOT)
	    {
	      unsigned int g_o_t = dyn.d_un.d_val;
	      asection *got = bfd_get_section_by_name (abfd, ".got");
	      if (got != NULL
		  && bfd_get_section_contents (abfd, got, buf,
					       g_o_t - got->vma + 4, 4))
		glink_vma = bfd_get_32 (abfd, buf);
	      break;
	    }
	}
      free (dynbuf);
    }

  /* Otherwise we read the first plt entry.  */
  if (glink_vma == 0)
    {
      if (bfd_get_section_contents (abfd, plt, buf, 0, 4))
	glink_vma = bfd_get_32 (abfd, buf);
    }

  if (glink_vma == 0)
    return 0;

  /* The .glink section usually does not survive the final
     link; search for the section (usually .text) where the
     glink stubs now reside.  */
  glink = bfd_sections_find_if (abfd, section_covers_vma, &glink_vma);
  if (glink == NULL)
    return 0;

  /* Determine glink PLT resolver by reading the relative branch
     from the first glink stub.  */
  if (bfd_get_section_contents (abfd, glink, buf,
				glink_vma - glink->vma, 4))
    {
      unsigned int insn = bfd_get_32 (abfd, buf);

      /* The first glink stub may either branch to the resolver ...  */
      insn ^= B;
      if ((insn & ~0x3fffffc) == 0)
	resolv_vma = glink_vma + (insn ^ 0x2000000) - 0x2000000;

      /* ... or fall through a bunch of NOPs.  */
      else if ((insn ^ B ^ NOP) == 0)
	for (i = 4;
	     bfd_get_section_contents (abfd, glink, buf,
				       glink_vma - glink->vma + i, 4);
	     i += 4)
	  if (bfd_get_32 (abfd, buf) != NOP)
	    {
	      resolv_vma = glink_vma + i;
	      break;
	    }
    }

  count = relplt->size / sizeof (Elf32_External_Rela);
  stub_vma = glink_vma - (bfd_vma) count * 16;
  /* If the stubs are those for -shared/-pie then we might have
     multiple stubs for each plt entry.  If that is the case then
     there is no way to associate stubs with their plt entries short
     of figuring out the GOT pointer value used in the stub.  */
  if (!is_nonpic_glink_stub (abfd, glink,
			     glink_vma - GLINK_ENTRY_SIZE - glink->vma))
    return 0;

  slurp_relocs = get_elf_backend_data (abfd)->s->slurp_reloc_table;
  if (! (*slurp_relocs) (abfd, relplt, dynsyms, TRUE))
    return -1;

  size = count * sizeof (asymbol);
  p = relplt->relocation;
  for (i = 0; i < count; i++, p++)
    {
      size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@@plt");
      if (p->addend != 0)
	size += sizeof ("+0x") - 1 + 8;
    }

  size += sizeof (asymbol) + sizeof ("__glink");

  if (resolv_vma)
    size += sizeof (asymbol) + sizeof ("__glink_PLTresolve");

  s = *ret = bfd_malloc (size);
  if (s == NULL)
    return -1;

  names = (char *) (s + count + 1 + (resolv_vma != 0));
  p = relplt->relocation;
  for (i = 0; i < count; i++, p++)
    {
      size_t len;

      *s = **p->sym_ptr_ptr;
      /* Undefined syms won't have BSF_LOCAL or BSF_GLOBAL set.  Since
	 we are defining a symbol, ensure one of them is set.  */
      if ((s->flags & BSF_LOCAL) == 0)
	s->flags |= BSF_GLOBAL;
      s->flags |= BSF_SYNTHETIC;
      s->section = glink;
      s->value = stub_vma - glink->vma;
      s->name = names;
      s->udata.p = NULL;
      len = strlen ((*p->sym_ptr_ptr)->name);
      memcpy (names, (*p->sym_ptr_ptr)->name, len);
      names += len;
      if (p->addend != 0)
	{
	  memcpy (names, "+0x", sizeof ("+0x") - 1);
	  names += sizeof ("+0x") - 1;
	  bfd_sprintf_vma (abfd, names, p->addend);
	  names += strlen (names);
	}
      memcpy (names, "@@plt", sizeof ("@@plt"));
      names += sizeof ("@@plt");
      ++s;
      stub_vma += 16;
    }

  /* Add a symbol at the start of the glink branch table.  */
  memset (s, 0, sizeof *s);
  s->the_bfd = abfd;
  s->flags = BSF_GLOBAL | BSF_SYNTHETIC;
  s->section = glink;
  s->value = glink_vma - glink->vma;
  s->name = names;
  memcpy (names, "__glink", sizeof ("__glink"));
  names += sizeof ("__glink");
  s++;
  count++;

  if (resolv_vma)
    {
      /* Add a symbol for the glink PLT resolver.  */
      memset (s, 0, sizeof *s);
      s->the_bfd = abfd;
      s->flags = BSF_GLOBAL | BSF_SYNTHETIC;
      s->section = glink;
      s->value = resolv_vma - glink->vma;
      s->name = names;
      memcpy (names, "__glink_PLTresolve", sizeof ("__glink_PLTresolve"));
      names += sizeof ("__glink_PLTresolve");
      s++;
      count++;
    }

  return count;
}

/* The following functions are specific to the ELF linker, while
   functions above are used generally.  They appear in this file more
   or less in the order in which they are called.  eg.
   ppc_elf_check_relocs is called early in the link process,
   ppc_elf_finish_dynamic_sections is one of the last functions
   called.  */

/* Track PLT entries needed for a given symbol.  We might need more
   than one glink entry per symbol when generating a pic binary.  */
struct plt_entry
{
  struct plt_entry *next;

  /* -fPIC uses multiple GOT sections, one per file, called ".got2".
     This field stores the offset into .got2 used to initialise the
     GOT pointer reg.  It will always be at least 32768.  (Current
     gcc always uses an offset of 32768, but ld -r will pack .got2
     sections together resulting in larger offsets).  */
  bfd_vma addend;

  /* The .got2 section.  */
  asection *sec;

  /* PLT refcount or offset.  */
  union
    {
      bfd_signed_vma refcount;
      bfd_vma offset;
    } plt;

  /* .glink stub offset.  */
  bfd_vma glink_offset;
};

/* Of those relocs that might be copied as dynamic relocs, this function
   selects those that must be copied when linking a shared library,
   even when the symbol is local.  */

static int
must_be_dyn_reloc (struct bfd_link_info *info,
		   enum elf_ppc_reloc_type r_type)
{
  switch (r_type)
    {
    default:
      return 1;

    case R_PPC_REL24:
    case R_PPC_REL14:
    case R_PPC_REL14_BRTAKEN:
    case R_PPC_REL14_BRNTAKEN:
    case R_PPC_REL32:
      return 0;

    case R_PPC_TPREL32:
    case R_PPC_TPREL16:
    case R_PPC_TPREL16_LO:
    case R_PPC_TPREL16_HI:
    case R_PPC_TPREL16_HA:
      return !info->executable;
    }
}

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

/* Used to track dynamic relocations for local symbols.  */
struct ppc_dyn_relocs
{
  struct ppc_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  unsigned int count : 31;

  /* Whether this entry is for STT_GNU_IFUNC symbols.  */
  unsigned int ifunc : 1;
};

/* PPC ELF linker hash entry.  */

struct ppc_elf_link_hash_entry
{
  struct elf_link_hash_entry elf;

  /* If this symbol is used in the linker created sections, the processor
     specific backend uses this field to map the field into the offset
     from the beginning of the section.  */
  elf_linker_section_pointers_t *linker_section_pointer;

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_dyn_relocs *dyn_relocs;

  /* Contexts in which symbol is used in the GOT (or TOC).
     TLS_GD .. TLS_TLS bits are or'd into the mask as the
     corresponding relocs are encountered during check_relocs.
     tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to
     indicate the corresponding GOT entry type is not needed.  */
#define TLS_GD		 1	/* GD reloc. */
#define TLS_LD		 2	/* LD reloc. */
#define TLS_TPREL	 4	/* TPREL reloc, => IE. */
#define TLS_DTPREL	 8	/* DTPREL reloc, => LD. */
#define TLS_TLS		16	/* Any TLS reloc.  */
#define TLS_TPRELGD	32	/* TPREL reloc resulting from GD->IE. */
#define PLT_IFUNC	64	/* STT_GNU_IFUNC.  */
  char tls_mask;

  /* Nonzero if we have seen a small data relocation referring to this
     symbol.  */
  unsigned char has_sda_refs;
};

#define ppc_elf_hash_entry(ent) ((struct ppc_elf_link_hash_entry *) (ent))

/* PPC ELF linker hash table.  */

struct ppc_elf_link_hash_table
{
  struct elf_link_hash_table elf;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *got;
  asection *relgot;
  asection *glink;
  asection *plt;
  asection *relplt;
  asection *iplt;
  asection *reliplt;
  asection *dynbss;
  asection *relbss;
  asection *dynsbss;
  asection *relsbss;
  elf_linker_section_t sdata[2];
  asection *sbss;
  asection *glink_eh_frame;

  /* The (unloaded but important) .rela.plt.unloaded on VxWorks.  */
  asection *srelplt2;

  /* The .got.plt section (VxWorks only)*/
  asection *sgotplt;

  /* Shortcut to __tls_get_addr.  */
  struct elf_link_hash_entry *tls_get_addr;

  /* The bfd that forced an old-style PLT.  */
  bfd *old_bfd;

  /* TLS local dynamic got entry handling.  */
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tlsld_got;

  /* Offset of branch table to PltResolve function in glink.  */
  bfd_vma glink_pltresolve;

  /* Size of reserved GOT entries.  */
  unsigned int got_header_size;
  /* Non-zero if allocating the header left a gap.  */
  unsigned int got_gap;

  /* The type of PLT we have chosen to use.  */
  enum ppc_elf_plt_type plt_type;

  /* Set if we should emit symbols for stubs.  */
  unsigned int emit_stub_syms:1;

  /* Set if __tls_get_addr optimization should not be done.  */
  unsigned int no_tls_get_addr_opt:1;

  /* True if the target system is VxWorks.  */
  unsigned int is_vxworks:1;

  /* The size of PLT entries.  */
  int plt_entry_size;
  /* The distance between adjacent PLT slots.  */
  int plt_slot_size;
  /* The size of the first PLT entry.  */
  int plt_initial_entry_size;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;
};

/* Rename some of the generic section flags to better document how they
   are used for ppc32.  The flags are only valid for ppc32 elf objects.  */

/* Nonzero if this section has TLS related relocations.  */
#define has_tls_reloc sec_flg0

/* Nonzero if this section has a call to __tls_get_addr.  */
#define has_tls_get_addr_call sec_flg1

/* Get the PPC ELF linker hash table from a link_info structure.  */

#define ppc_elf_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == PPC32_ELF_DATA ? ((struct ppc_elf_link_hash_table *) ((p)->hash)) : NULL)

/* Create an entry in a PPC ELF linker hash table.  */

static struct bfd_hash_entry *
ppc_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			   struct bfd_hash_table *table,
			   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct ppc_elf_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      ppc_elf_hash_entry (entry)->linker_section_pointer = NULL;
      ppc_elf_hash_entry (entry)->dyn_relocs = NULL;
      ppc_elf_hash_entry (entry)->tls_mask = 0;
      ppc_elf_hash_entry (entry)->has_sda_refs = 0;
    }

  return entry;
}

/* Create a PPC ELF linker hash table.  */

static struct bfd_link_hash_table *
ppc_elf_link_hash_table_create (bfd *abfd)
{
  struct ppc_elf_link_hash_table *ret;

  ret = bfd_zmalloc (sizeof (struct ppc_elf_link_hash_table));
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd,
				      ppc_elf_link_hash_newfunc,
				      sizeof (struct ppc_elf_link_hash_entry),
				      PPC32_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  ret->elf.init_plt_refcount.refcount = 0;
  ret->elf.init_plt_refcount.glist = NULL;
  ret->elf.init_plt_offset.offset = 0;
  ret->elf.init_plt_offset.glist = NULL;

  ret->sdata[0].name = ".sdata";
  ret->sdata[0].sym_name = "_SDA_BASE_";
  ret->sdata[0].bss_name = ".sbss";

  ret->sdata[1].name = ".sdata2";
  ret->sdata[1].sym_name = "_SDA2_BASE_";
  ret->sdata[1].bss_name = ".sbss2";

  ret->plt_entry_size = 12;
  ret->plt_slot_size = 8;
  ret->plt_initial_entry_size = 72;

  return &ret->elf.root;
}

/* Create .got and the related sections.  */

static bfd_boolean
ppc_elf_create_got (bfd *abfd, struct bfd_link_info *info)
{
  struct ppc_elf_link_hash_table *htab;
  asection *s;
  flagword flags;

  if (!_bfd_elf_create_got_section (abfd, info))
    return FALSE;

  htab = ppc_elf_hash_table (info);
  htab->got = s = bfd_get_linker_section (abfd, ".got");
  if (s == NULL)
    abort ();

  if (htab->is_vxworks)
    {
      htab->sgotplt = bfd_get_linker_section (abfd, ".got.plt");
      if (!htab->sgotplt)
	abort ();
    }
  else
    {
      /* The powerpc .got has a blrl instruction in it.  Mark it
	 executable.  */
      flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS
	       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      if (!bfd_set_section_flags (abfd, s, flags))
	return FALSE;
    }

  htab->relgot = bfd_get_linker_section (abfd, ".rela.got");
  if (!htab->relgot)
    abort ();

  return TRUE;
}

static bfd_boolean
ppc_elf_create_glink (bfd *abfd, struct bfd_link_info *info)
{
  struct ppc_elf_link_hash_table *htab = ppc_elf_hash_table (info);
  asection *s;
  flagword flags;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY | SEC_HAS_CONTENTS
	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  s = bfd_make_section_anyway_with_flags (abfd, ".glink", flags);
  htab->glink = s;
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 4))
    return FALSE;

  if (!info->no_ld_generated_unwind_info)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS
	       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      s = bfd_make_section_anyway_with_flags (abfd, ".eh_frame", flags);
      htab->glink_eh_frame = s;
      if (s == NULL
	  || !bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
    }

  flags = SEC_ALLOC | SEC_LINKER_CREATED;
  s = bfd_make_section_anyway_with_flags (abfd, ".iplt", flags);
  htab->iplt = s;
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 4))
    return FALSE;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS
	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);
  s = bfd_make_section_anyway_with_flags (abfd, ".rela.iplt", flags);
  htab->reliplt = s;
  if (s == NULL
      || ! bfd_set_section_alignment (abfd, s, 2))
    return FALSE;
  return TRUE;
}

/* We have to create .dynsbss and .rela.sbss here so that they get mapped
   to output sections (just like _bfd_elf_create_dynamic_sections has
   to create .dynbss and .rela.bss).  */

static bfd_boolean
ppc_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  struct ppc_elf_link_hash_table *htab;
  asection *s;
  flagword flags;

  htab = ppc_elf_hash_table (info);

  if (htab->got == NULL
      && !ppc_elf_create_got (abfd, info))
    return FALSE;

  if (!_bfd_elf_create_dynamic_sections (abfd, info))
    return FALSE;

  if (htab->glink == NULL
      && !ppc_elf_create_glink (abfd, info))
    return FALSE;

  htab->dynbss = bfd_get_linker_section (abfd, ".dynbss");
  s = bfd_make_section_anyway_with_flags (abfd, ".dynsbss",
					  SEC_ALLOC | SEC_LINKER_CREATED);
  htab->dynsbss = s;
  if (s == NULL)
    return FALSE;

  if (! info->shared)
    {
      htab->relbss = bfd_get_linker_section (abfd, ".rela.bss");
      flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS
	       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
      s = bfd_make_section_anyway_with_flags (abfd, ".rela.sbss", flags);
      htab->relsbss = s;
      if (s == NULL
	  || ! bfd_set_section_alignment (abfd, s, 2))
	return FALSE;
    }

  if (htab->is_vxworks
      && !elf_vxworks_create_dynamic_sections (abfd, info, &htab->srelplt2))
    return FALSE;

  htab->relplt = bfd_get_linker_section (abfd, ".rela.plt");
  htab->plt = s = bfd_get_linker_section (abfd, ".plt");
  if (s == NULL)
    abort ();

  flags = SEC_ALLOC | SEC_CODE | SEC_LINKER_CREATED;
  if (htab->plt_type == PLT_VXWORKS)
    /* The VxWorks PLT is a loaded section with contents.  */
    flags |= SEC_HAS_CONTENTS | SEC_LOAD | SEC_READONLY;
  return bfd_set_section_flags (abfd, s, flags);
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
ppc_elf_copy_indirect_symbol (struct bfd_link_info *info,
			      struct elf_link_hash_entry *dir,
			      struct elf_link_hash_entry *ind)
{
  struct ppc_elf_link_hash_entry *edir, *eind;

  edir = (struct ppc_elf_link_hash_entry *) dir;
  eind = (struct ppc_elf_link_hash_entry *) ind;

  edir->tls_mask |= eind->tls_mask;
  edir->has_sda_refs |= eind->has_sda_refs;

  /* If called to transfer flags for a weakdef during processing
     of elf_adjust_dynamic_symbol, don't copy non_got_ref.
     We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
  if (!(ELIMINATE_COPY_RELOCS
	&& eind->elf.root.type != bfd_link_hash_indirect
	&& edir->elf.dynamic_adjusted))
    edir->elf.non_got_ref |= eind->elf.non_got_ref;

  edir->elf.ref_dynamic |= eind->elf.ref_dynamic;
  edir->elf.ref_regular |= eind->elf.ref_regular;
  edir->elf.ref_regular_nonweak |= eind->elf.ref_regular_nonweak;
  edir->elf.needs_plt |= eind->elf.needs_plt;
  edir->elf.pointer_equality_needed |= eind->elf.pointer_equality_needed;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  /* Add reloc counts against the indirect sym to the direct sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  /* If we were called to copy over info for a weak sym, that's all.
     You might think dyn_relocs need not be copied over;  After all,
     both syms will be dynamic or both non-dynamic so we're just
     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS
     code in ppc_elf_adjust_dynamic_symbol needs to check for
     dyn_relocs in read-only sections, and it does so on what is the
     DIR sym here.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

  /* Copy over the GOT refcount entries that we may have already seen to
     the symbol which just became indirect.  */
  edir->elf.got.refcount += eind->elf.got.refcount;
  eind->elf.got.refcount = 0;

  /* And plt entries.  */
  if (eind->elf.plt.plist != NULL)
    {
      if (edir->elf.plt.plist != NULL)
	{
	  struct plt_entry **entp;
	  struct plt_entry *ent;

	  for (entp = &eind->elf.plt.plist; (ent = *entp) != NULL; )
	    {
	      struct plt_entry *dent;

	      for (dent = edir->elf.plt.plist; dent != NULL; dent = dent->next)
		if (dent->sec == ent->sec && dent->addend == ent->addend)
		  {
		    dent->plt.refcount += ent->plt.refcount;
		    *entp = ent->next;
		    break;
		  }
	      if (dent == NULL)
		entp = &ent->next;
	    }
	  *entp = edir->elf.plt.plist;
	}

      edir->elf.plt.plist = eind->elf.plt.plist;
      eind->elf.plt.plist = NULL;
    }

  if (eind->elf.dynindx != -1)
    {
      if (edir->elf.dynindx != -1)
	_bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
				edir->elf.dynstr_index);
      edir->elf.dynindx = eind->elf.dynindx;
      edir->elf.dynstr_index = eind->elf.dynstr_index;
      eind->elf.dynindx = -1;
      eind->elf.dynstr_index = 0;
    }
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .sbss, and not .bss.  */

static bfd_boolean
ppc_elf_add_symbol_hook (bfd *abfd,
			 struct bfd_link_info *info,
			 Elf_Internal_Sym *sym,
			 const char **namep ATTRIBUTE_UNUSED,
			 flagword *flagsp ATTRIBUTE_UNUSED,
			 asection **secp,
			 bfd_vma *valp)
{
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && is_ppc_elf (info->output_bfd)
      && sym->st_size <= elf_gp_size (abfd))
    {
      /* Common symbols less than or equal to -G nn bytes are automatically
	 put into .sbss.  */
      struct ppc_elf_link_hash_table *htab;

      htab = ppc_elf_hash_table (info);
      if (htab->sbss == NULL)
	{
	  flagword flags = SEC_IS_COMMON | SEC_LINKER_CREATED;

	  if (!htab->elf.dynobj)
	    htab->elf.dynobj = abfd;

	  htab->sbss = bfd_make_section_anyway_with_flags (htab->elf.dynobj,
							   ".sbss",
							   flags);
	  if (htab->sbss == NULL)
	    return FALSE;
	}

      *secp = htab->sbss;
      *valp = sym->st_size;
    }

  if ((abfd->flags & DYNAMIC) == 0
      && (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC
	  || ELF_ST_BIND (sym->st_info) == STB_GNU_UNIQUE))
    elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;

  return TRUE;
}

static bfd_boolean
create_sdata_sym (struct bfd_link_info *info, elf_linker_section_t *lsect)
{
  struct ppc_elf_link_hash_table *htab = ppc_elf_hash_table (info);

  lsect->sym = elf_link_hash_lookup (&htab->elf, lsect->sym_name,
				     TRUE, FALSE, TRUE);
  if (lsect->sym == NULL)
    return FALSE;
  if (lsect->sym->root.type == bfd_link_hash_new)
    lsect->sym->non_elf = 0;
  lsect->sym->ref_regular = 1;
  _bfd_elf_link_hash_hide_symbol (info, lsect->sym, TRUE);
  return TRUE;
}

/* Create a special linker section.  */

static bfd_boolean
ppc_elf_create_linker_section (bfd *abfd,
			       struct bfd_link_info *info,
			       flagword flags,
			       elf_linker_section_t *lsect)
{
  struct ppc_elf_link_hash_table *htab = ppc_elf_hash_table (info);
  asection *s;

  flags |= (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	    | SEC_LINKER_CREATED);

  /* Record the first bfd that needs the special sections.  */
  if (!htab->elf.dynobj)
    htab->elf.dynobj = abfd;

  s = bfd_make_section_anyway_with_flags (htab->elf.dynobj,
					  lsect->name,
					  flags);
  if (s == NULL
      || !bfd_set_section_alignment (htab->elf.dynobj, s, 2))
    return FALSE;
  lsect->section = s;

  return create_sdata_sym (info, lsect);
}

/* Find a linker generated pointer with a given addend and type.  */

static elf_linker_section_pointers_t *
elf_find_pointer_linker_section
  (elf_linker_section_pointers_t *linker_pointers,
   bfd_vma addend,
   elf_linker_section_t *lsect)
{
  for ( ; linker_pointers != NULL; linker_pointers = linker_pointers->next)
    if (lsect == linker_pointers->lsect && addend == linker_pointers->addend)
      return linker_pointers;

  return NULL;
}

/* Allocate a pointer to live in a linker created section.  */

static bfd_boolean
elf_create_pointer_linker_section (bfd *abfd,
				   elf_linker_section_t *lsect,
				   struct elf_link_hash_entry *h,
				   const Elf_Internal_Rela *rel)
{
  elf_linker_section_pointers_t **ptr_linker_section_ptr = NULL;
  elf_linker_section_pointers_t *linker_section_ptr;
  unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
  bfd_size_type amt;

  BFD_ASSERT (lsect != NULL);

  /* Is this a global symbol?  */
  if (h != NULL)
    {
      struct ppc_elf_link_hash_entry *eh;

      /* Has this symbol already been allocated?  If so, our work is done.  */
      eh = (struct ppc_elf_link_hash_entry *) h;
      if (elf_find_pointer_linker_section (eh->linker_section_pointer,
					   rel->r_addend,
					   lsect))
	return TRUE;

      ptr_linker_section_ptr = &eh->linker_section_pointer;
    }
  else
    {
      BFD_ASSERT (is_ppc_elf (abfd));

      /* Allocation of a pointer to a local symbol.  */
      elf_linker_section_pointers_t **ptr = elf_local_ptr_offsets (abfd);

      /* Allocate a table to hold the local symbols if first time.  */
      if (!ptr)
	{
	  unsigned int num_symbols = elf_symtab_hdr (abfd).sh_info;

	  amt = num_symbols;
	  amt *= sizeof (elf_linker_section_pointers_t *);
	  ptr = bfd_zalloc (abfd, amt);

	  if (!ptr)
	    return FALSE;

	  elf_local_ptr_offsets (abfd) = ptr;
	}

      /* Has this symbol already been allocated?  If so, our work is done.  */
      if (elf_find_pointer_linker_section (ptr[r_symndx],
					   rel->r_addend,
					   lsect))
	return TRUE;

      ptr_linker_section_ptr = &ptr[r_symndx];
    }

  /* Allocate space for a pointer in the linker section, and allocate
     a new pointer record from internal memory.  */
  BFD_ASSERT (ptr_linker_section_ptr != NULL);
  amt = sizeof (elf_linker_section_pointers_t);
  linker_section_ptr = bfd_alloc (abfd, amt);

  if (!linker_section_ptr)
    return FALSE;

  linker_section_ptr->next = *ptr_linker_section_ptr;
  linker_section_ptr->addend = rel->r_addend;
  linker_section_ptr->lsect = lsect;
  *ptr_linker_section_ptr = linker_section_ptr;

  linker_section_ptr->offset = lsect->section->size;
  lsect->section->size += 4;

#ifdef DEBUG
  fprintf (stderr,
	   "Create pointer in linker section %s, offset = %ld, section size = %ld\n",
	   lsect->name, (long) linker_section_ptr->offset,
	   (long) lsect->section->size);
#endif

  return TRUE;
}

static struct plt_entry **
update_local_sym_info (bfd *abfd,
		       Elf_Internal_Shdr *symtab_hdr,
		       unsigned long r_symndx,
		       int tls_type)
{
  bfd_signed_vma *local_got_refcounts = elf_local_got_refcounts (abfd);
  struct plt_entry **local_plt;
  char *local_got_tls_masks;

  if (local_got_refcounts == NULL)
    {
      bfd_size_type size = symtab_hdr->sh_info;

      size *= (sizeof (*local_got_refcounts)
	       + sizeof (*local_plt)
	       + sizeof (*local_got_tls_masks));
      local_got_refcounts = bfd_zalloc (abfd, size);
      if (local_got_refcounts == NULL)
	return NULL;
      elf_local_got_refcounts (abfd) = local_got_refcounts;
    }

  local_plt = (struct plt_entry **) (local_got_refcounts + symtab_hdr->sh_info);
  local_got_tls_masks = (char *) (local_plt + symtab_hdr->sh_info);
  local_got_tls_masks[r_symndx] |= tls_type;
  if (tls_type != PLT_IFUNC)
    local_got_refcounts[r_symndx] += 1;
  return local_plt + r_symndx;
}

static bfd_boolean
update_plt_info (bfd *abfd, struct plt_entry **plist,
		 asection *sec, bfd_vma addend)
{
  struct plt_entry *ent;

  if (addend < 32768)
    sec = NULL;
  for (ent = *plist; ent != NULL; ent = ent->next)
    if (ent->sec == sec && ent->addend == addend)
      break;
  if (ent == NULL)
    {
      bfd_size_type amt = sizeof (*ent);
      ent = bfd_alloc (abfd, amt);
      if (ent == NULL)
	return FALSE;
      ent->next = *plist;
      ent->sec = sec;
      ent->addend = addend;
      ent->plt.refcount = 0;
      *plist = ent;
    }
  ent->plt.refcount += 1;
  return TRUE;
}

static struct plt_entry *
find_plt_ent (struct plt_entry **plist, asection *sec, bfd_vma addend)
{
  struct plt_entry *ent;

  if (addend < 32768)
    sec = NULL;
  for (ent = *plist; ent != NULL; ent = ent->next)
    if (ent->sec == sec && ent->addend == addend)
      break;
  return ent;
}

static bfd_boolean
is_branch_reloc (enum elf_ppc_reloc_type r_type)
{
  return (r_type == R_PPC_PLTREL24
	  || r_type == R_PPC_LOCAL24PC
	  || r_type == R_PPC_REL24
	  || r_type == R_PPC_REL14
	  || r_type == R_PPC_REL14_BRTAKEN
	  || r_type == R_PPC_REL14_BRNTAKEN
	  || r_type == R_PPC_ADDR24
	  || r_type == R_PPC_ADDR14
	  || r_type == R_PPC_ADDR14_BRTAKEN
	  || r_type == R_PPC_ADDR14_BRNTAKEN);
}

static void
bad_shared_reloc (bfd *abfd, enum elf_ppc_reloc_type r_type)
{
  (*_bfd_error_handler)
    (_("%B: relocation %s cannot be used when making a shared object"),
     abfd,
     ppc_elf_howto_table[r_type]->name);
  bfd_set_error (bfd_error_bad_value);
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
ppc_elf_check_relocs (bfd *abfd,
		      struct bfd_link_info *info,
		      asection *sec,
		      const Elf_Internal_Rela *relocs)
{
  struct ppc_elf_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *got2, *sreloc;
  struct elf_link_hash_entry *tga;

  if (info->relocatable)
    return TRUE;

  /* Don't do anything special with non-loaded, non-alloced sections.
     In particular, any relocs in such sections should not affect GOT
     and PLT reference counting (ie. we don't allow them to create GOT
     or PLT entries), there's no possibility or desire to optimize TLS
     relocs, and there's not much point in propagating relocs to shared
     libs that the dynamic linker won't relocate.  */
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

#ifdef DEBUG
  _bfd_error_handler ("ppc_elf_check_relocs called for section %A in %B",
		      sec, abfd);
#endif

  BFD_ASSERT (is_ppc_elf (abfd));

  /* Initialize howto table if not already done.  */
  if (!ppc_elf_howto_table[R_PPC_ADDR32])
    ppc_elf_howto_init ();

  htab = ppc_elf_hash_table (info);
  if (htab->glink == NULL)
    {
      if (htab->elf.dynobj == NULL)
	htab->elf.dynobj = abfd;
      if (!ppc_elf_create_glink (htab->elf.dynobj, info))
	return FALSE;
    }
  tga = elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
			      FALSE, FALSE, TRUE);
  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  got2 = bfd_get_section_by_name (abfd, ".got2");
  sreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      enum elf_ppc_reloc_type r_type;
      struct elf_link_hash_entry *h;
      int tls_type;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      /* If a relocation refers to _GLOBAL_OFFSET_TABLE_, create the .got.
	 This shows up in particular in an R_PPC_ADDR32 in the eabi
	 startup code.  */
      if (h != NULL
	  && htab->got == NULL
	  && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	{
	  if (htab->elf.dynobj == NULL)
	    htab->elf.dynobj = abfd;
	  if (!ppc_elf_create_got (htab->elf.dynobj, info))
	    return FALSE;
	  BFD_ASSERT (h == htab->elf.hgot);
	}

      tls_type = 0;
      r_type = ELF32_R_TYPE (rel->r_info);
      if (h == NULL && !htab->is_vxworks)
	{
	  Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->sym_cache,
							  abfd, r_symndx);
	  if (isym == NULL)
	    return FALSE;

	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
	    {
	      struct plt_entry **ifunc;

	      /* Set PLT_IFUNC flag for this sym, no GOT entry yet.  */
	      ifunc = update_local_sym_info (abfd, symtab_hdr, r_symndx,
					     PLT_IFUNC);
	      if (ifunc == NULL)
		return FALSE;

	      /* STT_GNU_IFUNC symbols must have a PLT entry;
		 In a non-pie executable even when there are
		 no plt calls.  */
	      if (!info->shared
		  || is_branch_reloc (r_type))
		{
		  bfd_vma addend = 0;
		  if (r_type == R_PPC_PLTREL24)
		    {
		      ppc_elf_tdata (abfd)->makes_plt_call = 1;
		      if (info->shared)
			addend = rel->r_addend;
		    }
		  if (!update_plt_info (abfd, ifunc, got2, addend))
		    return FALSE;
		}
	    }
	}

      if (!htab->is_vxworks
	  && is_branch_reloc (r_type)
	  && h != NULL
	  && h == tga)
	{
	  if (rel != relocs
	      && (ELF32_R_TYPE (rel[-1].r_info) == R_PPC_TLSGD
		  || ELF32_R_TYPE (rel[-1].r_info) == R_PPC_TLSLD))
	    /* We have a new-style __tls_get_addr call with a marker
	       reloc.  */
	    ;
	  else
	    /* Mark this section as having an old-style call.  */
	    sec->has_tls_get_addr_call = 1;
	}

      switch (r_type)
	{
	case R_PPC_TLSGD:
	case R_PPC_TLSLD:
	  /* These special tls relocs tie a call to __tls_get_addr with
	     its parameter symbol.  */
	  break;

	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogottls;

	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogottls;

	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	  if (!info->executable)
	    info->flags |= DF_STATIC_TLS;
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogottls;

	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	dogottls:
	  sec->has_tls_reloc = 1;
	  /* Fall thru */

	  /* GOT16 relocations */
	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_GOT16_HI:
	case R_PPC_GOT16_HA:
	  /* This symbol requires a global offset table entry.  */
	  if (htab->got == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!ppc_elf_create_got (htab->elf.dynobj, info))
		return FALSE;
	    }
	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	      ppc_elf_hash_entry (h)->tls_mask |= tls_type;
	    }
	  else
	    /* This is a global offset table entry for a local symbol.  */
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx, tls_type))
	      return FALSE;

	  /* We may also need a plt entry if the symbol turns out to be
	     an ifunc.  */
	  if (h != NULL && !info->shared)
	    {
	      if (!update_plt_info (abfd, &h->plt.plist, NULL, 0))
		return FALSE;
	    }
	  break;

	  /* Indirect .sdata relocation.  */
	case R_PPC_EMB_SDAI16:
	  if (info->shared)
	    {
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
	    }
	  if (htab->sdata[0].section == NULL
	      && !ppc_elf_create_linker_section (abfd, info, 0,
						 &htab->sdata[0]))
	    return FALSE;
	  if (!elf_create_pointer_linker_section (abfd, &htab->sdata[0],
						  h, rel))
	    return FALSE;
	  if (h != NULL)
	    {
	      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;
	      h->non_got_ref = TRUE;
	    }
	  break;

	  /* Indirect .sdata2 relocation.  */
	case R_PPC_EMB_SDA2I16:
	  if (info->shared)
	    {
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
	    }
	  if (htab->sdata[1].section == NULL
	      && !ppc_elf_create_linker_section (abfd, info, SEC_READONLY,
						 &htab->sdata[1]))
	    return FALSE;
	  if (!elf_create_pointer_linker_section (abfd, &htab->sdata[1],
						  h, rel))
	    return FALSE;
	  if (h != NULL)
	    {
	      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;
	      h->non_got_ref = TRUE;
	    }
	  break;

	case R_PPC_VLE_SDAREL_LO16A:
	case R_PPC_VLE_SDAREL_LO16D:
	case R_PPC_VLE_SDAREL_HI16A:
	case R_PPC_VLE_SDAREL_HI16D:
	case R_PPC_VLE_SDAREL_HA16A:
	case R_PPC_VLE_SDAREL_HA16D:
	case R_PPC_SDAREL16:
	  if (htab->sdata[0].sym == NULL
	      && !create_sdata_sym (info, &htab->sdata[0]))
	    return FALSE;

	  if (htab->sdata[1].sym == NULL
	      && !create_sdata_sym (info, &htab->sdata[1]))
	    return FALSE;

	  if (h != NULL)
	    {
	      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;
	      h->non_got_ref = TRUE;
	    }
	  break;

	case R_PPC_VLE_REL8:
	case R_PPC_VLE_REL15:
	case R_PPC_VLE_REL24:
	case R_PPC_VLE_LO16A:
	case R_PPC_VLE_LO16D:
	case R_PPC_VLE_HI16A:
	case R_PPC_VLE_HI16D:
	case R_PPC_VLE_HA16A:
	case R_PPC_VLE_HA16D:
	  break;

	case R_PPC_EMB_SDA2REL:
	  if (info->shared)
	    {
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
	    }
	  if (htab->sdata[1].sym == NULL
	      && !create_sdata_sym (info, &htab->sdata[1]))
	    return FALSE;
	  if (h != NULL)
	    {
	      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;
	      h->non_got_ref = TRUE;
	    }
	  break;

	case R_PPC_VLE_SDA21_LO:
	case R_PPC_VLE_SDA21:
	case R_PPC_EMB_SDA21:
	case R_PPC_EMB_RELSDA:
	  if (info->shared)
	    {
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
	    }
	  if (htab->sdata[0].sym == NULL
	      && !create_sdata_sym (info, &htab->sdata[0]))
	    return FALSE;
	  if (htab->sdata[1].sym == NULL
	      && !create_sdata_sym (info, &htab->sdata[1]))
	    return FALSE;
	  if (h != NULL)
	    {
	      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;
	      h->non_got_ref = TRUE;
	    }
	  break;

	case R_PPC_EMB_NADDR32:
	case R_PPC_EMB_NADDR16:
	case R_PPC_EMB_NADDR16_LO:
	case R_PPC_EMB_NADDR16_HI:
	case R_PPC_EMB_NADDR16_HA:
	  if (info->shared)
	    {
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
	    }
	  if (h != NULL)
	    h->non_got_ref = TRUE;
	  break;

	case R_PPC_PLTREL24:
	  if (h == NULL)
	    break;
	  /* Fall through */
	case R_PPC_PLT32:
	case R_PPC_PLTREL32:
	case R_PPC_PLT16_LO:
	case R_PPC_PLT16_HI:
	case R_PPC_PLT16_HA:
#ifdef DEBUG
	  fprintf (stderr, "Reloc requires a PLT entry\n");
#endif
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in finish_dynamic_symbol,
	     because this might be a case of linking PIC code without
	     linking in any dynamic objects, in which case we don't
	     need to generate a procedure linkage table after all.  */

	  if (h == NULL)
	    {
	      /* It does not make sense to have a procedure linkage
		 table entry for a local symbol.  */
	      info->callbacks->einfo (_("%P: %H: %s reloc against local symbol\n"),
				      abfd, sec, rel->r_offset,
				      ppc_elf_howto_table[r_type]->name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  else
	    {
	      bfd_vma addend = 0;

	      if (r_type == R_PPC_PLTREL24)
		{
		  ppc_elf_tdata (abfd)->makes_plt_call = 1;
		  if (info->shared)
		    addend = rel->r_addend;
		}
	      h->needs_plt = 1;
	      if (!update_plt_info (abfd, &h->plt.plist, got2, addend))
		return FALSE;
	    }
	  break;

	  /* The following relocations don't need to propagate the
	     relocation if linking a shared object since they are
	     section relative.  */
	case R_PPC_SECTOFF:
	case R_PPC_SECTOFF_LO:
	case R_PPC_SECTOFF_HI:
	case R_PPC_SECTOFF_HA:
	case R_PPC_DTPREL16:
	case R_PPC_DTPREL16_LO:
	case R_PPC_DTPREL16_HI:
	case R_PPC_DTPREL16_HA:
	case R_PPC_TOC16:
	  break;

	case R_PPC_REL16:
	case R_PPC_REL16_LO:
	case R_PPC_REL16_HI:
	case R_PPC_REL16_HA:
	  ppc_elf_tdata (abfd)->has_rel16 = 1;
	  break;

	  /* These are just markers.  */
	case R_PPC_TLS:
	case R_PPC_EMB_MRKREF:
	case R_PPC_NONE:
	case R_PPC_max:
	case R_PPC_RELAX:
	case R_PPC_RELAX_PLT:
	case R_PPC_RELAX_PLTREL24:
	  break;

	  /* These should only appear in dynamic objects.  */
	case R_PPC_COPY:
	case R_PPC_GLOB_DAT:
	case R_PPC_JMP_SLOT:
	case R_PPC_RELATIVE:
	case R_PPC_IRELATIVE:
	  break;

	  /* These aren't handled yet.  We'll report an error later.  */
	case R_PPC_ADDR30:
	case R_PPC_EMB_RELSEC16:
	case R_PPC_EMB_RELST_LO:
	case R_PPC_EMB_RELST_HI:
	case R_PPC_EMB_RELST_HA:
	case R_PPC_EMB_BIT_FLD:
	  break;

	  /* This refers only to functions defined in the shared library.  */
	case R_PPC_LOCAL24PC:
	  if (h != NULL && h == htab->elf.hgot && htab->plt_type == PLT_UNSET)
	    {
	      htab->plt_type = PLT_OLD;
	      htab->old_bfd = abfd;
	    }
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_PPC_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_PPC_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;

	  /* We shouldn't really be seeing these.  */
	case R_PPC_TPREL32:
	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_TPREL16_HI:
	case R_PPC_TPREL16_HA:
	  if (!info->executable)
	    info->flags |= DF_STATIC_TLS;
	  goto dodyn;

	  /* Nor these.  */
	case R_PPC_DTPMOD32:
	case R_PPC_DTPREL32:
	  goto dodyn;

	case R_PPC_REL32:
	  if (h == NULL
	      && got2 != NULL
	      && (sec->flags & SEC_CODE) != 0
	      && info->shared
	      && htab->plt_type == PLT_UNSET)
	    {
	      /* Old -fPIC gcc code has .long LCTOC1-LCFx just before
		 the start of a function, which assembles to a REL32
		 reference to .got2.  If we detect one of these, then
		 force the old PLT layout because the linker cannot
		 reliably deduce the GOT pointer value needed for
		 PLT call stubs.  */
	      asection *s;
	      Elf_Internal_Sym *isym;

	      isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					    abfd, r_symndx);
	      if (isym == NULL)
		return FALSE;

	      s = bfd_section_from_elf_index (abfd, isym->st_shndx);
	      if (s == got2)
		{
		  htab->plt_type = PLT_OLD;
		  htab->old_bfd = abfd;
		}
	    }
	  if (h == NULL || h == htab->elf.hgot)
	    break;
	  /* fall through */

	case R_PPC_ADDR32:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	  if (h != NULL && !info->shared)
	    {
	      /* We may need a plt entry if the symbol turns out to be
		 a function defined in a dynamic object.  */
	      if (!update_plt_info (abfd, &h->plt.plist, NULL, 0))
		return FALSE;

	      /* We may need a copy reloc too.  */
	      h->non_got_ref = 1;
	      h->pointer_equality_needed = 1;
	    }
	  goto dodyn;

	case R_PPC_REL24:
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  if (h == NULL)
	    break;
	  if (h == htab->elf.hgot)
	    {
	      if (htab->plt_type == PLT_UNSET)
		{
		  htab->plt_type = PLT_OLD;
		  htab->old_bfd = abfd;
		}
	      break;
	    }
	  /* fall through */

	case R_PPC_ADDR24:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	  if (h != NULL && !info->shared)
	    {
	      /* We may need a plt entry if the symbol turns out to be
		 a function defined in a dynamic object.  */
	      h->needs_plt = 1;
	      if (!update_plt_info (abfd, &h->plt.plist, NULL, 0))
		return FALSE;
	      break;
	    }

	dodyn:
	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library.  We account for that possibility below by
	     storing information in the dyn_relocs field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (must_be_dyn_reloc (info, r_type)
		   || (h != NULL
		       && (!SYMBOLIC_BIND (info, h)
			   || h->root.type == bfd_link_hash_defweak
			   || !h->def_regular))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || !h->def_regular)))
	    {
#ifdef DEBUG
	      fprintf (stderr,
		       "ppc_elf_check_relocs needs to "
		       "create relocation for %s\n",
		       (h && h->root.root.string
			? h->root.root.string : "<unknown>"));
#endif
	      if (sreloc == NULL)
		{
		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;

		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, htab->elf.dynobj, 2, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		{
		  struct elf_dyn_relocs *p;
		  struct elf_dyn_relocs **rel_head;

		  rel_head = &ppc_elf_hash_entry (h)->dyn_relocs;
		  p = *rel_head;
		  if (p == NULL || p->sec != sec)
		    {
		      p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		      if (p == NULL)
			return FALSE;
		      p->next = *rel_head;
		      *rel_head = p;
		      p->sec = sec;
		      p->count = 0;
		      p->pc_count = 0;
		    }
		  p->count += 1;
		  if (!must_be_dyn_reloc (info, r_type))
		    p->pc_count += 1;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */
		  struct ppc_dyn_relocs *p;
		  struct ppc_dyn_relocs **rel_head;
		  bfd_boolean is_ifunc;
		  asection *s;
		  void *vpp;
		  Elf_Internal_Sym *isym;

		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						abfd, r_symndx);
		  if (isym == NULL)
		    return FALSE;

		  s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  if (s == NULL)
		    s = sec;

		  vpp = &elf_section_data (s)->local_dynrel;
		  rel_head = (struct ppc_dyn_relocs **) vpp;
		  is_ifunc = ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC;
		  p = *rel_head;
		  if (p != NULL && p->sec == sec && p->ifunc != is_ifunc)
		    p = p->next;
		  if (p == NULL || p->sec != sec || p->ifunc != is_ifunc)
		    {
		      p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		      if (p == NULL)
			return FALSE;
		      p->next = *rel_head;
		      *rel_head = p;
		      p->sec = sec;
		      p->ifunc = is_ifunc;
		      p->count = 0;
		    }
		  p->count += 1;
		}
	    }

	  break;
	}
    }

  return TRUE;
}


/* Merge object attributes from IBFD into OBFD.  Raise an error if
   there are conflicting attributes.  */
static bfd_boolean
ppc_elf_merge_obj_attributes (bfd *ibfd, bfd *obfd)
{
  obj_attribute *in_attr, *in_attrs;
  obj_attribute *out_attr, *out_attrs;

  if (!elf_known_obj_attributes_proc (obfd)[0].i)
    {
      /* This is the first object.  Copy the attributes.  */
      _bfd_elf_copy_obj_attributes (ibfd, obfd);

      /* Use the Tag_null value to indicate the attributes have been
	 initialized.  */
      elf_known_obj_attributes_proc (obfd)[0].i = 1;

      return TRUE;
    }

  in_attrs = elf_known_obj_attributes (ibfd)[OBJ_ATTR_GNU];
  out_attrs = elf_known_obj_attributes (obfd)[OBJ_ATTR_GNU];

  /* Check for conflicting Tag_GNU_Power_ABI_FP attributes and merge
     non-conflicting ones.  */
  in_attr = &in_attrs[Tag_GNU_Power_ABI_FP];
  out_attr = &out_attrs[Tag_GNU_Power_ABI_FP];
  if (in_attr->i != out_attr->i)
    {
      out_attr->type = 1;
      if (out_attr->i == 0)
	out_attr->i = in_attr->i;
      else if (in_attr->i == 0)
	;
      else if (out_attr->i == 1 && in_attr->i == 2)
	_bfd_error_handler
	  (_("Warning: %B uses hard float, %B uses soft float"), obfd, ibfd);
      else if (out_attr->i == 1 && in_attr->i == 3)
	_bfd_error_handler
	  (_("Warning: %B uses double-precision hard float, %B uses single-precision hard float"),
	  obfd, ibfd);
      else if (out_attr->i == 3 && in_attr->i == 1)
	_bfd_error_handler
	  (_("Warning: %B uses double-precision hard float, %B uses single-precision hard float"),
	  ibfd, obfd);
      else if (out_attr->i == 3 && in_attr->i == 2)
	_bfd_error_handler
	  (_("Warning: %B uses soft float, %B uses single-precision hard float"),
	  ibfd, obfd);
      else if (out_attr->i == 2 && (in_attr->i == 1 || in_attr->i == 3))
	_bfd_error_handler
	  (_("Warning: %B uses hard float, %B uses soft float"), ibfd, obfd);
      else if (in_attr->i > 3)
	_bfd_error_handler
	  (_("Warning: %B uses unknown floating point ABI %d"), ibfd,
	   in_attr->i);
      else
	_bfd_error_handler
	  (_("Warning: %B uses unknown floating point ABI %d"), obfd,
	   out_attr->i);
    }

  /* Check for conflicting Tag_GNU_Power_ABI_Vector attributes and
     merge non-conflicting ones.  */
  in_attr = &in_attrs[Tag_GNU_Power_ABI_Vector];
  out_attr = &out_attrs[Tag_GNU_Power_ABI_Vector];
  if (in_attr->i != out_attr->i)
    {
      const char *in_abi = NULL, *out_abi = NULL;

      switch (in_attr->i)
	{
	case 1: in_abi = "generic"; break;
	case 2: in_abi = "AltiVec"; break;
	case 3: in_abi = "SPE"; break;
	}

      switch (out_attr->i)
	{
	case 1: out_abi = "generic"; break;
	case 2: out_abi = "AltiVec"; break;
	case 3: out_abi = "SPE"; break;
	}

      out_attr->type = 1;
      if (out_attr->i == 0)
	out_attr->i = in_attr->i;
      else if (in_attr->i == 0)
	;
      /* For now, allow generic to transition to AltiVec or SPE
	 without a warning.  If GCC marked files with their stack
	 alignment and used don't-care markings for files which are
	 not affected by the vector ABI, we could warn about this
	 case too.  */
      else if (out_attr->i == 1)
	out_attr->i = in_attr->i;
      else if (in_attr->i == 1)
	;
      else if (in_abi == NULL)
	_bfd_error_handler
	  (_("Warning: %B uses unknown vector ABI %d"), ibfd,
	   in_attr->i);
      else if (out_abi == NULL)
	_bfd_error_handler
	  (_("Warning: %B uses unknown vector ABI %d"), obfd,
	   in_attr->i);
      else
	_bfd_error_handler
	  (_("Warning: %B uses vector ABI \"%s\", %B uses \"%s\""),
	   ibfd, obfd, in_abi, out_abi);
    }

  /* Check for conflicting Tag_GNU_Power_ABI_Struct_Return attributes
     and merge non-conflicting ones.  */
  in_attr = &in_attrs[Tag_GNU_Power_ABI_Struct_Return];
  out_attr = &out_attrs[Tag_GNU_Power_ABI_Struct_Return];
  if (in_attr->i != out_attr->i)
    {
      out_attr->type = 1;
      if (out_attr->i == 0)
       out_attr->i = in_attr->i;
      else if (in_attr->i == 0)
       ;
      else if (out_attr->i == 1 && in_attr->i == 2)
       _bfd_error_handler
         (_("Warning: %B uses r3/r4 for small structure returns, %B uses memory"), obfd, ibfd);
      else if (out_attr->i == 2 && in_attr->i == 1)
       _bfd_error_handler
         (_("Warning: %B uses r3/r4 for small structure returns, %B uses memory"), ibfd, obfd);
      else if (in_attr->i > 2)
       _bfd_error_handler
         (_("Warning: %B uses unknown small structure return convention %d"), ibfd,
          in_attr->i);
      else
       _bfd_error_handler
         (_("Warning: %B uses unknown small structure return convention %d"), obfd,
          out_attr->i);
    }

  /* Merge Tag_compatibility attributes and any common GNU ones.  */
  _bfd_elf_merge_object_attributes (ibfd, obfd);

  return TRUE;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
ppc_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword old_flags;
  flagword new_flags;
  bfd_boolean error;

  if (!is_ppc_elf (ibfd) || !is_ppc_elf (obfd))
    return TRUE;

  /* Check if we have the same endianness.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  if (!ppc_elf_merge_obj_attributes (ibfd, obfd))
    return FALSE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;
  if (!elf_flags_init (obfd))
    {
      /* First call, no flags set.  */
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
    }

  /* Compatible flags are ok.  */
  else if (new_flags == old_flags)
    ;

  /* Incompatible flags.  */
  else
    {
      /* Warn about -mrelocatable mismatch.  Allow -mrelocatable-lib
	 to be linked with either.  */
      error = FALSE;
      if ((new_flags & EF_PPC_RELOCATABLE) != 0
	  && (old_flags & (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB)) == 0)
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%B: compiled with -mrelocatable and linked with "
	       "modules compiled normally"), ibfd);
	}
      else if ((new_flags & (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB)) == 0
	       && (old_flags & EF_PPC_RELOCATABLE) != 0)
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%B: compiled normally and linked with "
	       "modules compiled with -mrelocatable"), ibfd);
	}

      /* The output is -mrelocatable-lib iff both the input files are.  */
      if (! (new_flags & EF_PPC_RELOCATABLE_LIB))
	elf_elfheader (obfd)->e_flags &= ~EF_PPC_RELOCATABLE_LIB;

      /* The output is -mrelocatable iff it can't be -mrelocatable-lib,
	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
      if (! (elf_elfheader (obfd)->e_flags & EF_PPC_RELOCATABLE_LIB)
	  && (new_flags & (EF_PPC_RELOCATABLE_LIB | EF_PPC_RELOCATABLE))
	  && (old_flags & (EF_PPC_RELOCATABLE_LIB | EF_PPC_RELOCATABLE)))
	elf_elfheader (obfd)->e_flags |= EF_PPC_RELOCATABLE;

      /* Do not warn about eabi vs. V.4 mismatch, just or in the bit if
	 any module uses it.  */
      elf_elfheader (obfd)->e_flags |= (new_flags & EF_PPC_EMB);

      new_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
      old_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);

      /* Warn about any other mismatches.  */
      if (new_flags != old_flags)
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%B: uses different e_flags (0x%lx) fields "
	       "than previous modules (0x%lx)"),
	     ibfd, (long) new_flags, (long) old_flags);
	}

      if (error)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
    }

  return TRUE;
}

static void
ppc_elf_vle_split16 (bfd *output_bfd, bfd_byte *contents,
                 bfd_vma offset, bfd_vma relocation,
		 split16_format_type split16_format)

{
  bfd_vma insn, top5, bottom11;

  insn = bfd_get_32 (output_bfd, contents + offset);
  top5 = relocation >> 11;
  top5 = top5 << (split16_format == split16a_type ? 20 : 16);
  bottom11 = relocation & 0x7ff;
  insn |= top5;
  insn |= bottom11;
  bfd_put_32 (output_bfd, insn, contents + offset);
}


/* Choose which PLT scheme to use, and set .plt flags appropriately.
   Returns -1 on error, 0 for old PLT, 1 for new PLT.  */
int
ppc_elf_select_plt_layout (bfd *output_bfd ATTRIBUTE_UNUSED,
			   struct bfd_link_info *info,
			   enum ppc_elf_plt_type plt_style,
			   int emit_stub_syms)
{
  struct ppc_elf_link_hash_table *htab;
  flagword flags;

  htab = ppc_elf_hash_table (info);

  htab->emit_stub_syms = emit_stub_syms;

  if (htab->plt_type == PLT_UNSET)
    {
      struct elf_link_hash_entry *h;

      if (plt_style == PLT_OLD)
	htab->plt_type = PLT_OLD;
      else if (info->shared
	       && htab->elf.dynamic_sections_created
	       && (h = elf_link_hash_lookup (&htab->elf, "_mcount",
					     FALSE, FALSE, TRUE)) != NULL
	       && (h->type == STT_FUNC
		   || h->needs_plt)
	       && h->ref_regular
	       && !(SYMBOL_CALLS_LOCAL (info, h)
		    || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
			&& h->root.type == bfd_link_hash_undefweak)))
	{
	  /* Profiling of shared libs (and pies) is not supported with
	     secure plt, because ppc32 does profiling before a
	     function prologue and a secure plt pic call stubs needs
	     r30 to be set up.  */
	  htab->plt_type = PLT_OLD;
	}
      else
	{
	  bfd *ibfd;
	  enum ppc_elf_plt_type plt_type = plt_style;

	  /* Look through the reloc flags left by ppc_elf_check_relocs.
	     Use the old style bss plt if a file makes plt calls
	     without using the new relocs, and if ld isn't given
	     --secure-plt and we never see REL16 relocs.  */
	  if (plt_type == PLT_UNSET)
	    plt_type = PLT_OLD;
	  for (ibfd = info->input_bfds; ibfd; ibfd = ibfd->link_next)
	    if (is_ppc_elf (ibfd))
	      {
		if (ppc_elf_tdata (ibfd)->has_rel16)
		  plt_type = PLT_NEW;
		else if (ppc_elf_tdata (ibfd)->makes_plt_call)
		  {
		    plt_type = PLT_OLD;
		    htab->old_bfd = ibfd;
		    break;
		  }
	      }
	  htab->plt_type = plt_type;
	}
    }
  if (htab->plt_type == PLT_OLD && plt_style == PLT_NEW)
    {
      if (htab->old_bfd != NULL)
	info->callbacks->einfo (_("%P: bss-plt forced due to %B\n"),
				htab->old_bfd);
      else
	info->callbacks->einfo (_("%P: bss-plt forced by profiling\n"));
    }

  BFD_ASSERT (htab->plt_type != PLT_VXWORKS);

  if (htab->plt_type == PLT_NEW)
    {
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
	       | SEC_IN_MEMORY | SEC_LINKER_CREATED);

      /* The new PLT is a loaded section.  */
      if (htab->plt != NULL
	  && !bfd_set_section_flags (htab->elf.dynobj, htab->plt, flags))
	return -1;

      /* The new GOT is not executable.  */
      if (htab->got != NULL
	  && !bfd_set_section_flags (htab->elf.dynobj, htab->got, flags))
	return -1;
    }
  else
    {
      /* Stop an unused .glink section from affecting .text alignment.  */
      if (htab->glink != NULL
	  && !bfd_set_section_alignment (htab->elf.dynobj, htab->glink, 0))
	return -1;
    }
  return htab->plt_type == PLT_NEW;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
ppc_elf_gc_mark_hook (asection *sec,
		      struct bfd_link_info *info,
		      Elf_Internal_Rela *rel,
		      struct elf_link_hash_entry *h,
		      Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_PPC_GNU_VTINHERIT:
      case R_PPC_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got, plt and dynamic reloc reference counts for the
   section being removed.  */

static bfd_boolean
ppc_elf_gc_sweep_hook (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
{
  struct ppc_elf_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
  asection *got2;

  if (info->relocatable)
    return TRUE;

  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

  elf_section_data (sec)->local_dynrel = NULL;

  htab = ppc_elf_hash_table (info);
  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
  got2 = bfd_get_section_by_name (abfd, ".got2");

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      enum elf_ppc_reloc_type r_type;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf_dyn_relocs **pp, *p;
	  struct ppc_elf_link_hash_entry *eh;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  eh = (struct ppc_elf_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF32_R_TYPE (rel->r_info);
      if (!htab->is_vxworks
	  && h == NULL
	  && local_got_refcounts != NULL
	  && (!info->shared
	      || is_branch_reloc (r_type)))
	{
	  struct plt_entry **local_plt = (struct plt_entry **)
	    (local_got_refcounts + symtab_hdr->sh_info);
	  char *local_got_tls_masks = (char *)
	    (local_plt + symtab_hdr->sh_info);
	  if ((local_got_tls_masks[r_symndx] & PLT_IFUNC) != 0)
	    {
	      struct plt_entry **ifunc = local_plt + r_symndx;
	      bfd_vma addend = 0;
	      struct plt_entry *ent;

	      if (r_type == R_PPC_PLTREL24 && info->shared)
		addend = rel->r_addend;
	      ent = find_plt_ent (ifunc, got2, addend);
	      if (ent->plt.refcount > 0)
		ent->plt.refcount -= 1;
	      continue;
	    }
	}

      switch (r_type)
	{
	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_GOT16_HI:
	case R_PPC_GOT16_HA:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount--;
	      if (!info->shared)
		{
		  struct plt_entry *ent;

		  ent = find_plt_ent (&h->plt.plist, NULL, 0);
		  if (ent != NULL && ent->plt.refcount > 0)
		    ent->plt.refcount -= 1;
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx]--;
	    }
	  break;

	case R_PPC_REL24:
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	case R_PPC_REL32:
	  if (h == NULL || h == htab->elf.hgot)
	    break;
	  /* Fall thru */

	case R_PPC_ADDR32:
	case R_PPC_ADDR24:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	  if (info->shared)
	    break;

	case R_PPC_PLT32:
	case R_PPC_PLTREL24:
	case R_PPC_PLTREL32:
	case R_PPC_PLT16_LO:
	case R_PPC_PLT16_HI:
	case R_PPC_PLT16_HA:
	  if (h != NULL)
	    {
	      bfd_vma addend = 0;
	      struct plt_entry *ent;

	      if (r_type == R_PPC_PLTREL24 && info->shared)
		addend = rel->r_addend;
	      ent = find_plt_ent (&h->plt.plist, got2, addend);
	      if (ent != NULL && ent->plt.refcount > 0)
		ent->plt.refcount -= 1;
	    }
	  break;

	default:
	  break;
	}
    }
  return TRUE;
}

/* Set plt output section type, htab->tls_get_addr, and call the
   generic ELF tls_setup function.  */

asection *
ppc_elf_tls_setup (bfd *obfd,
		   struct bfd_link_info *info,
		   int no_tls_get_addr_opt)
{
  struct ppc_elf_link_hash_table *htab;

  htab = ppc_elf_hash_table (info);
  htab->tls_get_addr = elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
					     FALSE, FALSE, TRUE);
  if (!no_tls_get_addr_opt)
    {
      struct elf_link_hash_entry *opt, *tga;
      opt = elf_link_hash_lookup (&htab->elf, "__tls_get_addr_opt",
				  FALSE, FALSE, TRUE);
      if (opt != NULL
	  && (opt->root.type == bfd_link_hash_defined
	      || opt->root.type == bfd_link_hash_defweak))
	{
	  /* If glibc supports an optimized __tls_get_addr call stub,
	     signalled by the presence of __tls_get_addr_opt, and we'll
	     be calling __tls_get_addr via a plt call stub, then
	     make __tls_get_addr point to __tls_get_addr_opt.  */
	  tga = htab->tls_get_addr;
	  if (htab->elf.dynamic_sections_created
	      && tga != NULL
	      && (tga->type == STT_FUNC
		  || tga->needs_plt)
	      && !(SYMBOL_CALLS_LOCAL (info, tga)
		   || (ELF_ST_VISIBILITY (tga->other) != STV_DEFAULT
		       && tga->root.type == bfd_link_hash_undefweak)))
	    {
	      struct plt_entry *ent;
	      for (ent = tga->plt.plist; ent != NULL; ent = ent->next)
		if (ent->plt.refcount > 0)
		  break;
	      if (ent != NULL)
		{
		  tga->root.type = bfd_link_hash_indirect;
		  tga->root.u.i.link = &opt->root;
		  ppc_elf_copy_indirect_symbol (info, opt, tga);
		  if (opt->dynindx != -1)
		    {
		      /* Use __tls_get_addr_opt in dynamic relocations.  */
		      opt->dynindx = -1;
		      _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
					      opt->dynstr_index);
		      if (!bfd_elf_link_record_dynamic_symbol (info, opt))
			return FALSE;
		    }
		  htab->tls_get_addr = opt;
		}
	    }
	}
      else
	no_tls_get_addr_opt = TRUE;
    }
  htab->no_tls_get_addr_opt = no_tls_get_addr_opt;
  if (htab->plt_type == PLT_NEW
      && htab->plt != NULL
      && htab->plt->output_section != NULL)
    {
      elf_section_type (htab->plt->output_section) = SHT_PROGBITS;
      elf_section_flags (htab->plt->output_section) = SHF_ALLOC + SHF_WRITE;
    }

  return _bfd_elf_tls_setup (obfd, info);
}

/* Return TRUE iff REL is a branch reloc with a global symbol matching
   HASH.  */

static bfd_boolean
branch_reloc_hash_match (const bfd *ibfd,
			 const Elf_Internal_Rela *rel,
			 const struct elf_link_hash_entry *hash)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (ibfd);
  enum elf_ppc_reloc_type r_type = ELF32_R_TYPE (rel->r_info);
  unsigned int r_symndx = ELF32_R_SYM (rel->r_info);

  if (r_symndx >= symtab_hdr->sh_info && is_branch_reloc (r_type))
    {
      struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (ibfd);
      struct elf_link_hash_entry *h;

      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h == hash)
	return TRUE;
    }
  return FALSE;
}

/* Run through all the TLS relocs looking for optimization
   opportunities.  */

bfd_boolean
ppc_elf_tls_optimize (bfd *obfd ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info)
{
  bfd *ibfd;
  asection *sec;
  struct ppc_elf_link_hash_table *htab;
  int pass;

  if (info->relocatable || !info->executable)
    return TRUE;

  htab = ppc_elf_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* Make two passes through the relocs.  First time check that tls
     relocs involved in setting up a tls_get_addr call are indeed
     followed by such a call.  If they are not, don't do any tls
     optimization.  On the second pass twiddle tls_mask flags to
     notify relocate_section that optimization can be done, and
     adjust got and plt refcounts.  */
  for (pass = 0; pass < 2; ++pass)
    for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
      {
	Elf_Internal_Sym *locsyms = NULL;
	Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (ibfd);
	asection *got2 = bfd_get_section_by_name (ibfd, ".got2");

	for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	  if (sec->has_tls_reloc && !bfd_is_abs_section (sec->output_section))
	    {
	      Elf_Internal_Rela *relstart, *rel, *relend;
	      int expecting_tls_get_addr = 0;

	      /* Read the relocations.  */
	      relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
						    info->keep_memory);
	      if (relstart == NULL)
		return FALSE;

	      relend = relstart + sec->reloc_count;
	      for (rel = relstart; rel < relend; rel++)
		{
		  enum elf_ppc_reloc_type r_type;
		  unsigned long r_symndx;
		  struct elf_link_hash_entry *h = NULL;
		  char *tls_mask;
		  char tls_set, tls_clear;
		  bfd_boolean is_local;
		  bfd_signed_vma *got_count;

		  r_symndx = ELF32_R_SYM (rel->r_info);
		  if (r_symndx >= symtab_hdr->sh_info)
		    {
		      struct elf_link_hash_entry **sym_hashes;

		      sym_hashes = elf_sym_hashes (ibfd);
		      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
		      while (h->root.type == bfd_link_hash_indirect
			     || h->root.type == bfd_link_hash_warning)
			h = (struct elf_link_hash_entry *) h->root.u.i.link;
		    }

		  is_local = FALSE;
		  if (h == NULL
		      || !h->def_dynamic)
		    is_local = TRUE;

		  r_type = ELF32_R_TYPE (rel->r_info);
		  /* If this section has old-style __tls_get_addr calls
		     without marker relocs, then check that each
		     __tls_get_addr call reloc is preceded by a reloc
		     that conceivably belongs to the __tls_get_addr arg
		     setup insn.  If we don't find matching arg setup
		     relocs, don't do any tls optimization.  */
		  if (pass == 0
		      && sec->has_tls_get_addr_call
		      && h != NULL
		      && h == htab->tls_get_addr
		      && !expecting_tls_get_addr
		      && is_branch_reloc (r_type))
		    {
		      info->callbacks->minfo ("%H __tls_get_addr lost arg, "
					      "TLS optimization disabled\n",
					      ibfd, sec, rel->r_offset);
		      if (elf_section_data (sec)->relocs != relstart)
			free (relstart);
		      return TRUE;
		    }

		  expecting_tls_get_addr = 0;
		  switch (r_type)
		    {
		    case R_PPC_GOT_TLSLD16:
		    case R_PPC_GOT_TLSLD16_LO:
		      expecting_tls_get_addr = 1;
		      /* Fall thru */

		    case R_PPC_GOT_TLSLD16_HI:
		    case R_PPC_GOT_TLSLD16_HA:
		      /* These relocs should never be against a symbol
			 defined in a shared lib.  Leave them alone if
			 that turns out to be the case.  */
		      if (!is_local)
			continue;

		      /* LD -> LE */
		      tls_set = 0;
		      tls_clear = TLS_LD;
		      break;

		    case R_PPC_GOT_TLSGD16:
		    case R_PPC_GOT_TLSGD16_LO:
		      expecting_tls_get_addr = 1;
		      /* Fall thru */

		    case R_PPC_GOT_TLSGD16_HI:
		    case R_PPC_GOT_TLSGD16_HA:
		      if (is_local)
			/* GD -> LE */
			tls_set = 0;
		      else
			/* GD -> IE */
			tls_set = TLS_TLS | TLS_TPRELGD;
		      tls_clear = TLS_GD;
		      break;

		    case R_PPC_GOT_TPREL16:
		    case R_PPC_GOT_TPREL16_LO:
		    case R_PPC_GOT_TPREL16_HI:
		    case R_PPC_GOT_TPREL16_HA:
		      if (is_local)
			{
			  /* IE -> LE */
			  tls_set = 0;
			  tls_clear = TLS_TPREL;
			  break;
			}
		      else
			continue;

		    case R_PPC_TLSGD:
		    case R_PPC_TLSLD:
		      expecting_tls_get_addr = 2;
		      tls_set = 0;
		      tls_clear = 0;
		      break;

		    default:
		      continue;
		    }

		  if (pass == 0)
		    {
		      if (!expecting_tls_get_addr
			  || (expecting_tls_get_addr == 1
			      && !sec->has_tls_get_addr_call))
			continue;

		      if (rel + 1 < relend
			  && branch_reloc_hash_match (ibfd, rel + 1,
						      htab->tls_get_addr))
			continue;

		      /* Uh oh, we didn't find the expected call.  We
			 could just mark this symbol to exclude it
			 from tls optimization but it's safer to skip
			 the entire optimization.  */
		      info->callbacks->minfo (_("%H arg lost __tls_get_addr, "
						"TLS optimization disabled\n"),
					      ibfd, sec, rel->r_offset);
		      if (elf_section_data (sec)->relocs != relstart)
			free (relstart);
		      return TRUE;
		    }

		  if (expecting_tls_get_addr)
		    {
		      struct plt_entry *ent;
		      bfd_vma addend = 0;

		      if (info->shared
			  && ELF32_R_TYPE (rel[1].r_info) == R_PPC_PLTREL24)
			addend = rel[1].r_addend;
		      ent = find_plt_ent (&htab->tls_get_addr->plt.plist,
					  got2, addend);
		      if (ent != NULL && ent->plt.refcount > 0)
			ent->plt.refcount -= 1;

		      if (expecting_tls_get_addr == 2)
			continue;
		    }

		  if (h != NULL)
		    {
		      tls_mask = &ppc_elf_hash_entry (h)->tls_mask;
		      got_count = &h->got.refcount;
		    }
		  else
		    {
		      bfd_signed_vma *lgot_refs;
		      struct plt_entry **local_plt;
		      char *lgot_masks;

		      if (locsyms == NULL)
			{
			  locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
			  if (locsyms == NULL)
			    locsyms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
							    symtab_hdr->sh_info,
							    0, NULL, NULL, NULL);
			  if (locsyms == NULL)
			    {
			      if (elf_section_data (sec)->relocs != relstart)
				free (relstart);
			      return FALSE;
			    }
			}
		      lgot_refs = elf_local_got_refcounts (ibfd);
		      if (lgot_refs == NULL)
			abort ();
		      local_plt = (struct plt_entry **)
			(lgot_refs + symtab_hdr->sh_info);
		      lgot_masks = (char *) (local_plt + symtab_hdr->sh_info);
		      tls_mask = &lgot_masks[r_symndx];
		      got_count = &lgot_refs[r_symndx];
		    }

		  if (tls_set == 0)
		    {
		      /* We managed to get rid of a got entry.  */
		      if (*got_count > 0)
			*got_count -= 1;
		    }

		  *tls_mask |= tls_set;
		  *tls_mask &= ~tls_clear;
		}

	      if (elf_section_data (sec)->relocs != relstart)
		free (relstart);
	    }

	if (locsyms != NULL
	    && (symtab_hdr->contents != (unsigned char *) locsyms))
	  {
	    if (!info->keep_memory)
	      free (locsyms);
	    else
	      symtab_hdr->contents = (unsigned char *) locsyms;
	  }
      }
  return TRUE;
}

/* Return true if we have dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h)
{
  struct elf_dyn_relocs *p;

  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL
	  && ((s->flags & (SEC_READONLY | SEC_ALLOC))
	      == (SEC_READONLY | SEC_ALLOC)))
	return TRUE;
    }
  return FALSE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
			       struct elf_link_hash_entry *h)
{
  struct ppc_elf_link_hash_table *htab;
  asection *s;

#ifdef DEBUG
  fprintf (stderr, "ppc_elf_adjust_dynamic_symbol called for %s\n",
	   h->root.root.string);
#endif

  /* Make sure we know what is going on here.  */
  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL
	      && (h->needs_plt
		  || h->type == STT_GNU_IFUNC
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* Deal with function syms.  */
  if (h->type == STT_FUNC
      || h->type == STT_GNU_IFUNC
      || h->needs_plt)
    {
      /* Clear procedure linkage table information for any symbol that
	 won't need a .plt entry.  */
      struct plt_entry *ent;
      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
	if (ent->plt.refcount > 0)
	  break;
      if (ent == NULL
	  || (h->type != STT_GNU_IFUNC
	      && (SYMBOL_CALLS_LOCAL (info, h)
		  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
		      && h->root.type == bfd_link_hash_undefweak))))
	{
	  /* A PLT entry is not required/allowed when:

	     1. We are not using ld.so; because then the PLT entry
	     can't be set up, so we can't use one.  In this case,
	     ppc_elf_adjust_dynamic_symbol won't even be called.

	     2. GC has rendered the entry unused.

	     3. We know for certain that a call to this symbol
	     will go to this object, or will remain undefined.  */
	  h->plt.plist = NULL;
	  h->needs_plt = 0;
	}
      else
	{
	  /* After adjust_dynamic_symbol, non_got_ref set in the
	     non-shared case means that we have allocated space in
	     .dynbss for the symbol and thus dyn_relocs for this
	     symbol should be discarded.
	     If we get here we know we are making a PLT entry for this
	     symbol, and in an executable we'd normally resolve
	     relocations against this symbol to the PLT entry.  Allow
	     dynamic relocs if the reference is weak, and the dynamic
	     relocs will not cause text relocation.  */
	  if (!h->ref_regular_nonweak
	      && h->non_got_ref
	      && h->type != STT_GNU_IFUNC
	      && !htab->is_vxworks
	      && !ppc_elf_hash_entry (h)->has_sda_refs
	      && !readonly_dynrelocs (h))
	    h->non_got_ref = 0;
	}
      return TRUE;
    }
  else
    h->plt.plist = NULL;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      if (ELIMINATE_COPY_RELOCS)
	h->non_got_ref = h->u.weakdef->non_got_ref;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

   /* If we didn't find any dynamic relocs in read-only sections, then
      we'll be keeping the dynamic relocs and avoiding the copy reloc.
      We can't do this if there are any small data relocations.  This
      doesn't work on VxWorks, where we can not have dynamic
      relocations (other than copy and jump slot relocations) in an
      executable.  */
  if (ELIMINATE_COPY_RELOCS
      && !ppc_elf_hash_entry (h)->has_sda_refs
      && !htab->is_vxworks
      && !h->def_regular
      && !readonly_dynrelocs (h))
    {
      h->non_got_ref = 0;
      return TRUE;
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.

     Of course, if the symbol is referenced using SDAREL relocs, we
     must instead allocate it in .sbss.  */

  if (ppc_elf_hash_entry (h)->has_sda_refs)
    s = htab->dynsbss;
  else
    s = htab->dynbss;
  BFD_ASSERT (s != NULL);

  /* We must generate a R_PPC_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      asection *srel;

      if (ppc_elf_hash_entry (h)->has_sda_refs)
	srel = htab->relsbss;
      else
	srel = htab->relbss;
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* Generate a symbol to mark plt call stubs.  For non-PIC code the sym is
   xxxxxxxx.plt_call32.<callee> where xxxxxxxx is a hex number, usually 0,
   specifying the addend on the plt relocation.  For -fpic code, the sym
   is xxxxxxxx.plt_pic32.<callee>, and for -fPIC
   xxxxxxxx.got2.plt_pic32.<callee>.  */

static bfd_boolean
add_stub_sym (struct plt_entry *ent,
	      struct elf_link_hash_entry *h,
	      struct bfd_link_info *info)
{
  struct elf_link_hash_entry *sh;
  size_t len1, len2, len3;
  char *name;
  const char *stub;
  struct ppc_elf_link_hash_table *htab = ppc_elf_hash_table (info);

  if (info->shared)
    stub = ".plt_pic32.";
  else
    stub = ".plt_call32.";

  len1 = strlen (h->root.root.string);
  len2 = strlen (stub);
  len3 = 0;
  if (ent->sec)
    len3 = strlen (ent->sec->name);
  name = bfd_malloc (len1 + len2 + len3 + 9);
  if (name == NULL)
    return FALSE;
  sprintf (name, "%08x", (unsigned) ent->addend & 0xffffffff);
  if (ent->sec)
    memcpy (name + 8, ent->sec->name, len3);
  memcpy (name + 8 + len3, stub, len2);
  memcpy (name + 8 + len3 + len2, h->root.root.string, len1 + 1);
  sh = elf_link_hash_lookup (&htab->elf, name, TRUE, FALSE, FALSE);
  if (sh == NULL)
    return FALSE;
  if (sh->root.type == bfd_link_hash_new)
    {
      sh->root.type = bfd_link_hash_defined;
      sh->root.u.def.section = htab->glink;
      sh->root.u.def.value = ent->glink_offset;
      sh->ref_regular = 1;
      sh->def_regular = 1;
      sh->ref_regular_nonweak = 1;
      sh->forced_local = 1;
      sh->non_elf = 0;
    }
  return TRUE;
}

/* Allocate NEED contiguous space in .got, and return the offset.
   Handles allocation of the got header when crossing 32k.  */

static bfd_vma
allocate_got (struct ppc_elf_link_hash_table *htab, unsigned int need)
{
  bfd_vma where;
  unsigned int max_before_header;

  if (htab->plt_type == PLT_VXWORKS)
    {
      where = htab->got->size;
      htab->got->size += need;
    }
  else
    {
      max_before_header = htab->plt_type == PLT_NEW ? 32768 : 32764;
      if (need <= htab->got_gap)
	{
	  where = max_before_header - htab->got_gap;
	  htab->got_gap -= need;
	}
      else
	{
	  if (htab->got->size + need > max_before_header
	      && htab->got->size <= max_before_header)
	    {
	      htab->got_gap = max_before_header - htab->got->size;
	      htab->got->size = max_before_header + htab->got_header_size;
	    }
	  where = htab->got->size;
	  htab->got->size += need;
	}
    }
  return where;
}

/* Allocate space in associated reloc sections for dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info = inf;
  struct ppc_elf_link_hash_entry *eh;
  struct ppc_elf_link_hash_table *htab;
  struct elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  htab = ppc_elf_hash_table (info);
  if (htab->elf.dynamic_sections_created
      || h->type == STT_GNU_IFUNC)
    {
      struct plt_entry *ent;
      bfd_boolean doneone = FALSE;
      bfd_vma plt_offset = 0, glink_offset = 0;
      bfd_boolean dyn;

      for (ent = h->plt.plist; ent != NULL; ent = ent->next)
	if (ent->plt.refcount > 0)
	  {
	    /* Make sure this symbol is output as a dynamic symbol.  */
	    if (h->dynindx == -1
		&& !h->forced_local
		&& !h->def_regular
		&& htab->elf.dynamic_sections_created)
	      {
		if (! bfd_elf_link_record_dynamic_symbol (info, h))
		  return FALSE;
	      }

	    dyn = htab->elf.dynamic_sections_created;
	    if (info->shared
		|| h->type == STT_GNU_IFUNC
		|| WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h))
	      {
		asection *s = htab->plt;
		if (!dyn || h->dynindx == -1)
		  s = htab->iplt;

		if (htab->plt_type == PLT_NEW || !dyn || h->dynindx == -1)
		  {
		    if (!doneone)
		      {
			plt_offset = s->size;
			s->size += 4;
		      }
		    ent->plt.offset = plt_offset;

		    s = htab->glink;
		    if (!doneone || info->shared)
		      {
			glink_offset = s->size;
			s->size += GLINK_ENTRY_SIZE;
			if (h == htab->tls_get_addr
			    && !htab->no_tls_get_addr_opt)
			  s->size += TLS_GET_ADDR_GLINK_SIZE - GLINK_ENTRY_SIZE;
		      }
		    if (!doneone
			&& !info->shared
			&& h->def_dynamic
			&& !h->def_regular)
		      {
			h->root.u.def.section = s;
			h->root.u.def.value = glink_offset;
		      }
		    ent->glink_offset = glink_offset;

		    if (htab->emit_stub_syms
			&& !add_stub_sym (ent, h, info))
		      return FALSE;
		  }
		else
		  {
		    if (!doneone)
		      {
			/* If this is the first .plt entry, make room
			   for the special first entry.  */
			if (s->size == 0)
			  s->size += htab->plt_initial_entry_size;

			/* The PowerPC PLT is actually composed of two
			   parts, the first part is 2 words (for a load
			   and a jump), and then there is a remaining
			   word available at the end.  */
			plt_offset = (htab->plt_initial_entry_size
				      + (htab->plt_slot_size
					 * ((s->size
					     - htab->plt_initial_entry_size)
					    / htab->plt_entry_size)));

			/* If this symbol is not defined in a regular
			   file, and we are not generating a shared
			   library, then set the symbol to this location
			   in the .plt.  This is to avoid text
			   relocations, and is required to make
			   function pointers compare as equal between
			   the normal executable and the shared library.  */
			if (! info->shared
			    && h->def_dynamic
			    && !h->def_regular)
			  {
			    h->root.u.def.section = s;
			    h->root.u.def.value = plt_offset;
			  }

			/* Make room for this entry.  */
			s->size += htab->plt_entry_size;
			/* After the 8192nd entry, room for two entries
			   is allocated.  */
			if (htab->plt_type == PLT_OLD
			    && (s->size - htab->plt_initial_entry_size)
				/ htab->plt_entry_size
			       > PLT_NUM_SINGLE_ENTRIES)
			  s->size += htab->plt_entry_size;
		      }
		    ent->plt.offset = plt_offset;
		  }

		/* We also need to make an entry in the .rela.plt section.  */
		if (!doneone)
		  {
		    if (!htab->elf.dynamic_sections_created
			|| h->dynindx == -1)
		      htab->reliplt->size += sizeof (Elf32_External_Rela);
		    else
		      {
			htab->relplt->size += sizeof (Elf32_External_Rela);

			if (htab->plt_type == PLT_VXWORKS)
			  {
			    /* Allocate space for the unloaded relocations.  */
			    if (!info->shared
				&& htab->elf.dynamic_sections_created)
			      {
				if (ent->plt.offset
				    == (bfd_vma) htab->plt_initial_entry_size)
				  {
				    htab->srelplt2->size
				      += (sizeof (Elf32_External_Rela)
					  * VXWORKS_PLTRESOLVE_RELOCS);
				  }

				htab->srelplt2->size
				  += (sizeof (Elf32_External_Rela)
				      * VXWORKS_PLT_NON_JMP_SLOT_RELOCS);
			      }

			    /* Every PLT entry has an associated GOT entry in
			       .got.plt.  */
			    htab->sgotplt->size += 4;
			  }
		      }
		    doneone = TRUE;
		  }
	      }
	    else
	      ent->plt.offset = (bfd_vma) -1;
	  }
	else
	  ent->plt.offset = (bfd_vma) -1;

      if (!doneone)
	{
	  h->plt.plist = NULL;
	  h->needs_plt = 0;
	}
    }
  else
    {
      h->plt.plist = NULL;
      h->needs_plt = 0;
    }

  eh = (struct ppc_elf_link_hash_entry *) h;
  if (eh->elf.got.refcount > 0)
    {
      bfd_boolean dyn;
      unsigned int need;

      /* Make sure this symbol is output as a dynamic symbol.  */
      if (eh->elf.dynindx == -1
	  && !eh->elf.forced_local
	  && eh->elf.type != STT_GNU_IFUNC
	  && htab->elf.dynamic_sections_created)
	{
	  if (!bfd_elf_link_record_dynamic_symbol (info, &eh->elf))
	    return FALSE;
	}

      need = 0;
      if ((eh->tls_mask & TLS_TLS) != 0)
	{
	  if ((eh->tls_mask & TLS_LD) != 0)
	    {
	      if (!eh->elf.def_dynamic)
		/* We'll just use htab->tlsld_got.offset.  This should
		   always be the case.  It's a little odd if we have
		   a local dynamic reloc against a non-local symbol.  */
		htab->tlsld_got.refcount += 1;
	      else
		need += 8;
	    }
	  if ((eh->tls_mask & TLS_GD) != 0)
	    need += 8;
	  if ((eh->tls_mask & (TLS_TPREL | TLS_TPRELGD)) != 0)
	    need += 4;
	  if ((eh->tls_mask & TLS_DTPREL) != 0)
	    need += 4;
	}
      else
	need += 4;
      if (need == 0)
	eh->elf.got.offset = (bfd_vma) -1;
      else
	{
	  eh->elf.got.offset = allocate_got (htab, need);
	  dyn = htab->elf.dynamic_sections_created;
	  if ((info->shared
	       || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, &eh->elf))
	      && (ELF_ST_VISIBILITY (eh->elf.other) == STV_DEFAULT
		  || eh->elf.root.type != bfd_link_hash_undefweak))
	    {
	      asection *rsec = htab->relgot;

	      if (eh->elf.type == STT_GNU_IFUNC)
		rsec = htab->reliplt;
	      /* All the entries we allocated need relocs.
		 Except LD only needs one.  */
	      if ((eh->tls_mask & TLS_LD) != 0
		  && eh->elf.def_dynamic)
		need -= 4;
	      rsec->size += need * (sizeof (Elf32_External_Rela) / 4);
	    }
	}
    }
  else
    eh->elf.got.offset = (bfd_vma) -1;

  if (eh->dyn_relocs == NULL
      || !htab->elf.dynamic_sections_created)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for relocs that have become local due to symbol visibility
     changes.  */

  if (info->shared)
    {
      /* Relocs that use pc_count are those that appear on a call insn,
	 or certain REL relocs (see must_be_dyn_reloc) that can be
	 generated via assembly.  We want calls to protected symbols to
	 resolve directly to the function rather than going via the plt.
	 If people want function pointer comparisons to work as expected
	 then they should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      if (htab->is_vxworks)
	{
	  struct elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      if (strcmp (p->sec->output_section->name, ".tls_vars") == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Discard relocs on undefined symbols that must be local.  */
      if (eh->dyn_relocs != NULL
	  && h->root.type == bfd_link_hash_undefined
	  && (ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
	      || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL))
	eh->dyn_relocs = NULL;

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (eh->dyn_relocs != NULL
	  && h->root.type == bfd_link_hash_undefweak)
	{
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    eh->dyn_relocs = NULL;

	  /* Make sure undefined weak symbols are output as a dynamic
	     symbol in PIEs.  */
	  else if (h->dynindx == -1
		   && !h->forced_local
		   && !h->def_regular)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
	}
    }
  else if (ELIMINATE_COPY_RELOCS)
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!h->non_got_ref
	  && !h->def_regular)
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      if (eh->elf.type == STT_GNU_IFUNC)
	sreloc = htab->reliplt;
      sreloc->size += p->count * sizeof (Elf32_External_Rela);
    }

  return TRUE;
}

/* Set DF_TEXTREL if we find any dynamic relocs that apply to
   read-only sections.  */

static bfd_boolean
maybe_set_textrel (struct elf_link_hash_entry *h, void *info)
{
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (readonly_dynrelocs (h))
    {
      ((struct bfd_link_info *) info)->flags |= DF_TEXTREL;

      /* Not an error, just cut short the traversal.  */
      return FALSE;
    }
  return TRUE;
}

static const unsigned char glink_eh_frame_cie[] =
{
  0, 0, 0, 16,				/* length.  */
  0, 0, 0, 0,				/* id.  */
  1,					/* CIE version.  */
  'z', 'R', 0,				/* Augmentation string.  */
  4,					/* Code alignment.  */
  0x7c,					/* Data alignment.  */
  65,					/* RA reg.  */
  1,					/* Augmentation size.  */
  DW_EH_PE_pcrel | DW_EH_PE_sdata4,	/* FDE encoding.  */
  DW_CFA_def_cfa, 1, 0			/* def_cfa: r1 offset 0.  */
};

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
ppc_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			       struct bfd_link_info *info)
{
  struct ppc_elf_link_hash_table *htab;
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;

#ifdef DEBUG
  fprintf (stderr, "ppc_elf_size_dynamic_sections called\n");
#endif

  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL);

  if (elf_hash_table (info)->dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (htab->elf.dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  if (htab->plt_type == PLT_OLD)
    htab->got_header_size = 16;
  else if (htab->plt_type == PLT_NEW)
    htab->got_header_size = 12;

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      struct plt_entry **local_plt;
      struct plt_entry **end_local_plt;
      char *lgot_masks;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;

      if (!is_ppc_elf (ibfd))
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct ppc_dyn_relocs *p;

	  for (p = ((struct ppc_dyn_relocs *)
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (htab->is_vxworks
		       && strcmp (p->sec->output_section->name,
				  ".tls_vars") == 0)
		{
		  /* Relocations in vxworks .tls_vars sections are
		     handled specially by the loader.  */
		}
	      else if (p->count != 0)
		{
		  asection *sreloc = elf_section_data (p->sec)->sreloc;
		  if (p->ifunc)
		    sreloc = htab->reliplt;
		  sreloc->size += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags
		       & (SEC_READONLY | SEC_ALLOC))
		      == (SEC_READONLY | SEC_ALLOC))
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_symtab_hdr (ibfd);
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      local_plt = (struct plt_entry **) end_local_got;
      end_local_plt = local_plt + locsymcount;
      lgot_masks = (char *) end_local_plt;

      for (; local_got < end_local_got; ++local_got, ++lgot_masks)
	if (*local_got > 0)
	  {
	    unsigned int need = 0;
	    if ((*lgot_masks & TLS_TLS) != 0)
	      {
		if ((*lgot_masks & TLS_GD) != 0)
		  need += 8;
		if ((*lgot_masks & TLS_LD) != 0)
		  htab->tlsld_got.refcount += 1;
		if ((*lgot_masks & (TLS_TPREL | TLS_TPRELGD)) != 0)
		  need += 4;
		if ((*lgot_masks & TLS_DTPREL) != 0)
		  need += 4;
	      }
	    else
	      need += 4;
	    if (need == 0)
	      *local_got = (bfd_vma) -1;
	    else
	      {
		*local_got = allocate_got (htab, need);
		if (info->shared)
		  {
		    asection *srel = htab->relgot;
		    if ((*lgot_masks & PLT_IFUNC) != 0)
		      srel = htab->reliplt;
		    srel->size += need * (sizeof (Elf32_External_Rela) / 4);
		  }
	      }
	  }
	else
	  *local_got = (bfd_vma) -1;

      if (htab->is_vxworks)
	continue;

      /* Allocate space for calls to local STT_GNU_IFUNC syms in .iplt.  */
      for (; local_plt < end_local_plt; ++local_plt)
	{
	  struct plt_entry *ent;
	  bfd_boolean doneone = FALSE;
	  bfd_vma plt_offset = 0, glink_offset = 0;

	  for (ent = *local_plt; ent != NULL; ent = ent->next)
	    if (ent->plt.refcount > 0)
	      {
		s = htab->iplt;

		if (!doneone)
		  {
		    plt_offset = s->size;
		    s->size += 4;
		  }
		ent->plt.offset = plt_offset;

		s = htab->glink;
		if (!doneone || info->shared)
		  {
		    glink_offset = s->size;
		    s->size += GLINK_ENTRY_SIZE;
		  }
		ent->glink_offset = glink_offset;

		if (!doneone)
		  {
		    htab->reliplt->size += sizeof (Elf32_External_Rela);
		    doneone = TRUE;
		  }
	      }
	    else
	      ent->plt.offset = (bfd_vma) -1;
	}
    }

  /* Allocate space for global sym dynamic relocs.  */
  elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, info);

  if (htab->tlsld_got.refcount > 0)
    {
      htab->tlsld_got.offset = allocate_got (htab, 8);
      if (info->shared)
	htab->relgot->size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tlsld_got.offset = (bfd_vma) -1;

  if (htab->got != NULL && htab->plt_type != PLT_VXWORKS)
    {
      unsigned int g_o_t = 32768;

      /* If we haven't allocated the header, do so now.  When we get here,
	 for old plt/got the got size will be 0 to 32764 (not allocated),
	 or 32780 to 65536 (header allocated).  For new plt/got, the
	 corresponding ranges are 0 to 32768 and 32780 to 65536.  */
      if (htab->got->size <= 32768)
	{
	  g_o_t = htab->got->size;
	  if (htab->plt_type == PLT_OLD)
	    g_o_t += 4;
	  htab->got->size += htab->got_header_size;
	}

      htab->elf.hgot->root.u.def.value = g_o_t;
    }
  if (info->shared)
    {
      struct elf_link_hash_entry *sda = htab->sdata[0].sym;
      if (sda != NULL
	  && !(sda->root.type == bfd_link_hash_defined
	       || sda->root.type == bfd_link_hash_defweak))
	{
	  sda->root.type = bfd_link_hash_defined;
	  sda->root.u.def.section = htab->elf.hgot->root.u.def.section;
	  sda->root.u.def.value = htab->elf.hgot->root.u.def.value;
	}
    }

  if (htab->glink != NULL
      && htab->glink->size != 0
      && htab->elf.dynamic_sections_created)
    {
      htab->glink_pltresolve = htab->glink->size;
      /* Space for the branch table.  */
      htab->glink->size += htab->glink->size / (GLINK_ENTRY_SIZE / 4) - 4;
      /* Pad out to align the start of PLTresolve.  */
      htab->glink->size += -htab->glink->size & 15;
      htab->glink->size += GLINK_PLTRESOLVE;

      if (htab->emit_stub_syms)
	{
	  struct elf_link_hash_entry *sh;
	  sh = elf_link_hash_lookup (&htab->elf, "__glink",
				     TRUE, FALSE, FALSE);
	  if (sh == NULL)
	    return FALSE;
	  if (sh->root.type == bfd_link_hash_new)
	    {
	      sh->root.type = bfd_link_hash_defined;
	      sh->root.u.def.section = htab->glink;
	      sh->root.u.def.value = htab->glink_pltresolve;
	      sh->ref_regular = 1;
	      sh->def_regular = 1;
	      sh->ref_regular_nonweak = 1;
	      sh->forced_local = 1;
	      sh->non_elf = 0;
	    }
	  sh = elf_link_hash_lookup (&htab->elf, "__glink_PLTresolve",
				     TRUE, FALSE, FALSE);
	  if (sh == NULL)
	    return FALSE;
	  if (sh->root.type == bfd_link_hash_new)
	    {
	      sh->root.type = bfd_link_hash_defined;
	      sh->root.u.def.section = htab->glink;
	      sh->root.u.def.value = htab->glink->size - GLINK_PLTRESOLVE;
	      sh->ref_regular = 1;
	      sh->def_regular = 1;
	      sh->ref_regular_nonweak = 1;
	      sh->forced_local = 1;
	      sh->non_elf = 0;
	    }
	}
    }

  if (htab->glink != NULL
      && htab->glink->size != 0
      && htab->glink_eh_frame != NULL
      && !bfd_is_abs_section (htab->glink_eh_frame->output_section)
      && _bfd_elf_eh_frame_present (info))
    {
      s = htab->glink_eh_frame;
      s->size = sizeof (glink_eh_frame_cie) + 20;
      if (info->shared)
	{
	  s->size += 4;
	  if (htab->glink->size - GLINK_PLTRESOLVE + 8 >= 256)
	    s->size += 4;
	}
    }

  /* We've now determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = htab->elf.dynobj->sections; s != NULL; s = s->next)
    {
      bfd_boolean strip_section = TRUE;

      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->plt
	  || s == htab->got)
	{
	  /* We'd like to strip these sections if they aren't needed, but if
	     we've exported dynamic symbols from them we must leave them.
	     It's too late to tell BFD to get rid of the symbols.  */
	  if (htab->elf.hplt != NULL)
	    strip_section = FALSE;
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if (s == htab->iplt
	       || s == htab->glink
	       || s == htab->glink_eh_frame
	       || s == htab->sgotplt
	       || s == htab->sbss
	       || s == htab->dynbss
	       || s == htab->dynsbss
	       || s == htab->sdata[0].section
	       || s == htab->sdata[1].section)
	{
	  /* Strip these too.  */
	}
      else if (CONST_STRNEQ (bfd_get_section_name (htab->elf.dynobj, s),
			     ".rela"))
	{
	  if (s->size != 0)
	    {
	      /* Remember whether there are any relocation sections.  */
	      relocs = TRUE;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0 && strip_section)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */
	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  */
      s->contents = bfd_zalloc (htab->elf.dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  if (htab->elf.dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in ppc_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->plt != NULL && htab->plt->size != 0)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (htab->glink != NULL && htab->glink->size != 0)
	{
	  if (!add_dynamic_entry (DT_PPC_GOT, 0))
	    return FALSE;
	  if (!htab->no_tls_get_addr_opt
	      && htab->tls_get_addr != NULL
	      && htab->tls_get_addr->plt.plist != NULL
	      && !add_dynamic_entry (DT_PPC_TLSOPT, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;
	}

      /* If any dynamic relocs apply to a read-only section, then we
	 need a DT_TEXTREL entry.  */
      if ((info->flags & DF_TEXTREL) == 0)
	elf_link_hash_traverse (elf_hash_table (info), maybe_set_textrel,
				info);

      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
	}
      if (htab->is_vxworks
	  && !elf_vxworks_add_dynamic_entries (output_bfd, info))
	return FALSE;
   }
#undef add_dynamic_entry

  if (htab->glink_eh_frame != NULL
      && htab->glink_eh_frame->contents != NULL)
    {
      unsigned char *p = htab->glink_eh_frame->contents;
      bfd_vma val;

      memcpy (p, glink_eh_frame_cie, sizeof (glink_eh_frame_cie));
      /* CIE length (rewrite in case little-endian).  */
      bfd_put_32 (htab->elf.dynobj, sizeof (glink_eh_frame_cie) - 4, p);
      p += sizeof (glink_eh_frame_cie);
      /* FDE length.  */
      val = htab->glink_eh_frame->size - 4 - sizeof (glink_eh_frame_cie);
      bfd_put_32 (htab->elf.dynobj, val, p);
      p += 4;
      /* CIE pointer.  */
      val = p - htab->glink_eh_frame->contents;
      bfd_put_32 (htab->elf.dynobj, val, p);
      p += 4;
      /* Offset to .glink.  Set later.  */
      p += 4;
      /* .glink size.  */
      bfd_put_32 (htab->elf.dynobj, htab->glink->size, p);
      p += 4;
      /* Augmentation.  */
      p += 1;

      if (info->shared
	  && htab->elf.dynamic_sections_created)
	{
	  bfd_vma adv = (htab->glink->size - GLINK_PLTRESOLVE + 8) >> 2;
	  if (adv < 64)
	    *p++ = DW_CFA_advance_loc + adv;
	  else if (adv < 256)
	    {
	      *p++ = DW_CFA_advance_loc1;
	      *p++ = adv;
	    }
	  else if (adv < 65536)
	    {
	      *p++ = DW_CFA_advance_loc2;
	      bfd_put_16 (htab->elf.dynobj, adv, p);
	      p += 2;
	    }
	  else
	    {
	      *p++ = DW_CFA_advance_loc4;
	      bfd_put_32 (htab->elf.dynobj, adv, p);
	      p += 4;
	    }
	  *p++ = DW_CFA_register;
	  *p++ = 65;
	  p++;
	  *p++ = DW_CFA_advance_loc + 4;
	  *p++ = DW_CFA_restore_extended;
	  *p++ = 65;
	}
      BFD_ASSERT ((bfd_vma) ((p + 3 - htab->glink_eh_frame->contents) & -4)
		  == htab->glink_eh_frame->size);
    }

  return TRUE;
}

/* Return TRUE if symbol should be hashed in the `.gnu.hash' section.  */

static bfd_boolean
ppc_elf_hash_symbol (struct elf_link_hash_entry *h)
{
  if (h->plt.plist != NULL
      && !h->def_regular
      && (!h->pointer_equality_needed
	  || !h->ref_regular_nonweak))
    return FALSE;

  return _bfd_elf_hash_symbol (h);
}

#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))

/* Relaxation trampolines.  r12 is available for clobbering (r11, is
   used for some functions that are allowed to break the ABI).  */
static const int shared_stub_entry[] =
  {
    0x7c0802a6, /* mflr 0 */
    0x429f0005, /* bcl 20, 31, .Lxxx */
    0x7d8802a6, /* mflr 12 */
    0x3d8c0000, /* addis 12, 12, (xxx-.Lxxx)@@ha */
    0x398c0008, /* addi 12, 12, (xxx-.Lxxx)@@l */
    0x7c0803a6, /* mtlr 0 */
    0x7d8903a6, /* mtctr 12 */
    0x4e800420, /* bctr */
  };

static const int stub_entry[] =
  {
    0x3d800000, /* lis 12,xxx@@ha */
    0x398c0000, /* addi 12,12,xxx@@l */
    0x7d8903a6, /* mtctr 12 */
    0x4e800420, /* bctr */
  };

static bfd_boolean
ppc_elf_relax_section (bfd *abfd,
		       asection *isec,
		       struct bfd_link_info *link_info,
		       bfd_boolean *again)
{
  struct one_fixup
  {
    struct one_fixup *next;
    asection *tsec;
    /* Final link, can use the symbol offset.  For a
       relocatable link we use the symbol's index.  */
    bfd_vma toff;
    bfd_vma trampoff;
  };

  Elf_Internal_Shdr *symtab_hdr;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  struct one_fixup *fixups = NULL;
  unsigned changes = 0;
  struct ppc_elf_link_hash_table *htab;
  bfd_size_type trampoff;
  asection *got2;
  bfd_boolean maybe_pasted;

  *again = FALSE;

  /* Nothing to do if there are no relocations, and no need to do
     anything with non-alloc or non-code sections.  */
  if ((isec->flags & SEC_ALLOC) == 0
      || (isec->flags & SEC_CODE) == 0
      || (isec->flags & SEC_RELOC) == 0
      || isec->reloc_count == 0)
    return TRUE;

  /* We cannot represent the required PIC relocs in the output, so don't
     do anything.  The linker doesn't support mixing -shared and -r
     anyway.  */
  if (link_info->relocatable && link_info->shared)
     return TRUE;

  trampoff = (isec->size + 3) & (bfd_vma) -4;
  maybe_pasted = (strcmp (isec->output_section->name, ".init") == 0
		  || strcmp (isec->output_section->name, ".fini") == 0);
  /* Space for a branch around any trampolines.  */
  if (maybe_pasted)
    trampoff += 4;

  symtab_hdr = &elf_symtab_hdr (abfd);

  /* Get a copy of the native relocations.  */
  internal_relocs = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL,
					       link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;

  htab = ppc_elf_hash_table (link_info);
  got2 = bfd_get_section_by_name (abfd, ".got2");

  irelend = internal_relocs + isec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      unsigned long r_type = ELF32_R_TYPE (irel->r_info);
      bfd_vma toff, roff;
      asection *tsec;
      struct one_fixup *f;
      size_t insn_offset = 0;
      bfd_vma max_branch_offset, val;
      bfd_byte *hit_addr;
      unsigned long t0;
      struct elf_link_hash_entry *h;
      struct plt_entry **plist;
      unsigned char sym_type;

      switch (r_type)
	{
	case R_PPC_REL24:
	case R_PPC_LOCAL24PC:
	case R_PPC_PLTREL24:
	  max_branch_offset = 1 << 25;
	  break;

	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  max_branch_offset = 1 << 15;
	  break;

	default:
	  continue;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      h = NULL;
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == 0)
		goto error_return;
	    }
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    tsec = bfd_und_section_ptr;
	  else if (isym->st_shndx == SHN_ABS)
	    tsec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    tsec = bfd_com_section_ptr;
	  else
	    tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);

	  toff = isym->st_value;
	  sym_type = ELF_ST_TYPE (isym->st_info);
	}
      else
	{
	  /* Global symbol handling.  */
	  unsigned long indx;

	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      tsec = h->root.u.def.section;
	      toff = h->root.u.def.value;
	    }
	  else if (h->root.type == bfd_link_hash_undefined
		   || h->root.type == bfd_link_hash_undefweak)
	    {
	      tsec = bfd_und_section_ptr;
	      toff = link_info->relocatable ? indx : 0;
	    }
	  else
	    continue;

	  sym_type = h->type;
	}

      /* The condition here under which we call find_plt_ent must
	 match that in relocate_section.  If we call find_plt_ent here
	 but not in relocate_section, or vice versa, then the branch
	 destination used here may be incorrect.  */
      plist = NULL;
      if (h != NULL)
	{
	  /* We know is_branch_reloc (r_type) is true.  */
	  if (h->type == STT_GNU_IFUNC
	      || r_type == R_PPC_PLTREL24)
	    plist = &h->plt.plist;
	}
      else if (sym_type == STT_GNU_IFUNC
	       && elf_local_got_offsets (abfd) != NULL)
	{
	  bfd_vma *local_got_offsets = elf_local_got_offsets (abfd);
	  struct plt_entry **local_plt = (struct plt_entry **)
	    (local_got_offsets + symtab_hdr->sh_info);
	  plist = local_plt + ELF32_R_SYM (irel->r_info);
	}
      if (plist != NULL)
	{
	  bfd_vma addend = 0;
	  struct plt_entry *ent;

	  if (r_type == R_PPC_PLTREL24 && link_info->shared)
	    addend = irel->r_addend;
	  ent = find_plt_ent (plist, got2, addend);
	  if (ent != NULL)
	    {
	      if (htab->plt_type == PLT_NEW
		  || h == NULL
		  || !htab->elf.dynamic_sections_created
		  || h->dynindx == -1)
		{
		  tsec = htab->glink;
		  toff = ent->glink_offset;
		}
	      else
		{
		  tsec = htab->plt;
		  toff = ent->plt.offset;
		}
	    }
	}

      /* If the branch and target are in the same section, you have
	 no hope of adding stubs.  We'll error out later should the
	 branch overflow.  */
      if (tsec == isec)
	continue;

      /* There probably isn't any reason to handle symbols in
	 SEC_MERGE sections;  SEC_MERGE doesn't seem a likely
	 attribute for a code section, and we are only looking at
	 branches.  However, implement it correctly here as a
	 reference for other target relax_section functions.  */
      if (0 && tsec->sec_info_type == SEC_INFO_TYPE_MERGE)
	{
	  /* At this stage in linking, no SEC_MERGE symbol has been
	     adjusted, so all references to such symbols need to be
	     passed through _bfd_merged_section_offset.  (Later, in
	     relocate_section, all SEC_MERGE symbols *except* for
	     section symbols have been adjusted.)

	     gas may reduce relocations against symbols in SEC_MERGE
	     sections to a relocation against the section symbol when
	     the original addend was zero.  When the reloc is against
	     a section symbol we should include the addend in the
	     offset passed to _bfd_merged_section_offset, since the
	     location of interest is the original symbol.  On the
	     other hand, an access to "sym+addend" where "sym" is not
	     a section symbol should not include the addend;  Such an
	     access is presumed to be an offset from "sym";  The
	     location of interest is just "sym".  */
	  if (sym_type == STT_SECTION)
	    toff += irel->r_addend;

	  toff = _bfd_merged_section_offset (abfd, &tsec,
					     elf_section_data (tsec)->sec_info,
					     toff);

	  if (sym_type != STT_SECTION)
	    toff += irel->r_addend;
	}
      /* PLTREL24 addends are special.  */
      else if (r_type != R_PPC_PLTREL24)
	toff += irel->r_addend;

      /* Attempted -shared link of non-pic code loses.  */
      if (tsec->output_section == NULL)
	continue;

      roff = irel->r_offset;

      /* If the branch is in range, no need to do anything.  */
      if (tsec != bfd_und_section_ptr
	  && (!link_info->relocatable
	      /* A relocatable link may have sections moved during
		 final link, so do not presume they remain in range.  */
	      || tsec->output_section == isec->output_section))
	{
	  bfd_vma symaddr, reladdr;

	  symaddr = tsec->output_section->vma + tsec->output_offset + toff;
	  reladdr = isec->output_section->vma + isec->output_offset + roff;
	  if (symaddr - reladdr + max_branch_offset < 2 * max_branch_offset)
	    continue;
	}

      /* Look for an existing fixup to this address.  */
      for (f = fixups; f ; f = f->next)
	if (f->tsec == tsec && f->toff == toff)
	  break;

      if (f == NULL)
	{
	  size_t size;
	  unsigned long stub_rtype;

	  val = trampoff - roff;
	  if (val >= max_branch_offset)
	    /* Oh dear, we can't reach a trampoline.  Don't try to add
	       one.  We'll report an error later.  */
	    continue;

	  if (link_info->shared)
	    {
	      size = 4 * ARRAY_SIZE (shared_stub_entry);
	      insn_offset = 12;
	    }
	  else
	    {
	      size = 4 * ARRAY_SIZE (stub_entry);
	      insn_offset = 0;
	    }
	  stub_rtype = R_PPC_RELAX;
	  if (tsec == htab->plt
	      || tsec == htab->glink)
	    {
	      stub_rtype = R_PPC_RELAX_PLT;
	      if (r_type == R_PPC_PLTREL24)
		stub_rtype = R_PPC_RELAX_PLTREL24;
	    }

	  /* Hijack the old relocation.  Since we need two
	     relocations for this use a "composite" reloc.  */
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       stub_rtype);
	  irel->r_offset = trampoff + insn_offset;
	  if (r_type == R_PPC_PLTREL24
	      && stub_rtype != R_PPC_RELAX_PLTREL24)
	    irel->r_addend = 0;

	  /* Record the fixup so we don't do it again this section.  */
	  f = bfd_malloc (sizeof (*f));
	  f->next = fixups;
	  f->tsec = tsec;
	  f->toff = toff;
	  f->trampoff = trampoff;
	  fixups = f;

	  trampoff += size;
	  changes++;
	}
      else
	{
	  val = f->trampoff - roff;
	  if (val >= max_branch_offset)
	    continue;

	  /* Nop out the reloc, since we're finalizing things here.  */
	  irel->r_info = ELF32_R_INFO (0, R_PPC_NONE);
	}

      /* Get the section contents.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (isec)->this_hdr.contents != NULL)
	    contents = elf_section_data (isec)->this_hdr.contents;
	  else
	    {
	      /* Go get them off disk.  */
	      if (!bfd_malloc_and_get_section (abfd, isec, &contents))
		goto error_return;
	    }
	}

      /* Fix up the existing branch to hit the trampoline.  */
      hit_addr = contents + roff;
      switch (r_type)
	{
	case R_PPC_REL24:
	case R_PPC_LOCAL24PC:
	case R_PPC_PLTREL24:
	  t0 = bfd_get_32 (abfd, hit_addr);
	  t0 &= ~0x3fffffc;
	  t0 |= val & 0x3fffffc;
	  bfd_put_32 (abfd, t0, hit_addr);
	  break;

	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  t0 = bfd_get_32 (abfd, hit_addr);
	  t0 &= ~0xfffc;
	  t0 |= val & 0xfffc;
	  bfd_put_32 (abfd, t0, hit_addr);
	  break;
	}
    }

  /* Write out the trampolines.  */
  if (fixups != NULL)
    {
      const int *stub;
      bfd_byte *dest;
      int i, size;

      do
	{
	  struct one_fixup *f = fixups;
	  fixups = fixups->next;
	  free (f);
	}
      while (fixups);

      contents = bfd_realloc_or_free (contents, trampoff);
      if (contents == NULL)
	goto error_return;

      isec->size = (isec->size + 3) & (bfd_vma) -4;
      dest = contents + isec->size;
      /* Branch around the trampolines.  */
      if (maybe_pasted)
	{
	  bfd_vma val = B + trampoff - isec->size;
	  bfd_put_32 (abfd, val, dest);
	  dest += 4;
	}
      isec->size = trampoff;

      if (link_info->shared)
	{
	  stub = shared_stub_entry;
	  size = ARRAY_SIZE (shared_stub_entry);
	}
      else
	{
	  stub = stub_entry;
	  size = ARRAY_SIZE (stub_entry);
	}

      i = 0;
      while (dest < contents + trampoff)
	{
	  bfd_put_32 (abfd, stub[i], dest);
	  i++;
	  if (i == size)
	    i = 0;
	  dest += 4;
	}
      BFD_ASSERT (i == 0);
    }

  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

  if (contents != NULL
      && elf_section_data (isec)->this_hdr.contents != contents)
    {
      if (!changes && !link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (isec)->this_hdr.contents = contents;
	}
    }

  if (changes != 0)
    {
      /* Append sufficient NOP relocs so we can write out relocation
	 information for the trampolines.  */
      Elf_Internal_Shdr *rel_hdr;
      Elf_Internal_Rela *new_relocs = bfd_malloc ((changes + isec->reloc_count)
						  * sizeof (*new_relocs));
      unsigned ix;

      if (!new_relocs)
	goto error_return;
      memcpy (new_relocs, internal_relocs,
	      isec->reloc_count * sizeof (*new_relocs));
      for (ix = changes; ix--;)
	{
	  irel = new_relocs + ix + isec->reloc_count;

	  irel->r_info = ELF32_R_INFO (0, R_PPC_NONE);
	}
      if (internal_relocs != elf_section_data (isec)->relocs)
	free (internal_relocs);
      elf_section_data (isec)->relocs = new_relocs;
      isec->reloc_count += changes;
      rel_hdr = _bfd_elf_single_rel_hdr (isec);
      rel_hdr->sh_size += changes * rel_hdr->sh_entsize;
    }
  else if (elf_section_data (isec)->relocs != internal_relocs)
    free (internal_relocs);

  *again = changes != 0;
  if (!*again && link_info->relocatable)
    {
      /* Convert the internal relax relocs to external form.  */
      for (irel = internal_relocs; irel < irelend; irel++)
	if (ELF32_R_TYPE (irel->r_info) == R_PPC_RELAX)
	  {
	    unsigned long r_symndx = ELF32_R_SYM (irel->r_info);

	    /* Rewrite the reloc and convert one of the trailing nop
	       relocs to describe this relocation.  */
	    BFD_ASSERT (ELF32_R_TYPE (irelend[-1].r_info) == R_PPC_NONE);
	    /* The relocs are at the bottom 2 bytes */
	    irel[0].r_offset += 2;
	    memmove (irel + 1, irel, (irelend - irel - 1) * sizeof (*irel));
	    irel[0].r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_HA);
	    irel[1].r_offset += 4;
	    irel[1].r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_LO);
	    irel++;
	  }
    }

  return TRUE;

 error_return:
  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (isec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (isec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

/* What to do when ld finds relocations against symbols defined in
   discarded sections.  */

static unsigned int
ppc_elf_action_discarded (asection *sec)
{
  if (strcmp (".fixup", sec->name) == 0)
    return 0;

  if (strcmp (".got2", sec->name) == 0)
    return 0;

  return _bfd_elf_default_action_discarded (sec);
}

/* Fill in the address for a pointer generated in a linker section.  */

static bfd_vma
elf_finish_pointer_linker_section (bfd *input_bfd,
				   elf_linker_section_t *lsect,
				   struct elf_link_hash_entry *h,
				   bfd_vma relocation,
				   const Elf_Internal_Rela *rel)
{
  elf_linker_section_pointers_t *linker_section_ptr;

  BFD_ASSERT (lsect != NULL);

  if (h != NULL)
    {
      /* Handle global symbol.  */
      struct ppc_elf_link_hash_entry *eh;

      eh = (struct ppc_elf_link_hash_entry *) h;
      BFD_ASSERT (eh->elf.def_regular);
      linker_section_ptr = eh->linker_section_pointer;
    }
  else
    {
      /* Handle local symbol.  */
      unsigned long r_symndx = ELF32_R_SYM (rel->r_info);

      BFD_ASSERT (is_ppc_elf (input_bfd));
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd) != NULL);
      linker_section_ptr = elf_local_ptr_offsets (input_bfd)[r_symndx];
    }

  linker_section_ptr = elf_find_pointer_linker_section (linker_section_ptr,
							rel->r_addend,
							lsect);
  BFD_ASSERT (linker_section_ptr != NULL);

  /* Offset will always be a multiple of four, so use the bottom bit
     as a "written" flag.  */
  if ((linker_section_ptr->offset & 1) == 0)
    {
      bfd_put_32 (lsect->section->owner,
		  relocation + linker_section_ptr->addend,
		  lsect->section->contents + linker_section_ptr->offset);
      linker_section_ptr->offset += 1;
    }

  relocation = (lsect->section->output_section->vma
		+ lsect->section->output_offset
		+ linker_section_ptr->offset - 1
		- SYM_VAL (lsect->sym));

#ifdef DEBUG
  fprintf (stderr,
	   "Finish pointer in linker section %s, offset = %ld (0x%lx)\n",
	   lsect->name, (long) relocation, (long) relocation);
#endif

  return relocation;
}

#define PPC_LO(v) ((v) & 0xffff)
#define PPC_HI(v) (((v) >> 16) & 0xffff)
#define PPC_HA(v) PPC_HI ((v) + 0x8000)

static void
write_glink_stub (struct plt_entry *ent, asection *plt_sec, unsigned char *p,
		  struct bfd_link_info *info)
{
  struct ppc_elf_link_hash_table *htab = ppc_elf_hash_table (info);
  bfd *output_bfd = info->output_bfd;
  bfd_vma plt;

  plt = ((ent->plt.offset & ~1)
	 + plt_sec->output_section->vma
	 + plt_sec->output_offset);

  if (info->shared)
    {
      bfd_vma got = 0;

      if (ent->addend >= 32768)
	got = (ent->addend
	       + ent->sec->output_section->vma
	       + ent->sec->output_offset);
      else if (htab->elf.hgot != NULL)
	got = SYM_VAL (htab->elf.hgot);

      plt -= got;

      if (plt + 0x8000 < 0x10000)
	{
	  bfd_put_32 (output_bfd, LWZ_11_30 + PPC_LO (plt), p);
	  p += 4;
	  bfd_put_32 (output_bfd, MTCTR_11, p);
	  p += 4;
	  bfd_put_32 (output_bfd, BCTR, p);
	  p += 4;
	  bfd_put_32 (output_bfd, NOP, p);
	  p += 4;
	}
      else
	{
	  bfd_put_32 (output_bfd, ADDIS_11_30 + PPC_HA (plt), p);
	  p += 4;
	  bfd_put_32 (output_bfd, LWZ_11_11 + PPC_LO (plt), p);
	  p += 4;
	  bfd_put_32 (output_bfd, MTCTR_11, p);
	  p += 4;
	  bfd_put_32 (output_bfd, BCTR, p);
	  p += 4;
	}
    }
  else
    {
      bfd_put_32 (output_bfd, LIS_11 + PPC_HA (plt), p);
      p += 4;
      bfd_put_32 (output_bfd, LWZ_11_11 + PPC_LO (plt), p);
      p += 4;
      bfd_put_32 (output_bfd, MTCTR_11, p);
      p += 4;
      bfd_put_32 (output_bfd, BCTR, p);
      p += 4;
    }
}

/* Return true if symbol is defined statically.  */

static bfd_boolean
is_static_defined (struct elf_link_hash_entry *h)
{
  return ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section != NULL
	  && h->root.u.def.section->output_section != NULL);
}

/* If INSN is an opcode that may be used with an @@tls operand, return
   the transformed insn for TLS optimisation, otherwise return 0.  If
   REG is non-zero only match an insn with RB or RA equal to REG.  */

unsigned int
_bfd_elf_ppc_at_tls_transform (unsigned int insn, unsigned int reg)
{
  unsigned int rtra;

  if ((insn & (0x3f << 26)) != 31 << 26)
    return 0;

  if (reg == 0 || ((insn >> 11) & 0x1f) == reg)
    rtra = insn & ((1 << 26) - (1 << 16));
  else if (((insn >> 16) & 0x1f) == reg)
    rtra = (insn & (0x1f << 21)) | ((insn & (0x1f << 11)) << 5);
  else
    return 0;

  if ((insn & (0x3ff << 1)) == 266 << 1)
    /* add -> addi.  */
    insn = 14 << 26;
  else if ((insn & (0x1f << 1)) == 23 << 1
	   && ((insn & (0x1f << 6)) < 14 << 6
	       || ((insn & (0x1f << 6)) >= 16 << 6
		   && (insn & (0x1f << 6)) < 24 << 6)))
    /* load and store indexed -> dform.  */
    insn = (32 | ((insn >> 6) & 0x1f)) << 26;
  else if ((insn & (((0x1a << 5) | 0x1f) << 1)) == 21 << 1)
    /* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
    insn = ((58 | ((insn >> 6) & 4)) << 26) | ((insn >> 6) & 1);
  else if ((insn & (((0x1f << 5) | 0x1f) << 1)) == 341 << 1)
    /* lwax -> lwa.  */
    insn = (58 << 26) | 2;
  else
    return 0;
  insn |= rtra;
  return insn;
}

/* If INSN is an opcode that may be used with an @@tprel operand, return
   the transformed insn for an undefined weak symbol, ie. with the
   thread pointer REG operand removed.  Otherwise return 0.  */

unsigned int
_bfd_elf_ppc_at_tprel_transform (unsigned int insn, unsigned int reg)
{
  if ((insn & (0x1f << 16)) == reg << 16
      && ((insn & (0x3f << 26)) == 14u << 26 /* addi */
	  || (insn & (0x3f << 26)) == 15u << 26 /* addis */
	  || (insn & (0x3f << 26)) == 32u << 26 /* lwz */
	  || (insn & (0x3f << 26)) == 34u << 26 /* lbz */
	  || (insn & (0x3f << 26)) == 36u << 26 /* stw */
	  || (insn & (0x3f << 26)) == 38u << 26 /* stb */
	  || (insn & (0x3f << 26)) == 40u << 26 /* lhz */
	  || (insn & (0x3f << 26)) == 42u << 26 /* lha */
	  || (insn & (0x3f << 26)) == 44u << 26 /* sth */
	  || (insn & (0x3f << 26)) == 46u << 26 /* lmw */
	  || (insn & (0x3f << 26)) == 47u << 26 /* stmw */
	  || (insn & (0x3f << 26)) == 48u << 26 /* lfs */
	  || (insn & (0x3f << 26)) == 50u << 26 /* lfd */
	  || (insn & (0x3f << 26)) == 52u << 26 /* stfs */
	  || (insn & (0x3f << 26)) == 54u << 26 /* stfd */
	  || ((insn & (0x3f << 26)) == 58u << 26 /* lwa,ld,lmd */
	      && (insn & 3) != 1)
	  || ((insn & (0x3f << 26)) == 62u << 26 /* std, stmd */
	      && ((insn & 3) == 0 || (insn & 3) == 3))))
    {
      insn &= ~(0x1f << 16);
    }
  else if ((insn & (0x1f << 21)) == reg << 21
	   && ((insn & (0x3e << 26)) == 24u << 26 /* ori, oris */
	       || (insn & (0x3e << 26)) == 26u << 26 /* xori,xoris */
	       || (insn & (0x3e << 26)) == 28u << 26 /* andi,andis */))
    {
      insn &= ~(0x1f << 21);
      insn |= (insn & (0x1f << 16)) << 5;
      if ((insn & (0x3e << 26)) == 26 << 26 /* xori,xoris */)
	insn -= 2 >> 26;  /* convert to ori,oris */
    }
  else
    insn = 0;
  return insn;
}

static bfd_boolean
is_insn_ds_form (unsigned int insn)
{
  return ((insn & (0x3f << 26)) == 58u << 26 /* ld,ldu,lwa */
	  || (insn & (0x3f << 26)) == 62u << 26 /* std,stdu,stq */
	  || (insn & (0x3f << 26)) == 57u << 26 /* lfdp */
	  || (insn & (0x3f << 26)) == 61u << 26 /* stfdp */);
}

static bfd_boolean
is_insn_dq_form (unsigned int insn)
{
  return (insn & (0x3f << 26)) == 56u << 26; /* lq */
}

/* The RELOCATE_SECTION function is called by the ELF backend linker
   to handle the relocations for a section.

   The relocs are always passed as Rela structures; if the section
   actually uses Rel structures, the r_addend field will always be
   zero.

   This function is responsible for adjust the section contents as
   necessary, and (if using Rela relocs and generating a
   relocatable output file) adjusting the reloc addend as
   necessary.

   This function does not have to worry about setting the reloc
   address or the reloc symbol index.

   LOCAL_SYMS is a pointer to the swapped in local symbols.

   LOCAL_SECTIONS is an array giving the section in the input file
   corresponding to the st_shndx field of each local symbol.

   The global hash table entry for the global symbols can be found
   via elf_sym_hashes (input_bfd).

   When generating relocatable output, this function must handle
   STB_LOCAL/STT_SECTION symbols specially.  The output symbol is
   going to be the section symbol corresponding to the output
   section, which means that the addend must be adjusted
   accordingly.  */

static bfd_boolean
ppc_elf_relocate_section (bfd *output_bfd,
			  struct bfd_link_info *info,
			  bfd *input_bfd,
			  asection *input_section,
			  bfd_byte *contents,
			  Elf_Internal_Rela *relocs,
			  Elf_Internal_Sym *local_syms,
			  asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct ppc_elf_link_hash_table *htab;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  Elf_Internal_Rela outrel;
  asection *got2;
  bfd_vma *local_got_offsets;
  bfd_boolean ret = TRUE;
  bfd_vma d_offset = (bfd_big_endian (output_bfd) ? 2 : 0);
  bfd_boolean is_vxworks_tls;

#ifdef DEBUG
  _bfd_error_handler ("ppc_elf_relocate_section called for %B section %A, "
		      "%ld relocations%s",
		      input_bfd, input_section,
		      (long) input_section->reloc_count,
		      (info->relocatable) ? " (relocatable)" : "");
#endif

  got2 = bfd_get_section_by_name (input_bfd, ".got2");

  /* Initialize howto table if not already done.  */
  if (!ppc_elf_howto_table[R_PPC_ADDR32])
    ppc_elf_howto_init ();

  htab = ppc_elf_hash_table (info);
  local_got_offsets = elf_local_got_offsets (input_bfd);
  symtab_hdr = &elf_symtab_hdr (input_bfd);
  sym_hashes = elf_sym_hashes (input_bfd);
  /* We have to handle relocations in vxworks .tls_vars sections
     specially, because the dynamic loader is 'weird'.  */
  is_vxworks_tls = (htab->is_vxworks && info->shared
		    && !strcmp (input_section->output_section->name,
				".tls_vars"));
  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      enum elf_ppc_reloc_type r_type;
      bfd_vma addend;
      bfd_reloc_status_type r;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      const char *sym_name;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      bfd_vma relocation;
      bfd_vma branch_bit, from;
      bfd_boolean unresolved_reloc;
      bfd_boolean warned;
      unsigned int tls_type, tls_mask, tls_gd;
      struct plt_entry **ifunc;

      r_type = ELF32_R_TYPE (rel->r_info);
      sym = NULL;
      sec = NULL;
      h = NULL;
      unresolved_reloc = FALSE;
      warned = FALSE;
      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  sym_name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym, sec);

	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);

	  sym_name = h->root.root.string;
	}

      if (sec != NULL && discarded_section (sec))
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  howto = NULL;
	  if (r_type < R_PPC_max)
	    howto = ppc_elf_howto_table[r_type];
	  RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					   rel, 1, relend, howto, 0, contents);
	}

      if (info->relocatable)
	{
	  if (got2 != NULL
	      && r_type == R_PPC_PLTREL24
	      && rel->r_addend != 0)
	    {
	      /* R_PPC_PLTREL24 is rather special.  If non-zero, the
		 addend specifies the GOT pointer offset within .got2.  */
	      rel->r_addend += got2->output_offset;
	    }
	  continue;
	}

      /* TLS optimizations.  Replace instruction sequences and relocs
	 based on information we collected in tls_optimize.  We edit
	 RELOCS so that --emit-relocs will output something sensible
	 for the final instruction stream.  */
      tls_mask = 0;
      tls_gd = 0;
      if (h != NULL)
	tls_mask = ((struct ppc_elf_link_hash_entry *) h)->tls_mask;
      else if (local_got_offsets != NULL)
	{
	  struct plt_entry **local_plt;
	  char *lgot_masks;
	  local_plt
	    = (struct plt_entry **) (local_got_offsets + symtab_hdr->sh_info);
	  lgot_masks = (char *) (local_plt + symtab_hdr->sh_info);
	  tls_mask = lgot_masks[r_symndx];
	}

      /* Ensure reloc mapping code below stays sane.  */
      if ((R_PPC_GOT_TLSLD16 & 3)    != (R_PPC_GOT_TLSGD16 & 3)
	  || (R_PPC_GOT_TLSLD16_LO & 3) != (R_PPC_GOT_TLSGD16_LO & 3)
	  || (R_PPC_GOT_TLSLD16_HI & 3) != (R_PPC_GOT_TLSGD16_HI & 3)
	  || (R_PPC_GOT_TLSLD16_HA & 3) != (R_PPC_GOT_TLSGD16_HA & 3)
	  || (R_PPC_GOT_TLSLD16 & 3)    != (R_PPC_GOT_TPREL16 & 3)
	  || (R_PPC_GOT_TLSLD16_LO & 3) != (R_PPC_GOT_TPREL16_LO & 3)
	  || (R_PPC_GOT_TLSLD16_HI & 3) != (R_PPC_GOT_TPREL16_HI & 3)
	  || (R_PPC_GOT_TLSLD16_HA & 3) != (R_PPC_GOT_TPREL16_HA & 3))
	abort ();
      switch (r_type)
	{
	default:
	  break;

	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	  if ((tls_mask & TLS_TLS) != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	      bfd_vma insn;

	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset - d_offset);
	      insn &= 31 << 21;
	      insn |= 0x3c020000;	/* addis 0,2,0 */
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset - d_offset);
	      r_type = R_PPC_TPREL16_HA;
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC_TLS:
	  if ((tls_mask & TLS_TLS) != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	      bfd_vma insn;

	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	      insn = _bfd_elf_ppc_at_tls_transform (insn, 2);
	      if (insn == 0)
		abort ();
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	      r_type = R_PPC_TPREL16_LO;
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);

	      /* Was PPC_TLS which sits on insn boundary, now
		 PPC_TPREL16_LO which is at low-order half-word.  */
	      rel->r_offset += d_offset;
	    }
	  break;

	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_gd = TLS_TPRELGD;
	  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_gdld_hi;
	  break;

	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0)
	    {
	    tls_gdld_hi:
	      if ((tls_mask & tls_gd) != 0)
		r_type = (((r_type - (R_PPC_GOT_TLSGD16 & 3)) & 3)
			  + R_PPC_GOT_TPREL16);
	      else
		{
		  bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
		  rel->r_offset -= d_offset;
		  r_type = R_PPC_NONE;
		}
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	  tls_gd = TLS_TPRELGD;
	  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_ldgd_opt;
	  break;

	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0)
	    {
	      unsigned int insn1, insn2;
	      bfd_vma offset;

	    tls_ldgd_opt:
	      offset = (bfd_vma) -1;
	      /* If not using the newer R_PPC_TLSGD/LD to mark
		 __tls_get_addr calls, we must trust that the call
		 stays with its arg setup insns, ie. that the next
		 reloc is the __tls_get_addr call associated with
		 the current reloc.  Edit both insns.  */
	      if (input_section->has_tls_get_addr_call
		  && rel + 1 < relend
		  && branch_reloc_hash_match (input_bfd, rel + 1,
					      htab->tls_get_addr))
		offset = rel[1].r_offset;
	      if ((tls_mask & tls_gd) != 0)
		{
		  /* IE */
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - d_offset);
		  insn1 &= (1 << 26) - 1;
		  insn1 |= 32 << 26;	/* lwz */
		  if (offset != (bfd_vma) -1)
		    {
		      rel[1].r_info = ELF32_R_INFO (STN_UNDEF, R_PPC_NONE);
		      insn2 = 0x7c631214;	/* add 3,3,2 */
		      bfd_put_32 (output_bfd, insn2, contents + offset);
		    }
		  r_type = (((r_type - (R_PPC_GOT_TLSGD16 & 3)) & 3)
			    + R_PPC_GOT_TPREL16);
		  rel->r_info = ELF32_R_INFO (r_symndx, r_type);
		}
	      else
		{
		  /* LE */
		  insn1 = 0x3c620000;	/* addis 3,2,0 */
		  if (tls_gd == 0)
		    {
		      /* Was an LD reloc.  */
		      for (r_symndx = 0;
			   r_symndx < symtab_hdr->sh_info;
			   r_symndx++)
			if (local_sections[r_symndx] == sec)
			  break;
		      if (r_symndx >= symtab_hdr->sh_info)
			r_symndx = STN_UNDEF;
		      rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
		      if (r_symndx != STN_UNDEF)
			rel->r_addend -= (local_syms[r_symndx].st_value
					  + sec->output_offset
					  + sec->output_section->vma);
		    }
		  r_type = R_PPC_TPREL16_HA;
		  rel->r_info = ELF32_R_INFO (r_symndx, r_type);
		  if (offset != (bfd_vma) -1)
		    {
		      rel[1].r_info = ELF32_R_INFO (r_symndx, R_PPC_TPREL16_LO);
		      rel[1].r_offset = offset + d_offset;
		      rel[1].r_addend = rel->r_addend;
		      insn2 = 0x38630000;	/* addi 3,3,0 */
		      bfd_put_32 (output_bfd, insn2, contents + offset);
		    }
		}
	      bfd_put_32 (output_bfd, insn1,
			  contents + rel->r_offset - d_offset);
	      if (tls_gd == 0)
		{
		  /* We changed the symbol on an LD reloc.  Start over
		     in order to get h, sym, sec etc. right.  */
		  rel--;
		  continue;
		}
	    }
	  break;

	case R_PPC_TLSGD:
	  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_GD) == 0)
	    {
	      unsigned int insn2;
	      bfd_vma offset = rel->r_offset;

	      if ((tls_mask & TLS_TPRELGD) != 0)
		{
		  /* IE */
		  r_type = R_PPC_NONE;
		  insn2 = 0x7c631214;	/* add 3,3,2 */
		}
	      else
		{
		  /* LE */
		  r_type = R_PPC_TPREL16_LO;
		  rel->r_offset += d_offset;
		  insn2 = 0x38630000;	/* addi 3,3,0 */
		}
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      bfd_put_32 (output_bfd, insn2, contents + offset);
	      /* Zap the reloc on the _tls_get_addr call too.  */
	      BFD_ASSERT (offset == rel[1].r_offset);
	      rel[1].r_info = ELF32_R_INFO (STN_UNDEF, R_PPC_NONE);
	    }
	  break;

	case R_PPC_TLSLD:
	  if ((tls_mask & TLS_TLS) != 0 && (tls_mask & TLS_LD) == 0)
	    {
	      unsigned int insn2;

	      for (r_symndx = 0;
		   r_symndx < symtab_hdr->sh_info;
		   r_symndx++)
		if (local_sections[r_symndx] == sec)
		  break;
	      if (r_symndx >= symtab_hdr->sh_info)
		r_symndx = STN_UNDEF;
	      rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
	      if (r_symndx != STN_UNDEF)
		rel->r_addend -= (local_syms[r_symndx].st_value
				  + sec->output_offset
				  + sec->output_section->vma);

	      rel->r_info = ELF32_R_INFO (r_symndx, R_PPC_TPREL16_LO);
	      rel->r_offset += d_offset;
	      insn2 = 0x38630000;	/* addi 3,3,0 */
	      bfd_put_32 (output_bfd, insn2,
			  contents + rel->r_offset - d_offset);
	      /* Zap the reloc on the _tls_get_addr call too.  */
	      BFD_ASSERT (rel->r_offset - d_offset == rel[1].r_offset);
	      rel[1].r_info = ELF32_R_INFO (STN_UNDEF, R_PPC_NONE);
	      rel--;
	      continue;
	    }
	  break;
	}

      /* Handle other relocations that tweak non-addend part of insn.  */
      branch_bit = 0;
      switch (r_type)
	{
	default:
	  break;

	  /* Branch taken prediction relocations.  */
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_REL14_BRTAKEN:
	  branch_bit = BRANCH_PREDICT_BIT;
	  /* Fall thru */

	  /* Branch not taken prediction relocations.  */
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  {
	    bfd_vma insn;

	    insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	    insn &= ~BRANCH_PREDICT_BIT;
	    insn |= branch_bit;

	    from = (rel->r_offset
		    + input_section->output_offset
		    + input_section->output_section->vma);

	    /* Invert 'y' bit if not the default.  */
	    if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
	      insn ^= BRANCH_PREDICT_BIT;

	    bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	    break;
	  }
	}

      ifunc = NULL;
      if (!htab->is_vxworks)
	{
	  struct plt_entry *ent;

	  if (h != NULL)
	    {
	      if (h->type == STT_GNU_IFUNC)
		ifunc = &h->plt.plist;
	    }
	  else if (local_got_offsets != NULL
		   && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
	    {
	      struct plt_entry **local_plt;

	      local_plt = (struct plt_entry **) (local_got_offsets
						 + symtab_hdr->sh_info);
	      ifunc = local_plt + r_symndx;
	    }

	  ent = NULL;
	  if (ifunc != NULL
	      && (!info->shared
		  || is_branch_reloc (r_type)))
	    {
	      addend = 0;
	      if (r_type == R_PPC_PLTREL24 && info->shared)
		addend = rel->r_addend;
	      ent = find_plt_ent (ifunc, got2, addend);
	    }
	  if (ent != NULL)
	    {
	      if (h == NULL && (ent->plt.offset & 1) == 0)
		{
		  Elf_Internal_Rela rela;
		  bfd_byte *loc;

		  rela.r_offset = (htab->iplt->output_section->vma
				   + htab->iplt->output_offset
				   + ent->plt.offset);
		  rela.r_info = ELF32_R_INFO (0, R_PPC_IRELATIVE);
		  rela.r_addend = relocation;
		  loc = htab->reliplt->contents;
		  loc += (htab->reliplt->reloc_count++
			  * sizeof (Elf32_External_Rela));
		  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);

		  ent->plt.offset |= 1;
		}
	      if (h == NULL && (ent->glink_offset & 1) == 0)
		{
		  unsigned char *p = ((unsigned char *) htab->glink->contents
				      + ent->glink_offset);
		  write_glink_stub (ent, htab->iplt, p, info);
		  ent->glink_offset |= 1;
		}

	      unresolved_reloc = FALSE;
	      if (htab->plt_type == PLT_NEW
		  || !htab->elf.dynamic_sections_created
		  || h == NULL)
		relocation = (htab->glink->output_section->vma
			      + htab->glink->output_offset
			      + (ent->glink_offset & ~1));
	      else
		relocation = (htab->plt->output_section->vma
			      + htab->plt->output_offset
			      + ent->plt.offset);
	    }
	}

      addend = rel->r_addend;
      tls_type = 0;
      howto = NULL;
      if (r_type < R_PPC_max)
	howto = ppc_elf_howto_table[r_type];
      switch (r_type)
	{
	default:
	  info->callbacks->einfo
	    (_("%P: %B: unknown relocation type %d for symbol %s\n"),
	     input_bfd, (int) r_type, sym_name);

	  bfd_set_error (bfd_error_bad_value);
	  ret = FALSE;
	  continue;

	case R_PPC_NONE:
	case R_PPC_TLS:
	case R_PPC_TLSGD:
	case R_PPC_TLSLD:
	case R_PPC_EMB_MRKREF:
	case R_PPC_GNU_VTINHERIT:
	case R_PPC_GNU_VTENTRY:
	  continue;

	  /* GOT16 relocations.  Like an ADDR16 using the symbol's
	     address in the GOT as relocation value instead of the
	     symbol's value itself.  Also, create a GOT entry for the
	     symbol and put the symbol value there.  */
	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogot;

	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogot;

	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogot;

	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	  goto dogot;

	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_GOT16_HI:
	case R_PPC_GOT16_HA:
	  tls_mask = 0;
	dogot:
	  {
	    /* Relocation is to the entry for this symbol in the global
	       offset table.  */
	    bfd_vma off;
	    bfd_vma *offp;
	    unsigned long indx;

	    if (htab->got == NULL)
	      abort ();

	    indx = 0;
	    if (tls_type == (TLS_TLS | TLS_LD)
		&& (h == NULL
		    || !h->def_dynamic))
	      offp = &htab->tlsld_got.offset;
	    else if (h != NULL)
	      {
		bfd_boolean dyn;
		dyn = htab->elf.dynamic_sections_created;
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		    || (info->shared
			&& SYMBOL_REFERENCES_LOCAL (info, h)))
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  */
		  ;
		else
		  {
		    BFD_ASSERT (h->dynindx != -1);
		    indx = h->dynindx;
		    unresolved_reloc = FALSE;
		  }
		offp = &h->got.offset;
	      }
	    else
	      {
		if (local_got_offsets == NULL)
		  abort ();
		offp = &local_got_offsets[r_symndx];
	      }

	    /* The offset must always be a multiple of 4.  We use the
	       least significant bit to record whether we have already
	       processed this entry.  */
	    off = *offp;
	    if ((off & 1) != 0)
	      off &= ~1;
	    else
	      {
		unsigned int tls_m = (tls_mask
				      & (TLS_LD | TLS_GD | TLS_DTPREL
					 | TLS_TPREL | TLS_TPRELGD));

		if (offp == &htab->tlsld_got.offset)
		  tls_m = TLS_LD;
		else if (h == NULL
			 || !h->def_dynamic)
		  tls_m &= ~TLS_LD;

		/* We might have multiple got entries for this sym.
		   Initialize them all.  */
		do
		  {
		    int tls_ty = 0;

		    if ((tls_m & TLS_LD) != 0)
		      {
			tls_ty = TLS_TLS | TLS_LD;
			tls_m &= ~TLS_LD;
		      }
		    else if ((tls_m & TLS_GD) != 0)
		      {
			tls_ty = TLS_TLS | TLS_GD;
			tls_m &= ~TLS_GD;
		      }
		    else if ((tls_m & TLS_DTPREL) != 0)
		      {
			tls_ty = TLS_TLS | TLS_DTPREL;
			tls_m &= ~TLS_DTPREL;
		      }
		    else if ((tls_m & (TLS_TPREL | TLS_TPRELGD)) != 0)
		      {
			tls_ty = TLS_TLS | TLS_TPREL;
			tls_m = 0;
		      }

		    /* Generate relocs for the dynamic linker.  */
		    if ((info->shared || indx != 0)
			&& (offp == &htab->tlsld_got.offset
			    || h == NULL
			    || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			    || h->root.type != bfd_link_hash_undefweak))
		      {
			asection *rsec = htab->relgot;
			bfd_byte * loc;

			if (ifunc != NULL)
			  rsec = htab->reliplt;
			outrel.r_offset = (htab->got->output_section->vma
					   + htab->got->output_offset
					   + off);
			outrel.r_addend = 0;
			if (tls_ty & (TLS_LD | TLS_GD))
			  {
			    outrel.r_info = ELF32_R_INFO (indx, R_PPC_DTPMOD32);
			    if (tls_ty == (TLS_TLS | TLS_GD))
			      {
				loc = rsec->contents;
				loc += (rsec->reloc_count++
					* sizeof (Elf32_External_Rela));
				bfd_elf32_swap_reloca_out (output_bfd,
							   &outrel, loc);
				outrel.r_offset += 4;
				outrel.r_info
				  = ELF32_R_INFO (indx, R_PPC_DTPREL32);
			      }
			  }
			else if (tls_ty == (TLS_TLS | TLS_DTPREL))
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_DTPREL32);
			else if (tls_ty == (TLS_TLS | TLS_TPREL))
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_TPREL32);
			else if (indx != 0)
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_GLOB_DAT);
			else if (ifunc != NULL)
			  outrel.r_info = ELF32_R_INFO (0, R_PPC_IRELATIVE);
			else
			  outrel.r_info = ELF32_R_INFO (0, R_PPC_RELATIVE);
			if (indx == 0 && tls_ty != (TLS_TLS | TLS_LD))
			  {
			    outrel.r_addend += relocation;
			    if (tls_ty & (TLS_GD | TLS_DTPREL | TLS_TPREL))
			      outrel.r_addend -= htab->elf.tls_sec->vma;
			  }
			loc = rsec->contents;
			loc += (rsec->reloc_count++
				* sizeof (Elf32_External_Rela));
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		      }

		    /* Init the .got section contents if we're not
		       emitting a reloc.  */
		    else
		      {
			bfd_vma value = relocation;

			if (tls_ty == (TLS_TLS | TLS_LD))
			  value = 1;
			else if (tls_ty != 0)
			  {
			    value -= htab->elf.tls_sec->vma + DTP_OFFSET;
			    if (tls_ty == (TLS_TLS | TLS_TPREL))
			      value += DTP_OFFSET - TP_OFFSET;

			    if (tls_ty == (TLS_TLS | TLS_GD))
			      {
				bfd_put_32 (output_bfd, value,
					    htab->got->contents + off + 4);
				value = 1;
			      }
			  }
			bfd_put_32 (output_bfd, value,
				    htab->got->contents + off);
		      }

		    off += 4;
		    if (tls_ty & (TLS_LD | TLS_GD))
		      off += 4;
		  }
		while (tls_m != 0);

		off = *offp;
		*offp = off | 1;
	      }

	    if (off >= (bfd_vma) -2)
	      abort ();

	    if ((tls_type & TLS_TLS) != 0)
	      {
		if (tls_type != (TLS_TLS | TLS_LD))
		  {
		    if ((tls_mask & TLS_LD) != 0
			&& !(h == NULL
			     || !h->def_dynamic))
		      off += 8;
		    if (tls_type != (TLS_TLS | TLS_GD))
		      {
			if ((tls_mask & TLS_GD) != 0)
			  off += 8;
			if (tls_type != (TLS_TLS | TLS_DTPREL))
			  {
			    if ((tls_mask & TLS_DTPREL) != 0)
			      off += 4;
			  }
		      }
		  }
	      }

	    relocation = (htab->got->output_section->vma
			  + htab->got->output_offset
			  + off
			  - SYM_VAL (htab->elf.hgot));

	    /* Addends on got relocations don't make much sense.
	       x+off@@got is actually x@@got+off, and since the got is
	       generated by a hash table traversal, the value in the
	       got at entry m+n bears little relation to the entry m.  */
	    if (addend != 0)
	      info->callbacks->einfo
		(_("%P: %H: non-zero addend on %s reloc against `%s'\n"),
		 input_bfd, input_section, rel->r_offset,
		 howto->name,
		 sym_name);
	  }
	break;

	/* Relocations that need no special processing.  */
	case R_PPC_LOCAL24PC:
	  /* It makes no sense to point a local relocation
	     at a symbol not in this object.  */
	  if (unresolved_reloc)
	    {
	      if (! (*info->callbacks->undefined_symbol) (info,
							  h->root.root.string,
							  input_bfd,
							  input_section,
							  rel->r_offset,
							  TRUE))
		return FALSE;
	      continue;
	    }
	  break;

	case R_PPC_DTPREL16:
	case R_PPC_DTPREL16_LO:
	case R_PPC_DTPREL16_HI:
	case R_PPC_DTPREL16_HA:
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
	  break;

	  /* Relocations that may need to be propagated if this is a shared
	     object.  */
	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_TPREL16_HI:
	case R_PPC_TPREL16_HA:
	  if (h != NULL
	      && h->root.type == bfd_link_hash_undefweak
	      && h->dynindx == -1)
	    {
	      /* Make this relocation against an undefined weak symbol
		 resolve to zero.  This is really just a tweak, since
		 code using weak externs ought to check that they are
		 defined before using them.  */
	      bfd_byte *p = contents + rel->r_offset - d_offset;
	      unsigned int insn = bfd_get_32 (output_bfd, p);
	      insn = _bfd_elf_ppc_at_tprel_transform (insn, 2);
	      if (insn != 0)
		bfd_put_32 (output_bfd, insn, p);
	      break;
	    }
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
	  /* The TPREL16 relocs shouldn't really be used in shared
	     libs as they will result in DT_TEXTREL being set, but
	     support them anyway.  */
	  goto dodyn;

	case R_PPC_TPREL32:
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
	  goto dodyn;

	case R_PPC_DTPREL32:
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
	  goto dodyn;

	case R_PPC_DTPMOD32:
	  relocation = 1;
	  addend = 0;
	  goto dodyn;

	case R_PPC_REL16:
	case R_PPC_REL16_LO:
	case R_PPC_REL16_HI:
	case R_PPC_REL16_HA:
	  break;

	case R_PPC_REL32:
	  if (h == NULL || h == htab->elf.hgot)
	    break;
	  /* fall through */

	case R_PPC_ADDR32:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	  goto dodyn;

	case R_PPC_VLE_REL8:
	case R_PPC_VLE_REL15:
	case R_PPC_VLE_REL24:
	case R_PPC_REL24:
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  /* If these relocations are not to a named symbol, they can be
	     handled right here, no need to bother the dynamic linker.  */
	  if (SYMBOL_CALLS_LOCAL (info, h)
	      || h == htab->elf.hgot)
	    break;
	  /* fall through */

	case R_PPC_ADDR24:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	  if (h != NULL && !info->shared)
	    break;
	  /* fall through */

	dodyn:
	  if ((input_section->flags & SEC_ALLOC) == 0
	      || is_vxworks_tls)
	    break;

	  if ((info->shared
	       && !(h != NULL
		    && ((h->root.type == bfd_link_hash_undefined
			 && (ELF_ST_VISIBILITY (h->other) == STV_HIDDEN
			     || ELF_ST_VISIBILITY (h->other) == STV_INTERNAL))
			|| (h->root.type == bfd_link_hash_undefweak
			    && ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)))
	       && (must_be_dyn_reloc (info, r_type)
		   || !SYMBOL_CALLS_LOCAL (info, h)))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && h != NULL
		  && h->dynindx != -1
		  && !h->non_got_ref
		  && !h->def_regular))
	    {
	      int skip;
	      bfd_byte *loc;
	      asection *sreloc;
#ifdef DEBUG
	      fprintf (stderr, "ppc_elf_relocate_section needs to "
		       "create relocation for %s\n",
		       (h && h->root.root.string
			? h->root.root.string : "<unknown>"));
#endif

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (ifunc)
		sreloc = htab->reliplt;
	      if (sreloc == NULL)
		return FALSE;

	      skip = 0;
	      outrel.r_offset = _bfd_elf_section_offset (output_bfd, info,
							 input_section,
							 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1
		  || outrel.r_offset == (bfd_vma) -2)
		skip = (int) outrel.r_offset;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		memset (&outrel, 0, sizeof outrel);
	      else if ((h != NULL
			&& (h->root.type == bfd_link_hash_undefined
			    || h->root.type == bfd_link_hash_undefweak))
		       || !SYMBOL_REFERENCES_LOCAL (info, h))
		{
		  BFD_ASSERT (h->dynindx != -1);
		  unresolved_reloc = FALSE;
		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
		  outrel.r_addend = rel->r_addend;
		}
	      else
		{
		  outrel.r_addend = relocation + rel->r_addend;

		  if (r_type != R_PPC_ADDR32)
		    {
		      long indx = 0;

		      if (ifunc != NULL)
			{
			  /* If we get here when building a static
			     executable, then the libc startup function
			     responsible for applying indirect function
			     relocations is going to complain about
			     the reloc type.
			     If we get here when building a dynamic
			     executable, it will be because we have
			     a text relocation.  The dynamic loader
			     will set the text segment writable and
			     non-executable to apply text relocations.
			     So we'll segfault when trying to run the
			     indirection function to resolve the reloc.  */
			  info->callbacks->einfo
			    (_("%P: %H: relocation %s for indirect "
			       "function %s unsupported\n"),
			     input_bfd, input_section, rel->r_offset,
			     howto->name,
			     sym_name);
			  ret = FALSE;
			}
		      else if (r_symndx == STN_UNDEF || bfd_is_abs_section (sec))
			;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  ret = FALSE;
			}
		      else
			{
			  asection *osec;

			  /* We are turning this relocation into one
			     against a section symbol.  It would be
			     proper to subtract the symbol's value,
			     osec->vma, from the emitted reloc addend,
			     but ld.so expects buggy relocs.
			     FIXME: Why not always use a zero index?  */
			  osec = sec->output_section;
			  indx = elf_section_data (osec)->dynindx;
			  if (indx == 0)
			    {
			      osec = htab->elf.text_index_section;
			      indx = elf_section_data (osec)->dynindx;
			    }
			  BFD_ASSERT (indx != 0);
#ifdef DEBUG
			  if (indx == 0)
			    printf ("indx=%ld section=%s flags=%08x name=%s\n",
				    indx, osec->name, osec->flags,
				    h->root.root.string);
#endif
			}

		      outrel.r_info = ELF32_R_INFO (indx, r_type);
		    }
		  else if (ifunc != NULL)
		    outrel.r_info = ELF32_R_INFO (0, R_PPC_IRELATIVE);
		  else
		    outrel.r_info = ELF32_R_INFO (0, R_PPC_RELATIVE);
		}

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      if (skip == -1)
		continue;

	      /* This reloc will be computed at runtime.  We clear the memory
		 so that it contains predictable value.  */
	      if (! skip
		  && ((input_section->flags & SEC_ALLOC) != 0
		      || ELF32_R_TYPE (outrel.r_info) != R_PPC_RELATIVE))
		{
		  relocation = howto->pc_relative ? outrel.r_offset : 0;
		  addend = 0;
		  break;
		}
	    }
	  break;

	case R_PPC_RELAX_PLT:
	case R_PPC_RELAX_PLTREL24:
	  if (h != NULL)
	    {
	      struct plt_entry *ent;
	      bfd_vma got2_addend = 0;

	      if (r_type == R_PPC_RELAX_PLTREL24)
		{
		  if (info->shared)
		    got2_addend = addend;
		  addend = 0;
		}
	      ent = find_plt_ent (&h->plt.plist, got2, got2_addend);
	      if (htab->plt_type == PLT_NEW)
		relocation = (htab->glink->output_section->vma
			      + htab->glink->output_offset
			      + ent->glink_offset);
	      else
		relocation = (htab->plt->output_section->vma
			      + htab->plt->output_offset
			      + ent->plt.offset);
	    }
	  /* Fall thru */

	case R_PPC_RELAX:
	  if (info->shared)
	    relocation -= (input_section->output_section->vma
			   + input_section->output_offset
			   + rel->r_offset - 4);

	  {
	    unsigned long t0;
	    unsigned long t1;

	    t0 = bfd_get_32 (output_bfd, contents + rel->r_offset);
	    t1 = bfd_get_32 (output_bfd, contents + rel->r_offset + 4);

	    /* We're clearing the bits for R_PPC_ADDR16_HA
	       and R_PPC_ADDR16_LO here.  */
	    t0 &= ~0xffff;
	    t1 &= ~0xffff;

	    /* t0 is HA, t1 is LO */
	    relocation += addend;
	    t0 |= ((relocation + 0x8000) >> 16) & 0xffff;
	    t1 |= relocation & 0xffff;

	    bfd_put_32 (output_bfd, t0, contents + rel->r_offset);
	    bfd_put_32 (output_bfd, t1, contents + rel->r_offset + 4);

	    /* Rewrite the reloc and convert one of the trailing nop
	       relocs to describe this relocation.  */
	    BFD_ASSERT (ELF32_R_TYPE (relend[-1].r_info) == R_PPC_NONE);
	    /* The relocs are at the bottom 2 bytes */
	    rel[0].r_offset += 2;
	    memmove (rel + 1, rel, (relend - rel - 1) * sizeof (*rel));
	    rel[0].r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_HA);
	    rel[1].r_offset += 4;
	    rel[1].r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_LO);
	    rel++;
	  }
	  continue;

	  /* Indirect .sdata relocation.  */
	case R_PPC_EMB_SDAI16:
	  BFD_ASSERT (htab->sdata[0].section != NULL);
	  if (!is_static_defined (htab->sdata[0].sym))
	    {
	      unresolved_reloc = TRUE;
	      break;
	    }
	  relocation
	    = elf_finish_pointer_linker_section (input_bfd, &htab->sdata[0],
						 h, relocation, rel);
	  addend = 0;
	  break;

	  /* Indirect .sdata2 relocation.  */
	case R_PPC_EMB_SDA2I16:
	  BFD_ASSERT (htab->sdata[1].section != NULL);
	  if (!is_static_defined (htab->sdata[1].sym))
	    {
	      unresolved_reloc = TRUE;
	      break;
	    }
	  relocation
	    = elf_finish_pointer_linker_section (input_bfd, &htab->sdata[1],
						 h, relocation, rel);
	  addend = 0;
	  break;

	  /* Handle the TOC16 reloc.  We want to use the offset within the .got
	     section, not the actual VMA.  This is appropriate when generating
	     an embedded ELF object, for which the .got section acts like the
	     AIX .toc section.  */
	case R_PPC_TOC16:			/* phony GOT16 relocations */
	  if (sec == NULL || sec->output_section == NULL)
	    {
	      unresolved_reloc = TRUE;
	      break;
	    }
	  BFD_ASSERT (strcmp (bfd_get_section_name (sec->owner, sec),
			      ".got") == 0
		      || strcmp (bfd_get_section_name (sec->owner, sec),
				 ".cgot") == 0);

	  addend -= sec->output_section->vma + sec->output_offset + 0x8000;
	  break;

	case R_PPC_PLTREL24:
	  if (h != NULL && ifunc == NULL)
	    {
	      struct plt_entry *ent = find_plt_ent (&h->plt.plist, got2,
						    info->shared ? addend : 0);
	      if (ent == NULL
		  || htab->plt == NULL)
		{
		  /* We didn't make a PLT entry for this symbol.  This
		     happens when statically linking PIC code, or when
		     using -Bsymbolic.  */
		}
	      else
		{
		  /* Relocation is to the entry for this symbol in the
		     procedure linkage table.  */
		  unresolved_reloc = FALSE;
		  if (htab->plt_type == PLT_NEW)
		    relocation = (htab->glink->output_section->vma
				  + htab->glink->output_offset
				  + ent->glink_offset);
		  else
		    relocation = (htab->plt->output_section->vma
				  + htab->plt->output_offset
				  + ent->plt.offset);
		}
	    }

	  /* R_PPC_PLTREL24 is rather special.  If non-zero, the
	     addend specifies the GOT pointer offset within .got2.
	     Don't apply it to the relocation field.  */
	  addend = 0;
	  break;

	  /* Relocate against _SDA_BASE_.  */
	case R_PPC_SDAREL16:
	  {
	    const char *name;
	    struct elf_link_hash_entry *sda = htab->sdata[0].sym;

	    if (sec == NULL
		|| sec->output_section == NULL
		|| !is_static_defined (sda))
	      {
		unresolved_reloc = TRUE;
		break;
	      }
	    addend -= SYM_VAL (sda);

	    name = bfd_get_section_name (output_bfd, sec->output_section);
	    if (! ((CONST_STRNEQ (name, ".sdata")
		    && (name[6] == 0 || name[6] == '.'))
		   || (CONST_STRNEQ (name, ".sbss")
		       && (name[5] == 0 || name[5] == '.'))))
	      {
		info->callbacks->einfo
		  (_("%P: %B: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)\n"),
		   input_bfd,
		   sym_name,
		   howto->name,
		   name);
	      }
	  }
	  break;

	  /* Relocate against _SDA2_BASE_.  */
	case R_PPC_EMB_SDA2REL:
	  {
	    const char *name;
	    struct elf_link_hash_entry *sda = htab->sdata[1].sym;

	    if (sec == NULL
		|| sec->output_section == NULL
		|| !is_static_defined (sda))
	      {
		unresolved_reloc = TRUE;
		break;
	      }
	    addend -= SYM_VAL (sda);

	    name = bfd_get_section_name (output_bfd, sec->output_section);
	    if (! (CONST_STRNEQ (name, ".sdata2")
		   || CONST_STRNEQ (name, ".sbss2")))
	      {
		info->callbacks->einfo
		  (_("%P: %B: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)\n"),
		   input_bfd,
		   sym_name,
		   howto->name,
		   name);
	      }
	  }
	  break;

	case R_PPC_VLE_LO16A:
	  relocation = (relocation + addend) & 0xffff;
	  ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                               relocation, split16a_type);
	  continue;

	case R_PPC_VLE_LO16D:
	  relocation = (relocation + addend) & 0xffff;
	  ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                               relocation, split16d_type);
	  continue;

	case R_PPC_VLE_HI16A:
	  relocation = ((relocation + addend) >> 16) & 0xffff;
	  ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                               relocation, split16a_type);
	  continue;

	case R_PPC_VLE_HI16D:
	  relocation = ((relocation + addend) >> 16) & 0xffff;
	  ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                               relocation, split16d_type);
	  continue;

	case R_PPC_VLE_HA16A:
	  {
	    bfd_vma value = relocation + addend;
	    value = (((value >> 16) + ((value & 0x8000) ? 1 : 0)) & 0xffff);
	    ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                                 value, split16a_type);
	  }
	  continue;

	case R_PPC_VLE_HA16D:
	  {
	    bfd_vma value = relocation + addend;
	    value = (((value >> 16) + ((value & 0x8000) ? 1 : 0)) & 0xffff);
	    ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                                 value, split16d_type);
	  }
	  continue;

	  /* Relocate against either _SDA_BASE_, _SDA2_BASE_, or 0.  */
	case R_PPC_EMB_SDA21:
	case R_PPC_VLE_SDA21:
	case R_PPC_EMB_RELSDA:
	case R_PPC_VLE_SDA21_LO:
	  {
	    const char *name;
	    int reg;
	    struct elf_link_hash_entry *sda = NULL;

	    if (sec == NULL || sec->output_section == NULL)
	      {
		unresolved_reloc = TRUE;
		break;
	      }

	    name = bfd_get_section_name (output_bfd, sec->output_section);
	    if (((CONST_STRNEQ (name, ".sdata")
		  && (name[6] == 0 || name[6] == '.'))
		 || (CONST_STRNEQ (name, ".sbss")
		     && (name[5] == 0 || name[5] == '.'))))
	      {
		reg = 13;
		sda = htab->sdata[0].sym;
	      }
	    else if (CONST_STRNEQ (name, ".sdata2")
		     || CONST_STRNEQ (name, ".sbss2"))
	      {
		reg = 2;
		sda = htab->sdata[1].sym;
	      }
	    else if (strcmp (name, ".PPC.EMB.sdata0") == 0
		     || strcmp (name, ".PPC.EMB.sbss0") == 0)
	      {
		reg = 0;
	      }
	    else
	      {
		info->callbacks->einfo
		  (_("%P: %B: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)\n"),
		   input_bfd,
		   sym_name,
		   howto->name,
		   name);

		bfd_set_error (bfd_error_bad_value);
		ret = FALSE;
		continue;
	      }

	    if (sda != NULL)
	      {
		if (!is_static_defined (sda))
		  {
		    unresolved_reloc = TRUE;
		    break;
		  }
		addend -= SYM_VAL (sda);
	      }

	    if (reg == 0
		&& (r_type == R_PPC_VLE_SDA21
		    || r_type == R_PPC_VLE_SDA21_LO))
	      {
		/* Use the split20 format.  */
		bfd_vma insn, bits12to15, bits21to31;
		bfd_vma value  = (relocation + rel->r_offset) & 0xffff;
		/* Propagate sign bit, if necessary.  */
		insn = (value & 0x8000) ? 0x70107800 : 0x70000000;
		bits12to15 = value & 0x700;
		bits21to31 = value & 0x7ff;
		insn |= bits12to15;
		insn |= bits21to31;
  		bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
		continue;
	      }
	    else if (r_type == R_PPC_EMB_SDA21
		     || r_type == R_PPC_VLE_SDA21
		     || r_type == R_PPC_VLE_SDA21_LO)
	      {
		bfd_vma insn;  /* Fill in register field.  */

		insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
		insn = (insn & ~RA_REGISTER_MASK) | (reg << RA_REGISTER_SHIFT);
		bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	      }
	  }
	  break;

	case R_PPC_VLE_SDAREL_LO16A:
	case R_PPC_VLE_SDAREL_LO16D:
	case R_PPC_VLE_SDAREL_HI16A:
	case R_PPC_VLE_SDAREL_HI16D:
	case R_PPC_VLE_SDAREL_HA16A:
	case R_PPC_VLE_SDAREL_HA16D:
	  {
	    bfd_vma value;
	    const char *name;
	    //int reg;
	    struct elf_link_hash_entry *sda = NULL;

	    if (sec == NULL || sec->output_section == NULL)
	      {
		unresolved_reloc = TRUE;
		break;
	      }

	    name = bfd_get_section_name (output_bfd, sec->output_section);
	    if (((CONST_STRNEQ (name, ".sdata")
		  && (name[6] == 0 || name[6] == '.'))
		 || (CONST_STRNEQ (name, ".sbss")
		     && (name[5] == 0 || name[5] == '.'))))
	      {
		//reg = 13;
		sda = htab->sdata[0].sym;
	      }
	    else if (CONST_STRNEQ (name, ".sdata2")
		     || CONST_STRNEQ (name, ".sbss2"))
	      {
		//reg = 2;
		sda = htab->sdata[1].sym;
	      }
	    else
	      {
		(*_bfd_error_handler)
		  (_("%B: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)"),
		   input_bfd,
		   sym_name,
		   howto->name,
		   name);

		bfd_set_error (bfd_error_bad_value);
		ret = FALSE;
		continue;
	      }

	    if (sda != NULL)
	      {
		if (!is_static_defined (sda))
		  {
		    unresolved_reloc = TRUE;
		    break;
		  }
	      }

	   value = sda->root.u.def.section->output_section->vma
   		   + sda->root.u.def.section->output_offset;

	   if (r_type == R_PPC_VLE_SDAREL_LO16A)
	      {
		value = (value + addend) & 0xffff;
	        ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                                     value, split16a_type);
	      }
	   else if (r_type == R_PPC_VLE_SDAREL_LO16D)
	      {
		value = (value + addend) & 0xffff;
	        ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                                     value, split16d_type);
	      }
	   else if (r_type == R_PPC_VLE_SDAREL_HI16A)
	      {
		value = ((value + addend) >> 16) & 0xffff;
	        ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                                     value, split16a_type);
	      }
	   else if (r_type == R_PPC_VLE_SDAREL_HI16D)
	      {
		value = ((value + addend) >> 16) & 0xffff;
	        ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                                     value, split16d_type);
	      }
	   else if (r_type == R_PPC_VLE_SDAREL_HA16A)
	      {
		value += addend;
		value = (((value >> 16) + ((value & 0x8000) ? 1 : 0)) & 0xffff);
	        ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                                     value, split16a_type);
	      }
	   else if (r_type == R_PPC_VLE_SDAREL_HA16D)
	      {
		value += addend;
		value = (((value >> 16) + ((value & 0x8000) ? 1 : 0)) & 0xffff);
	        ppc_elf_vle_split16 (output_bfd, contents, rel->r_offset,
                                     value, split16d_type);
	      }
	  }
	  continue;

	  /* Relocate against the beginning of the section.  */
	case R_PPC_SECTOFF:
	case R_PPC_SECTOFF_LO:
	case R_PPC_SECTOFF_HI:
	case R_PPC_SECTOFF_HA:
	  if (sec == NULL || sec->output_section == NULL)
	    {
	      unresolved_reloc = TRUE;
	      break;
	    }
	  addend -= sec->output_section->vma;
	  break;

	  /* Negative relocations.  */
	case R_PPC_EMB_NADDR32:
	case R_PPC_EMB_NADDR16:
	case R_PPC_EMB_NADDR16_LO:
	case R_PPC_EMB_NADDR16_HI:
	case R_PPC_EMB_NADDR16_HA:
	  addend -= 2 * relocation;
	  break;

	case R_PPC_COPY:
	case R_PPC_GLOB_DAT:
	case R_PPC_JMP_SLOT:
	case R_PPC_RELATIVE:
	case R_PPC_IRELATIVE:
	case R_PPC_PLT32:
	case R_PPC_PLTREL32:
	case R_PPC_PLT16_LO:
	case R_PPC_PLT16_HI:
	case R_PPC_PLT16_HA:
	case R_PPC_ADDR30:
	case R_PPC_EMB_RELSEC16:
	case R_PPC_EMB_RELST_LO:
	case R_PPC_EMB_RELST_HI:
	case R_PPC_EMB_RELST_HA:
	case R_PPC_EMB_BIT_FLD:
	  info->callbacks->einfo
	    (_("%P: %B: relocation %s is not yet supported for symbol %s\n"),
	     input_bfd,
	     howto->name,
	     sym_name);

	  bfd_set_error (bfd_error_invalid_operation);
	  ret = FALSE;
	  continue;
	}

      /* Do any further special processing.  */
      switch (r_type)
	{
	default:
	  break;

	case R_PPC_ADDR16_HA:
	case R_PPC_REL16_HA:
	case R_PPC_SECTOFF_HA:
	case R_PPC_TPREL16_HA:
	case R_PPC_DTPREL16_HA:
	case R_PPC_EMB_NADDR16_HA:
	case R_PPC_EMB_RELST_HA:
	  /* It's just possible that this symbol is a weak symbol
	     that's not actually defined anywhere.  In that case,
	     'sec' would be NULL, and we should leave the symbol
	     alone (it will be set to zero elsewhere in the link).  */
	  if (sec == NULL)
	    break;
	  /* Fall thru */

	case R_PPC_PLT16_HA:
	case R_PPC_GOT16_HA:
	case R_PPC_GOT_TLSGD16_HA:
	case R_PPC_GOT_TLSLD16_HA:
	case R_PPC_GOT_TPREL16_HA:
	case R_PPC_GOT_DTPREL16_HA:
	  /* Add 0x10000 if sign bit in 0:15 is set.
	     Bits 0:15 are not used.  */
	  addend += 0x8000;
	  break;

	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_SDAREL16:
	case R_PPC_SECTOFF:
	case R_PPC_SECTOFF_LO:
	case R_PPC_DTPREL16:
	case R_PPC_DTPREL16_LO:
	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	  {
	    /* The 32-bit ABI lacks proper relocations to deal with
	       certain 64-bit instructions.  Prevent damage to bits
	       that make up part of the insn opcode.  */
	    unsigned int insn, mask, lobit;

	    insn = bfd_get_32 (output_bfd, contents + rel->r_offset - d_offset);
	    mask = 0;
	    if (is_insn_ds_form (insn))
	      mask = 3;
	    else if (is_insn_dq_form (insn))
	      mask = 15;
	    else
	      break;
	    lobit = mask & (relocation + addend);
	    if (lobit != 0)
	      {
		addend -= lobit;
		info->callbacks->einfo
		  (_("%P: %H: error: %s against `%s' not a multiple of %u\n"),
		   input_bfd, input_section, rel->r_offset,
		   howto->name, sym_name, mask + 1);
		bfd_set_error (bfd_error_bad_value);
		ret = FALSE;
	      }
	    addend += insn & mask;
	  }
	  break;
	}

#ifdef DEBUG
      fprintf (stderr, "\ttype = %s (%d), name = %s, symbol index = %ld, "
	       "offset = %ld, addend = %ld\n",
	       howto->name,
	       (int) r_type,
	       sym_name,
	       r_symndx,
	       (long) rel->r_offset,
	       (long) addend);
#endif

      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic)
	  && _bfd_elf_section_offset (output_bfd, info, input_section,
				      rel->r_offset) != (bfd_vma) -1)
	{
	  info->callbacks->einfo
	    (_("%P: %H: unresolvable %s relocation against symbol `%s'\n"),
	     input_bfd, input_section, rel->r_offset,
	     howto->name,
	     sym_name);
	  ret = FALSE;
	}

      r = _bfd_final_link_relocate (howto,
				    input_bfd,
				    input_section,
				    contents,
				    rel->r_offset,
				    relocation,
				    addend);

      if (r != bfd_reloc_ok)
	{
	  if (r == bfd_reloc_overflow)
	    {
	      if (warned)
		continue;
	      if (h != NULL
		  && h->root.type == bfd_link_hash_undefweak
		  && howto->pc_relative)
		{
		  /* Assume this is a call protected by other code that
		     detect the symbol is undefined.  If this is the case,
		     we can safely ignore the overflow.  If not, the
		     program is hosed anyway, and a little warning isn't
		     going to help.  */

		  continue;
		}

	      if (! (*info->callbacks->reloc_overflow) (info,
							(h ? &h->root : NULL),
							sym_name,
							howto->name,
							rel->r_addend,
							input_bfd,
							input_section,
							rel->r_offset))
		return FALSE;
	    }
	  else
	    {
	      info->callbacks->einfo
		(_("%P: %H: %s reloc against `%s': error %d\n"),
		 input_bfd, input_section, rel->r_offset,
		 howto->name, sym_name, (int) r);
	      ret = FALSE;
	    }
	}
    }

#ifdef DEBUG
  fprintf (stderr, "\n");
#endif

  return ret;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
ppc_elf_finish_dynamic_symbol (bfd *output_bfd,
			       struct bfd_link_info *info,
			       struct elf_link_hash_entry *h,
			       Elf_Internal_Sym *sym)
{
  struct ppc_elf_link_hash_table *htab;
  struct plt_entry *ent;
  bfd_boolean doneone;

#ifdef DEBUG
  fprintf (stderr, "ppc_elf_finish_dynamic_symbol called for %s",
	   h->root.root.string);
#endif

  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL);

  doneone = FALSE;
  for (ent = h->plt.plist; ent != NULL; ent = ent->next)
    if (ent->plt.offset != (bfd_vma) -1)
      {
	if (!doneone)
	  {
	    Elf_Internal_Rela rela;
	    bfd_byte *loc;
	    bfd_vma reloc_index;

	    if (htab->plt_type == PLT_NEW
		|| !htab->elf.dynamic_sections_created
		|| h->dynindx == -1)
	      reloc_index = ent->plt.offset / 4;
	    else
	      {
		reloc_index = ((ent->plt.offset - htab->plt_initial_entry_size)
			       / htab->plt_slot_size);
		if (reloc_index > PLT_NUM_SINGLE_ENTRIES
		    && htab->plt_type == PLT_OLD)
		  reloc_index -= (reloc_index - PLT_NUM_SINGLE_ENTRIES) / 2;
	      }

	    /* This symbol has an entry in the procedure linkage table.
	       Set it up.  */
	    if (htab->plt_type == PLT_VXWORKS
		&& htab->elf.dynamic_sections_created
		&& h->dynindx != -1)
	      {
		bfd_vma got_offset;
		const bfd_vma *plt_entry;

		/* The first three entries in .got.plt are reserved.  */
		got_offset = (reloc_index + 3) * 4;

		/* Use the right PLT. */
		plt_entry = info->shared ? ppc_elf_vxworks_pic_plt_entry
			    : ppc_elf_vxworks_plt_entry;

		/* Fill in the .plt on VxWorks.  */
		if (info->shared)
		  {
		    bfd_put_32 (output_bfd,
				plt_entry[0] | PPC_HA (got_offset),
				htab->plt->contents + ent->plt.offset + 0);
		    bfd_put_32 (output_bfd,
				plt_entry[1] | PPC_LO (got_offset),
				htab->plt->contents + ent->plt.offset + 4);
		  }
		else
		  {
		    bfd_vma got_loc = got_offset + SYM_VAL (htab->elf.hgot);

		    bfd_put_32 (output_bfd,
				plt_entry[0] | PPC_HA (got_loc),
				htab->plt->contents + ent->plt.offset + 0);
		    bfd_put_32 (output_bfd,
				plt_entry[1] | PPC_LO (got_loc),
				htab->plt->contents + ent->plt.offset + 4);
		  }

		bfd_put_32 (output_bfd, plt_entry[2],
			    htab->plt->contents + ent->plt.offset + 8);
		bfd_put_32 (output_bfd, plt_entry[3],
			    htab->plt->contents + ent->plt.offset + 12);

		/* This instruction is an immediate load.  The value loaded is
		   the byte offset of the R_PPC_JMP_SLOT relocation from the
		   start of the .rela.plt section.  The value is stored in the
		   low-order 16 bits of the load instruction.  */
		/* NOTE: It appears that this is now an index rather than a
		   prescaled offset.  */
		bfd_put_32 (output_bfd,
			    plt_entry[4] | reloc_index,
			    htab->plt->contents + ent->plt.offset + 16);
		/* This instruction is a PC-relative branch whose target is
		   the start of the PLT section.  The address of this branch
		   instruction is 20 bytes beyond the start of this PLT entry.
		   The address is encoded in bits 6-29, inclusive.  The value
		   stored is right-shifted by two bits, permitting a 26-bit
		   offset.  */
		bfd_put_32 (output_bfd,
			    (plt_entry[5]
			     | (-(ent->plt.offset + 20) & 0x03fffffc)),
			    htab->plt->contents + ent->plt.offset + 20);
		bfd_put_32 (output_bfd, plt_entry[6],
			    htab->plt->contents + ent->plt.offset + 24);
		bfd_put_32 (output_bfd, plt_entry[7],
			    htab->plt->contents + ent->plt.offset + 28);

		/* Fill in the GOT entry corresponding to this PLT slot with
		   the address immediately after the "bctr" instruction
		   in this PLT entry.  */
		bfd_put_32 (output_bfd, (htab->plt->output_section->vma
					 + htab->plt->output_offset
					 + ent->plt.offset + 16),
			    htab->sgotplt->contents + got_offset);

		if (!info->shared)
		  {
		    /* Fill in a couple of entries in .rela.plt.unloaded.  */
		    loc = htab->srelplt2->contents
		      + ((VXWORKS_PLTRESOLVE_RELOCS + reloc_index
			  * VXWORKS_PLT_NON_JMP_SLOT_RELOCS)
			 * sizeof (Elf32_External_Rela));

		    /* Provide the @@ha relocation for the first instruction.  */
		    rela.r_offset = (htab->plt->output_section->vma
				     + htab->plt->output_offset
				     + ent->plt.offset + 2);
		    rela.r_info = ELF32_R_INFO (htab->elf.hgot->indx,
						R_PPC_ADDR16_HA);
		    rela.r_addend = got_offset;
		    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
		    loc += sizeof (Elf32_External_Rela);

		    /* Provide the @@l relocation for the second instruction.  */
		    rela.r_offset = (htab->plt->output_section->vma
				     + htab->plt->output_offset
				     + ent->plt.offset + 6);
		    rela.r_info = ELF32_R_INFO (htab->elf.hgot->indx,
						R_PPC_ADDR16_LO);
		    rela.r_addend = got_offset;
		    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
		    loc += sizeof (Elf32_External_Rela);

		    /* Provide a relocation for the GOT entry corresponding to this
		       PLT slot.  Point it at the middle of the .plt entry.  */
		    rela.r_offset = (htab->sgotplt->output_section->vma
				     + htab->sgotplt->output_offset
				     + got_offset);
		    rela.r_info = ELF32_R_INFO (htab->elf.hplt->indx,
						R_PPC_ADDR32);
		    rela.r_addend = ent->plt.offset + 16;
		    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
		  }

		/* VxWorks uses non-standard semantics for R_PPC_JMP_SLOT.
		   In particular, the offset for the relocation is not the
		   address of the PLT entry for this function, as specified
		   by the ABI.  Instead, the offset is set to the address of
		   the GOT slot for this function.  See EABI 4.4.4.1.  */
		rela.r_offset = (htab->sgotplt->output_section->vma
				 + htab->sgotplt->output_offset
				 + got_offset);

	      }
	    else
	      {
		asection *splt = htab->plt;
		if (!htab->elf.dynamic_sections_created
		    || h->dynindx == -1)
		  splt = htab->iplt;

		rela.r_offset = (splt->output_section->vma
				 + splt->output_offset
				 + ent->plt.offset);
		if (htab->plt_type == PLT_OLD
		    || !htab->elf.dynamic_sections_created
		    || h->dynindx == -1)
		  {
		    /* We don't need to fill in the .plt.  The ppc dynamic
		       linker will fill it in.  */
		  }
		else
		  {
		    bfd_vma val = (htab->glink_pltresolve + ent->plt.offset
				   + htab->glink->output_section->vma
				   + htab->glink->output_offset);
		    bfd_put_32 (output_bfd, val,
				splt->contents + ent->plt.offset);
		  }
	      }

	    /* Fill in the entry in the .rela.plt section.  */
	    rela.r_addend = 0;
	    if (!htab->elf.dynamic_sections_created
		|| h->dynindx == -1)
	      {
		BFD_ASSERT (h->type == STT_GNU_IFUNC
			    && h->def_regular
			    && (h->root.type == bfd_link_hash_defined
				|| h->root.type == bfd_link_hash_defweak));
		rela.r_info = ELF32_R_INFO (0, R_PPC_IRELATIVE);
		rela.r_addend = SYM_VAL (h);
	      }
	    else
	      rela.r_info = ELF32_R_INFO (h->dynindx, R_PPC_JMP_SLOT);

	    if (!htab->elf.dynamic_sections_created
		|| h->dynindx == -1)
	      loc = (htab->reliplt->contents
		     + (htab->reliplt->reloc_count++
			* sizeof (Elf32_External_Rela)));
	    else
	      loc = (htab->relplt->contents
		     + reloc_index * sizeof (Elf32_External_Rela));
	    bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);

	    if (!h->def_regular)
	      {
		/* Mark the symbol as undefined, rather than as
		   defined in the .plt section.  Leave the value if
		   there were any relocations where pointer equality
		   matters (this is a clue for the dynamic linker, to
		   make function pointer comparisons work between an
		   application and shared library), otherwise set it
		   to zero.  */
		sym->st_shndx = SHN_UNDEF;
		if (!h->pointer_equality_needed)
		  sym->st_value = 0;
		else if (!h->ref_regular_nonweak)
		  {
		    /* This breaks function pointer comparisons, but
		       that is better than breaking tests for a NULL
		       function pointer.  */
		    sym->st_value = 0;
		  }
	      }
	    else if (h->type == STT_GNU_IFUNC
		     && !info->shared)
	      {
		/* Set the value of ifunc symbols in a non-pie
		   executable to the glink entry.  This is to avoid
		   text relocations.  We can't do this for ifunc in
		   allocate_dynrelocs, as we do for normal dynamic
		   function symbols with plt entries, because we need
		   to keep the original value around for the ifunc
		   relocation.  */
		sym->st_shndx = (_bfd_elf_section_from_bfd_section
				 (output_bfd, htab->glink->output_section));
		sym->st_value = (ent->glink_offset
				 + htab->glink->output_offset
				 + htab->glink->output_section->vma);
	      }
	    doneone = TRUE;
	  }

	if (htab->plt_type == PLT_NEW
	    || !htab->elf.dynamic_sections_created
	    || h->dynindx == -1)
	  {
	    unsigned char *p;
	    asection *splt = htab->plt;
	    if (!htab->elf.dynamic_sections_created
		|| h->dynindx == -1)
	      splt = htab->iplt;

	    p = (unsigned char *) htab->glink->contents + ent->glink_offset;

	    if (h == htab->tls_get_addr && !htab->no_tls_get_addr_opt)
	      {
		bfd_put_32 (output_bfd, LWZ_11_3, p);
		p += 4;
		bfd_put_32 (output_bfd, LWZ_12_3 + 4, p);
		p += 4;
		bfd_put_32 (output_bfd, MR_0_3, p);
		p += 4;
		bfd_put_32 (output_bfd, CMPWI_11_0, p);
		p += 4;
		bfd_put_32 (output_bfd, ADD_3_12_2, p);
		p += 4;
		bfd_put_32 (output_bfd, BEQLR, p);
		p += 4;
		bfd_put_32 (output_bfd, MR_3_0, p);
		p += 4;
		bfd_put_32 (output_bfd, NOP, p);
		p += 4;
	      }

	    write_glink_stub (ent, splt, p, info);

	    if (!info->shared)
	      /* We only need one non-PIC glink stub.  */
	      break;
	  }
	else
	  break;
      }

  if (h->needs_copy)
    {
      asection *s;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbols needs a copy reloc.  Set it up.  */

#ifdef DEBUG
      fprintf (stderr, ", copy");
#endif

      BFD_ASSERT (h->dynindx != -1);

      if (ppc_elf_hash_entry (h)->has_sda_refs)
	s = htab->relsbss;
      else
	s = htab->relbss;
      BFD_ASSERT (s != NULL);

      rela.r_offset = SYM_VAL (h);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_PPC_COPY);
      rela.r_addend = 0;
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

#ifdef DEBUG
  fprintf (stderr, "\n");
#endif

  return TRUE;
}

static enum elf_reloc_type_class
ppc_elf_reloc_type_class (const struct bfd_link_info *info,
			  const asection *rel_sec,
			  const Elf_Internal_Rela *rela)
{
  struct ppc_elf_link_hash_table *htab = ppc_elf_hash_table (info);

  if (rel_sec == htab->reliplt)
    return reloc_class_ifunc;

  switch (ELF32_R_TYPE (rela->r_info))
    {
    case R_PPC_RELATIVE:
      return reloc_class_relative;
    case R_PPC_JMP_SLOT:
      return reloc_class_plt;
    case R_PPC_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Finish up the dynamic sections.  */

static bfd_boolean
ppc_elf_finish_dynamic_sections (bfd *output_bfd,
				 struct bfd_link_info *info)
{
  asection *sdyn;
  asection *splt;
  struct ppc_elf_link_hash_table *htab;
  bfd_vma got;
  bfd *dynobj;
  bfd_boolean ret = TRUE;

#ifdef DEBUG
  fprintf (stderr, "ppc_elf_finish_dynamic_sections called\n");
#endif

  htab = ppc_elf_hash_table (info);
  dynobj = elf_hash_table (info)->dynobj;
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");
  if (htab->is_vxworks)
    splt = bfd_get_linker_section (dynobj, ".plt");
  else
    splt = NULL;

  got = 0;
  if (htab->elf.hgot != NULL)
    got = SYM_VAL (htab->elf.hgot);

  if (htab->elf.dynamic_sections_created)
    {
      Elf32_External_Dyn *dyncon, *dynconend;

      BFD_ASSERT (htab->plt != NULL && sdyn != NULL);

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    case DT_PLTGOT:
	      if (htab->is_vxworks)
		s = htab->sgotplt;
	      else
		s = htab->plt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = htab->relplt->size;
	      break;

	    case DT_JMPREL:
	      s = htab->relplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    case DT_PPC_GOT:
	      dyn.d_un.d_ptr = got;
	      break;

	    case DT_RELASZ:
	      if (htab->is_vxworks)
		{
		  if (htab->relplt)
		    dyn.d_un.d_ptr -= htab->relplt->size;
		  break;
		}
	      continue;

	    default:
	      if (htab->is_vxworks
		  && elf_vxworks_finish_dynamic_entry (output_bfd, &dyn))
		break;
	      continue;
	    }

	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	}
    }

  if (htab->got != NULL)
    {
      if (htab->elf.hgot->root.u.def.section == htab->got
	  || htab->elf.hgot->root.u.def.section == htab->sgotplt)
	{
	  unsigned char *p = htab->elf.hgot->root.u.def.section->contents;

	  p += htab->elf.hgot->root.u.def.value;
	  if (htab->plt_type == PLT_OLD)
	    {
	      /* Add a blrl instruction at _GLOBAL_OFFSET_TABLE_-4
		 so that a function can easily find the address of
		 _GLOBAL_OFFSET_TABLE_.  */
	      BFD_ASSERT (htab->elf.hgot->root.u.def.value - 4
			  < htab->elf.hgot->root.u.def.section->size);
	      bfd_put_32 (output_bfd, 0x4e800021, p - 4);
	    }

	  if (sdyn != NULL)
	    {
	      bfd_vma val = sdyn->output_section->vma + sdyn->output_offset;
	      BFD_ASSERT (htab->elf.hgot->root.u.def.value
			  < htab->elf.hgot->root.u.def.section->size);
	      bfd_put_32 (output_bfd, val, p);
	    }
	}
      else
	{
	  info->callbacks->einfo (_("%P: %s not defined in linker created %s\n"),
				  htab->elf.hgot->root.root.string,
				  (htab->sgotplt != NULL
				   ? htab->sgotplt->name : htab->got->name));
	  bfd_set_error (bfd_error_bad_value);
	  ret = FALSE;
	}

      elf_section_data (htab->got->output_section)->this_hdr.sh_entsize = 4;
    }

  /* Fill in the first entry in the VxWorks procedure linkage table.  */
  if (splt && splt->size > 0)
    {
      /* Use the right PLT. */
      const bfd_vma *plt_entry = (info->shared
				  ? ppc_elf_vxworks_pic_plt0_entry
				  : ppc_elf_vxworks_plt0_entry);

      if (!info->shared)
	{
	  bfd_vma got_value = SYM_VAL (htab->elf.hgot);

	  bfd_put_32 (output_bfd, plt_entry[0] | PPC_HA (got_value),
		      splt->contents +  0);
	  bfd_put_32 (output_bfd, plt_entry[1] | PPC_LO (got_value),
		      splt->contents +  4);
	}
      else
	{
	  bfd_put_32 (output_bfd, plt_entry[0], splt->contents +  0);
	  bfd_put_32 (output_bfd, plt_entry[1], splt->contents +  4);
	}
      bfd_put_32 (output_bfd, plt_entry[2], splt->contents +  8);
      bfd_put_32 (output_bfd, plt_entry[3], splt->contents + 12);
      bfd_put_32 (output_bfd, plt_entry[4], splt->contents + 16);
      bfd_put_32 (output_bfd, plt_entry[5], splt->contents + 20);
      bfd_put_32 (output_bfd, plt_entry[6], splt->contents + 24);
      bfd_put_32 (output_bfd, plt_entry[7], splt->contents + 28);

      if (! info->shared)
	{
	  Elf_Internal_Rela rela;
	  bfd_byte *loc;

	  loc = htab->srelplt2->contents;

	  /* Output the @@ha relocation for the first instruction.  */
	  rela.r_offset = (htab->plt->output_section->vma
			   + htab->plt->output_offset
			   + 2);
	  rela.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_PPC_ADDR16_HA);
	  rela.r_addend = 0;
	  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
	  loc += sizeof (Elf32_External_Rela);

	  /* Output the @@l relocation for the second instruction.  */
	  rela.r_offset = (htab->plt->output_section->vma
			   + htab->plt->output_offset
			   + 6);
	  rela.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_PPC_ADDR16_LO);
	  rela.r_addend = 0;
	  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
	  loc += sizeof (Elf32_External_Rela);

	  /* Fix up the remaining relocations.  They may have the wrong
	     symbol index for _G_O_T_ or _P_L_T_ depending on the order
	     in which symbols were output.  */
	  while (loc < htab->srelplt2->contents + htab->srelplt2->size)
	    {
	      Elf_Internal_Rela rel;

	      bfd_elf32_swap_reloc_in (output_bfd, loc, &rel);
	      rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_PPC_ADDR16_HA);
	      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
	      loc += sizeof (Elf32_External_Rela);

	      bfd_elf32_swap_reloc_in (output_bfd, loc, &rel);
	      rel.r_info = ELF32_R_INFO (htab->elf.hgot->indx, R_PPC_ADDR16_LO);
	      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
	      loc += sizeof (Elf32_External_Rela);

	      bfd_elf32_swap_reloc_in (output_bfd, loc, &rel);
	      rel.r_info = ELF32_R_INFO (htab->elf.hplt->indx, R_PPC_ADDR32);
	      bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
	      loc += sizeof (Elf32_External_Rela);
	    }
	}
    }

  if (htab->glink != NULL
      && htab->glink->contents != NULL
      && htab->elf.dynamic_sections_created)
    {
      unsigned char *p;
      unsigned char *endp;
      bfd_vma res0;
      unsigned int i;

      /*
       * PIC glink code is the following:
       *
       * # ith PLT code stub.
       *   addis 11,30,(plt+(i-1)*4-got)@@ha
       *   lwz 11,(plt+(i-1)*4-got)@@l(11)
       *   mtctr 11
       *   bctr
       *
       * # A table of branches, one for each plt entry.
       * # The idea is that the plt call stub loads ctr and r11 with these
       * # addresses, so (r11 - res_0) gives the plt index * 4.
       * res_0:	b PLTresolve
       * res_1:	b PLTresolve
       * .
       * # Some number of entries towards the end can be nops
       * res_n_m3: nop
       * res_n_m2: nop
       * res_n_m1:
       *
       * PLTresolve:
       *    addis 11,11,(1f-res_0)@@ha
       *    mflr 0
       *    bcl 20,31,1f
       * 1: addi 11,11,(1b-res_0)@@l
       *    mflr 12
       *    mtlr 0
       *    sub 11,11,12                # r11 = index * 4
       *    addis 12,12,(got+4-1b)@@ha
       *    lwz 0,(got+4-1b)@@l(12)      # got[1] address of dl_runtime_resolve
       *    lwz 12,(got+8-1b)@@l(12)     # got[2] contains the map address
       *    mtctr 0
       *    add 0,11,11
       *    add 11,0,11                 # r11 = index * 12 = reloc offset.
       *    bctr
       */
      static const unsigned int pic_plt_resolve[] =
	{
	  ADDIS_11_11,
	  MFLR_0,
	  BCL_20_31,
	  ADDI_11_11,
	  MFLR_12,
	  MTLR_0,
	  SUB_11_11_12,
	  ADDIS_12_12,
	  LWZ_0_12,
	  LWZ_12_12,
	  MTCTR_0,
	  ADD_0_11_11,
	  ADD_11_0_11,
	  BCTR,
	  NOP,
	  NOP
	};

      /*
       * Non-PIC glink code is a little simpler.
       *
       * # ith PLT code stub.
       *   lis 11,(plt+(i-1)*4)@@ha
       *   lwz 11,(plt+(i-1)*4)@@l(11)
       *   mtctr 11
       *   bctr
       *
       * The branch table is the same, then comes
       *
       * PLTresolve:
       *    lis 12,(got+4)@@ha
       *    addis 11,11,(-res_0)@@ha
       *    lwz 0,(got+4)@@l(12)         # got[1] address of dl_runtime_resolve
       *    addi 11,11,(-res_0)@@l       # r11 = index * 4
       *    mtctr 0
       *    add 0,11,11
       *    lwz 12,(got+8)@@l(12)        # got[2] contains the map address
       *    add 11,0,11                 # r11 = index * 12 = reloc offset.
       *    bctr
       */
      static const unsigned int plt_resolve[] =
	{
	  LIS_12,
	  ADDIS_11_11,
	  LWZ_0_12,
	  ADDI_11_11,
	  MTCTR_0,
	  ADD_0_11_11,
	  LWZ_12_12,
	  ADD_11_0_11,
	  BCTR,
	  NOP,
	  NOP,
	  NOP,
	  NOP,
	  NOP,
	  NOP,
	  NOP
	};

      if (ARRAY_SIZE (pic_plt_resolve) != GLINK_PLTRESOLVE / 4)
	abort ();
      if (ARRAY_SIZE (plt_resolve) != GLINK_PLTRESOLVE / 4)
	abort ();

      /* Build the branch table, one for each plt entry (less one),
	 and perhaps some padding.  */
      p = htab->glink->contents;
      p += htab->glink_pltresolve;
      endp = htab->glink->contents;
      endp += htab->glink->size - GLINK_PLTRESOLVE;
      while (p < endp - 8 * 4)
	{
	  bfd_put_32 (output_bfd, B + endp - p, p);
	  p += 4;
	}
      while (p < endp)
	{
	  bfd_put_32 (output_bfd, NOP, p);
	  p += 4;
	}

      res0 = (htab->glink_pltresolve
	      + htab->glink->output_section->vma
	      + htab->glink->output_offset);

      /* Last comes the PLTresolve stub.  */
      if (info->shared)
	{
	  bfd_vma bcl;

	  for (i = 0; i < ARRAY_SIZE (pic_plt_resolve); i++)
	    {
	      bfd_put_32 (output_bfd, pic_plt_resolve[i], p);
	      p += 4;
	    }
	  p -= 4 * ARRAY_SIZE (pic_plt_resolve);

	  bcl = (htab->glink->size - GLINK_PLTRESOLVE + 3*4
		 + htab->glink->output_section->vma
		 + htab->glink->output_offset);

	  bfd_put_32 (output_bfd,
		      ADDIS_11_11 + PPC_HA (bcl - res0), p + 0*4);
	  bfd_put_32 (output_bfd,
		      ADDI_11_11 + PPC_LO (bcl - res0), p + 3*4);
	  bfd_put_32 (output_bfd,
		      ADDIS_12_12 + PPC_HA (got + 4 - bcl), p + 7*4);
	  if (PPC_HA (got + 4 - bcl) == PPC_HA (got + 8 - bcl))
	    {
	      bfd_put_32 (output_bfd,
			  LWZ_0_12 + PPC_LO (got + 4 - bcl), p + 8*4);
	      bfd_put_32 (output_bfd,
			  LWZ_12_12 + PPC_LO (got + 8 - bcl), p + 9*4);
	    }
	  else
	    {
	      bfd_put_32 (output_bfd,
			  LWZU_0_12 + PPC_LO (got + 4 - bcl), p + 8*4);
	      bfd_put_32 (output_bfd,
			  LWZ_12_12 + 4, p + 9*4);
	    }
	}
      else
	{
	  for (i = 0; i < ARRAY_SIZE (plt_resolve); i++)
	    {
	      bfd_put_32 (output_bfd, plt_resolve[i], p);
	      p += 4;
	    }
	  p -= 4 * ARRAY_SIZE (plt_resolve);

	  bfd_put_32 (output_bfd,
		      LIS_12 + PPC_HA (got + 4), p + 0*4);
	  bfd_put_32 (output_bfd,
		      ADDIS_11_11 + PPC_HA (-res0), p + 1*4);
	  bfd_put_32 (output_bfd,
		      ADDI_11_11 + PPC_LO (-res0), p + 3*4);
	  if (PPC_HA (got + 4) == PPC_HA (got + 8))
	    {
	      bfd_put_32 (output_bfd,
			  LWZ_0_12 + PPC_LO (got + 4), p + 2*4);
	      bfd_put_32 (output_bfd,
			  LWZ_12_12 + PPC_LO (got + 8), p + 6*4);
	    }
	  else
	    {
	      bfd_put_32 (output_bfd,
			  LWZU_0_12 + PPC_LO (got + 4), p + 2*4);
	      bfd_put_32 (output_bfd,
			  LWZ_12_12 + 4, p + 6*4);
	    }
	}
    }

  if (htab->glink_eh_frame != NULL
      && htab->glink_eh_frame->contents != NULL)
    {
      unsigned char *p = htab->glink_eh_frame->contents;
      bfd_vma val;

      p += sizeof (glink_eh_frame_cie);
      /* FDE length.  */
      p += 4;
      /* CIE pointer.  */
      p += 4;
      /* Offset to .glink.  */
      val = (htab->glink->output_section->vma
	     + htab->glink->output_offset);
      val -= (htab->glink_eh_frame->output_section->vma
	      + htab->glink_eh_frame->output_offset);
      val -= p - htab->glink_eh_frame->contents;
      bfd_put_32 (htab->elf.dynobj, val, p);

      if (htab->glink_eh_frame->sec_info_type == SEC_INFO_TYPE_EH_FRAME
	  && !_bfd_elf_write_section_eh_frame (output_bfd, info,
					       htab->glink_eh_frame,
					       htab->glink_eh_frame->contents))
	return FALSE;
    }

  return ret;
}

#define TARGET_LITTLE_SYM	bfd_elf32_powerpcle_vec
#define TARGET_LITTLE_NAME	"elf32-powerpcle"
#define TARGET_BIG_SYM		bfd_elf32_powerpc_vec
#define TARGET_BIG_NAME		"elf32-powerpc"
#define ELF_ARCH		bfd_arch_powerpc
#define ELF_TARGET_ID		PPC32_ELF_DATA
#define ELF_MACHINE_CODE	EM_PPC
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE		0x1000
#else
#define ELF_MAXPAGESIZE		0x10000
#endif
#define ELF_MINPAGESIZE		0x1000
#define ELF_COMMONPAGESIZE	0x1000
#define elf_info_to_howto	ppc_elf_info_to_howto

#ifdef  EM_CYGNUS_POWERPC
#define ELF_MACHINE_ALT1	EM_CYGNUS_POWERPC
#endif

#ifdef EM_PPC_OLD
#define ELF_MACHINE_ALT2	EM_PPC_OLD
#endif

#define elf_backend_plt_not_loaded	1
#define elf_backend_can_gc_sections	1
#define elf_backend_can_refcount	1
#define elf_backend_rela_normal		1

#define bfd_elf32_mkobject			ppc_elf_mkobject
#define bfd_elf32_bfd_merge_private_bfd_data	ppc_elf_merge_private_bfd_data
#define bfd_elf32_bfd_relax_section		ppc_elf_relax_section
#define bfd_elf32_bfd_reloc_type_lookup		ppc_elf_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup		ppc_elf_reloc_name_lookup
#define bfd_elf32_bfd_set_private_flags		ppc_elf_set_private_flags
#define bfd_elf32_bfd_link_hash_table_create	ppc_elf_link_hash_table_create
#define bfd_elf32_get_synthetic_symtab		ppc_elf_get_synthetic_symtab

#define elf_backend_object_p			ppc_elf_object_p
#define elf_backend_gc_mark_hook		ppc_elf_gc_mark_hook
#define elf_backend_gc_sweep_hook		ppc_elf_gc_sweep_hook
#define elf_backend_section_from_shdr		ppc_elf_section_from_shdr
#define elf_backend_relocate_section		ppc_elf_relocate_section
#define elf_backend_create_dynamic_sections	ppc_elf_create_dynamic_sections
#define elf_backend_check_relocs		ppc_elf_check_relocs
#define elf_backend_copy_indirect_symbol	ppc_elf_copy_indirect_symbol
#define elf_backend_adjust_dynamic_symbol	ppc_elf_adjust_dynamic_symbol
#define elf_backend_add_symbol_hook		ppc_elf_add_symbol_hook
#define elf_backend_size_dynamic_sections	ppc_elf_size_dynamic_sections
#define elf_backend_hash_symbol			ppc_elf_hash_symbol
#define elf_backend_finish_dynamic_symbol	ppc_elf_finish_dynamic_symbol
#define elf_backend_finish_dynamic_sections	ppc_elf_finish_dynamic_sections
#define elf_backend_fake_sections		ppc_elf_fake_sections
#define elf_backend_additional_program_headers	ppc_elf_additional_program_headers
#define elf_backend_modify_segment_map     	ppc_elf_modify_segment_map
#define elf_backend_grok_prstatus		ppc_elf_grok_prstatus
#define elf_backend_grok_psinfo			ppc_elf_grok_psinfo
#define elf_backend_write_core_note		ppc_elf_write_core_note
#define elf_backend_reloc_type_class		ppc_elf_reloc_type_class
#define elf_backend_begin_write_processing	ppc_elf_begin_write_processing
#define elf_backend_final_write_processing	ppc_elf_final_write_processing
#define elf_backend_write_section		ppc_elf_write_section
#define elf_backend_get_sec_type_attr		ppc_elf_get_sec_type_attr
#define elf_backend_plt_sym_val			ppc_elf_plt_sym_val
#define elf_backend_action_discarded		ppc_elf_action_discarded
#define elf_backend_init_index_section		_bfd_elf_init_1_index_section
#define elf_backend_post_process_headers	_bfd_elf_set_osabi
#define elf_backend_lookup_section_flags_hook	ppc_elf_lookup_section_flags
#define elf_backend_section_processing		ppc_elf_section_processing

#include "elf32-target.h"

/* FreeBSD Target */

#undef  TARGET_LITTLE_SYM
#undef  TARGET_LITTLE_NAME

#undef  TARGET_BIG_SYM
#define TARGET_BIG_SYM  bfd_elf32_powerpc_freebsd_vec
#undef  TARGET_BIG_NAME
#define TARGET_BIG_NAME "elf32-powerpc-freebsd"

#undef  ELF_OSABI
#define ELF_OSABI	ELFOSABI_FREEBSD

#undef  elf32_bed
#define elf32_bed	elf32_powerpc_fbsd_bed

#include "elf32-target.h"

/* VxWorks Target */

#undef TARGET_LITTLE_SYM
#undef TARGET_LITTLE_NAME

#undef TARGET_BIG_SYM
#define TARGET_BIG_SYM		bfd_elf32_powerpc_vxworks_vec
#undef TARGET_BIG_NAME
#define TARGET_BIG_NAME		"elf32-powerpc-vxworks"

#undef  ELF_OSABI

/* VxWorks uses the elf default section flags for .plt.  */
static const struct bfd_elf_special_section *
ppc_elf_vxworks_get_sec_type_attr (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  if (sec->name == NULL)
    return NULL;

  if (strcmp (sec->name, ".plt") == 0)
    return _bfd_elf_get_sec_type_attr (abfd, sec);

  return ppc_elf_get_sec_type_attr (abfd, sec);
}

/* Like ppc_elf_link_hash_table_create, but overrides
   appropriately for VxWorks.  */
static struct bfd_link_hash_table *
ppc_elf_vxworks_link_hash_table_create (bfd *abfd)
{
  struct bfd_link_hash_table *ret;

  ret = ppc_elf_link_hash_table_create (abfd);
  if (ret)
    {
      struct ppc_elf_link_hash_table *htab
        = (struct ppc_elf_link_hash_table *)ret;
      htab->is_vxworks = 1;
      htab->plt_type = PLT_VXWORKS;
      htab->plt_entry_size = VXWORKS_PLT_ENTRY_SIZE;
      htab->plt_slot_size = VXWORKS_PLT_ENTRY_SIZE;
      htab->plt_initial_entry_size = VXWORKS_PLT_INITIAL_ENTRY_SIZE;
    }
  return ret;
}

/* Tweak magic VxWorks symbols as they are loaded.  */
static bfd_boolean
ppc_elf_vxworks_add_symbol_hook (bfd *abfd,
				 struct bfd_link_info *info,
				 Elf_Internal_Sym *sym,
				 const char **namep ATTRIBUTE_UNUSED,
				 flagword *flagsp ATTRIBUTE_UNUSED,
				 asection **secp,
				 bfd_vma *valp)
{
  if (!elf_vxworks_add_symbol_hook(abfd, info, sym,namep, flagsp, secp,
				   valp))
    return FALSE;

  return ppc_elf_add_symbol_hook(abfd, info, sym,namep, flagsp, secp, valp);
}

static void
ppc_elf_vxworks_final_write_processing (bfd *abfd, bfd_boolean linker)
{
  ppc_elf_final_write_processing(abfd, linker);
  elf_vxworks_final_write_processing(abfd, linker);
}

/* On VxWorks, we emit relocations against _PROCEDURE_LINKAGE_TABLE_, so
   define it.  */
#undef elf_backend_want_plt_sym
#define elf_backend_want_plt_sym		1
#undef elf_backend_want_got_plt
#define elf_backend_want_got_plt		1
#undef elf_backend_got_symbol_offset
#define elf_backend_got_symbol_offset		0
#undef elf_backend_plt_not_loaded
#define elf_backend_plt_not_loaded		0
#undef elf_backend_plt_readonly
#define elf_backend_plt_readonly		1
#undef elf_backend_got_header_size
#define elf_backend_got_header_size		12

#undef bfd_elf32_get_synthetic_symtab

#undef bfd_elf32_bfd_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_create \
  ppc_elf_vxworks_link_hash_table_create
#undef elf_backend_add_symbol_hook
#define elf_backend_add_symbol_hook \
  ppc_elf_vxworks_add_symbol_hook
#undef elf_backend_link_output_symbol_hook
#define elf_backend_link_output_symbol_hook \
  elf_vxworks_link_output_symbol_hook
#undef elf_backend_final_write_processing
#define elf_backend_final_write_processing \
  ppc_elf_vxworks_final_write_processing
#undef elf_backend_get_sec_type_attr
#define elf_backend_get_sec_type_attr \
  ppc_elf_vxworks_get_sec_type_attr
#undef elf_backend_emit_relocs
#define elf_backend_emit_relocs \
  elf_vxworks_emit_relocs

#undef elf32_bed
#define elf32_bed				ppc_elf_vxworks_bed
#undef elf_backend_post_process_headers

#include "elf32-target.h"
@


1.331
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d4427 1
a4427 1
		       && (! info->symbolic
@


1.330
log
@	* elf32-ppc.c (struct ppc_dyn_relocs): New.
	(ppc_elf_check_relocs): Separate dynrel counts for local syms
	into ifunc and non-ifunc.
	(allocate_dynrelocs): Always put ifunc relocs into reliplt.
	(ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
@
text
@d3914 4
@


1.329
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d3086 15
a4431 3
	      struct elf_dyn_relocs *p;
	      struct elf_dyn_relocs **rel_head;

d4455 3
d4459 15
d4480 3
d4497 17
a4513 1
		  rel_head = (struct elf_dyn_relocs **) vpp;
a4514 17

	      p = *rel_head;
	      if (p == NULL || p->sec != sec)
		{
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		  if (p == NULL)
		    return FALSE;
		  p->next = *rel_head;
		  *rel_head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      if (!must_be_dyn_reloc (info, r_type))
		p->pc_count += 1;
d6058 1
a6058 1
      if (!htab->elf.dynamic_sections_created)
d6151 1
a6151 1
	  struct elf_dyn_relocs *p;
d6153 1
a6153 1
	  for (p = ((struct elf_dyn_relocs *)
d6176 1
a6176 1
		  if (!htab->elf.dynamic_sections_created)
d7425 1
a7425 1
  asection *got2, *sreloc = NULL;
d8279 2
a8280 1
	      bfd_byte * loc;
d8291 3
d8295 1
a8295 7
		{
		  sreloc = elf_section_data (input_section)->sreloc;
		  if (!htab->elf.dynamic_sections_created)
		    sreloc = htab->reliplt;
		  if (sreloc == NULL)
		    return FALSE;
		}
@


1.328
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Set PLT_IFUNC in local got
	masks for all local ifunc syms.
	(allocate_dynrelocs): Don't use htab->relgot for ifunc.
	(ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
@
text
@d9365 3
a9367 1
ppc_elf_reloc_type_class (const Elf_Internal_Rela *rela)
d9369 5
a9377 2
    case R_PPC_REL24:
    case R_PPC_ADDR24:
@


1.327
log
@	* elf32-ppc.c (ppc_elf_relocate_section <R_PPC_PLTREL24>): Adjust
	non-zero addends when relocatable, rather than addends >= 32768.
	Always zero "addend" before applying relocation.
@
text
@d3924 1
a3924 3
	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC
	      && (!info->shared
		  || is_branch_reloc (r_type)))
a3926 1
	      bfd_vma addend;
d3928 1
d3937 2
a3938 2
	      addend = 0;
	      if (r_type == R_PPC_PLTREL24)
d3940 9
a3948 3
		  ppc_elf_tdata (abfd)->makes_plt_call = 1;
		  if (info->shared)
		    addend = rel->r_addend;
a3949 2
	      if (!update_plt_info (abfd, ifunc, got2, addend))
		return FALSE;
d5906 3
d6189 6
a6194 2
		  htab->relgot->size += (need
					 * (sizeof (Elf32_External_Rela) / 4));
d7999 2
@


1.326
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d7475 1
a7475 1
	      && rel->r_addend >= 32768)
d8480 26
a8505 16
	  if (h == NULL || ifunc != NULL)
	    break;
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */
	  {
	    struct plt_entry *ent = find_plt_ent (&h->plt.plist, got2,
						  info->shared ? addend : 0);
	    addend = 0;
	    if (ent == NULL
		|| htab->plt == NULL)
	      {
		/* We didn't make a PLT entry for this symbol.  This
		   happens when statically linking PIC code, or when
		   using -Bsymbolic.  */
		break;
	      }
d8507 4
a8510 10
	    unresolved_reloc = FALSE;
	    if (htab->plt_type == PLT_NEW)
	      relocation = (htab->glink->output_section->vma
			    + htab->glink->output_offset
			    + ent->glink_offset);
	    else
	      relocation = (htab->plt->output_section->vma
			    + htab->plt->output_offset
			    + ent->plt.offset);
	  }
@


1.325
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Rename segment_map to seg_map.
	Delete num_locals and num_globals.
	(elf_num_locals, elf_num_globals): Don't define.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_strtab_sec, elf_shstrtab_sec): Define.
	* bfd.c, * elf-eh-frame.c, * elf-nacl.c, * elf-vxworks.c, * elf.c,
	* elf32-arm.c, * elf32-lm32.c, * elf32-ppc.c, * elf32-rx.c,
	* elf32-spu.c, * elf64-hppa.c, * elfcode.h, * elflink.c,
	* elfnn-ia64.c, * elfxx-mips.c: Use newly defined elf_obj_tdata
	accessor macros.
	* elf.c (elf_map_symbols): Add pnum_locals param.  Return
	number of locals syms via new param.
	(swap_out_syms): Adjust to suit elf_map_symbols change.
ld/
	* emultempl/elf-generic.em: Use newly defined elf_obj_tdata
	accessor macros.
@
text
@d2219 1
a2219 1
      elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d2222 1
a2222 1
      elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 24);
d2245 1
a2245 1
      elf_tdata (abfd)->core_pid
d2247 1
a2247 1
      elf_tdata (abfd)->core_program
d2249 1
a2249 1
      elf_tdata (abfd)->core_command
d2258 1
a2258 1
    char *command = elf_tdata (abfd)->core_command;
@


1.324
log
@2013-02-04  Sergio Durigan Junior  <sergiodj@@redhat.com>
	    Pedro Alves  <palves@@redhat.com>

	* Makefile.in (SOURCE_HFILES): Add `elf-linux-psinfo.h'.
	* elf-bfd.h (elf_internal_linux_prpsinfo): New structure
	declaration.
	(elfcore_write_linux_prpsinfo32, elfcore_write_linux_prpsinfo64)
	(elfcore_write_ppc32_linux_prpsinfo32): New declarations.
	* elf-linux-psinfo.h: New file.
	* elf.c: Include elf-linux-psinfo.h.
	(elfcore_write_linux_prpsinfo32, elfcore_write_linux_prpsinfo64):
	New functions.
	* elf32-ppc.c: Include `elf-linux-psinfo.h'.
	(elf_external_ppc_linux_prpsinfo32): New structure declaration.
	(PPC_LINUX_PRPSINFO32_SWAP_FIELDS): New macro.
	(elfcore_write_ppc_linux_prpsinfo32): New function.
@
text
@d2439 1
a2439 1
  for (m = elf_tdata (abfd)->segment_map; m != NULL; m = m->next)
@


1.323
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d40 1
d1781 52
d2268 13
@


1.322
log
@	* elf32-ppc.c (ppc_elf_howto_raw): Correct dst_mask in
	R_PPC_VLE_LO16A, R_PPC_VLE_HI16A, R_PPC_VLE_HA16A,
	R_PPC_VLE_SDAREL_LO16A, R_PPC_VLE_SDAREL_HI16A,
	R_PPC_VLE_SDAREL_HA16A reloc howtos.
@
text
@d1418 1
a1418 1
	 
d1434 1
a1434 1
  /* A relative 24 bit branch.  */ 
d2262 1
a2262 1
ppc_elf_lookup_section_flags (char *flag_name) 
d2356 1
a2356 1
/* Modify the segment map for VLE executables.  */ 
d3416 1
a3416 1
     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
@


1.321
log
@	PR target/14758
bfd/
	* elf32-ppc.c (ppc_elf_reloc_type_lookup): Decode ppc64 _DS
	bfd_reloc values.  Map to corresponding D-form relocs.
	(is_insn_ds_form, is_insn_qs_form): New functions.
	(ppc_elf_relocate_section): Validate insn with DS-form or DQ-form
	fields using D-form reloc.
gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Fix comment.
	(md_assemble): Translate to _DS relocs for ppc32 as well as ppc64.
	(tc_gen_reloc): Handle _DS relocs in ppc32 mode.
@
text
@d1454 1
a1454 1
	 FALSE,			/* pc_relative */  /* FIXME: Does this apply to split relocs? */
d1461 1
a1461 1
	 0x1f00fff,		/* dst_mask */
d1491 1
a1491 1
	 0x1f00fff,		/* dst_mask */
d1521 1
a1521 1
	 0x1f00fff,		/* dst_mask */
d1581 1
a1581 1
	 0x1f00fff,		/* dst_mask */
d1612 1
a1612 1
	 0x1f00fff,		/* dst_mask */
d1642 1
a1642 1
	 0x1f00fff,		/* dst_mask */
@


1.320
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Assert that dynindx is
	not minus one.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
@
text
@d1818 1
d1820 1
d1831 1
d1833 1
d1844 1
d1849 1
d1851 1
d1856 1
d1862 1
d1864 1
d1869 1
d1871 1
d7258 15
d8818 48
@


1.319
log
@typo fixes
@
text
@d7829 1
d8180 1
@


1.318
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d8983 1
a8983 1
		   the address immediately after the the "bctr" instruction
@


1.318.4.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@a7828 1
		    BFD_ASSERT (h->dynindx != -1);
a8178 1
		  BFD_ASSERT (h->dynindx != -1);
@


1.318.4.2
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d1454 1
a1454 1
	 FALSE,			/* pc_relative */
d1461 1
a1461 1
	 0x1f007ff,		/* dst_mask */
d1491 1
a1491 1
	 0x1f007ff,		/* dst_mask */
d1521 1
a1521 1
	 0x1f007ff,		/* dst_mask */
d1581 1
a1581 1
	 0x1f007ff,		/* dst_mask */
d1612 1
a1612 1
	 0x1f007ff,		/* dst_mask */
d1642 1
a1642 1
	 0x1f007ff,		/* dst_mask */
a1817 1
    case BFD_RELOC_PPC64_ADDR16_DS:
a1818 1
    case BFD_RELOC_PPC64_ADDR16_LO_DS:
a1828 1
    case BFD_RELOC_PPC64_GOT16_DS:
a1829 1
    case BFD_RELOC_PPC64_GOT16_LO_DS:
a1839 1
    case BFD_RELOC_PPC64_PLT16_LO_DS:
a1843 1
    case BFD_RELOC_PPC64_SECTOFF_DS:
a1844 1
    case BFD_RELOC_PPC64_SECTOFF_LO_DS:
a1848 1
    case BFD_RELOC_PPC64_TOC16_DS:
a1853 1
    case BFD_RELOC_PPC64_TPREL16_DS:
a1854 1
    case BFD_RELOC_PPC64_TPREL16_LO_DS:
a1858 1
    case BFD_RELOC_PPC64_DTPREL16_DS:
a1859 1
    case BFD_RELOC_PPC64_DTPREL16_LO_DS:
a7245 15
static bfd_boolean
is_insn_ds_form (unsigned int insn)
{
  return ((insn & (0x3f << 26)) == 58u << 26 /* ld,ldu,lwa */
	  || (insn & (0x3f << 26)) == 62u << 26 /* std,stdu,stq */
	  || (insn & (0x3f << 26)) == 57u << 26 /* lfdp */
	  || (insn & (0x3f << 26)) == 61u << 26 /* stfdp */);
}

static bfd_boolean
is_insn_dq_form (unsigned int insn)
{
  return (insn & (0x3f << 26)) == 56u << 26; /* lq */
}

a8790 48

	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_SDAREL16:
	case R_PPC_SECTOFF:
	case R_PPC_SECTOFF_LO:
	case R_PPC_DTPREL16:
	case R_PPC_DTPREL16_LO:
	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	  {
	    /* The 32-bit ABI lacks proper relocations to deal with
	       certain 64-bit instructions.  Prevent damage to bits
	       that make up part of the insn opcode.  */
	    unsigned int insn, mask, lobit;

	    insn = bfd_get_32 (output_bfd, contents + rel->r_offset - d_offset);
	    mask = 0;
	    if (is_insn_ds_form (insn))
	      mask = 3;
	    else if (is_insn_dq_form (insn))
	      mask = 15;
	    else
	      break;
	    lobit = mask & (relocation + addend);
	    if (lobit != 0)
	      {
		addend -= lobit;
		info->callbacks->einfo
		  (_("%P: %H: error: %s against `%s' not a multiple of %u\n"),
		   input_bfd, input_section, rel->r_offset,
		   howto->name, sym_name, mask + 1);
		bfd_set_error (bfd_error_bad_value);
		ret = FALSE;
	      }
	    addend += insn & mask;
	  }
	  break;
@


1.318.4.3
log
@	* elf32-ppc.c (ppc_elf_relocate_section <R_PPC_PLTREL24>): Adjust
	non-zero addends when relocatable, rather than addends >= 32768.
	Always zero "addend" before applying relocation.
@
text
@d7409 1
a7409 1
	      && rel->r_addend != 0)
d8414 16
a8429 26
	  if (h != NULL && ifunc == NULL)
	    {
	      struct plt_entry *ent = find_plt_ent (&h->plt.plist, got2,
						    info->shared ? addend : 0);
	      if (ent == NULL
		  || htab->plt == NULL)
		{
		  /* We didn't make a PLT entry for this symbol.  This
		     happens when statically linking PIC code, or when
		     using -Bsymbolic.  */
		}
	      else
		{
		  /* Relocation is to the entry for this symbol in the
		     procedure linkage table.  */
		  unresolved_reloc = FALSE;
		  if (htab->plt_type == PLT_NEW)
		    relocation = (htab->glink->output_section->vma
				  + htab->glink->output_offset
				  + ent->glink_offset);
		  else
		    relocation = (htab->plt->output_section->vma
				  + htab->plt->output_offset
				  + ent->plt.offset);
		}
	    }
d8431 10
a8440 4
	  /* R_PPC_PLTREL24 is rather special.  If non-zero, the
	     addend specifies the GOT pointer offset within .got2.
	     Don't apply it to the relocation field.  */
	  addend = 0;
d9060 1
a9060 1
		   the address immediately after the "bctr" instruction
@


1.317
log
@	PR ld/13909
	* elf-eh-frame.c (_bfd_elf_eh_frame_present): New function.
	(_bfd_elf_maybe_strip_eh_frame_hdr): Use it here.
	* elf-bfd.h (_bfd_elf_eh_frame_present): Declare.
	* elflink.c (bfd_elf_size_dynamic_sections): Let the backend
	size dynamic sections before stripping eh_frame_hdr.
	(bfd_elf_gc_sections): Handle multiple .eh_frame sections.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Drop glink_eh_frame
	if no other .eh_frame sections exist.
	* elf64-ppc.c (ppc64_elf_size_stubs): Likewise.
	* elf32-i386.c (elf_i386_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_i386_size_dynamic_sections): ..do it here instead.  Don't
	specially keep sgotplt, iplt, tgotplt, sdynbss for symbols.
	(elf_i386_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_x86_64_size_dynamic_sections): ..do it here instead.
	(elf_x86_64_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
@
text
@d3212 1
a3212 1
  htab->got = s = bfd_get_section_by_name (abfd, ".got");
d3218 1
a3218 1
      htab->sgotplt = bfd_get_section_by_name (abfd, ".got.plt");
d3232 1
a3232 1
  htab->relgot = bfd_get_section_by_name (abfd, ".rela.got");
d3306 1
a3306 1
  htab->dynbss = bfd_get_section_by_name (abfd, ".dynbss");
d3315 1
a3315 1
      htab->relbss = bfd_get_section_by_name (abfd, ".rela.bss");
d3329 2
a3330 2
  htab->relplt = bfd_get_section_by_name (abfd, ".rela.plt");
  htab->plt = s = bfd_get_section_by_name (abfd, ".plt");
d6007 1
a6007 1
	  s = bfd_get_section_by_name (htab->elf.dynobj, ".interp");
d9243 1
a9243 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d9245 1
a9245 1
    splt = bfd_get_section_by_name (dynobj, ".plt");
@


1.316
log
@	* elflink.c (bfd_elf_discard_info): Look for next .eh_frame if
	first one is zero size or discarded.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Set most of
	glink_eh_frame contents here..
	(ppc_elf_finish_dynamic_sections): ..rather than here.  Just set
	offset to .glink.
@
text
@d6247 2
a6248 1
      && !bfd_is_abs_section (htab->glink_eh_frame->output_section))
@


1.315
log
@bfd/
	* elf32-ppc.h (has_vle_insns, is_ppc_vle): Delete.
	(has_tls_reloc, has_tls_get_addr_call): Move back to..
	* elf32-ppc.c: ..here.
	(ppc_elf_section_flags, elf_backend_section_flags): Delete.
	(ppc_elf_modify_segment_map): Use ELF sh_flags to detect VLE sections.
opcodes/
	* ppc-dis.c: Don't include elf32-ppc.h, do include elf/ppc.h.
	(get_powerpc_dialect): Detect VLE sections from ELF sh_flags.
ld/testsuite/
	* ld-powerpc/vle.ld: New.
	* ld-powerpc/powerpc.exp (vle reloc tests): Link using vle.ld.
@
text
@d6396 60
a9635 3
      memcpy (p, glink_eh_frame_cie, sizeof (glink_eh_frame_cie));
      /* CIE length (rewrite in case little-endian).  */
      bfd_put_32 (htab->elf.dynobj, sizeof (glink_eh_frame_cie) - 4, p);
a9637 2
      val = htab->glink_eh_frame->size - 4 - sizeof (glink_eh_frame_cie);
      bfd_put_32 (htab->elf.dynobj, val, p);
a9639 2
      val = p - htab->glink_eh_frame->contents;
      bfd_put_32 (htab->elf.dynobj, val, p);
a9647 39
      p += 4;
      /* .glink size.  */
      bfd_put_32 (htab->elf.dynobj, htab->glink->size, p);
      p += 4;
      /* Augmentation.  */
      p += 1;

      if (info->shared
	  && htab->elf.dynamic_sections_created)
	{
	  bfd_vma adv = (htab->glink->size - GLINK_PLTRESOLVE + 8) >> 2;
	  if (adv < 64)
	    *p++ = DW_CFA_advance_loc + adv;
	  else if (adv < 256)
	    {
	      *p++ = DW_CFA_advance_loc1;
	      *p++ = adv;
	    }
	  else if (adv < 65536)
	    {
	      *p++ = DW_CFA_advance_loc2;
	      bfd_put_16 (htab->elf.dynobj, adv, p);
	      p += 2;
	    }
	  else
	    {
	      *p++ = DW_CFA_advance_loc4;
	      bfd_put_32 (htab->elf.dynobj, adv, p);
	      p += 4;
	    }
	  *p++ = DW_CFA_register;
	  *p++ = 65;
	  p++;
	  *p++ = DW_CFA_advance_loc + 4;
	  *p++ = DW_CFA_restore_extended;
	  *p++ = 65;
	}
      BFD_ASSERT ((bfd_vma) ((p + 3 - htab->glink_eh_frame->contents) & -4)
		  == htab->glink_eh_frame->size);
@


1.314
log
@bfd/
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Don't make _DYNAMIC,
	_GLOBAL_OFFSET_TABLE_ or _PROCEDURE_LINKAGE_TABLE_ absolute.
	* elf64-ppc.c (ppc64_elf_finish_dynamic_symbol): Don't make _DYNAMIC
	absolute.
ld/testsuite/
	* ld-powerpc/tlsso.r: Update for dynamic sym changes.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
@
text
@a2248 9
static bfd_boolean
ppc_elf_section_flags (flagword *flags ATTRIBUTE_UNUSED,
		       const Elf_Internal_Shdr *hdr)
{
  if (hdr->sh_flags & SHF_PPC_VLE)
    hdr->bfd_section->has_vle_insns = 1;
  return TRUE;
}

d2366 1
a2366 1
      sect0_vle = is_ppc_vle (m->sections[0]);
d2369 3
a2371 1
	  if (is_ppc_vle (m->sections[j]) != sect0_vle)
a2376 2
      sectj_vle = is_ppc_vle (m->sections[j]);

d3114 9
a9712 1
#define elf_backend_section_flags		ppc_elf_section_flags
@


1.313
log
@bfd/
	* elf32-ppc.c (has_tls_reloc, has_tls_get_addr_call, has_vle_insns,
	is_ppc_vle): Move to..
	* elf32-ppc.h: ..here, making is_ppc_vle a macro.
opcodes/
	* ppc_dis.c: Don't include elf/ppc.h.
@
text
@a9141 8
  /* Mark some specially defined symbols as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || (!htab->is_vxworks
	  && (h == htab->elf.hgot
	      || strcmp (h->root.root.string,
			 "_PROCEDURE_LINKAGE_TABLE_") == 0)))
    sym->st_shndx = SHN_ABS;

@


1.312
log
@	* bfd-in.h (bfd_get_section_name, bfd_get_section_vma,
	bfd_get_section_lma, bfd_get_section_alignment,
	bfd_get_section_flags, bfd_get_section_userdata): Rewrite macros
	in order to use the `bfd' argument.
	* bfd-in2.h: Regenerate.
	* elf-vxworks.c (elf_vxworks_finish_dynamic_entry): Pass proper `bfd'
	as the first argument for `bfd_get_section_alignment'.
	* elf32-arm.c (create_ifunc_sections): Likewise, for
	`bfd_set_section_alignment'.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise, for
	`bfd_get_section_name'.
	* elf32-microblaze.c (microblaze_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
	* elf64-mmix.c (mmix_final_link_relocate): Likewise, for
	`bfd_get_section_vma'.
	* elf64-ppc.c (create_linkage_sections): Likewise, for
	`bfd_set_section_alignment'.

	* emultempl/m68hc1xelf.em (hook_in_stub): Pass proper `bfd'
	as the first argument for `bfd_get_section_name'.

	* config/tc-alpha.c (maybe_set_gp): Pass proper `bfd'
	as the first argument for `bfd_get_section_vma'.
@
text
@a2096 20
/* Rename some of the generic section flags to better document how they
   are used for ppc32.  */

/* Nonzero if this section has TLS related relocations.  */
#define has_tls_reloc sec_flg0

/* Nonzero if this section has a call to __tls_get_addr.  */
#define has_tls_get_addr_call sec_flg1

/* Nonzero if this secs_tls_get_addr_calltion has the VLE bit set.  */
#define has_vle_insns sec_flg2

bfd_boolean
is_ppc_vle (asection *sec)
{
  return (sec->owner != NULL
	  && is_ppc_elf (sec->owner)
	  && sec->has_vle_insns);
}

@


1.311
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d6312 2
a6313 1
      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
d8335 4
a8338 2
	  BFD_ASSERT (strcmp (bfd_get_section_name (abfd, sec), ".got") == 0
		      || strcmp (bfd_get_section_name (abfd, sec), ".cgot") == 0);
d8388 1
a8388 1
	    name = bfd_get_section_name (abfd, sec->output_section);
d8420 1
a8420 1
	    name = bfd_get_section_name (abfd, sec->output_section);
d8493 1
a8493 1
	    name = bfd_get_section_name (abfd, sec->output_section);
d8585 1
a8585 1
	    name = bfd_get_section_name (abfd, sec->output_section);
@


1.310
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d41 7
d54 2
d1404 256
d1896 29
d2097 20
d2269 31
d2373 64
a3142 9
/* Rename some of the generic section flags to better document how they
   are used here.  */

/* Nonzero if this section has TLS related relocations.  */
#define has_tls_reloc sec_flg0

/* Nonzero if this section has a call to __tls_get_addr.  */
#define has_tls_get_addr_call sec_flg1

d4023 6
d4033 5
d4045 11
d4072 2
d4671 18
d8056 3
d8432 42
d8476 1
d8478 1
d8535 19
a8553 1
	    if (r_type == R_PPC_EMB_SDA21)
d8564 101
d9703 1
a9703 1
#define bfd_elf32_bfd_reloc_name_lookup	ppc_elf_reloc_name_lookup
d9724 1
d9737 3
@


1.309
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d6891 1
a6891 1
					   rel, relend, howto, contents);
@


1.308
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d6227 1
a6227 1
      if (0 && tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
d6882 1
a6882 1
      if (sec != NULL && elf_discarded_section (sec))
d9052 1
a9052 1
      if (htab->glink_eh_frame->sec_info_type == ELF_INFO_TYPE_EH_FRAME
@


1.307
log
@	* elf32-ppc.c (ppc_elf_write_core_note <NT_PRPSINFO>): Don't leave
	trailing garbage in the note.
	* elf64-ppc.c (ppc64_elf_write_core_note <NT_PRPSINFO>): Likewise.
@
text
@a5047 7
  if (h->size == 0)
    {
      info->callbacks->einfo (_("%P: dynamic variable `%s' is zero size\n"),
			      h->root.root.string);
      return TRUE;
    }

d5071 1
a5071 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.306
log
@	PR ld/13470
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Revert substantive
	change in 2011-07-01 commit.  Comment.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d1923 1
a1923 1
	memset (data, 0, 32);
@


1.305
log
@	* config.bfd: Add vectors for powerpc and powerpc64-freebsd.
	* configure.in (TDEFINES): Add rules for powerpc*-freebsd.
	* configure: Regenerate.
	* elf32-ppc.c: Add powerpc-freebsd definitions.
	* elf64-ppc.c: Add powerpc64-freebsd definitions.
	* targets.c: Add bits for powerpc and powerpc64-freebsd.
@
text
@a2989 4
  /* If we were called to copy over info for a weak sym, that's all.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

d3021 10
@


1.304
log
@	* elflink.c (_bfd_elf_create_got_section): Replace
	bfd_make_section_with_flags with bfd_make_section_anyway_with_flags.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_create_glink): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
@
text
@d9132 18
d9160 2
@


1.303
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d2894 1
a2894 1
  s = bfd_make_section_with_flags (abfd, ".rela.iplt", flags);
d2927 2
a2928 2
  s = bfd_make_section_with_flags (abfd, ".dynsbss",
				   SEC_ALLOC | SEC_LINKER_CREATED);
d2938 1
a2938 1
      s = bfd_make_section_with_flags (abfd, ".rela.sbss", flags);
@


1.302
log
@	* elf32-ppc.c (ppc_elf_select_plt_layout): Force bss-plt when
	shared and call to _mcount will go via plt.
@
text
@d8153 3
a8155 1
	       && h->def_dynamic))
@


1.302.2.1
log
@	* elflink.c (_bfd_elf_create_got_section): Replace
	bfd_make_section_with_flags with bfd_make_section_anyway_with_flags.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_create_glink): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
@
text
@d2894 1
a2894 1
  s = bfd_make_section_anyway_with_flags (abfd, ".rela.iplt", flags);
d2927 2
a2928 2
  s = bfd_make_section_anyway_with_flags (abfd, ".dynsbss",
					  SEC_ALLOC | SEC_LINKER_CREATED);
d2938 1
a2938 1
      s = bfd_make_section_anyway_with_flags (abfd, ".rela.sbss", flags);
@


1.302.2.2
log
@	PR ld/13470
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Revert substantive
	change in 2011-07-01 commit.  Comment.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
@
text
@d2990 4
a3024 10
  /* If we were called to copy over info for a weak sym, that's all.
     You might think dyn_relocs need not be copied over;  After all,
     both syms will be dynamic or both non-dynamic so we're just
     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
     code in ppc_elf_adjust_dynamic_symbol needs to check for
     dyn_relocs in read-only sections, and it does so on what is the
     DIR sym here.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

@


1.302.2.3
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d6234 1
a6234 1
      if (0 && tsec->sec_info_type == SEC_INFO_TYPE_MERGE)
d6889 1
a6889 1
      if (sec != NULL && discarded_section (sec))
d9057 1
a9057 1
      if (htab->glink_eh_frame->sec_info_type == SEC_INFO_TYPE_EH_FRAME
@


1.301
log
@	* elf64-ppc.c: Prefix all einfo error strings with "%P: ".
	* elf32-ppc.c: Likewise.
	(ppc_elf_select_plt_layout): Use einfo rather than info to report
	forced bss-plt.
@
text
@d4259 2
d4263 17
d4307 7
a4313 1
    info->callbacks->einfo (_("%P: bss-plt forced due to %B\n"), htab->old_bfd);
@


1.300
log
@	* elf32-ppc.c: Include dwarf2.h.
	(struct ppc_elf_link_hash_table): Add glink_eh_frame.
	(ppc_elf_create_glink): Create .eh_frame section.
	(glink_eh_frame_cie): New array.
	(ppc_elf_size_dynamic_sections): Size glink_eh_frame.
	(ppc_elf_finish_dynamic_sections): Write glink_eh_frame.
@
text
@d3700 1
a3700 1
	      info->callbacks->einfo (_("%H: %s reloc against local symbol\n"),
d4288 1
a4288 1
    info->callbacks->info (_("Using bss-plt due to %B"), htab->old_bfd);
d5019 1
a5019 1
      info->callbacks->einfo (_("dynamic variable `%s' is zero size\n"),
d7238 1
a7238 1
	    (_("%B: unknown relocation type %d for symbol %s\n"),
d7499 1
a7499 1
		(_("%H: non-zero addend on %s reloc against `%s'\n"),
d7695 1
a7695 1
			    (_("%H: relocation %s for indirect "
d7923 1
a7923 1
		  (_("%B: the target (%s) of a %s relocation is "
d7953 1
a7953 1
		  (_("%B: the target (%s) of a %s relocation is "
d8000 1
a8000 1
		  (_("%B: the target (%s) of a %s relocation is "
d8072 1
a8072 1
	    (_("%B: relocation %s is not yet supported for symbol %s\n"),
d8131 1
a8131 1
	    (_("%H: unresolvable %s relocation against symbol `%s'\n"),
d8178 1
a8178 1
		(_("%H: %s reloc against `%s': error %d\n"),
d8669 1
a8669 1
	  info->callbacks->einfo (_("%s not defined in linker created %s\n"),
@


1.299
log
@	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Don't look at
	dyn relocs when called to copy flags for a weak sym.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	(ppc64_elf_merge_private_bfd_data): Delete.
	(bfd_elf64_bfd_merge_private_bfd_data): Define as
	_bfd_generic_verify_endian_match.
@
text
@d39 1
d2683 1
d2874 11
d5524 14
d5798 15
d5836 1
d8961 72
@


1.298
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d2960 21
a3011 21
  edir->tls_mask |= eind->tls_mask;
  edir->has_sda_refs |= eind->has_sda_refs;

  /* If called to transfer flags for a weakdef during processing
     of elf_adjust_dynamic_symbol, don't copy non_got_ref.
     We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
  if (!(ELIMINATE_COPY_RELOCS
	&& eind->elf.root.type != bfd_link_hash_indirect
	&& edir->elf.dynamic_adjusted))
    edir->elf.non_got_ref |= eind->elf.non_got_ref;

  edir->elf.ref_dynamic |= eind->elf.ref_dynamic;
  edir->elf.ref_regular |= eind->elf.ref_regular;
  edir->elf.ref_regular_nonweak |= eind->elf.ref_regular_nonweak;
  edir->elf.needs_plt |= eind->elf.needs_plt;
  edir->elf.pointer_equality_needed |= eind->elf.pointer_equality_needed;

  /* If we were called to copy over info for a weak sym, that's all.  */
  if (eind->elf.root.type != bfd_link_hash_indirect)
    return;

@


1.297
log
@Fix spelling mistakes.
@
text
@a5151 6
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a5500 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.296
log
@	* elf-bfd.h: Comment typo fix.
	* elf32-ppc.c (struct ppc_elf_dyn_relocs): Delete.  Replace with
	struct elf_dyn_relocs throughout.
	* elf64-ppc.c (struct ppc_dyn_relocs): Likewise.
@
text
@d4148 1
a4148 1
  /* Check if we have the same endianess.  */
@


1.295
log
@	* elf32-frv.c: Use info->callbacks->einfo throughout file in linker
	functions rather than warning callback or _bfd_error_handler.
	* elf32-ppc.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf32-ppc.c (ppc_elf_tls_optimize): Use %H in __tls_get_addr lost
	arg error.
	* elf64-ppc.c (ppc64_elf_tls_optimize): Likewise.
@
text
@a2564 20
/* The PPC linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct ppc_elf_dyn_relocs
{
  struct ppc_elf_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};

d2639 1
a2639 1
  struct ppc_elf_dyn_relocs *dyn_relocs;
d2964 2
a2965 2
	  struct ppc_elf_dyn_relocs **pp;
	  struct ppc_elf_dyn_relocs *p;
d2971 1
a2971 1
	      struct ppc_elf_dyn_relocs *q;
d3914 2
a3915 2
	      struct ppc_elf_dyn_relocs *p;
	      struct ppc_elf_dyn_relocs **rel_head;
d3961 1
a3961 1
		  rel_head = (struct ppc_elf_dyn_relocs **) vpp;
d4365 1
a4365 1
	  struct ppc_elf_dyn_relocs **pp, *p;
d4863 1
a4863 1
  struct ppc_elf_dyn_relocs *p;
d5147 1
a5147 1
  struct ppc_elf_dyn_relocs *p;
d5405 1
a5405 1
	  struct ppc_elf_dyn_relocs **pp;
d5420 1
a5420 1
	  struct ppc_elf_dyn_relocs **pp;
d5572 1
a5572 1
	  struct ppc_elf_dyn_relocs *p;
d5574 1
a5574 1
	  for (p = ((struct ppc_elf_dyn_relocs *)
@


1.294
log
@bfd/
	* elf.c (elfcore_grok_psinfo): Initialize CORE_PID for both native and
	32bit psinfo.
	* elf32-ppc.c (ppc_elf_grok_psinfo): Initialize core_pid.
	* elf64-ppc.c (ppc64_elf_grok_psinfo): Likewise.
@
text
@d3 2
a4 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
d3707 3
a3709 6
	      (*_bfd_error_handler) (_("%B(%A+0x%lx): %s reloc against "
				       "local symbol"),
				     abfd,
				     sec,
				     (long) rel->r_offset,
				     ppc_elf_howto_table[r_type]->name);
d4705 1
a4705 1
		      info->callbacks->minfo ("%C __tls_get_addr lost arg, "
d4791 1
a4791 1
		      info->callbacks->minfo (_("%C arg lost __tls_get_addr, "
d5026 2
a5027 2
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
d7223 2
a7224 2
	  (*_bfd_error_handler)
	    (_("%B: unknown relocation type %d for symbol %s"),
d7484 3
a7486 5
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): non-zero addend on %s reloc against `%s'"),
		 input_bfd,
		 input_section,
		 (long) rel->r_offset,
d7680 4
a7683 6
			  (*_bfd_error_handler)
			    (_("%B(%A+0x%lx): relocation %s for indirect "
			       "function %s unsupported"),
			     input_bfd,
			     input_section,
			     (long) rel->r_offset,
d7908 1
a7908 1
		(*_bfd_error_handler)
d7910 1
a7910 1
		     "in the wrong output section (%s)"),
d7938 1
a7938 1
		(*_bfd_error_handler)
d7940 1
a7940 1
		     "in the wrong output section (%s)"),
d7985 1
a7985 1
		(*_bfd_error_handler)
d7987 1
a7987 1
		     "in the wrong output section (%s)"),
d8057 2
a8058 2
	  (*_bfd_error_handler)
	    (_("%B: relocation %s is not yet supported for symbol %s."),
d8116 3
a8118 5
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     input_bfd,
	     input_section,
	     (long) rel->r_offset,
d8163 4
a8166 4
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): %s reloc against `%s': error %d"),
		 input_bfd, input_section,
		 (long) rel->r_offset, howto->name, sym_name, (int) r);
d8655 4
a8658 4
	  (*_bfd_error_handler) (_("%s not defined in linker created %s"),
				 htab->elf.hgot->root.root.string,
				 (htab->sgotplt != NULL
				  ? htab->sgotplt->name : htab->got->name));
@


1.293
log
@	PR 10549
	* elf-bfd.h (has_ifunc_symbols): Renamed to has_gnu_symbols.
	(has_gnu_symbols): Renamed from has_ifunc_symbols.
	* elf.c (_bfd_elf_set_osabi): Use new has_gnu_symbols name.
	* elf32-arm.c (elf32_arm_add_symbol_hook): Set has_gnu_symbols
	also if STB_GNU_UNIQUE symbol binding was seen.
	* elf32-i386.c (elf_i386_add_symbol_hook): Likewise.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf_x86_64_add_symbol_hook): Likewise.

	* ld-unique: New directory.
	* ld-unique/unique.exp: New file: Run the UNIQUE tests.
	* ld-unique/unique.s: New test file.
	* ld-unique/unique_empty.s: Likewise.
	* ld-unique/unique_shared.s: Likewise.
@
text
@d1884 2
@


1.292
log
@bfd/
	* elf32-ppc.c (ppc_elf_tls_optimize): Catch more cases where
	old-style __tls_get_addr calls without marker relocs don't match
	their arg setup insn one for one.  If such mismatches are found
	report the reloc and don't do any tls optimization.
	* elf64-ppc.c (ppc64_elf_tls_optimize): Likewise.
ld/testsuite/
	* ld-powerpc/tlsmark.s: Delete non-optimizable section.
	* ld-powerpc/tlsmark32.s: Likewise.
	* ld-powerpc/tlsmark.d: Adjust to suit.
	* ld-powerpc/tlsmark32.d: Likewise.
	* ld-powerpc/tlsopt1.d, * ld-powerpc/tlsopt1.s: New.
	* ld-powerpc/tlsopt2.d, * ld-powerpc/tlsopt2.s: New.
	* ld-powerpc/tlsopt3.d, * ld-powerpc/tlsopt3.s: New.
	* ld-powerpc/tlsopt4.d, * ld-powerpc/tlsopt4.s: New.
	* ld-powerpc/tlsopt1_32.d, * ld-powerpc/tlsopt1_32.s: New.
	* ld-powerpc/tlsopt2_32.d, * ld-powerpc/tlsopt2_32.s: New.
	* ld-powerpc/tlsopt3_32.d, * ld-powerpc/tlsopt3_32.s: New.
	* ld-powerpc/tlsopt4_32.d, * ld-powerpc/tlsopt4_32.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.
@
text
@d3116 3
a3118 2
      && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
    elf_tdata (info->output_bfd)->has_ifunc_symbols = TRUE;
@


1.291
log
@	* elf32-ppc.c (ppc_elf_link_hash_newfunc): Initialize has_sda_refs
	field.
@
text
@d4634 3
d4639 4
a4642 2
     followed by such a call.  If they are not, exclude them from
     the optimizations done on the second pass.  */
d4654 1
a4670 1
		  int expecting_tls_get_addr;
a4684 1
		  expecting_tls_get_addr = 0;
d4691 22
d4789 7
a4795 3
			 the entire section.  */
		      sec->has_tls_reloc = 0;
		      break;
@


1.290
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d2788 1
@


1.290.2.1
log
@	* elf32-ppc.c (ppc_elf_link_hash_newfunc): Initialize has_sda_refs
	field.
@
text
@a2787 1
      ppc_elf_hash_entry (entry)->has_sda_refs = 0;
@


1.290.2.2
log
@bfd/
	* elf32-ppc.c (ppc_elf_tls_optimize): Catch more cases where
	old-style __tls_get_addr calls without marker relocs don't match
	their arg setup insn one for one.  If such mismatches are found
	report the reloc and don't do any tls optimization.
	* elf64-ppc.c (ppc64_elf_tls_optimize): Likewise.
ld/testsuite/
	* ld-powerpc/tlsmark.s: Delete non-optimizable section.
	* ld-powerpc/tlsmark32.s: Likewise.
	* ld-powerpc/tlsmark.d: Adjust to suit.
	* ld-powerpc/tlsmark32.d: Likewise.
	* ld-powerpc/tlsopt1.d, * ld-powerpc/tlsopt1.s: New.
	* ld-powerpc/tlsopt2.d, * ld-powerpc/tlsopt2.s: New.
	* ld-powerpc/tlsopt3.d, * ld-powerpc/tlsopt3.s: New.
	* ld-powerpc/tlsopt4.d, * ld-powerpc/tlsopt4.s: New.
	* ld-powerpc/tlsopt1_32.d, * ld-powerpc/tlsopt1_32.s: New.
	* ld-powerpc/tlsopt2_32.d, * ld-powerpc/tlsopt2_32.s: New.
	* ld-powerpc/tlsopt3_32.d, * ld-powerpc/tlsopt3_32.s: New.
	* ld-powerpc/tlsopt4_32.d, * ld-powerpc/tlsopt4_32.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.
@
text
@a4633 3
  if (htab == NULL)
    return FALSE;

d4636 2
a4637 4
     followed by such a call.  If they are not, don't do any tls
     optimization.  On the second pass twiddle tls_mask flags to
     notify relocate_section that optimization can be done, and
     adjust got and plt refcounts.  */
a4648 1
	      int expecting_tls_get_addr = 0;
d4665 1
d4680 1
a4686 22
		  /* If this section has old-style __tls_get_addr calls
		     without marker relocs, then check that each
		     __tls_get_addr call reloc is preceded by a reloc
		     that conceivably belongs to the __tls_get_addr arg
		     setup insn.  If we don't find matching arg setup
		     relocs, don't do any tls optimization.  */
		  if (pass == 0
		      && sec->has_tls_get_addr_call
		      && h != NULL
		      && h == htab->tls_get_addr
		      && !expecting_tls_get_addr
		      && is_branch_reloc (r_type))
		    {
		      info->callbacks->minfo ("%C __tls_get_addr lost arg, "
					      "TLS optimization disabled\n",
					      ibfd, sec, rel->r_offset);
		      if (elf_section_data (sec)->relocs != relstart)
			free (relstart);
		      return TRUE;
		    }

		  expecting_tls_get_addr = 0;
d4763 3
a4765 7
			 the entire optimization.  */
		      info->callbacks->minfo (_("%C arg lost __tls_get_addr, "
						"TLS optimization disabled\n"),
					      ibfd, sec, rel->r_offset);
		      if (elf_section_data (sec)->relocs != relstart)
			free (relstart);
		      return TRUE;
@


1.290.2.3
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@d3116 2
a3117 3
      && (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC
	  || ELF_ST_BIND (sym->st_info) == STB_GNU_UNIQUE))
    elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;
@


1.290.2.4
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@a1883 2
      elf_tdata (abfd)->core_pid
	= bfd_get_32 (abfd, note->descdata + 16);
@


1.289
log
@bfd/
	* elf-bfd.h (struct bfd_elf_section_reloc_data): New structure.
	(struct bfd_elf_section_data): New members REL and RELA; delete
	members REL_HDR, REL_HDR2, REL_COUNT, REL_COUNT2, REL_IDX,
	REL_IDX2, REL_HASHES.
	(_bfd_elf_init_reloc_shdr): Adjust declaration.
	(_bfd_elf_single_rel_hdr): Declare.
	(RELOC_AGAINST_DISCARDED_SECTION): Use it.
	* elf.c (bfd_section_from_shdr): Adjusted to match changes in
	data structures.
	(_bfd_elf_init_reloc_shdr): New arg RELDATA.  Remove arg REL_HDR.
	All callers changed.  Allocate memory for the Elf_Internal_Shdr
	structure.
	(_bfd_elf_single_rel_hdr): New function.
	(struct fake_section_arg): New structure.
	(elf_fake_section): Expect to see a pointer to it in the third
	argument.  If doing a relocatable link, allocate both REL and RELA
	sections as needed.
	(assign_section_numbers): Adjusted to match changes in
	data structures.
	(_bfd_elf_compute_section_file_positions): Call elf_fake_sections
	with a struct fake_section_args argument.
	* elfcode.h (elf_write_relocs): Adjusted to match changes in
	data structures.
	(elf_slurp_reloc_table): Likewise.
	* elflink.c (_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Remove arg REL_HDR, replace with
	RELDATA.  Remove argument O.  All callers changed.  Remove code to
	discover the right rel_hdr and count.
	(_bfd_elf_link_output_relocs): Adjusted to match changes in
	data structures.
	(elf_link_adjust_relocs): Remove args REL_HDR, COUNT and REL_HASH;
	replace with RELDATA.  All callers changed.
	(elf_link_input_bfd): Correctly generate rel_hash data when both
	REL and RELA sections are present.
	(elf_reloc_link_order): Adjusted to match changes in
	data structures.
	(bfd_elf_final_link): Simplify code to count relocs.  Free the
	hashes array for both REL and RELA.
	(get_dynamic_reloc_section_name): Use _bfd_elf_single_reloc_hdr
	* elf32-m32r.c (m32r_elf_fake_sections, elf_backend_fake_sections):
	Delete.
	* elf32-tic6x.c (elf32_tic6x_fake_sections, elf_backend_fake_sections):
	Delete.
	(elf32_tic6x_rel_relocation_p): Adjusted to match changes in
	data structures.
 	* elf32-microblaze.c (microblaze_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	* elf64-mips.c (mips_elf64_slurp_reloc_table): Adjusted to match
	changes in data structures.
	(mips_elf64_write_relocs): Use _bfd_elf_single_rel_hdr.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(get_relocs): Adjusted to match changes in data structures.
	Allocate an Elf_Internal_Shdr structure if necessary.
	(ppc64_elf_finish_dynamic_sections): Use _bfd_elf_single_rel_hdr.
	* elf64-sparc.c (elf64_sparc_slurp_reloc_table): Adjusted to match
	changes in data structures.
	* elfxx-ia64.c (get_reloc_section): Use _bfd_elf_single_rel_hdr.
	* elfxx-mips.c (MIPS_RELOC_RELA_P): Remove macro.
	(mips_elf_rel_relocation_p): Adjusted to match changes in data
	structures.
	(_bfd_mips_elf_relocate_section): Use mips_elf_rel_relocation_p rather
	than MIPS_RELOC_RELOCA_P.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Use
	_bfd_elf_single_rel_hdr.
	(_bfd_sparc_elf_relocate_section): Likewise.

ld/
	* emultempl/xtensaelf.em (replace_insn_sec_with_prop_sec): Use
	_bfd_elf_single_rel_hdr.
@
text
@d6820 2
a6821 4
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
@


1.288
log
@2010-09-24  Thomas Schwinge  <thomas@@codesourcery.com>

	* elf32-arm.c, elf32-cris.c, elf32-hppa.c, elf32-i370.c, elf32-m32r.c,
	elf32-m68k.c, elf32-microblaze.c, elf32-ppc.c, elf32-score.c,
	elf32-score7.c, elf32-sh.c, elf32-vax.c, elf32-xtensa.c, elf64-alpha.c,
	elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-sparc.c, elfcode.h,
	elflink.c, elfxx-ia64.c, elfxx-mips.c: Use STN_UNDEF when referring to
	the zero symbol index.
@
text
@d6394 1
d6413 2
a6414 2
      elf_section_data (isec)->rel_hdr.sh_size
	+= changes * elf_section_data (isec)->rel_hdr.sh_entsize;
@


1.287
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d6988 1
a6988 1
			r_symndx = 0;
d6990 1
a6990 1
		      if (r_symndx != 0)
d7056 1
a7056 1
		r_symndx = 0;
d7058 1
a7058 1
	      if (r_symndx != 0)
d7661 1
a7661 1
		      else if (r_symndx == 0 || bfd_is_abs_section (sec))
@


1.286
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d8930 1
@


1.285
log
@bfd/
	* elf32-ppc.c (ppc_elf_relax_section): Insert branch around
	trampolines only for .init and .fini sections.
ld/testsuite/
	* ld-powerpc/relax.s: Add branch back to _start.
	* ld-powerpc/relax.d: Update.
	* ld-powerpc/relaxr.d: Update.
@
text
@d1861 1
a1861 1
      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
@


1.284
log
@	* elf32-ppc.c: Formatting.
	(ppc_elf_finish_dynamic_sections): Don't make plt_entry var static.
@
text
@d5970 1
d5989 2
d5992 2
a5993 1
  trampoff += 4;
a6317 1
      bfd_vma val;
d6333 1
d6335 6
a6340 2
      val = B + trampoff - isec->size;
      dest = contents + isec->size;
a6341 2
      bfd_put_32 (abfd, val, dest);
      dest += 4;
@


1.283
log
@fix set but unused variable warnings
@
text
@d2195 1
a2195 1
      
d2233 1
a2233 1
      
d2711 1
a2711 1
 
d4047 1
a4047 1
	  (_("Warning: %B uses double-precision hard float, %B uses single-precision hard float"), 
d4051 1
a4051 1
	  (_("Warning: %B uses double-precision hard float, %B uses single-precision hard float"), 
d4055 1
a4055 1
	  (_("Warning: %B uses soft float, %B uses single-precision hard float"), 
d5230 1
a5230 1
			   library, then set the symbol to this location 
d5986 1
a5986 1
  
d6391 1
a6391 1
      
d6433 1
a6433 1
  
d7603 3
a7605 3
	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
d8200 1
a8200 1
		
d8241 1
a8241 1
		bfd_put_32 (output_bfd, 
d8250 2
a8251 2
		bfd_put_32 (output_bfd, 
			    (plt_entry[5] 
d8400 2
a8401 2
		sym->st_value = (ent->glink_offset +
				 htab->glink->output_offset
d8530 1
a8530 1
    splt = bfd_get_section_by_name (dynobj, ".plt");  
d8639 3
a8641 3
      static const bfd_vma *plt_entry = NULL;
      plt_entry = info->shared ? 
	ppc_elf_vxworks_pic_plt0_entry : ppc_elf_vxworks_plt0_entry;
d8679 1
a8679 1
	  
@


1.282
log
@Implement generic SHF_EXCLUDE.

bfd/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* elf.c (_bfd_elf_make_section_from_shdr): Handle SHF_EXCLUDE
	(elf_fake_sections): Likewise.

	* elf32-i370.c (i370_elf_section_from_shdr): Don't handle
	SHF_EXCLUDE here.
	* elf32-ppc.c (ppc_elf_fake_sections): Likewise.

binutils/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* readelf.c (get_elf_section_flags): Treat SHF_EXCLUDE as a
	generic flag.

binutils/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* binutils-all/objcopy.exp: Run exclude-1a and exclude-1b for
	ELF targets.

	* binutils-all/exclude-1.s: New.
	* binutils-all/exclude-1a.d: Likewise.
	* binutils-all/exclude-1b.d: Likewise.

gas/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* obj-elf.c (obj_elf_change_section): Handle SHF_EXCLUDE.
	(obj_elf_parse_section_letters): Likewise.
	(obj_elf_section_word): Likewise.

	* config/tc-ppc.c (ppc_section_letter): Removed.
	(ppc_section_word): Likewise.
	* config/tc-ppc.h (ppc_section_letter): Likewise.
	(ppc_section_word): Likewise.
	(md_elf_section_letter): Likewise.
	(md_elf_section_word): Likewise.

	* doc/as.texinfo: Document `e' and `#exclude'.

gas/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* gas/elf/elf.exp: Run section8.

	* gas/elf/section8.d: New.
	* gas/elf/section8.s: Likewise.

include/elf/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* common.h (SHF_EXCLUDE): New.

	* i370.h (SHF_EXCLUDE): Removed.
	* or32.h (SHF_EXCLUDE): Likewise.
	* ppc.h (SHF_EXCLUDE): Likewise.
	* sparc.h (SHF_EXCLUDE): Likewise.

ld/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* ld-elf/exclude3.s: New.
	* ld-elf/exclude3a.d: Likewise.
	* ld-elf/exclude3b.d: Likewise.
	* ld-elf/exclude3c.d: Likewise.
@
text
@a4790 1
		      Elf_Internal_Sym *sym;
a4808 1
		      sym = locsyms + r_symndx;
@


1.281
log
@	bfd/
	* elf32-ppc.c (apuinfo_set): New static var.
	(ppc_elf_begin_write_processing): Set it here, always create an
	APUinfo section if there were any in the inputs.
	(ppc_elf_write_section): Check apuinfo_set.
	(ppc_elf_final_write_processing): Likewise.

	ld/testsuite/
	* ld-powerpc/apuinfo-nul.rd: New.
	* ld-powerpc/apuinfo-nul1.s: New.
	* ld-powerpc/powerpc.exp: Add it.
@
text
@a1996 3
  if ((asect->flags & (SEC_GROUP | SEC_EXCLUDE)) == SEC_EXCLUDE)
    shdr->sh_flags |= SHF_EXCLUDE;

@


1.280
log
@	* elf32-ppc.c (ppc_elf_howto_raw <R_PPC_EMB_RELSDA>): Not pc-relative.
	* bfd-in.h (elf_discarded_section): Clarify comment.
	* reloc.c (struct reloc_howto_struct <pc_relative>): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2080 1
a2080 1

d2086 1
a2165 1
  unsigned num_entries;
d2188 1
d2232 1
a2232 4
  /* Compute the size of the output section.  */
  num_entries = apuinfo_list_length ();

  if (num_entries)
d2234 3
d2239 1
d2264 1
a2264 2
  return (apuinfo_list_length ()
	  && strcmp (asec->name, APUINFO_SECTION_NAME) == 0);
d2282 1
a2282 1
  if (apuinfo_list_length () == 0)
@


1.279
log
@Don't set ELFOSABI_LINUX in dynamic ifunc-using executable.

bfd/

2010-02-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_add_symbol_hook): Don't set
	has_ifunc_symbols if the symbol comes from a shared library.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): Likewise.

ld/testsuite/

2010-02-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-ifunc/ifunc.exp: Expect System V OSABI in dynamic
	ifunc-using executable.
@
text
@d1383 1
a1383 1
	 TRUE,			/* pc_relative */
@


1.278
log
@	* section.c (struct bfd_section): Delete has_tls_reloc,
	has_tls_get_addr_call, has_gp_reloc, need_finalize_relax, reloc_done.
	Add sec_flg0 thru sec_flg5.
	(BFD_FAKE_SECTION): Update for changed flags.
	* ecoff.c (bfd_debug_section): Likewise.
	* elf32-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	* elf64-ppc.c (has_tls_reloc, has_tls_get_addr_call): Define.
	(has_toc_reloc, makes_toc_func_call, call_check_in_progress): Update.
	* elf32-xtensa.c (reloc_done): Define.
	* elfxx-ia64.c (skip_relax_pass_0, skip_relax_pass_1): Update.
	* bfd-in2.h: Regenerate.
@
text
@d3116 2
a3117 1
  if (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
@


1.277
log
@bfd/
	* elf32-ppc.c (ppc_elf_begin_write_processing): Allow empty
	apuinfo sections, only scan input sections once and reuse the
	buffer.
ld/testsuite/
	* ld-powerpc/apuinfo-nul.s: New.
	* ld-powerpc/apuinfo.rd: Add it.
	* ld-powerpc/powerpc.exp: Likewise.
@
text
@d2751 9
@


1.276
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Remove dead ifunc code.
@
text
@d2162 2
a2163 3
  char *buffer;
  unsigned num_input_sections;
  bfd_size_type	output_section_size;
a2165 1
  unsigned long	offset;
a2171 30
  /* Scan the input bfds, looking for apuinfo sections.  */
  num_input_sections = 0;
  output_section_size = 0;

  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);
      if (asec)
	{
	  ++ num_input_sections;
	  output_section_size += asec->size;
	}
    }

  /* We need at least one input sections
     in order to make merging worthwhile.  */
  if (num_input_sections < 1)
    return;

  /* Just make sure that the output section exists as well.  */
  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);
  if (asec == NULL)
    return;

  /* Allocate a buffer for the contents of the input sections.  */
  buffer = bfd_malloc (output_section_size);
  if (buffer == NULL)
    return;

  offset = 0;
a2177 1
      char *ptr;
d2183 1
d2185 4
a2188 1
      if (length < 24)
d2190 6
a2195 2
	  error_message = _("corrupt or empty %s section in %B");
	  goto fail;
d2197 1
a2197 1

d2199 1
a2199 1
	  || (bfd_bread (buffer + offset, length, ibfd) != length))
a2204 4
      /* Process the contents of the section.  */
      ptr = buffer + offset;
      error_message = _("corrupt %s section in %B");

d2208 1
a2208 1
      datum = bfd_get_32 (ibfd, ptr);
d2212 1
a2212 1
      datum = bfd_get_32 (ibfd, ptr + 8);
d2216 1
a2216 1
      if (strcmp (ptr + 12, APUINFO_LABEL) != 0)
d2220 1
a2220 1
      datum = bfd_get_32 (ibfd, ptr + 4);
a2223 4
      /* Make sure that we do not run off the end of the section.  */
      if (offset + length > output_section_size)
	goto fail;

d2226 1
a2226 4
	apuinfo_list_add (bfd_get_32 (ibfd, ptr + 20 + i));

      /* Update the offset.  */
      offset += length;
a2232 1
  output_section_size = 20 + num_entries * 4;
d2234 10
a2243 5
  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);

  if (! bfd_set_section_size (abfd, asec, output_section_size))
    ibfd = abfd,
      error_message = _("warning: unable to set size of %s section in %B");
d2246 2
a2247 1
  free (buffer);
@


1.275
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@a3449 1
      struct plt_entry **ifunc;
a3476 1
      ifunc = NULL;
d3478 1
a3478 1
      if (!htab->is_vxworks)
d3480 8
a3487 1
	  if (h != NULL)
d3489 6
a3494 8
	      if (h->type == STT_GNU_IFUNC)
		ifunc = &h->plt.plist;
	    }
	  else
	    {
	      Elf_Internal_Sym *isym = bfd_sym_from_r_symndx (&htab->sym_cache,
							      abfd, r_symndx);
	      if (isym == NULL)
d3497 5
a3501 3
	      if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC
		  && (!info->shared
		      || is_branch_reloc (r_type)))
d3503 3
a3505 19
		  bfd_vma addend;

		  ifunc = update_local_sym_info (abfd, symtab_hdr, r_symndx,
						 PLT_IFUNC);
		  if (ifunc == NULL)
		    return FALSE;

		  /* STT_GNU_IFUNC symbols must have a PLT entry;
		     In a non-pie executable even when there are
		     no plt calls.  */
		  addend = 0;
		  if (r_type == R_PPC_PLTREL24)
		    {
		      ppc_elf_tdata (abfd)->makes_plt_call = 1;
		      if (info->shared)
			addend = rel->r_addend;
		    }
		  if (!update_plt_info (abfd, ifunc, got2, addend))
		    return FALSE;
d3507 2
@


1.274
log
@	PR ld/11217
	* elf64-ppc.c (ppc64_elf_tls_optimize): Optimize tls sequences
	with relocations against undefined weak symbols.
	(ppc64_elf_relocate_section): Don't optimize calls to undefined
	weak functions if the symbol is dynamic.
	(ppc64_elf_relocate_section): Edit tprel tls sequences.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(_bfd_elf_ppc_at_tprel_transform): New function.
	* bfd-in.h (_bfd_elf_ppc_at_tprel_transform): Declare.
	* bfd-in2.h: Regenerate.
@
text
@d1799 1
a1799 1
   && elf_object_id (bfd) == PPC32_ELF_TDATA)
d1807 1
a1807 1
				  PPC32_ELF_TDATA);
d2785 2
a2786 1
  ((struct ppc_elf_link_hash_table *) (p)->hash)
d2830 2
a2831 1
				      sizeof (struct ppc_elf_link_hash_entry)))
@


1.273
log
@	PR ld/11088
include/elf/
	* ppc.h (R_PPC_RELAX32, R_PPC_RELAX32PC, R_PPC_RELAX32_PLT,
	R_PPC_RELAX32PC_PLT): Delete.
	(R_PPC_RELAX, R_PPC_RELAX_PLT, R_PPC_RELAX_PLTREL24): Define.
bfd/
	* elf32-ppc.c (update_plt_info): Clear sec here when addend is
	less than 32768..
	(ppc_elf_check_relocs): ..rather than doing so here.  Ignore new
	relax relocs.
	(ppc_elf_gc_sweep_hook): Don't segfault when symbol hiding has
	removed plt_entry records.
	(ppc_elf_tls_setup): Handle PIE calls to __tls_get_addr correctly.
	(ppc_elf_tls_optimize): Likewise.  Also dec __tls_get_addr refcount
	when optimizing code using new tlsgd and tlsld marker relocs.
	(ppc_elf_relax_section): Differentiate relaxed PLTREL24 relocs
	from ADDR24 relocs using plt or glink.  Don't clear the addend
	for R_PPC_RELAX_PLTREL24.
	(ppc_elf_relocate_section): Correctly handle addends on relaxed
	PLTREL24 relocs.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d6672 45
d7519 15
@


1.272
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3326 2
d3513 1
a3513 2
		  if (!update_plt_info (abfd, ifunc,
					addend < 32768 ? NULL : got2, addend))
d3752 1
a3752 2
	      if (!update_plt_info (abfd, &h->plt.plist,
				    addend < 32768 ? NULL : got2, addend))
d3783 3
a3785 4
	case R_PPC_RELAX32:
	case R_PPC_RELAX32PC:
	case R_PPC_RELAX32_PLT:
	case R_PPC_RELAX32PC_PLT:
d4488 1
a4488 1
		  if (ent->plt.refcount > 0)
d4536 1
a4536 1
	      if (ent->plt.refcount > 0)
d4584 4
a4587 3
	      ent = find_plt_ent (&tga->plt.plist, NULL, 0);
	      if (ent != NULL
		  && ent->plt.refcount > 0)
d4672 1
d4766 7
d4780 2
a4781 1
			  || !sec->has_tls_get_addr_call)
d4797 17
a4857 10
		  if (expecting_tls_get_addr)
		    {
		      struct plt_entry *ent;

		      ent = find_plt_ent (&htab->tls_get_addr->plt.plist,
					  NULL, 0);
		      if (ent != NULL && ent->plt.refcount > 0)
			ent->plt.refcount -= 1;
		    }

a6257 1
	      stub_rtype = R_PPC_RELAX32PC;
a6262 1
	      stub_rtype = R_PPC_RELAX32;
d6264 1
a6264 4

	  if (R_PPC_RELAX32_PLT - R_PPC_RELAX32
	      != R_PPC_RELAX32PC_PLT - R_PPC_RELAX32PC)
	    abort ();
d6267 5
a6271 1
	    stub_rtype += R_PPC_RELAX32_PLT - R_PPC_RELAX32;
d6278 2
a6279 1
	  if (r_type == R_PPC_PLTREL24)
d6449 1
a6449 1
	if (ELF32_R_TYPE (irel->r_info) == R_PPC_RELAX32)
d7688 2
a7689 2
	case R_PPC_RELAX32PC_PLT:
	case R_PPC_RELAX32_PLT:
d7692 10
a7701 2
	      struct plt_entry *ent = find_plt_ent (&h->plt.plist, got2,
						    info->shared ? addend : 0);
a7710 2
	  if (r_type == R_PPC_RELAX32_PLT)
	    goto relax32;
d7713 5
a7717 5
	case R_PPC_RELAX32PC:
	  relocation -= (input_section->output_section->vma
			 + input_section->output_offset
			 + rel->r_offset - 4);
	  /* Fall thru */
a7718 2
	case R_PPC_RELAX32:
	relax32:
@


1.271
log
@	PR ld/11047
	* elf32-ppc.c (ppc_elf_relocate_section): Delete __tls_get_addr
	symbol reference from relocs belonging to calls that are
	optimized away.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
@
text
@d3964 1
a3964 1
	      struct ppc_elf_dyn_relocs **head;
d3989 1
a3989 1
		  head = &ppc_elf_hash_entry (h)->dyn_relocs;
d4010 1
a4010 1
		  head = (struct ppc_elf_dyn_relocs **) vpp;
d4013 1
a4013 1
	      p = *head;
d4019 2
a4020 2
		  p->next = *head;
		  *head = p;
d5622 1
d5666 1
a5666 1
		asection *s = htab->iplt;
d6022 1
a6022 1
      bfd_vma reladdr, toff, roff;
a6205 1
      reladdr = isec->output_section->vma + isec->output_offset + roff;
a6700 1
  bfd_byte *loc;
d6744 1
a6744 1
      bfd_vma branch_bit, insn, from;
d6842 1
d7058 14
a7071 11
	  insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	  insn &= ~BRANCH_PREDICT_BIT;
	  insn |= branch_bit;

	  from = (rel->r_offset
		  + input_section->output_offset
		  + input_section->output_section->vma);

	  /* Invert 'y' bit if not the default.  */
	  if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
	    insn ^= BRANCH_PREDICT_BIT;
d7073 3
a7075 2
	  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	  break;
d7306 1
d7538 1
a7538 1

d7928 3
a7930 1
	      {			/* fill in register field */
@


1.270
log
@bfd/
	* bfd-in.h (_bfd_elf_ppc_at_tls_transform): Declare.
	* bfd-in2.h: Regenerate.
	* elf64-ppc.c (ppc64_elf_relocate_section): Move code for R_PPC64_TLS
	insn optimisation to..
	* elf32-ppc.c (_bfd_elf_ppc_at_tls_transform): ..here.  New function.
	(ppc_elf_relocate_section): Use it.
gas/
	* config/tc-ppc.c (md_assemble): Report error on invalid @@tls operands
	and opcode.
@
text
@d6932 1
a6932 3
		      rel[1].r_info
			= ELF32_R_INFO (ELF32_R_SYM (rel[1].r_info),
					R_PPC_NONE);
d7006 1
a7006 2
	      rel[1].r_info = ELF32_R_INFO (ELF32_R_SYM (rel[1].r_info),
					    R_PPC_NONE);
d7035 1
a7035 2
	      rel[1].r_info = ELF32_R_INFO (ELF32_R_SYM (rel[1].r_info),
					    R_PPC_NONE);
@


1.269
log
@include/elf/
	* ppc.h (DT_PPC_TLSOPT): Define.
	* ppc64.h (DT_PPC64_TLSOPT): Define.
bfd/
	* elf32-ppc.c (TLS_GET_ADDR_GLINK_SIZE): Define.
	(ADD_3_12_2, BEQLR, CMPWI_11_0, LWZ_11_3, LWZ_12_3): Define.
	(MR_0_3, MR_3_0): Define.
	(struct ppc_elf_link_hash_table): Add no_tls_get_addr_opt.
	(ppc_elf_select_plt_layout): Save emit_stub_syms param earlier.
	(ppc_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt
	(allocate_dynrelocs): Increase glink entry size for __tls_get_addr.
	(ppc_elf_size_dynamic_sections): Add DT_PPC_TLS_OPT tag.
	(write_glink_stub): Add param p.
	(ppc_elf_relocate_section): Adjust write_glink_stub call.
	(ppc_elf_finish_dynamic_symbol): Emit special glink call stub for
	__tls_get_addr.
	* elf32-ppc.h (ppc_elf_tls_setup): Update prototype.
	* elf64-ppc.c (struct ppc_link_hash_table): Add no_tls_get_addr_opt.
	(ppc64_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt.
	(ppc64_elf_size_dynamic_sections): Add DT_PPC64_TLS_OPT tag.
	(LD_R11_0R3, LD_R12_0R3, MR_R0_R3, CMPDI_R11_0, ADD_R3_R12_R13,
	BEQLR, MR_R3_R0, MFLR_R11, STD_R11_0R1, BCTRL, LD_R11_0R1,
	LD_R2_0R1, MTLR_R11): Define.
	(build_tls_get_addr_stub): New function.
	(ppc_build_one_stub): Call it.
	(ppc_size_one_stub): Add extra size for __tls_get_addr stub.
	(ppc64_elf_relocate_section): Don't change nop to ld 2,40(1) for
	__tls_get_addr plt call.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update prototype.
binutils/
	* readelf.c (get_ppc_dynamic_type): Add TLSOPT.
	(get_ppc64_dynamic_type): Likewise.
ld/
	* emultempl/ppc32elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.  Redefine other options in
	terms of previous option.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
	* emultempl/ppc64elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc64_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
ld/testsuite/
	* ld-powerpc/tlslib.s: Delete dot-symbol entry syms.  Add
	__tls_get_addr_opt.
	* ld-powerpc/tlslib32.s: Add __tls_get_addr_opt.
	* ld-powerpc/oldtlslib.s: New file, old-abi version of tlslib.s.
	* ld-powerpc/powerpc.exp: Build old-abi library and use it in
	two new link tests.
	* ld-powerpc/tlsexe.d: Update for new __tls_get_addr stub.
	* ld-powerpc/tlsexe.g, * ld-powerpc/tlsexe.r, *ld-powerpc/tlsexe32.d,
	* ld-powerpc/tlsexe32.g, * ld-powerpc/tlsexe32.r,
	* ld-powerpc/tlsexetoc.d, * ld-powerpc/tlsexetoc.g,
	* ld-powerpc/tlsexetoc.r: Likewise.
@
text
@d6616 40
d6856 2
a6857 1
	      bfd_vma insn, rtra;
d6859 2
a6860 27
	      if ((insn & ((31 << 26) | (31 << 11)))
		  == ((31 << 26) | (2 << 11)))
		rtra = insn & ((1 << 26) - (1 << 16));
	      else if ((insn & ((31 << 26) | (31 << 16)))
		       == ((31 << 26) | (2 << 16)))
		rtra = (insn & (31 << 21)) | ((insn & (31 << 11)) << 5);
	      else
		abort ();
	      if ((insn & ((1 << 11) - (1 << 1))) == 266 << 1)
		/* add -> addi.  */
		insn = 14 << 26;
	      else if ((insn & (31 << 1)) == 23 << 1
		       && ((insn & (31 << 6)) < 14 << 6
			   || ((insn & (31 << 6)) >= 16 << 6
			       && (insn & (31 << 6)) < 24 << 6)))
		/* load and store indexed -> dform.  */
		insn = (32 | ((insn >> 6) & 31)) << 26;
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & (0x1a << 6)) == 0)
		/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
		insn = (((58 | ((insn >> 6) & 4)) << 26)
			| ((insn >> 6) & 1));
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & ((1 << 11) - (1 << 1))) == 341 << 1)
		/* lwax -> lwa.  */
		insn = (58 << 26) | 2;
	      else
a6861 1
	      insn |= rtra;
@


1.268
log
@	PR ld/10406
	* elf32-ppc.c (ppc_elf_howto_raw): Make R_PPC_EMB_SDAI16 and
	R_PPC_EMB_SDA2I16 complain_overflow_signed.
	(create_sdata_sym): Pass info rather than htab.
	Update all callers.  Ensure symbols are hidden.
	(ppc_elf_check_relocs): Allow SDAREL16 when shared.
	(ppc_elf_size_dynamic_sections): When shared, equate _SDA_BASE_ to
	_GLOBAL_OFFSET_TABLE_.
	(elf_finish_pointer_linker_section): Don't assume that sdata base
	symbol is always at 0x8000 offset.  Don't subtract the addend here.
	(is_static_defined): New function.
	(ppc_elf_relocate_section): Verify symbol base used in SDA relocs
	is statically defined.  Clear addend for EMB_SDAI16 and EMB_SDA2I16
	relocs.  Downgrade error on unexpected section for EMB_SDA2REL
	reloc symbols to a warning.
@
text
@d64 1
d139 1
d144 2
d150 1
d153 1
d155 2
d2765 3
d4291 2
a4325 2
  htab->emit_stub_syms = emit_stub_syms;

d4553 3
a4555 1
ppc_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
d4560 49
a4616 2
  htab->tls_get_addr = elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
					     FALSE, FALSE, TRUE);
d5207 3
d5886 5
d6545 1
a6545 1
write_glink_stub (struct plt_entry *ent, asection *plt_sec,
a6550 1
  unsigned char *p;
a6554 1
  p = (unsigned char *) htab->glink->contents + ent->glink_offset;
d7114 3
a7116 1
		  write_glink_stub (ent, htab->iplt, info);
d8345 1
d8351 23
a8373 1
	    write_glink_stub (ent, splt, info);
@


1.267
log
@	bfd/
	* elf32-ppc.c (shared_stub_entry, stub_entry): Use r12, not r11.
	(ppc_elf_relax_section): Use symbol index to distinguish
	relocatable stubs.

	ld/testsuite/
	* ld-powerpc/relax.s: New.
	* ld-powerpc/relax.d: New.
	* ld-powerpc/relaxr.d: New.
	* ld-powerpc/powerpc.exp: Add new tests.
@
text
@d1303 1
a1303 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d1320 1
a1320 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d3132 1
a3132 2
create_sdata_sym (struct ppc_elf_link_hash_table *htab,
		  elf_linker_section_t *lsect)
d3134 2
d3143 1
d3173 1
a3173 1
  return create_sdata_sym (htab, lsect);
a3637 5
	  if (info->shared)
	    {
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
	    }
d3639 1
a3639 1
	      && !create_sdata_sym (htab, &htab->sdata[0]))
d3655 1
a3655 1
	      && !create_sdata_sym (htab, &htab->sdata[1]))
d3672 1
a3672 1
	      && !create_sdata_sym (htab, &htab->sdata[0]))
d3675 1
a3675 1
	      && !create_sdata_sym (htab, &htab->sdata[1]))
d5660 12
d6458 2
a6459 1
  relocation = (lsect->section->output_offset
d6461 1
a6461 1
		- 0x8000);
d6469 1
a6469 3
  /* Subtract out the addend, because it will get added back in by the normal
     processing.  */
  return relocation - linker_section_ptr->addend;
d6539 11
d7651 5
d7659 1
d7665 5
d7673 1
d7726 1
d7728 3
a7730 1
	    if (sec == NULL || sec->output_section == NULL)
d7735 1
a7750 1
	    addend -= SYM_VAL (htab->sdata[0].sym);
d7758 1
d7760 3
a7762 1
	    if (sec == NULL || sec->output_section == NULL)
d7767 1
a7779 4

		bfd_set_error (bfd_error_bad_value);
		ret = FALSE;
		continue;
a7780 1
	    addend -= SYM_VAL (htab->sdata[1].sym);
d7790 1
d7805 1
a7805 1
		addend -= SYM_VAL (htab->sdata[0].sym);
d7811 1
a7811 1
		addend -= SYM_VAL (htab->sdata[1].sym);
d7833 10
@


1.267.2.1
log
@	PR ld/10406
	* elf32-ppc.c (ppc_elf_howto_raw): Make R_PPC_EMB_SDAI16 and
	R_PPC_EMB_SDA2I16 complain_overflow_signed.
	(create_sdata_sym): Pass info rather than htab.
	Update all callers.  Ensure symbols are hidden.
	(ppc_elf_check_relocs): Allow SDAREL16 when shared.
	(ppc_elf_size_dynamic_sections): When shared, equate _SDA_BASE_ to
	_GLOBAL_OFFSET_TABLE_.
	(elf_finish_pointer_linker_section): Don't assume that sdata base
	symbol is always at 0x8000 offset.  Don't subtract the addend here.
	(is_static_defined): New function.
	(ppc_elf_relocate_section): Verify symbol base used in SDA relocs
	is statically defined.  Clear addend for EMB_SDAI16 and EMB_SDA2I16
	relocs.  Downgrade error on unexpected section for EMB_SDA2REL
	reloc symbols to a warning.
@
text
@d1303 1
a1303 1
	 complain_overflow_signed, /* complain_on_overflow */
d1320 1
a1320 1
	 complain_overflow_signed, /* complain_on_overflow */
d3132 2
a3133 1
create_sdata_sym (struct bfd_link_info *info, elf_linker_section_t *lsect)
a3134 2
  struct ppc_elf_link_hash_table *htab = ppc_elf_hash_table (info);

a3141 1
  _bfd_elf_link_hash_hide_symbol (info, lsect->sym, TRUE);
d3171 1
a3171 1
  return create_sdata_sym (info, lsect);
d3636 5
d3642 1
a3642 1
	      && !create_sdata_sym (info, &htab->sdata[0]))
d3658 1
a3658 1
	      && !create_sdata_sym (info, &htab->sdata[1]))
d3675 1
a3675 1
	      && !create_sdata_sym (info, &htab->sdata[0]))
d3678 1
a3678 1
	      && !create_sdata_sym (info, &htab->sdata[1]))
a5662 12
  if (info->shared)
    {
      struct elf_link_hash_entry *sda = htab->sdata[0].sym;
      if (sda != NULL
	  && !(sda->root.type == bfd_link_hash_defined
	       || sda->root.type == bfd_link_hash_defweak))
	{
	  sda->root.type = bfd_link_hash_defined;
	  sda->root.u.def.section = htab->elf.hgot->root.u.def.section;
	  sda->root.u.def.value = htab->elf.hgot->root.u.def.value;
	}
    }
d6449 1
a6449 2
  relocation = (lsect->section->output_section->vma
		+ lsect->section->output_offset
d6451 1
a6451 1
		- SYM_VAL (lsect->sym));
d6459 3
a6461 1
  return relocation;
a6530 11
/* Return true if symbol is defined statically.  */

static bfd_boolean
is_static_defined (struct elf_link_hash_entry *h)
{
  return ((h->root.type == bfd_link_hash_defined
	   || h->root.type == bfd_link_hash_defweak)
	  && h->root.u.def.section != NULL
	  && h->root.u.def.section->output_section != NULL);
}

a7631 5
	  if (!is_static_defined (htab->sdata[0].sym))
	    {
	      unresolved_reloc = TRUE;
	      break;
	    }
a7634 1
	  addend = 0;
a7639 5
	  if (!is_static_defined (htab->sdata[1].sym))
	    {
	      unresolved_reloc = TRUE;
	      break;
	    }
a7642 1
	  addend = 0;
a7694 1
	    struct elf_link_hash_entry *sda = htab->sdata[0].sym;
d7696 1
a7696 3
	    if (sec == NULL
		|| sec->output_section == NULL
		|| !is_static_defined (sda))
a7700 1
	    addend -= SYM_VAL (sda);
d7716 1
a7723 1
	    struct elf_link_hash_entry *sda = htab->sdata[1].sym;
d7725 1
a7725 3
	    if (sec == NULL
		|| sec->output_section == NULL
		|| !is_static_defined (sda))
a7729 1
	    addend -= SYM_VAL (sda);
d7742 4
d7747 1
a7756 1
	    struct elf_link_hash_entry *sda = NULL;
d7771 1
a7771 1
		sda = htab->sdata[0].sym;
d7777 1
a7777 1
		sda = htab->sdata[1].sym;
a7798 10
	    if (sda != NULL)
	      {
		if (!is_static_defined (sda))
		  {
		    unresolved_reloc = TRUE;
		    break;
		  }
		addend -= SYM_VAL (sda);
	      }

@


1.267.2.2
log
@include/elf/
	* ppc.h (DT_PPC_TLSOPT): Define.
	* ppc64.h (DT_PPC64_TLSOPT): Define.
bfd/
	* elf32-ppc.c (TLS_GET_ADDR_GLINK_SIZE): Define.
	(ADD_3_12_2, BEQLR, CMPWI_11_0, LWZ_11_3, LWZ_12_3): Define.
	(MR_0_3, MR_3_0): Define.
	(struct ppc_elf_link_hash_table): Add no_tls_get_addr_opt.
	(ppc_elf_select_plt_layout): Save emit_stub_syms param earlier.
	(ppc_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt
	(allocate_dynrelocs): Increase glink entry size for __tls_get_addr.
	(ppc_elf_size_dynamic_sections): Add DT_PPC_TLS_OPT tag.
	(write_glink_stub): Add param p.
	(ppc_elf_relocate_section): Adjust write_glink_stub call.
	(ppc_elf_finish_dynamic_symbol): Emit special glink call stub for
	__tls_get_addr.
	* elf32-ppc.h (ppc_elf_tls_setup): Update prototype.
	* elf64-ppc.c (struct ppc_link_hash_table): Add no_tls_get_addr_opt.
	(ppc64_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt.
	(ppc64_elf_size_dynamic_sections): Add DT_PPC64_TLS_OPT tag.
	(LD_R11_0R3, LD_R12_0R3, MR_R0_R3, CMPDI_R11_0, ADD_R3_R12_R13,
	BEQLR, MR_R3_R0, MFLR_R11, STD_R11_0R1, BCTRL, LD_R11_0R1,
	LD_R2_0R1, MTLR_R11): Define.
	(build_tls_get_addr_stub): New function.
	(ppc_build_one_stub): Call it.
	(ppc_size_one_stub): Add extra size for __tls_get_addr stub.
	(ppc64_elf_relocate_section): Don't change nop to ld 2,40(1) for
	__tls_get_addr plt call.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update prototype.
binutils/
	* readelf.c (get_ppc_dynamic_type): Add TLSOPT.
	(get_ppc64_dynamic_type): Likewise.
ld/
	* emultempl/ppc32elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.  Redefine other options in
	terms of previous option.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
	* emultempl/ppc64elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc64_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
ld/testsuite/
	* ld-powerpc/tlslib.s: Delete dot-symbol entry syms.  Add
	__tls_get_addr_opt.
	* ld-powerpc/tlslib32.s: Add __tls_get_addr_opt.
	* ld-powerpc/oldtlslib.s: New file, old-abi version of tlslib.s.
	* ld-powerpc/powerpc.exp: Build old-abi library and use it in
	two new link tests.
	* ld-powerpc/tlsexe.d: Update for new __tls_get_addr stub.
	* ld-powerpc/tlsexe.g, * ld-powerpc/tlsexe.r, *ld-powerpc/tlsexe32.d,
	* ld-powerpc/tlsexe32.g, * ld-powerpc/tlsexe32.r,
	* ld-powerpc/tlsexetoc.d, * ld-powerpc/tlsexetoc.g,
	* ld-powerpc/tlsexetoc.r: Likewise.
@
text
@a63 1
#define TLS_GET_ADDR_GLINK_SIZE 12*4
a137 1
#define ADD_3_12_2	0x7c6c1214
a141 2
#define BEQLR		0x4d820020
#define CMPWI_11_0	0x2c0b0000
a145 1
#define LWZ_11_3	0x81630000
a147 1
#define LWZ_12_3	0x81830000
a148 2
#define MR_0_3		0x7c601b78
#define MR_3_0		0x7c030378
a2756 3
  /* Set if __tls_get_addr optimization should not be done.  */
  unsigned int no_tls_get_addr_opt:1;

a4279 2
  htab->emit_stub_syms = emit_stub_syms;

d4313 2
d4542 1
a4542 3
ppc_elf_tls_setup (bfd *obfd,
		   struct bfd_link_info *info,
		   int no_tls_get_addr_opt)
a4546 49
  htab->tls_get_addr = elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
					     FALSE, FALSE, TRUE);
  if (!no_tls_get_addr_opt)
    {
      struct elf_link_hash_entry *opt, *tga;
      opt = elf_link_hash_lookup (&htab->elf, "__tls_get_addr_opt",
				  FALSE, FALSE, TRUE);
      if (opt != NULL
	  && (opt->root.type == bfd_link_hash_defined
	      || opt->root.type == bfd_link_hash_defweak))
	{
	  /* If glibc supports an optimized __tls_get_addr call stub,
	     signalled by the presence of __tls_get_addr_opt, and we'll
	     be calling __tls_get_addr via a plt call stub, then
	     make __tls_get_addr point to __tls_get_addr_opt.  */
	  tga = htab->tls_get_addr;
	  if (htab->elf.dynamic_sections_created
	      && tga != NULL
	      && (tga->type == STT_FUNC
		  || tga->needs_plt)
	      && !(SYMBOL_CALLS_LOCAL (info, tga)
		   || (ELF_ST_VISIBILITY (tga->other) != STV_DEFAULT
		       && tga->root.type == bfd_link_hash_undefweak)))
	    {
	      struct plt_entry *ent;
	      ent = find_plt_ent (&tga->plt.plist, NULL, 0);
	      if (ent != NULL
		  && ent->plt.refcount > 0)
		{
		  tga->root.type = bfd_link_hash_indirect;
		  tga->root.u.i.link = &opt->root;
		  ppc_elf_copy_indirect_symbol (info, opt, tga);
		  if (opt->dynindx != -1)
		    {
		      /* Use __tls_get_addr_opt in dynamic relocations.  */
		      opt->dynindx = -1;
		      _bfd_elf_strtab_delref (elf_hash_table (info)->dynstr,
					      opt->dynstr_index);
		      if (!bfd_elf_link_record_dynamic_symbol (info, opt))
			return FALSE;
		    }
		  htab->tls_get_addr = opt;
		}
	    }
	}
      else
	no_tls_get_addr_opt = TRUE;
    }
  htab->no_tls_get_addr_opt = no_tls_get_addr_opt;
d4555 2
a5146 3
			if (h == htab->tls_get_addr
			    && !htab->no_tls_get_addr_opt)
			  s->size += TLS_GET_ADDR_GLINK_SIZE - GLINK_ENTRY_SIZE;
a5822 5
	  if (!htab->no_tls_get_addr_opt
	      && htab->tls_get_addr != NULL
	      && htab->tls_get_addr->plt.plist != NULL
	      && !add_dynamic_entry (DT_PPC_TLSOPT, 0))
	    return FALSE;
d6477 1
a6477 1
write_glink_stub (struct plt_entry *ent, asection *plt_sec, unsigned char *p,
d6483 1
d6488 1
d7048 1
a7048 3
		  unsigned char *p = ((unsigned char *) htab->glink->contents
				      + ent->glink_offset);
		  write_glink_stub (ent, htab->iplt, p, info);
a8276 1
	    unsigned char *p;
d8282 1
a8282 23
	    p = (unsigned char *) htab->glink->contents + ent->glink_offset;

	    if (h == htab->tls_get_addr && !htab->no_tls_get_addr_opt)
	      {
		bfd_put_32 (output_bfd, LWZ_11_3, p);
		p += 4;
		bfd_put_32 (output_bfd, LWZ_12_3 + 4, p);
		p += 4;
		bfd_put_32 (output_bfd, MR_0_3, p);
		p += 4;
		bfd_put_32 (output_bfd, CMPWI_11_0, p);
		p += 4;
		bfd_put_32 (output_bfd, ADD_3_12_2, p);
		p += 4;
		bfd_put_32 (output_bfd, BEQLR, p);
		p += 4;
		bfd_put_32 (output_bfd, MR_3_0, p);
		p += 4;
		bfd_put_32 (output_bfd, NOP, p);
		p += 4;
	      }

	    write_glink_stub (ent, splt, p, info);
@


1.267.2.3
log
@	PR ld/11047
	* elf32-ppc.c (ppc_elf_relocate_section): Delete __tls_get_addr
	symbol reference from relocs belonging to calls that are
	optimized away.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
@
text
@d6917 3
a6919 1
		      rel[1].r_info = ELF32_R_INFO (STN_UNDEF, R_PPC_NONE);
d6993 2
a6994 1
	      rel[1].r_info = ELF32_R_INFO (STN_UNDEF, R_PPC_NONE);
d7023 2
a7024 1
	      rel[1].r_info = ELF32_R_INFO (STN_UNDEF, R_PPC_NONE);
@


1.267.2.4
log
@	PR ld/11088
include/elf/
	* ppc.h (R_PPC_RELAX32, R_PPC_RELAX32PC, R_PPC_RELAX32_PLT,
	R_PPC_RELAX32PC_PLT): Delete.
	(R_PPC_RELAX, R_PPC_RELAX_PLT, R_PPC_RELAX_PLTREL24): Define.
bfd/
	* elf32-ppc.c (update_plt_info): Clear sec here when addend is
	less than 32768..
	(ppc_elf_check_relocs): ..rather than doing so here.  Ignore new
	relax relocs.
	(ppc_elf_gc_sweep_hook): Don't segfault when symbol hiding has
	removed plt_entry records.
	(ppc_elf_tls_setup): Handle PIE calls to __tls_get_addr correctly.
	(ppc_elf_tls_optimize): Likewise.  Also dec __tls_get_addr refcount
	when optimizing code using new tlsgd and tlsld marker relocs.
	(ppc_elf_relax_section): Differentiate relaxed PLTREL24 relocs
	from ADDR24 relocs using plt or glink.  Don't clear the addend
	for R_PPC_RELAX_PLTREL24.
	(ppc_elf_relocate_section): Correctly handle addends on relaxed
	PLTREL24 relocs.
@
text
@a3325 2
  if (addend < 32768)
    sec = NULL;
d3511 2
a3512 1
		  if (!update_plt_info (abfd, ifunc, got2, addend))
d3751 2
a3752 1
	      if (!update_plt_info (abfd, &h->plt.plist, got2, addend))
d3783 4
a3786 3
	case R_PPC_RELAX:
	case R_PPC_RELAX_PLT:
	case R_PPC_RELAX_PLTREL24:
d4489 1
a4489 1
		  if (ent != NULL && ent->plt.refcount > 0)
d4537 1
a4537 1
	      if (ent != NULL && ent->plt.refcount > 0)
d4585 3
a4587 4
	      for (ent = tga->plt.plist; ent != NULL; ent = ent->next)
		if (ent->plt.refcount > 0)
		  break;
	      if (ent != NULL)
a4671 1
	asection *got2 = bfd_get_section_by_name (ibfd, ".got2");
a4764 7
		    case R_PPC_TLSGD:
		    case R_PPC_TLSLD:
		      expecting_tls_get_addr = 2;
		      tls_set = 0;
		      tls_clear = 0;
		      break;

d4772 1
a4772 2
			  || (expecting_tls_get_addr == 1
			      && !sec->has_tls_get_addr_call))
a4787 17
		  if (expecting_tls_get_addr)
		    {
		      struct plt_entry *ent;
		      bfd_vma addend = 0;

		      if (info->shared
			  && ELF32_R_TYPE (rel[1].r_info) == R_PPC_PLTREL24)
			addend = rel[1].r_addend;
		      ent = find_plt_ent (&htab->tls_get_addr->plt.plist,
					  got2, addend);
		      if (ent != NULL && ent->plt.refcount > 0)
			ent->plt.refcount -= 1;

		      if (expecting_tls_get_addr == 2)
			continue;
		    }

d4832 10
d6242 1
d6248 1
d6250 4
a6253 1
	  stub_rtype = R_PPC_RELAX;
d6256 1
a6256 5
	    {
	      stub_rtype = R_PPC_RELAX_PLT;
	      if (r_type == R_PPC_PLTREL24)
		stub_rtype = R_PPC_RELAX_PLTREL24;
	    }
d6263 1
a6263 2
	  if (r_type == R_PPC_PLTREL24
	      && stub_rtype != R_PPC_RELAX_PLTREL24)
d6433 1
a6433 1
	if (ELF32_R_TYPE (irel->r_info) == R_PPC_RELAX)
d7652 2
a7653 2
	case R_PPC_RELAX_PLT:
	case R_PPC_RELAX_PLTREL24:
d7656 2
a7657 10
	      struct plt_entry *ent;
	      bfd_vma got2_addend = 0;

	      if (r_type == R_PPC_RELAX_PLTREL24)
		{
		  if (info->shared)
		    got2_addend = addend;
		  addend = 0;
		}
	      ent = find_plt_ent (&h->plt.plist, got2, got2_addend);
d7667 2
d7671 5
a7675 5
	case R_PPC_RELAX:
	  if (info->shared)
	    relocation -= (input_section->output_section->vma
			   + input_section->output_offset
			   + rel->r_offset - 4);
d7677 2
@


1.267.2.5
log
@	Backport
	2009-12-11  Nick Clifton  <nickc@@redhat.com>
	* elf32-ppc.c: Fix shadowed variable warnings.
	* elf64-ppc.c: Likewise.

	2009-11-18  Alan Modra  <amodra@@bigpond.net.au>
	* bfd-in.h (_bfd_elf_ppc_at_tls_transform): Declare.
	* bfd-in2.h: Regenerate.
	* elf64-ppc.c (ppc64_elf_relocate_section): Move code for R_PPC64_TLS
	insn optimisation to..
	* elf32-ppc.c (_bfd_elf_ppc_at_tls_transform): ..here.  New function.
	(ppc_elf_relocate_section): Use it.
@
text
@d3963 1
a3963 1
	      struct ppc_elf_dyn_relocs **rel_head;
d3988 1
a3988 1
		  rel_head = &ppc_elf_hash_entry (h)->dyn_relocs;
d4009 1
a4009 1
		  rel_head = (struct ppc_elf_dyn_relocs **) vpp;
d4012 1
a4012 1
	      p = *rel_head;
d4018 2
a4019 2
		  p->next = *rel_head;
		  *rel_head = p;
a5637 1

d5681 1
a5681 1
		s = htab->iplt;
d6037 1
a6037 1
      bfd_vma toff, roff;
d6221 1
a6631 40
/* If INSN is an opcode that may be used with an @@tls operand, return
   the transformed insn for TLS optimisation, otherwise return 0.  If
   REG is non-zero only match an insn with RB or RA equal to REG.  */

unsigned int
_bfd_elf_ppc_at_tls_transform (unsigned int insn, unsigned int reg)
{
  unsigned int rtra;

  if ((insn & (0x3f << 26)) != 31 << 26)
    return 0;

  if (reg == 0 || ((insn >> 11) & 0x1f) == reg)
    rtra = insn & ((1 << 26) - (1 << 16));
  else if (((insn >> 16) & 0x1f) == reg)
    rtra = (insn & (0x1f << 21)) | ((insn & (0x1f << 11)) << 5);
  else
    return 0;

  if ((insn & (0x3ff << 1)) == 266 << 1)
    /* add -> addi.  */
    insn = 14 << 26;
  else if ((insn & (0x1f << 1)) == 23 << 1
	   && ((insn & (0x1f << 6)) < 14 << 6
	       || ((insn & (0x1f << 6)) >= 16 << 6
		   && (insn & (0x1f << 6)) < 24 << 6)))
    /* load and store indexed -> dform.  */
    insn = (32 | ((insn >> 6) & 0x1f)) << 26;
  else if ((insn & (((0x1a << 5) | 0x1f) << 1)) == 21 << 1)
    /* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
    insn = ((58 | ((insn >> 6) & 4)) << 26) | ((insn >> 6) & 1);
  else if ((insn & (((0x1f << 5) | 0x1f) << 1)) == 341 << 1)
    /* lwax -> lwa.  */
    insn = (58 << 26) | 2;
  else
    return 0;
  insn |= rtra;
  return insn;
}

d6677 1
d6721 1
a6721 1
      bfd_vma branch_bit, from;
a6818 1

d6832 1
a6832 2
	      bfd_vma insn;

d6834 27
a6860 2
	      insn = _bfd_elf_ppc_at_tls_transform (insn, 2);
	      if (insn == 0)
d6862 1
d7059 11
a7069 2
	  {
	    bfd_vma insn;
d7071 2
a7072 15
	    insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	    insn &= ~BRANCH_PREDICT_BIT;
	    insn |= branch_bit;

	    from = (rel->r_offset
		    + input_section->output_offset
		    + input_section->output_section->vma);

	    /* Invert 'y' bit if not the default.  */
	    if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
	      insn ^= BRANCH_PREDICT_BIT;

	    bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	    break;
	  }
a7302 1
			bfd_byte * loc;
d7534 1
a7534 1
	      bfd_byte * loc;
d7928 1
a7928 3
	      {
		bfd_vma insn;  /* Fill in register field.  */

@


1.267.2.6
log
@	PR ld/11217
	* elf64-ppc.c (ppc64_elf_tls_optimize): Optimize tls sequences
	with relocations against undefined weak symbols.
	(ppc64_elf_relocate_section): Don't optimize calls to undefined
	weak functions if the symbol is dynamic.
	(ppc64_elf_relocate_section): Edit tprel tls sequences.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(_bfd_elf_ppc_at_tprel_transform): New function.
	* bfd-in.h (_bfd_elf_ppc_at_tprel_transform): Declare.
	* bfd-in2.h: Regenerate.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
a6671 45
/* If INSN is an opcode that may be used with an @@tprel operand, return
   the transformed insn for an undefined weak symbol, ie. with the
   thread pointer REG operand removed.  Otherwise return 0.  */

unsigned int
_bfd_elf_ppc_at_tprel_transform (unsigned int insn, unsigned int reg)
{
  if ((insn & (0x1f << 16)) == reg << 16
      && ((insn & (0x3f << 26)) == 14u << 26 /* addi */
	  || (insn & (0x3f << 26)) == 15u << 26 /* addis */
	  || (insn & (0x3f << 26)) == 32u << 26 /* lwz */
	  || (insn & (0x3f << 26)) == 34u << 26 /* lbz */
	  || (insn & (0x3f << 26)) == 36u << 26 /* stw */
	  || (insn & (0x3f << 26)) == 38u << 26 /* stb */
	  || (insn & (0x3f << 26)) == 40u << 26 /* lhz */
	  || (insn & (0x3f << 26)) == 42u << 26 /* lha */
	  || (insn & (0x3f << 26)) == 44u << 26 /* sth */
	  || (insn & (0x3f << 26)) == 46u << 26 /* lmw */
	  || (insn & (0x3f << 26)) == 47u << 26 /* stmw */
	  || (insn & (0x3f << 26)) == 48u << 26 /* lfs */
	  || (insn & (0x3f << 26)) == 50u << 26 /* lfd */
	  || (insn & (0x3f << 26)) == 52u << 26 /* stfs */
	  || (insn & (0x3f << 26)) == 54u << 26 /* stfd */
	  || ((insn & (0x3f << 26)) == 58u << 26 /* lwa,ld,lmd */
	      && (insn & 3) != 1)
	  || ((insn & (0x3f << 26)) == 62u << 26 /* std, stmd */
	      && ((insn & 3) == 0 || (insn & 3) == 3))))
    {
      insn &= ~(0x1f << 16);
    }
  else if ((insn & (0x1f << 21)) == reg << 21
	   && ((insn & (0x3e << 26)) == 24u << 26 /* ori, oris */
	       || (insn & (0x3e << 26)) == 26u << 26 /* xori,xoris */
	       || (insn & (0x3e << 26)) == 28u << 26 /* andi,andis */))
    {
      insn &= ~(0x1f << 21);
      insn |= (insn & (0x1f << 16)) << 5;
      if ((insn & (0x3e << 26)) == 26 << 26 /* xori,xoris */)
	insn -= 2 >> 26;  /* convert to ori,oris */
    }
  else
    insn = 0;
  return insn;
}

a7473 15
	  if (h != NULL
	      && h->root.type == bfd_link_hash_undefweak
	      && h->dynindx == -1)
	    {
	      /* Make this relocation against an undefined weak symbol
		 resolve to zero.  This is really just a tweak, since
		 code using weak externs ought to check that they are
		 defined before using them.  */
	      bfd_byte *p = contents + rel->r_offset - d_offset;
	      unsigned int insn = bfd_get_32 (output_bfd, p);
	      insn = _bfd_elf_ppc_at_tprel_transform (insn, 2);
	      if (insn != 0)
		bfd_put_32 (output_bfd, insn, p);
	      break;
	    }
@


1.266
log
@	* elf32-ppc.c (ppc_elf_relax_section): Ignore non-code sections.
@
text
@d5860 2
d5866 3
a5868 3
    0x7d6802a6, /* mflr 11 */
    0x3d6b0000, /* addis 11, 11, (xxx-.Lxxx)@@ha */
    0x396b0018, /* addi 11, 11, (xxx-.Lxxx)@@l */
d5870 1
a5870 1
    0x7d6903a6, /* mtctr 11 */
d5876 3
a5878 3
    0x3d600000, /* lis 11,xxx@@ha */
    0x396b0000, /* addi 11,11,xxx@@l */
    0x7d6903a6, /* mtctr 11 */
d5892 2
d5944 1
a5944 1
      bfd_vma symaddr, reladdr, toff, roff;
d6026 1
a6026 1
	      toff = 0;
a6126 2
      symaddr = tsec->output_section->vma + tsec->output_offset + toff;

d6135 9
a6143 3
	      || tsec->output_section == isec->output_section)
	  && symaddr - reladdr + max_branch_offset < 2 * max_branch_offset)
	continue;
@


1.265
log
@	* elflink.c (_bfd_elf_adjust_dynamic_symbol): Don't clear plt
	info for STT_GNU_IFUNC.
	* elf32-ppc.c (ppc_elf_check_relocs): Count a needed plt entry
	on got refs in case the symbol turns out to be ifunc.
	(ppc_elf_gc_sweep_hook): Similarly.
	(ppc_elf_adjust_dynamic_symbol): Adjust assertion.
	(allocate_dynrelocs): Don't specially allocate got relocs for ifunc.
	(ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relocate_section): Likewise.
@
text
@d5908 1
a5908 1
     anything with non-alloc sections.  */
d5910 1
@


1.264
log
@	* elf32-ppc.c (ppc_elf_relax_section): Correct conditions under
	which find_plt_ent is called.  Delete redundant code.
@
text
@d3583 8
d4476 8
d4846 1
a5308 1
	  asection *rsec = NULL;
a5314 4
	    rsec = htab->relgot;
	  else if (h->type == STT_GNU_IFUNC)
	    rsec = htab->reliplt;
	  if (rsec != NULL)
d5316 1
a5586 3
		else if ((*lgot_masks & PLT_IFUNC) != 0)
		  htab->reliplt->size += (need
					  * (sizeof (Elf32_External_Rela) / 4));
a7149 1
		asection *rsec;
a7187 1
		    rsec = NULL;
a7192 4
		      rsec = htab->relgot;
		    else if (ifunc != NULL)
		      rsec = htab->reliplt;
		    if (rsec != NULL)
d7194 2
@


1.263
log
@	* elf32-ppc.c (struct plt_entry): Revise comments.
	(ppc_elf_check_relocs): Don't create needless plt_entry info
	for non-pie executables.  Don't test info->pie when info->shared
	already covers that case.
	(ppc_elf_gc_sweep_hook): Adjust for above change.
	(add_stub_sym): Don't test info->pie when info->shared tested.
	(allocate_dynrelocs, ppc_elf_size_dynamic_sections): Likewise.
	(write_glink_stub, ppc_elf_finish_dynamic_symbol): Likewise.
	(ppc_elf_relax_section): Adjust find_plt_ent arguments.
	(ppc_elf_relocate_section): Likewise.
@
text
@d5937 1
d6001 2
a6002 6
	  tsec = NULL;
	  toff = 0;
	  if (tsec != NULL)
	    ;
	  else if (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
d6019 21
a6039 1
      if (is_branch_reloc (r_type))
d6041 2
a6042 1
	  struct plt_entry **plist = NULL;
d6044 4
a6047 3
	  if (h != NULL)
	    plist = &h->plt.plist;
	  else if (sym_type == STT_GNU_IFUNC)
d6049 9
a6057 14
	      bfd_vma *local_got_offsets = elf_local_got_offsets (abfd);
	      struct plt_entry **local_plt = (struct plt_entry **)
		(local_got_offsets + symtab_hdr->sh_info);
	      plist = local_plt + ELF32_R_SYM (irel->r_info);
	    }
	  if (plist != NULL)
	    {
	      bfd_vma addend = 0;
	      struct plt_entry *ent;

	      if (r_type == R_PPC_PLTREL24 && link_info->shared)
		addend = irel->r_addend;
	      ent = find_plt_ent (plist, got2, addend);
	      if (ent != NULL)
d6059 2
a6060 13
		  if (htab->plt_type == PLT_NEW
		      || h == NULL
		      || !htab->elf.dynamic_sections_created
		      || h->dynindx == -1)
		    {
		      tsec = htab->glink;
		      toff = ent->glink_offset;
		    }
		  else
		    {
		      tsec = htab->plt;
		      toff = ent->plt.offset;
		    }
@


1.262
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Always add a plt ref count
	for local ifunc symbols in non-pie executables, regardless of
	reloc type.  Don't specially create ifunc dyn relocs.  Tidy ifunc
	code so that it's obvious that we only do anything special for
	local ifunc syms.
	(ppc_elf_gc_sweep_hook): Adjust to suit check_relocs changes.
	(allocate_dynrelocs): Correct comment for syms defined in plt.
	Don't specially allocate ifunc dyn relocs.
	(ppc_elf_relax_section): Relax branches to ifunc plt entries too.
	(ppc_elf_relocate_section): Set "relocation" value for ifunc
	syms in non-pie executables.  No specially allocated dyn relocs
	for ifunc to write.  Allow for local sym on R_PPC_RELAX32_PLT.
	(ppc_elf_finish_dynamic_symbol): Set value of ifunc symbols in
	a non-pie executable.
@
text
@d2608 1
a2608 1
   than one glink entry per symbol.  */
d2615 3
a2617 2
     GOT pointer reg.  It will always be at least 32768 (and for
     current gcc this is the only offset used).  */
d3495 2
a3496 1
		      addend = rel->r_addend;
d3731 2
a3732 1
		  addend = rel->r_addend;
d3834 1
a3834 1
	      && (info->shared || info->pie)
d4430 6
a4435 2
	      bfd_vma addend = r_type == R_PPC_PLTREL24 ? rel->r_addend : 0;
	      struct plt_entry *ent = find_plt_ent (ifunc, got2, addend);
d4507 6
a4512 3
	      bfd_vma addend = r_type == R_PPC_PLTREL24 ? rel->r_addend : 0;
	      struct plt_entry *ent = find_plt_ent (&h->plt.plist,
						    got2, addend);
d4997 1
a4997 1
  if (info->shared || info->pie)
d5129 1
a5129 1
		    if (!doneone || info->shared || info->pie)
d5605 1
a5605 1
		if (!doneone || info->shared || info->pie)
d6040 1
a6040 1
	      if (r_type == R_PPC_PLTREL24)
d6460 1
a6460 1
  if (info->shared || info->pie)
d6982 1
a6982 1
	      if (r_type == R_PPC_PLTREL24)
d7556 1
a7556 1
						    addend);
d7649 2
a7650 2
	    struct plt_entry *ent = find_plt_ent (&h->plt.plist, got2, addend);

d8222 1
a8222 1
	    if (!info->shared && !info->pie)
d8629 1
a8629 1
      if (info->shared || info->pie)
@


1.261
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Always set up sections
	used by indirect function support.  Count dynamic relocs for
	ifunc syms.
	(ppc_elf_adjust_dynamic_symbol): Tweak for ifunc.
	(allocate_dynrelocs): Allocate all non-dynamic ifunc plt entries
	in iplt and their relocs in reliplt.  Don't make ifunc syms
	dynamic.  Allocate got entry relocs for non-dynamic ifunc in
	reliplt.  Handle other dynamic relocs for ifunc.
	(ppc_elf_size_dynamic_sections): Alloc dyn relocs for static
	ifunc in reliplt, likewise relocs for got against local ifunc.
	Typo fix on reliplt size adjust.
	(ppc_elf_relocate_section): Don't use plt scheme of allocating
	relocs 1-1 with entries for iplt, instead just add using
	reloc_count.  Write got relocs and dyn relocs for ifunc to reliplt.
	Error on invalid ifunc dyn relocs.
	(ppc_elf_finish_dynamic_symbol): Adjust for non-dynamic ifunc plt
	in iplt/reliplt.
	* elf64-ppc.c (ppc64_elf_howto_raw): Add R_PPC64_JMP_IREL,
	R_PPC64_REL16, R_PPC64_REL16_LO, R_PPC64_REL16_HI, R_PPC64_REL16_HA.
	(ppc64_elf_reloc_type_lookup): Handle new relocs.
	(ppc64_elf_check_relocs): Likewise.  Count dyn relocs for ifunc.
	(allocate_dynrelocs): As for elf32-ppc.c above.
	(ppc64_elf_size_dynamic_sections): Likewise.
	(ppc_build_one_stub): Put non-dynamic ifunc plt call stubs in iplt,
	and their relocs in reliplt.  Use R_PPC64_JMP_IREL.
	(ppc_size_one_stub): Similarly.
	(ppc64_elf_relocate_section): As for elf32-ppc.c above.  Handle new
	relocs too.
	(ppc64_elf_finish_dynamic_symbol): As for elf32-ppc.c above.
@
text
@d3461 1
d3467 1
a3467 4
		{
		  h->needs_plt = 1;
		  ifunc = &h->plt.plist;
		}
d3476 3
a3478 1
	      if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
d3480 2
d3486 13
d3503 14
a3516 30
      r_type = ELF32_R_TYPE (rel->r_info);
      if (!htab->is_vxworks && is_branch_reloc (r_type))
	{
	  if (h != NULL && h == tga)
	    {
	      if (rel != relocs
		  && (ELF32_R_TYPE (rel[-1].r_info) == R_PPC_TLSGD
		      || ELF32_R_TYPE (rel[-1].r_info) == R_PPC_TLSLD))
		/* We have a new-style __tls_get_addr call with a marker
		   reloc.  */
		;
	      else
		/* Mark this section as having an old-style call.  */
		sec->has_tls_get_addr_call = 1;
	    }

	  /* STT_GNU_IFUNC symbols must have a PLT entry.  */
	  if (ifunc != NULL)
	    {
	      bfd_vma addend = 0;

	      if (r_type == R_PPC_PLTREL24)
		{
		  ppc_elf_tdata (abfd)->makes_plt_call = 1;
		  addend = rel->r_addend;
		}
	      if (!update_plt_info (abfd, ifunc,
				    addend < 32768 ? NULL : got2, addend))
		return FALSE;
	    }
d3692 1
a3692 1
	  if (h == NULL || ifunc != NULL)
d3905 1
a3905 2
	      if (ifunc == NULL
		  && !update_plt_info (abfd, &h->plt.plist, NULL, 0))
d3942 1
a3942 3
		      || !h->def_regular))
	      || (!info->shared
		  && ifunc != NULL))
d4414 11
a4424 18
      if (!htab->is_vxworks && is_branch_reloc (r_type))
	{
	  struct plt_entry **ifunc = NULL;
	  if (h != NULL)
	    {
	      if (h->type == STT_GNU_IFUNC)
		ifunc = &h->plt.plist;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      struct plt_entry **local_plt = (struct plt_entry **)
		(local_got_refcounts + symtab_hdr->sh_info);
	      char *local_got_tls_masks = (char *)
		(local_plt + symtab_hdr->sh_info);
	      if ((local_got_tls_masks[r_symndx] & PLT_IFUNC) != 0)
		ifunc = local_plt + r_symndx;
	    }
	  if (ifunc != NULL)
d4426 1
d5159 3
a5161 2
			   library, then set the symbol to this location
			   in the .plt.  This is required to make
d5307 1
a5307 2
      || (!htab->elf.dynamic_sections_created
	  && h->type != STT_GNU_IFUNC))
a5377 5
  else if (h->type == STT_GNU_IFUNC)
    {
      if (!h->non_got_ref)
	eh->dyn_relocs = NULL;
    }
d5926 1
d5948 1
a5981 1
	  struct elf_link_hash_entry *h;
a5991 20
	  if (r_type == R_PPC_PLTREL24
	      && htab->plt != NULL)
	    {
	      struct plt_entry *ent = find_plt_ent (&h->plt.plist,
						    got2, irel->r_addend);

	      if (ent != NULL)
		{
		  if (htab->plt_type == PLT_NEW)
		    {
		      tsec = htab->glink;
		      toff = ent->glink_offset;
		    }
		  else
		    {
		      tsec = htab->plt;
		      toff = ent->plt.offset;
		    }
		}
	    }
d6012 40
d6949 2
d6956 2
a6957 1
	  else if (local_got_offsets != NULL)
d6959 6
a6964 4
	      if (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
		{
		  struct plt_entry **local_plt = (struct plt_entry **)
		    (local_got_offsets + symtab_hdr->sh_info);
d6966 9
a6974 2
		  ifunc = local_plt + r_symndx;
		}
d6976 1
a6976 1
	  if (ifunc != NULL && is_branch_reloc (r_type))
a6977 2
	      struct plt_entry *ent = find_plt_ent (ifunc, got2, rel->r_addend);

d7404 1
a7404 3
		  && !h->def_regular)
	      || (!info->shared
		  && ifunc != NULL))
d7543 13
a7555 12
	  {
	    struct plt_entry *ent = find_plt_ent (&h->plt.plist, got2, addend);

	    if (htab->plt_type == PLT_NEW)
	      relocation = (htab->glink->output_section->vma
			    + htab->glink->output_offset
			    + ent->glink_offset);
	    else
	      relocation = (htab->plt->output_section->vma
			    + htab->plt->output_offset
			    + ent->plt.offset);
	  }
d8182 16
@


1.260
log
@STT_GNU_IFUNC support for PowerPC.
@
text
@d3411 7
d3461 1
a3461 2
      r_type = ELF32_R_TYPE (rel->r_info);
      if (!htab->is_vxworks && is_branch_reloc (r_type))
a3462 14
	  if (h != NULL && h == tga)
	    {
	      if (rel != relocs
		  && (ELF32_R_TYPE (rel[-1].r_info) == R_PPC_TLSGD
		      || ELF32_R_TYPE (rel[-1].r_info) == R_PPC_TLSLD))
		/* We have a new-style __tls_get_addr call with a marker
		   reloc.  */
		;
	      else
		/* Mark this section as having an old-style call.  */
		sec->has_tls_get_addr_call = 1;
	    }

	  /* STT_GNU_IFUNC symbols must have a PLT entry.  */
d3486 19
a3516 8

	      if (htab->glink == NULL)
		{
		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;
		  if (!ppc_elf_create_glink (htab->elf.dynobj, info))
		    return FALSE;
		}
d3944 3
a3946 1
		      || !h->def_regular)))
d4867 4
a4870 2
	  /* After adjust_dynamic_symbol, non_got_ref set means that
	     dyn_relocs for this symbol should be discarded.
d4878 1
d5116 1
a5116 1
		if (!dyn)
d5119 1
a5119 1
		if (htab->plt_type == PLT_NEW || !dyn)
d5197 2
a5198 1
		    if (!htab->elf.dynamic_sections_created)
d5258 1
a5258 1
	  && !eh->elf.def_regular
d5291 1
d5298 4
d5308 1
a5308 1
	      htab->relgot->size += need * (sizeof (Elf32_External_Rela) / 4);
d5316 2
a5317 1
      || !htab->elf.dynamic_sections_created)
d5388 5
d5405 1
a5405 2
	      && !h->forced_local
	      && !h->def_regular)
d5426 2
d5532 4
a5535 2
		  elf_section_data (p->sec)->sreloc->size
		    += p->count * sizeof (Elf32_External_Rela);
d5579 3
d5619 1
a5619 1
		    htab->reliplt += sizeof (Elf32_External_Rela);
d6941 1
a6941 1
      if (!htab->is_vxworks && is_branch_reloc (r_type))
d6958 1
a6958 1
	  if (ifunc != NULL)
d6972 3
a6974 2
		  loc = (htab->reliplt->contents
			 + ent->plt.offset * sizeof (Elf32_External_Rela) / 4);
d7111 1
d7150 1
d7156 4
d7170 2
a7171 2
				loc = htab->relgot->contents;
				loc += (htab->relgot->reloc_count++
d7184 4
a7187 2
			else if (indx == 0)
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_RELATIVE);
d7189 1
a7189 1
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_GLOB_DAT);
d7196 2
a7197 2
			loc = htab->relgot->contents;
			loc += (htab->relgot->reloc_count++
d7388 3
a7390 1
		  && !h->def_regular))
d7406 3
a7408 2
		  sreloc = _bfd_elf_get_dynamic_reloc_section
		    (input_bfd, input_section, /*rela?*/ TRUE);
d7438 1
a7438 3
		  if (r_type == R_PPC_ADDR32)
		    outrel.r_info = ELF32_R_INFO (0, R_PPC_RELATIVE);
		  else
d7442 25
a7466 1
		      if (r_symndx == 0 || bfd_is_abs_section (sec))
d7481 2
a7482 1
			     but ld.so expects buggy relocs.  */
d7501 4
d7959 2
a7960 1
		|| !htab->elf.dynamic_sections_created)
d7974 2
a7975 1
		&& htab->elf.dynamic_sections_created)
d8098 2
a8099 1
		if (!htab->elf.dynamic_sections_created)
d8106 2
a8107 1
		    || !htab->elf.dynamic_sections_created)
d8137 5
a8141 2
	    if (!htab->elf.dynamic_sections_created)
	      loc = htab->reliplt->contents;
d8143 2
a8144 2
	      loc = htab->relplt->contents;
	    loc += reloc_index * sizeof (Elf32_External_Rela);
d8171 2
a8172 1
	    || !htab->elf.dynamic_sections_created)
d8175 2
a8176 1
	    if (!htab->elf.dynamic_sections_created)
@


1.259
log
@include/elf/
	* ppc.h (R_PPC_RELAX*): Define as enum.
bfd/
	* elf32-ppc.c (ppc_elf_check_relocs): Handle R_PPC_RELAX* in switch.
	* elf32-v850.c (v850_elf_relocate_section): Warning fix.
@
text
@d1385 14
d2503 5
a2507 1
    size += strlen ((*p->sym_ptr_ptr)->name) + sizeof ("@@plt");
d2537 7
d2693 1
d2715 2
d2883 32
d2935 2
a2936 7
  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_HAS_CONTENTS
	   | SEC_IN_MEMORY | SEC_LINKER_CREATED);

  s = bfd_make_section_anyway_with_flags (abfd, ".glink", flags | SEC_CODE);
  htab->glink = s;
  if (s == NULL
      || !bfd_set_section_alignment (abfd, s, 4))
d2949 2
d3124 3
d3275 1
a3275 1
static bfd_boolean
d3282 1
d3289 3
a3291 1
      size *= sizeof (*local_got_refcounts) + sizeof (*local_got_tls_masks);
d3294 1
a3294 1
	return FALSE;
d3298 2
a3299 2
  local_got_refcounts[r_symndx] += 1;
  local_got_tls_masks = (char *) (local_got_refcounts + symtab_hdr->sh_info);
d3301 3
a3303 1
  return TRUE;
d3344 15
d3425 1
d3453 1
d3455 51
a3505 5
      if (h != NULL && h == tga)
	switch (r_type)
	  {
	  default:
	    break;
d3507 9
a3515 21
	  case R_PPC_PLTREL24:
	  case R_PPC_LOCAL24PC:
	  case R_PPC_REL24:
	  case R_PPC_REL14:
	  case R_PPC_REL14_BRTAKEN:
	  case R_PPC_REL14_BRNTAKEN:
	  case R_PPC_ADDR24:
	  case R_PPC_ADDR14:
	  case R_PPC_ADDR14_BRTAKEN:
	  case R_PPC_ADDR14_BRNTAKEN:
	    if (rel != relocs
		&& (ELF32_R_TYPE (rel[-1].r_info) == R_PPC_TLSGD
		    || ELF32_R_TYPE (rel[-1].r_info) == R_PPC_TLSLD))
	      /* We have a new-style __tls_get_addr call with a marker
		 reloc.  */
	      ;
	    else
	      /* Mark this section as having an old-style call.  */
	      sec->has_tls_get_addr_call = 1;
	    break;
	  }
d3690 1
a3690 1
	  if (h == NULL)
d3773 1
d3902 3
a3904 1
	      if (!update_plt_info (abfd, &h->plt.plist, NULL, 0))
d4413 27
d4554 1
a4554 11
  if (r_symndx >= symtab_hdr->sh_info
      && (r_type == R_PPC_PLTREL24
	  || r_type == R_PPC_LOCAL24PC
	  || r_type == R_PPC_REL14
	  || r_type == R_PPC_REL14_BRTAKEN
	  || r_type == R_PPC_REL14_BRNTAKEN
	  || r_type == R_PPC_REL24
	  || r_type == R_PPC_ADDR24
	  || r_type == R_PPC_ADDR14
	  || r_type == R_PPC_ADDR14_BRTAKEN
	  || r_type == R_PPC_ADDR14_BRNTAKEN))
d4719 1
d4740 3
a4742 1
		      lgot_masks = (char *) (lgot_refs + symtab_hdr->sh_info);
d4832 1
d4842 4
a4845 3
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d5081 2
a5082 1
  if (htab->elf.dynamic_sections_created)
d5087 1
d5094 3
a5096 1
		&& !h->forced_local)
d5102 1
d5104 2
a5105 1
		|| WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d5108 2
d5111 1
a5111 1
		if (htab->plt_type == PLT_NEW)
d5189 5
a5193 1
		    htab->relplt->size += sizeof (Elf32_External_Rela);
d5195 1
a5195 4
		    if (htab->plt_type == PLT_VXWORKS)
		      {
			/* Allocate space for the unloaded relocations.  */
			if (!info->shared)
d5197 3
a5199 2
			    if (ent->plt.offset
				== (bfd_vma) htab->plt_initial_entry_size)
d5201 8
d5210 2
a5211 2
				  += sizeof (Elf32_External_Rela)
				      * VXWORKS_PLTRESOLVE_RELOCS;
d5214 3
a5216 3
			    htab->srelplt2->size
			      += sizeof (Elf32_External_Rela)
				  * VXWORKS_PLT_NON_JMP_SLOT_RELOCS;
a5217 4

			/* Every PLT entry has an associated GOT entry in
			   .got.plt.  */
			htab->sgotplt->size += 4;
d5249 1
d5365 2
a5366 1
		   && !h->forced_local)
d5385 2
a5386 1
	      && !h->forced_local)
d5476 2
d5528 3
a5530 1
      lgot_masks = (char *) end_local_got;
d5560 40
d5633 3
a5635 1
  if (htab->glink != NULL && htab->glink->size != 0)
d5691 1
a5691 6
	  || s == htab->glink
	  || s == htab->got
	  || s == htab->sgotplt
	  || s == htab->sbss
	  || s == htab->dynbss
	  || s == htab->dynsbss)
d5696 1
a5696 1
	  if ((s == htab->plt || s == htab->got) && htab->elf.hplt != NULL)
d5701 7
a5707 1
      else if (s == htab->sdata[0].section
d6400 67
d6560 1
d6625 1
d6627 3
a6629 1
	  lgot_masks = (char *) (local_got_offsets + symtab_hdr->sh_info);
d6650 1
a6650 1
	  if (tls_mask != 0
d6664 1
a6664 1
	  if (tls_mask != 0
d6711 1
a6711 1
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
d6717 1
a6717 1
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
d6736 1
a6736 1
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
d6742 1
a6742 1
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
d6822 1
a6822 1
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
d6850 1
a6850 1
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
d6914 58
d7554 1
a7554 1
	  if (h == NULL)
d7726 1
a7861 4
#define PPC_LO(v) ((v) & 0xffff)
#define PPC_HI(v) (((v) >> 16) & 0xffff)
#define PPC_HA(v) PPC_HI ((v) + 0x8000)

d7893 2
a7894 1
	    if (htab->plt_type == PLT_NEW)
d7907 2
a7908 1
	    if (htab->plt_type == PLT_VXWORKS)
d8030 6
a8035 2
		rela.r_offset = (htab->plt->output_section->vma
				 + htab->plt->output_offset
d8037 2
a8038 1
		if (htab->plt_type == PLT_OLD)
d8049 1
a8049 1
				htab->plt->contents + ent->plt.offset);
a8053 1
	    rela.r_info = ELF32_R_INFO (h->dynindx, R_PPC_JMP_SLOT);
d8055 12
d8068 5
a8072 2
	    loc = (htab->relplt->contents
		   + reloc_index * sizeof (Elf32_External_Rela));
d8098 2
a8099 1
	if (htab->plt_type == PLT_NEW)
d8101 3
a8103 2
	    bfd_vma plt;
	    unsigned char *p;
d8105 1
a8105 4
	    plt = (ent->plt.offset
		   + htab->plt->output_section->vma
		   + htab->plt->output_offset);
	    p = (unsigned char *) htab->glink->contents + ent->glink_offset;
d8107 3
a8109 50
	    if (info->shared || info->pie)
	      {
		bfd_vma got = 0;

		if (ent->addend >= 32768)
		  got = (ent->addend
			 + ent->sec->output_section->vma
			 + ent->sec->output_offset);
		else if (htab->elf.hgot != NULL)
		  got = SYM_VAL (htab->elf.hgot);

		plt -= got;

		if (plt + 0x8000 < 0x10000)
		  {
		    bfd_put_32 (output_bfd, LWZ_11_30 + PPC_LO (plt), p);
		    p += 4;
		    bfd_put_32 (output_bfd, MTCTR_11, p);
		    p += 4;
		    bfd_put_32 (output_bfd, BCTR, p);
		    p += 4;
		    bfd_put_32 (output_bfd, NOP, p);
		    p += 4;
		  }
		else
		  {
		    bfd_put_32 (output_bfd, ADDIS_11_30 + PPC_HA (plt), p);
		    p += 4;
		    bfd_put_32 (output_bfd, LWZ_11_11 + PPC_LO (plt), p);
		    p += 4;
		    bfd_put_32 (output_bfd, MTCTR_11, p);
		    p += 4;
		    bfd_put_32 (output_bfd, BCTR, p);
		    p += 4;
		  }
	      }
	    else
	      {
		bfd_put_32 (output_bfd, LIS_11 + PPC_HA (plt), p);
		p += 4;
		bfd_put_32 (output_bfd, LWZ_11_11 + PPC_LO (plt), p);
		p += 4;
		bfd_put_32 (output_bfd, MTCTR_11, p);
		p += 4;
		bfd_put_32 (output_bfd, BCTR, p);
		p += 4;

		/* We only need one non-PIC glink stub.  */
		break;
	      }
d8380 3
a8382 1
  if (htab->glink != NULL && htab->glink->contents != NULL)
d8649 1
d8759 1
@


1.258
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Allow local symbols for
	R_PPC_PLTREL24 relocs.
	(ppc_elf_relocate_section): Likewise.
@
text
@d3646 4
@


1.257
log
@	* elf32-ppc.c (find_plt_ent): Pass pointer to plist rather than
	pointer to sym hash.  Update all uses.
	(update_plt_info): Likewise.  Don't check addend here.
@
text
@d3573 4
a3577 1
	case R_PPC_PLTREL24:
d7216 2
@


1.256
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d3242 1
a3242 1
update_plt_info (bfd *abfd, struct elf_link_hash_entry *h,
d3247 1
a3247 3
  if (addend < 32768)
    sec = NULL;
  for (ent = h->plt.plist; ent != NULL; ent = ent->next)
d3256 1
a3256 1
      ent->next = h->plt.plist;
d3260 1
a3260 1
      h->plt.plist = ent;
d3267 1
a3267 1
find_plt_ent (struct elf_link_hash_entry *h, asection *sec, bfd_vma addend)
d3273 1
a3273 1
  for (ent = h->plt.plist; ent != NULL; ent = ent->next)
d3611 2
a3612 1
	      if (!update_plt_info (abfd, h, got2, addend))
d3744 1
a3744 1
	      if (!update_plt_info (abfd, h, NULL, 0))
d3778 1
a3778 1
	      if (!update_plt_info (abfd, h, NULL, 0))
d4353 2
a4354 1
	      struct plt_entry *ent = find_plt_ent (h, got2, addend);
d4612 2
a4613 1
		      ent = find_plt_ent (htab->tls_get_addr, NULL, 0);
d5771 2
a5772 1
	      struct plt_entry *ent = find_plt_ent (h, got2, irel->r_addend);
d7124 1
a7124 1
	    struct plt_entry *ent = find_plt_ent (h, got2, addend);
d7216 1
a7216 1
	    struct plt_entry *ent = find_plt_ent (h, got2, addend);
@


1.255
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.c (create_got_section): Get existing .rela.got
	section.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	* elf32-lm32.c (create_got_section): Likewise.
	* elf32-m32r.c (create_got_section): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.

	* elflink.c (_bfd_elf_create_got_section): Properly initialize
	the GOT size.
@
text
@d2738 2
a2739 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d3716 1
d3718 6
a3723 2
	      s = bfd_section_from_r_symndx (abfd, &htab->sym_sec, sec,
					     r_symndx);
a3850 1

d3853 1
d3855 6
a3860 2
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
d3862 1
a3862 1
		    return FALSE;
@


1.254
log
@	bfd/
	* elf32-ppc.c (ppc_elf_relax_section): Work with a partial
	link.
	* bout.c (b_out_bfd_relax_section): Reject relocatable links.
	* elf32-m10300.c (mn10300_elf_relax_section): Likewise.
	* elf32-avr.c (elf32_avr_relax_section): Likewise.
	* elf32-frv.c (elf32_avr_relax_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relax_section): Likewise.
	* elf64-mmix.c (mmix_elf_relax_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relax_section): Likewise.
	* reloc.c (bfd_generic_relax_section): Likewise.
	* reloc16.c (bfd_coff_reloc16_relax_section): Likewise.
	* vms.c (vms_bfd_relax_section): Likewise.

	ld/
	* ldmain.c (main): Don't reject --relax -r.
	* ld.texinfo (PowerPC ELF32): Document behaviour of relaxing
	partial links.

	ld/testsuite/
	* ld-powerpc/vxworks-relax-2.s: New.
	* ld-powerpc/vxworks-relax-2.rd: New.
	* ld-powerpc/powerpc.exp: Add it.
@
text
@d2848 3
a2850 6
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED | SEC_READONLY);
  htab->relgot = bfd_make_section_with_flags (abfd, ".rela.got", flags);
  if (!htab->relgot
      || ! bfd_set_section_alignment (abfd, htab->relgot, 2))
    return FALSE;
@


1.253
log
@	* elf32-ppc.c (is_pic_glink_stub): Delete.
	(is_nonpic_glink_stub): New function.
	(ppc_elf_get_synthetic_symtab): Check for last non-pic stub rather
	than first pic one.
	(struct ppc_elf_link_hash_table <glink_pltresolve>): Comment fix.
@
text
@d5664 6
d5735 1
a5735 1
	    continue;	/* We can't do anything with undefined symbols.  */
d5788 6
d5853 6
a5858 1
      if (symaddr - reladdr + max_branch_offset < 2 * max_branch_offset)
d6068 21
@


1.252
log
@include/elf/
	* ppc.h (R_PPC_TLSGD, R_PPC_TLSLD): Add new relocs.
	* ppc64.h (R_PPC64_TLSGD, R_PPC64_TLSLD): Add new relocs.
bfd/
	* reloc.c (BFD_RELOC_PPC_TLSGD, BFD_RELOC_PPC_TLSLD): New.
	* section.c (struct bfd_section): Add has_tls_get_addr_call.
	(BFD_FAKE_SECTION): Init new flag.
	* ecoff.c (bfd_debug_section): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* elf32-ppc.c (ppc_elf_howto_raw): Add R_PPC_TLSGD and R_PPC_TLSLD.
	(ppc_elf_reloc_type_lookup): Handle new relocs.
	(ppc_elf_check_relocs): Set has_tls_get_addr_call on finding such
	without marker relocs.
	(ppc_elf_tls_optimize): Allow out-of-order __tls_get_addr relocs
	if section has no old-style calls.
	(ppc_elf_relocate_section): Set tls_mask for non-tls relocs too.
	Don't try to optimize new-style __tls_get_addr call when handling
	arg setup relocs.  Instead do so for R_PPC_TLSGD and R_PPC_TLSLD
	relocs.
	* elf64-ppc.c (ppc64_elf_howto_raw): Add R_PPC64_TLSGD, R_PPC64_TLSLD.
	(ppc64_elf_reloc_type_lookup): Handle new relocs.
	(ppc64_elf_check_relocs): Set has_tls_get_addr_call on finding such
	without marker relocs.
	(ppc64_elf_tls_optimize): Allow out-of-order __tls_get_addr relocs
	if section has no old-style calls.  Set toc_ref for new relocs as
	appropriate.
	(ppc64_elf_relocate_section): Set tls_mask for non-tls relocs too.
	Don't try to optimize new-style __tls_get_addr call when handling
	arg setup relocs.  Instead do so for R_PPC_TLSGD and R_PPC_TLSLD
	relocs.
gas/
	* config/tc-ppc.c (ppc_elf_suffix): Error if ppc32 tls got relocs
	have non-zero addend.
	(md_assemble): Parse args of __tls_get_addr calls.
	(md_apply_fix): Handle BFD_RELOC_PPC_TLSGD and BFD_RELOC_PPC_TLSLD.
ld/testsuite/
	* ld-powerpc/tlsmark.s, * ld-powerpc/tlsmark.d: New test.
	* ld-powerpc/tlsmark32.s, * ld-powerpc/tlsmark32.d: New test.
	* ld-powerpc/powerpc.exp: Run them.
@
text
@d2331 1
a2331 1
is_pic_glink_stub (bfd *abfd, asection *glink, bfd_vma off)
d2333 1
a2333 2
  bfd_byte buf[16];
  unsigned int insn;
d2335 1
a2335 1
  if (!bfd_get_section_contents (abfd, glink, buf, off, 16))
d2338 4
a2341 12
  insn = bfd_get_32 (abfd, buf);
  if ((insn & 0xffff0000) == LWZ_11_30
      && bfd_get_32 (abfd, buf + 4) == MTCTR_11
      && bfd_get_32 (abfd, buf + 8) == BCTR)
    return TRUE;

  if ((insn & 0xffff0000) == ADDIS_11_30
      && (bfd_get_32 (abfd, buf + 4) & 0xffff0000) == LWZ_11_11
      && bfd_get_32 (abfd, buf + 8) == MTCTR_11
      && bfd_get_32 (abfd, buf + 12) == BCTR)
    return TRUE;
  return FALSE;
d2478 2
a2479 4
  if (!bfd_get_section_contents (abfd, glink, buf,
				 stub_vma - glink->vma, 4)
      || ((bfd_get_32 (abfd, buf) & 0xffff0000) != LIS_11
	  && is_pic_glink_stub (abfd, glink, stub_vma - glink->vma - 16)))
d2714 1
a2714 1
  /* Offset of PltResolve function in glink.  */
@


1.251
log
@	* elf64-ppc.c (struct _ppc64_elf_section_data): Delete t_symndx,
	add toc.symndx and toc.add.
	(ppc64_elf_check_relocs): Don't set htab->tls_get_addr here.
	Set up toc.add.
	(get_tls_mask): Add toc_addend param, set from toc.add.  Adjust all
	callers.
	(ppc64_elf_tls_setup): Set htab->tls_get_addr and tls_get_addr_fd.
	(branch_reloc_hash_match): New function, extracted from..
	(ppc64_elf_tls_optimize): ..here.
	(ppc64_elf_relocate_section): Properly set addends when optimizing
	tls sequences.  Avoid unnecessary reading and writing of insns.
	Only redo reloc when symbol changed.  Bypass symbol checks when
	using tlsld_got.
	* elf32-ppc.c (ppc_elf_tls_setup): Correct comment.
	(branch_reloc_hash_match): New function, extracted from..
	(ppc_elf_tls_optimize): ..here.
	(ppc_elf_relocate_section): Avoid unnecessary reading of insns.
	Don't clear addend on zapped __tls_get_addr reloc.
@
text
@d756 1
a756 1
  /* Marker reloc for TLS.  */
d771 28
d1562 2
d3321 1
d3347 2
d3360 1
a3360 1
      int tls_type = 0;
d3387 1
d3389 28
d3419 6
d3678 1
a3678 1
	  if (h && h == htab->elf.hgot && htab->plt_type == PLT_UNSET)
d4555 2
a4556 1
		      if (!expecting_tls_get_addr)
d6306 7
a6312 10
      if (IS_PPC_TLS_RELOC (r_type))
	{
	  if (h != NULL)
	    tls_mask = ((struct ppc_elf_link_hash_entry *) h)->tls_mask;
	  else if (local_got_offsets != NULL)
	    {
	      char *lgot_masks;
	      lgot_masks = (char *) (local_got_offsets + symtab_hdr->sh_info);
	      tls_mask = lgot_masks[r_symndx];
	    }
d6430 11
a6440 1
	      offset = rel[1].r_offset;
d6448 8
a6455 3
		  insn2 = 0x7c631214;	/* add 3,3,2 */
		  rel[1].r_info
		    = ELF32_R_INFO (ELF32_R_SYM (rel[1].r_info), R_PPC_NONE);
a6463 1
		  insn2 = 0x38630000;	/* addi 3,3,0 */
d6482 8
a6489 4
		  rel[1].r_info = ELF32_R_INFO (r_symndx,
						R_PPC_TPREL16_LO);
		  rel[1].r_offset += d_offset;
		  rel[1].r_addend = rel->r_addend;
a6492 1
	      bfd_put_32 (output_bfd, insn2, contents + offset);
d6502 60
d6614 2
d6657 1
@


1.250
log
@	* ld-powerpc/powerpc.exp: Add vxworks relax testcase.
	* ld-powerpc/vxworks-relax.s, ld-powerpc/vxworks-relax.rd: New.
	* ld-powerpc/vxworks1.ld: Add .pad and .far input sections.
	* ld-powerpc/vxworks1.rd: Correct regexp for undefined symbols.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d4304 2
a4305 1
/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */
d4326 37
d4490 4
a4493 29
		      if (rel + 1 < relend)
			{
			  enum elf_ppc_reloc_type r_type2;
			  unsigned long r_symndx2;
			  struct elf_link_hash_entry *h2;

			  /* The next instruction should be a call to
			     __tls_get_addr.  Peek at the reloc to be sure.  */
			  r_type2 = ELF32_R_TYPE (rel[1].r_info);
			  r_symndx2 = ELF32_R_SYM (rel[1].r_info);
			  if (r_symndx2 >= symtab_hdr->sh_info
			      && (r_type2 == R_PPC_REL14
				  || r_type2 == R_PPC_REL14_BRTAKEN
				  || r_type2 == R_PPC_REL14_BRNTAKEN
				  || r_type2 == R_PPC_REL24
				  || r_type2 == R_PPC_PLTREL24))
			    {
			      struct elf_link_hash_entry **sym_hashes;

			      sym_hashes = elf_sym_hashes (ibfd);
			      h2 = sym_hashes[r_symndx2 - symtab_hdr->sh_info];
			      while (h2->root.type == bfd_link_hash_indirect
				     || h2->root.type == bfd_link_hash_warning)
				h2 = ((struct elf_link_hash_entry *)
				      h2->root.u.i.link);
			      if (h2 == htab->tls_get_addr)
				continue;
			    }
			}
d6360 1
a6360 1
	      bfd_vma insn1, insn2;
a6364 2
	      insn1 = bfd_get_32 (output_bfd,
				  contents + rel->r_offset - d_offset);
d6368 2
a6374 1
		  rel[1].r_addend = 0;
@


1.249
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d5579 1
a5579 1
  bfd_boolean changed;
d5826 1
a5876 1
  changed = fixups != NULL;
d5942 1
a5942 1
      if (!changed && !link_info->keep_memory)
d5951 1
a5951 1
  if (elf_section_data (isec)->relocs != internal_relocs)
d5953 17
a5969 1
      if (!changed)
d5971 4
a5974 2
      else
	elf_section_data (isec)->relocs = internal_relocs;
d5976 2
d5979 1
a5979 1
  *again = changed;
d6973 11
@


1.248
log
@	* elf32-ppc.c (allocate_dynrelocs): Always use tlsld_got for
	TLS_LD even when symbol is used with other TLS reloc types.
	(ppc_elf_relocate_section): Bypass symbol checks when using tlsld_got.
	Leave addend zero on LD DTPMOD dynamic reloc.
@
text
@d3771 2
a3772 8
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;
d3774 2
a3775 3
		  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);
a3776 3
		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;
		  sreloc = bfd_get_section_by_name (htab->elf.dynobj, name);
d3778 1
a3778 15
		    {
		      flagword flags;

		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED
			       | SEC_ALLOC | SEC_LOAD);
		      sreloc = bfd_make_section_with_flags (htab->elf.dynobj,
							    name,
							    flags);
		      if (sreloc == NULL
			  || ! bfd_set_section_alignment (htab->elf.dynobj,
							  sreloc, 2))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
d6815 3
a6817 7
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
a6818 8

		  BFD_ASSERT (CONST_STRNEQ (name, ".rela")
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (htab->elf.dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
@


1.247
log
@include/elf/
	* ppc.h: Add Tag_GNU_Power_ABI_Struct_Return.
bfd/
	* elf32-ppc.c (ppc_elf_merge_obj_attributes): Merge
	Tag_GNU_Power_ABI_Struct_Return.
binutils/
	* readelf.c (display_power_gnu_attribute): Decode
	Tag_GNU_Power_ABI_Struct_Return.
ld/testsuite/
	* ld-powerpc/gnu-attr-12-1.s: New file.
	* ld-powerpc/gnu-attr-12-2.s: New file.
	* ld-powerpc/gnu-attr-12-11.d: New file.
	* ld-powerpc/gnu-attr-12-21.d: New file.
	* ld-powerpc/powerpc.exp: Run new dump tests.
@
text
@d5027 3
d5039 2
a5040 8
      if (eh->tls_mask == (TLS_TLS | TLS_LD)
	  && !eh->elf.def_dynamic)
	{
	  /* If just an LD reloc, we'll just use htab->tlsld_got.offset.  */
	  htab->tlsld_got.refcount += 1;
	  eh->elf.got.offset = (bfd_vma) -1;
	}
      else
d5042 1
a5042 3
	  bfd_boolean dyn;
	  unsigned int need = 0;
	  if ((eh->tls_mask & TLS_TLS) != 0)
d5044 6
a5049 1
	      if ((eh->tls_mask & TLS_LD) != 0)
a5050 6
	      if ((eh->tls_mask & TLS_GD) != 0)
		need += 8;
	      if ((eh->tls_mask & (TLS_TPREL | TLS_TPRELGD)) != 0)
		need += 4;
	      if ((eh->tls_mask & TLS_DTPREL) != 0)
		need += 4;
d5052 5
a5056 1
	  else
d5058 7
d5074 2
a5075 1
	      if ((eh->tls_mask & TLS_LD) != 0)
d5311 2
a5312 1
	    if (*lgot_masks == (TLS_TLS | TLS_LD))
d5314 8
a5321 4
		/* If just an LD reloc, we'll just use
		   htab->tlsld_got.offset.  */
		htab->tlsld_got.refcount += 1;
		*local_got = (bfd_vma) -1;
d5324 4
a5328 12
		unsigned int need = 0;
		if ((*lgot_masks & TLS_TLS) != 0)
		  {
		    if ((*lgot_masks & TLS_GD) != 0)
		      need += 8;
		    if ((*lgot_masks & (TLS_TPREL | TLS_TPRELGD)) != 0)
		      need += 4;
		    if ((*lgot_masks & TLS_DTPREL) != 0)
		      need += 4;
		  }
		else
		  need += 4;
d6593 2
a6594 1
			&& (h == NULL
d6625 1
a6625 1
			if (indx == 0)
@


1.246
log
@	* elf32-ppc.c (ppc_elf_finish_dynamic_sections): Handle vxworks
	_GLOBAL_OFFSET_TABLE_ in .got.plt section.  Add BFD_ASSERTs.
@
text
@d3967 27
@


1.245
log
@	PR 6844
	* elf32-ppc.c (SYM_VAL): Define.  Use throughout to find symbol vma.
	(ppc_elf_relocate_section): Correct GOT offset calculation.
	(ppc_elf_finish_dynamic_symbol): Use PPC_HA and PPC_LO.
	(ppc_elf_finish_dynamic_sections): Likewise.  Error if
	htab->elf.hgot symbol is not defined in htab->got section.
@
text
@a7729 2
  /* Add a blrl instruction at _GLOBAL_OFFSET_TABLE_-4 so that a function can
     easily find the address of the _GLOBAL_OFFSET_TABLE_.  */
d7732 2
a7733 1
      if (htab->elf.hgot->root.u.def.section == htab->got)
d7735 1
a7735 2
	  unsigned char *p = htab->got->contents;
	  bfd_vma val;
d7739 8
a7746 1
	    bfd_put_32 (output_bfd, 0x4e800021 /* blrl */, p - 4);
a7747 1
	  val = 0;
d7749 6
a7754 2
	    val = sdyn->output_section->vma + sdyn->output_offset;
	  bfd_put_32 (output_bfd, val, p);
d7760 2
a7761 1
				 htab->got->name);
@


1.244
log
@	PR 6888
	* elf32-ppc.c (ppc_elf_relocate_section): Handle NULL symbol section
	on R_PPC_TOC16, R_PPC_SDAREL16, R_PPC_EMB_SDA2REL, R_PPC_EMB_SDA21,
	R_PPC_EMB_RELSDA, R_PPC_SECTOFF* relocs.
@
text
@d160 6
d6665 4
a6668 2
	    relocation = htab->got->output_offset + off;
	    relocation -= htab->elf.hgot->root.u.def.value;
a7024 1
	    struct elf_link_hash_entry *sh;
d7046 1
a7046 4
	    sh = htab->sdata[0].sym;
	    addend -= (sh->root.u.def.value
		       + sh->root.u.def.section->output_offset
		       + sh->root.u.def.section->output_section->vma);
a7053 1
	    struct elf_link_hash_entry *sh;
d7077 1
a7077 4
	    sh = htab->sdata[1].sym;
	    addend -= (sh->root.u.def.value
		       + sh->root.u.def.section->output_offset
		       + sh->root.u.def.section->output_section->vma);
a7086 1
	    struct elf_link_hash_entry *sh;
d7101 1
a7101 4
		sh = htab->sdata[0].sym;
		addend -= (sh->root.u.def.value
			   + sh->root.u.def.section->output_offset
			   + sh->root.u.def.section->output_section->vma);
d7107 1
a7107 4
		sh = htab->sdata[1].sym;
		addend -= (sh->root.u.def.value
			   + sh->root.u.def.section->output_offset
			   + sh->root.u.def.section->output_section->vma);
a7361 3
		    bfd_vma got_offset_hi = (got_offset >> 16)
					    + ((got_offset & 0x8000) >> 15);

d7363 1
a7363 1
				plt_entry[0] | (got_offset_hi & 0xffff),
d7366 1
a7366 1
				plt_entry[1] | (got_offset & 0xffff),
d7371 1
a7371 7
		    bfd_vma got_loc
		      = (got_offset
			 + htab->elf.hgot->root.u.def.value
			 + htab->elf.hgot->root.u.def.section->output_offset
			 + htab->elf.hgot->root.u.def.section->output_section->vma);
		    bfd_vma got_loc_hi = (got_loc >> 16)
					 + ((got_loc & 0x8000) >> 15);
d7374 1
a7374 1
				plt_entry[0] | (got_loc_hi & 0xffff),
d7377 1
a7377 1
				plt_entry[1] | (got_loc & 0xffff),
d7537 1
a7537 3
		  got = (htab->elf.hgot->root.u.def.value
			 + htab->elf.hgot->root.u.def.section->output_section->vma
			 + htab->elf.hgot->root.u.def.section->output_offset);
d7603 1
a7603 3
      rela.r_offset = (h->root.u.def.value
		       + h->root.u.def.section->output_section->vma
		       + h->root.u.def.section->output_offset);
d7653 2
a7654 1
  bfd * dynobj;
d7670 1
a7670 3
    got = (htab->elf.hgot->root.u.def.value
	   + htab->elf.hgot->root.u.def.section->output_section->vma
	   + htab->elf.hgot->root.u.def.section->output_offset);
d7734 4
a7737 2
      unsigned char *p = htab->got->contents;
      bfd_vma val;
d7739 17
a7755 8
      p += htab->elf.hgot->root.u.def.value;
      if (htab->plt_type == PLT_OLD)
	bfd_put_32 (output_bfd, 0x4e800021 /* blrl */, p - 4);

      val = 0;
      if (sdyn != NULL)
	val = sdyn->output_section->vma + sdyn->output_offset;
      bfd_put_32 (output_bfd, val, p);
d7770 1
a7770 5
	  bfd_vma got_value =
	    (htab->elf.hgot->root.u.def.section->output_section->vma
	     + htab->elf.hgot->root.u.def.section->output_offset
	     + htab->elf.hgot->root.u.def.value);
	  bfd_vma got_hi = (got_value >> 16) + ((got_value & 0x8000) >> 15);
d7772 1
a7772 1
	  bfd_put_32 (output_bfd, plt_entry[0] | (got_hi & 0xffff),
d7774 1
a7774 1
	  bfd_put_32 (output_bfd, plt_entry[1] | (got_value & 0xffff),
d8039 1
a8039 1
  return TRUE;
@


1.243
log
@	* elf32-ppc.c (allocate_dynrelocs): Ignore dyn_relocs when
	!dynamic_sections_created.  Don't make symbols with got
	references dynamic if !dynamic_sections_created.
	* elf64-ppc.c (allocate_dynrelocs): Likewise.  Alloc dynamic
	relocs on undefined symbols.
	(ppc64_elf_relocate_section): Allow dynamic relocs on
	undefined symbols.
@
text
@d6974 6
a6979 3
	  BFD_ASSERT (sec != NULL);
	  BFD_ASSERT (bfd_is_und_section (sec)
		      || strcmp (bfd_get_section_name (abfd, sec), ".got") == 0
d6982 1
a6982 1
	    addend -= sec->output_section->vma + sec->output_offset + 0x8000;
d7019 6
a7024 1
	    BFD_ASSERT (sec != NULL);
d7052 6
a7057 1
	    BFD_ASSERT (sec != NULL);
d7089 6
a7094 1
	    BFD_ASSERT (sec != NULL);
a7106 1

a7115 1

a7120 1

d7150 5
a7154 1
	  BFD_ASSERT (sec != NULL);
@


1.243.2.1
log
@	PR 6888
	* elf32-ppc.c (ppc_elf_relocate_section): Handle NULL symbol section
	on R_PPC_TOC16, R_PPC_SDAREL16, R_PPC_EMB_SDA2REL, R_PPC_EMB_SDA21,
	R_PPC_EMB_RELSDA, R_PPC_SECTOFF* relocs.
@
text
@d6974 3
a6976 6
	  if (sec == NULL || sec->output_section == NULL)
	    {
	      unresolved_reloc = TRUE;
	      break;
	    }
	  BFD_ASSERT (strcmp (bfd_get_section_name (abfd, sec), ".got") == 0
d6979 1
a6979 1
	  addend -= sec->output_section->vma + sec->output_offset + 0x8000;
d7016 1
a7016 6
	    if (sec == NULL || sec->output_section == NULL)
	      {
		unresolved_reloc = TRUE;
		break;
	      }

d7044 1
a7044 6
	    if (sec == NULL || sec->output_section == NULL)
	      {
		unresolved_reloc = TRUE;
		break;
	      }

d7076 1
a7076 6
	    if (sec == NULL || sec->output_section == NULL)
	      {
		unresolved_reloc = TRUE;
		break;
	      }

d7089 1
d7099 1
d7105 1
d7135 1
a7135 5
	  if (sec == NULL || sec->output_section == NULL)
	    {
	      unresolved_reloc = TRUE;
	      break;
	    }
@


1.243.2.2
log
@	PR 6844
	* elf32-ppc.c (SYM_VAL): Define.  Use throughout to find symbol vma.
	(ppc_elf_relocate_section): Correct GOT offset calculation.
	(ppc_elf_finish_dynamic_symbol): Use PPC_HA and PPC_LO.
	(ppc_elf_finish_dynamic_sections): Likewise.  Error if
	htab->elf.hgot symbol is not defined in htab->got section.
@
text
@a159 6

/* The value of a defined global symbol.  */
#define SYM_VAL(SYM) \
  ((SYM)->root.u.def.section->output_section->vma	\
   + (SYM)->root.u.def.section->output_offset		\
   + (SYM)->root.u.def.value)
d6659 2
a6660 4
	    relocation = (htab->got->output_section->vma
			  + htab->got->output_offset
			  + off
			  - SYM_VAL (htab->elf.hgot));
d7017 1
d7039 4
a7042 1
	    addend -= SYM_VAL (htab->sdata[0].sym);
d7050 1
d7074 4
a7077 1
	    addend -= SYM_VAL (htab->sdata[1].sym);
d7087 1
d7102 4
a7105 1
		addend -= SYM_VAL (htab->sdata[0].sym);
d7111 4
a7114 1
		addend -= SYM_VAL (htab->sdata[1].sym);
d7369 3
d7373 1
a7373 1
				plt_entry[0] | PPC_HA (got_offset),
d7376 1
a7376 1
				plt_entry[1] | PPC_LO (got_offset),
d7381 7
a7387 1
		    bfd_vma got_loc = got_offset + SYM_VAL (htab->elf.hgot);
d7390 1
a7390 1
				plt_entry[0] | PPC_HA (got_loc),
d7393 1
a7393 1
				plt_entry[1] | PPC_LO (got_loc),
d7553 3
a7555 1
		  got = SYM_VAL (htab->elf.hgot);
d7621 3
a7623 1
      rela.r_offset = SYM_VAL (h);
d7673 1
a7673 2
  bfd *dynobj;
  bfd_boolean ret = TRUE;
d7689 3
a7691 1
    got = SYM_VAL (htab->elf.hgot);
d7755 2
a7756 4
      if (htab->elf.hgot->root.u.def.section == htab->got)
	{
	  unsigned char *p = htab->got->contents;
	  bfd_vma val;
d7758 8
a7765 17
	  p += htab->elf.hgot->root.u.def.value;
	  if (htab->plt_type == PLT_OLD)
	    bfd_put_32 (output_bfd, 0x4e800021 /* blrl */, p - 4);

	  val = 0;
	  if (sdyn != NULL)
	    val = sdyn->output_section->vma + sdyn->output_offset;
	  bfd_put_32 (output_bfd, val, p);
	}
      else
	{
	  (*_bfd_error_handler) (_("%s not defined in linker created %s"),
				 htab->elf.hgot->root.root.string,
				 htab->got->name);
	  bfd_set_error (bfd_error_bad_value);
	  ret = FALSE;
	}
d7780 5
a7784 1
	  bfd_vma got_value = SYM_VAL (htab->elf.hgot);
d7786 1
a7786 1
	  bfd_put_32 (output_bfd, plt_entry[0] | PPC_HA (got_value),
d7788 1
a7788 1
	  bfd_put_32 (output_bfd, plt_entry[1] | PPC_LO (got_value),
d8053 1
a8053 1
  return ret;
@


1.243.2.3
log
@	* elf32-ppc.c (ppc_elf_finish_dynamic_sections): Handle vxworks
	_GLOBAL_OFFSET_TABLE_ in .got.plt section.  Add BFD_ASSERTs.
@
text
@d7730 2
d7734 1
a7734 2
      if (htab->elf.hgot->root.u.def.section == htab->got
	  || htab->elf.hgot->root.u.def.section == htab->sgotplt)
d7736 2
a7737 1
	  unsigned char *p = htab->elf.hgot->root.u.def.section->contents;
d7741 1
a7741 8
	    {
	      /* Add a blrl instruction at _GLOBAL_OFFSET_TABLE_-4
		 so that a function can easily find the address of
		 _GLOBAL_OFFSET_TABLE_.  */
	      BFD_ASSERT (htab->elf.hgot->root.u.def.value - 4
			  < htab->elf.hgot->root.u.def.section->size);
	      bfd_put_32 (output_bfd, 0x4e800021, p - 4);
	    }
d7743 1
d7745 2
a7746 6
	    {
	      bfd_vma val = sdyn->output_section->vma + sdyn->output_offset;
	      BFD_ASSERT (htab->elf.hgot->root.u.def.value
			  < htab->elf.hgot->root.u.def.section->size);
	      bfd_put_32 (output_bfd, val, p);
	    }
d7752 1
a7752 2
				 (htab->sgotplt != NULL
				  ? htab->sgotplt->name : htab->got->name));
@


1.243.2.4
log
@	* elf32-ppc.c (allocate_dynrelocs): Always use tlsld_got for
	TLS_LD even when symbol is used with other TLS reloc types.
	(ppc_elf_relocate_section): Bypass symbol checks when using tlsld_got.
	Leave addend zero on LD DTPMOD dynamic reloc.
@
text
@a4999 3
      bfd_boolean dyn;
      unsigned int need;

d5009 8
a5016 2
      need = 0;
      if ((eh->tls_mask & TLS_TLS) != 0)
d5018 3
a5020 1
	  if ((eh->tls_mask & TLS_LD) != 0)
d5022 3
a5024 6
	      if (!eh->elf.def_dynamic)
		/* We'll just use htab->tlsld_got.offset.  This should
		   always be the case.  It's a little odd if we have
		   a local dynamic reloc against a non-local symbol.  */
		htab->tlsld_got.refcount += 1;
	      else
d5026 4
d5031 1
a5031 5
	  if ((eh->tls_mask & TLS_GD) != 0)
	    need += 8;
	  if ((eh->tls_mask & (TLS_TPREL | TLS_TPRELGD)) != 0)
	    need += 4;
	  if ((eh->tls_mask & TLS_DTPREL) != 0)
a5032 7
	}
      else
	need += 4;
      if (need == 0)
	eh->elf.got.offset = (bfd_vma) -1;
      else
	{
d5042 1
a5042 2
	      if ((eh->tls_mask & TLS_LD) != 0
		  && eh->elf.def_dynamic)
d5278 1
a5278 2
	    unsigned int need = 0;
	    if ((*lgot_masks & TLS_TLS) != 0)
d5280 4
a5283 8
		if ((*lgot_masks & TLS_GD) != 0)
		  need += 8;
		if ((*lgot_masks & TLS_LD) != 0)
		  htab->tlsld_got.refcount += 1;
		if ((*lgot_masks & (TLS_TPREL | TLS_TPRELGD)) != 0)
		  need += 4;
		if ((*lgot_masks & TLS_DTPREL) != 0)
		  need += 4;
a5285 4
	      need += 4;
	    if (need == 0)
	      *local_got = (bfd_vma) -1;
	    else
d5287 12
d6563 1
a6563 2
			&& (offp == &htab->tlsld_got.offset
			    || h == NULL
d6594 1
a6594 1
			if (indx == 0 && tls_ty != (TLS_TLS | TLS_LD))
@


1.243.2.5
log
@backport 2008-10-10  Nathan Froyd  <froydnj@@codesourcery.com>
@
text
@a3966 27
  /* Check for conflicting Tag_GNU_Power_ABI_Struct_Return attributes
     and merge non-conflicting ones.  */
  in_attr = &in_attrs[Tag_GNU_Power_ABI_Struct_Return];
  out_attr = &out_attrs[Tag_GNU_Power_ABI_Struct_Return];
  if (in_attr->i != out_attr->i)
    {
      out_attr->type = 1;
      if (out_attr->i == 0)
       out_attr->i = in_attr->i;
      else if (in_attr->i == 0)
       ;
      else if (out_attr->i == 1 && in_attr->i == 2)
       _bfd_error_handler
         (_("Warning: %B uses r3/r4 for small structure returns, %B uses memory"), obfd, ibfd);
      else if (out_attr->i == 2 && in_attr->i == 1)
       _bfd_error_handler
         (_("Warning: %B uses r3/r4 for small structure returns, %B uses memory"), ibfd, obfd);
      else if (in_attr->i > 2)
       _bfd_error_handler
         (_("Warning: %B uses unknown small structure return convention %d"), ibfd,
          in_attr->i);
      else
       _bfd_error_handler
         (_("Warning: %B uses unknown small structure return convention %d"), obfd,
          out_attr->i);
    }

@


1.243.2.6
log
@backport 2009-01-26  Nathan Sidwell  <nathan@@codesourcery.com>
@
text
@d5603 1
a5603 1
  unsigned changes = 0;
a5849 1
	  changes++;
d5900 1
d5966 1
a5966 1
      if (!changes && !link_info->keep_memory)
d5975 1
a5975 1
  if (changes != 0)
d5977 1
a5977 17
      /* Append sufficient NOP relocs so we can write out relocation
	 information for the trampolines.  */
      Elf_Internal_Rela *new_relocs = bfd_malloc ((changes + isec->reloc_count)
						  * sizeof (*new_relocs));
      unsigned ix;
      
      if (!new_relocs)
	goto error_return;
      memcpy (new_relocs, internal_relocs,
	      isec->reloc_count * sizeof (*new_relocs));
      for (ix = changes; ix--;)
	{
	  irel = new_relocs + ix + isec->reloc_count;

	  irel->r_info = ELF32_R_INFO (0, R_PPC_NONE);
	}
      if (internal_relocs != elf_section_data (isec)->relocs)
d5979 2
a5980 4
      elf_section_data (isec)->relocs = new_relocs;
      isec->reloc_count += changes;
      elf_section_data (isec)->rel_hdr.sh_size
	+= changes * elf_section_data (isec)->rel_hdr.sh_entsize;
a5981 2
  else if (elf_section_data (isec)->relocs != internal_relocs)
    free (internal_relocs);
d5983 1
a5983 1
  *again = changes != 0;
a6988 11

	    /* Rewrite the reloc and convert one of the trailing nop
	       relocs to describe this relocation.  */
	    BFD_ASSERT (ELF32_R_TYPE (relend[-1].r_info) == R_PPC_NONE);
	    /* The relocs are at the bottom 2 bytes */
	    rel[0].r_offset += 2;
	    memmove (rel + 1, rel, (relend - rel - 1) * sizeof (*rel));
	    rel[0].r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_HA);
	    rel[1].r_offset += 4;
	    rel[1].r_info = ELF32_R_INFO (r_symndx, R_PPC_ADDR16_LO);
	    rel++;
@


1.243.2.7
log
@backport 2009-02-15  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d4328 1
a4328 2
/* Set plt output section type, htab->tls_get_addr, and call the
   generic ELF tls_setup function.  */
a4348 37
/* Return TRUE iff REL is a branch reloc with a global symbol matching
   HASH.  */

static bfd_boolean
branch_reloc_hash_match (const bfd *ibfd,
			 const Elf_Internal_Rela *rel,
			 const struct elf_link_hash_entry *hash)
{
  Elf_Internal_Shdr *symtab_hdr = &elf_symtab_hdr (ibfd);
  enum elf_ppc_reloc_type r_type = ELF32_R_TYPE (rel->r_info);
  unsigned int r_symndx = ELF32_R_SYM (rel->r_info);

  if (r_symndx >= symtab_hdr->sh_info
      && (r_type == R_PPC_PLTREL24
	  || r_type == R_PPC_LOCAL24PC
	  || r_type == R_PPC_REL14
	  || r_type == R_PPC_REL14_BRTAKEN
	  || r_type == R_PPC_REL14_BRNTAKEN
	  || r_type == R_PPC_REL24
	  || r_type == R_PPC_ADDR24
	  || r_type == R_PPC_ADDR14
	  || r_type == R_PPC_ADDR14_BRTAKEN
	  || r_type == R_PPC_ADDR14_BRNTAKEN))
    {
      struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (ibfd);
      struct elf_link_hash_entry *h;

      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;
      if (h == hash)
	return TRUE;
    }
  return FALSE;
}

d4476 29
a4504 4
		      if (rel + 1 < relend
			  && branch_reloc_hash_match (ibfd, rel + 1,
						      htab->tls_get_addr))
			continue;
d6371 1
a6371 1
	      unsigned int insn1, insn2;
d6376 2
a6380 2
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - d_offset);
d6386 1
@


1.242
log
@	* elf32-ppc.c (ppc_elf_relax_section): Clear R_PPC_PLTREL24 addend.
	(ppc_elf_relocate_section <R_PPC_RELAX32_PLT>): Don't bother here.
@
text
@d4996 2
a4997 1
	  && !eh->elf.forced_local)
d5045 2
a5046 1
  if (eh->dyn_relocs == NULL)
@


1.241
log
@Support PowerPC single-precision float.
@
text
@d5800 2
d5884 1
a5884 1
      val = trampoff - isec->size + 0x48000000;
a6915 1
	    addend = 0;
@


1.240
log
@	* elf32-ppc.c (is_pic_glink_stub): New function.
	(ppc_elf_get_synthetic_symtab): Don't generate symbols when
	multiple shared/pie stubs per plt entry.
@
text
@d3886 13
a3898 1
      else if (out_attr->i == 2 && in_attr->i == 1)
d3901 1
a3901 1
      else if (in_attr->i > 2)
@


1.239
log
@bfd/
	* syms.c (BSF_SYNTHETIC): New flag.
	* elf.c (_bfd_elf_get_synthetic_symtab): Set it.
	* elf32-ppc.c (ppc_elf_get_synthetic_symtab): Likewise.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Likewise.
	* bfd-in.h (bfd_asymbol_flavour): Return bfd_target_unknown_flavour
	for synthetic symbols.
	* bfd-in2.h: Regenerate.

opcodes/
	* mips-dis.c (_print_insn_mips): Use bfd_asymbol_flavour to check
	for ELF symbols.
@
text
@d2295 23
d2445 12
a2460 2
  count = relplt->size / sizeof (Elf32_External_Rela);
  stub_vma = glink_vma - (bfd_vma) count * 16;
@


1.238
log
@	* elf32-ppc.c (ppc_elf_get_synthetic_symtab): Fix memset calls.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Likewise.
@
text
@d2453 1
d2470 1
a2470 1
  s->flags = BSF_GLOBAL;
d2484 1
a2484 1
      s->flags = BSF_GLOBAL;
@


1.237
log
@	* elf32-ppc.c (section_covers_vma): New function.
	(ppc_elf_get_synthetic_symtab): New function.
	(bfd_elf32_get_synthetic_symtab): Define.
	* elf64-ppc.c (section_covers_vma): New function.
	(ppc64_elf_get_synthetic_symtab): Generate sym@@plt on glink branch
	table entries, and __glink_PLTresolve on resolver stub.
	(ppc64_elf_build_stubs): Rename __glink sym to __glink_PLTresolve.
@
text
@d2467 1
a2467 1
  memset (s, sizeof *s, 0);
d2481 1
a2481 1
      memset (s, sizeof *s, 0);
@


1.236
log
@	PR 6443
	* elf32-ppc.c (MUST_BE_DYN_RELOC): Delete.
	(must_be_dyn_reloc): New function.
	(ppc_elf_check_relocs): Don't set DF_STATIC_TLS for tprel relocs
	in pies.
	(ppc_elf_tls_optimize): Optimise pies.
	(ppc_elf_relocate_section): Use a section symbol rather than no
	symbol if possible for LD->IE TLS sequence, but don't error if
	we must use no symbol.
	* elf64-ppc.c (MUST_BE_DYN_RELOC): As for elf32-ppc.c.
	(must_be_dyn_reloc): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	(ppc64_elf_tls_optimize): Likewise.
	(ppc64_elf_relocate_section): Likewise.
@
text
@d2294 202
d8023 1
d8138 2
@


1.235
log
@	bfd/
	* elf32-arm.c (elf32_arm_final_link_relocate): Skip dynamic relocs
	in vxworks tls_vars sections.
	(allocate_dynrelocs, elf32_arm_size_dynamic_sections): Likewise.
	* elf32-i386.c (allocate_dynrelocs,
	elf_i386_size_dynamic_sections, elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (allocate_dynrelocs, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs,
	_bfd_sparc_elf_size_dynamic_sections,
	_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-vxworks/tls-3.s: New.
	* ld-vxworks/tls-3.d: New.
@
text
@d2347 1
a2347 1
/* Of those relocs that might be copied as dynamic relocs, this macro
d2351 24
a2374 6
#define MUST_BE_DYN_RELOC(RTYPE)		\
  ((RTYPE) != R_PPC_REL24			\
   && (RTYPE) != R_PPC_REL14			\
   && (RTYPE) != R_PPC_REL14_BRTAKEN		\
   && (RTYPE) != R_PPC_REL14_BRNTAKEN		\
   && (RTYPE) != R_PPC_REL32)
d2441 1
a2441 1
  /* Shortcut to .__tls_get_addr.  */
d3133 1
a3133 1
	  if (info->shared)
d3393 5
a3397 1
	  if (info->shared)
a3405 8
	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_TPREL16_HI:
	case R_PPC_TPREL16_HA:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  goto dodyn;

d3506 1
a3506 1
	       && (MUST_BE_DYN_RELOC (r_type)
d3601 1
a3601 1
	      if (!MUST_BE_DYN_RELOC (r_type))
d4080 1
a4080 1
  if (info->relocatable || info->shared)
d4808 1
a4808 1
	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be
d6091 7
a6097 1
		      r_symndx = 0;
d6099 4
d6525 1
a6525 1
	       && (MUST_BE_DYN_RELOC (r_type)
d6597 1
a6597 1
		      if (bfd_is_abs_section (sec))
@


1.234
log
@	* elf32-ppc.c (allocate_dynrelocs): Discard relocs on
	undefined symbols with internal or hidden visibility.
	(ppc_elf_relocate_section): Likewise.  Use SYMBOL_CALLS_LOCAL
	rather than SYMBOL_REFERENCES_LOCAL on branches.  Don't
	return immediately on dynamic reloc error.
@
text
@d4814 13
d4978 7
d5823 1
d5843 5
d6490 2
a6491 1
	  if ((input_section->flags & SEC_ALLOC) == 0)
@


1.233
log
@bfd/
	* elf64-ppc.c (build_plt_stub): Add relocs on plt call stubs
	if emitrelocations.
	(get_relocs): New function, split out from..
	(ppc_build_one_stub): ..here.  Add relocs on plt_branch stubs if
	emitrelocations.  Remove indx temp.
	(ppc_size_one_stub): Count new stub relocs.
	(ppc64_elf_size_stubs): Count new glink reloc.
	(ppc64_elf_build_stubs): Emit glink reloc if emitrelocations.
	(ppc64_elf_finish_dynamic_sections): Output glink relocs.
	* elf32-ppc.c (ppc_elf_finish_dynamic_sections): Describe non-pic
	glink code.
ld/testsuite/
	* ld-powerpc/relbrlt.d: Update.  Also check .branch_lt section.
@
text
@d4814 7
d6450 1
a6450 1
	  if (SYMBOL_REFERENCES_LOCAL (info, h)
d6468 6
a6473 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
a6515 1

d6527 4
a6530 1
	      else if (!SYMBOL_REFERENCES_LOCAL (info, h))
d6544 1
a6544 1
		      long indx;
d6547 1
a6547 1
			indx = 0;
d6551 1
a6551 1
			  return FALSE;
@


1.232
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Set pointer_equality_needed
	for R_PPC_REL32 syms.  Don't set non_got_ref on branch reloc syms,
	and assume branch relocs are not dynamic when non-shared.
	(readonly_dynrelocs): New function, split out from..
	(maybe_set_textrel): ..here, renamed from old readonly_dynrelocs.
	(ppc_elf_adjust_dynamic_symbol): For symbols generating plt entries,
	clear non_got_ref..
	(allocate_dynrelocs): ..and don't set u.def for undefined weak.
	Do allow dynamic relocs on undefined symbols.
	(ppc_elf_adjust_dynamic_symbol): Use readonly_dynrelocs.
	(ppc_elf_relocate_section): Mirror dynamic reloc changes in
	check_relocs.
	(ppc_elf_finish_dynamic_symbol): Don't give a warning on weak
	plt symbols needing pointer_equality_needed.
@
text
@d7537 1
a7537 1
       * # The idea is that the plt call stub loads ctr (and r11) with these
d7583 22
@


1.231
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Revert non_got_ref change.
@
text
@a3391 20
	case R_PPC_ADDR32:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	  if (h != NULL && !info->shared)
	    {
	      /* We may need a plt entry if the symbol turns out to be
		 a function defined in a dynamic object.  */
	      if (!update_plt_info (abfd, h, NULL, 0))
		return FALSE;

	      /* We may need a copy reloc too.  */
	      h->non_got_ref = 1;
	      h->pointer_equality_needed = 1;
	    }
	  goto dodyn;

d3417 21
a3437 1
	  goto dodyn1;
a3459 1
	dodyn1:
d3466 1
a3466 3

	      /* We may need a copy reloc too.  */
	      h->non_got_ref = 1;
d4289 19
d4363 16
d4421 3
a4423 1
      && !htab->is_vxworks)
d4425 2
a4426 13
      struct ppc_elf_dyn_relocs *p;
      for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      if (p == NULL)
	{
	  h->non_got_ref = 0;
	  return TRUE;
	}
d4623 1
d4661 1
a4838 1
	  && h->def_dynamic
d4871 2
a4872 1
/* Find any dynamic relocs that apply to read-only sections.  */
d4875 1
a4875 1
readonly_dynrelocs (struct elf_link_hash_entry *h, void *info)
a4876 2
  struct ppc_elf_dyn_relocs *p;

d4883 1
a4883 1
  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
d4885 1
a4885 1
      asection *s = p->sec->output_section;
d4887 2
a4888 9
      if (s != NULL
	  && ((s->flags & (SEC_READONLY | SEC_ALLOC))
	      == (SEC_READONLY | SEC_ALLOC)))
	{
	  ((struct bfd_link_info *) info)->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
d5203 1
a5203 1
	elf_link_hash_traverse (elf_hash_table (info), readonly_dynrelocs,
d6423 14
a6437 1
	case R_PPC_REL32:
a6447 3
	  /* Relocations that always need to be propagated if this is a shared
	     object.  */
	case R_PPC_ADDR32:
a6448 4
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
d6452 4
a6455 2
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
a6458 1
	  /* Fall thru.  */
a6470 1
		  && h->def_dynamic
d7192 2
a7193 3
		    /* Choose your poison.  We must have either text
		       dynamic relocations, broken function pointer
		       comparisons, or broken tests for a NULL
a7194 4
		    (*_bfd_error_handler)
		      (_("weak reference to %s in non-pic code"
			 " will break function pointer comparisons"),
		       h->root.root.string);
@


1.230
log
@	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Copy
	pointer_equality_needed.
	(ppc_elf_check_relocs): Split out non-branch relocs from others
	that might emit dynamic relocs.  Set pointer_equality_needed
	for their symbols.  Don't set non_got_ref on branch reloc symbols.
	(ppc_elf_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
	(ppc_elf_finish_dynamic_symbol): Handle pointer_equality_needed.
	Error if pointer_equality_needed on weak plt symbol.
@
text
@d3467 3
@


1.229
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d2699 1
d3392 20
a3455 1
	case R_PPC_ADDR32:
a3456 4
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
a3459 2
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
a3466 3

	      /* We may need a copy reloc too.  */
	      h->non_got_ref = 1;
d5200 14
d7155 7
a7161 2
		/* Mark the symbol as undefined, rather than as defined in
		   the .plt section.  Leave the value alone.  */
d7163 1
a7163 5
		/* If the symbol is weak, we do need to clear the value.
		   Otherwise, the PLT entry would provide a definition for
		   the symbol even if the symbol wasn't defined anywhere,
		   and so the symbol would never be NULL.  */
		if (!h->ref_regular_nonweak)
d7165 12
d7728 1
@


1.228
log
@	* elf-bfd.h (enum elf_object_id): Add HPPA_ELF_TDATA.
	* elf.c (bfd_elf_allocate_object): Don't check for already allocated
	tdata.
	* elf32-hppa.c (elf32_hppa_mkobject): New function.
	(bfd_elf32_mkobject): Define.
	* elf32-ppc.c (is_ppc_elf_target): Delete.  Replace all uses with..
	(is_ppc_elf): ..this new macro.
	* elf64-ppc.c (is_ppc64_elf_target): Delete.  Replace all uses with..
	(is_ppc64_elf): ..this new macro.
@
text
@d5543 1
a5543 1
      contents = bfd_realloc (contents, trampoff);
@


1.227
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d1739 4
a2749 14
/* Return 1 if target is one of ours.  */

static bfd_boolean
is_ppc_elf_target (const struct bfd_target *targ)
{
  extern const bfd_target bfd_elf32_powerpc_vec;
  extern const bfd_target bfd_elf32_powerpc_vxworks_vec;
  extern const bfd_target bfd_elf32_powerpcle_vec;

  return (targ == &bfd_elf32_powerpc_vec
	  || targ == &bfd_elf32_powerpc_vxworks_vec
	  || targ == &bfd_elf32_powerpcle_vec);
}

d2764 2
a2765 2
      && sym->st_size <= elf_gp_size (abfd)
      && is_ppc_elf_target (info->output_bfd->xvec))
d2882 1
a2882 1
      BFD_ASSERT (is_ppc_elf_target (abfd->xvec));
d3048 1
a3048 1
  BFD_ASSERT (is_ppc_elf_target (abfd->xvec));
d3704 1
a3704 2
  if (!is_ppc_elf_target (ibfd->xvec)
      || !is_ppc_elf_target (obfd->xvec))
d3817 1
a3817 1
	    if (is_ppc_elf_target (ibfd->xvec))
d4908 1
a4908 1
      if (!is_ppc_elf_target (ibfd->xvec))
d5667 1
a5667 1
      BFD_ASSERT (is_ppc_elf_target (input_bfd->xvec));
@


1.226
log
@PR ld/5692
   * elf-bfd.h (enum elf_object_id): New enum, used to identify
   target specific extensions to the elf_obj_tdata structure.
   (struct elf_obj_tdata): New field 'object_id'.
   (elf_object_id, elf_program_header_size, elf_symtab_hdr): New
   macros for accessing fields in the elf_obj_tdata structure.
   (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object.
   (bfd_elf_allocate_object): New function.
   * elf.c (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object
   and implement by calling bfd_elf_allocate_object.
   (bfd_elf_allocate_object): New function: Allocates an
   elf_obj_tdata structure, possibly with a target specific
   extension.
   * elfxx-target.h (bfd_elfNN_mkobject): Use
   bfd_elf_make_generic_object as the default value.
   * elf32-arm.c (elf32_arm_obj_tdata): Rename to elf_arm_obj_tdata
   for consistency with other, similar structures.
   (is_arm_elf): New macro.  Checks a BFD to make sure that is an ARM
   ELF bfd.
   (elf32_arm_mkobject): Call bfd_elf_allocate_object.
   (bfd_elf32_arm_vfp11_erratum_scan): Use is_arm_elf macro to check
   the bfd being processed.
   (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
   (bfd_elf32_arm_set_target_relocs): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_copy_private_bfd_data): Likewise.
   (bfd_elf32_arm_merge_eabi_attributes): Likewise.
   (bfd_elf32_arm_merge_private_bfd_data): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_gc_mark_extra_sections): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   (bfd_elf32_arm_process_before_allocation): Use elf_symtab_hdr.
   (bfd_elf32_arm_init_maps): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_relocate_section): Likewise.
   (bfd_elf32_arm_gc_sweep_hook): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   * elf32-i386.c (elf_i386_mkobject): Call bfd_elf_allocate_object.
   (is_i386_elf): New macro.  Checks a BFD to make sure that is an x86
   ELF bfd.
   (elf_i386_check_relocs): Use is_i386_elf macro to check    the bfd
   being processed.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   (elf_i386_check_relocs): Use elf_symtab_hdr.
   (elf_i386_gc_sweep_hook): Likewise.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   * elf32-ppc.c (ppc_elf_mkobject): Call bfd_elf_allocate_object.
   (elf_create_pointer_linker_section): Use is_ppc_elf_target to
   verify that the bfd before accessing target specific fields.
   (ppc_elf_check_relocs): Likewise.
   (elf_finish_pointer_linker_section): Likewise.
   (elf_create_pointer_linker_section): Use elf_symtab_hdr.
   (ppc_elf_check_relocs): Likewise.
   (ppc_elf_gc_sweep_hook): Likewise.
   (ppc_elf_tls_optimize): Likewise.
   (ppc_elf_size_dynamic_sections): Likewise.
   (ppc_elf_relax_section): Likewise.
   (ppc_elf_relocate_section): Likewise.
   * elf32-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf64-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf32-sh.c (sh_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sh_elf): New macro.  Checks a BFD to make sure that is an SH
   ELF bfd.
   (sh_elf_size_dynamic_sections): Use is_sh_elf macro to check the
   bfd being processed.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_check_relocs): Likewise.
   (sh_elf_copy_private_data): Likewise.
   (sh_elf_relax_section): Use elf_symtab_hdr.
   (sh_elf_size_dynamic_sections): Likewise.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_get_relocated_section_contents): Likewise.
   (sh_elf_gc_sweep_hook): Likewise.
   (sh_elf_check_relocs): Likewise.
   * elf64-alpha.c (elf64_alpha_mkobject): Call bfd_elf_allocate_object.
   (is_alpha_elf): New macro.  Checks a BFD to make sure that is an
   Alpha ELF bfd.
   (elf64_alpha_create_got_section): Use is_alpha_elf macro to check
   the bfd being processed.
   (elf64_alpha_create_dynamic_section): Likewise.
   (elf64_alpha_check_relocs): Likewise.
   (elf64_alpha_size_got_sections): Likewise.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   (elf64_alpha_final_link): Likewise.
   (elf64_alpha_check_relocs): Use elf_symtab_hdr.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section_r): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   * elf64-ppc.c (ppc64_elf_mkobject): Call bfd_elf_allocate_object.
   (ppc64_elf_check_relocs): Use is_ppc64_elf_target to check the bfd
   being processed.
   (opd_entry_value): Likewise.
   (allocate_dynrelocs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   (ppc64_elf_check_relocs): Use elf_symtab_hdr.
   (opd_entry_value): Likewise.
   (ppc64_elf_gc_sweep_hook): Likewise.
   (get_sym_h): Likewise.
   (ppc64_elf_edit_opd): Likewise.
   (ppc64_elf_tls_optimize): Likewise.
   (ppc64_elf_edit_toc): Likewise.
   (ppc64_elf_size_dynamic_sections): Likewise.
   (toc_adjusting_stub_needed): Likewise.
   (ppc64_elf_size_stubs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   * elf64-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf32-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf64-x86_64.c (elf64_x86_64_mkobject): Call bfd_elf_allocate_object.
   (is_x86_64_elf): New macro.  Checks a BFD to make sure that is an
   x86_64 ELF bfd.
   (elf64_x86_64_check_relocs): Use is_x86_64_elf macro to check the bfd
   being processed.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   (elf64_x86_64_check_relocs): Use elf_symtab_hdr.
   (elf64_x86_64_gc_sweep_hook): Likewise.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   * elfxx-sparc.c (_bfd_sparc_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sparc_elf): New macro.  Checks a BFD to make sure that is a Sparc
   ELF bfd.
   (_bfd_sparc_elf_check_relocs): Use is_sparc_elf macro to check the
   bfd being processed.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_check_relocs): Use elf_symtab_hdr.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d2775 1
a2775 1
      && is_ppc_elf_target (info->hash->creator))
@


1.225
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d1744 2
a1745 8
  if (abfd->tdata.any == NULL)
    {
      bfd_size_type amt = sizeof (struct ppc_elf_obj_tdata);
      abfd->tdata.any = bfd_zalloc (abfd, amt);
      if (abfd->tdata.any == NULL)
	return FALSE;
    }
  return bfd_elf_mkobject (abfd);
d2892 2
d2900 1
a2900 1
	  unsigned int num_symbols = elf_tdata (abfd)->symtab_hdr.sh_info;
d3058 2
d3065 1
a3065 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d3920 1
a3920 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d4078 1
a4078 1
	Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d4955 1
a4955 1
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d5261 1
a5261 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d5678 1
d5780 1
a5780 1
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
@


1.224
log
@	include/elf/
	* vxworks.h: New.

	bfd/
	* elf-vxworks.h (elf_vxworks_add_dynamic_entries): Declare.
	(elf_vxworks_finish_dynamic_entry): Declare.
	* elf-vxworks.c: Include elf/vxworks.h.
	(elf_vxworks_add_dynamic_entries): New.
	(elf_vxworks_finish_dynamic_entry): New.
	* Makefile.am (elf-vxworks.lo): Add dependency.
	* Makefile.in (elf-vxworks.lo): Add dependency.
	* elf32-i386.c (elf_i386_size_dynamic_sections,
	elf_i386_finish_dynamic_sections): Call
	elf_vxworks_add_dynamic_entries and
	elf_vxworks_finish_dynamic_entry.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections,
	sparc_finish_dyn): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections,
	sh_elf_finish_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elf32-arm.c (elf32_arm_size_dynamic_sections,
	elf32_arm_finish_dynamic_sections): Likewise.

	ld/
	* ld-vxworks/tls-2.d: New.
	* ld-vxworks/tls-2.s: New.
@
text
@d3913 3
@


1.223
log
@bfd/
	* elf32-ppc.c (ppc_elf_check_relocs): Don't refcount tlsld_got here..
	(ppc_elf_gc_sweep_hook): ..or here..
	(ppc_elf_tls_optimize): ..or here.  Make two passes through the
	relocs, ensuring that tls_get_addr calls follow gd and ld relocs.
	(allocate_dynrelocs): Refcount tlsld_got here.
	(ppc_elf_size_dynamic_sections): Call allocate_dynrelocs before
	allocating tlsld_got.
	(ppc_elf_relocate_section): Remove check that a tls_get_addr
	call follows gd and ld relocs.
ld/testsuite/
	* ld-powerpc/tlsso32.d: Update for changed got alloc order.
@
text
@d5191 4
a5194 1
    }
d7359 3
@


1.222
log
@	* elf32-ppc.c (ppc_elf_merge_obj_attributes): Add support for
	Tag_GNU_Power_ABI_Vector.

	* readelf.c (display_power_gnu_attribute): Add support for
	Tag_GNU_Power_ABI_Vector.

	* ppc.h (Tag_GNU_Power_ABI_Vector): New.

	* ld-powerpc/attr-gnu-8-1.s, ld-powerpc/attr-gnu-8-11.d,
	ld-powerpc/attr-gnu-8-2.s, ld-powerpc/attr-gnu-8-23.d,
	ld-powerpc/attr-gnu-8-3.s, ld-powerpc/attr-gnu-8-31.d: New.
	* ld-powerpc/powerpc.exp: Run new tests.
@
text
@a3111 1
	  htab->tlsld_got.refcount += 1;
a3958 3
	  htab->tlsld_got.refcount -= 1;
	  /* Fall thru */

d4063 1
d4069 9
a4077 4
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      Elf_Internal_Sym *locsyms = NULL;
      Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d4079 4
a4082 5
      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	if (sec->has_tls_reloc && !bfd_is_abs_section (sec->output_section))
	  {
	    Elf_Internal_Rela *relstart, *rel, *relend;
	    int expecting_tls_get_addr;
d4084 5
a4088 5
	    /* Read the relocations.  */
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
						  info->keep_memory);
	    if (relstart == NULL)
	      return FALSE;
d4090 11
a4100 10
	    expecting_tls_get_addr = 0;
	    relend = relstart + sec->reloc_count;
	    for (rel = relstart; rel < relend; rel++)
	      {
		enum elf_ppc_reloc_type r_type;
		unsigned long r_symndx;
		struct elf_link_hash_entry *h = NULL;
		char *tls_mask;
		char tls_set, tls_clear;
		bfd_boolean is_local;
d4102 4
a4105 4
		r_symndx = ELF32_R_SYM (rel->r_info);
		if (r_symndx >= symtab_hdr->sh_info)
		  {
		    struct elf_link_hash_entry **sym_hashes;
d4107 6
a4112 6
		    sym_hashes = elf_sym_hashes (ibfd);
		    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
		    while (h->root.type == bfd_link_hash_indirect
			   || h->root.type == bfd_link_hash_warning)
		      h = (struct elf_link_hash_entry *) h->root.u.i.link;
		  }
d4114 5
a4118 4
		is_local = FALSE;
		if (h == NULL
		    || !h->def_dynamic)
		  is_local = TRUE;
d4120 15
a4134 14
		r_type = ELF32_R_TYPE (rel->r_info);
		switch (r_type)
		  {
		  case R_PPC_GOT_TLSLD16:
		  case R_PPC_GOT_TLSLD16_LO:
		  case R_PPC_GOT_TLSLD16_HI:
		  case R_PPC_GOT_TLSLD16_HA:
		    /* These relocs should never be against a symbol
		       defined in a shared lib.  Leave them alone if
		       that turns out to be the case.  */
		    expecting_tls_get_addr = 0;
		    htab->tlsld_got.refcount -= 1;
		    if (!is_local)
		      continue;
d4136 1
a4136 12
		    /* LD -> LE */
		    tls_set = 0;
		    tls_clear = TLS_LD;
		    expecting_tls_get_addr = 1;
		    break;

		  case R_PPC_GOT_TLSGD16:
		  case R_PPC_GOT_TLSGD16_LO:
		  case R_PPC_GOT_TLSGD16_HI:
		  case R_PPC_GOT_TLSGD16_HA:
		    if (is_local)
		      /* GD -> LE */
d4138 2
a4139 6
		    else
		      /* GD -> IE */
		      tls_set = TLS_TLS | TLS_TPRELGD;
		    tls_clear = TLS_GD;
		    expecting_tls_get_addr = 1;
		    break;
d4141 9
a4149 8
		  case R_PPC_GOT_TPREL16:
		  case R_PPC_GOT_TPREL16_LO:
		  case R_PPC_GOT_TPREL16_HI:
		  case R_PPC_GOT_TPREL16_HA:
		    expecting_tls_get_addr = 0;
		    if (is_local)
		      {
			/* IE -> LE */
d4151 21
a4171 4
			tls_clear = TLS_TPREL;
			break;
		      }
		    else
d4173 78
d4252 6
a4257 14
		  case R_PPC_REL14:
		  case R_PPC_REL14_BRTAKEN:
		  case R_PPC_REL14_BRNTAKEN:
		  case R_PPC_REL24:
		    if (expecting_tls_get_addr
			&& h != NULL
			&& h == htab->tls_get_addr)
		      {
			struct plt_entry *ent = find_plt_ent (h, NULL, 0);
			if (ent != NULL && ent->plt.refcount > 0)
			  ent->plt.refcount -= 1;
		      }
		    expecting_tls_get_addr = 0;
		    continue;
d4259 3
a4261 4
		  default:
		    expecting_tls_get_addr = 0;
		    continue;
		  }
d4263 4
a4266 15
		if (h != NULL)
		  {
		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (h->got.refcount > 0)
			  h->got.refcount -= 1;
		      }
		    tls_mask = &ppc_elf_hash_entry (h)->tls_mask;
		  }
		else
		  {
		    Elf_Internal_Sym *sym;
		    bfd_signed_vma *lgot_refs;
		    char *lgot_masks;
d4268 3
a4270 27
		    if (locsyms == NULL)
		      {
			locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
			if (locsyms == NULL)
			  locsyms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
							  symtab_hdr->sh_info,
							  0, NULL, NULL, NULL);
			if (locsyms == NULL)
			  {
			    if (elf_section_data (sec)->relocs != relstart)
			      free (relstart);
			    return FALSE;
			  }
		      }
		    sym = locsyms + r_symndx;
		    lgot_refs = elf_local_got_refcounts (ibfd);
		    if (lgot_refs == NULL)
		      abort ();
		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (lgot_refs[r_symndx] > 0)
			  lgot_refs[r_symndx] -= 1;
		      }
		    lgot_masks = (char *) (lgot_refs + symtab_hdr->sh_info);
		    tls_mask = &lgot_masks[r_symndx];
		  }
d4272 3
a4274 3
		*tls_mask |= tls_set;
		*tls_mask &= ~tls_clear;
	      }
d4276 7
a4282 2
	    if (elf_section_data (sec)->relocs != relstart)
	      free (relstart);
d4284 1
a4284 10

      if (locsyms != NULL
	  && (symtab_hdr->contents != (unsigned char *) locsyms))
	{
	  if (!info->keep_memory)
	    free (locsyms);
	  else
	    symtab_hdr->contents = (unsigned char *) locsyms;
	}
    }
d4713 5
a4717 2
	/* If just an LD reloc, we'll just use htab->tlsld_got.offset.  */
	eh->elf.got.offset = (bfd_vma) -1;
d4992 3
a5003 3
  /* Allocate space for global sym dynamic relocs.  */
  elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, info);

d5971 1
a5971 1
	    goto tls_get_addr_check;
d5978 8
a5985 2
	    tls_get_addr_check:
	      if (rel + 1 < relend)
d5987 16
a6002 61
		  enum elf_ppc_reloc_type r_type2;
		  unsigned long r_symndx2;
		  struct elf_link_hash_entry *h2;
		  bfd_vma insn1, insn2;
		  bfd_vma offset;

		  /* The next instruction should be a call to
		     __tls_get_addr.  Peek at the reloc to be sure.  */
		  r_type2 = ELF32_R_TYPE (rel[1].r_info);
		  r_symndx2 = ELF32_R_SYM (rel[1].r_info);
		  if (r_symndx2 < symtab_hdr->sh_info
		      || (r_type2 != R_PPC_REL14
			  && r_type2 != R_PPC_REL14_BRTAKEN
			  && r_type2 != R_PPC_REL14_BRNTAKEN
			  && r_type2 != R_PPC_REL24
			  && r_type2 != R_PPC_PLTREL24))
		    break;

		  h2 = sym_hashes[r_symndx2 - symtab_hdr->sh_info];
		  while (h2->root.type == bfd_link_hash_indirect
			 || h2->root.type == bfd_link_hash_warning)
		    h2 = (struct elf_link_hash_entry *) h2->root.u.i.link;
		  if (h2 == NULL || h2 != htab->tls_get_addr)
		    break;

		  /* OK, it checks out.  Replace the call.  */
		  offset = rel[1].r_offset;
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - d_offset);
		  if ((tls_mask & tls_gd) != 0)
		    {
		      /* IE */
		      insn1 &= (1 << 26) - 1;
		      insn1 |= 32 << 26;	/* lwz */
		      insn2 = 0x7c631214;	/* add 3,3,2 */
		      rel[1].r_info = ELF32_R_INFO (r_symndx2, R_PPC_NONE);
		      rel[1].r_addend = 0;
		      r_type = (((r_type - (R_PPC_GOT_TLSGD16 & 3)) & 3)
				+ R_PPC_GOT_TPREL16);
		      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
		    }
		  else
		    {
		      /* LE */
		      insn1 = 0x3c620000;	/* addis 3,2,0 */
		      insn2 = 0x38630000;	/* addi 3,3,0 */
		      if (tls_gd == 0)
			{
			  /* Was an LD reloc.  */
			  r_symndx = 0;
			  rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
			}
		      r_type = R_PPC_TPREL16_HA;
		      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
		      rel[1].r_info = ELF32_R_INFO (r_symndx,
						    R_PPC_TPREL16_LO);
		      rel[1].r_offset += d_offset;
		      rel[1].r_addend = rel->r_addend;
		    }
		  bfd_put_32 (output_bfd, insn1, contents + rel->r_offset - d_offset);
		  bfd_put_32 (output_bfd, insn2, contents + offset);
d6005 3
a6007 4
		      /* We changed the symbol on an LD reloc.  Start over
			 in order to get h, sym, sec etc. right.  */
		      rel--;
		      continue;
d6009 16
@


1.221
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d3606 2
a3607 2
  obj_attribute *in_attr;
  obj_attribute *out_attr;
d3621 3
d3626 8
a3633 8
  in_attr = elf_known_obj_attributes (ibfd)[OBJ_ATTR_GNU];
  out_attr = elf_known_obj_attributes (obfd)[OBJ_ATTR_GNU];
  if (in_attr[Tag_GNU_Power_ABI_FP].i != out_attr[Tag_GNU_Power_ABI_FP].i)
    {
      out_attr[Tag_GNU_Power_ABI_FP].type = 1;
      if (out_attr[Tag_GNU_Power_ABI_FP].i == 0)
	out_attr[Tag_GNU_Power_ABI_FP].i = in_attr[Tag_GNU_Power_ABI_FP].i;
      else if (in_attr[Tag_GNU_Power_ABI_FP].i == 0)
d3635 1
a3635 2
      else if (out_attr[Tag_GNU_Power_ABI_FP].i == 1
	       && in_attr[Tag_GNU_Power_ABI_FP].i == 2)
d3638 1
a3638 2
      else if (out_attr[Tag_GNU_Power_ABI_FP].i == 2
	       && in_attr[Tag_GNU_Power_ABI_FP].i == 1)
d3641 1
a3641 1
      else if (in_attr[Tag_GNU_Power_ABI_FP].i > 2)
d3644 1
a3644 1
	   in_attr[Tag_GNU_Power_ABI_FP].i);
d3648 51
a3698 1
	   out_attr[Tag_GNU_Power_ABI_FP].i);
@


1.220
log
@	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Don't eliminate
	copy relocs on vxworks.
@
text
@d3379 3
a3381 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.219
log
@Switch sources over to use the GPL version 3
@
text
@d4287 6
a4292 3
   /* If we didn't find any dynamic relocs in read-only sections, then we'll
      be keeping the dynamic relocs and avoiding the copy reloc.  We can't
      do this if there are any small data relocations.  */
d4294 2
a4295 1
      && !ppc_elf_hash_entry (h)->has_sda_refs)
@


1.218
log
@bfd:
	* elf32-ppc.c (ppc_elf_merge_obj_attributes): New.
	(ppc_elf_merge_private_bfd_data): Call it.

binutils:
	* readelf.c (display_power_gnu_attribute, process_power_specific):
	New.
	(process_arch_specific): Call process_power_specific.

include/elf:
	* ppc.h (Tag_GNU_Power_ABI_FP): Define.

ld/testsuite:
	* ld-powerpc/attr-gnu-4-0.s, ld-powerpc/attr-gnu-4-00.d,
	ld-powerpc/attr-gnu-4-01.d, ld-powerpc/attr-gnu-4-02.d,
	ld-powerpc/attr-gnu-4-1.s, ld-powerpc/attr-gnu-4-10.d,
	ld-powerpc/attr-gnu-4-11.d, ld-powerpc/attr-gnu-4-12.d,
	ld-powerpc/attr-gnu-4-13.d, ld-powerpc/attr-gnu-4-2.s,
	ld-powerpc/attr-gnu-4-20.d, ld-powerpc/attr-gnu-4-21.d,
	ld-powerpc/attr-gnu-4-22.d, ld-powerpc/attr-gnu-4-3.s,
	ld-powerpc/attr-gnu-4-31.d: New.
	* ld-powerpc/powerpc.exp: Run these new tests.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d23 1
@


1.217
log
@	* elf32-ppc.c (ppc_elf_info_to_howto): Check for invalid relocation
	types.
@
text
@d3597 56
d3671 3
@


1.216
log
@	* elf32-ppc.c (ppc_elf_select_plt_layout): Properly iterate over
	input bfds.
@
text
@d1610 11
@


1.215
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d3706 1
a3706 1
	  for (ibfd = info->input_bfds; ibfd; ibfd = ibfd->next)
@


1.214
log
@bfd/
	* elf32-ppc.h (ppc_elf_select_plt_layout): Update prototype.
	(enum ppc_elf_plt_type): Move from..
	* elf32-ppc.c: ..here.
	(struct ppc_elf_obj_tdata): Add makes_plt_call and has_rel16.
	(struct ppc_elf_link_hash_table): Reorder.  Add old_bfd.  Delete
	can_use_new_plt.  Make is_vxworks a bitfield.
	(ppc_elf_link_hash_table_create): Don't clear is_vxworks (again).
	(ppc_elf_check_relocs): Update setting of reloc flags.  Set old_bfd.
	(ppc_elf_select_plt_layout): Modify parameters.  Use bfd reloc
	flags to better detect object files needing old bss-style plt.
	Allow secure plt to be used without rel16 relocs being detected.
	Warn if secure plt request cannot be allowed.
ld/
	* emultempl/ppc32elf.em (plt_style): New variable.
	(old_plt): Delete.
	(ppc_after_open): Adjust ppc_elf_select_plt_layout call.
	(PARSE_AND_LIST_PROLOGUE): Define OPTION_NEW_PLT, renumber
	OPTION_OLD_PLT, OPTION_OLD_GOT and OPTION_STUBSYMS.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add secure-plt.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_NEW_PLT.
	* ld.texinfo (--secure-plt): Document.
@
text
@a4138 1
  unsigned int power_of_two;
d4280 1
a4280 22
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 4)
    power_of_two = 4;

  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
    {
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
	return FALSE;
    }

  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.213
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d1715 4
a2387 7
enum ppc_elf_plt_type {
  PLT_UNSET,
  PLT_OLD,
  PLT_NEW,
  PLT_VXWORKS
};

d2407 6
d2416 3
a2435 3
  /* Whether we can use the new PLT layout.  */
  unsigned int can_use_new_plt:1;

a2438 9
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;

  /* The (unloaded but important) .rela.plt.unloaded on VxWorks.  */
  asection *srelplt2;

  /* The .got.plt section (VxWorks only)*/
  asection *sgotplt;

d2440 1
a2440 1
  int is_vxworks;
d2448 3
a2521 2
  
  ret->is_vxworks = 0;
d3291 1
a3291 1
	      bfd_vma addend = r_type == R_PPC_PLTREL24 ? rel->r_addend : 0;
d3293 5
d3322 1
a3322 1
	  htab->can_use_new_plt = 1;
d3351 4
a3354 1
	    htab->plt_type = PLT_OLD;
d3408 4
a3411 1
		htab->plt_type = PLT_OLD;
d3426 4
a3429 1
		htab->plt_type = PLT_OLD;
d3683 1
a3683 1
			   int force_old_plt,
d3692 31
a3722 2
    htab->plt_type = (force_old_plt || !htab->can_use_new_plt
		      ? PLT_OLD : PLT_NEW);
@


1.212
log
@	PR ld/4267
	* elf32-ppc.c (allocate_dynrelocs): Set plt.offset to -1 for
	unused entries.  Don't clear plt.plist in loop.
@
text
@d28 1
a30 1
#include "sysdep.h"
@


1.211
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d4503 3
d4507 5
a4511 6
	    if (!doneone)
	      {
		h->plt.plist = NULL;
		h->needs_plt = 0;
	      }
	  }
@


1.210
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d1581 16
d7516 1
@


1.209
log
@	* elf-bfd.h (struct elf_backend_data): Add elf_backend_write_core_note.
	* elfxx-target.h (elf_backend_write_core_note): Define and use.
	* elf.c (elfcore_write_prpsinfo): Call the above.  Add support for
	32-bit core note on 64-bit target.
	(elfcore_write_prstatus): Likewise.
	(elfcore_write_lwpstatus): Make note_name const.
	(elfcore_write_prfpreg): Likewise.
	(elfcore_write_pstatus): Add support for 32-bit core note on 64-bit
	target.
	* elf32-ppc.c (ppc_elf_write_core_note): New function.
	(elf_backend_write_core_note): Define.
	* elf64-ppc.c (ppc64_elf_write_core_note): New function.
	(elf_backend_write_core_note): Define.
@
text
@d3 1
a3 1
   2004, 2005, 2006 Free Software Foundation, Inc.
a5566 23
  if (info->relocatable)
    {
      if (got2 == NULL)
	return TRUE;

      rel = relocs;
      relend = relocs + input_section->reloc_count;
      for (; rel < relend; rel++)
	{
	  enum elf_ppc_reloc_type r_type;

	  r_type = ELF32_R_TYPE (rel->r_info);
	  if (r_type == R_PPC_PLTREL24
	      && rel->r_addend >= 32768)
	    {
	      /* R_PPC_PLTREL24 is rather special.  If non-zero, the
		 addend specifies the GOT pointer offset within .got2.  */
	      rel->r_addend += got2->output_offset;
	    }
	}
      return TRUE;
    }

d5620 27
a6231 3
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
a6232 7
	  if (r_symndx == 0)
	    {
	      _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	      break;
	    }
	  /* Fall thru.  */

@


1.208
log
@	* bfd-in2.h: Regenerate.
	* bfd-in.h (bfd_arm_vfp11_fix): New enum. Specify how VFP11
	instruction scanning should be done.
	(bfd_elf32_arm_init_maps, bfd_elf32_arm_vfp11_erratum_scan)
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Add prototypes.
	(bfd_elf32_arm_set_target_relocs): Add vfp11 fix type argument to
	prototype.
	* elf-bfd.h (elf_backend_write_section): Add struct bfd_link_info
	argument.
	* elf32-arm.c (VFP11_ERRATUM_VENEER_SECTION_NAME)
	(VFP11_ERRATUM_VENEER_ENTRY_NAME): Define macros.
	(elf32_vfp11_erratum_type): New enum.
	(elf32_vfp11_erratum_list): New struct. List of veneers or jumps to
	veneers.
	(_arm_elf_section_data): Add mapsize, erratumcount, erratumlist.
	(elf32_arm_link_hash_table): Add vfp11_erratum_glue_size,
	vfp11_fix and num_vfp11_fixes fields.
	(elf32_arm_link_hash_table_create): Initialise vfp11_fix,
	vfp11_erratum_glue_size, num_vfp11_fixes fields.
	(VFP11_ERRATUM_VENEER_SIZE): Define. Size of an (ARM) veneer.
	(bfd_elf32_arm_allocate_interworking_sections): Initialise erratum
	glue section.
	(elf32_arm_section_map_add): Add an code/data mapping symbol entry
	to a section's map.
	(record_vfp11_erratum_veneer): Create a single veneer, and its
	associated symbols.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Add vfp11 erratum glue.
	(bfd_elf32_arm_init_maps): Initialise mapping symbol table for input
	BFDs.
	(bfd_elf32_arm_set_vfp11_fix): Set the type of erratum workaround
	required.
	(bfd_arm_vfp11_pipe): Define VFP11 instruction pipes.
	(bfd_arm_vfp11_regno): Recode a register number from a VFP11 insn.
	(bfd_arm_vfp11_write_mask): Update write mask according to coded
	register number.
	(bfd_arm_vfp11_antidependency): New function.
	(bfd_arm_vfp11_insn_decode): Decode a VFP11 insn.
	(elf32_arm_compare_mapping): Declare.
	(bfd_elf32_arm_vfp11_erratum_scan): Scan the sections of an input
	BFD for potential erratum-triggering insns. Record results.
	(bfd_elf32_arm_vfp11_fix_veneer_locations): Find out where veneers
	and branches to veneers have been placed in virtual memory after
	layout.
	(bfd_elf32_arm_set_target_relocs): Set vfp11_fix field in global
	hash table.
	(elf32_arm_output_symbol_hook): Remove.
	(elf32_arm_write_section): Output veneers, and branches to veneers.
	Use maps from input sections, not output sections, for code
	byte-swapping.
	* elf32-ppc.c (ppc_elf_write_section): Add dummy link_info argument.
	* elf32-score.c (_bfd_score_elf_write_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_write_section): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_write_section): Likewise.
@
text
@d28 1
d1817 46
d7526 1
@


1.207
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Fixup D field
	at proper offset in little-endian mode.
	* elf64-ppc.c (ppc_elf_relocate_section): Likewise.
@
text
@d2154 1
@


1.206
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d5507 1
d5634 1
a5634 1
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset - 2);
d5637 1
a5637 1
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset - 2);
d5681 1
d5683 2
a5684 2
		 PPC_TPREL16_LO which is at insn+2.  */
	      rel->r_offset += 2;
d5706 1
a5706 1
		  rel->r_offset -= 2;
d5755 1
a5755 1
				      contents + rel->r_offset - 2);
d5783 1
a5783 1
		      rel[1].r_offset += 2;
d5786 1
a5786 1
		  bfd_put_32 (output_bfd, insn1, contents + rel->r_offset - 2);
@


1.205
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d6183 4
a6186 1
	    break;
@


1.204
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d6283 6
a6288 1
			  BFD_ASSERT (indx > 0);
d6290 1
a6290 1
			  if (indx <= 0)
d7480 1
@


1.203
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3656 1
a3656 1
		      struct bfd_link_info *info ATTRIBUTE_UNUSED,
d3662 6
a3667 24
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_PPC_GNU_VTINHERIT:
	case R_PPC_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d3669 1
a3669 1
  return NULL;
@


1.202
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Correct GOT and PLT HA
	reloc handling.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
@
text
@d1899 10
a1908 10
  { ".plt",              4,  0, SHT_NOBITS,   SHF_ALLOC + SHF_EXECINSTR },
  { ".sbss",             5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".sbss2",            6, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".sdata",            6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".sdata2",           7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".tags",             5,  0, SHT_ORDERED,  SHF_ALLOC },
  { ".PPC.EMB.apuinfo", 16,  0, SHT_NOTE,     0 },
  { ".PPC.EMB.sbss0",   14,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".PPC.EMB.sdata0",  15,  0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,                0,  0, 0,            0 }
d1913 1
a1913 1
  { ".plt",              4,  0, SHT_PROGBITS, SHF_ALLOC };
d3439 1
a3439 1
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d4867 1
a4867 1
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
d6245 1
a6245 1
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
d6448 1
a6448 1
	    if (! ((strncmp (name, ".sdata", 6) == 0
d6450 1
a6450 1
		   || (strncmp (name, ".sbss", 5) == 0
d6476 2
a6477 2
	    if (! (strncmp (name, ".sdata2", 7) == 0
		   || strncmp (name, ".sbss2", 6) == 0))
d6508 1
a6508 1
	    if (((strncmp (name, ".sdata", 6) == 0
d6510 1
a6510 1
		 || (strncmp (name, ".sbss", 5) == 0
d6520 2
a6521 2
	    else if (strncmp (name, ".sdata2", 7) == 0
		     || strncmp (name, ".sbss2", 6) == 0)
@


1.201
log
@	PR ld/2754
	* elf.c (bfd_elf_mkobject): Don't alloc if already done.  Set
	program_header_size to -1.
	(_bfd_elf_map_sections_to_segments): Adjust program_header_size check.
	(assign_file_positions_for_load_sections ): Likewise.
	(_bfd_elf_sizeof_headers): Use saved program_header_size if
	available.
	* elf32-arm.c (elf32_arm_mkobject): Call bfd_elf_mkobject, don't
	alloc if already done.
	* elf32-i386.c (elf_i386_mkobject): Likewise.
	* elf32-ppc.c (ppc_elf_mkobject): Likewise.
	* elf32-s390.c (elf_s390_mkobject): Likewise.
	* elf32-sh.c (sh_elf_mkobject): Likewise.
	* elf64-alpha.c (elf64_alpha_mkobject): Likewise.
	* elf64-ppc.c (ppc64_elf_mkobject): Likewise.
	* elf64-s390.c (elf_s390_mkobject): Likewise.
	* elf64-x86-64.c (elf64_x86_64_mkobject): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_mkobject): Likewise.
@
text
@a6611 2
	case R_PPC_GOT16_HA:
	case R_PPC_PLT16_HA:
a6614 4
	case R_PPC_GOT_TLSGD16_HA:
	case R_PPC_GOT_TLSLD16_HA:
	case R_PPC_GOT_TPREL16_HA:
	case R_PPC_GOT_DTPREL16_HA:
d6621 13
a6633 4
	  if (sec != NULL)
	    /* Add 0x10000 if sign bit in 0:15 is set.
	       Bits 0:15 are not used.  */
	    addend += 0x8000;
@


1.200
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@a1710 2
  bfd_size_type amt = sizeof (struct ppc_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
d1712 7
a1718 2
    return FALSE;
  return TRUE;
@


1.199
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@d1872 2
a1873 1
ppc_elf_additional_program_headers (bfd *abfd)
@


1.198
log
@	PR 2658
	* elf32-ppc.c (ppc_elf_relax_section): Don't segfault on non-pic
	-shared link.
@
text
@d7439 1
@


1.197
log
@	* dwarf2.c: Formatting.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Simplify
	output section check.
	* elf32-i370.c: Warning fixes inside #ifdef DEBUG.
	* elf32-m32c.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-v850.c: Similarly.
	* nlm32-sparc.c: Similarly.
	* elfcode.h: Similarly.
	(elf_symbol_flags): Delete.
	* elflink.c (elf_link_input_bfd): Comment typo.
@
text
@d5184 4
@


1.196
log
@bfd/ChangeLog:
* elf32-ppc.c (ppc_elf_relocate_section): Copy addend from
first relocation to the second when relaxing TLS GD to LE;
zero it out when relaxing to IE.
ld/testsuite/ChangeLog:
* ld-powerpc/tls32.s: Verify that +32768 @@plt addend is
discarded.
@
text
@d6296 1
a6296 1
			    printf ("indx=%d section=%s flags=%08x name=%s\n",
@


1.196.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a5183 4
      /* Attempted -shared link of non-pic code loses.  */
      if (tsec->output_section == NULL)
	continue;

@


1.196.6.1
log
@	PR 2658
	* elf32-ppc.c (ppc_elf_relax_section): Don't segfault on non-pic
	-shared link.
@
text
@a5183 4
      /* Attempted -shared link of non-pic code loses.  */
      if (tsec->output_section == NULL)
	continue;

@


1.195
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d5771 1
a5785 1
			  rel[1].r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
d5792 1
@


1.194
log
@	* elf32-ppc.c (ppc_elf_check_relocs): REL24 and REL14 relocs
	against __GLOBAL_OFFSET_TABLE__ need never be dynamic.  Tweak
	last change to REL32 relocs so that they are counted as
	possibly dynamic as per REL24 and REL14.
@
text
@d3 1
a3 1
   2004, 2005 Free Software Foundation, Inc.
d2433 3
a2435 2
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd,
				       ppc_elf_link_hash_newfunc))
@


1.193
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Don't fall into REL24
	checks from REL32.
@
text
@d3338 1
a3338 1
	  if (h == NULL)
d3340 1
a3340 1
	  goto dodyn;
d3348 1
a3348 1
	  if (h == htab->elf.hgot && htab->plt_type == PLT_UNSET)
d3350 2
a3351 1
	      htab->plt_type = PLT_OLD;
d3367 1
@


1.192
log
@bfd/
	* elf32-ppc.c (is_ppc_elf_target): Return true if the target is
	bfd_elf32_powerpc_vxworks_vec.

ld/testsuite/
	* ld-i386/vxworks1.ld (.data): New section.
	* ld-i386/vxworks1-lib.s: Add a pointer to a local symbol.
	* ld-i386/vxworks1-lib.rd: Test for the associated reloc.
	* ld-powerpc/vxworks1.ld (.data): New section.
	* ld-powerpc/vxworks1-lib.s: Add a pointer to a local symbol.
	* ld-powerpc/vxworks1-lib.rd: Test for the associated reloc.
@
text
@d3338 3
a3340 1
	  /* fall through */
@


1.191
log
@bfd/
	* elf32-i386.c (elf_i386_create_dynamic_sections): Use
	elf_vxworks_create_dynamic_sections.
	(elf_i386_size_dynamic_sections): Remove VxWorks GOT and PLT
	symbol handling.
	* elf32-ppc.c (ppc_elf_create_dynamic_sections): Use
	elf_vxworks_create_dynamic_sections.
	(ppc_elf_size_dynamic_sections): Remove VxWorks GOT and PLT
	symbol handling.
	* elf-vxworks.c (elf_vxworks_create_dynamic_sections): New function.
	* elf-vxworks.h (elf_vxworks_create_dynamic_sections): Declare.

ld/testsuite/
	* ld-i386/ld-i386/vxworks1-lib.nd: New test.
	* ld-i386/i386.exp: Run it.
	* ld-powerpc/ld-powerpc/vxworks1-lib.nd: New test.
	* ld-powerpc/powerc.exp: Run it.
@
text
@d2682 1
d2685 3
a2687 1
  return targ == &bfd_elf32_powerpc_vec || targ == &bfd_elf32_powerpcle_vec;
@


1.190
log
@bfd/
	* elf32-i386.c (elf_i386_vxworks_link_output_symbol_hook): Delete.
	(elf_backend_link_output_symbol_hook): Use
	elf_vxworks_link_output_symbol_hook instead.
	* elf32-ppc.c (elf_i386_vxworks_link_output_symbol_hook): Delete.
	(elf_backend_link_output_symbol_hook): Use
	elf_vxworks_link_output_symbol_hook instead.
	* elf-vxworks.c (elf_vxworks_link_output_symbol_hook): Provide the
	same interface as elf_backend_link_output_symbol_hook.
	* elf-vxworks.h (elf_vxworks_link_output_symbol_hook): Update
	prototype accordingly.
@
text
@d2551 3
a2553 13
  /* Create the section for VxWorks static plt relocations.  */
  if (htab->is_vxworks && !info->shared)
    {
      s = bfd_make_section (abfd, ".rela.plt.unloaded");
      flags = (SEC_HAS_CONTENTS | SEC_IN_MEMORY | SEC_READONLY
	       | SEC_LINKER_CREATED);
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags)
	  || ! bfd_set_section_alignment (abfd, s,
		  get_elf_backend_data (abfd)->s->log_file_align))
	return FALSE;
      htab->srelplt2 = s;
    }
a4756 15
  if (htab->is_vxworks)
    {
      /* Mark the GOT and PLT symbols as having relocations; they might
	 not, but we won't know for sure until we build the GOT in
	 finish_dynamic_symbol.  */
      if (htab->elf.hgot)
	htab->elf.hgot->indx = -2;
      if (htab->elf.hplt)
	{
	  htab->elf.hplt->indx = -2;
	  if (htab->plt->flags & SEC_CODE)
	    htab->elf.hplt->type = STT_FUNC;
	}
    }

@


1.189
log
@bfd/
	* elf32-ppc.c (ppc_elf_plt_type): New enumeration.
	(ppc_elf_link_hash_table): Replace old_got and new_got with
	plt_type and can_use_new_plt.
	(ppc_elf_create_dynamic_sections): Add SEC_HAS_CONTENTS,
	SEC_LOAD and SEC_READONLY to the VxWorks .plt flags.
	(ppc_elf_check_relocs): Set can_use_new_plt instead of new_plt.
	Move from plt_type == PLT_UNSET to PLT_OLD instead of setting old_plt.
	(ppc_elf_select_plt_layout): Move from plt_type == PLT_UNSET to
	either plt_type == PLT_OLD or plt_type == PLT_NEW.  Assert that
	this function should not be called for VxWorks targets.
	(ppc_elf_tls_setup): Use plt_type instead of old_got.
	(allocate_got): Likewise.  Rearrange so that max_before_header
	is only used for PLT_OLD and PLT_NEW.
	(allocate_dynrelocs): Use plt_type instead of old_got and is_vxworks.
	(ppc_elf_size_dynamic_sections): Likewise.
	(ppc_elf_relax_section): Likewise.
	(ppc_elf_relocate_section): Likewise.
	(ppc_elf_finish_dynamic_symbol): Likewise.
	(ppc_elf_vxworks_link_hash_table_create): Initialize plt_type.

ld/
	* emulparams/elf32ppccommon.sh: New file, extracted from...
	* emulparams/elf32ppc.sh: ...here.
	* emulparams/elf32ppcvxworks.sh: Include elf32ppccommon.sh
	instead of elf32ppc.sh.
	(BSS_PLT): Remove override.
	* Makefile.am (eelf32lppc.c): Depend on elf32ppccommons.h.
	(eelf32lppcnto.c, eelf32lppcsim.c, eelf32ppcnto.c): Likewise.
	(eelf32ppc.c, eelf32ppc_fbsd.c, eelf32ppcsimm): Likewise.
	(eelf32ppclinux.c): Likewise.
	(eelf32ppcvxworks.c): Likewise.  Add missing vxworks.sh dependency.
	* Makefile.in: Regenerate.

ld/testsuite/
	* ld-powerpc/vxworks1-lib.s, ld-powerpc/vxworks1-lib.dd,
	* ld-powerpc/vxworks1-lib.rd, ld-powerpc/vxworks1.s,
	* ld-powerpc/vxworks1.dd, ld-powerpc/vxworks1.rd,
	* ld-powerpc/vxworks1.ld, ld-powerpc/vxworks1.sd: New test.
	* ld-powerpc/powerpc.exp: Run it.
@
text
@a7560 17
/* Tweak magic VxWorks symbols as they are written to the output file.  */
static bfd_boolean
elf_i386_vxworks_link_output_symbol_hook (struct bfd_link_info *info
					   ATTRIBUTE_UNUSED,
					 const char *name,
					 Elf_Internal_Sym *sym,
					 asection *input_sec ATTRIBUTE_UNUSED,
					 struct elf_link_hash_entry *h
					   ATTRIBUTE_UNUSED)
{
  /* Ignore the first dummy symbol.  */
  if (!name)
    return TRUE;

  return elf_vxworks_link_output_symbol_hook (name, sym);
}

d7591 1
a7591 1
  elf_i386_vxworks_link_output_symbol_hook
@


1.188
log
@bfd/
	* elf-bfd.h (elf_link_hash_table): Add hplt field.
	* elflink.c (_bfd_elf_create_dynamic_sections): Initialize it.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-m32r.c (m32r_elf_create_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_create_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_create_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_create_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table): Remove hgot and hplt.
	(elf_i386_link_hash_table_create): Don't initialize them.
	(elf_i386_size_dynamic_sections): Use the generic ELF hplt and
	hgot fields.
	(elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_link_hash_table): Remove hplt.
	(ppc_elf_size_dynamic_sections): Use the generic ELF hplt fields.
	(ppc_elf_finish_dynamic_symbol): Likewise.
@
text
@d2316 7
d2359 5
a2363 3
  /* Whether to use new plt/got layout or not.  */
  unsigned int new_plt:1;
  unsigned int old_plt:1;
d2571 3
d3260 1
a3260 1
	  htab->new_plt = 1;
d3288 2
a3289 2
	  if (h && h == htab->elf.hgot)
	    htab->old_plt = 1;
d3330 1
a3330 1
	      && !htab->old_plt)
d3343 1
a3343 1
		htab->old_plt = 1;
d3353 1
a3353 1
	  if (h == htab->elf.hgot)
d3355 1
a3355 1
	      htab->old_plt = 1;
d3615 4
a3618 2
  if (force_old_plt || !htab->new_plt)
    htab->old_plt = 1;
d3622 1
a3622 5
  if (htab->is_vxworks)
    {
      /* The VxWorks PLT is a loaded section with contents.  */
      flags = SEC_ALLOC | SEC_CODE | SEC_IN_MEMORY | SEC_LINKER_CREATED
	      | SEC_HAS_CONTENTS | SEC_LOAD | SEC_READONLY;
d3624 1
a3624 5
      if (htab->plt != NULL
	  && !bfd_set_section_flags (htab->elf.dynobj, htab->plt, flags))
	return -1;
    }
  else if (!htab->old_plt)
d3646 1
a3646 1
  return !htab->old_plt;
d3834 1
a3834 1
  if (!htab->old_plt
d4278 1
a4278 4
  unsigned int max_before_header = 32768;

  if (htab->old_plt)
    max_before_header = 32764;
d4280 1
a4280 1
  if (htab->is_vxworks)
a4284 5
  else if (need <= htab->got_gap)
    {
      where = max_before_header - htab->got_gap;
      htab->got_gap -= need;
    }
d4287 2
a4288 2
      if (htab->got->size + need > max_before_header
	  && htab->got->size <= max_before_header)
d4290 13
a4302 2
	  htab->got_gap = max_before_header - htab->got->size;
	  htab->got->size = max_before_header + htab->got_header_size;
a4303 2
      where = htab->got->size;
      htab->got->size += need;
d4350 1
a4350 1
		if (!(htab->old_plt || htab->is_vxworks))
d4414 1
a4414 1
			if (!htab->is_vxworks
d4428 1
a4428 1
		    if (htab->is_vxworks)
d4669 1
a4669 1
  if (htab->old_plt)
d4671 1
a4671 1
  else
d4785 1
a4785 1
  if (htab->got != NULL && !htab->is_vxworks)
d4796 1
a4796 1
	  if (htab->old_plt)
d5132 1
a5132 1
		  if (!htab->old_plt)
d6347 1
a6347 1
	    if (!htab->old_plt)
d6437 1
a6437 1
	    if (!htab->old_plt)
d6757 1
a6757 1
	    if (!(htab->old_plt || htab->is_vxworks))
d6764 1
a6764 1
		    && !htab->is_vxworks)
d6770 1
a6770 1
	    if (htab->is_vxworks)
d6904 1
a6904 1
		if (htab->old_plt)
d6942 1
a6942 1
	if (!htab->old_plt)
d7164 1
a7164 1
      if (htab->old_plt && !htab->is_vxworks)
d7536 1
@


1.187
log
@	* elf32-ppc.c (allocate_dynrelocs): Tweak undef weak handling.
	* elf64-ppc.c (allocate_dynrelocs): Likewise.
@
text
@a2367 3
  /* Short-cuts to frequently used symbols on VxWorks targets.  */
  struct elf_link_hash_entry *hplt;

d4762 2
a4763 3
      /* Save the PLT symbol in the hash table for easy access.
	 Mark GOT and PLT syms as having relocations; they might not,
	 but we won't know for sure until we build the GOT in
a4764 1

d4767 6
a4772 8
      htab->hplt = elf_link_hash_lookup (elf_hash_table (info),
					 "_PROCEDURE_LINKAGE_TABLE_",
					 FALSE, FALSE, FALSE);
      if (htab->hplt)
	htab->hplt->indx = -2;
      /* If the PLT is executable then give the symbol function type.  */
      if (htab->hplt && htab->plt->flags & SEC_CODE)
       htab->hplt->type = STT_FUNC;
d4863 1
a4863 1
	  if ((s == htab->plt || s == htab->got) && htab->hplt != NULL)
d6876 1
a6876 1
		    rela.r_info = ELF32_R_INFO (htab->hplt->indx,
d7244 1
a7244 1
	      rel.r_info = ELF32_R_INFO (htab->hplt->indx, R_PPC_ADDR32);
@


1.186
log
@	PR ld/2218
	* elf64-ppc.c (allocate_dynrelocs): Ensure undef weak sym is
	dynamic.
	(ppc64_elf_relocate_section): Check output reloc section size.
	* elf32-ppc.c (allocate_dynrelocs): Simplify undef weak test.
@
text
@d4549 2
a4550 1
      if (h->root.type == bfd_link_hash_undefweak)
@


1.185
log
@	* elf32-ppc.c (add_stub_sym): Pass info rather than htab.
	Use different names for pic vs non-pic, '.' instead of '_'.
	(allocate_dynrelocs): Adjust add_stub_sym call.
@
text
@d4549 1
a4549 11
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;

      /* Make sure undefined weak symbols are output as a dynamic symbol
	 in PIEs.  */
      if (info->pie
	  && eh->dyn_relocs != NULL
	  && h->dynindx == -1
	  && h->root.type == bfd_link_hash_undefweak
	  && !h->forced_local)
d4551 11
a4561 2
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
@


1.184
log
@bfd/
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Add emit_stub_syms.
	(ppc_elf_select_plt_layout): Add emit_stub_syms param, save to htab.
	(add_stub_sym): New function.
	(allocate_dynrelocs): Call add_stub_sym.
	(ppc_elf_size_dynamic_sections): Emit __glink and __glink_PLTresolve
	when emit_stub_syms.
	* elf32-ppc.h (ppc_elf_select_plt_layout): Update prototype.
ld/
	* emultempl/ppc32elf.em (emit_stub_syms): New var.
	(ppc_after_open): Pass it to ppc_elf_select_plt_layout.
	(PARSE_AND_LIST_PROLOGUE <OPTION_STUBSYMS>): Define.
	(PARSE_AND_LIST_LONGOPTS): Add emit-stub-syms.
	(PARSE_AND_LIST_OPTIONS): Describe emit-stub-syms.
	(PARSE_AND_LIST_OPTIONS): Handle it.
@
text
@d4216 5
a4220 4
/* Generate a symbol to mark plt call stubs, of the form
   xxxxxxxx_plt_call_<callee> where xxxxxxxx is a hex number, usually 0,
   specifying the addend on the plt relocation, or for -fPIC,
   xxxxxxxx.got2_plt_call_<callee>.  */
d4225 1
a4225 1
	      struct ppc_elf_link_hash_table *htab)
d4230 7
d4239 1
a4239 1
  len2 = sizeof ("plt_call_") - 1;
d4243 1
a4243 1
  name = bfd_malloc (len1 + len2 + len3 + 10);
d4249 2
a4250 3
  name[len3 + 8] = '_';
  memcpy (name + len3 + 9, "plt_call_", len2);
  memcpy (name + len3 + 9 + len2, h->root.root.string, len1 + 1);
d4371 1
a4371 1
			&& !add_stub_sym (ent, h, htab))
@


1.183
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d2356 3
d3599 2
a3600 1
			   int force_old_plt)
d3609 2
d4216 45
d4362 4
d4805 35
@


1.182
log
@	* elf32-ppc.c (ppc_elf_fake_sections): Don't set SHF_EXCLUDE on
	group sections.
@
text
@d2568 1
a2568 1
ppc_elf_copy_indirect_symbol (const struct elf_backend_data *bed ATTRIBUTE_UNUSED,
a2572 1
  bfd_signed_vma tmp;
d2584 1
a2584 4
	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
d2630 2
a2631 8
  tmp = edir->elf.got.refcount;
  if (tmp < 1)
    {
      edir->elf.got.refcount = eind->elf.got.refcount;
      eind->elf.got.refcount = tmp;
    }
  else
    BFD_ASSERT (eind->elf.got.refcount < 1);
d2662 1
a2662 1
  if (edir->elf.dynindx == -1)
d2664 3
a2671 2
  else
    BFD_ASSERT (eind->elf.dynindx == -1);
@


1.181
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d1859 1
a1859 1
  if ((asect->flags & SEC_EXCLUDE) != 0)
@


1.180
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d3472 2
d3479 2
a3480 2
		  head = ((struct ppc_elf_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
@


1.179
log
@bfd/
	* elf32-ppc.c (struct elf_linker_section): Replace sym_val field
	with sym.
	(ppc_elf_relocate_section): Adjust for above.
	(create_sdata_sym): New function.
	(ppc_elf_create_linker_section): Call it.
	(ppc_elf_check_relocs): Correct has_sda_refs and non_got_refs.
	Create sdata syms for all SDA relocs.
	(ppc_elf_adjust_dynamic_symbol): Don't special case _SDA_BASE_
	and _SDA2_BASE_.
	(ppc_elf_set_sdata_syms): Delete.
	* elflink.c (bfd_elf_size_dynamic_sections): Don't create DT_INIT
	and DT_FINI tags unless associated section has input.
	(bfd_elf_set_symbol, _bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in.h (_bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_do_assignments, do_assignments_default): Delete.
	* ldemul.h (ldemul_do_assignments, do_assignments_default): Delete.
	(struct ld_emulation_xfer_struct): Remove do_assignments field.
	* ldlang.c (lang_do_assignments): Don't call ldemul_do_assignments.
	* emulparams/elf32ppc.sh (SDATA_START_SYMBOLS): New.
	(SDATA2_START_SYMBOLS, SBSS_START_SYMBOLS, SBSS_END_SYMBOLS): New.
	* emultempl/aix.em (ld_*_emulation): Delete do_assignments init.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise.
	(gld*_provide_bound_symbols): Delete.
	(gld*_provide_init_fini_syms): Delete.
	(gld*_before_allocation): Don't call ldemul_do_assignments.
	* emultempl/ppc32elf.em (ppc_do_assignments): Delete.
	(LDEMUL_DO_ASSIGNMENTS): Delete.
	* scripttempl/elf.sc: Provide init/fini syms.  Add SBSS_START_SYMBOLS,
	SBSS_END_SYMBOLS, SDATA2_START_SYMBOLS.
@
text
@d4150 7
@


1.178
log
@	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove hgot.  Use
	elf.hgot throughout file.
@
text
@d1671 2
a1672 2
  /* Value of symbol.  */
  bfd_vma sym_val;
d2737 14
d2777 1
a2777 1
  return TRUE;
d3107 5
d3128 5
d3136 15
d3152 15
d3169 18
d3198 1
a3198 5
	    {
	      ppc_elf_hash_entry (h)->has_sda_refs = TRUE;
	      /* We may need a copy reloc.  */
	      h->non_got_ref = TRUE;
	    }
a4116 18
  /* First, a fudge for old shared libs that export some symbols they
     should not.  */
  if (!h->def_regular
      && (strcmp (h->root.root.string, "_SDA_BASE_") == 0
	  || strcmp (h->root.root.string, "_SDA2_BASE_") == 0))
    {
      /* These symbols will be defined later, as if they were defined in
	 a linker script.  We don't want to use a definition in a shared
	 object.  */
      const struct elf_backend_data *bed;

      bed = get_elf_backend_data (htab->elf.dynobj);
      (*bed->elf_backend_hide_symbol) (info, h, TRUE);
      h->root.type = bfd_link_hash_undefined;
      h->root.u.undef.abfd = htab->elf.dynobj;
      return TRUE;
    }

a5311 46
/* Set _SDA_BASE_, _SDA2_BASE, and sbss start and end syms.  They are
   set here rather than via PROVIDE in the default linker script,
   because using PROVIDE inside an output section statement results in
   unnecessary output sections.  Using PROVIDE outside an output section
   statement runs the risk of section alignment affecting where the
   section starts.  */

void
ppc_elf_set_sdata_syms (bfd *obfd, struct bfd_link_info *info)
{
  struct ppc_elf_link_hash_table *htab;
  unsigned i;
  asection *s;
  bfd_vma val;

  htab = ppc_elf_hash_table (info);

  for (i = 0; i < 2; i++)
    {
      elf_linker_section_t *lsect = &htab->sdata[i];

      s = lsect->section;
      if (s != NULL)
	s = s->output_section;
      if (s == NULL)
	s = bfd_get_section_by_name (obfd, lsect->name);
      if (s == NULL)
	s = bfd_get_section_by_name (obfd, lsect->bss_name);

      if (s)
	{
	  /* VxWorks executables are relocatable, so the sdata base symbols
	     must be section-relative.  */
	  val = 32768;
	  lsect->sym_val = val + s->vma;
	}
      else
	{
	  val = 0;
	  lsect->sym_val = 0;
	}

      _bfd_elf_provide_symbol (info, lsect->sym_name, val, s);
    }
}

d6355 1
d6372 4
a6375 1
	    addend -= htab->sdata[0].sym_val;
d6383 1
d6402 4
a6405 1
	    addend -= htab->sdata[1].sym_val;
d6415 1
d6425 4
a6428 1
		addend -= htab->sdata[0].sym_val;
d6435 4
a6438 1
		addend -= htab->sdata[1].sym_val;
@


1.177
log
@	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Correct value of
	_GLOBAL_OFFSET_TABLE_ for > 32k GOT.
@
text
@d2366 1
a2366 1
  struct elf_link_hash_entry *hgot, *hplt;
d4653 4
a4656 3
      /* Save the GOT and PLT symbols in the hash table for easy access.
	 Mark them as having relocations; they might not, but we won't
	 know for sure until we build the GOT in finish_dynamic_symbol.  */
d4658 2
a4659 5
      htab->hgot = elf_link_hash_lookup (elf_hash_table (info),
					 "_GLOBAL_OFFSET_TABLE_",
					 FALSE, FALSE, FALSE);
      if (htab->hgot)
	htab->hgot->indx = -2;
d6681 5
a6685 4
		    bfd_vma got_loc = (got_offset
			+ htab->hgot->root.u.def.value
			+ htab->hgot->root.u.def.section->output_offset
			+ htab->hgot->root.u.def.section->output_section->vma);
d6746 1
a6746 1
		    rela.r_info = ELF32_R_INFO (htab->hgot->indx,
d6756 1
a6756 1
		    rela.r_info = ELF32_R_INFO (htab->hgot->indx,
d7047 1
a7047 1
      p += elf_hash_table (info)->hgot->root.u.def.value;
d7070 3
a7072 3
	    (htab->hgot->root.u.def.section->output_section->vma
	     + htab->hgot->root.u.def.section->output_offset
	     + htab->hgot->root.u.def.value);
d7103 1
a7103 1
	  rela.r_info = ELF32_R_INFO (htab->hgot->indx, R_PPC_ADDR16_HA);
d7112 1
a7112 1
	  rela.r_info = ELF32_R_INFO (htab->hgot->indx, R_PPC_ADDR16_LO);
d7125 1
a7125 1
	      rel.r_info = ELF32_R_INFO (htab->hgot->indx, R_PPC_ADDR16_HA);
d7130 1
a7130 1
	      rel.r_info = ELF32_R_INFO (htab->hgot->indx, R_PPC_ADDR16_LO);
@


1.176
log
@	* elf-bfd.h (struct elf_backend_data): Add action_discarded.
	(enum action_discarded): Move from..
	* elflink.c (enum action_discarded): ..here.
	(_bfd_elf_default_action_discarded): Rename from elf_action_discarded.
	Remove target specific section checks.
	(elf_link_input_bfd): Adjust.
	* elfxx-target.h (elf_backend_action_discarded): Define.
	(elfNN_bed): Init new field.
	* bfd-in.h (_bfd_elf_default_action_discarded): Declare.
	* bfd-in2.h: Regenerate.
	* elf-hppa.h (elf_hppa_action_discarded): New function.
	* elf32-hppa.c (elf_backend_action_discarded): Define.
	* elf64-hppa.c (elf_backend_action_discarded): Define.
	* elf32-ppc.c (ppc_elf_action_discarded): New function.
	(elf_backend_action_discarded): Define.
@
text
@d4679 4
a4682 1
      /* If we haven't allocated the header, do so now.  */
d4686 2
a4689 2
      if (htab->old_plt && !htab->is_vxworks)
	g_o_t += 4;
@


1.175
log
@	* elflink.c (elf_gc_mark_dynamic_ref_symbol): Handle -shared.
	(bfd_elf_gc_sections): Allow -gc-sections when -shared.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Correct for -shared.
@
text
@d5306 15
d7378 1
@


1.174
log
@bfd/
	* elf32-ppc.c (ppc_elf_set_sdata_syms): Return void.  Remove hack
	for zero size sections.  Don't set .sbss syms here.
	* elf32-ppc.h (ppc_elf_set_sdata_syms): Adjust prototype.
ld/
	* emultempl/elf32.em (gld*_provide_init_fini_syms): Prototype.
	(gld*_before_allocation): Call ldemul_do_assignments rather than
	gld*_provide_init_fini_syms directly.
	* emultempl/ppc32elf.em (gld*_after_allocation): Delete.
	(ppc_do_assignments): New function.
	(LDEMUL_AFTER_ALLOCATION): Don't define.
	(LDEMUL_DO_ASSIGNMENTS): Define.
@
text
@d3731 3
d3736 1
@


1.173
log
@bfd/
	* bfd-in.h (_bfd_elf_fix_excluded_sec_syms): Declare.
	(_bfd_elf_provide_section_bound_symbols): Remove param name.
	Formatting.
	* bfd-in2.h: Regenerate.
	* elflink.c (bfd_elf_gc_sections): Don't call generic function.
	(_bfd_elf_provide_symbol): Formatting.
	(_bfd_elf_provide_section_bound_symbols): Remove all hacks, just
	create section relative syms.
	(fix_syms, _bfd_elf_fix_excluded_sec_syms): New functions.
	* elf32-ppc.c (ppc_elf_set_sdata_syms): Use
	_bfd_elf_provide_section_bound_symbols.
	* reloc.c (bfd_mark_used_section): Delete.
	(bfd_generic_gc_sections): Don't call the above.
ld/
	* ldlang.c (strip_excluded_output_sections): Don't call
	bfd_gc_sections.
	* emultempl/elf32.em (gld*_provide_bound_symbols): Move.
	(gld*_provide_init_fini_syms): Move.
	(gld*_before_allocation): Call the above from here..
	(gld*_finish): ..not here.  Call _bfd_elf_fix_excluded_sec_syms.
	* emultempl/hppaelf.em (hppaelf_finish): Likewise.
	* emultempl/ppc64elf.em (ppc_finish): Likewise.
@
text
@d5264 1
a5264 1
bfd_boolean
d5289 1
a5289 3
	     must be section-relative.  If the section is zero sized leave
	     them as absolute symbols to avoid creationg an unused
	     output section.  */
a5291 5
	  if (s->size == 0)
	    {
	      val += s->vma;
	      s = NULL;
	    }
a5300 7

  s = bfd_get_section_by_name (obfd, ".sbss");
  _bfd_elf_provide_section_bound_symbols (info, s,
					  "__sbss_start", "__sbss_end");
  _bfd_elf_provide_section_bound_symbols (info, s,
					  "___sbss_start", "___sbss_end");
  return TRUE;
@


1.172
log
@	* elf32-ppc.c (ppc_elf_set_sdata_syms): Correct __sbss_start value.
@
text
@d5310 4
a5313 7
  val = 0;
  _bfd_elf_provide_symbol (info, "__sbss_start", val, s);
  _bfd_elf_provide_symbol (info, "___sbss_start", val, s);
  if (s != NULL)
    val = s->size;
  _bfd_elf_provide_symbol (info, "__sbss_end", val, s);
  _bfd_elf_provide_symbol (info, "___sbss_end", val, s);
@


1.171
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d5310 3
a5312 2
  _bfd_elf_provide_symbol (info, "__sbss_start", 0, NULL);
  _bfd_elf_provide_symbol (info, "___sbss_start", 0, NULL);
a5314 2
  else
    val = 0;
@


1.170
log
@2005-07-05  Paul Brook  <paul@@codesourcery.com>

	* elf32-ppc.c (ppc_elf_vxworks_special_sections): Remove.
	(ppc_elf_vxworks_get_sec_type_attr): New function.
	(elf_backend_special_sections): Remove vxwords definition.
	(elf_backend_get_sec_type_attr): Define for vxworks.
@
text
@d4711 3
a4713 1
	  || s == htab->sbss)
d4730 1
a4730 13
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	    }
	  else
d4748 9
@


1.169
log
@2005-05-07  Paul Brook  <paul@@codesourcery.com>

bfd/
	* config.bfd: Add separate case for ppc-vxworks.
	* configure: Regenerate.
	* configure.in: Include elf-vxworks.lo on ppc targets.
	* elf-vxworks.c (elf_vxworks_final_write_processing): Handle
	.rela.plt.unloaded.
	* elf32-ppc.c: Add VxWorks target vec.	Include elf-vxworks.h.
	(PLT_ENTRY_SIZE, PLT_INITIAL_ENTRY_SIZE, PLT_SLOT_SIZE): Remove.
	(VXWORKS_PLT_ENTRY_SIZE, ppc_elf_vxworks_plt_entry,
	ppc_elf_vxworks_pic_plt_entry, VXWORKS_PLT_INITIAL_ENTRY_SIZE,
	ppc_elf_vxworks_plt0_entry, ppc_elf_vxworks_pic_plt0_entry,
	VXWORKS_PLT_NON_JMP_SLOT_RELOCS, VXWORKS_PLTRESOLVE_RELOCS,
	VXWORKS_PLTRESOLVE_RELOCS_SHLIB): New.
	(ppc_elf_link_hash_table): Add srelplt2, sgotplt, hgot, hplt,
	is_vxworks, plt_entry_size, plt_slot_size, plt_initial_entry_size.
	(ppc_elf_link_hash_table_create): Initialize hadtab plt fields.
	(ppc_elf_create_got): Create .got.plt for VxWorks.
	(ppc_elf_create_dynamic_sections): Create unloaded plt relocation
	section for VxWorks.
	(ppc_elf_select_plt_layout): Handle VxWorks plt format.
	(allocate_got): VxWorks does not need a got header.
	(allocate_dynrelocs): Handle VxWorks plt format.
	(ppc_elf_size_dynamic_sections): Save _G_O_T_ and _P_L_T_ symbols for
	VxWorks.  Handle VxWorks plt/got.
	(ppc_elf_finish_dynamic_sections): Fill in VxWorks plt.
	(ppc_elf_vxworks_special_sections): New.
	(ppc_elf_vxworks_link_hash_table_create,
	ppc_elf_vxworks_add_symbol_hook,
	elf_i386_vxworks_link_output_symbol_hook,
	ppc_elf_vxworks_final_write_processing): New functions.
	* targets.c (bfd_elf32_powerpc_vxworks_vec): Declare.
	(_bfd_target_vector): Use it.
gas/
	* config/tc-ppc.c (ppc_target_format): Add VxWorks.
gas/testsuite/
	* gas/ppc/altivec.d: Match all powerpc target vecs.
	* gas/ppc/booke.d: Ditto.
	* gas/ppc/e500.d: Ditto.
ld/
	* Makefile.am (ALL_EMULATIONS): Add eelf32ppcvxworks.o.
	(eelf32ppcvxworks.o): Add dependencies.
	* Makefile.in: Regenerate.
	* configure.tgt: Add entry for powerpc-vxworks.
	* emulparams/elf32-ppc.c: Mention elf32ppcvxworks.sh in comment.
	* emulparams/elf32ppcvxworks.sh: New file.
	* emultempl/ppc32elf.em (bfd_elf32_powerpc_vxworks_vec): Declare.
	(is_ppc_elf32_vec): New function.
	(ppc_after_open, ppc_before_allocation,
	gld${EMULATION_NAME}_after_allocation): Use it.
@
text
@d7391 3
a7393 4
/* This is the same as ppc_elf_special_sections except it does not include
   the entry for .plt.  */
static struct bfd_elf_special_section const *
  ppc_elf_vxworks_special_sections[27]=
d7395 8
a7402 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  NULL,				/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  ppc_special_sections_s,	/* 's' */
  ppc_special_sections_t,	/* 's' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  ppc_special_sections_other,	/* other */
};
a7482 3
#undef elf_backend_special_sections
#define elf_backend_special_sections \
  ppc_elf_vxworks_special_sections
d7492 3
@


1.168
log
@	* elf.c (special_sections): Move const qualifier.
	(special_sections_b..special_sections_t): Likewise.
	* elf32-arm.c (elf32_arm_symbian_get_sec_type_attr): Remove duplicate
	const.
	(elf32_arm_symbian_special_sections): Move const qualifier.
	* elf32-m32r.c: Similarly.
	* elf32-m68hc11.c: Similarly.
	* elf32-m68hc12.c: Similarly.
	* elf32-mcore.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sh64.c: Similarly.
	* elf32-v850.c: Similarly.
	* elf32-xtensa.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-hppa.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-sh64.c: Similarly.
	* elfxx-ia64.c: Similarly.
	* elfxx-mips.c: Similarly.
@
text
@d35 1
a55 6
/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 12
/* The initial size of the plt reserved for the dynamic linker.  */
#define PLT_INITIAL_ENTRY_SIZE 72
/* The size of the gap between entries in the PLT.  */
#define PLT_SLOT_SIZE 8
d63 67
d2358 19
d2444 6
d2453 1
a2453 1
/* The powerpc .got has a blrl instruction in it.  Mark it executable.  */
d2470 15
a2484 4
  flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
  if (!bfd_set_section_flags (abfd, s, flags))
    return FALSE;
d2542 14
d3538 1
d3544 11
a3554 1
  if (!htab->old_plt)
d3556 2
a3557 2
      flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			| SEC_IN_MEMORY | SEC_LINKER_CREATED);
d4168 6
a4173 1
  if (need <= htab->got_gap)
d4234 1
a4234 1
		if (!htab->old_plt)
d4265 1
a4265 1
			  s->size += PLT_INITIAL_ENTRY_SIZE;
d4271 5
a4275 4
			plt_offset = (PLT_INITIAL_ENTRY_SIZE
				      + (PLT_SLOT_SIZE
					 * ((s->size - PLT_INITIAL_ENTRY_SIZE)
					    / PLT_ENTRY_SIZE)));
d4290 9
a4298 6
			/* Make room for this entry.  After the 8192nd
			   entry, room for two entries is allocated.  */
			s->size += PLT_ENTRY_SIZE;
			if ((s->size - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
			    > PLT_NUM_SINGLE_ENTRIES)
			  s->size += PLT_ENTRY_SIZE;
d4307 23
d4647 21
d4671 1
a4671 1
  if (htab->got != NULL)
d4681 1
a4681 1
      if (htab->old_plt)
d4702 2
d4710 1
d4713 5
d4756 1
a4756 1
      if (s->size == 0)
d6640 11
d6653 1
a6653 1
	    if (htab->old_plt)
d6655 125
a6779 2
		/* We don't need to fill in the .plt.  The ppc dynamic
		   linker will fill it in.  */
d6783 16
a6798 5
		bfd_vma val = (htab->glink_pltresolve + ent->plt.offset
			       + htab->glink->output_section->vma
			       + htab->glink->output_offset);
		bfd_put_32 (output_bfd, val,
			    htab->plt->contents + ent->plt.offset);
a6801 3
	    rela.r_offset = (htab->plt->output_section->vma
			     + htab->plt->output_offset
			     + ent->plt.offset);
a6804 9
	    if (!htab->old_plt)
	      reloc_index = ent->plt.offset / 4;
	    else
	      {
		reloc_index = ((ent->plt.offset - PLT_INITIAL_ENTRY_SIZE)
			       / PLT_SLOT_SIZE);
		if (reloc_index > PLT_NUM_SINGLE_ENTRIES)
		  reloc_index -= (reloc_index - PLT_NUM_SINGLE_ENTRIES) / 2;
	      }
d6925 5
a6929 3
  if (h == htab->elf.hgot
      || strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
d6960 1
d6963 1
d6970 6
a6975 1
  sdyn = bfd_get_section_by_name (htab->elf.dynobj, ".dynamic");
d6996 1
a6996 1
	  bfd_elf32_swap_dyn_in (htab->elf.dynobj, dyncon, &dyn);
d7001 4
a7004 1
	      s = htab->plt;
d7021 9
d7046 1
a7046 1
      if (htab->old_plt)
d7057 83
d7380 144
@


1.167
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d1831 1
a1831 1
static struct bfd_elf_special_section const ppc_elf_special_sections[] =
d1852 1
a1852 1
  const struct bfd_elf_special_section const *ssect;
@


1.166
log
@	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Ignore dynamic
	_SDA_BASE_ and _SDA2_BASE_ symbols.
	* elflink.c (_bfd_elf_provide_symbol): Correct comment.  Define
	sym if not def_regular.
	(_bfd_elf_provide_section_bound_symbols): Similarly.
@
text
@d1831 1
a1831 2
static struct bfd_elf_special_section const
  ppc_special_sections_p[] =
d1834 2
a1835 6
  { NULL,                0,  0, 0,            0 }
};

static struct bfd_elf_special_section const
  ppc_special_sections_s[] =
{
a1836 1
  { ".sbss",             5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
a1837 7
  { ".sbss2",            6, -2, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  ppc_special_sections_t[] =
{
a1838 6
  { NULL,        0, 0, 0,            0 }
};

static struct bfd_elf_special_section const
  ppc_special_sections_other[]=
{
d1840 1
d1842 1
a1842 2
  { ".PPC.EMB.sbss0",   14,  0, SHT_PROGBITS, SHF_ALLOC },
  { NULL,        0, 0, 0,            0 }
d1845 6
a1850 2
static struct bfd_elf_special_section const *
  ppc_elf_special_sections[27]=
d1852 17
a1868 28
  NULL,				/* 'a' */
  NULL,				/* 'b' */
  NULL,				/* 'c' */
  NULL,				/* 'd' */
  NULL,				/* 'e' */
  NULL,				/* 'f' */
  NULL,				/* 'g' */
  NULL,				/* 'h' */
  NULL,				/* 'i' */
  NULL,				/* 'j' */
  NULL,				/* 'k' */
  NULL,				/* 'l' */
  NULL,				/* 'm' */
  NULL,				/* 'n' */
  NULL,				/* 'o' */
  ppc_special_sections_p,	/* 'p' */
  NULL,				/* 'q' */
  NULL,				/* 'r' */
  ppc_special_sections_s,	/* 's' */
  ppc_special_sections_t,	/* 's' */
  NULL,				/* 'u' */
  NULL,				/* 'v' */
  NULL,				/* 'w' */
  NULL,				/* 'x' */
  NULL,				/* 'y' */
  NULL,				/* 'z' */
  ppc_special_sections_other,	/* other */
};
d6955 1
a6955 1
#define elf_backend_special_sections		ppc_elf_special_sections
@


1.165
log
@2005-06-29  Paul Brook  <paul@@codesourcery.com>

	* bfd-in.h (_bfd_elf_provide_symbol): Update prototype.
	* bfd-in2.h: Regenerate.
	* elf32-ppc.c (ppc_elf_set_sdata_syms): Make sdata symbols section
	relative.
	* elflink.c (bfd_elf_set_symbol): Add section argument.
	(_bfd_elf_provide_symbol): Ditto.
	(_bfd_elf_provide_section_bound_symbols): Pass NULL section argument.
@
text
@d3948 18
@


1.164
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d5111 19
a5129 4
      val = 0;
      if (s != NULL)
	val = s->vma + 32768;
      lsect->sym_val = val;
d5131 1
a5131 1
      _bfd_elf_provide_symbol (info, lsect->sym_name, val);
d5135 2
a5136 1
  val = 0;
d5138 5
a5142 7
    val = s->vma;
  _bfd_elf_provide_symbol (info, "__sbss_start", val);
  _bfd_elf_provide_symbol (info, "___sbss_start", val);
  if (s != NULL)
    val += s->size;
  _bfd_elf_provide_symbol (info, "__sbss_end", val);
  _bfd_elf_provide_symbol (info, "___sbss_end", val);
@


1.163
log
@	* elf32-ppc.c (ppc_elf_check_relocs): For old gcc -fPIC code
	force old plt layout.
@
text
@d2912 6
a2917 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.162
log
@bfd/
	* bfd/elf32-ppc.c (struct ppc_elf_link_hash_entry): Add new field
	has_sda_refs.
	(ppc_elf_copy_indirect_symbol): Copy has_sda_refs.
	(ppc_elf_check_relocs): Set has_sda_refs.
	(ppc_elf_adjust_dynamic_symbol): Check has_sda_refs before eliminating
	copy relocations.  Use has_sda_refs to place variables in .sbss.
	(ppc_elf_finish_dynamic_symbol): Use has_sda_refs to place variables in
	.sbss.
ld/testsuite/
	* ld-powerpc/sdalib.s, ld-powerpc/sdadyn.s, ld-powerpc/sdadyn.d: New
	files.
	* ld-powerpc/powerpc.exp: Run the new test.
@
text
@d3163 22
a3184 3
	  /* When creating a shared object, we must copy these
	     relocs into the output file.  We create a reloc
	     section in dynobj and make room for the reloc.  */
a3188 1
	case R_PPC_REL32:
@


1.161
log
@	* elf32-ppc.c (allocate_dynrelocs): Correct plt offset assigned
	for second and subsequent list entries.  Only allocate multiple
	glink stubs when shared or pie.
	(ppc_elf_finish_dynamic_symbol): Break out early when only one
	glink stub is needed.
@
text
@d2272 4
d2527 1
d3034 6
d3937 5
a3941 1
  if (ELIMINATE_COPY_RELOCS)
a3950 2
      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
d3968 2
a3969 3
     Of course, if the symbol is sufficiently small, we must instead
     allocate it in .sbss.  FIXME: It would be better to do this if and
     only if there were actually SDAREL relocs for that symbol.  */
d3971 1
a3971 1
  if (h->size <= elf_gp_size (htab->elf.dynobj))
d3985 1
a3985 1
      if (h->size <= elf_gp_size (htab->elf.dynobj))
d6559 1
a6559 1
      if (h->size <= elf_gp_size (htab->elf.dynobj))
@


1.160
log
@	* elf-bfd.h (struct elf_link_hash_table): Delete init_refcount and
	init_offset.  Add init_got_refcount, init_plt_refcount,
	init_got_offset and init_plt_offset.
	* elf.c (_bfd_elf_link_hash_newfunc): Adjust for above change.
	(_bfd_elf_link_hash_hide_symbol): Likewise.
	(_bfd_elf_link_hash_table_init): Likewise.
	* elf32-hppa.c (elf32_hppa_hide_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_adjust_dynamic_symbol): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (GLINK_PLTRESOLVE): Now 16 insns.
	(LWZU_0_X_12, LWZ_0_4_30, LWZ_0_X_12, LWZ_11_X_11, LWZ_11_X_30,
	LWZ_12_4_12, LWZ_12_8_30, LWZ_12_X_12, SUB_11_11_30): Delete.
	(ADDIS_12_12, BCL_20_31, LWZU_0_12, LWZ_0_12, LWZ_11_11, LWZ_11_30,
	LWZ_12_12, MFLR_0, MFLR_12, MTLR_0, SUB_11_11_12): Define.
	(struct plt_entry): New.
	(ppc_elf_link_hash_table_create): Set new init_plt fields.
	(ppc_elf_copy_indirect_symbol): Handle merge of plt plist.  Don't
	use _bfd_elf_link_hash_copy_indirect.
	(update_plt_info, find_plt_ent): New functions.
	(ppc_elf_check_relocs): Handle R_PPC_PLTREL24 with non-zero addend
	and adjust for use of plt list rather than refcount.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_tls_optimize): Likewise.
	(ppc_elf_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(ppc_elf_relax_section): Likewise.
	(ppc_elf_relocate_section): Likewise.  Adjust R_PPC_PLTREL24 addends
	when performing a relocatable link.
	(ppc_elf_finish_dynamic_symbol): Likewise.  Write .glink stubs here..
	(ppc_elf_finish_dynamic_sections): ..rather than here.  Use new
	pic resolver stub.
@
text
@d4061 2
a4080 1
		    ent->plt.offset = s->size;
d4082 5
a4086 1
		      s->size += 4;
d4089 7
a4095 1
		    if (!info->shared
d4099 1
a4099 1
			h->root.u.def.value = s->size;
d4101 1
a4101 2
		    ent->glink_offset = s->size;
		    s->size += GLINK_ENTRY_SIZE;
d4105 1
a4105 20
		    /* If this is the first .plt entry, make room for the
		       special first entry.  */
		    if (s->size == 0)
		      s->size += PLT_INITIAL_ENTRY_SIZE;

		    /* The PowerPC PLT is actually composed of two parts, the
		       first part is 2 words (for a load and a jump), and then
		       there is a remaining word available at the end.  */
		    ent->plt.offset = (PLT_INITIAL_ENTRY_SIZE
				       + (PLT_SLOT_SIZE
					  * ((s->size - PLT_INITIAL_ENTRY_SIZE)
					     / PLT_ENTRY_SIZE)));

		    /* If this symbol is not defined in a regular file, and we
		       are not generating a shared library, then set the symbol
		       to this location in the .plt.  This is required to make
		       function pointers compare as equal between the normal
		       executable and the shared library.  */
		    if (! info->shared
			&& !h->def_regular)
d4107 26
a4132 3
			h->root.u.def.section = s;
			h->root.u.def.value = ent->plt.offset;
		      }
d4134 2
a4135 4
		    /* Make room for this entry.  After the 8192nd entry, room
		       for two entries is allocated.  */
		    if (!doneone)
		      {
d4141 1
d6524 3
@


1.159
log
@	* elf32-ppc.c (LIS_11. LIS_12): Define.
	(LWZU_0_X_12, LWZ_0_X_12, LWZ_12_4_12, LWZ_12_X_12): Define.
	(ppc_elf_finish_dynamic_sections): Provide non-pic plt call stub
	for --data-plt when building non-pie executables.
@
text
@d65 1
a65 1
#define GLINK_PLTRESOLVE 12*4
a68 2
#define NOP		0x60000000
#define B		0x48000000
d70 2
a72 1
#define SUB_11_11_30	0x7d7e5850
d75 2
a76 3
#define LWZ_0_4_30	0x801e0004
#define MTCTR_0		0x7c0903a6
#define LWZ_12_8_30	0x819e0008
a77 4
#define ADDIS_11_30	0x3d7e0000
#define LWZ_11_X_11	0x816b0000
#define LWZ_11_X_30	0x817e0000
#define MTCTR_11	0x7d6903a6
d80 12
a91 4
#define LWZU_0_X_12	0x840c0000
#define LWZ_0_X_12	0x800c0000
#define LWZ_12_4_12	0x818c0004
#define LWZ_12_X_12	0x818c0000
d2203 26
d2372 5
d2478 1
a2478 1
ppc_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
d2483 1
d2524 24
a2547 11
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
d2550 40
a2589 1
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d2801 40
d2866 1
a2866 1
  asection *sreloc;
d2892 1
d3059 3
d3063 4
a3066 2
	  h->needs_plt = 1;
	  h->plt.refcount++;
d3090 1
a3090 1
	  /* This are just markers.  */
d3184 2
a3185 1
	      h->plt.refcount++;
d3501 1
d3512 1
d3607 4
a3610 2
	      if (h->plt.refcount > 0)
		h->plt.refcount--;
d3760 3
a3762 2
			if (h->plt.refcount > 0)
			  h->plt.refcount -= 1;
d3870 5
a3874 1
      if (h->plt.refcount <= 0
d3889 1
a3889 1
	  h->plt.offset = (bfd_vma) -1;
d3895 1
a3895 1
    h->plt.offset = (bfd_vma) -1;
d4057 1
a4057 2
  if (htab->elf.dynamic_sections_created
      && h->plt.refcount > 0)
d4059 12
a4070 7
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}
d4072 4
a4075 4
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->plt;
d4077 42
a4118 4
	  if (!htab->old_plt)
	    {
	      h->plt.offset = s->size;
	      s->size += 4;
d4120 10
a4129 35
	      s = htab->glink;
	      if (!info->shared
		  && !h->def_regular)
		{
		  h->root.u.def.section = s;
		  h->root.u.def.value = s->size;
		}
	      s->size += GLINK_ENTRY_SIZE;
	    }
	  else
	    {
	      /* If this is the first .plt entry, make room for the
		 special first entry.  */
	      if (s->size == 0)
		s->size += PLT_INITIAL_ENTRY_SIZE;

	      /* The PowerPC PLT is actually composed of two parts, the
		 first part is 2 words (for a load and a jump), and then
		 there is a remaining word available at the end.  */
	      h->plt.offset = (PLT_INITIAL_ENTRY_SIZE
			       + (PLT_SLOT_SIZE
				  * ((s->size - PLT_INITIAL_ENTRY_SIZE)
				     / PLT_ENTRY_SIZE)));

	      /* If this symbol is not defined in a regular file, and we
		 are not generating a shared library, then set the symbol
		 to this location in the .plt.  This is required to make
		 function pointers compare as equal between the normal
		 executable and the shared library.  */
	      if (! info->shared
		  && !h->def_regular)
		{
		  h->root.u.def.section = s;
		  h->root.u.def.value = h->plt.offset;
		}
d4131 9
a4139 7
	      /* Make room for this entry.  After the 8192nd entry, room
		 for two entries is allocated.  */
	      s->size += PLT_ENTRY_SIZE;
	      if ((s->size - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
		  > PLT_NUM_SINGLE_ENTRIES)
		s->size += PLT_ENTRY_SIZE;
	    }
d4141 6
a4146 8
	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->relplt->size += sizeof (Elf32_External_Rela);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}
d4150 1
a4150 1
      h->plt.offset = (bfd_vma) -1;
d4648 1
d4672 2
a4674 1

d4748 2
d4751 1
a4751 2
	      && htab->plt != NULL
	      && h->plt.offset != (bfd_vma) -1)
d4753 3
a4755 1
	      if (!htab->old_plt)
d4757 10
a4766 7
		  tsec = htab->glink;
		  toff = h->plt.offset * (GLINK_ENTRY_SIZE / 4);
		}
	      else
		{
		  tsec = htab->plt;
		  toff = h->plt.offset;
d4769 2
d4822 2
a4823 1
      else
d5191 1
a5191 1
  asection *sreloc = NULL;
d5203 2
d5206 21
a5226 1
    return TRUE;
d6004 13
a6016 12
	  BFD_ASSERT (h != NULL
		      && h->plt.offset != (bfd_vma) -1
		      && htab->plt != NULL);

	  if (!htab->old_plt)
	    relocation = (htab->glink->output_section->vma
			  + htab->glink->output_offset
			  + h->plt.offset * (GLINK_ENTRY_SIZE / 4));
	  else
	    relocation = (htab->plt->output_section->vma
			  + htab->plt->output_offset
			  + h->plt.offset);
d6083 2
a6084 1
	  BFD_ASSERT (h != NULL);
d6086 9
a6094 8
	  if (h->plt.offset == (bfd_vma) -1
	      || htab->plt == NULL)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }
d6096 10
a6105 9
	  unresolved_reloc = FALSE;
	  if (!htab->old_plt)
	    relocation = (htab->glink->output_section->vma
			  + htab->glink->output_offset
			  + h->plt.offset * (GLINK_ENTRY_SIZE / 4));
	  else
	    relocation = (htab->plt->output_section->vma
			  + htab->plt->output_offset
			  + h->plt.offset);
d6367 4
d6381 2
d6392 45
a6436 5
  if (h->plt.offset != (bfd_vma) -1)
    {
      Elf_Internal_Rela rela;
      bfd_byte *loc;
      bfd_vma reloc_index;
d6438 14
a6451 3
#ifdef DEBUG
      fprintf (stderr, ", plt_offset = %d", h->plt.offset);
#endif
d6453 4
a6456 2
      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */
d6458 4
a6461 2
      BFD_ASSERT (h->dynindx != -1);
      BFD_ASSERT (htab->plt != NULL && htab->relplt != NULL);
d6463 3
a6465 13
      if (htab->old_plt)
	{
	  /* We don't need to fill in the .plt.  The ppc dynamic linker
	     will fill it in.  */
	}
      else
	{
	  bfd_vma val = (htab->glink_pltresolve
			 + h->plt.offset
			 + htab->glink->output_section->vma
			 + htab->glink->output_offset);
	  bfd_put_32 (output_bfd, val, htab->plt->contents + h->plt.offset);
	}
d6467 8
a6474 6
      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (htab->plt->output_section->vma
		       + htab->plt->output_offset
		       + h->plt.offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_PPC_JMP_SLOT);
      rela.r_addend = 0;
d6476 1
a6476 12
      if (!htab->old_plt)
	reloc_index = h->plt.offset / 4;
      else
	{
	  reloc_index = ((h->plt.offset - PLT_INITIAL_ENTRY_SIZE)
			 / PLT_SLOT_SIZE);
	  if (reloc_index > PLT_NUM_SINGLE_ENTRIES)
	    reloc_index -= (reloc_index - PLT_NUM_SINGLE_ENTRIES) / 2;
	}
      loc = (htab->relplt->contents
	     + reloc_index * sizeof (Elf32_External_Rela));
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d6478 38
a6515 13
      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if (!h->ref_regular_nonweak)
	    sym->st_value = 0;
	}
    }
d6666 1
a6666 1
      bfd_vma pltgot, res0;
d6668 57
d6727 4
a6730 2
	  LWZ_0_4_30,
	  SUB_11_11_30,
d6733 1
a6733 1
	  LWZ_12_8_30,
d6738 4
d6745 3
a6747 1
      if (ARRAY_SIZE (plt_resolve) + 2 != GLINK_PLTRESOLVE / 4)
d6750 2
a6751 7
#define PPC_LO(v) ((v) & 0xffff)
#define PPC_HI(v) (((v) >> 16) & 0xffff)
#define PPC_HA(v) PPC_HI ((v) + 0x8000)

      pltgot = htab->plt->output_section->vma + htab->plt->output_offset;

      /* Write the plt call stubs.  */
d6753 1
a6753 48
      endp = p + htab->glink_pltresolve;
      if (info->shared || info->pie)
	{
	  pltgot -= got;

	  while (p < endp)
	    {
	      if (pltgot < 0x8000)
		{
		  bfd_put_32 (output_bfd, LWZ_11_X_30 + pltgot, p);
		  p += 4;
		  bfd_put_32 (output_bfd, MTCTR_11, p);
		  p += 4;
		  bfd_put_32 (output_bfd, BCTR, p);
		  p += 4;
		  bfd_put_32 (output_bfd, NOP, p);
		  p += 4;
		}
	      else
		{
		  bfd_put_32 (output_bfd, ADDIS_11_30 + PPC_HA (pltgot), p);
		  p += 4;
		  bfd_put_32 (output_bfd, LWZ_11_X_11 + PPC_LO (pltgot), p);
		  p += 4;
		  bfd_put_32 (output_bfd, MTCTR_11, p);
		  p += 4;
		  bfd_put_32 (output_bfd, BCTR, p);
		  p += 4;
		}
	      pltgot += 4;
	    }
	}
      else
	while (p < endp)
	  {
	    bfd_put_32 (output_bfd, LIS_11 + PPC_HA (pltgot), p);
	    p += 4;
	    bfd_put_32 (output_bfd, LWZ_11_X_11 + PPC_LO (pltgot), p);
	    p += 4;
	    bfd_put_32 (output_bfd, MTCTR_11, p);
	    p += 4;
	    bfd_put_32 (output_bfd, BCTR, p);
	    p += 4;
	    pltgot += 4;
	  }

      /* Now build the branch table, one for each plt entry (less one),
	 and perhaps some padding.  */
d6774 1
a6774 4
	  bfd_put_32 (output_bfd, ADDIS_11_11 + PPC_HA (got - res0), p);
	  p += 4;
	  bfd_put_32 (output_bfd, ADDI_11_11 + PPC_LO (got - res0), p);
	  p += 4;
d6776 1
a6776 1
	  for (i = 0; i < ARRAY_SIZE (plt_resolve); i++)
d6778 1
a6778 1
	      bfd_put_32 (output_bfd, plt_resolve[i], p);
d6781 26
d6810 1
a6810 22
	  bfd_put_32 (output_bfd, LIS_12 + PPC_HA (got + 4), p);
	  p += 4;
	  bfd_put_32 (output_bfd, ADDIS_11_11 + PPC_HA (-res0), p);
	  p += 4;
	  if (PPC_HA (got + 4) != PPC_HA (got + 8))
	    bfd_put_32 (output_bfd, LWZU_0_X_12 + PPC_LO (got + 4), p);
	  else
	    bfd_put_32 (output_bfd, LWZ_0_X_12 + PPC_LO (got + 4), p);
	  p += 4;
	  bfd_put_32 (output_bfd, ADDI_11_11 + PPC_LO (-res0), p);
	  p += 4;
	  bfd_put_32 (output_bfd, MTCTR_0, p);
	  p += 4;
	  bfd_put_32 (output_bfd, ADD_0_11_11, p);
	  p += 4;
	  if (PPC_HA (got + 4) != PPC_HA (got + 8))
	    bfd_put_32 (output_bfd, LWZ_12_4_12, p);
	  else
	    bfd_put_32 (output_bfd, LWZ_12_X_12 + PPC_LO (got + 8), p);
	  p += 4;

	  for (i = 5; i < ARRAY_SIZE (plt_resolve); i++)
d6815 22
@


1.158
log
@include/elf/
	* ppc.h (DT_PPC_GOT): Rename from DT_PPC_GLINK.
bfd/
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Set DT_PPC_GOT,
	not DT_PPC_GLINK.
	(ppc_elf_finish_dynamic_sections): Likewise.
binutils/
	* readelf.c (get_ppc_dynamic_type): Display DT_PPC_GOT, not
	DT_PPC_GLINK.
@
text
@d84 6
d6403 1
a6403 1
      bfd_vma pltgot;
d6407 1
d6409 1
d6411 1
a6412 3
	  LWZ_0_4_30,
	  MTCTR_0,
	  LWZ_12_8_30,
d6419 3
d6426 1
a6426 3
      pltgot = (htab->plt->output_section->vma
		+ htab->plt->output_offset
		- got);
d6431 1
a6431 1
      while (p < endp)
d6433 3
a6435 1
	  if (pltgot < 0x8000)
d6437 23
a6459 19
	      bfd_put_32 (output_bfd, LWZ_11_X_30 + pltgot, p);
	      p += 4;
	      bfd_put_32 (output_bfd, MTCTR_11, p);
	      p += 4;
	      bfd_put_32 (output_bfd, BCTR, p);
	      p += 4;
	      bfd_put_32 (output_bfd, NOP, p);
	      p += 4;
	    }
	  else
	    {
	      bfd_put_32 (output_bfd, ADDIS_11_30 + PPC_HA (pltgot), p);
	      p += 4;
	      bfd_put_32 (output_bfd, LWZ_11_X_11 + PPC_LO (pltgot), p);
	      p += 4;
	      bfd_put_32 (output_bfd, MTCTR_11, p);
	      p += 4;
	      bfd_put_32 (output_bfd, BCTR, p);
	      p += 4;
a6460 1
	  pltgot += 4;
d6462 13
d6491 1
a6491 1
      got -= (htab->glink_pltresolve
d6496 6
a6501 4
      bfd_put_32 (output_bfd, ADDIS_11_11 + PPC_HA (got), p);
      p += 4;
      bfd_put_32 (output_bfd, ADDI_11_11 + PPC_LO (got), p);
      p += 4;
d6503 7
a6509 1
      for (i = 0; i < ARRAY_SIZE (plt_resolve); i++)
d6511 3
a6513 1
	  bfd_put_32 (output_bfd, plt_resolve[i], p);
d6515 22
a6537 2
      if (ARRAY_SIZE (plt_resolve) + 2 != GLINK_PLTRESOLVE / 4)
	abort ();
@


1.157
log
@	* elf32-ppc.c (LWZU_0_X_11): Delete.
	(B, LWZ_11_X_11, LWZ_11_X_30, MTCTR_11): Define.
	(ppc_elf_select_plt_layout): Set .got flags too.  Formatting.
	(ppc_elf_size_dynamic_sections): Allocate space for .glink branch
	table.
	(ppc_elf_finish_dynamic_symbol): Point .plt entries into the branch
	table.
	(ppc_elf_finish_dynamic_sections): Adjust DT_PPC_GLINK value.
	Generate .glink branch table and updated stubs.
@
text
@d4409 1
a4409 1
	  if (!add_dynamic_entry (DT_PPC_GLINK, 0))
d6316 1
d6325 6
d6362 2
a6363 4
	    case DT_PPC_GLINK:
	      s = htab->glink;
	      dyn.d_un.d_ptr = (s->size - GLINK_PLTRESOLVE
				+ s->output_section->vma + s->output_offset);
d6397 1
a6397 1
      bfd_vma got, pltgot;
a6416 4
      got = (htab->elf.hgot->root.u.def.value
	     + htab->elf.hgot->root.u.def.section->output_section->vma
	     + htab->elf.hgot->root.u.def.section->output_offset);

@


1.156
log
@	* reloc.c (BFD_RELOC_HI16_PCREL): Define.
	(BFD_RELOC_HI16_S_PCREL, BFD_RELOC_LO16_PCREL): Define.
	* elf32-ppc.c (GLINK_PLTRESOLVE, GLINK_ENTRY_SIZE): Define.
	(CROR_151515, CROR_313131): Delete.
	(ADDIS_11_11, ADDI_11_11, SUB_11_11_30, ADD_0_11_11, ADD_11_0_11,
	LWZ_0_4_30, MTCTR_0, LWZ_12_8_30, BCTR, ADDIS_11_30,
	LWZU_0_X_11): Define.
	(ppc_elf_howto_raw): Add R_PPC_REL16, R_PPC_REL16_LO, R_PPC_REL16_HI
	and R_PPC_REL16_HA entries.
	(ppc_elf_reloc_type_lookup): Convert new bfd reloc types.
	(ppc_elf_addr16_ha_reloc): Also handle R_PPC_REL16_HA.
	(struct ppc_elf_link_hash_table): Add glink, glink_pltresolve,
	new_plt, and old_plt.
	(ppc_elf_create_dynamic_sections): Create .glink section.
	(ppc_elf_check_relocs): Set new_plt and old_plt.
	(ppc_elf_select_plt_layout): New function.
	(ppc_elf_tls_setup): Set plt output section elf type and flags.
	(allocate_got): Handle differences between old and new got layout.
	(allocate_dynrelocs): Likewise for plt.
	(ppc_elf_size_dynamic_sections): Likewise.  Allocate memory for
	.glink.  Don't allocate memory for old bss .plt.  Emit DT_PPC_GLINK.
	(ppc_elf_relax_section): Rename ppc_info to htab.  Handle .glink
	destination of R_PPC_PLTREL24 relocs.
	(ppc_elf_relocate_section): Handle new relocs and changed destination
	of R_PPC_PLTREL24.
	(ppc_elf_finish_dynamic_symbol): Init new style plt and handle
	differences in layout.
	(ppc_elf_finish_dynamic_sections): Set DT_PPC_GLINK value.  Don't
	put a blrl in new got.  Write glink contents.
	* elf32-ppc.h (ppc_elf_select_plt_layout): Declare.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d70 1
d81 3
a83 1
#define LWZU_0_X_11	0x840b0000
d3286 2
a3287 5
      /* The new PLT is a loaded section.  Fix its flags.  */
      if (htab->plt != NULL)
	{
	  flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			    | SEC_IN_MEMORY | SEC_LINKER_CREATED);
d3289 9
a3297 3
	  if (!bfd_set_section_flags (htab->elf.dynobj, htab->plt, flags))
	    return -1;
	}
d3302 3
a3304 5
      if (htab->glink != NULL)
	{
	  if (!bfd_set_section_alignment (htab->elf.dynobj, htab->glink, 0))
	    return -1;
	}
d4309 4
d6208 1
d6357 1
a6357 1
	      dyn.d_un.d_ptr = (htab->glink_pltresolve
d6392 1
a6392 1
      bfd_vma pltgot;
d6412 4
d6418 1
a6418 3
		- htab->elf.hgot->root.u.def.value
		- htab->elf.hgot->root.u.def.section->output_section->vma
		- htab->elf.hgot->root.u.def.section->output_offset);
d6420 1
d6422 49
a6470 2
      p += htab->glink_pltresolve;
      bfd_put_32 (output_bfd, ADDIS_11_11 + PPC_HA (-pltgot), p);
d6472 1
a6472 1
      bfd_put_32 (output_bfd, ADDI_11_11 + PPC_LO (-pltgot), p);
a6481 15

      p = htab->glink->contents;
      endp = p + htab->glink_pltresolve;
      while (p < endp)
	{
	  bfd_put_32 (output_bfd, ADDIS_11_30 + PPC_HA (pltgot), p);
	  p += 4;
	  bfd_put_32 (output_bfd, LWZU_0_X_11 + PPC_LO (pltgot), p);
	  p += 4;
	  bfd_put_32 (output_bfd, MTCTR_0, p);
	  p += 4;
	  bfd_put_32 (output_bfd, BCTR, p);
	  p += 4;
	  pltgot += 4;
	}
@


1.155
log
@2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Update special_sections to
	array of pointer to bfd_elf_special_section.
	* elf.c (special_sections): Likewise.
	* elf32-arm.c (elf32_arm_symbian_special_sections): Likewise.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_special_sections): Likewise.

	* elf.c (get_special_section): Updated.
@
text
@d54 1
d64 5
a68 1
/* Some nop instructions.  */
d70 11
a80 2
#define CROR_151515	0x4def7b82
#define CROR_313131	0x4ffffb82
d1276 61
d1496 4
d1522 1
a1522 1
/* Handle the R_PPC_ADDR16_HA reloc.  */
d1552 2
d2248 1
d2267 3
d2275 4
d2398 8
a2405 2
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
d2417 1
a2417 2
      s = bfd_make_section_with_flags (abfd, ".rela.sbss",
				       flags | SEC_READONLY);
d2942 7
d2974 2
d3019 1
a3019 1
	  if (h == NULL || h == htab->elf.hgot)
d3021 5
d3268 37
d3482 8
a3491 1

d3861 4
a3864 1
  unsigned int max_before_header = 32764;
d3921 4
a3924 4
	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->size == 0)
	    s->size += PLT_INITIAL_ENTRY_SIZE;
d3926 10
a3935 15
	  /* The PowerPC PLT is actually composed of two parts, the
	     first part is 2 words (for a load and a jump), and then
	     there is a remaining word available at the end.  */
	  h->plt.offset = (PLT_INITIAL_ENTRY_SIZE
			   + (PLT_SLOT_SIZE
			      * ((s->size - PLT_INITIAL_ENTRY_SIZE)
				 / PLT_ENTRY_SIZE)));

	  /* If this symbol is not defined in a regular file, and we
	     are not generating a shared library, then set the symbol
	     to this location in the .plt.  This is required to make
	     function pointers compare as equal between the normal
	     executable and the shared library.  */
	  if (! info->shared
	      && !h->def_regular)
d3937 31
a3967 2
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
a3969 7
	  /* Make room for this entry.  After the 8192nd entry, room
	     for two entries is allocated.  */
	  s->size += PLT_ENTRY_SIZE;
	  if ((s->size - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
	      > PLT_NUM_SINGLE_ENTRIES)
	    s->size += PLT_ENTRY_SIZE;

d4185 4
a4188 1
  htab->got_header_size = 16;
d4296 2
a4297 1
      g_o_t += 4;
d4302 6
d4317 1
d4365 1
a4365 1
      if (s == htab->sbss)
d4399 6
d4473 1
a4473 1
  struct ppc_elf_link_hash_table *ppc_info;
d4497 1
a4497 1
  ppc_info = ppc_elf_hash_table (link_info);
d4574 1
a4574 1
	      && ppc_info->plt != NULL
d4577 10
a4586 2
	      tsec = ppc_info->plt;
	      toff = h->plt.offset;
d4683 2
a4684 1
	  if (tsec == ppc_info->plt)
d5627 6
d5802 8
a5809 3
	  relocation = (htab->plt->output_section->vma
			+ htab->plt->output_offset
			+ h->plt.offset);
d5888 8
a5895 3
	  relocation = (htab->plt->output_section->vma
			+ htab->plt->output_offset
			+ h->plt.offset);
d6054 1
d6192 12
a6203 2
      /* We don't need to fill in the .plt.  The ppc dynamic linker
	 will fill it in.  */
d6212 9
a6220 3
      reloc_index = (h->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_SLOT_SIZE;
      if (reloc_index > PLT_NUM_SINGLE_ENTRIES)
	reloc_index -= (reloc_index - PLT_NUM_SINGLE_ENTRIES) / 2;
d6346 6
d6368 2
a6369 1
      bfd_put_32 (output_bfd, 0x4e800021 /* blrl */, p - 4);
d6379 61
@


1.154
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Remove got_symbol_offset.
	* elfxx-target.h (elf_backend_got_symbol_offset): Delete.
	* elflink.c (_bfd_elf_create_got_section): Use zero in place of
	got_symbol_offset.
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Likewise.
	* elf32-frv.c (_frv_create_got_section): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Delete ppc code.
	(elf_backend_got_symbol_offset): Don't define.
	* elf64-ppc.c (elf_backend_got_symbol_offset): Don't define.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Add got_header_size
	and got_gap.
	(ppc_elf_create_got): Tidy.
	(ppc_elf_create_dynamic_sections): Don't set SEC_IN_MEMORY for .plt.
	(ppc_elf_check_relocs): Reduce string comparisons by using elf.hgot.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_relocate_section): Likewise.
	(ppc_elf_finish_dynamic_symbol): Likewise.
	(allocate_got): New function.
	(allocate_dynrelocs): Use allocate_got.
	(ppc_elf_size_dynamic_sections): Likewise.  Delay tlsld_got allocation
	so that local got can refcount it.  Set got_header_size.
	(ppc_elf_relocate_section): Use value of elf.hgot rather than hard-
	coded 4.
	(ppc_elf_finish_dynamic_sections): Likewise.
	(elf_backend_got_symbol_offset): Don't define.
	(elf_backend_got_header_size): Ditto.
ld/testsuite/
	* ld-powerpc/tlsexe32.d: Update for changed got layout.
	* ld-powerpc/tlsexe32.g: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
@
text
@d1739 9
a1747 1
static struct bfd_elf_special_section const ppc_elf_special_sections[]=
a1748 1
  { ".tags",             5,  0, SHT_ORDERED,  SHF_ALLOC },
d1753 13
d1769 33
a1801 2
  { ".plt",              4,  0, SHT_NOBITS,   SHF_ALLOC + SHF_EXECINSTR },
  { NULL,                0,  0, 0,            0 }
@


1.153
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d2134 5
d2228 3
a2230 6
  htab->relgot = bfd_make_section_with_flags (abfd, ".rela.got",
					      SEC_ALLOC | SEC_LOAD
					      | SEC_HAS_CONTENTS
					      | SEC_IN_MEMORY
					      | SEC_LINKER_CREATED
					      | SEC_READONLY);
d2262 3
a2264 3
  htab->dynsbss = s = bfd_make_section_with_flags (abfd, ".dynsbss",
						   SEC_ALLOC
						   | SEC_LINKER_CREATED);
d2271 3
a2273 3
      htab->relsbss = s = bfd_make_section_with_flags (abfd,
						       ".rela.sbss",
						       flags | SEC_READONLY);
d2284 1
a2284 1
  flags = SEC_ALLOC | SEC_CODE | SEC_IN_MEMORY | SEC_LINKER_CREATED;
d2631 3
a2633 1
      if (h && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d2635 5
a2639 7
	  if (htab->got == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!ppc_elf_create_got (htab->elf.dynobj, info))
		return FALSE;
	    }
d2865 1
a2865 2
	  if (h == NULL
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d3244 1
a3244 2
	  if (h == NULL
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d3651 28
d3780 1
a3780 1
	  eh->elf.got.offset = htab->got->size;
d3784 1
a3784 1
		htab->got->size += 8;
d3786 1
a3786 1
		htab->got->size += 8;
d3788 1
a3788 1
		htab->got->size += 4;
d3790 1
a3790 1
		htab->got->size += 4;
d3793 2
a3794 1
	    htab->got->size += 4;
d3801 2
a3802 5
	      /* All the entries we allocated need relocs.  */
	      htab->relgot->size
		+= ((htab->got->size - eh->elf.got.offset) / 4
		    * sizeof (Elf32_External_Rela));
	      /* Except LD only needs one.  */
d3804 2
a3805 1
		htab->relgot->size -= sizeof (Elf32_External_Rela);
d3962 1
a3962 9
  if (htab->tlsld_got.refcount > 0)
    {
      htab->tlsld_got.offset = htab->got->size;
      htab->got->size += 8;
      if (info->shared)
	htab->relgot->size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tlsld_got.offset = (bfd_vma) -1;
a3972 1
      asection *srel;
a4013 2
      s = htab->got;
      srel = htab->relgot;
d4021 1
a4021 7
		if (htab->tlsld_got.offset == (bfd_vma) -1)
		  {
		    htab->tlsld_got.offset = s->size;
		    s->size += 8;
		    if (info->shared)
		      srel->size += sizeof (Elf32_External_Rela);
		  }
d4026 1
a4026 1
		*local_got = s->size;
d4030 1
a4030 1
		      s->size += 8;
d4032 1
a4032 1
		      s->size += 4;
d4034 1
a4034 1
		      s->size += 4;
d4037 2
a4038 1
		  s->size += 4;
d4040 2
a4041 2
		  srel->size += ((s->size - *local_got) / 4
				 * sizeof (Elf32_External_Rela));
d4048 9
d4060 15
d5311 2
a5312 1
	    relocation = htab->got->output_offset + off - 4;
d5386 1
a5386 1
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d5991 2
a5992 2
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
d6074 1
a6074 1
  if (htab->got)
d6076 2
a6077 2
      unsigned char *contents = htab->got->contents;
      bfd_put_32 (output_bfd, 0x4e800021 /* blrl */, contents);
d6079 7
a6085 6
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, 0, contents + 4);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    contents + 4);
a6115 1
#define elf_backend_got_symbol_offset	4
a6117 1
#define elf_backend_got_header_size	12
@


1.152
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2223 6
a2228 1
  htab->relgot = bfd_make_section (abfd, ".rela.got");
a2229 4
      || ! bfd_set_section_flags (abfd, htab->relgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
d2260 4
a2263 3
  htab->dynsbss = s = bfd_make_section (abfd, ".dynsbss");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
d2269 3
a2271 1
      htab->relsbss = s = bfd_make_section (abfd, ".rela.sbss");
a2272 1
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
d2390 4
a2393 3
	  htab->sbss = bfd_make_section_anyway (htab->elf.dynobj, ".sbss");
	  if (htab->sbss == NULL
	      || ! bfd_set_section_flags (htab->elf.dynobj, htab->sbss, flags))
d2422 3
a2424 1
  s = bfd_make_section_anyway (htab->elf.dynobj, lsect->name);
a2425 1
      || !bfd_set_section_flags (htab->elf.dynobj, s, flags)
a2954 1
		      sreloc = bfd_make_section (htab->elf.dynobj, name);
d2958 3
a2961 2
			  || ! bfd_set_section_flags (htab->elf.dynobj,
						      sreloc, flags)
@


1.151
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
@


1.150
log
@Update the FSF address in the copyright/GPL notice
@
text
@d4087 1
a4087 1
	  _bfd_strip_section_from_output (info, s);
@


1.149
log
@2005-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_sym_name): Also take "asection *".

	* elf.c (bfd_elf_sym_name): Updated.
	(group_signature): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_edit_opd): Likewise.
	(ppc64_elf_edit_toc): Likewise.
	(ppc64_elf_relocate_section): Likewise.
	* elfcode.h (elf_slurp_symbol_table): Likewise.
	* elflink.c (elf_link_input_bfd): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Call
	bfd_elf_sym_name to get local symbol name when reporting errors.
@
text
@d21 1
a21 1
   Boston, MA 02111-1307, USA.  */
@


1.148
log
@bfd/
	* elf32-ppc.c (ppc_elf_check_relocs): Don't bother with
	dynamic relocs in non-SEC_ALLOC sections.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_relax_section): Likewise.
	(ppc_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-powerpc/reloc.d: Update to suit removal of non-alloc relocs.
@
text
@d4772 1
a4772 1
	  sym_name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym);
a5804 2
	  if (sym_name == NULL)
	    sym_name = "(null)";
@


1.147
log
@bfd/

2005-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (_bfd_elf_provide_symbol): New.
	* bfd-in2.h: Regenerated.

	* elf32-ppc.c (set_linker_sym): Moved to elflink.c.
	(ppc_elf_set_sdata_syms): Call _bfd_elf_provide_symbol instead
	of set_linker_sym.

	* elflink.c (_bfd_elf_provide_symbol): New. Moved and renamed
	from elf32-ppc.c.

ld/

2005-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_provide_bound_symbols): New
	(gld${EMULATION_NAME}_finish): Call
	gld${EMULATION_NAME}_provide_bound_symbols to provide
	__preinit_array_start, __preinit_array_end, __init_array_start,
	__init_array_end, __fini_array_start and __fini_array_end.

	* scripttempl/elf.sc: Don't provide __preinit_array_start,
	__preinit_array_end, __init_array_start, __init_array_end,
	__fini_array_start nor __fini_array_end.
@
text
@d2584 9
a2913 1
		  && (sec->flags & SEC_ALLOC) != 0
d2952 2
a2953 3
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
d3157 3
d4198 5
a4202 2
  /* Nothing to do if there are no relocations.  */
  if ((isec->flags & SEC_RELOC) == 0 || isec->reloc_count == 0)
d5370 4
a5381 1
		  && (input_section->flags & SEC_ALLOC) != 0
@


1.146
log
@	* elf32-ppc.c (elf_linker_section_pointers_t): Remove
	written_address_p.
	(ppc_elf_create_linker_section): Don't try to reuse existing section.
	(elf_create_pointer_linker_section): Delete info parm.  Don't make
	h dynamic.  Don't set written_address_p.
	(ppc_elf_check_relocs): Adjust ppc_elf_create_linker_section calls.
	(bfd_put_ptr): Delete.
	(elf_finish_pointer_linker_section): Remove output_bfd and info parms.
	Always write section contents.  Assert global sym is def_regular.
	Use offset bottom bit as a written flag.
	(ppc_elf_relocate_section): Adjust elf_finish_pointer_linker_section
	calls.
@
text
@a4547 20
/* Set SYM_NAME to VAL if the symbol exists and is undefined.  */

static void
set_linker_sym (struct ppc_elf_link_hash_table *htab,
		const char *sym_name,
		bfd_vma val)
{
  struct elf_link_hash_entry *h;
  h = elf_link_hash_lookup (&htab->elf, sym_name, FALSE, FALSE, FALSE);
  if (h != NULL && h->root.type == bfd_link_hash_undefined)
    {
      h->root.type = bfd_link_hash_defined;
      h->root.u.def.section = bfd_abs_section_ptr;
      h->root.u.def.value = val;
      h->def_regular = 1;
      h->type = STT_OBJECT;
      h->other = STV_HIDDEN;
    }
}

d4582 1
a4582 1
      set_linker_sym (htab, lsect->sym_name, val);
d4589 2
a4590 2
  set_linker_sym (htab, "__sbss_start", val);
  set_linker_sym (htab, "___sbss_start", val);
d4593 2
a4594 2
  set_linker_sym (htab, "__sbss_end", val);
  set_linker_sym (htab, "___sbss_end", val);
@


1.145
log
@	* elf32-ppc.c (ppc_elf_set_sdata_syms): New function, extracted from..
	(ppc_elf_set_sdata_syms): ..here.  Expand comment.  Set .sbss start
	and end syms.
@
text
@a1534 2
  /* whether address was written yet */
  bfd_boolean written_address_p;
d2418 5
a2422 9
  /* See if the section already exists.  */
  s = bfd_get_section_by_name (htab->elf.dynobj, lsect->name);
  if (s == NULL || (s->flags & flags) != flags)
    {
      s = bfd_make_section_anyway (htab->elf.dynobj, lsect->name);
      if (s == NULL
	  || !bfd_set_section_flags (htab->elf.dynobj, s, flags))
	return FALSE;
    }
a2424 11
  if (bfd_get_section_alignment (htab->elf.dynobj, s) < 2
      && !bfd_set_section_alignment (htab->elf.dynobj, s, 2))
    return FALSE;

  s->size = align_power (s->size, 2);

#ifdef DEBUG
  fprintf (stderr, "Creating section %s, current size = %ld\n",
	   lsect->name, (long) s->size);
#endif

a2446 1
				   struct bfd_link_info *info,
a2470 6
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}
a2512 1
  linker_section_ptr->written_address_p = FALSE;
d2697 2
a2698 2
	  if (!elf_create_pointer_linker_section (abfd, info,
						  &htab->sdata[0], h, rel))
d2713 2
a2714 2
	  if (!elf_create_pointer_linker_section (abfd, info,
						  &htab->sdata[1], h, rel))
a4617 2
#define bfd_put_ptr(BFD, VAL, ADDR) bfd_put_32 (BFD, VAL, ADDR)

d4621 1
a4621 3
elf_finish_pointer_linker_section (bfd *output_bfd,
				   bfd *input_bfd,
				   struct bfd_link_info *info,
d4637 2
a4638 29
      linker_section_ptr
	= elf_find_pointer_linker_section (eh->linker_section_pointer,
					   rel->r_addend,
					   lsect);

      BFD_ASSERT (linker_section_ptr != NULL);

      if (! elf_hash_table (info)->dynamic_sections_created
	  || (info->shared
	      && info->symbolic
	      && h->def_regular))
	{
	  /* This is actually a static link, or it is a
	     -Bsymbolic link and the symbol is defined
	     locally.  We must initialize this entry in the
	     global section.

	     When doing a dynamic link, we create a .rela.<xxx>
	     relocation entry to initialize the value.  This
	     is done in the finish_dynamic_symbol routine.  */
	  if (!linker_section_ptr->written_address_p)
	    {
	      linker_section_ptr->written_address_p = TRUE;
	      bfd_put_ptr (output_bfd,
			   relocation + linker_section_ptr->addend,
			   (lsect->section->contents
			    + linker_section_ptr->offset));
	    }
	}
d4644 1
d4646 16
a4661 15
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd)[r_symndx] != NULL);
      linker_section_ptr = (elf_find_pointer_linker_section
			    (elf_local_ptr_offsets (input_bfd)[r_symndx],
			     rel->r_addend,
			     lsect));

      BFD_ASSERT (linker_section_ptr != NULL);

      /* Write out pointer if it hasn't been rewritten out before.  */
      if (!linker_section_ptr->written_address_p)
	{
	  linker_section_ptr->written_address_p = TRUE;
	  bfd_put_ptr (output_bfd, relocation + linker_section_ptr->addend,
		       lsect->section->contents + linker_section_ptr->offset);
	}
d4665 1
a4665 1
		+ linker_section_ptr->offset
d5551 2
a5552 3
	    = elf_finish_pointer_linker_section (output_bfd, input_bfd, info,
						 &htab->sdata[0], h,
						 relocation, rel);
d5559 2
a5560 3
	    = elf_finish_pointer_linker_section (output_bfd, input_bfd, info,
						 &htab->sdata[1], h,
						 relocation, rel);
@


1.144
log
@bfd/
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Make htab->sbss
	SEC_LINKER_CREATED.  Attach to dynobj.
	(ppc_elf_size_dynamic_sections): Strip htab->sbss if zero size.
ld/
	* scripttempl/elf.sc (SBSS): Don't provide sbss start and end syms.
ld/testsuite/
	* ld-powerpc/tlsexe32.r: Update.
	* ld-powerpc/tlsso32.d: Update.
	* ld-powerpc/tlsso32.g: Update.
	* ld-powerpc/tlsso32.r: Update.
@
text
@d4573 26
a4598 1
/* Set _SDA_BASE_ and _SDA2_BASE.  */
d4605 2
a4612 3
      asection *s;
      bfd_vma val;
      struct elf_link_hash_entry *h;
d4627 1
a4627 11
      h = elf_link_hash_lookup (&htab->elf, lsect->sym_name,
				FALSE, FALSE, FALSE);
      if (h != NULL && h->root.type == bfd_link_hash_undefined)
	{
	  h->root.type = bfd_link_hash_defined;
	  h->root.u.def.section = bfd_abs_section_ptr;
	  h->root.u.def.value = val;
	  h->def_regular = 1;
	  h->type = STT_OBJECT;
	  h->other = STV_HIDDEN;
	}
d4629 11
@


1.143
log
@bfd/
	* elf32-ppc.c (struct elf_linker_section): Remove sym_hash and
	sym_offset.  Add name, bss_name, sym_name, sym_val.
	(struct ppc_elf_link_hash_table): Remove sdata and sdata2 pointers.
	Add sdata array of elf_linker_section_t.
	(ppc_elf_link_hash_table_create): Set name, sym_name, and bss_name.
	(enum elf_linker_section_enum): Delete.
	(ppc_elf_create_linker_section): Rewrite.  Don't create syms here.
	(ppc_elf_check_relocs): Delay ppc_elf_create_linker_section until
	the special sections are needed.  Adjust htab->sdata refs.
	Ensure dynobj is set in sreloc code.
	(ppc_elf_size_dynamic_sections): Strip sdata sections.
	(ppc_elf_set_sdata_syms): New function.
	(elf_finish_pointer_linker_section): Use 0x8000 for sym_offset.
	(ppc_elf_relocate_section): Adjust references to htab->sdata.  Use
	sym_val instead of sym_hash.
	* elf32-ppc.h (ppc_elf_set_sdata_syms): Declare.
ld/
	* emultempl/ppc32elf.em (gld${EMULATION_NAME}_after_allocation): New
	function.
	(LDEMUL_AFTER_ALLOCATION): Define.
@
text
@d2384 1
a2384 1
	  flagword flags = SEC_IS_COMMON;
d2386 4
a2389 1
	  htab->sbss = bfd_make_section_anyway (abfd, ".sbss");
d2391 1
a2391 1
	      || ! bfd_set_section_flags (abfd, htab->sbss, flags))
d4059 2
a4060 1
	  || s == htab->got)
d4106 3
@


1.142
log
@	* elf32-ppc.c (is_ppc_elf_target): Move to linker part of file.
	(ppc_elf_merge_private_bfd_data): Likewise.
@
text
@d1509 1
a1509 1
  /* pointer to the section */
d1511 8
a1518 4
  /* pointer to the created symbol hash value */
  struct elf_link_hash_entry *sym_hash;
  /* offset of symbol from beginning of section */
  bfd_vma sym_offset;
d2124 1
a2124 2
  elf_linker_section_t *sdata;
  elf_linker_section_t *sdata2;
d2192 8
d2399 1
a2399 6
/* Enumeration to specify the special section.  */
enum elf_linker_section_enum
{
  LINKER_SECTION_SDATA,
  LINKER_SECTION_SDATA2
};
d2401 1
a2401 2
/* Create a special linker section */
static elf_linker_section_t *
d2404 2
a2405 1
			       enum elf_linker_section_enum which)
a2406 1
  elf_linker_section_t *lsect;
d2408 1
a2408 7
  asection *s, *sym_sec;
  bfd_size_type amt;
  flagword flags;
  const char *name;
  const char *rel_name;
  const char *sym_name;
  bfd_vma sym_offset;
d2410 2
a2411 31
  /* The linker creates these sections so it has somewhere to attach
     their respective symbols.  Startup code (crt1.o) uses these symbols
     to initialize a register pointing to the section.  If the output
     sections corresponding to these input sections were empty it would
     be OK to set the symbol to 0 (or any random number), because the
     associated register should never be used.
     FIXME: Setting a symbol this way is silly.  The symbols ought to 
     be set the same way other backends set gp.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
  sym_offset = 32768;

  switch (which)
    {
    default:
      abort ();
      return NULL;

    case LINKER_SECTION_SDATA:	/* .sdata/.sbss section */
      name	= ".sdata";
      rel_name	= ".rela.sdata";
      sym_name	= "_SDA_BASE_";
      break;

    case LINKER_SECTION_SDATA2:	/* .sdata2/.sbss2 section */
      name	= ".sdata2";
      rel_name	= ".rela.sdata2";
      sym_name	= "_SDA2_BASE_";
      flags    |= SEC_READONLY;
      break;
    }
d2417 2
a2418 7
  amt = sizeof (elf_linker_section_t);
  lsect = bfd_zalloc (htab->elf.dynobj, amt);

  lsect->sym_offset = sym_offset;

  /* See if the sections already exist.  */
  sym_sec = s = bfd_get_section_by_name (htab->elf.dynobj, name);
d2421 1
a2421 1
      s = bfd_make_section_anyway (htab->elf.dynobj, name);
d2424 1
a2424 3
	return NULL;
      if (sym_sec == NULL)
	sym_sec = s;
d2430 1
a2430 1
    return NULL;
d2436 1
a2436 1
	   name, (long) s->size);
d2439 1
a2439 27
  if (sym_name)
    {
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh;

#ifdef DEBUG
      fprintf (stderr, "Adding %s to section %s\n", sym_name, name);
#endif
      bh = bfd_link_hash_lookup (info->hash, sym_name,
				 FALSE, FALSE, FALSE);

      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	  && !(_bfd_generic_link_add_one_symbol
	       (info, abfd, sym_name, BSF_GLOBAL, sym_sec, sym_offset, NULL,
		FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return NULL;
      h = (struct elf_link_hash_entry *) bh;

      h->type = STT_OBJECT;
      lsect->sym_hash = h;

      if (info->shared
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
	return NULL;
    }

  return lsect;
a2614 2
  /* Create the linker generated sections all the time so that the
     special symbols are created.  */
a2615 16
  if (htab->sdata == NULL)
    {
      htab->sdata = ppc_elf_create_linker_section (abfd, info,
						   LINKER_SECTION_SDATA);
      if (htab->sdata == NULL)
	return FALSE;
    }

  if (htab->sdata2 == NULL)
    {
      htab->sdata2 = ppc_elf_create_linker_section (abfd, info,
						    LINKER_SECTION_SDATA2);
      if (htab->sdata2 == NULL)
	return FALSE;
    }

d2715 4
d2720 1
a2720 1
						  htab->sdata, h, rel))
d2731 4
d2736 1
a2736 1
						  htab->sdata2, h, rel))
d2957 2
d4061 2
a4062 2
      else if ((htab->sdata != NULL && s == htab->sdata->section)
	       || (htab->sdata2 != NULL && s == htab->sdata2->section))
d4064 1
a4064 5
	  if (s->size == 0)
	    /* Don't strip these sections.  We need them because they
	       define _SDA_BASE_ and _SDA2_BASE_.  crt1.o makes a
	       reference to _SDA_BASE_ to set up r13.  */
	    continue;
d4566 45
d4688 1
a4688 1
		- lsect->sym_offset);
d5571 1
a5571 1
	  BFD_ASSERT (htab->sdata != NULL);
d5574 2
a5575 2
						 htab->sdata, h, relocation,
						 rel);
d5580 1
a5580 1
	  BFD_ASSERT (htab->sdata2 != NULL);
d5583 2
a5584 2
						 htab->sdata2, h, relocation,
						 rel);
a5623 1
	    const struct elf_link_hash_entry *sh;
d5640 1
a5640 4
	    sh = htab->sdata->sym_hash;
	    addend -= (sh->root.u.def.value
		       + sh->root.u.def.section->output_section->vma
		       + sh->root.u.def.section->output_offset);
a5647 1
	    const struct elf_link_hash_entry *sh;
d5666 1
a5666 4
	    sh = htab->sdata2->sym_hash;
	    addend -= (sh->root.u.def.value
		       + sh->root.u.def.section->output_section->vma
		       + sh->root.u.def.section->output_offset);
a5674 1
	    const struct elf_link_hash_entry *sh;
d5685 1
a5685 4
		sh = htab->sdata->sym_hash;
		addend -= (sh->root.u.def.value
			   + sh->root.u.def.section->output_section->vma
			   + sh->root.u.def.section->output_offset);
d5692 1
a5692 4
		sh = htab->sdata2->sym_hash;
		addend -= (sh->root.u.def.value
			   + sh->root.u.def.section->output_section->vma
			   + sh->root.u.def.section->output_offset);
@


1.141
log
@	* elf32-ppc.c (struct elf_linker_section): Remove rel_section.
	(ppc_elf_create_linker_section): Don't create rel_section.
	(elf_create_pointer_linker_section): Don't size relocs.
	(elf_finish_pointer_linker_section): Remove relative_reloc parm.
	Don't generate relocs.
	(ppc_elf_relocate_section): Adjust calls to
	elf_finish_pointer_linker_section.
@
text
@a1594 103
/* Return 1 if target is one of ours.  */

static bfd_boolean
is_ppc_elf_target (const struct bfd_target *targ)
{
  extern const bfd_target bfd_elf32_powerpc_vec;
  extern const bfd_target bfd_elf32_powerpcle_vec;

  return targ == &bfd_elf32_powerpc_vec || targ == &bfd_elf32_powerpcle_vec;
}

/* Merge backend specific data from an object file to the output
   object file when linking.  */

static bfd_boolean
ppc_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword old_flags;
  flagword new_flags;
  bfd_boolean error;

  if (!is_ppc_elf_target (ibfd->xvec)
      || !is_ppc_elf_target (obfd->xvec))
    return TRUE;

  /* Check if we have the same endianess.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;
  if (!elf_flags_init (obfd))
    {
      /* First call, no flags set.  */
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
    }

  /* Compatible flags are ok.  */
  else if (new_flags == old_flags)
    ;

  /* Incompatible flags.  */
  else
    {
      /* Warn about -mrelocatable mismatch.  Allow -mrelocatable-lib
	 to be linked with either.  */
      error = FALSE;
      if ((new_flags & EF_PPC_RELOCATABLE) != 0
	  && (old_flags & (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB)) == 0)
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%B: compiled with -mrelocatable and linked with "
	       "modules compiled normally"), ibfd);
	}
      else if ((new_flags & (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB)) == 0
	       && (old_flags & EF_PPC_RELOCATABLE) != 0)
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%B: compiled normally and linked with "
	       "modules compiled with -mrelocatable"), ibfd);
	}

      /* The output is -mrelocatable-lib iff both the input files are.  */
      if (! (new_flags & EF_PPC_RELOCATABLE_LIB))
	elf_elfheader (obfd)->e_flags &= ~EF_PPC_RELOCATABLE_LIB;

      /* The output is -mrelocatable iff it can't be -mrelocatable-lib,
	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
      if (! (elf_elfheader (obfd)->e_flags & EF_PPC_RELOCATABLE_LIB)
	  && (new_flags & (EF_PPC_RELOCATABLE_LIB | EF_PPC_RELOCATABLE))
	  && (old_flags & (EF_PPC_RELOCATABLE_LIB | EF_PPC_RELOCATABLE)))
	elf_elfheader (obfd)->e_flags |= EF_PPC_RELOCATABLE;

      /* Do not warn about eabi vs. V.4 mismatch, just or in the bit if
	 any module uses it.  */
      elf_elfheader (obfd)->e_flags |= (new_flags & EF_PPC_EMB);

      new_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
      old_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);

      /* Warn about any other mismatches.  */
      if (new_flags != old_flags)
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%B: uses different e_flags (0x%lx) fields "
	       "than previous modules (0x%lx)"),
	     ibfd, (long) new_flags, (long) old_flags);
	}

      if (error)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
    }

  return TRUE;
}

d2338 11
d3097 92
@


1.140
log
@	* elf32-ppc.c (is_ppc_elf_target): New function.
	(ppc_elf_merge_private_bfd_data): Use it rather than just testing
	for bfd_target_elf_flavour.  Do this test before endian check.
	(ppc_elf_add_symbol_hook): Use is_pcc_elf_target.
	(ppc_elf_size_dynamic_sections): Likewise.
@
text
@a1510 2
  /* pointer to the relocations needed for this section */
  asection *rel_section;
a2593 12
  if (info->shared)
    {
      s = bfd_make_section_anyway (htab->elf.dynobj, rel_name);
      lsect->rel_section = s;
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_LINKER_CREATED | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_flags (htab->elf.dynobj, s, flags)
	  || ! bfd_set_section_alignment (htab->elf.dynobj, s, 2))
	return NULL;
    }

a2646 3

      if (lsect->rel_section)
	lsect->rel_section->size += sizeof (Elf32_External_Rela);
a2674 9

      if (info->shared)
	{
	  /* If we are generating a shared object, we need to
	     output a R_<xxx>_RELATIVE reloc so that the
	     dynamic linker can adjust this GOT entry.  */
	  BFD_ASSERT (lsect->rel_section != NULL);
	  lsect->rel_section->size += sizeof (Elf32_External_Rela);
	}
d4652 1
a4652 2
				   const Elf_Internal_Rela *rel,
				   int relative_reloc)
a4712 29

	  if (info->shared)
	    {
	      /* We need to generate a relative reloc for the dynamic
		 linker.  */

	      asection *srel = lsect->rel_section;
	      Elf_Internal_Rela outrel[MAX_INT_RELS_PER_EXT_REL];
	      bfd_byte *erel;
	      const struct elf_backend_data *bed;
	      unsigned int i;

	      BFD_ASSERT (srel != NULL);

	      bed = get_elf_backend_data (output_bfd);
	      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
		{
		  outrel[i].r_offset = (lsect->section->output_section->vma
					+ lsect->section->output_offset
					+ linker_section_ptr->offset);
		  outrel[i].r_info = 0;
		  outrel[i].r_addend = 0;
		}
	      outrel[0].r_info = ELF32_R_INFO (0, relative_reloc);
	      erel = lsect->section->contents;
	      erel += (elf_section_data (lsect->section)->rel_count++
		       * sizeof (Elf32_External_Rela));
	      bfd_elf32_swap_reloca_out (output_bfd, outrel, erel);
	    }
d5605 1
a5605 1
						 rel, R_PPC_RELATIVE);
d5614 1
a5614 1
						 rel, R_PPC_RELATIVE);
@


1.139
log
@2005-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add int to
	elf_backend_section_from_shdr.
	(bfd_elf_section_data): Update comment for this_idx.
	(_bfd_elf_make_section_from_shdr): Add int.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.

	* elf.c (_bfd_elf_make_section_from_shdr): Take section index
	and use it to set this_idx in bfd_elf_section_data.
	(bfd_section_from_shdr): Pass shindex to
	_bfd_elf_make_section_from_shdr.
	(_bfd_elf_section_from_bfd_section): Use this_idx in
	bfd_elf_section_data to find section index.

	* elf32-arm.c (elf32_arm_section_from_shdr): Take section
	index and pass it to _bfd_elf_make_section_from_shdr.
	* elf32-i370.c(i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d1597 11
d1618 4
a1625 4
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

d2458 1
a2458 2
      && (info->hash->creator == abfd->xvec
	  || info->hash->creator == abfd->xvec->alternative_target))
d4060 1
a4060 1
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
@


1.138
log
@	* elf32-ppc.c: Divide file into general and linker specific
	functions.  Sort linker functions into roughly the order in which
	they are called by the ELF linker code.
@
text
@d1763 2
a1764 1
   is called when elfcode.h finds a section with an unknown type.  */
d1767 4
a1770 1
ppc_elf_section_from_shdr (bfd *abfd, Elf_Internal_Shdr *hdr, const char *name)
d1775 1
a1775 1
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
@


1.137
log
@bfd/
	* elf32-ppc.c (ppc_elf_create_linker_section): Set SEC_LINKER_CREATED
	on section.  Correct comment, and add FIXME.
	(ppc_elf_additional_program_headers): Don't bump header count for
	interp.  Test SEC_ALLOC, not SEC_LOAD, and don't test size.
	(ppc_elf_size_dynamic_sections): Don't strip sdata and sdata2, but
	do allocate memory if they need it.
ld/
	* emulparams/elf32ppclinux.sh (OTHER_READWRITE_SECTION): Delete.
	(OTHER_RELRO_SECTIONS): Set this instead.
ld/testsuite/
	* ld-powerpc/tlsexe32.d: Update.
	* ld-powerpc/tlsexe32.g: Update.
	* ld-powerpc/tlsexe32.r: Update.
	* ld-powerpc/tlsexe32.t: Update.
	* ld-powerpc/tlsso32.d: Update.
	* ld-powerpc/tlsso32.g: Update.
	* ld-powerpc/tlsso32.r: Update.
	* ld-powerpc/tlsso32.t: Update.
@
text
@a70 1

d72 1
a72 6
/* Enumeration to specify the special section.  */
enum elf_linker_section_enum
{
  LINKER_SECTION_SDATA,
  LINKER_SECTION_SDATA2
};
d74 15
a88 1
/* Sections created by the linker.  */
d90 14
a103 11
typedef struct elf_linker_section
{
  /* pointer to the section */
  asection *section;
  /* pointer to the relocations needed for this section */
  asection *rel_section;
  /* pointer to the created symbol hash value */
  struct elf_link_hash_entry *sym_hash;
  /* offset of symbol from beginning of section */
  bfd_vma sym_offset;
} elf_linker_section_t;
d105 15
a119 3
/* Linked list of allocated pointer entries.  This hangs off of the
   symbol lists, and provides allows us to return different pointers,
   based on different addend's.  */
d121 14
a134 13
typedef struct elf_linker_section_pointers
{
  /* next allocated pointer for this symbol */
  struct elf_linker_section_pointers *next;
  /* offset of pointer from beginning of section */
  bfd_vma offset;
  /* addend used */
  bfd_vma addend;
  /* which linker section this is */
  elf_linker_section_t *lsect;
  /* whether address was written yet */
  bfd_boolean written_address_p;
} elf_linker_section_pointers_t;
d136 14
a149 3
struct ppc_elf_obj_tdata
{
  struct elf_obj_tdata elf;
d151 14
a164 4
  /* A mapping from local symbols to offsets into the various linker
     sections added.  This is index by the symbol index.  */
  elf_linker_section_pointers_t **linker_section_pointers;
};
d166 15
a180 2
#define ppc_elf_tdata(bfd) \
  ((struct ppc_elf_obj_tdata *) (bfd)->tdata.any)
d182 15
a196 2
#define elf_local_ptr_offsets(bfd) \
  (ppc_elf_tdata (bfd)->linker_section_pointers)
d198 16
a213 1
/* Override the generic function because we store some extras.  */
d215 16
a230 9
static bfd_boolean
ppc_elf_mkobject (bfd *abfd)
{
  bfd_size_type amt = sizeof (struct ppc_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}
d232 14
a245 5
/* The PPC linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */
d247 14
a260 3
struct ppc_elf_dyn_relocs
{
  struct ppc_elf_dyn_relocs *next;
d262 16
a277 2
  /* The input section of the reloc.  */
  asection *sec;
d279 4
a282 199
  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};

/* PPC ELF linker hash entry.  */

struct ppc_elf_link_hash_entry
{
  struct elf_link_hash_entry elf;

  /* If this symbol is used in the linker created sections, the processor
     specific backend uses this field to map the field into the offset
     from the beginning of the section.  */
  elf_linker_section_pointers_t *linker_section_pointer;

  /* Track dynamic relocs copied for this symbol.  */
  struct ppc_elf_dyn_relocs *dyn_relocs;

  /* Contexts in which symbol is used in the GOT (or TOC).
     TLS_GD .. TLS_TLS bits are or'd into the mask as the
     corresponding relocs are encountered during check_relocs.
     tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to
     indicate the corresponding GOT entry type is not needed.  */
#define TLS_GD		 1	/* GD reloc. */
#define TLS_LD		 2	/* LD reloc. */
#define TLS_TPREL	 4	/* TPREL reloc, => IE. */
#define TLS_DTPREL	 8	/* DTPREL reloc, => LD. */
#define TLS_TLS		16	/* Any TLS reloc.  */
#define TLS_TPRELGD	32	/* TPREL reloc resulting from GD->IE. */
  char tls_mask;
};

#define ppc_elf_hash_entry(ent) ((struct ppc_elf_link_hash_entry *) (ent))

/* PPC ELF linker hash table.  */

struct ppc_elf_link_hash_table
{
  struct elf_link_hash_table elf;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *got;
  asection *relgot;
  asection *plt;
  asection *relplt;
  asection *dynbss;
  asection *relbss;
  asection *dynsbss;
  asection *relsbss;
  elf_linker_section_t *sdata;
  elf_linker_section_t *sdata2;
  asection *sbss;

  /* Shortcut to .__tls_get_addr.  */
  struct elf_link_hash_entry *tls_get_addr;

  /* TLS local dynamic got entry handling.  */
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tlsld_got;

  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};

/* Get the PPC ELF linker hash table from a link_info structure.  */

#define ppc_elf_hash_table(p) \
  ((struct ppc_elf_link_hash_table *) (p)->hash)

/* Create an entry in a PPC ELF linker hash table.  */

static struct bfd_hash_entry *
ppc_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			   struct bfd_hash_table *table,
			   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct ppc_elf_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      ppc_elf_hash_entry (entry)->linker_section_pointer = NULL;
      ppc_elf_hash_entry (entry)->dyn_relocs = NULL;
      ppc_elf_hash_entry (entry)->tls_mask = 0;
    }

  return entry;
}

/* Create a PPC ELF linker hash table.  */

static struct bfd_link_hash_table *
ppc_elf_link_hash_table_create (bfd *abfd)
{
  struct ppc_elf_link_hash_table *ret;

  ret = bfd_zmalloc (sizeof (struct ppc_elf_link_hash_table));
  if (ret == NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd,
				       ppc_elf_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  return &ret->elf.root;
}

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
ppc_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
			      struct elf_link_hash_entry *dir,
			      struct elf_link_hash_entry *ind)
{
  struct ppc_elf_link_hash_entry *edir, *eind;

  edir = (struct ppc_elf_link_hash_entry *) dir;
  eind = (struct ppc_elf_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct ppc_elf_dyn_relocs **pp;
	  struct ppc_elf_dyn_relocs *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct ppc_elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  edir->tls_mask |= eind->tls_mask;

  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
    }
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

static reloc_howto_type *ppc_elf_howto_table[R_PPC_max];

static reloc_howto_type ppc_elf_howto_raw[] = {
  /* This reloc does nothing.  */
  HOWTO (R_PPC_NONE,		/* type */
d285 2
a286 2
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
d288 1
a288 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d290 1
a290 1
	 "R_PPC_NONE",		/* name */
d293 2
a294 2
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */
d296 3
a298 2
  /* A standard 32 bit relocation.  */
  HOWTO (R_PPC_ADDR32,		/* type */
d300 2
a301 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
d304 1
a304 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d306 1
a306 1
	 "R_PPC_ADDR32",	/* name */
d309 1
a309 1
	 0xffffffff,		/* dst_mask */
d312 3
a314 3
  /* An absolute 26 bit branch; the lower two bits must be zero.
     FIXME: we don't check that, we just clear them.  */
  HOWTO (R_PPC_ADDR24,		/* type */
d316 2
a317 2
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
d320 1
a320 1
	 complain_overflow_bitfield, /* complain_on_overflow */
d322 1
a322 1
	 "R_PPC_ADDR24",	/* name */
d325 1
a325 1
	 0x3fffffc,		/* dst_mask */
d328 4
a331 211
  /* A standard 16 bit relocation.  */
  HOWTO (R_PPC_ADDR16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit relocation without overflow.  */
  HOWTO (R_PPC_ADDR16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of an address.  */
  HOWTO (R_PPC_ADDR16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of an address, plus 1 if the contents of
     the low 16 bits, treated as a signed number, is negative.  */
  HOWTO (R_PPC_ADDR16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_ADDR16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 16 bit branch; the lower two bits must be zero.
     FIXME: we don't check that, we just clear them.  */
  HOWTO (R_PPC_ADDR14,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR14",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 16 bit branch, for which bit 10 should be set to
     indicate that the branch is expected to be taken.	The lower two
     bits must be zero.  */
  HOWTO (R_PPC_ADDR14_BRTAKEN,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR14_BRTAKEN",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* An absolute 16 bit branch, for which bit 10 should be set to
     indicate that the branch is not expected to be taken.  The lower
     two bits must be zero.  */
  HOWTO (R_PPC_ADDR14_BRNTAKEN, /* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_ADDR14_BRNTAKEN",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A relative 26 bit branch; the lower two bits must be zero.  */
  HOWTO (R_PPC_REL24,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 26,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL24",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0x3fffffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 16 bit branch; the lower two bits must be zero.  */
  HOWTO (R_PPC_REL14,		/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL14",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 16 bit branch.  Bit 10 should be set to indicate that
     the branch is expected to be taken.  The lower two bits must be
     zero.  */
  HOWTO (R_PPC_REL14_BRTAKEN,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL14_BRTAKEN",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* A relative 16 bit branch.  Bit 10 should be set to indicate that
     the branch is not expected to be taken.  The lower two bits must
     be zero.  */
  HOWTO (R_PPC_REL14_BRNTAKEN,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_REL14_BRNTAKEN",/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xfffc,		/* dst_mask */
	 TRUE),			/* pcrel_offset */

  /* Like R_PPC_ADDR16, but referring to the GOT table entry for the
     symbol.  */
  HOWTO (R_PPC_GOT16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_GOT16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC_ADDR16_LO, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_PPC_GOT16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_GOT16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like R_PPC_ADDR16_HI, but referring to the GOT table entry for
     the symbol.  */
  HOWTO (R_PPC_GOT16_HI,	/* type */
	 16,			/* rightshift */
a1325 2

#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))
d1327 5
a1331 11
static const int shared_stub_entry[] =
  {
    0x7c0802a6, /* mflr 0 */
    0x429f0005, /* bcl 20, 31, .Lxxx */
    0x7d6802a6, /* mflr 11 */
    0x3d6b0000, /* addis 11, 11, (xxx-.Lxxx)@@ha */
    0x396b0018, /* addi 11, 11, (xxx-.Lxxx)@@l */
    0x7c0803a6, /* mtlr 0 */
    0x7d6903a6, /* mtctr 11 */
    0x4e800420, /* bctr */
  };
d1333 3
a1335 7
static const int stub_entry[] =
  {
    0x3d600000, /* lis 11,xxx@@ha */
    0x396b0000, /* addi 11,11,xxx@@l */
    0x7d6903a6, /* mtctr 11 */
    0x4e800420, /* bctr */
  };
d1337 4
d1342 82
a1423 13
static bfd_boolean
ppc_elf_relax_section (bfd *abfd,
		       asection *isec,
		       struct bfd_link_info *link_info,
		       bfd_boolean *again)
{
  struct one_fixup
  {
    struct one_fixup *next;
    asection *tsec;
    bfd_vma toff;
    bfd_vma trampoff;
  };
d1425 2
a1426 9
  Elf_Internal_Shdr *symtab_hdr;
  bfd_byte *contents = NULL;
  Elf_Internal_Sym *isymbuf = NULL;
  Elf_Internal_Rela *internal_relocs = NULL;
  Elf_Internal_Rela *irel, *irelend;
  struct one_fixup *fixups = NULL;
  bfd_boolean changed;
  struct ppc_elf_link_hash_table *ppc_info;
  bfd_size_type trampoff;
d1428 1
a1428 1
  *again = FALSE;
d1430 8
a1437 3
  /* Nothing to do if there are no relocations.  */
  if ((isec->flags & SEC_RELOC) == 0 || isec->reloc_count == 0)
    return TRUE;
d1439 3
a1441 3
  trampoff = (isec->size + 3) & (bfd_vma) -4;
  /* Space for a branch around any trampolines.  */
  trampoff += 4;
d1443 1
a1443 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d1445 10
a1454 5
  /* Get a copy of the native relocations.  */
  internal_relocs = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL,
					       link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;
d1456 5
a1460 2
  ppc_info = ppc_elf_hash_table (link_info);
  irelend = internal_relocs + isec->reloc_count;
d1462 2
a1463 11
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      unsigned long r_type = ELF32_R_TYPE (irel->r_info);
      bfd_vma symaddr, reladdr, toff, roff;
      asection *tsec;
      struct one_fixup *f;
      size_t insn_offset = 0;
      bfd_vma max_branch_offset, val;
      bfd_byte *hit_addr;
      unsigned long t0;
      unsigned char sym_type;
d1465 4
a1468 7
      switch (r_type)
	{
	case R_PPC_REL24:
	case R_PPC_LOCAL24PC:
	case R_PPC_PLTREL24:
	  max_branch_offset = 1 << 25;
	  break;
d1470 3
a1472 5
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  max_branch_offset = 1 << 15;
	  break;
d1474 1
a1474 3
	default:
	  continue;
	}
d1476 2
a1477 5
      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
d1479 15
a1493 20
	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == 0)
		goto error_return;
	    }
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    continue;	/* We can't do anything with undefined symbols.  */
	  else if (isym->st_shndx == SHN_ABS)
	    tsec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    tsec = bfd_com_section_ptr;
	  else
	    tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d1495 11
a1505 8
	  toff = isym->st_value;
	  sym_type = ELF_ST_TYPE (isym->st_info);
	}
      else
	{
	  /* Global symbol handling.  */
	  unsigned long indx;
	  struct elf_link_hash_entry *h;
d1507 11
a1517 2
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
d1519 3
a1521 3
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1523 25
a1547 15
	  if (r_type == R_PPC_PLTREL24
	      && ppc_info->plt != NULL
	      && h->plt.offset != (bfd_vma) -1)
	    {
	      tsec = ppc_info->plt;
	      toff = h->plt.offset;
	    }
	  else if (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
	    {
	      tsec = h->root.u.def.section;
	      toff = h->root.u.def.value;
	    }
	  else
	    continue;
d1549 2
a1550 2
	  sym_type = h->type;
	}
d1552 1
a1552 5
      /* If the branch and target are in the same section, you have
	 no hope of adding stubs.  We'll error out later should the
	 branch overflow.  */
      if (tsec == isec)
	continue;
d1554 9
a1562 12
      /* There probably isn't any reason to handle symbols in
	 SEC_MERGE sections;  SEC_MERGE doesn't seem a likely
	 attribute for a code section, and we are only looking at
	 branches.  However, implement it correctly here as a
	 reference for other target relax_section functions.  */
      if (0 && tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	{
	  /* At this stage in linking, no SEC_MERGE symbol has been
	     adjusted, so all references to such symbols need to be
	     passed through _bfd_merged_section_offset.  (Later, in
	     relocate_section, all SEC_MERGE symbols *except* for
	     section symbols have been adjusted.)
d1564 2
a1565 12
	     gas may reduce relocations against symbols in SEC_MERGE
	     sections to a relocation against the section symbol when
	     the original addend was zero.  When the reloc is against
	     a section symbol we should include the addend in the
	     offset passed to _bfd_merged_section_offset, since the
	     location of interest is the original symbol.  On the
	     other hand, an access to "sym+addend" where "sym" is not
	     a section symbol should not include the addend;  Such an
	     access is presumed to be an offset from "sym";  The
	     location of interest is just "sym".  */
	  if (sym_type == STT_SECTION)
	    toff += irel->r_addend;
d1567 6
a1572 3
	  toff = _bfd_merged_section_offset (abfd, &tsec,
					     elf_section_data (tsec)->sec_info,
					     toff);
d1574 5
a1578 2
	  if (sym_type != STT_SECTION)
	    toff += irel->r_addend;
d1580 3
a1582 2
      else
	toff += irel->r_addend;
d1584 1
a1584 1
      symaddr = tsec->output_section->vma + tsec->output_offset + toff;
d1586 5
a1590 2
      roff = irel->r_offset;
      reladdr = isec->output_section->vma + isec->output_offset + roff;
d1592 4
a1595 3
      /* If the branch is in range, no need to do anything.  */
      if (symaddr - reladdr + max_branch_offset < 2 * max_branch_offset)
	continue;
d1597 2
a1598 4
      /* Look for an existing fixup to this address.  */
      for (f = fixups; f ; f = f->next)
	if (f->tsec == tsec && f->toff == toff)
	  break;
d1600 6
a1605 4
      if (f == NULL)
	{
	  size_t size;
	  unsigned long stub_rtype;
d1607 3
a1609 5
	  val = trampoff - roff;
	  if (val >= max_branch_offset)
	    /* Oh dear, we can't reach a trampoline.  Don't try to add
	       one.  We'll report an error later.  */
	    continue;
d1611 3
a1613 12
	  if (link_info->shared)
	    {
	      size = 4 * ARRAY_SIZE (shared_stub_entry);
	      insn_offset = 12;
	      stub_rtype = R_PPC_RELAX32PC;
	    }
	  else
	    {
	      size = 4 * ARRAY_SIZE (stub_entry);
	      insn_offset = 0;
	      stub_rtype = R_PPC_RELAX32;
	    }
d1615 8
a1622 5
	  if (R_PPC_RELAX32_PLT - R_PPC_RELAX32
	      != R_PPC_RELAX32PC_PLT - R_PPC_RELAX32PC)
	    abort ();
	  if (tsec == ppc_info->plt)
	    stub_rtype += R_PPC_RELAX32_PLT - R_PPC_RELAX32;
d1624 3
a1626 5
	  /* Hijack the old relocation.  Since we need two
	     relocations for this use a "composite" reloc.  */
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       stub_rtype);
	  irel->r_offset = trampoff + insn_offset;
d1628 13
a1640 9
	  /* Record the fixup so we don't do it again this section.  */
	  f = bfd_malloc (sizeof (*f));
	  f->next = fixups;
	  f->tsec = tsec;
	  f->toff = toff;
	  f->trampoff = trampoff;
	  fixups = f;

	  trampoff += size;
d1642 2
a1643 1
      else
d1645 23
a1667 3
	  val = f->trampoff - roff;
	  if (val >= max_branch_offset)
	    continue;
d1669 8
a1676 2
	  /* Nop out the reloc, since we're finalizing things here.  */
	  irel->r_info = ELF32_R_INFO (0, R_PPC_NONE);
d1679 1
a1679 2
      /* Get the section contents.  */
      if (contents == NULL)
d1681 2
a1682 9
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (isec)->this_hdr.contents != NULL)
	    contents = elf_section_data (isec)->this_hdr.contents;
	  else
	    {
	      /* Go get them off disk.  */
	      if (!bfd_malloc_and_get_section (abfd, isec, &contents))
		goto error_return;
	    }
d1684 6
d1691 21
a1711 12
      /* Fix up the existing branch to hit the trampoline.  */
      hit_addr = contents + roff;
      switch (r_type)
	{
	case R_PPC_REL24:
	case R_PPC_LOCAL24PC:
	case R_PPC_PLTREL24:
	  t0 = bfd_get_32 (abfd, hit_addr);
	  t0 &= ~0x3fffffc;
	  t0 |= val & 0x3fffffc;
	  bfd_put_32 (abfd, t0, hit_addr);
	  break;
d1713 1
a1713 9
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  t0 = bfd_get_32 (abfd, hit_addr);
	  t0 &= ~0xfffc;
	  t0 |= val & 0xfffc;
	  bfd_put_32 (abfd, t0, hit_addr);
	  break;
	}
d1716 9
a1724 3
  /* Write out the trampolines.  */
  changed = fixups != NULL;
  if (fixups != NULL)
d1726 38
a1763 4
      const int *stub;
      bfd_byte *dest;
      bfd_vma val;
      int i, size;
d1765 5
a1769 7
      do
	{
	  struct one_fixup *f = fixups;
	  fixups = fixups->next;
	  free (f);
	}
      while (fixups);
d1771 2
a1772 3
      contents = bfd_realloc (contents, trampoff);
      if (contents == NULL)
	goto error_return;
d1774 4
a1777 7
      isec->size = (isec->size + 3) & (bfd_vma) -4;
      /* Branch around the trampolines.  */
      val = trampoff - isec->size + 0x48000000;
      dest = contents + isec->size;
      isec->size = trampoff;
      bfd_put_32 (abfd, val, dest);
      dest += 4;
d1779 2
a1780 10
      if (link_info->shared)
	{
	  stub = shared_stub_entry;
	  size = ARRAY_SIZE (shared_stub_entry);
	}
      else
	{
	  stub = stub_entry;
	  size = ARRAY_SIZE (stub_entry);
	}
d1782 3
a1784 11
      i = 0;
      while (dest < contents + trampoff)
	{
	  bfd_put_32 (abfd, stub[i], dest);
	  i++;
	  if (i == size)
	    i = 0;
	  dest += 4;
	}
      BFD_ASSERT (i == 0);
    }
d1786 1
a1786 11
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
    {
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }
d1788 7
a1794 11
  if (contents != NULL
      && elf_section_data (isec)->this_hdr.contents != contents)
    {
      if (!changed && !link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (isec)->this_hdr.contents = contents;
	}
    }
d1796 2
a1797 7
  if (elf_section_data (isec)->relocs != internal_relocs)
    {
      if (!changed)
	free (internal_relocs);
      else
	elf_section_data (isec)->relocs = internal_relocs;
    }
a1798 1
  *again = changed;
d1800 1
d1802 18
a1819 10
 error_return:
  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (isec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (isec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
d1821 19
d1841 2
a1842 3
static reloc_howto_type *
ppc_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   bfd_reloc_code_real_type code)
d1844 6
a1849 1
  enum elf_ppc_reloc_type r;
a1850 3
  /* Initialize howto table if not already done.  */
  if (!ppc_elf_howto_table[R_PPC_ADDR32])
    ppc_elf_howto_init ();
d1852 12
a1863 1
  switch (code)
d1865 3
a1867 84
    default:
      return NULL;

    case BFD_RELOC_NONE:		r = R_PPC_NONE;			break;
    case BFD_RELOC_32:			r = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC_BA26:		r = R_PPC_ADDR24;		break;
    case BFD_RELOC_16:			r = R_PPC_ADDR16;		break;
    case BFD_RELOC_LO16:		r = R_PPC_ADDR16_LO;		break;
    case BFD_RELOC_HI16:		r = R_PPC_ADDR16_HI;		break;
    case BFD_RELOC_HI16_S:		r = R_PPC_ADDR16_HA;		break;
    case BFD_RELOC_PPC_BA16:		r = R_PPC_ADDR14;		break;
    case BFD_RELOC_PPC_BA16_BRTAKEN:	r = R_PPC_ADDR14_BRTAKEN;	break;
    case BFD_RELOC_PPC_BA16_BRNTAKEN:	r = R_PPC_ADDR14_BRNTAKEN;	break;
    case BFD_RELOC_PPC_B26:		r = R_PPC_REL24;		break;
    case BFD_RELOC_PPC_B16:		r = R_PPC_REL14;		break;
    case BFD_RELOC_PPC_B16_BRTAKEN:	r = R_PPC_REL14_BRTAKEN;	break;
    case BFD_RELOC_PPC_B16_BRNTAKEN:	r = R_PPC_REL14_BRNTAKEN;	break;
    case BFD_RELOC_16_GOTOFF:		r = R_PPC_GOT16;		break;
    case BFD_RELOC_LO16_GOTOFF:		r = R_PPC_GOT16_LO;		break;
    case BFD_RELOC_HI16_GOTOFF:		r = R_PPC_GOT16_HI;		break;
    case BFD_RELOC_HI16_S_GOTOFF:	r = R_PPC_GOT16_HA;		break;
    case BFD_RELOC_24_PLT_PCREL:	r = R_PPC_PLTREL24;		break;
    case BFD_RELOC_PPC_COPY:		r = R_PPC_COPY;			break;
    case BFD_RELOC_PPC_GLOB_DAT:	r = R_PPC_GLOB_DAT;		break;
    case BFD_RELOC_PPC_LOCAL24PC:	r = R_PPC_LOCAL24PC;		break;
    case BFD_RELOC_32_PCREL:		r = R_PPC_REL32;		break;
    case BFD_RELOC_32_PLTOFF:		r = R_PPC_PLT32;		break;
    case BFD_RELOC_32_PLT_PCREL:	r = R_PPC_PLTREL32;		break;
    case BFD_RELOC_LO16_PLTOFF:		r = R_PPC_PLT16_LO;		break;
    case BFD_RELOC_HI16_PLTOFF:		r = R_PPC_PLT16_HI;		break;
    case BFD_RELOC_HI16_S_PLTOFF:	r = R_PPC_PLT16_HA;		break;
    case BFD_RELOC_GPREL16:		r = R_PPC_SDAREL16;		break;
    case BFD_RELOC_16_BASEREL:		r = R_PPC_SECTOFF;		break;
    case BFD_RELOC_LO16_BASEREL:	r = R_PPC_SECTOFF_LO;		break;
    case BFD_RELOC_HI16_BASEREL:	r = R_PPC_SECTOFF_HI;		break;
    case BFD_RELOC_HI16_S_BASEREL:	r = R_PPC_SECTOFF_HA;		break;
    case BFD_RELOC_CTOR:		r = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC_TOC16:		r = R_PPC_TOC16;		break;
    case BFD_RELOC_PPC_TLS:		r = R_PPC_TLS;			break;
    case BFD_RELOC_PPC_DTPMOD:		r = R_PPC_DTPMOD32;		break;
    case BFD_RELOC_PPC_TPREL16:		r = R_PPC_TPREL16;		break;
    case BFD_RELOC_PPC_TPREL16_LO:	r = R_PPC_TPREL16_LO;		break;
    case BFD_RELOC_PPC_TPREL16_HI:	r = R_PPC_TPREL16_HI;		break;
    case BFD_RELOC_PPC_TPREL16_HA:	r = R_PPC_TPREL16_HA;		break;
    case BFD_RELOC_PPC_TPREL:		r = R_PPC_TPREL32;		break;
    case BFD_RELOC_PPC_DTPREL16:	r = R_PPC_DTPREL16;		break;
    case BFD_RELOC_PPC_DTPREL16_LO:	r = R_PPC_DTPREL16_LO;		break;
    case BFD_RELOC_PPC_DTPREL16_HI:	r = R_PPC_DTPREL16_HI;		break;
    case BFD_RELOC_PPC_DTPREL16_HA:	r = R_PPC_DTPREL16_HA;		break;
    case BFD_RELOC_PPC_DTPREL:		r = R_PPC_DTPREL32;		break;
    case BFD_RELOC_PPC_GOT_TLSGD16:	r = R_PPC_GOT_TLSGD16;		break;
    case BFD_RELOC_PPC_GOT_TLSGD16_LO:	r = R_PPC_GOT_TLSGD16_LO;	break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HI:	r = R_PPC_GOT_TLSGD16_HI;	break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HA:	r = R_PPC_GOT_TLSGD16_HA;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16:	r = R_PPC_GOT_TLSLD16;		break;
    case BFD_RELOC_PPC_GOT_TLSLD16_LO:	r = R_PPC_GOT_TLSLD16_LO;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HI:	r = R_PPC_GOT_TLSLD16_HI;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HA:	r = R_PPC_GOT_TLSLD16_HA;	break;
    case BFD_RELOC_PPC_GOT_TPREL16:	r = R_PPC_GOT_TPREL16;		break;
    case BFD_RELOC_PPC_GOT_TPREL16_LO:	r = R_PPC_GOT_TPREL16_LO;	break;
    case BFD_RELOC_PPC_GOT_TPREL16_HI:	r = R_PPC_GOT_TPREL16_HI;	break;
    case BFD_RELOC_PPC_GOT_TPREL16_HA:	r = R_PPC_GOT_TPREL16_HA;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16:	r = R_PPC_GOT_DTPREL16;		break;
    case BFD_RELOC_PPC_GOT_DTPREL16_LO:	r = R_PPC_GOT_DTPREL16_LO;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HI:	r = R_PPC_GOT_DTPREL16_HI;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HA:	r = R_PPC_GOT_DTPREL16_HA;	break;
    case BFD_RELOC_PPC_EMB_NADDR32:	r = R_PPC_EMB_NADDR32;		break;
    case BFD_RELOC_PPC_EMB_NADDR16:	r = R_PPC_EMB_NADDR16;		break;
    case BFD_RELOC_PPC_EMB_NADDR16_LO:	r = R_PPC_EMB_NADDR16_LO;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HI:	r = R_PPC_EMB_NADDR16_HI;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HA:	r = R_PPC_EMB_NADDR16_HA;	break;
    case BFD_RELOC_PPC_EMB_SDAI16:	r = R_PPC_EMB_SDAI16;		break;
    case BFD_RELOC_PPC_EMB_SDA2I16:	r = R_PPC_EMB_SDA2I16;		break;
    case BFD_RELOC_PPC_EMB_SDA2REL:	r = R_PPC_EMB_SDA2REL;		break;
    case BFD_RELOC_PPC_EMB_SDA21:	r = R_PPC_EMB_SDA21;		break;
    case BFD_RELOC_PPC_EMB_MRKREF:	r = R_PPC_EMB_MRKREF;		break;
    case BFD_RELOC_PPC_EMB_RELSEC16:	r = R_PPC_EMB_RELSEC16;		break;
    case BFD_RELOC_PPC_EMB_RELST_LO:	r = R_PPC_EMB_RELST_LO;		break;
    case BFD_RELOC_PPC_EMB_RELST_HI:	r = R_PPC_EMB_RELST_HI;		break;
    case BFD_RELOC_PPC_EMB_RELST_HA:	r = R_PPC_EMB_RELST_HA;		break;
    case BFD_RELOC_PPC_EMB_BIT_FLD:	r = R_PPC_EMB_BIT_FLD;		break;
    case BFD_RELOC_PPC_EMB_RELSDA:	r = R_PPC_EMB_RELSDA;		break;
    case BFD_RELOC_VTABLE_INHERIT:	r = R_PPC_GNU_VTINHERIT;	break;
    case BFD_RELOC_VTABLE_ENTRY:	r = R_PPC_GNU_VTENTRY;		break;
d1870 3
a1872 2
  return ppc_elf_howto_table[r];
};
d1874 4
a1877 1
/* Set the howto pointer for a PowerPC ELF reloc.  */
d1879 2
a1880 4
static void
ppc_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *cache_ptr,
		       Elf_Internal_Rela *dst)
d1882 7
a1888 3
  /* Initialize howto table if not already done.  */
  if (!ppc_elf_howto_table[R_PPC_ADDR32])
    ppc_elf_howto_init ();
d1890 1
a1890 2
  BFD_ASSERT (ELF32_R_TYPE (dst->r_info) < (unsigned int) R_PPC_max);
  cache_ptr->howto = ppc_elf_howto_table[ELF32_R_TYPE (dst->r_info)];
d1893 12
a1904 1
/* Handle the R_PPC_ADDR16_HA reloc.  */
d1906 2
a1907 8
static bfd_reloc_status_type
ppc_elf_addr16_ha_reloc (bfd *abfd ATTRIBUTE_UNUSED,
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void *data ATTRIBUTE_UNUSED,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message ATTRIBUTE_UNUSED)
d1909 1
a1909 1
  bfd_vma relocation;
d1911 1
a1911 1
  if (output_bfd != NULL)
d1913 3
a1915 2
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
d1918 2
a1919 2
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;
d1921 2
a1922 4
  if (bfd_is_com_section (symbol->section))
    relocation = 0;
  else
    relocation = symbol->value;
d1924 2
a1925 3
  relocation += symbol->section->output_section->vma;
  relocation += symbol->section->output_offset;
  relocation += reloc_entry->addend;
d1927 2
a1928 13
  reloc_entry->addend += (relocation & 0x8000) << 1;

  return bfd_reloc_continue;
}

static bfd_reloc_status_type
ppc_elf_unhandled_reloc (bfd *abfd,
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void *data,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message)
d1930 10
a1939 6
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);
d1941 2
a1942 9
  if (error_message != NULL)
    {
      static char buf[60];
      sprintf (buf, _("generic linker can't handle %s"),
	       reloc_entry->howto->name);
      *error_message = buf;
    }
  return bfd_reloc_dangerous;
}
d1944 3
a1946 2
/* Fix bad default arch selected for a 32 bit input bfd when the
   default is 64 bit.  */
d1948 1
a1948 4
static bfd_boolean
ppc_elf_object_p (bfd *abfd)
{
  if (abfd->arch_info->the_default && abfd->arch_info->bits_per_word == 64)
d1950 2
a1951 3
      Elf_Internal_Ehdr *i_ehdr = elf_elfheader (abfd);

      if (i_ehdr->e_ident[EI_CLASS] == ELFCLASS32)
d1953 2
a1954 3
	  /* Relies on arch after 64 bit default being 32 bit default.  */
	  abfd->arch_info = abfd->arch_info->next;
	  BFD_ASSERT (abfd->arch_info->bits_per_word == 32);
a1956 2
  return TRUE;
}
d1958 4
a1961 1
/* Function to set whether a module needs the -mrelocatable bit set.  */
d1963 4
a1966 5
static bfd_boolean
ppc_elf_set_private_flags (bfd *abfd, flagword flags)
{
  BFD_ASSERT (!elf_flags_init (abfd)
	      || elf_elfheader (abfd)->e_flags == flags);
d1968 4
a1971 4
  elf_elfheader (abfd)->e_flags = flags;
  elf_flags_init (abfd) = TRUE;
  return TRUE;
}
d1973 2
a1974 2
/* Merge backend specific data from an object file to the output
   object file when linking.  */
d1976 2
a1977 18
static bfd_boolean
ppc_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  flagword old_flags;
  flagword new_flags;
  bfd_boolean error;

  /* Check if we have the same endianess.  */
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
    return FALSE;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return TRUE;

  new_flags = elf_elfheader (ibfd)->e_flags;
  old_flags = elf_elfheader (obfd)->e_flags;
  if (!elf_flags_init (obfd))
d1979 2
a1980 4
      /* First call, no flags set.  */
      elf_flags_init (obfd) = TRUE;
      elf_elfheader (obfd)->e_flags = new_flags;
    }
d1982 3
a1984 3
  /* Compatible flags are ok.  */
  else if (new_flags == old_flags)
    ;
d1986 2
a1987 8
  /* Incompatible flags.  */
  else
    {
      /* Warn about -mrelocatable mismatch.  Allow -mrelocatable-lib
	 to be linked with either.  */
      error = FALSE;
      if ((new_flags & EF_PPC_RELOCATABLE) != 0
	  && (old_flags & (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB)) == 0)
d1989 2
a1990 4
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%B: compiled with -mrelocatable and linked with "
	       "modules compiled normally"), ibfd);
d1992 3
a1994 2
      else if ((new_flags & (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB)) == 0
	       && (old_flags & EF_PPC_RELOCATABLE) != 0)
d1996 2
a1997 4
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%B: compiled normally and linked with "
	       "modules compiled with -mrelocatable"), ibfd);
d2000 14
a2013 3
      /* The output is -mrelocatable-lib iff both the input files are.  */
      if (! (new_flags & EF_PPC_RELOCATABLE_LIB))
	elf_elfheader (obfd)->e_flags &= ~EF_PPC_RELOCATABLE_LIB;
d2015 2
a2016 6
      /* The output is -mrelocatable iff it can't be -mrelocatable-lib,
	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
      if (! (elf_elfheader (obfd)->e_flags & EF_PPC_RELOCATABLE_LIB)
	  && (new_flags & (EF_PPC_RELOCATABLE_LIB | EF_PPC_RELOCATABLE))
	  && (old_flags & (EF_PPC_RELOCATABLE_LIB | EF_PPC_RELOCATABLE)))
	elf_elfheader (obfd)->e_flags |= EF_PPC_RELOCATABLE;
d2018 4
a2021 3
      /* Do not warn about eabi vs. V.4 mismatch, just or in the bit if
	 any module uses it.  */
      elf_elfheader (obfd)->e_flags |= (new_flags & EF_PPC_EMB);
d2023 3
a2025 2
      new_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
      old_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
d2027 3
a2029 9
      /* Warn about any other mismatches.  */
      if (new_flags != old_flags)
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%B: uses different e_flags (0x%lx) fields "
	       "than previous modules (0x%lx)"),
	     ibfd, (long) new_flags, (long) old_flags);
	}
d2031 2
a2032 5
      if (error)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
d2035 1
a2035 5
  return TRUE;
}

/* Handle a PowerPC specific section when reading an object file.  This
   is called when elfcode.h finds a section with an unknown type.  */
d2037 3
a2039 5
static bfd_boolean
ppc_elf_section_from_shdr (bfd *abfd, Elf_Internal_Shdr *hdr, const char *name)
{
  asection *newsect;
  flagword flags;
d2041 1
a2041 2
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
    return FALSE;
d2043 3
a2045 4
  newsect = hdr->bfd_section;
  flags = bfd_get_section_flags (abfd, newsect);
  if (hdr->sh_flags & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;
d2047 2
a2048 2
  if (hdr->sh_type == SHT_ORDERED)
    flags |= SEC_SORT_ENTRIES;
d2050 2
a2051 2
  bfd_set_section_flags (abfd, newsect, flags);
  return TRUE;
d2053 3
a2055 2

/* Set up any other section flags and such that may be necessary.  */
d2058 3
a2060 3
ppc_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
		       Elf_Internal_Shdr *shdr,
		       asection *asect)
d2062 3
a2064 2
  if ((asect->flags & SEC_EXCLUDE) != 0)
    shdr->sh_flags |= SHF_EXCLUDE;
d2066 1
a2066 2
  if ((asect->flags & SEC_SORT_ENTRIES) != 0)
    shdr->sh_type = SHT_ORDERED;
d2068 2
a2069 10
  return TRUE;
}

/* Find a linker generated pointer with a given addend and type.  */

static elf_linker_section_pointers_t *
elf_find_pointer_linker_section
  (elf_linker_section_pointers_t *linker_pointers,
   bfd_vma addend,
   elf_linker_section_t *lsect)
d2071 5
a2075 3
  for ( ; linker_pointers != NULL; linker_pointers = linker_pointers->next)
    if (lsect == linker_pointers->lsect && addend == linker_pointers->addend)
      return linker_pointers;
d2077 3
a2079 4
  return NULL;
}

/* Allocate a pointer to live in a linker created section.  */
d2081 2
a2082 11
static bfd_boolean
elf_create_pointer_linker_section (bfd *abfd,
				   struct bfd_link_info *info,
				   elf_linker_section_t *lsect,
				   struct elf_link_hash_entry *h,
				   const Elf_Internal_Rela *rel)
{
  elf_linker_section_pointers_t **ptr_linker_section_ptr = NULL;
  elf_linker_section_pointers_t *linker_section_ptr;
  unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
  bfd_size_type amt;
d2084 3
a2086 1
  BFD_ASSERT (lsect != NULL);
d2088 2
a2089 2
  /* Is this a global symbol?  */
  if (h != NULL)
d2091 11
a2101 1
      struct ppc_elf_link_hash_entry *eh;
d2103 6
a2108 6
      /* Has this symbol already been allocated?  If so, our work is done.  */
      eh = (struct ppc_elf_link_hash_entry *) h;
      if (elf_find_pointer_linker_section (eh->linker_section_pointer,
					   rel->r_addend,
					   lsect))
	return TRUE;
d2110 2
a2111 7
      ptr_linker_section_ptr = &eh->linker_section_pointer;
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}
d2113 20
a2132 7
      if (lsect->rel_section)
	lsect->rel_section->size += sizeof (Elf32_External_Rela);
    }
  else
    {
      /* Allocation of a pointer to a local symbol.  */
      elf_linker_section_pointers_t **ptr = elf_local_ptr_offsets (abfd);
d2134 3
a2136 4
      /* Allocate a table to hold the local symbols if first time.  */
      if (!ptr)
	{
	  unsigned int num_symbols = elf_tdata (abfd)->symtab_hdr.sh_info;
d2138 2
a2139 3
	  amt = num_symbols;
	  amt *= sizeof (elf_linker_section_pointers_t *);
	  ptr = bfd_zalloc (abfd, amt);
d2141 2
a2142 2
	  if (!ptr)
	    return FALSE;
d2144 3
a2146 2
	  elf_local_ptr_offsets (abfd) = ptr;
	}
d2148 3
a2150 5
      /* Has this symbol already been allocated?  If so, our work is done.  */
      if (elf_find_pointer_linker_section (ptr[r_symndx],
					   rel->r_addend,
					   lsect))
	return TRUE;
d2152 6
a2157 1
      ptr_linker_section_ptr = &ptr[r_symndx];
d2159 5
a2163 9
      if (info->shared)
	{
	  /* If we are generating a shared object, we need to
	     output a R_<xxx>_RELATIVE reloc so that the
	     dynamic linker can adjust this GOT entry.  */
	  BFD_ASSERT (lsect->rel_section != NULL);
	  lsect->rel_section->size += sizeof (Elf32_External_Rela);
	}
    }
d2165 1
a2165 5
  /* Allocate space for a pointer in the linker section, and allocate
     a new pointer record from internal memory.  */
  BFD_ASSERT (ptr_linker_section_ptr != NULL);
  amt = sizeof (elf_linker_section_pointers_t);
  linker_section_ptr = bfd_alloc (abfd, amt);
d2167 3
a2169 2
  if (!linker_section_ptr)
    return FALSE;
d2171 4
a2174 5
  linker_section_ptr->next = *ptr_linker_section_ptr;
  linker_section_ptr->addend = rel->r_addend;
  linker_section_ptr->lsect = lsect;
  linker_section_ptr->written_address_p = FALSE;
  *ptr_linker_section_ptr = linker_section_ptr;
d2176 2
a2177 2
  linker_section_ptr->offset = lsect->section->size;
  lsect->section->size += 4;
d2179 13
a2191 6
#ifdef DEBUG
  fprintf (stderr,
	   "Create pointer in linker section %s, offset = %ld, section size = %ld\n",
	   lsect->name, (long) linker_section_ptr->offset,
	   (long) lsect->section->size);
#endif
d2193 1
a2193 4
  return TRUE;
}

#define bfd_put_ptr(BFD, VAL, ADDR) bfd_put_32 (BFD, VAL, ADDR)
d2195 1
a2195 1
/* Fill in the address for a pointer generated in a linker section.  */
d2197 1
a2197 9
static bfd_vma
elf_finish_pointer_linker_section (bfd *output_bfd,
				   bfd *input_bfd,
				   struct bfd_link_info *info,
				   elf_linker_section_t *lsect,
				   struct elf_link_hash_entry *h,
				   bfd_vma relocation,
				   const Elf_Internal_Rela *rel,
				   int relative_reloc)
d2199 17
a2215 1
  elf_linker_section_pointers_t *linker_section_ptr;
d2217 5
a2221 1
  BFD_ASSERT (lsect != NULL);
d2223 3
a2225 4
  if (h != NULL)
    {
      /* Handle global symbol.  */
      struct ppc_elf_link_hash_entry *eh;
d2227 1
a2227 5
      eh = (struct ppc_elf_link_hash_entry *) h;
      linker_section_ptr
	= elf_find_pointer_linker_section (eh->linker_section_pointer,
					   rel->r_addend,
					   lsect);
d2229 2
a2230 1
      BFD_ASSERT (linker_section_ptr != NULL);
d2232 1
a2232 9
      if (! elf_hash_table (info)->dynamic_sections_created
	  || (info->shared
	      && info->symbolic
	      && h->def_regular))
	{
	  /* This is actually a static link, or it is a
	     -Bsymbolic link and the symbol is defined
	     locally.  We must initialize this entry in the
	     global section.
d2234 13
a2246 12
	     When doing a dynamic link, we create a .rela.<xxx>
	     relocation entry to initialize the value.  This
	     is done in the finish_dynamic_symbol routine.  */
	  if (!linker_section_ptr->written_address_p)
	    {
	      linker_section_ptr->written_address_p = TRUE;
	      bfd_put_ptr (output_bfd,
			   relocation + linker_section_ptr->addend,
			   (lsect->section->contents
			    + linker_section_ptr->offset));
	    }
	}
d2248 4
a2251 1
  else
d2253 4
a2256 8
      /* Handle local symbol.  */
      unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd) != NULL);
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd)[r_symndx] != NULL);
      linker_section_ptr = (elf_find_pointer_linker_section
			    (elf_local_ptr_offsets (input_bfd)[r_symndx],
			     rel->r_addend,
			     lsect));
d2258 2
a2259 1
      BFD_ASSERT (linker_section_ptr != NULL);
d2261 1
a2261 6
      /* Write out pointer if it hasn't been rewritten out before.  */
      if (!linker_section_ptr->written_address_p)
	{
	  linker_section_ptr->written_address_p = TRUE;
	  bfd_put_ptr (output_bfd, relocation + linker_section_ptr->addend,
		       lsect->section->contents + linker_section_ptr->offset);
d2263 4
a2266 4
	  if (info->shared)
	    {
	      /* We need to generate a relative reloc for the dynamic
		 linker.  */
d2268 3
a2270 5
	      asection *srel = lsect->rel_section;
	      Elf_Internal_Rela outrel[MAX_INT_RELS_PER_EXT_REL];
	      bfd_byte *erel;
	      const struct elf_backend_data *bed;
	      unsigned int i;
d2272 6
a2277 1
	      BFD_ASSERT (srel != NULL);
d2279 123
a2401 14
	      bed = get_elf_backend_data (output_bfd);
	      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
		{
		  outrel[i].r_offset = (lsect->section->output_section->vma
					+ lsect->section->output_offset
					+ linker_section_ptr->offset);
		  outrel[i].r_info = 0;
		  outrel[i].r_addend = 0;
		}
	      outrel[0].r_info = ELF32_R_INFO (0, relative_reloc);
	      erel = lsect->section->contents;
	      erel += (elf_section_data (lsect->section)->rel_count++
		       * sizeof (Elf32_External_Rela));
	      bfd_elf32_swap_reloca_out (output_bfd, outrel, erel);
d2403 1
d2405 18
d2424 30
d2455 5
a2459 3
  relocation = (lsect->section->output_offset
		+ linker_section_ptr->offset
		- lsect->sym_offset);
d2461 3
a2463 5
#ifdef DEBUG
  fprintf (stderr,
	   "Finish pointer in linker section %s, offset = %ld (0x%lx)\n",
	   lsect->name, (long) relocation, (long) relocation);
#endif
d2465 1
a2465 3
  /* Subtract out the addend, because it will get added back in by the normal
     processing.  */
  return relocation - linker_section_ptr->addend;
d2468 7
a2595 3

/* If we have .sbss2 or .PPC.EMB.sbss0 output sections, we
   need to bump up the number of section headers.  */
d2597 7
a2603 2
static int
ppc_elf_additional_program_headers (bfd *abfd)
d2605 3
a2607 2
  asection *s;
  int ret = 0;
d2609 2
a2610 3
  s = bfd_get_section_by_name (abfd, ".sbss2");
  if (s != NULL && (s->flags & SEC_ALLOC) != 0)
    ++ret;
d2612 1
a2612 8
  s = bfd_get_section_by_name (abfd, ".PPC.EMB.sbss0");
  if (s != NULL && (s->flags & SEC_ALLOC) != 0)
    ++ret;

  return ret;
}

/* The powerpc .got has a blrl instruction in it.  Mark it executable.  */
d2615 5
a2619 1
ppc_elf_create_got (bfd *abfd, struct bfd_link_info *info)
d2621 4
a2624 3
  struct ppc_elf_link_hash_table *htab;
  asection *s;
  flagword flags;
d2626 34
a2659 2
  if (!_bfd_elf_create_got_section (abfd, info))
    return FALSE;
d2661 3
a2663 4
  htab = ppc_elf_hash_table (info);
  htab->got = s = bfd_get_section_by_name (abfd, ".got");
  if (s == NULL)
    abort ();
d2665 2
a2666 4
  flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
  if (!bfd_set_section_flags (abfd, s, flags))
    return FALSE;
d2668 2
a2669 8
  htab->relgot = bfd_make_section (abfd, ".rela.got");
  if (!htab->relgot
      || ! bfd_set_section_flags (abfd, htab->relgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, htab->relgot, 2))
    return FALSE;
d2671 5
a2675 2
  return TRUE;
}
d2677 1
a2677 3
/* We have to create .dynsbss and .rela.sbss here so that they get mapped
   to output sections (just like _bfd_elf_create_dynamic_sections has
   to create .dynbss and .rela.bss).  */
d2679 9
a2687 6
static bfd_boolean
ppc_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
{
  struct ppc_elf_link_hash_table *htab;
  asection *s;
  flagword flags;
d2689 5
a2693 1
  htab = ppc_elf_hash_table (info);
d2695 1
a2695 2
  if (htab->got == NULL
      && !ppc_elf_create_got (abfd, info))
d2698 15
a2712 2
  if (!_bfd_elf_create_dynamic_sections (abfd, info))
    return FALSE;
d2714 2
a2715 2
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
d2717 8
a2724 5
  htab->dynbss = bfd_get_section_by_name (abfd, ".dynbss");
  htab->dynsbss = s = bfd_make_section (abfd, ".dynsbss");
  if (s == NULL
      || ! bfd_set_section_flags (abfd, s, SEC_ALLOC | SEC_LINKER_CREATED))
    return FALSE;
d2726 1
a2726 1
  if (! info->shared)
d2728 5
a2732 5
      htab->relbss = bfd_get_section_by_name (abfd, ".rela.bss");
      htab->relsbss = s = bfd_make_section (abfd, ".rela.sbss");
      if (s == NULL
	  || ! bfd_set_section_flags (abfd, s, flags | SEC_READONLY)
	  || ! bfd_set_section_alignment (abfd, s, 2))
d2734 1
d2737 5
a2741 4
  htab->relplt = bfd_get_section_by_name (abfd, ".rela.plt");
  htab->plt = s = bfd_get_section_by_name (abfd, ".plt");
  if (s == NULL)
    abort ();
d2743 8
a2750 2
  flags = SEC_ALLOC | SEC_CODE | SEC_IN_MEMORY | SEC_LINKER_CREATED;
  return bfd_set_section_flags (abfd, s, flags);
d2753 3
a2755 5
/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */
d2758 4
a2761 2
ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
			       struct elf_link_hash_entry *h)
d2764 8
a2771 2
  asection *s;
  unsigned int power_of_two;
d2774 2
a2775 2
  fprintf (stderr, "ppc_elf_adjust_dynamic_symbol called for %s\n",
	   h->root.root.string);
d2778 6
a2783 1
  /* Make sure we know what is going on here.  */
d2785 1
a2785 10
  BFD_ASSERT (htab->elf.dynobj != NULL
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));

  /* Deal with function syms.  */
  if (h->type == STT_FUNC
      || h->needs_plt)
d2787 4
a2790 21
      /* Clear procedure linkage table information for any symbol that
	 won't need a .plt entry.  */
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
	{
	  /* A PLT entry is not required/allowed when:

	     1. We are not using ld.so; because then the PLT entry
	     can't be set up, so we can't use one.  In this case,
	     ppc_elf_adjust_dynamic_symbol won't even be called.

	     2. GC has rendered the entry unused.

	     3. We know for certain that a call to this symbol
	     will go to this object, or will remain undefined.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}
      return TRUE;
a2791 2
  else
    h->plt.offset = (bfd_vma) -1;
d2793 1
a2793 4
  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
d2795 4
a2798 7
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      if (ELIMINATE_COPY_RELOCS)
	h->non_got_ref = h->u.weakdef->non_got_ref;
      return TRUE;
d2801 3
a2803 2
  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */
d2805 7
a2811 6
  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;
d2813 5
a2817 4
  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;
d2819 4
a2822 4
  if (ELIMINATE_COPY_RELOCS)
    {
      struct ppc_elf_dyn_relocs *p;
      for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
d2824 7
a2830 3
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
d2833 2
a2834 3
      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
d2836 14
a2849 4
	  h->non_got_ref = 0;
	  return TRUE;
	}
    }
d2851 8
a2858 9
  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.
d2860 8
a2867 3
     Of course, if the symbol is sufficiently small, we must instead
     allocate it in .sbss.  FIXME: It would be better to do this if and
     only if there were actually SDAREL relocs for that symbol.  */
d2869 23
a2891 5
  if (h->size <= elf_gp_size (htab->elf.dynobj))
    s = htab->dynsbss;
  else
    s = htab->dynbss;
  BFD_ASSERT (s != NULL);
d2893 11
a2903 7
  /* We must generate a R_PPC_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
    {
      asection *srel;
d2905 11
a2915 8
      if (h->size <= elf_gp_size (htab->elf.dynobj))
	srel = htab->relsbss;
      else
	srel = htab->relbss;
      BFD_ASSERT (srel != NULL);
      srel->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }
d2917 15
a2931 5
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 4)
    power_of_two = 4;
d2933 14
a2946 7
  /* Apply the required alignment.  */
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
    {
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
	return FALSE;
    }
d2948 13
a2960 3
  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;
d2962 3
a2964 2
  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;
d2966 13
a2978 6
  return TRUE;
}

/* Of those relocs that might be copied as dynamic relocs, this macro
   selects those that must be copied when linking a shared library,
   even when the symbol is local.  */
d2980 6
a2985 6
#define MUST_BE_DYN_RELOC(RTYPE)		\
  ((RTYPE) != R_PPC_REL24			\
   && (RTYPE) != R_PPC_REL14			\
   && (RTYPE) != R_PPC_REL14_BRTAKEN		\
   && (RTYPE) != R_PPC_REL14_BRNTAKEN		\
   && (RTYPE) != R_PPC_REL32)
d2987 6
a2992 1
/* Allocate space in associated reloc sections for dynamic relocs.  */
d2994 8
a3001 7
static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info = inf;
  struct ppc_elf_link_hash_entry *eh;
  struct ppc_elf_link_hash_table *htab;
  struct ppc_elf_dyn_relocs *p;
d3003 3
a3005 2
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;
d3007 6
a3012 5
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d3014 4
a3017 9
  htab = ppc_elf_hash_table (info);
  if (htab->elf.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3019 7
a3025 1
	}
d3027 4
a3030 4
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->plt;
d3032 7
a3038 4
	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->size == 0)
	    s->size += PLT_INITIAL_ENTRY_SIZE;
d3040 12
a3051 7
	  /* The PowerPC PLT is actually composed of two parts, the
	     first part is 2 words (for a load and a jump), and then
	     there is a remaining word available at the end.  */
	  h->plt.offset = (PLT_INITIAL_ENTRY_SIZE
			   + (PLT_SLOT_SIZE
			      * ((s->size - PLT_INITIAL_ENTRY_SIZE)
				 / PLT_ENTRY_SIZE)));
d3053 12
a3064 7
	  /* If this symbol is not defined in a regular file, and we
	     are not generating a shared library, then set the symbol
	     to this location in the .plt.  This is required to make
	     function pointers compare as equal between the normal
	     executable and the shared library.  */
	  if (! info->shared
	      && !h->def_regular)
d3066 6
a3071 2
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
d3074 17
a3090 6
	  /* Make room for this entry.  After the 8192nd entry, room
	     for two entries is allocated.  */
	  s->size += PLT_ENTRY_SIZE;
	  if ((s->size - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
	      > PLT_NUM_SINGLE_ENTRIES)
	    s->size += PLT_ENTRY_SIZE;
d3092 4
a3095 48
	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->relplt->size += sizeof (Elf32_External_Rela);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
    }

  eh = (struct ppc_elf_link_hash_entry *) h;
  if (eh->elf.got.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (eh->elf.dynindx == -1
	  && !eh->elf.forced_local)
	{
	  if (!bfd_elf_link_record_dynamic_symbol (info, &eh->elf))
	    return FALSE;
	}

      if (eh->tls_mask == (TLS_TLS | TLS_LD)
	  && !eh->elf.def_dynamic)
	/* If just an LD reloc, we'll just use htab->tlsld_got.offset.  */
	eh->elf.got.offset = (bfd_vma) -1;
      else
	{
	  bfd_boolean dyn;
	  eh->elf.got.offset = htab->got->size;
	  if ((eh->tls_mask & TLS_TLS) != 0)
	    {
	      if ((eh->tls_mask & TLS_LD) != 0)
		htab->got->size += 8;
	      if ((eh->tls_mask & TLS_GD) != 0)
		htab->got->size += 8;
	      if ((eh->tls_mask & (TLS_TPREL | TLS_TPRELGD)) != 0)
		htab->got->size += 4;
	      if ((eh->tls_mask & TLS_DTPREL) != 0)
		htab->got->size += 4;
	    }
	  else
	    htab->got->size += 4;
	  dyn = htab->elf.dynamic_sections_created;
d3097 11
a3107 3
	       || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, &eh->elf))
	      && (ELF_ST_VISIBILITY (eh->elf.other) == STV_DEFAULT
		  || eh->elf.root.type != bfd_link_hash_undefweak))
d3109 2
a3110 12
	      /* All the entries we allocated need relocs.  */
	      htab->relgot->size
		+= ((htab->got->size - eh->elf.got.offset) / 4
		    * sizeof (Elf32_External_Rela));
	      /* Except LD only needs one.  */
	      if ((eh->tls_mask & TLS_LD) != 0)
		htab->relgot->size -= sizeof (Elf32_External_Rela);
	    }
	}
    }
  else
    eh->elf.got.offset = (bfd_vma) -1;
d3112 10
a3121 2
  if (eh->dyn_relocs == NULL)
    return TRUE;
d3123 6
a3128 5
  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for relocs that have become local due to symbol visibility
     changes.  */
d3130 3
a3132 11
  if (info->shared)
    {
      /* Relocs that use pc_count are those that appear on a call insn,
	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be
	 generated via assembly.  We want calls to protected symbols to
	 resolve directly to the function rather than going via the plt.
	 If people want function pointer comparisons to work as expected
	 then they should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct ppc_elf_dyn_relocs **pp;
d3134 26
a3159 6
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
d3161 10
a3170 3
		pp = &p->next;
	    }
	}
d3172 3
a3174 5
      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d3176 12
a3187 17
      /* Make sure undefined weak symbols are output as a dynamic symbol
	 in PIEs.  */
      if (info->pie
	  && eh->dyn_relocs != NULL
	  && h->dynindx == -1
	  && h->root.type == bfd_link_hash_undefweak
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}
    }
  else if (ELIMINATE_COPY_RELOCS)
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */
d3189 3
a3191 11
      if (!h->non_got_ref
	  && h->def_dynamic
	  && !h->def_regular)
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
d3194 1
a3194 4
	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
a3195 11

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->size += p->count * sizeof (Elf32_External_Rela);
d3200 3
d3204 6
a3209 4
/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void *info)
d3211 7
a3217 1
  struct ppc_elf_dyn_relocs *p;
d3219 6
a3224 2
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;
d3226 2
a3227 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d3229 3
a3231 12
  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL
	  && ((s->flags & (SEC_READONLY | SEC_ALLOC))
	      == (SEC_READONLY | SEC_ALLOC)))
	{
	  ((struct bfd_link_info *) info)->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
d3234 4
a3237 1
  return TRUE;
d3240 2
a3241 1
/* Set the sizes of the dynamic sections.  */
d3244 4
a3247 2
ppc_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			       struct bfd_link_info *info)
d3250 4
a3253 3
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;
d3255 1
a3255 3
#ifdef DEBUG
  fprintf (stderr, "ppc_elf_size_dynamic_sections called\n");
#endif
d3258 3
a3260 1
  BFD_ASSERT (htab->elf.dynobj != NULL);
d3262 2
a3263 1
  if (elf_hash_table (info)->dynamic_sections_created)
d3265 6
a3270 2
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
d3272 2
a3273 6
	  s = bfd_get_section_by_name (htab->elf.dynobj, ".interp");
	  BFD_ASSERT (s != NULL);
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }
d3275 5
a3279 9
  if (htab->tlsld_got.refcount > 0)
    {
      htab->tlsld_got.offset = htab->got->size;
      htab->got->size += 8;
      if (info->shared)
	htab->relgot->size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tlsld_got.offset = (bfd_vma) -1;
d3281 8
a3288 10
  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *lgot_masks;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
d3290 2
a3291 4
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
d3293 6
a3298 1
	  struct ppc_elf_dyn_relocs *p;
d3300 22
a3321 4
	  for (p = ((struct ppc_elf_dyn_relocs *)
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
d3323 2
a3324 17
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  elf_section_data (p->sec)->sreloc->size
		    += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags
		       & (SEC_READONLY | SEC_ALLOC))
		      == (SEC_READONLY | SEC_ALLOC))
		    info->flags |= DF_TEXTREL;
		}
d3326 11
a3336 1
	}
d3338 22
a3359 3
      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;
d3361 3
a3363 43
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      lgot_masks = (char *) end_local_got;
      s = htab->got;
      srel = htab->relgot;
      for (; local_got < end_local_got; ++local_got, ++lgot_masks)
	if (*local_got > 0)
	  {
	    if (*lgot_masks == (TLS_TLS | TLS_LD))
	      {
		/* If just an LD reloc, we'll just use
		   htab->tlsld_got.offset.  */
		if (htab->tlsld_got.offset == (bfd_vma) -1)
		  {
		    htab->tlsld_got.offset = s->size;
		    s->size += 8;
		    if (info->shared)
		      srel->size += sizeof (Elf32_External_Rela);
		  }
		*local_got = (bfd_vma) -1;
	      }
	    else
	      {
		*local_got = s->size;
		if ((*lgot_masks & TLS_TLS) != 0)
		  {
		    if ((*lgot_masks & TLS_GD) != 0)
		      s->size += 8;
		    if ((*lgot_masks & (TLS_TPREL | TLS_TPRELGD)) != 0)
		      s->size += 4;
		    if ((*lgot_masks & TLS_DTPREL) != 0)
		      s->size += 4;
		  }
		else
		  s->size += 4;
		if (info->shared)
		  srel->size += ((s->size - *local_got) / 4
				 * sizeof (Elf32_External_Rela));
	      }
	  }
	else
	  *local_got = (bfd_vma) -1;
d3365 4
d3370 4
a3373 2
  /* Allocate space for global sym dynamic relocs.  */
  elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, info);
d3375 3
a3377 7
  /* We've now determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = htab->elf.dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;
d3379 2
a3380 33
      if (s == htab->plt
	  || s == htab->got)
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if ((htab->sdata != NULL && s == htab->sdata->section)
	       || (htab->sdata2 != NULL && s == htab->sdata2->section))
	{
	  if (s->size == 0)
	    /* Don't strip these sections.  We need them because they
	       define _SDA_BASE_ and _SDA2_BASE_.  crt1.o makes a
	       reference to _SDA_BASE_ to set up r13.  */
	    continue;
	}
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
	{
	  if (s->size == 0)
	    {
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	    }
	  else
	    {
	      /* Remember whether there are any relocation sections.  */
	      relocs = TRUE;
d3382 2
a3383 10
	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}
d3385 7
a3391 5
      if (s->size == 0)
	{
	  _bfd_strip_section_from_output (info, s);
	  continue;
	}
d3393 2
a3394 5
      /* Allocate memory for the section contents.  */
      s->contents = bfd_zalloc (htab->elf.dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }
d3396 2
a3397 1
  if (htab->elf.dynamic_sections_created)
d3399 8
a3406 7
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in ppc_elf_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d3408 5
a3412 5
      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}
d3414 10
a3423 8
      if (htab->plt != NULL && htab->plt->size != 0)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}
d3425 133
a3557 7
      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;
	}
d3559 3
a3561 5
      /* If any dynamic relocs apply to a read-only section, then we
	 need a DT_TEXTREL entry.  */
      if ((info->flags & DF_TEXTREL) == 0)
	elf_link_hash_traverse (elf_hash_table (info), readonly_dynrelocs,
				info);
d3563 2
a3564 1
      if ((info->flags & DF_TEXTREL) != 0)
d3566 4
a3569 2
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return FALSE;
a3571 2
#undef add_dynamic_entry

d3575 5
a3579 39
static bfd_boolean
update_local_sym_info (bfd *abfd,
		       Elf_Internal_Shdr *symtab_hdr,
		       unsigned long r_symndx,
		       int tls_type)
{
  bfd_signed_vma *local_got_refcounts = elf_local_got_refcounts (abfd);
  char *local_got_tls_masks;

  if (local_got_refcounts == NULL)
    {
      bfd_size_type size = symtab_hdr->sh_info;

      size *= sizeof (*local_got_refcounts) + sizeof (*local_got_tls_masks);
      local_got_refcounts = bfd_zalloc (abfd, size);
      if (local_got_refcounts == NULL)
	return FALSE;
      elf_local_got_refcounts (abfd) = local_got_refcounts;
    }

  local_got_refcounts[r_symndx] += 1;
  local_got_tls_masks = (char *) (local_got_refcounts + symtab_hdr->sh_info);
  local_got_tls_masks[r_symndx] |= tls_type;
  return TRUE;
}

static void
bad_shared_reloc (bfd *abfd, enum elf_ppc_reloc_type r_type)
{
  (*_bfd_error_handler)
    (_("%B: relocation %s cannot be used when making a shared object"),
     abfd,
     ppc_elf_howto_table[r_type]->name);
  bfd_set_error (bfd_error_bad_value);
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */
d3582 2
a3583 4
ppc_elf_check_relocs (bfd *abfd,
		      struct bfd_link_info *info,
		      asection *sec,
		      const Elf_Internal_Rela *relocs)
d3586 2
a3587 8
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sreloc;

  if (info->relocatable)
    return TRUE;
d3590 2
a3591 2
  _bfd_error_handler ("ppc_elf_check_relocs called for section %A in %B",
		      sec, abfd);
d3594 8
a3601 3
  /* Initialize howto table if not already done.  */
  if (!ppc_elf_howto_table[R_PPC_ADDR32])
    ppc_elf_howto_init ();
d3603 3
a3605 4
  /* Create the linker generated sections all the time so that the
     special symbols are created.  */
  htab = ppc_elf_hash_table (info);
  if (htab->sdata == NULL)
d3607 8
a3614 5
      htab->sdata = ppc_elf_create_linker_section (abfd, info,
						   LINKER_SECTION_SDATA);
      if (htab->sdata == NULL)
	return FALSE;
    }
d3616 20
a3635 1
  if (htab->sdata2 == NULL)
d3637 7
a3643 4
      htab->sdata2 = ppc_elf_create_linker_section (abfd, info,
						    LINKER_SECTION_SDATA2);
      if (htab->sdata2 == NULL)
	return FALSE;
d3646 2
a3647 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  sreloc = NULL;
d3649 6
a3654 7
  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned long r_symndx;
      enum elf_ppc_reloc_type r_type;
      struct elf_link_hash_entry *h;
      int tls_type = 0;
d3656 4
a3659 5
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d3661 4
a3664 4
      /* If a relocation refers to _GLOBAL_OFFSET_TABLE_, create the .got.
	 This shows up in particular in an R_PPC_ADDR32 in the eabi
	 startup code.  */
      if (h && strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d3666 3
a3668 7
	  if (htab->got == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!ppc_elf_create_got (htab->elf.dynobj, info))
		return FALSE;
	    }
d3671 3
a3673 2
      r_type = ELF32_R_TYPE (rel->r_info);
      switch (r_type)
d3675 4
a3678 7
	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  htab->tlsld_got.refcount += 1;
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogottls;
d3680 9
a3688 6
	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogottls;
d3690 3
a3692 8
	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogottls;
d3694 5
a3698 8
	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	dogottls:
	  sec->has_tls_reloc = 1;
	  /* Fall thru */
d3700 7
a3706 23
	  /* GOT16 relocations */
	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_GOT16_HI:
	case R_PPC_GOT16_HA:
	  /* This symbol requires a global offset table entry.  */
	  if (htab->got == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!ppc_elf_create_got (htab->elf.dynobj, info))
		return FALSE;
	    }
	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	      ppc_elf_hash_entry (h)->tls_mask |= tls_type;
	    }
	  else
	    /* This is a global offset table entry for a local symbol.  */
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx, tls_type))
	      return FALSE;
	  break;
d3708 8
a3715 11
	  /* Indirect .sdata relocation.  */
	case R_PPC_EMB_SDAI16:
	  if (info->shared)
	    {
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
	    }
	  if (!elf_create_pointer_linker_section (abfd, info,
						  htab->sdata, h, rel))
	    return FALSE;
	  break;
d3717 5
a3721 11
	  /* Indirect .sdata2 relocation.  */
	case R_PPC_EMB_SDA2I16:
	  if (info->shared)
	    {
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
	    }
	  if (!elf_create_pointer_linker_section (abfd, info,
						  htab->sdata2, h, rel))
	    return FALSE;
	  break;
d3723 7
a3729 15
	case R_PPC_SDAREL16:
	case R_PPC_EMB_SDA2REL:
	case R_PPC_EMB_SDA21:
	case R_PPC_EMB_RELSDA:
	case R_PPC_EMB_NADDR32:
	case R_PPC_EMB_NADDR16:
	case R_PPC_EMB_NADDR16_LO:
	case R_PPC_EMB_NADDR16_HI:
	case R_PPC_EMB_NADDR16_HA:
	  if (info->shared)
	    {
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
	    }
	  break;
d3731 3
a3733 14
	case R_PPC_PLT32:
	case R_PPC_PLTREL24:
	case R_PPC_PLTREL32:
	case R_PPC_PLT16_LO:
	case R_PPC_PLT16_HI:
	case R_PPC_PLT16_HA:
#ifdef DEBUG
	  fprintf (stderr, "Reloc requires a PLT entry\n");
#endif
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in finish_dynamic_symbol,
	     because this might be a case of linking PIC code without
	     linking in any dynamic objects, in which case we don't
	     need to generate a procedure linkage table after all.  */
d3735 2
a3736 13
	  if (h == NULL)
	    {
	      /* It does not make sense to have a procedure linkage
		 table entry for a local symbol.  */
	      (*_bfd_error_handler) (_("%B(%A+0x%lx): %s reloc against "
				       "local symbol"),
				     abfd,
				     sec,
				     (long) rel->r_offset,
				     ppc_elf_howto_table[r_type]->name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
d3738 4
a3741 3
	  h->needs_plt = 1;
	  h->plt.refcount++;
	  break;
d3743 7
a3749 13
	  /* The following relocations don't need to propagate the
	     relocation if linking a shared object since they are
	     section relative.  */
	case R_PPC_SECTOFF:
	case R_PPC_SECTOFF_LO:
	case R_PPC_SECTOFF_HI:
	case R_PPC_SECTOFF_HA:
	case R_PPC_DTPREL16:
	case R_PPC_DTPREL16_LO:
	case R_PPC_DTPREL16_HI:
	case R_PPC_DTPREL16_HA:
	case R_PPC_TOC16:
	  break;
d3751 2
a3752 6
	  /* This are just markers.  */
	case R_PPC_TLS:
	case R_PPC_EMB_MRKREF:
	case R_PPC_NONE:
	case R_PPC_max:
	  break;
d3754 5
a3758 6
	  /* These should only appear in dynamic objects.  */
	case R_PPC_COPY:
	case R_PPC_GLOB_DAT:
	case R_PPC_JMP_SLOT:
	case R_PPC_RELATIVE:
	  break;
d3760 11
a3770 8
	  /* These aren't handled yet.  We'll report an error later.  */
	case R_PPC_ADDR30:
	case R_PPC_EMB_RELSEC16:
	case R_PPC_EMB_RELST_LO:
	case R_PPC_EMB_RELST_HI:
	case R_PPC_EMB_RELST_HA:
	case R_PPC_EMB_BIT_FLD:
	  break;
d3772 4
a3775 3
	  /* This refers only to functions defined in the shared library.  */
	case R_PPC_LOCAL24PC:
	  break;
d3777 4
a3780 6
	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_PPC_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;
d3782 7
a3788 6
	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_PPC_GNU_VTENTRY:
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;
d3790 11
a3800 5
	  /* We shouldn't really be seeing these.  */
	case R_PPC_TPREL32:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  goto dodyn;
d3802 6
a3807 4
	  /* Nor these.  */
	case R_PPC_DTPMOD32:
	case R_PPC_DTPREL32:
	  goto dodyn;
d3809 14
a3822 7
	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_TPREL16_HI:
	case R_PPC_TPREL16_HA:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  goto dodyn;
d3824 10
a3833 12
	  /* When creating a shared object, we must copy these
	     relocs into the output file.  We create a reloc
	     section in dynobj and make room for the reloc.  */
	case R_PPC_REL24:
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	case R_PPC_REL32:
	  if (h == NULL
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* fall through */
d3835 26
a3860 12
	case R_PPC_ADDR32:
	case R_PPC_ADDR24:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	  if (h != NULL && !info->shared)
d3862 7
a3868 6
	      /* We may need a plt entry if the symbol turns out to be
		 a function defined in a dynamic object.  */
	      h->plt.refcount++;

	      /* We may need a copy reloc too.  */
	      h->non_got_ref = 1;
d3870 4
d3875 2
a3876 17
	dodyn:
	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library.  We account for that possibility below by
	     storing information in the dyn_relocs field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.
d3878 127
a4004 19
	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (MUST_BE_DYN_RELOC (r_type)
		   || (h != NULL
		       && (! info->symbolic
			   || h->root.type == bfd_link_hash_defweak
			   || !h->def_regular))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || !h->def_regular)))
	    {
	      struct ppc_elf_dyn_relocs *p;
	      struct ppc_elf_dyn_relocs **head;
d4007 1
a4007 5
	      fprintf (stderr,
		       "ppc_elf_check_relocs needs to "
		       "create relocation for %s\n",
		       (h && h->root.root.string
			? h->root.root.string : "<unknown>"));
d4009 58
a4066 1
	      if (sreloc == NULL)
d4068 13
a4080 1
		  const char *name;
d4082 44
a4125 6
		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;
d4127 2
a4128 3
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);
d4130 7
a4136 4
		  sreloc = bfd_get_section_by_name (htab->elf.dynobj, name);
		  if (sreloc == NULL)
		    {
		      flagword flags;
d4138 33
a4170 14
		      sreloc = bfd_make_section (htab->elf.dynobj, name);
		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      if (sreloc == NULL
			  || ! bfd_set_section_flags (htab->elf.dynobj,
						      sreloc, flags)
			  || ! bfd_set_section_alignment (htab->elf.dynobj,
							  sreloc, 2))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
		}
d4172 3
a4174 38
	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		{
		  head = &ppc_elf_hash_entry (h)->dyn_relocs;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */

		  asection *s;
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return FALSE;

		  head = ((struct ppc_elf_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      if (!MUST_BE_DYN_RELOC (r_type))
		p->pc_count += 1;
d4176 6
d4183 4
a4186 1
	  break;
d4188 5
d4195 9
a4203 2
  return TRUE;
}
d4205 5
a4209 2
/* Return the section that should be marked against GC for a given
   relocation.  */
d4211 1
a4211 10
static asection *
ppc_elf_gc_mark_hook (asection *sec,
		      struct bfd_link_info *info ATTRIBUTE_UNUSED,
		      Elf_Internal_Rela *rel,
		      struct elf_link_hash_entry *h,
		      Elf_Internal_Sym *sym)
{
  if (h != NULL)
    {
      switch (ELF32_R_TYPE (rel->r_info))
d4213 6
a4218 3
	case R_PPC_GNU_VTINHERIT:
	case R_PPC_GNU_VTENTRY:
	  break;
d4220 7
a4226 6
	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
d4228 5
a4232 2
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;
d4234 4
a4237 3
	    default:
	      break;
	    }
d4240 1
a4240 2
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d4242 1
a4242 1
  return NULL;
d4244 14
d4259 7
a4265 2
/* Update the got, plt and dynamic reloc reference counts for the
   section being removed.  */
d4268 4
a4271 4
ppc_elf_gc_sweep_hook (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
d4273 8
a4280 1
  struct ppc_elf_link_hash_table *htab;
d4282 14
a4295 3
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;
d4297 3
a4299 1
  elf_section_data (sec)->local_dynrel = NULL;
a4300 1
  htab = ppc_elf_hash_table (info);
a4301 2
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
d4303 5
a4307 6
  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      enum elf_ppc_reloc_type r_type;
      struct elf_link_hash_entry *h = NULL;
d4309 2
a4310 5
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct ppc_elf_dyn_relocs **pp, *p;
	  struct ppc_elf_link_hash_entry *eh;
d4312 11
a4322 14
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  eh = (struct ppc_elf_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
a4323 1
      r_type = ELF32_R_TYPE (rel->r_info);
d4326 4
a4329 33
	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  htab->tlsld_got.refcount -= 1;
	  /* Fall thru */

	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_GOT16_HI:
	case R_PPC_GOT16_HA:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount--;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx]--;
	    }
a4331 1
	case R_PPC_REL24:
d4335 1
a4335 27
	case R_PPC_REL32:
	  if (h == NULL
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* Fall thru */

	case R_PPC_ADDR32:
	case R_PPC_ADDR24:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	case R_PPC_PLT32:
	case R_PPC_PLTREL24:
	case R_PPC_PLT16_LO:
	case R_PPC_PLT16_HI:
	case R_PPC_PLT16_HA:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount--;
	    }
d4339 1
a4339 1
	  break;
a4340 3
    }
  return TRUE;
}
d4342 5
a4346 1
/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */
d4348 20
a4367 4
asection *
ppc_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
{
  struct ppc_elf_link_hash_table *htab;
d4369 8
a4376 3
  htab = ppc_elf_hash_table (info);
  htab->tls_get_addr = elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
					     FALSE, FALSE, TRUE);
d4378 2
a4379 2
  return _bfd_elf_tls_setup (obfd, info);
}
d4381 3
a4383 2
/* Run through all the TLS relocs looking for optimization
   opportunities.  */
d4385 15
a4399 7
bfd_boolean
ppc_elf_tls_optimize (bfd *obfd ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info)
{
  bfd *ibfd;
  asection *sec;
  struct ppc_elf_link_hash_table *htab;
d4401 2
a4402 2
  if (info->relocatable || info->shared)
    return TRUE;
d4404 5
a4408 5
  htab = ppc_elf_hash_table (info);
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      Elf_Internal_Sym *locsyms = NULL;
      Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d4410 12
a4421 5
      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	if (sec->has_tls_reloc && !bfd_is_abs_section (sec->output_section))
	  {
	    Elf_Internal_Rela *relstart, *rel, *relend;
	    int expecting_tls_get_addr;
d4423 12
a4434 5
	    /* Read the relocations.  */
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
						  info->keep_memory);
	    if (relstart == NULL)
	      return FALSE;
d4436 3
a4438 10
	    expecting_tls_get_addr = 0;
	    relend = relstart + sec->reloc_count;
	    for (rel = relstart; rel < relend; rel++)
	      {
		enum elf_ppc_reloc_type r_type;
		unsigned long r_symndx;
		struct elf_link_hash_entry *h = NULL;
		char *tls_mask;
		char tls_set, tls_clear;
		bfd_boolean is_local;
d4440 5
a4444 4
		r_symndx = ELF32_R_SYM (rel->r_info);
		if (r_symndx >= symtab_hdr->sh_info)
		  {
		    struct elf_link_hash_entry **sym_hashes;
d4446 1
a4446 6
		    sym_hashes = elf_sym_hashes (ibfd);
		    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
		    while (h->root.type == bfd_link_hash_indirect
			   || h->root.type == bfd_link_hash_warning)
		      h = (struct elf_link_hash_entry *) h->root.u.i.link;
		  }
d4448 2
a4449 4
		is_local = FALSE;
		if (h == NULL
		    || !h->def_dynamic)
		  is_local = TRUE;
d4451 3
a4453 14
		r_type = ELF32_R_TYPE (rel->r_info);
		switch (r_type)
		  {
		  case R_PPC_GOT_TLSLD16:
		  case R_PPC_GOT_TLSLD16_LO:
		  case R_PPC_GOT_TLSLD16_HI:
		  case R_PPC_GOT_TLSLD16_HA:
		    /* These relocs should never be against a symbol
		       defined in a shared lib.  Leave them alone if
		       that turns out to be the case.  */
		    expecting_tls_get_addr = 0;
		    htab->tlsld_got.refcount -= 1;
		    if (!is_local)
		      continue;
d4455 4
a4458 5
		    /* LD -> LE */
		    tls_set = 0;
		    tls_clear = TLS_LD;
		    expecting_tls_get_addr = 1;
		    break;
d4460 4
a4463 13
		  case R_PPC_GOT_TLSGD16:
		  case R_PPC_GOT_TLSGD16_LO:
		  case R_PPC_GOT_TLSGD16_HI:
		  case R_PPC_GOT_TLSGD16_HA:
		    if (is_local)
		      /* GD -> LE */
		      tls_set = 0;
		    else
		      /* GD -> IE */
		      tls_set = TLS_TLS | TLS_TPRELGD;
		    tls_clear = TLS_GD;
		    expecting_tls_get_addr = 1;
		    break;
d4465 5
a4469 14
		  case R_PPC_GOT_TPREL16:
		  case R_PPC_GOT_TPREL16_LO:
		  case R_PPC_GOT_TPREL16_HI:
		  case R_PPC_GOT_TPREL16_HA:
		    expecting_tls_get_addr = 0;
		    if (is_local)
		      {
			/* IE -> LE */
			tls_set = 0;
			tls_clear = TLS_TPREL;
			break;
		      }
		    else
		      continue;
d4471 12
a4482 13
		  case R_PPC_REL14:
		  case R_PPC_REL14_BRTAKEN:
		  case R_PPC_REL14_BRNTAKEN:
		  case R_PPC_REL24:
		    if (expecting_tls_get_addr
			&& h != NULL
			&& h == htab->tls_get_addr)
		      {
			if (h->plt.refcount > 0)
			  h->plt.refcount -= 1;
		      }
		    expecting_tls_get_addr = 0;
		    continue;
d4484 5
a4488 4
		  default:
		    expecting_tls_get_addr = 0;
		    continue;
		  }
d4490 5
a4494 15
		if (h != NULL)
		  {
		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (h->got.refcount > 0)
			  h->got.refcount -= 1;
		      }
		    tls_mask = &ppc_elf_hash_entry (h)->tls_mask;
		  }
		else
		  {
		    Elf_Internal_Sym *sym;
		    bfd_signed_vma *lgot_refs;
		    char *lgot_masks;
d4496 7
a4502 27
		    if (locsyms == NULL)
		      {
			locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
			if (locsyms == NULL)
			  locsyms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
							  symtab_hdr->sh_info,
							  0, NULL, NULL, NULL);
			if (locsyms == NULL)
			  {
			    if (elf_section_data (sec)->relocs != relstart)
			      free (relstart);
			    return FALSE;
			  }
		      }
		    sym = locsyms + r_symndx;
		    lgot_refs = elf_local_got_refcounts (ibfd);
		    if (lgot_refs == NULL)
		      abort ();
		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (lgot_refs[r_symndx] > 0)
			  lgot_refs[r_symndx] -= 1;
		      }
		    lgot_masks = (char *) (lgot_refs + symtab_hdr->sh_info);
		    tls_mask = &lgot_masks[r_symndx];
		  }
d4504 7
a4510 3
		*tls_mask |= tls_set;
		*tls_mask &= ~tls_clear;
	      }
d4512 3
a4514 3
	    if (elf_section_data (sec)->relocs != relstart)
	      free (relstart);
	  }
d4516 2
a4517 2
      if (locsyms != NULL
	  && (symtab_hdr->contents != (unsigned char *) locsyms))
d4519 3
a4521 2
	  if (!info->keep_memory)
	    free (locsyms);
d4523 5
a4527 1
	    symtab_hdr->contents = (unsigned char *) locsyms;
a4528 6
    }
  return TRUE;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put .comm items in .sbss, and not .bss.  */
d4530 3
a4532 21
static bfd_boolean
ppc_elf_add_symbol_hook (bfd *abfd,
			 struct bfd_link_info *info,
			 Elf_Internal_Sym *sym,
			 const char **namep ATTRIBUTE_UNUSED,
			 flagword *flagsp ATTRIBUTE_UNUSED,
			 asection **secp,
			 bfd_vma *valp)
{
  if (sym->st_shndx == SHN_COMMON
      && !info->relocatable
      && sym->st_size <= elf_gp_size (abfd)
      && (info->hash->creator == abfd->xvec
	  || info->hash->creator == abfd->xvec->alternative_target))
    {
      /* Common symbols less than or equal to -G nn bytes are automatically
	 put into .sbss.  */
      struct ppc_elf_link_hash_table *htab;

      htab = ppc_elf_hash_table (info);
      if (htab->sbss == NULL)
d4534 8
a4541 1
	  flagword flags = SEC_IS_COMMON;
d4543 8
a4550 4
	  htab->sbss = bfd_make_section_anyway (abfd, ".sbss");
	  if (htab->sbss == NULL
	      || ! bfd_set_section_flags (abfd, htab->sbss, flags))
	    return FALSE;
a4551 3

      *secp = htab->sbss;
      *valp = sym->st_size;
d4554 3
a4556 23
  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
ppc_elf_finish_dynamic_symbol (bfd *output_bfd,
			       struct bfd_link_info *info,
			       struct elf_link_hash_entry *h,
			       Elf_Internal_Sym *sym)
{
  struct ppc_elf_link_hash_table *htab;

#ifdef DEBUG
  fprintf (stderr, "ppc_elf_finish_dynamic_symbol called for %s",
	   h->root.root.string);
#endif

  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL);

  if (h->plt.offset != (bfd_vma) -1)
d4558 4
a4561 3
      Elf_Internal_Rela rela;
      bfd_byte *loc;
      bfd_vma reloc_index;
d4563 7
a4569 3
#ifdef DEBUG
      fprintf (stderr, ", plt_offset = %d", h->plt.offset);
#endif
d4571 3
a4573 2
      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */
d4575 7
a4581 12
      BFD_ASSERT (h->dynindx != -1);
      BFD_ASSERT (htab->plt != NULL && htab->relplt != NULL);

      /* We don't need to fill in the .plt.  The ppc dynamic linker
	 will fill it in.  */

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (htab->plt->output_section->vma
		       + htab->plt->output_offset
		       + h->plt.offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_PPC_JMP_SLOT);
      rela.r_addend = 0;
d4583 10
a4592 6
      reloc_index = (h->plt.offset - PLT_INITIAL_ENTRY_SIZE) / PLT_SLOT_SIZE;
      if (reloc_index > PLT_NUM_SINGLE_ENTRIES)
	reloc_index -= (reloc_index - PLT_NUM_SINGLE_ENTRIES) / 2;
      loc = (htab->relplt->contents
	     + reloc_index * sizeof (Elf32_External_Rela));
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d4594 2
a4595 1
      if (!h->def_regular)
d4597 5
a4601 9
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  */
	  sym->st_shndx = SHN_UNDEF;
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if (!h->ref_regular_nonweak)
	    sym->st_value = 0;
d4603 1
d4606 2
a4607 1
  if (h->needs_copy)
d4609 8
a4616 3
      asection *s;
      Elf_Internal_Rela rela;
      bfd_byte *loc;
d4618 11
a4628 1
      /* This symbols needs a copy reloc.  Set it up.  */
d4630 4
a4633 8
#ifdef DEBUG
      fprintf (stderr, ", copy");
#endif

      BFD_ASSERT (h->dynindx != -1);

      if (h->size <= elf_gp_size (htab->elf.dynobj))
	s = htab->relsbss;
d4635 1
a4635 10
	s = htab->relbss;
      BFD_ASSERT (s != NULL);

      rela.r_offset = (h->root.u.def.value
		       + h->root.u.def.section->output_section->vma
		       + h->root.u.def.section->output_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_PPC_COPY);
      rela.r_addend = 0;
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d4638 2
a4639 3
#ifdef DEBUG
  fprintf (stderr, "\n");
#endif
d4641 10
a4650 7
  /* Mark some specially defined symbols as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
    sym->st_shndx = SHN_ABS;

  return TRUE;
d4653 3
a4655 1
/* Finish up the dynamic sections.  */
d4657 9
a4665 3
static bfd_boolean
ppc_elf_finish_dynamic_sections (bfd *output_bfd,
				 struct bfd_link_info *info)
d4667 14
a4680 2
  asection *sdyn;
  struct ppc_elf_link_hash_table *htab;
d4682 1
a4682 3
#ifdef DEBUG
  fprintf (stderr, "ppc_elf_finish_dynamic_sections called\n");
#endif
d4684 9
a4692 2
  htab = ppc_elf_hash_table (info);
  sdyn = bfd_get_section_by_name (htab->elf.dynobj, ".dynamic");
d4694 14
a4707 1
  if (htab->elf.dynamic_sections_created)
d4709 8
a4716 1
      Elf32_External_Dyn *dyncon, *dynconend;
d4718 1
a4718 1
      BFD_ASSERT (htab->plt != NULL && sdyn != NULL);
d4720 2
a4721 3
      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
d4723 3
a4725 2
	  Elf_Internal_Dyn dyn;
	  asection *s;
d4727 1
a4727 3
	  bfd_elf32_swap_dyn_in (htab->elf.dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
d4729 2
a4730 4
	    case DT_PLTGOT:
	      s = htab->plt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;
d4732 5
a4736 3
	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = htab->relplt->size;
	      break;
d4738 1
a4738 4
	    case DT_JMPREL:
	      s = htab->relplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;
d4740 14
a4753 2
	    default:
	      continue;
a4754 2

	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d4758 3
a4760 6
  /* Add a blrl instruction at _GLOBAL_OFFSET_TABLE_-4 so that a function can
     easily find the address of the _GLOBAL_OFFSET_TABLE_.  */
  if (htab->got)
    {
      unsigned char *contents = htab->got->contents;
      bfd_put_32 (output_bfd, 0x4e800021 /* blrl */, contents);
d4762 5
a4766 6
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, 0, contents + 4);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    contents + 4);
d4768 4
a4771 2
      elf_section_data (htab->got->output_section)->this_hdr.sh_entsize = 4;
    }
a4772 3
  return TRUE;
}

a5965 18

static enum elf_reloc_type_class
ppc_elf_reloc_type_class (const Elf_Internal_Rela *rela)
{
  switch (ELF32_R_TYPE (rela->r_info))
    {
    case R_PPC_RELATIVE:
      return reloc_class_relative;
    case R_PPC_REL24:
    case R_PPC_ADDR24:
    case R_PPC_JMP_SLOT:
      return reloc_class_plt;
    case R_PPC_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}
d5967 2
a5968 1
/* Support for core dump NOTE sections.  */
d5971 4
a5974 1
ppc_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d5976 1
a5976 2
  int offset;
  unsigned int size;
d5978 4
a5981 4
  switch (note->descsz)
    {
    default:
      return FALSE;
d5983 2
a5984 3
    case 268:		/* Linux/PPC.  */
      /* pr_cursig */
      elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d5986 1
a5986 19
      /* pr_pid */
      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

      /* pr_reg */
      offset = 72;
      size = 192;

      break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
ppc_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
d5988 3
a5990 187
    default:
      return FALSE;

    case 128:		/* Linux/PPC elf_prpsinfo.  */
      elf_tdata (abfd)->core_program
	= _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
      elf_tdata (abfd)->core_command
	= _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

/* Very simple linked list structure for recording apuinfo values.  */
typedef struct apuinfo_list
{
  struct apuinfo_list *next;
  unsigned long value;
}
apuinfo_list;

static apuinfo_list *head;


static void
apuinfo_list_init (void)
{
  head = NULL;
}

static void
apuinfo_list_add (unsigned long value)
{
  apuinfo_list *entry = head;

  while (entry != NULL)
    {
      if (entry->value == value)
	return;
      entry = entry->next;
    }

  entry = bfd_malloc (sizeof (* entry));
  if (entry == NULL)
    return;

  entry->value = value;
  entry->next  = head;
  head = entry;
}

static unsigned
apuinfo_list_length (void)
{
  apuinfo_list *entry;
  unsigned long count;

  for (entry = head, count = 0;
       entry;
       entry = entry->next)
    ++ count;

  return count;
}

static inline unsigned long
apuinfo_list_element (unsigned long number)
{
  apuinfo_list * entry;

  for (entry = head;
       entry && number --;
       entry = entry->next)
    ;

  return entry ? entry->value : 0;
}

static void
apuinfo_list_finish (void)
{
  apuinfo_list *entry;

  for (entry = head; entry;)
    {
      apuinfo_list *next = entry->next;
      free (entry);
      entry = next;
    }

  head = NULL;
}

#define APUINFO_SECTION_NAME	".PPC.EMB.apuinfo"
#define APUINFO_LABEL		"APUinfo"

/* Scan the input BFDs and create a linked list of
   the APUinfo values that will need to be emitted.  */

static void
ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)
{
  bfd *ibfd;
  asection *asec;
  char *buffer;
  unsigned num_input_sections;
  bfd_size_type	output_section_size;
  unsigned i;
  unsigned num_entries;
  unsigned long	offset;
  unsigned long length;
  const char *error_message = NULL;

  if (link_info == NULL)
    return;

  /* Scan the input bfds, looking for apuinfo sections.  */
  num_input_sections = 0;
  output_section_size = 0;

  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);
      if (asec)
	{
	  ++ num_input_sections;
	  output_section_size += asec->size;
	}
    }

  /* We need at least one input sections
     in order to make merging worthwhile.  */
  if (num_input_sections < 1)
    return;

  /* Just make sure that the output section exists as well.  */
  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);
  if (asec == NULL)
    return;

  /* Allocate a buffer for the contents of the input sections.  */
  buffer = bfd_malloc (output_section_size);
  if (buffer == NULL)
    return;

  offset = 0;
  apuinfo_list_init ();

  /* Read in the input sections contents.  */
  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      unsigned long datum;
      char *ptr;

      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);
      if (asec == NULL)
	continue;

      length = asec->size;
      if (length < 24)
	{
	  error_message = _("corrupt or empty %s section in %B");
	  goto fail;
	}

      if (bfd_seek (ibfd, asec->filepos, SEEK_SET) != 0
	  || (bfd_bread (buffer + offset, length, ibfd) != length))
	{
	  error_message = _("unable to read in %s section from %B");
	  goto fail;
	}

      /* Process the contents of the section.  */
      ptr = buffer + offset;
      error_message = _("corrupt %s section in %B");
d5992 3
a5994 6
      /* Verify the contents of the header.  Note - we have to
	 extract the values this way in order to allow for a
	 host whose endian-ness is different from the target.  */
      datum = bfd_get_32 (ibfd, ptr);
      if (datum != sizeof APUINFO_LABEL)
	goto fail;
d5996 2
a5997 3
      datum = bfd_get_32 (ibfd, ptr + 8);
      if (datum != 0x2)
	goto fail;
d5999 2
a6000 2
      if (strcmp (ptr + 12, APUINFO_LABEL) != 0)
	goto fail;
d6002 2
a6003 4
      /* Get the number of bytes used for apuinfo entries.  */
      datum = bfd_get_32 (ibfd, ptr + 4);
      if (datum + 20 != length)
	goto fail;
d6005 6
a6010 3
      /* Make sure that we do not run off the end of the section.  */
      if (offset + length > output_section_size)
	goto fail;
d6012 6
a6017 3
      /* Scan the apuinfo section, building a list of apuinfo numbers.  */
      for (i = 0; i < datum; i += 4)
	apuinfo_list_add (bfd_get_32 (ibfd, ptr + 20 + i));
d6019 12
a6030 2
      /* Update the offset.  */
      offset += length;
d6033 7
a6039 1
  error_message = NULL;
d6041 3
a6043 3
  /* Compute the size of the output section.  */
  num_entries = apuinfo_list_length ();
  output_section_size = 20 + num_entries * 4;
d6045 1
a6045 1
  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);
d6047 5
a6051 3
  if (! bfd_set_section_size (abfd, asec, output_section_size))
    ibfd = abfd,
      error_message = _("warning: unable to set size of %s section in %B");
d6053 8
a6060 2
 fail:
  free (buffer);
d6062 3
a6064 3
  if (error_message)
    (*_bfd_error_handler) (error_message, ibfd, APUINFO_SECTION_NAME);
}
d6066 5
d6072 22
a6093 2
/* Prevent the output section from accumulating the input sections'
   contents.  We have already stored this in our linked list structure.  */
d6096 2
a6097 3
ppc_elf_write_section (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *asec,
		       bfd_byte *contents ATTRIBUTE_UNUSED)
d6099 2
a6100 3
  return (apuinfo_list_length ()
	  && strcmp (asec->name, APUINFO_SECTION_NAME) == 0);
}
d6102 3
d6106 2
a6107 1
/* Finally we can generate the output section.  */
d6109 3
a6111 8
static void
ppc_elf_final_write_processing (bfd *abfd, bfd_boolean linker ATTRIBUTE_UNUSED)
{
  bfd_byte *buffer;
  asection *asec;
  unsigned i;
  unsigned num_entries;
  bfd_size_type length;
d6113 1
a6113 3
  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);
  if (asec == NULL)
    return;
d6115 6
a6120 2
  if (apuinfo_list_length () == 0)
    return;
d6122 1
a6122 3
  length = asec->size;
  if (length < 20)
    return;
d6124 6
a6129 7
  buffer = bfd_malloc (length);
  if (buffer == NULL)
    {
      (*_bfd_error_handler)
	(_("failed to allocate space for new APUinfo section."));
      return;
    }
d6131 3
a6133 6
  /* Create the apuinfo header.  */
  num_entries = apuinfo_list_length ();
  bfd_put_32 (abfd, sizeof APUINFO_LABEL, buffer);
  bfd_put_32 (abfd, num_entries * 4, buffer + 4);
  bfd_put_32 (abfd, 0x2, buffer + 8);
  strcpy ((char *) buffer + 12, APUINFO_LABEL);
d6135 4
a6138 6
  length = 20;
  for (i = 0; i < num_entries; i++)
    {
      bfd_put_32 (abfd, apuinfo_list_element (i), buffer + length);
      length += 4;
    }
d6140 3
a6142 2
  if (length != asec->size)
    (*_bfd_error_handler) (_("failed to compute new APUinfo section."));
d6144 3
a6146 2
  if (! bfd_set_section_contents (abfd, asec, buffer, (file_ptr) 0, length))
    (*_bfd_error_handler) (_("failed to install new APUinfo section."));
d6148 6
a6153 1
  free (buffer);
d6155 6
a6160 2
  apuinfo_list_finish ();
}
d6162 2
a6163 2
/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */
d6165 1
a6165 6
static bfd_vma
ppc_elf_plt_sym_val (bfd_vma i ATTRIBUTE_UNUSED,
		     const asection *plt ATTRIBUTE_UNUSED,
		     const arelent *rel)
{
  return rel->address;
a6166 19

/* Add extra PPC sections -- Note, for now, make .sbss2 and
   .PPC.EMB.sbss0 a normal section, and not a bss section so
   that the linker doesn't crater when trying to make more than
   2 sections.  */

static struct bfd_elf_special_section const ppc_elf_special_sections[]=
{
  { ".tags",             5,  0, SHT_ORDERED,  SHF_ALLOC },
  { ".sdata",            6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".sbss",             5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".sdata2",           7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".sbss2",            6, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".PPC.EMB.apuinfo", 16,  0, SHT_NOTE,     0 },
  { ".PPC.EMB.sdata0",  15,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".PPC.EMB.sbss0",   14,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".plt",              4,  0, SHT_NOBITS,   SHF_ALLOC + SHF_EXECINSTR },
  { NULL,                0,  0, 0,            0 }
};
@


1.136
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d2609 10
a2618 9
  /* Both of these sections are (technically) created by the user
     putting data in them, so they shouldn't be marked
     SEC_LINKER_CREATED.

     The linker creates them so it has somewhere to attach their
     respective symbols. In fact, if they were empty it would
     be OK to leave the symbol set to 0 (or any random number), because
     the appropriate register should never be used.  */
  flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
d2715 1
a2715 1
/* If we have a non-zero sized .sbss2 or .PPC.EMB.sbss0 sections, we
d2722 1
a2722 7
  int ret;

  ret = 0;

  s = bfd_get_section_by_name (abfd, ".interp");
  if (s != NULL)
    ++ret;
d2725 1
a2725 1
  if (s != NULL && (s->flags & SEC_LOAD) != 0 && s->size > 0)
d2729 1
a2729 1
  if (s != NULL && (s->flags & SEC_LOAD) != 0 && s->size > 0)
d3392 1
a3392 3
	  || s == htab->got
	  || (htab->sdata != NULL && s == htab->sdata->section)
	  || (htab->sdata2 != NULL && s == htab->sdata2->section))
d3397 9
@


1.136.2.1
log
@bfd/
	* elf32-ppc.c (ppc_elf_create_linker_section): Set SEC_LINKER_CREATED
	on section.  Correct comment, and add FIXME.
	(ppc_elf_additional_program_headers): Don't bump header count for
	interp.  Test SEC_ALLOC, not SEC_LOAD, and don't test size.
	(ppc_elf_size_dynamic_sections): Don't strip sdata and sdata2, but
	do allocate memory if they need it.
ld/
	* emulparams/elf32ppclinux.sh (OTHER_READWRITE_SECTION): Delete.
	(OTHER_RELRO_SECTIONS): Set this instead.
ld/testsuite/
	* ld-powerpc/tlsexe32.d: Update.
	* ld-powerpc/tlsexe32.g: Update.
	* ld-powerpc/tlsexe32.r: Update.
	* ld-powerpc/tlsexe32.t: Update.
	* ld-powerpc/tlsso32.d: Update.
	* ld-powerpc/tlsso32.g: Update.
	* ld-powerpc/tlsso32.r: Update.
	* ld-powerpc/tlsso32.t: Update.
@
text
@d2609 9
a2617 10
  /* The linker creates these sections so it has somewhere to attach
     their respective symbols.  Startup code (crt1.o) uses these symbols
     to initialize a register pointing to the section.  If the output
     sections corresponding to these input sections were empty it would
     be OK to set the symbol to 0 (or any random number), because the
     associated register should never be used.
     FIXME: Setting a symbol this way is silly.  The symbols ought to 
     be set the same way other backends set gp.  */
  flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
d2714 1
a2714 1
/* If we have .sbss2 or .PPC.EMB.sbss0 output sections, we
d2721 7
a2727 1
  int ret = 0;
d2730 1
a2730 1
  if (s != NULL && (s->flags & SEC_ALLOC) != 0)
d2734 1
a2734 1
  if (s != NULL && (s->flags & SEC_ALLOC) != 0)
d3397 3
a3399 1
	  || s == htab->got)
a3403 9
      else if ((htab->sdata != NULL && s == htab->sdata->section)
	       || (htab->sdata2 != NULL && s == htab->sdata2->section))
	{
	  if (s->size == 0)
	    /* Don't strip these sections.  We need them because they
	       define _SDA_BASE_ and _SDA2_BASE_.  crt1.o makes a
	       reference to _SDA_BASE_ to set up r13.  */
	    continue;
	}
@


1.136.2.2
log
@	* elf32-ppc.c (is_ppc_elf_target): New function.
	(ppc_elf_merge_private_bfd_data): Use it rather than just testing
	for bfd_target_elf_flavour.  Do this test before endian check.
	(ppc_elf_add_symbol_hook): Use is_pcc_elf_target.
	(ppc_elf_size_dynamic_sections): Likewise.
@
text
@a2220 11
/* Return 1 if target is one of ours.  */

static bfd_boolean
is_ppc_elf_target (const struct bfd_target *targ)
{
  extern const bfd_target bfd_elf32_powerpc_vec;
  extern const bfd_target bfd_elf32_powerpcle_vec;

  return targ == &bfd_elf32_powerpc_vec || targ == &bfd_elf32_powerpcle_vec;
}

a2230 4
  if (!is_ppc_elf_target (ibfd->xvec)
      || !is_ppc_elf_target (obfd->xvec))
    return TRUE;

d2235 4
d3299 1
a3299 1
      if (!is_ppc_elf_target (ibfd->xvec))
d4371 2
a4372 1
      && is_ppc_elf_target (info->hash->creator))
@


1.136.2.3
log
@bfd/
	* elf32-ppc.c (ppc_elf_check_relocs): Don't bother with
	dynamic relocs in non-SEC_ALLOC sections.
	(ppc_elf_gc_sweep_hook): Likewise.
	(ppc_elf_relax_section): Likewise.
	(ppc_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-powerpc/reloc.d: Update to suit removal of non-alloc relocs.
@
text
@d1650 2
a1651 5
  /* Nothing to do if there are no relocations, and no need to do
     anything with non-alloc sections.  */
  if ((isec->flags & SEC_ALLOC) == 0
      || (isec->flags & SEC_RELOC) == 0
      || isec->reloc_count == 0)
a3564 9
  /* Don't do anything special with non-loaded, non-alloced sections.
     In particular, any relocs in such sections should not affect GOT
     and PLT reference counting (ie. we don't allow them to create GOT
     or PLT entries), there's no possibility or desire to optimize TLS
     relocs, and there's not much point in propagating relocs to shared
     libs that the dynamic linker won't relocate.  */
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

d3896 1
d3933 3
a3935 2
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED
			       | SEC_ALLOC | SEC_LOAD);
a4046 3
  if ((sec->flags & SEC_ALLOC) == 0)
    return TRUE;

a5286 4
	  if ((input_section->flags & SEC_ALLOC) == 0)
	    break;
	  /* Fall thru.  */

d5295 1
@


1.135
log
@	* elf-bfd.h (struct elf_backend_data): Add minpagesize.
	* elf32-arm.c (ELF_MINPAGESIZE): Define.
	* elf32-ppc.c (ELF_MINPAGESIZE): Define.
	* elfcode.h (elf_object_p): Use minpagesize instead of
	maxpagesize.
	* elfxx-target.h (ELF_MINPAGESIZE): Default to ELF_MAXPAGESIZE.
	(elfNN_bed): Include ELF_MINPAGESIZE.
@
text
@d6113 1
a6113 1
  strcpy (buffer + 12, APUINFO_LABEL);
@


1.134
log
@include/elf/
	* ppc.h (R_PPC_RELAX32_PLT, R_PPC_RELAX32PC_PLT): Define.
	(R_PPC_RELAX32, R_PPC_RELAX32PC): Adjust value.
bfd/
	* elf32-ppc.c (ppc_elf_howto_raw): Delete RELAX32* entries.
	(ppc_elf_relax_section): Use PLT variants of RELAX32 relocs for
	reaching PLT.
	(ppc_elf_relocate_section): Handle R_PPC_RELAX32_PLT and
	R_PPC_RELAX32PC_PLT.
@
text
@d6174 1
@


1.133
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@a1535 29
  /* Phony relocs to handle branch stubs.  */
  HOWTO (R_PPC_RELAX32,		/* type */
	 0,			/* rightshift */
	 0,			/* size */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_RELAX32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC_RELAX32PC,	/* type */
	 0,			/* rightshift */
	 0,			/* size */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_RELAX32PC",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

d1841 6
d5402 13
d5420 1
d5422 1
@


1.132
log
@	* elf32-ppc.c (ppc_elf_create_dynamic_sections): Correct
	.dynsbss flags.
@
text
@d4078 3
@


1.131
log
@	* elf.c (bfd_elf_sym_name): Add symtab_hdr param.
	(group_signature): Update call.
	* elf-bfd.h (bfd_elf_sym_name): Update.
	* elf32-ppc.c (ppc_elf_relocate_section): Update.
	* elf64-ppc.c (ppc64_elf_edit_opd, ppc64_elf_edit_toc)
	(ppc64_elf_relocate_section): Update
	* elflink.c (elf_link_input_bfd): Update.
@
text
@d3 1
a3 1
   2004 Free Software Foundation, Inc.
d2823 1
a2823 1
      || ! bfd_set_section_flags (abfd, s, SEC_ALLOC))
@


1.130
log
@	* elf.c (bfd_elf_sym_name): Rename from bfd_elf_local_sym_name.
	(group_signature): Update calls.
	* elf-bfd.h (bfd_elf_sym_name): Update.
	* elf32-ppc.c (ppc_elf_relocate_section): Update.
	* elf64-ppc.c (ppc64_elf_edit_opd, ppc64_elf_edit_toc)
	(ppc64_elf_relocate_section): Update
	* elflink.c (elf_link_input_bfd): Update.
@
text
@d4697 1
a4697 1
	  sym_name = bfd_elf_sym_name (input_bfd, sym);
@


1.129
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d4697 1
a4697 1
	  sym_name = bfd_elf_local_sym_name (input_bfd, sym);
@


1.128
log
@	* libbfd-in.h (BFD_ASSERT, BFD_FAIL): Wrap macro body in do while.
	* libbfd.h: Regnerate.
	* elf32-cris.c: Add missing semicolon to BFD_ASSERTs.
	* elf32-frv.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* opncls.c: Likewise.
@
text
@d5749 1
@


1.127
log
@	* elf32-ppc.c (ppc_elf_modify_segment_map): Delete.
	(elf_backend_modify_segment_map): Don't define.
@
text
@d5476 1
a5476 1
		      || strcmp (bfd_get_section_name (abfd, sec), ".cgot") == 0)
@


1.126
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@a2761 9

/* Modify the segment map if needed.  */

static bfd_boolean
ppc_elf_modify_segment_map (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  return TRUE;
}
a6216 1
#define elf_backend_modify_segment_map		ppc_elf_modify_segment_map
@


1.125
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d2877 1
a2877 1
		  || h->weakdef != NULL
d2914 1
a2914 1
  if (h->weakdef != NULL)
d2916 4
a2919 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
d2921 1
a2921 1
	h->non_got_ref = h->weakdef->non_got_ref;
@


1.124
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d332 10
a341 9
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d2530 1
a2530 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2876 1
a2876 1
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
d2878 3
a2880 6
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));
d2884 1
a2884 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d2904 1
a2904 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d2921 1
a2921 3
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d2937 1
a2937 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
d2954 1
a2954 1
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d2993 1
a2993 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d3056 1
a3056 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d3086 1
a3086 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3105 1
a3105 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3111 1
a3111 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d3119 1
a3119 1
	  && (eh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d3126 1
a3126 1
	  && !(eh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
d3209 1
a3209 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d3221 3
a3223 3
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3228 1
a3228 1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d3773 1
a3773 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d3882 1
a3882 1
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d3912 1
a3912 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d3918 1
a3918 2
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d4247 1
a4247 1
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
d4475 1
a4475 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d4484 1
a4484 2
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	      == 0)
d4489 1
a4489 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
d5028 1
a5028 1
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
d5071 1
a5071 2
			 || !(h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC))
d5190 1
a5190 2
			     || !(h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC)))
d5315 3
a5317 3
		  && (h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
d5716 1
a5716 1
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
@


1.123
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2285 2
a2286 3
	    (_("%s: compiled with -mrelocatable and linked with "
	       "modules compiled normally"),
	     bfd_archive_filename (ibfd));
d2293 2
a2294 3
	    (_("%s: compiled normally and linked with "
	       "modules compiled with -mrelocatable"),
	     bfd_archive_filename (ibfd));
d2320 1
a2320 1
	    (_("%s: uses different e_flags (0x%lx) fields "
d2322 1
a2322 1
	     bfd_archive_filename (ibfd), (long) new_flags, (long) old_flags);
d3562 2
a3563 2
    (_("%s: relocation %s cannot be used when making a shared object"),
     bfd_archive_filename (abfd),
d3589 2
a3590 3
  fprintf (stderr, "ppc_elf_check_relocs called for section %s in %s\n",
	   bfd_get_section_name (abfd, sec),
	   bfd_archive_filename (abfd));
d3767 1
a3767 1
	      (*_bfd_error_handler) (_("%s(%s+0x%lx): %s reloc against "
d3769 2
a3770 2
				     bfd_archive_filename (abfd),
				     sec->name,
d4664 5
a4668 6
  fprintf (stderr, "ppc_elf_relocate_section called for %s section %s, "
	   "%ld relocations%s\n",
	   bfd_archive_filename (input_bfd),
	   bfd_section_name(input_bfd, input_section),
	   (long) input_section->reloc_count,
	   (info->relocatable) ? " (relocatable)" : "");
d4971 2
a4972 2
	    (_("%s: unknown relocation type %d for symbol %s"),
	     bfd_archive_filename (input_bfd), (int) r_type, sym_name);
d5222 3
a5224 3
		(_("%s(%s+0x%lx): non-zero addend on %s reloc against `%s'"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
d5533 1
a5533 1
		  (_("%s: the target (%s) of a %s relocation is "
d5535 1
a5535 1
		   bfd_archive_filename (input_bfd),
d5559 1
a5559 1
		  (_("%s: the target (%s) of a %s relocation is "
d5561 1
a5561 1
		   bfd_archive_filename (input_bfd),
d5618 1
a5618 1
		  (_("%s: the target (%s) of a %s relocation is "
d5620 1
a5620 1
		   bfd_archive_filename (input_bfd),
d5673 2
a5674 2
	    (_("%s: relocation %s is not yet supported for symbol %s."),
	     bfd_archive_filename (input_bfd),
d5728 3
a5730 3
	    (_("%s(%s+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     bfd_archive_filename (input_bfd),
	     bfd_get_section_name (input_bfd, input_section),
d5778 2
a5779 3
		(_("%s(%s+0x%lx): %s reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
d6021 1
a6021 1
	  error_message = _("corrupt or empty %s section in %s");
d6028 1
a6028 1
	  error_message = _("unable to read in %s section from %s");
d6034 1
a6034 1
      error_message = _("corrupt %s section in %s");
d6077 1
a6077 1
      error_message = _("warning: unable to set size of %s section in %s");
d6083 1
a6083 2
    (*_bfd_error_handler) (error_message, APUINFO_SECTION_NAME,
			   bfd_archive_filename (ibfd));
@


1.122
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a2159 1
  bfd_size_type sz;
d2167 1
a2167 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
@


1.121
log
@	* elf32-ppc.c (ppc_elf_relax_section): Implement reference code
	for handling SEC_MERGE symbols in relax_section.
	* coff-i386.c: Update copyright date.
@
text
@d1682 1
a1682 5
  /* If needed, initialize this section's cooked size.  */
  if (isec->_cooked_size == 0)
    isec->_cooked_size = isec->_raw_size;

  trampoff = (isec->_cooked_size + 3) & (bfd_vma) -4;
a1696 15
  /* Get the section contents.  */
  /* Get cached copy if it exists.  */
  if (elf_section_data (isec)->this_hdr.contents != NULL)
    contents = elf_section_data (isec)->this_hdr.contents;
  else
    {
      /* Go get them off disk.  */
      contents = bfd_malloc (isec->_raw_size);
      if (contents == NULL)
	goto error_return;

      if (!bfd_get_section_contents (abfd, isec, contents, 0, isec->_raw_size))
	goto error_return;
    }

d1895 14
d1954 1
a1954 1
      isec->_cooked_size = (isec->_cooked_size + 3) & (bfd_vma) -4;
d1956 3
a1958 3
      val = trampoff - isec->_cooked_size + 0x48000000;
      dest = contents + isec->_cooked_size;
      isec->_cooked_size = trampoff;
d2160 1
d2168 2
a2169 1
  if (reloc_entry->address > input_section->_cooked_size)
d2431 1
a2431 1
	lsect->rel_section->_raw_size += sizeof (Elf32_External_Rela);
d2467 1
a2467 1
	  lsect->rel_section->_raw_size += sizeof (Elf32_External_Rela);
d2486 2
a2487 2
  linker_section_ptr->offset = lsect->section->_raw_size;
  lsect->section->_raw_size += 4;
d2493 1
a2493 1
	   (long) lsect->section->_raw_size);
d2692 1
a2692 1
  s->_raw_size = align_power (s->_raw_size, 2);
d2696 1
a2696 1
	   name, (long) s->_raw_size);
d2756 1
a2756 1
  if (s != NULL && (s->flags & SEC_LOAD) != 0 && s->_raw_size > 0)
d2760 1
a2760 1
  if (s != NULL && (s->flags & SEC_LOAD) != 0 && s->_raw_size > 0)
d3000 1
a3000 1
      srel->_raw_size += sizeof (Elf32_External_Rela);
d3011 1
a3011 2
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
d3020 1
a3020 1
  h->root.u.def.value = s->_raw_size;
d3023 1
a3023 1
  s->_raw_size += h->size;
d3077 2
a3078 2
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_INITIAL_ENTRY_SIZE;
d3085 1
a3085 1
			      * ((s->_raw_size - PLT_INITIAL_ENTRY_SIZE)
d3102 2
a3103 2
	  s->_raw_size += PLT_ENTRY_SIZE;
	  if ((s->_raw_size - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
d3105 1
a3105 1
	    s->_raw_size += PLT_ENTRY_SIZE;
d3108 1
a3108 1
	  htab->relplt->_raw_size += sizeof (Elf32_External_Rela);
d3140 1
a3140 1
	  eh->elf.got.offset = htab->got->_raw_size;
d3144 1
a3144 1
		htab->got->_raw_size += 8;
d3146 1
a3146 1
		htab->got->_raw_size += 8;
d3148 1
a3148 1
		htab->got->_raw_size += 4;
d3150 1
a3150 1
		htab->got->_raw_size += 4;
d3153 1
a3153 1
	    htab->got->_raw_size += 4;
d3161 2
a3162 2
	      htab->relgot->_raw_size
		+= ((htab->got->_raw_size - eh->elf.got.offset) / 4
d3166 1
a3166 1
		htab->relgot->_raw_size -= sizeof (Elf32_External_Rela);
d3257 1
a3257 1
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
d3318 1
a3318 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d3325 2
a3326 2
      htab->tlsld_got.offset = htab->got->_raw_size;
      htab->got->_raw_size += 8;
d3328 1
a3328 1
	htab->relgot->_raw_size += sizeof (Elf32_External_Rela);
d3366 1
a3366 1
		  elf_section_data (p->sec)->sreloc->_raw_size
d3395 2
a3396 2
		    htab->tlsld_got.offset = s->_raw_size;
		    s->_raw_size += 8;
d3398 1
a3398 1
		      srel->_raw_size += sizeof (Elf32_External_Rela);
d3404 1
a3404 1
		*local_got = s->_raw_size;
d3408 1
a3408 1
		      s->_raw_size += 8;
d3410 1
a3410 1
		      s->_raw_size += 4;
d3412 1
a3412 1
		      s->_raw_size += 4;
d3415 1
a3415 1
		  s->_raw_size += 4;
d3417 2
a3418 2
		  srel->_raw_size += ((s->_raw_size - *local_got) / 4
				      * sizeof (Elf32_External_Rela));
d3446 1
a3446 1
	  if (s->_raw_size == 0)
d3474 1
a3474 1
      if (s->_raw_size == 0)
d3481 1
a3481 1
      s->contents = bfd_zalloc (htab->elf.dynobj, s->_raw_size);
d3502 1
a3502 1
      if (htab->plt != NULL && htab->plt->_raw_size != 0)
d4566 1
a4566 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d4582 1
a4582 1
	      dyn.d_un.d_val = htab->relplt->_raw_size;
d5824 1
a5824 1
  unsigned int raw_size;
d5840 1
a5840 1
      raw_size = 192;
d5847 1
a5847 1
					  raw_size, note->descpos + offset);
d5993 1
a5993 1
	  output_section_size += asec->_raw_size;
d6025 1
a6025 1
      length = asec->_raw_size;
d6126 1
a6126 1
  length = asec->_raw_size;
d6152 1
a6152 1
  if (length != asec->_raw_size)
@


1.120
log
@	* elf32-ppc.c (ppc_elf_create_linker_section): Create symbols in
	the pre-existing section.
@
text
@d1726 1
d1774 1
d1804 2
d1814 35
a1848 5
      toff += irel->r_addend;
      if (tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	toff = _bfd_merged_section_offset (abfd, &tsec,
					   elf_section_data (tsec)->sec_info,
					   toff);
@


1.119
log
@	* merge.c (_bfd_merged_section_offset): Remove "addend" param.
	* libbfd-in.h (_bfd_merged_section_offset): Adjust prototype.
	* libbfd.h: Regenerate.
	* elf.c (_bfd_elf_rela_local_sym): Adjust call.
	(_bfd_elf_rel_local_sym): Likewise.
	* elflink.c (_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_input_bfd): Likewise.
	* elf32-ppc.c (ppc_elf_relax_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_relocate_section): Likewise.
@
text
@d2596 1
a2596 1
  asection *s;
d2645 1
a2645 1
  s = bfd_get_section_by_name (htab->elf.dynobj, name);
d2652 2
d2681 1
a2681 1
	       (info, abfd, sym_name, BSF_GLOBAL, s, sym_offset, NULL,
@


1.118
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d1814 1
a1814 1
					   toff, 0);
@


1.117
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d6131 11
d6219 1
@


1.116
log
@	* elf64-ppc.c (elf_backend_add_symbol_hook): Define.
	(ppc64_elf_add_symbol_hook): New function.
	* elf-bfd.h (struct elf_backend_data <elf_add_symbol_hook>): Remove
	const from Elf_Internal_Sym param.
	* elflink.c (elf_link_add_object_symbols): Adjust.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Adjust.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Adjust.
	* elf32-i370.c (elf_backend_add_symbol_hook): Adjust.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Adjust.
	* elf32-m68hc1x.c (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-m68hc1x.h (elf32_m68hc11_add_symbol_hook): Adjust.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Adjust.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Adjust.
	* elf32-v850.c (v850_elf_add_symbol_hook): Adjust.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Adjust.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Adjust.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Adjust.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Adjust.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_add_symbol_hook): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_add_symbol_hook): Adjust.
@
text
@d2395 1
a2395 1
	  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
d2688 1
a2688 1
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
a2995 11
/* This is the condition under which finish_dynamic_symbol will be
   called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d3034 1
a3034 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d3097 1
a3097 1
	  if (!bfd_elf32_link_record_dynamic_symbol (info, &eh->elf))
d3187 1
a3187 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d3206 1
a3206 1
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
d3798 1
a3798 1
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3805 1
a3805 1
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.115
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d4379 1
a4379 1
			 const Elf_Internal_Sym *sym,
@


1.114
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d3473 1
a3473 1
  bfd_elf32_add_dynamic_entry (info, (TAG), (VAL))
@


1.113
log
@copyright date.
@
text
@d4704 4
a4707 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.112
log
@	* elflink.c (elf_link_read_relocs_from_section): Don't use
	NUM_SHDR_ENTRIES in end of reloc calc.  Move NULL shdr check..
	(_bfd_elf_link_read_relocs): ..to here.
	* elf32-ppc.c (ppc_elf_relax_section): Formatting.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
@


1.111
log
@	* elf32-ppc.c (allocate_dynrelocs): Create dynsym for undef weak
	symbols used in PIE relocs.
@
text
@d1819 1
a1819 4

      reladdr = (isec->output_section->vma
		 + isec->output_offset
		 + roff);
@


1.111.2.1
log
@Merge mainline to intercu branch.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d1819 4
a1822 1
      reladdr = isec->output_section->vma + isec->output_offset + roff;
d3476 1
a3476 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d4382 1
a4382 1
			 Elf_Internal_Sym *sym,
d4707 4
a4710 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.111.2.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d2395 1
a2395 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2688 1
a2688 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d2996 11
d3045 1
a3045 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3108 1
a3108 1
	  if (!bfd_elf_link_record_dynamic_symbol (info, &eh->elf))
d3198 1
a3198 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3217 1
a3217 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3809 1
a3809 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3816 1
a3816 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.111.2.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d1682 5
a1686 1
  trampoff = (isec->size + 3) & (bfd_vma) -4;
d1701 15
a1725 1
      unsigned char sym_type;
a1772 1
	  sym_type = ELF_ST_TYPE (isym->st_info);
a1801 2

	  sym_type = h->type;
d1810 5
a1814 35
      /* There probably isn't any reason to handle symbols in
	 SEC_MERGE sections;  SEC_MERGE doesn't seem a likely
	 attribute for a code section, and we are only looking at
	 branches.  However, implement it correctly here as a
	 reference for other target relax_section functions.  */
      if (0 && tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	{
	  /* At this stage in linking, no SEC_MERGE symbol has been
	     adjusted, so all references to such symbols need to be
	     passed through _bfd_merged_section_offset.  (Later, in
	     relocate_section, all SEC_MERGE symbols *except* for
	     section symbols have been adjusted.)

	     gas may reduce relocations against symbols in SEC_MERGE
	     sections to a relocation against the section symbol when
	     the original addend was zero.  When the reloc is against
	     a section symbol we should include the addend in the
	     offset passed to _bfd_merged_section_offset, since the
	     location of interest is the original symbol.  On the
	     other hand, an access to "sym+addend" where "sym" is not
	     a section symbol should not include the addend;  Such an
	     access is presumed to be an offset from "sym";  The
	     location of interest is just "sym".  */
	  if (sym_type == STT_SECTION)
	    toff += irel->r_addend;

	  toff = _bfd_merged_section_offset (abfd, &tsec,
					     elf_section_data (tsec)->sec_info,
					     toff);

	  if (sym_type != STT_SECTION)
	    toff += irel->r_addend;
	}
      else
	toff += irel->r_addend;
a1879 14
      /* Get the section contents.  */
      if (contents == NULL)
	{
	  /* Get cached copy if it exists.  */
	  if (elf_section_data (isec)->this_hdr.contents != NULL)
	    contents = elf_section_data (isec)->this_hdr.contents;
	  else
	    {
	      /* Go get them off disk.  */
	      if (!bfd_malloc_and_get_section (abfd, isec, &contents))
		goto error_return;
	    }
	}

d1925 1
a1925 1
      isec->size = (isec->size + 3) & (bfd_vma) -4;
d1927 3
a1929 3
      val = trampoff - isec->size + 0x48000000;
      dest = contents + isec->size;
      isec->size = trampoff;
d2138 1
a2138 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d2256 3
a2258 2
	    (_("%B: compiled with -mrelocatable and linked with "
	       "modules compiled normally"), ibfd);
d2265 3
a2267 2
	    (_("%B: compiled normally and linked with "
	       "modules compiled with -mrelocatable"), ibfd);
d2293 1
a2293 1
	    (_("%B: uses different e_flags (0x%lx) fields "
d2295 1
a2295 1
	     ibfd, (long) new_flags, (long) old_flags);
d2400 1
a2400 1
	lsect->rel_section->size += sizeof (Elf32_External_Rela);
d2436 1
a2436 1
	  lsect->rel_section->size += sizeof (Elf32_External_Rela);
d2455 2
a2456 2
  linker_section_ptr->offset = lsect->section->size;
  lsect->section->size += 4;
d2462 1
a2462 1
	   (long) lsect->section->size);
d2596 1
a2596 1
  asection *s, *sym_sec;
d2645 1
a2645 1
  sym_sec = s = bfd_get_section_by_name (htab->elf.dynobj, name);
a2651 2
      if (sym_sec == NULL)
	sym_sec = s;
d2659 1
a2659 1
  s->size = align_power (s->size, 2);
d2663 1
a2663 1
	   name, (long) s->size);
d2679 1
a2679 1
	       (info, abfd, sym_name, BSF_GLOBAL, sym_sec, sym_offset, NULL,
d2723 1
a2723 1
  if (s != NULL && (s->flags & SEC_LOAD) != 0 && s->size > 0)
d2727 1
a2727 1
  if (s != NULL && (s->flags & SEC_LOAD) != 0 && s->size > 0)
d2967 1
a2967 1
      srel->size += sizeof (Elf32_External_Rela);
d2978 2
a2979 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d2988 1
a2988 1
  h->root.u.def.value = s->size;
d2991 1
a2991 1
  s->size += h->size;
d3045 2
a3046 2
	  if (s->size == 0)
	    s->size += PLT_INITIAL_ENTRY_SIZE;
d3053 1
a3053 1
			      * ((s->size - PLT_INITIAL_ENTRY_SIZE)
d3070 2
a3071 2
	  s->size += PLT_ENTRY_SIZE;
	  if ((s->size - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
d3073 1
a3073 1
	    s->size += PLT_ENTRY_SIZE;
d3076 1
a3076 1
	  htab->relplt->size += sizeof (Elf32_External_Rela);
d3108 1
a3108 1
	  eh->elf.got.offset = htab->got->size;
d3112 1
a3112 1
		htab->got->size += 8;
d3114 1
a3114 1
		htab->got->size += 8;
d3116 1
a3116 1
		htab->got->size += 4;
d3118 1
a3118 1
		htab->got->size += 4;
d3121 1
a3121 1
	    htab->got->size += 4;
d3129 2
a3130 2
	      htab->relgot->size
		+= ((htab->got->size - eh->elf.got.offset) / 4
d3134 1
a3134 1
		htab->relgot->size -= sizeof (Elf32_External_Rela);
d3225 1
a3225 1
      sreloc->size += p->count * sizeof (Elf32_External_Rela);
d3286 1
a3286 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d3293 2
a3294 2
      htab->tlsld_got.offset = htab->got->size;
      htab->got->size += 8;
d3296 1
a3296 1
	htab->relgot->size += sizeof (Elf32_External_Rela);
d3334 1
a3334 1
		  elf_section_data (p->sec)->sreloc->size
d3363 2
a3364 2
		    htab->tlsld_got.offset = s->size;
		    s->size += 8;
d3366 1
a3366 1
		      srel->size += sizeof (Elf32_External_Rela);
d3372 1
a3372 1
		*local_got = s->size;
d3376 1
a3376 1
		      s->size += 8;
d3378 1
a3378 1
		      s->size += 4;
d3380 1
a3380 1
		      s->size += 4;
d3383 1
a3383 1
		  s->size += 4;
d3385 2
a3386 2
		  srel->size += ((s->size - *local_got) / 4
				 * sizeof (Elf32_External_Rela));
d3414 1
a3414 1
	  if (s->size == 0)
d3442 1
a3442 1
      if (s->size == 0)
d3449 1
a3449 1
      s->contents = bfd_zalloc (htab->elf.dynobj, s->size);
d3470 1
a3470 1
      if (htab->plt != NULL && htab->plt->size != 0)
d3534 2
a3535 2
    (_("%B: relocation %s cannot be used when making a shared object"),
     abfd,
d3561 3
a3563 2
  _bfd_error_handler ("ppc_elf_check_relocs called for section %A in %B",
		      sec, abfd);
d3740 1
a3740 1
	      (*_bfd_error_handler) (_("%B(%A+0x%lx): %s reloc against "
d3742 2
a3743 2
				     abfd,
				     sec,
d4534 1
a4534 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
d4550 1
a4550 1
	      dyn.d_un.d_val = htab->relplt->size;
d4637 6
a4642 5
  _bfd_error_handler ("ppc_elf_relocate_section called for %B section %A, "
		      "%ld relocations%s",
		      input_bfd, input_section,
		      (long) input_section->reloc_count,
		      (info->relocatable) ? " (relocatable)" : "");
d4945 2
a4946 2
	    (_("%B: unknown relocation type %d for symbol %s"),
	     input_bfd, (int) r_type, sym_name);
d5196 3
a5198 3
		(_("%B(%A+0x%lx): non-zero addend on %s reloc against `%s'"),
		 input_bfd,
		 input_section,
d5507 1
a5507 1
		  (_("%B: the target (%s) of a %s relocation is "
d5509 1
a5509 1
		   input_bfd,
d5533 1
a5533 1
		  (_("%B: the target (%s) of a %s relocation is "
d5535 1
a5535 1
		   input_bfd,
d5592 1
a5592 1
		  (_("%B: the target (%s) of a %s relocation is "
d5594 1
a5594 1
		   input_bfd,
d5647 2
a5648 2
	    (_("%B: relocation %s is not yet supported for symbol %s."),
	     input_bfd,
d5702 3
a5704 3
	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     input_bfd,
	     input_section,
d5752 3
a5754 2
		(_("%B(%A+0x%lx): %s reloc against `%s': error %d"),
		 input_bfd, input_section,
d5792 1
a5792 1
  unsigned int size;
d5808 1
a5808 1
      size = 192;
d5815 1
a5815 1
					  size, note->descpos + offset);
d5961 1
a5961 1
	  output_section_size += asec->size;
d5993 1
a5993 1
      length = asec->size;
d5996 1
a5996 1
	  error_message = _("corrupt or empty %s section in %B");
d6003 1
a6003 1
	  error_message = _("unable to read in %s section from %B");
d6009 1
a6009 1
      error_message = _("corrupt %s section in %B");
d6052 1
a6052 1
      error_message = _("warning: unable to set size of %s section in %B");
d6058 2
a6059 1
    (*_bfd_error_handler) (error_message, ibfd, APUINFO_SECTION_NAME);
d6094 1
a6094 1
  length = asec->size;
d6120 1
a6120 1
  if (length != asec->size)
a6130 11
/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
ppc_elf_plt_sym_val (bfd_vma i ATTRIBUTE_UNUSED,
		     const asection *plt ATTRIBUTE_UNUSED,
		     const arelent *rel)
{
  return rel->address;
}

a6207 1
#define elf_backend_plt_sym_val			ppc_elf_plt_sym_val
@


1.111.2.4
log
@Merge from mainline.
@
text
@d332 9
a340 10
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
    }
d2529 1
a2529 1
	      && h->def_regular))
d2875 8
a2882 5
	      && (h->needs_plt
		  || h->u.weakdef != NULL
		  || (h->def_dynamic
		      && h->ref_regular
		      && !h->def_regular)));
d2886 1
a2886 1
      || h->needs_plt)
d2906 1
a2906 1
	  h->needs_plt = 0;
d2916 1
a2916 1
  if (h->u.weakdef != NULL)
d2918 4
a2921 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d2923 3
a2925 1
	h->non_got_ref = h->u.weakdef->non_got_ref;
d2941 1
a2941 1
  if (!h->non_got_ref)
d2958 1
a2958 1
	  h->non_got_ref = 0;
d2997 1
a2997 1
      h->needs_copy = 1;
d3060 1
a3060 1
	  && !h->forced_local)
d3090 1
a3090 1
	      && !h->def_regular)
d3109 1
a3109 1
	  h->needs_plt = 0;
d3115 1
a3115 1
      h->needs_plt = 0;
d3123 1
a3123 1
	  && !eh->elf.forced_local)
d3130 1
a3130 1
	  && !eh->elf.def_dynamic)
d3213 1
a3213 1
	  && !h->forced_local)
d3225 3
a3227 3
      if (!h->non_got_ref
	  && h->def_dynamic
	  && !h->def_regular)
d3232 1
a3232 1
	      && !h->forced_local)
d3777 1
a3777 1
	  h->needs_plt = 1;
d3886 1
a3886 1
	      h->non_got_ref = 1;
d3916 2
a3917 1
			   || !h->def_regular))))
d3923 2
a3924 1
		      || !h->def_regular)))
d4253 1
a4253 1
		    || !h->def_dynamic)
d4481 1
a4481 1
      if (!h->def_regular)
d4490 2
a4491 1
	  if (!h->ref_regular_nonweak)
d4496 1
a4496 1
  if (h->needs_copy)
d5035 1
a5035 1
		    || !h->def_dynamic))
d5078 2
a5079 1
			 || !h->def_dynamic)
d5198 2
a5199 1
			     || !h->def_dynamic))
d5324 3
a5326 3
		  && !h->non_got_ref
		  && h->def_dynamic
		  && !h->def_regular))
d5725 1
a5725 1
	       && h->def_dynamic))
@


1.111.6.1
log
@Merge with mainline cagney_tramp-20040321-mergepoint.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d1819 4
a1822 1
      reladdr = isec->output_section->vma + isec->output_offset + roff;
@


1.110
log
@2003-12-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-ppc.c (ppc_elf_relax_section): Don't check relax_finalizing.
@
text
@d3192 12
@


1.110.6.1
log
@	* elflink.c (elf_link_read_relocs_from_section): Don't use
	NUM_SHDR_ENTRIES in end of reloc calc.  Move NULL shdr check..
	(_bfd_elf_link_read_relocs): ..to here.
	* elf32-ppc.c (ppc_elf_relax_section): Formatting.

	Merge from mainline.
	2004-02-20  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (allocate_dynrelocs): Create dynsym for undef weak
	symbols used in PIE relocs.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d1819 4
a1822 1
      reladdr = isec->output_section->vma + isec->output_offset + roff;
a3191 12

      /* Make sure undefined weak symbols are output as a dynamic symbol
	 in PIEs.  */
      if (info->pie
	  && eh->dyn_relocs != NULL
	  && h->dynindx == -1
	  && h->root.type == bfd_link_hash_undefweak
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}
@


1.110.6.2
log
@Merge from mainline
@
text
@d2395 1
a2395 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2688 1
a2688 1
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
d2996 11
d3045 1
a3045 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3108 1
a3108 1
	  if (!bfd_elf_link_record_dynamic_symbol (info, &eh->elf))
d3198 1
a3198 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3217 1
a3217 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d3473 1
a3473 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d3809 1
a3809 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d3816 1
a3816 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d4379 1
a4379 1
			 Elf_Internal_Sym *sym,
d4704 4
a4707 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.109
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@d1678 2
a1679 5
  /* Nothing to do if there are no relocations and no need for
     the relax finalize pass.  */
  if ((isec->flags & SEC_RELOC) == 0
      || isec->reloc_count == 0
      || link_info->relax_finalizing)
@


1.108
log
@* elf-bfd.h (elf_backend_data::elf_backend_modify_segment_map):
Add link info argument.
* elf32-i370.c (elf_backend_modify_segment_map): Likewise.
* elf32-ppc.c (ppc_elf_modify_segment_map): Likewise.
* elf32-xtensa.c (elf_xtensa_modify_segment_map): Likewise.
* elf64-hppa.c (elf64_hppa_modify_segment_map): Likewise.
* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
* elfxx-mips.h (_bfd_mips_elf_modify_segment_map): Likewise.
* elf.c (assign_file_positions_except_relocs,
assign_file_positions_for_segments): Likewise.  Adjust calls.
@
text
@d1767 1
a1767 1
	    continue;	/* We can't do anthing with undefined symbols.  */
d4922 1
a4922 1
	  /* Branch not taken predicition relocations.  */
@


1.107
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@d2742 2
a2743 1
ppc_elf_modify_segment_map (bfd *abfd ATTRIBUTE_UNUSED)
@


1.106
log
@	* elf32-ppc.c (ppc_elf_install_value): Delete.
	(shared_stub_entry, stub_entry): Make them arrays of ints.
	Remove initial branch.
	(ppc_elf_relax_section): Write one branch around all trampolines
	instead.  Correct bogus R_PPC_PLTREL24 handling.  Correct
	branch range check.  Only use shared_stub_entry when shared.
	Test that branches can reach stubs.  Write trampolines out at
	end so that just one realloc is used.  Handle little-endian
	mode.  Move relevant code from ppc_elf_install_value to here.
	(ppc_elf_relocate_section): Move code handling RELAX32 from
	ppc_elf_install_value to here.
@
text
@d339 2
a340 1
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
@


1.105
log
@	* elf32-ppc.c (ppc_elf_howto_raw); Add entry for R_PPC_RELAX32PC.
	(ppc_elf_install_value): Handle R_PPC_RELAX32PC.  Merge duplicate
	cases.
	(shared_stub_entry): Correct opcode.
	(ppc_elf_relax_section): Generate R_PPC_RELAX32PC relocs.
	(ppc_elf_relocate_section): Handle them.
@
text
@d1535 3
a1537 3
  HOWTO (R_PPC_RELAX32,         /* type */
	 0,                     /* rightshift */
	 0,                     /* size */
d1543 1
a1543 1
	 "R_PPC_RELAX32",      	/* name */
d1546 1
a1546 1
	 0,	        	/* dst_mask */
d1549 3
a1551 3
  HOWTO (R_PPC_RELAX32PC,       /* type */
	 0,                     /* rightshift */
	 0,                     /* size */
d1557 1
a1557 1
	 "R_PPC_RELAX32PC",    	/* name */
d1560 1
a1560 1
	 0,	        	/* dst_mask */
d1628 1
a1628 41
static bfd_reloc_status_type
ppc_elf_install_value (bfd *abfd,
		       bfd_byte *hit_addr,
		       bfd_vma v,
		       unsigned int r_type)
{
  bfd_vma t0, t1;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val = (BFD_HOST_U_64_BIT) v;
#else
  bfd_vma val = v;
#endif

  switch (r_type)
    {
    case R_PPC_RELAX32:
    case R_PPC_RELAX32PC:
      t0 = bfd_get_32 (abfd, hit_addr);
      t1 = bfd_get_32 (abfd, hit_addr + 4);

      /* We're clearing the bits for R_PPC_ADDR16_HA
	 and R_PPC_ADDR16_LO here.  */
      t0 &= ~0xffff;
      t1 &= ~0xffff;

      /* t0 is HA, t1 is lo */
      t0 |= ((val + 0x8000) >> 16) & 0xffff;
      t1 |= val & 0xffff;

      bfd_put_32 (abfd, t0, hit_addr);
      bfd_put_32 (abfd, t1, hit_addr + 4);
      break;

    case R_PPC_REL24:
    case R_PPC_LOCAL24PC:
    case R_PPC_PLTREL24:
      t0 = bfd_get_32 (abfd, hit_addr);
      t0 &= ~0x3fffffc;
      t0 |= val & 0x3fffffc;
      bfd_put_32 (abfd, t0, hit_addr);
      break;
d1630 1
a1630 17
    case R_PPC_REL14:
    case R_PPC_REL14_BRTAKEN:
    case R_PPC_REL14_BRNTAKEN:
      t0 = bfd_get_32 (abfd, hit_addr);
      t0 &= ~0xfffc;
      t0 |= val & 0xfffc;
      bfd_put_32 (abfd, t0, hit_addr);
      break;

    default:
      return bfd_reloc_notsupported;
    }

  return bfd_reloc_ok;
}

static const bfd_byte shared_stub_entry[] =
d1632 8
a1639 9
    0x48, 0x00, 0x00, 0x24, /* b .+36 */
    0x7c, 0x08, 0x02, 0xa6, /* mflr 0 */
    0x42, 0x9f, 0x00, 0x05, /* bcl 20, 31, .Lxxx */
    0x7d, 0x68, 0x02, 0xa6, /* mflr 11 */
    0x3d, 0x6b, 0x00, 0x00, /* addis 11, 11, (xxx-.Lxxx)@@ha */
    0x39, 0x6b, 0x00, 0x18, /* addi 11, 11, (xxx-.Lxxx)@@l */
    0x7c, 0x08, 0x03, 0xa6, /* mtlr 0 */
    0x7d, 0x69, 0x03, 0xa6, /* mtctr 11 */
    0x4e, 0x80, 0x04, 0x20, /* bctr */
d1642 1
a1642 1
static const bfd_byte stub_entry[] =
d1644 4
a1647 5
    0x48, 0x00, 0x00, 0x14, /* b .+20 */
    0x3d, 0x60, 0x00, 0x00, /* lis 11,xxx@@ha */
    0x39, 0x6b, 0x00, 0x00, /* addi 11,11,xxx@@l */
    0x7d, 0x69, 0x03, 0xa6, /* mtctr 11 */
    0x4e, 0x80, 0x04, 0x20, /* bctr */
d1671 1
a1671 2
  bfd_boolean changed_contents = FALSE;
  bfd_boolean changed_relocs = FALSE;
d1673 1
d1688 4
d1721 1
a1721 1
      bfd_vma symaddr, reladdr, trampoff, toff, roff;
a1722 1
      bfd_size_type amt;
d1725 3
a1727 1
      bfd_vma max_branch_offset;
d1733 4
d1740 1
a1740 1
	case R_PPC_PLTREL24:
d1778 1
a1778 1
	  /* Need dynamic symbol handling.  */
d1789 3
a1791 1
	  if (r_type == R_PPC_PLTREL24)
d1793 2
a1794 36
	      Elf_Internal_Sym *isym;

	      if (h->plt.offset == (bfd_vma) -1
		  || ppc_info->plt == NULL)
		{

		  /* Read this BFD's local symbols.  */
		  if (isymbuf == NULL)
		    {
		      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
		      if (isymbuf == NULL)
			isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
							symtab_hdr->sh_info, 0,
							NULL, NULL, NULL);
		      if (isymbuf == 0)
			goto error_return;
		    }
		  isym = isymbuf + ELF32_R_SYM (irel->r_info);

		  if (isym->st_shndx == SHN_UNDEF)
		    /* We can't do anthing with undefined symbols.  */
		    continue;
		  else if (isym->st_shndx == SHN_ABS)
		    tsec = bfd_abs_section_ptr;
		  else if (isym->st_shndx == SHN_COMMON)
		    tsec = bfd_com_section_ptr;
		  else
		    tsec = h->root.u.def.section;

		  toff = h->root.u.def.value;
		}
	      else
		{
		  tsec = ppc_info->plt;
		  toff = h->plt.offset;
		}
d1796 2
a1797 5
	  else if (h->root.type == bfd_link_hash_undefined
		   || h->root.type == bfd_link_hash_undefweak)
	    continue;

	  else
d1802 2
d1806 7
d1816 1
a1816 3
					   toff + irel->r_addend, 0);
      else
	toff += irel->r_addend;
d1824 1
a1824 1
		 + roff) & (bfd_vma) -4;
d1827 1
a1827 8
      max_branch_offset = 1 << 25;
      if (r_type != R_PPC_REL24
	  && r_type != R_PPC_LOCAL24PC
	  && r_type != R_PPC_PLTREL24)
	max_branch_offset = 1 << 15;

      if ((bfd_vma) (symaddr - reladdr) + max_branch_offset
	  <= 2 * max_branch_offset)
d1830 1
a1830 13
      /* If the branch and target are in the same section, you have
	 no hope.  We'll error out later.  */
      if (tsec == isec)
	continue;

      /* Look for an existing fixup to this address.
	 ??? What if the existing fixup is for a non-pic stub, and the
	 new one requires a pic stub?  This presumably could happen with
	 a static link and a mix of R_PPC_LOCAL24PC and R_PPC_REL24
	 relocs to a symbol needing long branch stubs.
	 ??? Why do we require R_PPC_LOCAL24PC and branches to the plt
	 to have a shared branch stub?  Shared branch stubs should only
	 be needed when info->shared.  */
a1836 1
	  const bfd_byte *stub;
d1840 10
a1849 7
	  if (link_info->shared
	      || tsec == ppc_info->plt
	      || r_type == R_PPC_LOCAL24PC)
	    {
	      stub = shared_stub_entry;
	      size = sizeof (shared_stub_entry);
	      insn_offset = 16;
d1854 2
a1855 3
	      stub = stub_entry;
	      size = sizeof (stub_entry);
	      insn_offset = 4;
a1858 11
	  /* Resize the current section to make room for the new branch.  */
	  trampoff = (isec->_cooked_size + 3) & (bfd_vma) - 4;
	  amt = trampoff + size;
	  contents = bfd_realloc (contents, amt);
	  if (contents == NULL)
	    abort ();

	  isec->_cooked_size = amt;

	  memcpy (contents + trampoff, stub, size);

d1872 2
d1877 4
d1885 12
a1896 6
      /* Fix up the existing branch to hit the trampoline.  Hope like
	 hell this doesn't overflow too.  */
      if (ppc_elf_install_value (abfd, contents + roff,
				 f->trampoff - (roff & (bfd_vma) -3) + 4,
				 r_type) != bfd_reloc_ok)
	abort ();
d1898 9
a1906 2
      changed_contents = TRUE;
      changed_relocs = TRUE;
d1909 3
a1911 2
  /* Clean up.  */
  while (fixups)
d1913 46
a1958 3
      struct one_fixup *f = fixups;
      fixups = fixups->next;
      free (f);
d1960 1
d1976 1
a1976 1
      if (!changed_contents && !link_info->keep_memory)
d1987 1
a1987 1
      if (!changed_relocs)
d1993 1
a1993 1
  *again = changed_contents || changed_relocs;
d4700 1
a4700 1
	  
d5423 20
a5442 2
	  ppc_elf_install_value (output_bfd, contents + rel->r_offset,
				 relocation + addend, r_type);
@


1.104
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d1534 1
a1534 1
  /* Phony reloc to handle branch stubs.  */
d1549 14
d1644 1
a1644 1
      /* Do stuff here.  */
d1662 2
a1678 8
    case R_PPC_LOCAL24PC:
    case R_PPC_PLTREL24:
      t0 = bfd_get_32 (abfd, hit_addr);
      t0 &= ~0x3fffffc;
      t0 |= val & 0x3fffffc;
      bfd_put_32 (abfd, t0, hit_addr);
      break;

d1692 1
a1692 1
    0x3d, 0x60, 0x00, 0x00, /* addis 11, 11, (xxx-.Lxxx)@@ha */
d1919 8
a1926 1
      /* Look for an existing fixup to this address.  */
d1933 1
d1935 1
d1941 1
d1944 1
d1948 1
d1951 1
d1963 1
a1963 6
	  if (link_info->shared
	      || tsec == ppc_info->plt
	      || r_type == R_PPC_LOCAL24PC)
	    memcpy (contents + trampoff, shared_stub_entry, size);
	  else
	    memcpy (contents + trampoff, stub_entry, size);
d1968 1
a1968 1
				       R_PPC_RELAX32);
d5459 5
@


1.103
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d4718 1
a4718 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d5444 3
a5446 38
	  {
	    unsigned long r_symndx;
	    Elf_Internal_Sym *sym;
	    asection *sym_sec;
	    bfd_byte *hit_addr = 0;
	    bfd_vma value = 0;

	    r_symndx = ELF32_R_SYM (rel->r_info);

	    if (r_symndx < symtab_hdr->sh_info)
	      {
		sym = local_syms + r_symndx;
		sym_sec = local_sections[r_symndx];

		value = _bfd_elf_rela_local_sym (output_bfd, sym, sym_sec, rel);
	      }
	    else
	      {
		bfd_boolean warned;
		bfd_boolean unresolved_reloc;

		RELOC_FOR_GLOBAL_SYMBOL (h, elf_sym_hashes (input_bfd),
					 r_symndx, symtab_hdr,
					 value, sym_sec,
					 unresolved_reloc, info,
					 warned);
		if (warned)
		  continue;
	      }
	    hit_addr = contents + rel->r_offset;
	    value += rel->r_addend;

	    r = ppc_elf_install_value (output_bfd, hit_addr, value, r_type);
	    if (r != bfd_reloc_ok)
	      break;
	    else
	      continue;
	  }
@


1.102
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@a207 3
  /* Short-cut to first output tls section.  */
  asection *tls_sec;

d4184 1
a4184 1
/* Set htab->tls_sec and htab->tls_get_addr.  */
d4186 1
a4186 1
bfd_boolean
a4188 1
  asection *tls;
d4195 1
a4195 7
  for (tls = obfd->sections; tls != NULL; tls = tls->next)
    if ((tls->flags & (SEC_THREAD_LOCAL | SEC_LOAD))
	== (SEC_THREAD_LOCAL | SEC_LOAD))
      break;
  htab->tls_sec = tls;

  return tls != NULL;
d4910 2
a4911 2
			  rel->r_addend = htab->tls_sec->vma + DTP_OFFSET;
			  rel[1].r_addend = htab->tls_sec->vma + DTP_OFFSET;
d5149 1
a5149 1
			      outrel.r_addend -= htab->tls_sec->vma;
d5167 1
a5167 1
			    value -= htab->tls_sec->vma + DTP_OFFSET;
d5255 1
a5255 1
	  addend -= htab->tls_sec->vma + DTP_OFFSET;
d5264 1
a5264 1
	  addend -= htab->tls_sec->vma + TP_OFFSET;
d5271 1
a5271 1
	  addend -= htab->tls_sec->vma + TP_OFFSET;
d5275 1
a5275 1
	  addend -= htab->tls_sec->vma + DTP_OFFSET;
@


1.101
log
@	* elf-bfd.h (struct bfd_elf_special_section): Remove "suffix".  Change
	type of prefix_length and suffix_length to int.  Rename "attributes"
	to "attr".  Comment.
	(_bfd_elf_get_sec_type_attr): Update prototype.
	* elf.c (get_special_section): Rewrite.
	(_bfd_elf_get_sec_type_attr): Return struct rather than passing in
	attr and type pointers.
	(_bfd_elf_new_section_hook): Adjust for above.
	(special_sections): Merge suffix with prefix.  Set
	prefix_length for all entries.  Set suffix_length appropriately.
	* elf32-m32r.c (m32r_elf_special_sections): Likewise.
	* elf32-m68hc11.c (elf32_m68hc11_special_sections): Likewise.
	* elf32-m68hc12.c (elf32_m68hc12_special_sections): Likewise.
	* elf32-mcore.c (mcore_elf_special_sections): Likewise.
	* elf32-sh64.c (sh64_elf_special_sections): Likewise.
	* elf32-v850.c (v850_elf_special_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_special_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_special_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_special_sections): Likewise.
	* elf64-ppc.c (ppc64_elf_special_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_special_sections): Likewise.
	* elfxx-ia64.c (elfNN_ia64_special_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_special_sections): Likewise.
	* elf32-ppc.c (ppc_elf_special_sections): Likewise.  Fix .plt flags.
@
text
@a6226 1
#define elf_backend_plt_header_size	PLT_INITIAL_ENTRY_SIZE
@


1.100
log
@Better handking for unresolved symbols
@
text
@d6189 10
a6198 20
  { ".tags",		0,	NULL,	0,
    SHT_ORDERED,	SHF_ALLOC },
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { ".sdata2",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".sbss2",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".PPC.EMB.apuinfo",	0,	NULL,	0,
    SHT_NOTE,		0 },
  { ".PPC.EMB.sdata0",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".PPC.EMB.sbss0",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".plt",		0,	NULL,	0,
    SHT_NOBITS,		0 },
  { NULL,		0,	NULL,	0,
    0,			0 }
@


1.99
log
@	* elf32-i386.c (elf_i386_relocate_section): Make undefined symbols
	fatal if -pie.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(ppc_elf_relocate_section) <case R_PPC_RELAX32>: Issue fatal error
	on undefined symbols if -pie.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
@
text
@d4721 1
d4732 5
a4736 4
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
a4737 33

	  relocation = 0;
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      /* Set a flag that will be cleared later if we find a
		 relocation value for this symbol.  output_section
		 is typically NULL for symbols satisfied by a shared
		 library.  */
	      if (sec->output_section == NULL)
		unresolved_reloc = TRUE;
	      else
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    ;
	  else if (!info->executable
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    ;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_offset, (info->executable
				      || info->no_undefined
				      || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      warned = TRUE;
	    }
d5472 2
a5473 21
		long indx;

		indx = r_symndx - symtab_hdr->sh_info;
		h = elf_sym_hashes (input_bfd)[indx];
		while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
		  h = (struct elf_link_hash_entry *) h->root.u.i.link;

		value = 0;
		if (h->root.type == bfd_link_hash_defined
		    || h->root.type == bfd_link_hash_defweak)
		  {
		    sym_sec = h->root.u.def.section;

		    /* Detect the cases that sym_sec->output_section is
		       expected to be NULL -- all cases in which the symbol
		       is defined in another shared module.  This includes
		       PLT relocs for which we've created a PLT entry and
		       other relocs for which we're prepared to create
		       dynamic relocations.  */
		    /* ??? Just accept it NULL and continue.  */
d5475 7
a5481 21
		    if (sym_sec->output_section != NULL)
		      {
			value = (h->root.u.def.value
				 + sym_sec->output_section->vma
				 + sym_sec->output_offset);
		      }
		  }
		else if (!info->executable
			 && !info->no_undefined
			 && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
		  ;
		else
		  {
		    if (! ((*info->callbacks->undefined_symbol)
			   (info, h->root.root.string, input_bfd,
			    input_section, rel->r_offset,
			    (info->executable || info->no_undefined
			     || ELF_ST_VISIBILITY (h->other)))))
		      return FALSE;
		    continue;
		  }
@


1.98
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d4763 1
a4763 1
		      rel->r_offset, (!info->shared
d5532 1
a5532 1
		else if (info->shared
d5541 1
a5541 1
			    (!info->shared || info->no_undefined
@


1.97
log
@	* elf32-ppc.c (ppc_elf_install_value): Tidy.
	(ppc_elf_relax_section): Remove dead code.  Remove unnecessary casts.
	Formatting.
	* elfxx-target.h: Remove PARAMS macro.  Formatting.
@
text
@d288 1
a288 1
ppc_elf_copy_indirect_symbol (struct elf_backend_data *bed,
d2584 1
a2584 1
	      struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
d2589 1
@


1.96
log
@2003-07-28  Eric Christopher  <echristo@@redhat.com>

        * elf32-ppc.c (R_PPC_RELAX32): New relocation.
        (ppc_elf_install_value): New function.
        (ppc_elf_sort_rela): Remove.
        (ppc_elf_relax_section): Rewrite. Remove old relaxation
        and replace with out of range branch stubs.
        (ppc_elf_relocate_section): Handle R_PPC_RELAX32.

2003-07-28  Eric Christopher  <echristo@@redhat.com>

        * ppc.h (R_PPC_RELAX32): New. Fake relocation.
@
text
@d1618 4
a1621 1
ppc_elf_install_value (bfd *abfd, bfd_byte *hit_addr, bfd_vma v, unsigned int r_type)
d1639 2
a1640 2
      t0 &= ~(0xffff);
      t1 &= ~(0xffff);
d1644 1
a1644 2
      /*      t0 |= (((val >> 16) + ((val & 0x8000) ? 1 : 0)) & 0xffff); */
      t1 |= (val & 0xffff);
d1652 2
a1653 2
      t0 &= ~(0x3fffffc);
      t0 |= (val & 0x3fffffc);
d1661 2
a1662 2
      t0 &= ~(0xfffc);
      t0 |= (val & 0xfffc);
d1669 2
a1670 2
      t0 &= ~(0x3fffffc);
      t0 |= (val & 0x3fffffc);
a1720 1
  bfd_byte *free_contents = NULL;
a1722 1
  Elf_Internal_Rela *free_relocs = NULL;
a1727 1
  /* We never have to do this more than once per input section.  */
d1730 1
a1730 1
  /* Nothing to do if there are no relocations or there is no need for
d1734 1
a1734 2
      || (link_info->relax_finalizing
	  && isec->need_finalize_relax == 0))
d1744 2
a1745 4
  internal_relocs
    = _bfd_elf_link_read_relocs (abfd, isec, (PTR) NULL,
				 (Elf_Internal_Rela *) NULL,
				 link_info->keep_memory);
a1747 2
  if (! link_info->keep_memory)
    free_relocs = internal_relocs;
d1752 10
a1761 11
      /* Get the section contents.  */
      /* Get cached copy if it exists.  */
      if (elf_section_data (isec)->this_hdr.contents != NULL)
	contents = elf_section_data (isec)->this_hdr.contents;
      else
	{
	  /* Go get them off disk.  */
	  contents = bfd_malloc (isec->_raw_size);
	  if (contents == NULL)
	    goto error_return;
	  free_contents = contents;
d1763 3
a1765 4
	  if (! bfd_get_section_contents (abfd, isec, contents,
					  (file_ptr) 0, isec->_raw_size))
	    goto error_return;
	}
a1769 1
      bfd_boolean is_branch;
d1775 1
a1784 3
	  if (link_info->relax_finalizing)
	     continue;
	  is_branch = TRUE;
d1815 1
a1815 1
	   else
d1838 1
a1838 1
		   || ppc_info->plt == NULL)
d1855 2
a1856 1
		    continue;	/* We can't do anthing with undefined symbols.  */
d1886 1
a1886 2
					   toff + irel->r_addend,
					   (bfd_vma) 0);
d1894 26
a1919 1
      if (is_branch)
d1921 1
a1921 12
	  bfd_vma max_branch_offset;

	  reladdr = (isec->output_section->vma
		     + isec->output_offset
		     + roff) & (bfd_vma) -4;

	  /* If the branch is in range, no need to do anything.  */
	  max_branch_offset = 1 << 25;
	  if (r_type != R_PPC_REL24
	      && r_type != R_PPC_LOCAL24PC
	      && r_type != R_PPC_PLTREL24)
	    max_branch_offset = 1 << 15;
d1923 3
a1925 14
	  if ((bfd_vma) (symaddr - reladdr) + max_branch_offset <= 2 * max_branch_offset)
	    continue;

	  /* If the branch and target are in the same section, you have
	     no hope. We'll error out later.  */
	  if (tsec == isec)
	    continue;

	  /* Look for an existing fixup to this address.  */
	  for (f = fixups; f ; f = f->next)
	    if (f->tsec == tsec && f->toff == toff)
	      break;

	  if (f == NULL)
d1927 2
a1928 51
	      size_t size;

	      if (link_info->shared
		  || tsec == ppc_info->plt
		  || r_type == R_PPC_LOCAL24PC)
		{
		  size = sizeof (shared_stub_entry);
		  insn_offset = 16;
		}
	      else
		{
		  size = sizeof (stub_entry);
		  insn_offset = 4;
		}

	      /* Resize the current section to make room for the new branch.  */
	      trampoff = (isec->_cooked_size + 3) & (bfd_vma) - 4;
	      amt = trampoff + size;
	      contents = (bfd_byte *) bfd_realloc (contents, amt);
	      if (contents == NULL)
		abort ();

	      isec->_cooked_size = amt;

	      if (link_info->shared
		  || tsec == ppc_info->plt
		  || r_type == R_PPC_LOCAL24PC)
		{
		  memcpy (contents + trampoff, shared_stub_entry, size);
		  /* Hijack the old relocation. Since we need two
		     relocations for this use a "composite" reloc.  */
		  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					       R_PPC_RELAX32);
		  irel->r_offset = trampoff + insn_offset;
		}
	      else
		{
		  memcpy (contents + trampoff, stub_entry, size);
		  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
					       R_PPC_RELAX32);
		  irel->r_offset = trampoff + insn_offset;
		}

	      /* Record the fixup so we don't do it again this section.  */
	      f = (struct one_fixup *)
		bfd_malloc ((bfd_size_type) sizeof (*f));
	      f->next = fixups;
	      f->tsec = tsec;
	      f->toff = toff;
	      f->trampoff = trampoff;
	      fixups = f;
d1932 2
a1933 2
	      /* Nop out the reloc, since we're finalizing things here.  */
	      irel->r_info = ELF32_R_INFO (0, R_PPC_NONE);
d1936 5
a1940 5
	  /* Fix up the existing branch to hit the trampoline. Hope like
	     hell this doesn't overflow too.  */
	  if (ppc_elf_install_value (abfd, contents + roff,
				     f->trampoff - (roff & (bfd_vma) -3) + 4,
				     r_type) != bfd_reloc_ok)
d1943 22
a1964 2
	  changed_contents = TRUE;
	  changed_relocs = TRUE;
d1966 15
a2020 3

  if (link_info->relax_finalizing)
    isec->need_finalize_relax = 0;
@


1.95
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d1537 15
d1617 30
a1646 1
/* This function handles relaxing for the PPC with option --mpc860c0[=<n>].
d1648 6
a1653 19
   The MPC860, revision C0 or earlier contains a bug in the die.
   If all of the following conditions are true, the next instruction
   to be executed *may* be treated as a no-op.
   1/ A forward branch is executed.
   2/ The branch is predicted as not taken.
   3/ The branch is taken.
   4/ The branch is located in the last 5 words of a page.
      (The EOP limit is 5 by default but may be specified as any value
      from 1-10.)

   Our software solution is to detect these problematic branches in a
   linker pass and modify them as follows:
   1/ Unconditional branches - Since these are always predicted taken,
      there is no problem and no action is required.
   2/ Conditional backward branches - No problem, no action required.
   3/ Conditional forward branches - Ensure that the "inverse prediction
      bit" is set (ensure it is predicted taken).
   4/ Conditional register branches - Ensure that the "y bit" is set
      (ensure it is predicted taken).  */
d1655 16
a1670 1
/* Sort sections by address.  */
d1672 3
a1674 5
static int
ppc_elf_sort_rela (const void *arg1, const void *arg2)
{
  const Elf_Internal_Rela * const *rela1 = arg1;
  const Elf_Internal_Rela * const *rela2 = arg2;
d1676 1
a1676 2
  /* Sort by offset.  */
  return ((*rela1)->r_offset - (*rela2)->r_offset);
d1679 23
d1708 7
a1714 1
#define PAGESIZE 0x1000
d1716 1
d1718 1
d1721 1
d1723 4
a1726 2
  Elf_Internal_Rela **rela_comb = NULL;
  int comb_curr, comb_count;
d1731 8
d1743 14
a1756 6
  /* We're only interested in text sections which overlap the
     troublesome area at the end of a page.  */
  if (link_info->mpc860c0 && (isec->flags & SEC_CODE) && isec->_cooked_size)
    {
      bfd_vma dot, end_page, end_section;
      bfd_boolean section_modified;
d1775 32
a1806 15
      comb_curr = 0;
      comb_count = 0;
      if (isec->reloc_count)
	{
	  unsigned n;
	  bfd_size_type amt;

	  /* Get a copy of the native relocations.  */
	  internal_relocs
	    = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL,
					 link_info->keep_memory);
	  if (internal_relocs == NULL)
	    goto error_return;
	  if (! link_info->keep_memory)
	    free_relocs = internal_relocs;
d1808 2
a1809 7
	  /* Setup a faster access method for the reloc info we need.  */
	  amt = isec->reloc_count;
	  amt *= sizeof (Elf_Internal_Rela*);
	  rela_comb = bfd_malloc (amt);
	  if (rela_comb == NULL)
	    goto error_return;
	  for (n = 0; n < isec->reloc_count; ++n)
d1811 32
a1842 1
	      enum elf_ppc_reloc_type r_type;
d1844 3
a1846 3
	      r_type = ELF32_R_TYPE (internal_relocs[n].r_info);
	      if (r_type >= R_PPC_max)
		goto error_return;
d1848 2
a1849 53
	      /* Prologue constants are sometimes present in the ".text"
		 sections and they can be identified by their associated
		 relocation.  We don't want to process those words and
		 some others which can also be identified by their
		 relocations.  However, not all conditional branches will
		 have a relocation so we will only ignore words that
		 1) have a reloc, and 2) the reloc is not applicable to a
		 conditional branch.  The array rela_comb is built here
		 for use in the EOP scan loop.  */
	      switch (r_type)
		{
		case R_PPC_ADDR14_BRNTAKEN:
		case R_PPC_REL14:
		case R_PPC_REL14_BRNTAKEN:
		  /* We should check the instruction.  */
		  break;
		default:
		  /* The word is not a conditional branch - ignore it.  */
		  rela_comb[comb_count++] = &internal_relocs[n];
		  break;
		}
	    }
	  if (comb_count > 1)
	    qsort (rela_comb, (size_t) comb_count, sizeof (int),
		   ppc_elf_sort_rela);
	}

      /* Enumerate each EOP region that overlaps this section.  */
      end_section = isec->vma + isec->_cooked_size;
      dot = end_page = (isec->vma | (PAGESIZE - 1)) + 1;
      dot -= link_info->mpc860c0;
      section_modified = FALSE;
      /* Increment the start position if this section begins in the
	 middle of its first EOP region.  */
      if (dot < isec->vma)
	dot = isec->vma;
      for (;
	   dot < end_section;
	   dot += PAGESIZE, end_page += PAGESIZE)
	{
	  /* Check each word in this EOP region.  */
	  for (; dot < end_page; dot += 4)
	    {
	      bfd_vma isec_offset;
	      unsigned long insn;
	      bfd_boolean skip, modified;

	      /* Don't process this word if there is a relocation for it
		 and the relocation indicates the word is not a
		 conditional branch.  */
	      skip = FALSE;
	      isec_offset = dot - isec->vma;
	      for (; comb_curr<comb_count; ++comb_curr)
a1850 1
		  bfd_vma r_offset;
d1852 2
a1853 2
		  r_offset = rela_comb[comb_curr]->r_offset;
		  if (r_offset >= isec_offset)
d1855 7
a1861 2
		      if (r_offset == isec_offset) skip = TRUE;
		      break;
d1863 17
d1881 38
a1918 1
	      if (skip) continue;
d1920 20
a1939 8
	      /* Check the current word for a problematic conditional
		 branch.  */
#define BO0(insn) ((insn) & 0x02000000)
#define BO2(insn) ((insn) & 0x00800000)
#define BO4(insn) ((insn) & 0x00200000)
	      insn = (unsigned long) bfd_get_32 (abfd, contents + isec_offset);
	      modified = FALSE;
	      if ((insn & 0xFc000000) == 0x40000000)
d1941 2
a1942 19
		  /* Instruction is BCx */
		  if ((!BO0(insn) || !BO2(insn)) && !BO4(insn))
		    {
		      bfd_vma target;

		      /* This branch is predicted as "normal".
			 If this is a forward branch, it is problematic.  */
		      target = insn & 0x0000Fffc;
		      target = (target ^ 0x8000) - 0x8000;
		      if ((insn & 0x00000002) == 0)
			/* Convert to abs.  */
			target += dot;
		      if (target > dot)
			{
			  /* Set the prediction bit.  */
			  insn |= 0x00200000;
			  modified = TRUE;
			}
		    }
d1944 1
a1944 1
	      else if ((insn & 0xFc00Fffe) == 0x4c000420)
d1946 2
a1947 10
		  /* Instruction is BCCTRx.  */
		  if ((!BO0(insn) || !BO2(insn)) && !BO4(insn))
		    {
		      /* This branch is predicted as not-taken.
			 If this is a forward branch, it is problematic.
			 Since we can't tell statically if it will branch
			 forward, always set the prediction bit.  */
		      insn |= 0x00200000;
		      modified = TRUE;
		    }
d1949 13
a1961 1
	      else if ((insn & 0xFc00Fffe) == 0x4c000020)
d1963 6
a1968 10
		  /* Instruction is BCLRx */
		  if ((!BO0(insn) || !BO2(insn)) && !BO4(insn))
		    {
		      /* This branch is predicted as not-taken.
			 If this is a forward branch, it is problematic.
			 Since we can't tell statically if it will branch
			 forward, always set the prediction bit.  */
		      insn |= 0x00200000;
		      modified = TRUE;
		    }
d1970 1
a1970 4
#undef BO0
#undef BO2
#undef BO4
	      if (modified)
d1972 4
a1975 2
		  bfd_put_32 (abfd, insn, contents + isec_offset);
		  section_modified = TRUE;
d1977 14
d1992 10
a2001 5
	}
      if (section_modified)
	{
	  elf_section_data (isec)->this_hdr.contents = contents;
	  free_contents = NULL;
d2005 2
a2006 1
  if (rela_comb != NULL)
d2008 3
a2010 2
      free (rela_comb);
      rela_comb = NULL;
d2012 2
a2013 2

  if (free_relocs != NULL)
d2015 7
a2021 2
      free (free_relocs);
      free_relocs = NULL;
d2024 2
a2025 1
  if (free_contents != NULL)
d2027 2
a2028 2
      if (! link_info->keep_memory)
	free (free_contents);
a2033 1
      free_contents = NULL;
d2036 12
d2051 8
a2058 6
  if (rela_comb != NULL)
    free (rela_comb);
  if (free_relocs != NULL)
    free (free_relocs);
  if (free_contents != NULL)
    free (free_contents);
d5507 73
@


1.94
log
@	* elf-bfd.h (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Use..
	(_bfd_elf_symbol_refs_local_p): ..this.  Declare.
	* elflink.c (_bfd_elf_symbol_refs_local_p): New function.
	* elf32-i386.c (elf_i386_relocate_section): Remove h NULL test
	now done in _bfd_elf_symbol_refs_local_p.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@d6019 29
d6107 1
@


1.93
log
@Set maxpagesize for NTO targets to 4k
@
text
@d5178 2
a5179 3
	  if (h == NULL
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
	      || SYMBOL_REFERENCES_LOCAL (info, h))
d5209 1
a5209 2
		   || (h != NULL
		       && !SYMBOL_CALLS_LOCAL (info, h))))
d5264 1
a5264 2
	      else if (h != NULL
		       && !SYMBOL_REFERENCES_LOCAL (info, h))
@


1.92
log
@	* elf-bfd.h (struct elf_obj_tdata): Move linker_section_pointers..
	* elf32-ppc.c (struct ppc_elf_obj_tdata): ..to here.  New.
	(ppc_elf_tdata): Define.
	(elf_local_ptr_offsets): Adjust.
	(ppc_elf_mkobject): New function.
	(bfd_elf32_mkobject): Define.
@
text
@d6029 3
d6033 1
@


1.91
log
@	* elf-bfd.h (struct elf_link_hash_entry): Remove linker_section_pointer
	field.
	(enum elf_linker_section_enum): Delete.
	(struct elf_linker_section): Delete.
	(struct elf_linker_section_pointers): Delete.
	(struct elf_obj_tdata): Remove #if 0 chunk.  Remove linker_section.
	Make linker_section_pointers a void**.
	(elf_local_ptr_offsets, elf_linker_section): Don't define.
	* elf32-ppc.c (enum elf_linker_section_enum): New, cut-down version
	of old item in elf-bfd.h.
	(struct elf_linker_section): Likewise.
	(struct elf_linker_section_pointers): Likewise.
	(elf_local_ptr_offsets): Define.
	(struct ppc_elf_link_hash_entry): Add linker_section_pointer.
	(ppc_elf_link_hash_newfunc): Init it.
	(struct ppc_elf_link_hash_table): Add sbss.
	(ppc_elf_link_hash_table_create): zmalloc rather than clearing
	individual fields.
	(elf_create_linker_section): Fold into..
	(ppc_elf_create_linker_section): ..here.  Remove hole_size code.
	Make rela section here if shared.
	(elf_find_pointer_linker_section): Pass lsect rather than enum.
	(elf_create_pointer_linker_section): Adjust.  zalloc rather than
	clearing in a loop.
	(elf_finish_pointer_linker_section): Adjust.  Don't make rela
	section here.
	(ppc_elf_check_relocs): Adjust.
	(ppc_elf_add_symbol_hook): Tighten hash creator test.  Remove code
	creating .sbss by hand.
	* elf.c (_bfd_elf_link_hash_newfunc): Adjust.
@
text
@d112 12
d125 13
a137 2
  ((elf_linker_section_pointers_t **) \
   (elf_tdata (bfd)->linker_section_pointers))
d6048 1
@


1.90
log
@bfd/
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add rel_fptr_sec.
	(elfNN_ia64_dynamic_symbol_p): Change info->shared into
	!info->executable.
	(get_fptr): For -pie create .opd as writable section and create
	.rela.opd as well.
	(elfNN_ia64_check_relocs): Change info->shared into
	!info->executable.
	(allocate_fptr): Likewise.
	(allocate_dynrel_entries): Account for a relative reloc for -pie
	@@fptr().  Don't account for a relative reloc if -pie want_ltoff_fptr
	for undefweak symbol.  Account for an IPLT reloc in .rela.opd
	section if -pie.
	(set_got_entry): Don't create a relative reloc if -pie
	want_ltoff_fptr for undefweak symbol.
	(set_fptr_entry): Emit an IPLT reloc in .rela.opd for -pie.
	(elfNN_ia64_relocate_section): Emit a relative reloc for -pie
	@@fptr().

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Issue undefined_symbol
	even if -pie.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
ld/
	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Don't include
	.opd if -pie.
	(OTHER_READWRITE_SECTIONS): Include .opd if -pie.
	* scripttempl/elf.sc: Use SHLIB_DATA_ADDR instead of DATA_ADDR
	if -pie.
@
text
@d73 43
d142 5
d183 1
d227 1
d242 1
a242 1
  ret = bfd_malloc (sizeof (struct ppc_elf_link_hash_table));
a252 15
  ret->got = NULL;
  ret->relgot = NULL;
  ret->plt = NULL;
  ret->relplt = NULL;
  ret->dynbss = NULL;
  ret->relbss = NULL;
  ret->dynsbss = NULL;
  ret->relsbss = NULL;
  ret->sdata = NULL;
  ret->sdata2 = NULL;
  ret->tls_sec = NULL;
  ret->tls_get_addr = NULL;
  ret->tlsld_got.refcount = 0;
  ret->sym_sec.abfd = NULL;

a2206 111
/* Create a special linker section, or return a pointer to a linker
   section already created */

static elf_linker_section_t *
elf_create_linker_section (bfd *abfd,
			   struct bfd_link_info *info,
			   enum elf_linker_section_enum which,
			   elf_linker_section_t *defaults)
{
  bfd *dynobj = elf_hash_table (info)->dynobj;
  elf_linker_section_t *lsect;

  /* Record the first bfd section that needs the special section */
  if (!dynobj)
    dynobj = elf_hash_table (info)->dynobj = abfd;

  /* If this is the first time, create the section */
  lsect = elf_linker_section (dynobj, which);
  if (!lsect)
    {
      asection *s;
      bfd_size_type amt = sizeof (elf_linker_section_t);

      lsect = bfd_alloc (dynobj, amt);

      *lsect = *defaults;
      elf_linker_section (dynobj, which) = lsect;
      lsect->which = which;
      lsect->hole_written_p = FALSE;

      /* See if the sections already exist */
      lsect->section = s = bfd_get_section_by_name (dynobj, lsect->name);
      if (!s || (s->flags & defaults->flags) != defaults->flags)
	{
	  lsect->section = s = bfd_make_section_anyway (dynobj, lsect->name);

	  if (s == NULL)
	    return NULL;

	  bfd_set_section_flags (dynobj, s, defaults->flags);
	  bfd_set_section_alignment (dynobj, s, lsect->alignment);
	}
      else if (bfd_get_section_alignment (dynobj, s) < lsect->alignment)
	bfd_set_section_alignment (dynobj, s, lsect->alignment);

      s->_raw_size = align_power (s->_raw_size, lsect->alignment);

      /* Is there a hole we have to provide?  If so check whether the
	 segment is too big already */
      if (lsect->hole_size)
	{
	  lsect->hole_offset = s->_raw_size;
	  s->_raw_size += lsect->hole_size;
	  if (lsect->hole_offset > lsect->max_hole_offset)
	    {
	      (*_bfd_error_handler)
		(_("%s: Section %s is too large to add hole of %ld bytes"),
		 bfd_get_filename (abfd),
		 lsect->name,
		 (long) lsect->hole_size);

	      bfd_set_error (bfd_error_bad_value);
	      return NULL;
	    }
	}

#ifdef DEBUG
      fprintf (stderr, "Creating section %s, current size = %ld\n",
	       lsect->name, (long) s->_raw_size);
#endif

      if (lsect->sym_name)
	{
	  struct elf_link_hash_entry *h;
	  struct bfd_link_hash_entry *bh;

#ifdef DEBUG
	  fprintf (stderr, "Adding %s to section %s\n",
		   lsect->sym_name,
		   lsect->name);
#endif
	  bh = bfd_link_hash_lookup (info->hash, lsect->sym_name,
				     FALSE, FALSE, FALSE);

	  if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	      && !(_bfd_generic_link_add_one_symbol
		   (info, abfd, lsect->sym_name, BSF_GLOBAL, s,
		    (lsect->hole_size
		     ? s->_raw_size - lsect->hole_size + lsect->sym_offset
		     : lsect->sym_offset),
		    NULL, FALSE,
		    get_elf_backend_data (abfd)->collect, &bh)))
	    return NULL;
	  h = (struct elf_link_hash_entry *) bh;

	  if ((defaults->which != LINKER_SECTION_SDATA)
	      && (defaults->which != LINKER_SECTION_SDATA2))
	    h->elf_link_hash_flags |= ELF_LINK_HASH_DEF_DYNAMIC;

	  h->type = STT_OBJECT;
	  lsect->sym_hash = h;

	  if (info->shared
	      && ! _bfd_elf_link_record_dynamic_symbol (info, h))
	    return NULL;
	}
    }

  return lsect;
}

d2213 1
a2213 1
   elf_linker_section_enum_t which)
d2216 1
a2216 1
    if (which == linker_pointers->which && addend == linker_pointers->addend)
d2241 2
d2244 2
a2245 1
      if (elf_find_pointer_linker_section (h->linker_section_pointer,
d2247 1
a2247 1
					   lsect->which))
d2250 1
a2250 1
      ptr_linker_section_ptr = &h->linker_section_pointer;
a2269 1
	  register unsigned int i;
d2273 1
a2273 1
	  ptr = bfd_alloc (abfd, amt);
a2278 2
	  for (i = 0; i < num_symbols; i++)
	    ptr[i] = NULL;
d2284 1
a2284 1
					   lsect->which))
d2310 1
a2310 1
  linker_section_ptr->which = lsect->which;
d2348 3
d2352 1
a2352 1
	= elf_find_pointer_linker_section (h->linker_section_pointer,
d2354 1
a2354 1
					   lsect->which);
d2390 1
a2390 1
			     lsect->which));
d2403 3
a2411 9
	      /* We need to generate a relative reloc for the dynamic
		 linker.  */
	      if (!srel)
		{
		  srel = bfd_get_section_by_name (elf_hash_table (info)->dynobj,
						  lsect->rel_name);
		  lsect->rel_section = srel;
		}

a2432 1
		- lsect->hole_offset
a2451 1
  bfd *dynobj = elf_hash_table (info)->dynobj;
d2453 43
d2497 2
a2498 26
  /* Record the first bfd section that needs the special section.  */
  if (!dynobj)
    dynobj = elf_hash_table (info)->dynobj = abfd;

  /* If this is the first time, create the section.  */
  lsect = elf_linker_section (dynobj, which);
  if (!lsect)
    {
      elf_linker_section_t defaults;
      static elf_linker_section_t zero_section;

      defaults = zero_section;
      defaults.which = which;
      defaults.hole_written_p = FALSE;
      defaults.alignment = 2;

      /* Both of these sections are (technically) created by the user
	 putting data in them, so they shouldn't be marked
	 SEC_LINKER_CREATED.

	 The linker creates them so it has somewhere to attach their
	 respective symbols. In fact, if they were empty it would
	 be OK to leave the symbol set to 0 (or any random number), because
	 the appropriate register should never be used.  */
      defaults.flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
			| SEC_IN_MEMORY);
d2500 34
a2533 6
      switch (which)
	{
	default:
	  (*_bfd_error_handler) (_("%s: unknown special linker type %d"),
				 bfd_get_filename (abfd),
				 (int) which);
d2535 6
a2540 2
	  bfd_set_error (bfd_error_bad_value);
	  return NULL;
d2542 2
a2543 7
	case LINKER_SECTION_SDATA:	/* .sdata/.sbss section */
	  defaults.name		  = ".sdata";
	  defaults.rel_name	  = ".rela.sdata";
	  defaults.bss_name	  = ".sbss";
	  defaults.sym_name	  = "_SDA_BASE_";
	  defaults.sym_offset	  = 32768;
	  break;
d2545 4
a2548 9
	case LINKER_SECTION_SDATA2:	/* .sdata2/.sbss2 section */
	  defaults.name		  = ".sdata2";
	  defaults.rel_name	  = ".rela.sdata2";
	  defaults.bss_name	  = ".sbss2";
	  defaults.sym_name	  = "_SDA2_BASE_";
	  defaults.sym_offset	  = 32768;
	  defaults.flags	 |= SEC_READONLY;
	  break;
	}
d2550 10
a2559 1
      lsect = elf_create_linker_section (abfd, info, which, &defaults);
d3431 2
a3432 4
      htab->sdata = elf_linker_section (abfd, LINKER_SECTION_SDATA);
      if (htab->sdata == NULL)
	htab->sdata = ppc_elf_create_linker_section (abfd, info,
						     LINKER_SECTION_SDATA);
d3439 2
a3440 4
      htab->sdata2 = elf_linker_section (abfd, LINKER_SECTION_SDATA2);
      if (htab->sdata2 == NULL)
	htab->sdata2 = ppc_elf_create_linker_section (abfd, info,
						      LINKER_SECTION_SDATA2);
d4240 2
a4241 1
      && info->hash->creator->flavour == bfd_target_elf_flavour)
d4244 2
a4245 3
	 put into .sdata.  */
      elf_linker_section_t *sdata
	= ppc_elf_create_linker_section (abfd, info, LINKER_SECTION_SDATA);
d4247 2
a4248 1
      if (!sdata->bss_section)
d4250 1
a4250 1
	  bfd_size_type amt;
d4252 3
a4254 17
	  /* We don't go through bfd_make_section, because we don't
	     want to attach this common section to DYNOBJ.  The linker
	     will move the symbols to the appropriate output section
	     when it defines common symbols.  */
	  amt = sizeof (asection);
	  sdata->bss_section = bfd_zalloc (abfd, amt);
	  if (sdata->bss_section == NULL)
	    return FALSE;
	  sdata->bss_section->name = sdata->bss_name;
	  sdata->bss_section->flags = SEC_IS_COMMON;
	  sdata->bss_section->output_section = sdata->bss_section;
	  amt = sizeof (asymbol);
	  sdata->bss_section->symbol = bfd_zalloc (abfd, amt);
	  amt = sizeof (asymbol *);
	  sdata->bss_section->symbol_ptr_ptr = bfd_zalloc (abfd, amt);
	  if (sdata->bss_section->symbol == NULL
	      || sdata->bss_section->symbol_ptr_ptr == NULL)
a4255 4
	  sdata->bss_section->symbol->name = sdata->bss_name;
	  sdata->bss_section->symbol->flags = BSF_SECTION_SYM;
	  sdata->bss_section->symbol->section = sdata->bss_section;
	  *sdata->bss_section->symbol_ptr_ptr = sdata->bss_section->symbol;
d4258 1
a4258 1
      *secp = sdata->bss_section;
@


1.89
log
@	* elf-bfd.h (_bfd_elf_create_linker_section) Don't declare.
	(_bfd_elf_find_pointer_linker_section): Likewise.
	(bfd_elf32_create_pointer_linker_section): Likewise.
	(bfd_elf32_finish_pointer_linker_section): Likewise.
	(bfd_elf64_create_pointer_linker_section): Likewise.
	(bfd_elf64_finish_pointer_linker_section): Likewise.
	(_bfd_elf_make_linker_section_rela): Likewise.
	* elfcode.h (elf_create_pointer_linker_section): Don't define.
	(elf_finish_pointer_linker_section): Likewise.
	* elflink.c (_bfd_elf_make_linker_section_rela): Delete.
	(_bfd_elf_create_linker_section): Move this function..
	(_bfd_elf_find_pointer_linker_section): ..and this..
	* elflink.h (elf_create_pointer_linker_section): ..and this..
	(elf_finish_pointer_linker_section): ..and this..
	* elf32-ppc.c: ..to here, renaming to the following, and adjusting
	calls.
	(elf_create_linker_section): Convert to C90, tidy.
	(elf_find_pointer_linker_section): Likewise.
	(elf_create_pointer_linker_section): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	* elf32-i370.c: Delete #if 0 code.
@
text
@d4631 1
a4631 1
	  else if (info->shared
@


1.88
log
@	* elf32-ppc.c (ppc_elf_howto_table): Remove unnecessary cast.
	(ppc_elf_reloc_type_lookup): Modify comment.
	(ppc_elf_info_to_howto): Ditto.
	(ppc_elf_relocate_section): Ditto.
	(ppc_elf_check_relocs): Call ppc_elf_howto_init.
@
text
@d2172 354
d2590 1
a2590 1
      lsect = _bfd_elf_create_linker_section (abfd, info, which, &defaults);
d2675 4
a2678 1
  if (!ppc_elf_create_got (abfd, info))
a2686 1
  htab = ppc_elf_hash_table (info);
d3579 2
a3580 2
	  if (!bfd_elf32_create_pointer_linker_section (abfd, info,
							htab->sdata, h, rel))
d3591 2
a3592 2
	  if (!bfd_elf32_create_pointer_linker_section (abfd, info,
							htab->sdata2, h, rel))
d5367 3
a5369 4
	    = bfd_elf32_finish_pointer_linker_section (output_bfd, input_bfd,
						       info, htab->sdata, h,
						       relocation, rel,
						       R_PPC_RELATIVE);
d5376 3
a5378 4
	    = bfd_elf32_finish_pointer_linker_section (output_bfd, input_bfd,
						       info, htab->sdata2, h,
						       relocation, rel,
						       R_PPC_RELATIVE);
@


1.87
log
@Correct spelling of "relocatable".
@
text
@d289 1
a289 1
static reloc_howto_type *ppc_elf_howto_table[(int) R_PPC_max];
d1833 1
a1834 1
    /* Initialize howto table if needed.  */
d1935 1
a1936 1
    /* Initialize howto table if needed.  */
d3097 4
a3102 1

d4207 1
a4208 1
    /* Initialize howto table if needed.  */
@


1.86
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Report plt reloc against
	local sym errors.
@
text
@d3088 1
a3088 1
  if (info->relocateable)
d3719 1
a3719 1
  if (info->relocateable || info->shared)
d3914 1
a3914 1
      && !info->relocateable
d4151 1
a4151 1
   relocateable output file) adjusting the reloc addend as
d4165 1
a4165 1
   When generating relocateable output, this function must handle
d4198 1
a4198 1
	   (info->relocateable) ? " (relocatable)" : "");
d4201 1
a4201 1
  if (info->relocateable)
@


1.85
log
@	* elf32-i386.c: Convert to C90 function definitions, remove unnecessary
	prototypes and casts.  Replace PTR with void *.  Formatting.
	* elf32-ppc.c: Likewise.  Break long strings too.
	(ppc_elf_relax_section): Use enum elf_ppc_reloc_type for r_type.
	(ppc_elf_unhandled_reloc): Internationalize error message.
	* elf32-ppc.h: Remove PARAMS.
@
text
@d3272 6
@


1.84
log
@	* elf32-ppc.c (ppc_elf_begin_write_processing): Use bytes to count
	APUinfo slots.
	(ppc_elf_final_write_processing): Likewise.
@
text
@a37 18
static struct bfd_hash_entry *ppc_elf_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *entry, struct bfd_hash_table *table,
	   const char *string));
static struct bfd_link_hash_table *ppc_elf_link_hash_table_create
  PARAMS ((bfd *abfd));
static void ppc_elf_copy_indirect_symbol
  PARAMS ((struct elf_backend_data *bed, struct elf_link_hash_entry *dir,
	   struct elf_link_hash_entry *ind));
static reloc_howto_type *ppc_elf_reloc_type_lookup
  PARAMS ((bfd *abfd, bfd_reloc_code_real_type code));
static void ppc_elf_info_to_howto
  PARAMS ((bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst));
static void ppc_elf_howto_init
  PARAMS ((void));
static int ppc_elf_sort_rela
  PARAMS ((const PTR, const PTR));
static bfd_boolean ppc_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
d39 1
a39 1
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d41 1
a41 61
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_boolean ppc_elf_object_p
  PARAMS ((bfd *));
static bfd_boolean ppc_elf_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean ppc_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static int ppc_elf_additional_program_headers
  PARAMS ((bfd *));
static bfd_boolean ppc_elf_modify_segment_map
  PARAMS ((bfd *));
static bfd_boolean ppc_elf_create_got
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean ppc_elf_create_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean ppc_elf_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
static bfd_boolean ppc_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
static elf_linker_section_t *ppc_elf_create_linker_section
  PARAMS ((bfd *abfd, struct bfd_link_info *info,
	   enum elf_linker_section_enum));
static bfd_boolean update_local_sym_info
  PARAMS ((bfd *, Elf_Internal_Shdr *, unsigned long, int));
static void bad_shared_reloc
  PARAMS ((bfd *, enum elf_ppc_reloc_type));
static bfd_boolean ppc_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static asection *ppc_elf_gc_mark_hook
  PARAMS ((asection *sec, struct bfd_link_info *info, Elf_Internal_Rela *rel,
	   struct elf_link_hash_entry *h, Elf_Internal_Sym *sym));
static bfd_boolean ppc_elf_gc_sweep_hook
  PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *sec,
	   const Elf_Internal_Rela *relocs));
static bfd_boolean ppc_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean ppc_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean ppc_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *info, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms,
	   asection **));
static bfd_boolean ppc_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
static bfd_boolean ppc_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean ppc_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static enum elf_reloc_type_class ppc_elf_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean ppc_elf_grok_prstatus
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
static bfd_boolean ppc_elf_grok_psinfo
  PARAMS ((bfd *abfd, Elf_Internal_Note *note));
d160 3
a162 4
ppc_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d188 1
a188 2
ppc_elf_link_hash_table_create (abfd)
     bfd *abfd;
d192 1
a192 2
  ret = ((struct ppc_elf_link_hash_table *)
	 bfd_malloc (sizeof (struct ppc_elf_link_hash_table)));
d230 3
a232 3
ppc_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
d1528 1
a1528 1
ppc_elf_howto_init ()
d1569 1
a1569 3
ppc_elf_sort_rela (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d1571 2
a1572 2
  const Elf_Internal_Rela **rela1 = (const Elf_Internal_Rela**) arg1;
  const Elf_Internal_Rela **rela2 = (const Elf_Internal_Rela**) arg2;
d1579 4
a1582 5
ppc_elf_relax_section (abfd, isec, link_info, again)
     bfd *abfd;
     asection *isec;
     struct bfd_link_info *link_info;
     bfd_boolean *again;
d1614 1
a1614 1
	  contents = (bfd_byte *) bfd_malloc (isec->_raw_size);
d1633 1
a1633 2
	    = _bfd_elf_link_read_relocs (abfd, isec, (PTR) NULL,
					 (Elf_Internal_Rela *) NULL,
d1643 1
a1643 1
	  rela_comb = (Elf_Internal_Rela**) bfd_malloc (amt);
d1648 1
a1648 1
	      long r_type;
d1651 1
a1651 1
	      if (r_type < 0 || r_type >= (int) R_PPC_max)
d1779 1
a1779 1
		  bfd_put_32 (abfd, (bfd_vma) insn, contents + isec_offset);
d1828 2
a1829 3
ppc_elf_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1837 1
a1837 1
  switch ((int) code)
d1840 1
a1840 1
      return (reloc_howto_type *) NULL;
d1925 1
a1925 1
  return ppc_elf_howto_table[(int) r];
d1931 3
a1933 4
ppc_elf_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d1946 7
a1952 9
ppc_elf_addr16_ha_reloc (abfd, reloc_entry, symbol, data, input_section,
			 output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1980 7
a1986 9
ppc_elf_unhandled_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
d1998 1
a1998 1
      sprintf (buf, "generic linker can't handle %s",
d2009 1
a2009 2
ppc_elf_object_p (abfd)
     bfd *abfd;
d2028 1
a2028 3
ppc_elf_set_private_flags (abfd, flags)
     bfd *abfd;
     flagword flags;
d2042 1
a2042 3
ppc_elf_merge_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d2080 2
a2081 1
	    (_("%s: compiled with -mrelocatable and linked with modules compiled normally"),
d2089 2
a2090 1
	    (_("%s: compiled normally and linked with modules compiled with -mrelocatable"),
d2117 2
a2118 1
	    (_("%s: uses different e_flags (0x%lx) fields than previous modules (0x%lx)"),
d2136 1
a2136 4
ppc_elf_section_from_shdr (abfd, hdr, name)
     bfd *abfd;
     Elf_Internal_Shdr *hdr;
     const char *name;
d2159 3
a2161 4
ppc_elf_fake_sections (abfd, shdr, asect)
     bfd *abfd ATTRIBUTE_UNUSED;
     Elf_Internal_Shdr *shdr;
     asection *asect;
d2174 3
a2176 4
ppc_elf_create_linker_section (abfd, info, which)
     bfd *abfd;
     struct bfd_link_info *info;
     enum elf_linker_section_enum which;
d2216 1
a2216 1
	  return (elf_linker_section_t *) 0;
d2246 1
a2246 2
ppc_elf_additional_program_headers (abfd)
     bfd *abfd;
d2271 1
a2271 2
ppc_elf_modify_segment_map (abfd)
     bfd *abfd ATTRIBUTE_UNUSED;
d2279 1
a2279 3
ppc_elf_create_got (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2315 1
a2315 3
ppc_elf_create_dynamic_sections (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d2363 2
a2364 3
ppc_elf_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d2553 1
a2553 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d2555 1
a2555 1
  struct bfd_link_info *info = (struct bfd_link_info *) inf;
d2700 1
a2700 1
	 then they should avoid writing weird assembly.  */ 
d2765 1
a2765 3
readonly_dynrelocs (h, info)
     struct elf_link_hash_entry *h;
     PTR info;
d2795 2
a2796 3
ppc_elf_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d2980 1
a2980 1
      s->contents = (bfd_byte *) bfd_zalloc (htab->elf.dynobj, s->_raw_size);
d2993 1
a2993 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
d3022 1
a3022 1
				(PTR) info);
d3036 4
a3039 5
update_local_sym_info (abfd, symtab_hdr, r_symndx, tls_type)
     bfd *abfd;
     Elf_Internal_Shdr *symtab_hdr;
     unsigned long r_symndx;
     int tls_type;
d3049 1
a3049 1
      local_got_refcounts = (bfd_signed_vma *) bfd_zalloc (abfd, size);
d3062 1
a3062 3
bad_shared_reloc (abfd, r_type)
     bfd *abfd;
     enum elf_ppc_reloc_type r_type;
d3067 1
a3067 1
     ppc_elf_howto_table[(int) r_type]->name);
d3076 4
a3079 5
ppc_elf_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d3153 1
a3153 1
      r_type = (enum elf_ppc_reloc_type) ELF32_R_TYPE (rel->r_info);
d3429 3
a3431 1
	      fprintf (stderr, "ppc_elf_check_relocs need to create relocation for %s\n",
d3495 1
a3495 2
		  p = ((struct ppc_elf_dyn_relocs *)
		       bfd_alloc (htab->elf.dynobj, sizeof *p));
d3521 5
a3525 6
ppc_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d3560 4
a3563 5
ppc_elf_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d3603 1
a3603 1
      r_type = (enum elf_ppc_reloc_type) ELF32_R_TYPE (rel->r_info);
d3684 1
a3684 3
ppc_elf_tls_setup (obfd, info)
     bfd *obfd;
     struct bfd_link_info *info;
d3706 2
a3707 3
ppc_elf_tls_optimize (obfd, info)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d3729 1
a3729 2
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, (PTR) NULL,
						  (Elf_Internal_Rela *) NULL,
d3762 1
a3762 1
		r_type = (enum elf_ppc_reloc_type) ELF32_R_TYPE (rel->r_info);
d3899 7
a3905 8
ppc_elf_add_symbol_hook (abfd, info, sym, namep, flagsp, secp, valp)
     bfd *abfd;
     struct bfd_link_info *info;
     const Elf_Internal_Sym *sym;
     const char **namep ATTRIBUTE_UNUSED;
     flagword *flagsp ATTRIBUTE_UNUSED;
     asection **secp;
     bfd_vma *valp;
d3926 1
a3926 1
	  sdata->bss_section = (asection *) bfd_zalloc (abfd, amt);
d3933 1
a3933 1
	  sdata->bss_section->symbol = (asymbol *) bfd_zalloc (abfd, amt);
d3935 1
a3935 2
	  sdata->bss_section->symbol_ptr_ptr =
	    (asymbol **) bfd_zalloc (abfd, amt);
d3956 4
a3959 5
ppc_elf_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d4064 2
a4065 3
ppc_elf_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d4121 1
a4121 1
      bfd_put_32 (output_bfd, (bfd_vma) 0x4e800021 /* blrl */, contents);
d4124 1
a4124 1
	bfd_put_32 (output_bfd, (bfd_vma) 0, contents + 4);
d4166 8
a4173 10
ppc_elf_relocate_section (output_bfd, info, input_bfd, input_section,
			  contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d4187 2
a4188 1
  fprintf (stderr, "ppc_elf_relocate_section called for %s section %s, %ld relocations%s\n",
d4225 4
a4228 4
      r_type = (enum elf_ppc_reloc_type)ELF32_R_TYPE (rel->r_info);
      sym = (Elf_Internal_Sym *) 0;
      sec = (asection *) 0;
      h = (struct elf_link_hash_entry *) 0;
d4421 1
a4421 2
		  r_type2
		    = (enum elf_ppc_reloc_type) ELF32_R_TYPE (rel[1].r_info);
d4520 2
a4521 2
      if ((unsigned) r_type < (unsigned) R_PPC_max)
	howto = ppc_elf_howto_table[(int) r_type];
d4888 2
a4889 1
	      fprintf (stderr, "ppc_elf_relocate_section need to create relocation for %s\n",
d4968 3
a4970 5
			    {
			      printf ("indx=%d section=%s flags=%08x name=%s\n",
				      indx, osec->name, osec->flags,
				      h->root.root.string);
			    }
d5023 1
a5023 1
	  BFD_ASSERT (sec != (asection *) 0);
d5057 1
a5057 1
	    BFD_ASSERT (sec != (asection *) 0);
d5064 7
a5070 5
		(*_bfd_error_handler) (_("%s: the target (%s) of a %s relocation is in the wrong output section (%s)"),
				       bfd_archive_filename (input_bfd),
				       sym_name,
				       howto->name,
				       name);
d5085 1
a5085 1
	    BFD_ASSERT (sec != (asection *) 0);
d5090 7
a5096 5
		(*_bfd_error_handler) (_("%s: the target (%s) of a %s relocation is in the wrong output section (%s)"),
				       bfd_archive_filename (input_bfd),
				       sym_name,
				       howto->name,
				       name);
d5117 1
a5117 1
	    BFD_ASSERT (sec != (asection *) 0);
d5149 7
a5155 5
		(*_bfd_error_handler) (_("%s: the target (%s) of a %s relocation is in the wrong output section (%s)"),
				       bfd_archive_filename (input_bfd),
				       sym_name,
				       howto->name,
				       name);
d5176 1
a5176 1
	  BFD_ASSERT (sec != (asection *) 0);
d5245 2
a5246 1
      fprintf (stderr, "\ttype = %s (%d), name = %s, symbol index = %ld, offset = %ld, addend = %ld\n",
d5327 1
a5327 2
ppc_elf_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d5329 1
a5329 1
  switch ((int) ELF32_R_TYPE (rela->r_info))
d5347 1
a5347 3
ppc_elf_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d5377 1
a5377 3
ppc_elf_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d5414 1
a5414 14
static apuinfo_list * head;

static void apuinfo_list_init PARAMS ((void));
static void apuinfo_list_add PARAMS ((unsigned long));
static unsigned apuinfo_list_length PARAMS ((void));
static unsigned long apuinfo_list_element PARAMS ((unsigned long));
static void apuinfo_list_finish PARAMS ((void));

extern void ppc_elf_begin_write_processing
  PARAMS ((bfd *, struct bfd_link_info *));
extern void ppc_elf_final_write_processing
  PARAMS ((bfd *, bfd_boolean));
extern bfd_boolean ppc_elf_write_section
  PARAMS ((bfd *, asection *, bfd_byte *));
d5418 1
a5418 1
apuinfo_list_init PARAMS ((void))
d5424 1
a5424 2
apuinfo_list_add (value)
     unsigned long value;
d5445 1
a5445 1
apuinfo_list_length PARAMS ((void))
d5459 1
a5459 2
apuinfo_list_element (number)
     unsigned long number;
d5472 1
a5472 1
apuinfo_list_finish PARAMS ((void))
d5492 2
a5493 4
void
ppc_elf_begin_write_processing (abfd, link_info)
     bfd *abfd;
     struct bfd_link_info *link_info;
d5624 4
a5627 5
bfd_boolean
ppc_elf_write_section (abfd, asec, contents)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *asec;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d5636 2
a5637 4
void
ppc_elf_final_write_processing (abfd, linker)
     bfd *abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
@


1.83
log
@	* elf32-ppc.c (allocate_dynrelocs): Use single slot for first 8192
	plt entries, not just 8191.
@
text
@d5724 1
a5724 1
      /* Get the number of apuinfo entries.  */
d5726 1
a5726 1
      if ((datum * 4 + 20) != length)
d5734 2
a5735 2
      for (i = 0; i < datum; i++)
	apuinfo_list_add (bfd_get_32 (ibfd, ptr + 20 + (i * 4)));
d5811 1
a5811 1
  bfd_put_32 (abfd, num_entries, buffer + 4);
@


1.82
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d2722 1
a2722 1
	      >= PLT_NUM_SINGLE_ENTRIES)
@


1.81
log
@	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL
	to trim plt entries.  Move undefweak non-default visibility test..
	(allocate_dynrelocs): ..from here.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Don't test
	dynamic_sections_created here.  Update comment.  Move undefweak
	non-default visibility test..
	(allocate_dynrelocs): ..from here.  Fix comment.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL
	to trim plt entries.  Move undefweak non-default visibility test..
	(allocate_dynrelocs): ..from here.  Fix comment.
	* elflink.h (elf_link_output_extsym): Compare ELF_ST_VISIBILITY with
	STV_DEFAULT rather than comparing with zero.
	* elflink.c (_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.  Format comment.
@
text
@d2923 1
a2923 1
      if (! info->shared)
d3105 1
a3105 1
      if (!info->shared)
@


1.80
log
@	* elf32-i386.c (allocate_dynrelocs): Use SYMBOL_CALLS_LOCAL.
	(elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (allocate_dynrelocs): Likewise.
	(ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (allocate_dynrelocs): Likewise.
	(ppc64_elf_relocate_section): Likewise.
@
text
@d2498 1
a2498 1
      if (! htab->elf.dynamic_sections_created
d2500 2
a2501 1
	  || h->plt.refcount <= 0)
d2505 3
a2507 2
	  1. We are not using ld.so; because then the PLT entry
	  can't be set up, so we can't use one.
d2509 1
a2509 2
	  2. We know for certain that a call to this symbol
	  will go to this object.
d2511 2
a2512 1
	  3. GC has rendered the entry unused.  */
d2678 1
a2678 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d2802 6
a2807 6
      /* Relocs that use pc_count are those that appear on a call
	 insn, or certain REL relocs (see MUST_BE_DYN_RELOC) that can
	 generated via assembly.  We want calls to protected symbols
	 to resolve directly to the function rather than going via the
	 plt.  If people want function pointer comparisons to work as
	 expected then they should avoid writing weird assembly.  */
@


1.79
log
@	* elf-bfd.h (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Move from
	elf32-ppc.c.  Add ELF_LINK_FORCED_LOCAL check.
	* elf32-ppc.c: (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Delete.
	(allocate_dynrelocs): Use SYMBOL_REFERENCES_LOCAL for dynreloc check.
	(ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (allocate_dynrelocs): Likewise.
	(ppc64_elf_relocate_section): Likewise.  Use for .got relocs too.
	(ppc64_elf_adjust_dynamic_symbol): Don't assume symbols with .plt
	relocs need no other types.
	* elf32-i386.c (allocate_dynrelocs): Use SYMBOL_REFERENCES_LOCAL for
	dynreloc check.
	(elf_i386_relocate_section): Likewise.  Use for .got relocs too.
	(elf_i386_finish_dynamic_symbol): Use SYMBOL_REFERENCES_LOCAL for
	.got relocs.
@
text
@d2802 7
a2808 1
      if (SYMBOL_REFERENCES_LOCAL (info, h))
d5000 1
a5000 1
		       && !SYMBOL_REFERENCES_LOCAL (info, h))))
@


1.78
log
@	* elflink.c (_bfd_elf_link_create_dynamic_sections): Move from
	elflink.h.  Replace LOG_FILE_ALIGN with bed->s->log_file_align.
	(_bfd_elf_create_dynamic_sections): Use bed->s->log_file_align.
	(bfd_elf_record_link_assignment): Move from elflink.h.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_add_default_symbol): Likewise.
	(_bfd_elf_export_symbol): Likewise.
	(_bfd_elf_link_find_version_dependencies): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	(_bfd_elf_link_read_relocs): Likewise.
	(_bfd_elf_link_size_reloc_section): Likewise.
	(_bfd_elf_fix_symbol_flags): Likewise.
	(_bfd_elf_adjust_dynamic_symbol): Likewise.
	(_bfd_elf_link_sec_merge_syms): Likewise.
	(elf_link_read_relocs_from_section): Likewise.  Use bed->s->sizeof_rel
	and bed->s->sizeof_rela.
	(_bfd_elf_link_output_relocs): Likewise.
	* elf-bfd.h (struct elf_size_info): Rename file_align to
	log_file_align.
	(struct elf_info_failed): Move from elflink.h.
	(struct elf_assign_sym_version_info): Likewise.
	(struct elf_find_verdep_info): Likewise.
	(_bfd_elf_create_dynamic_sections): Delete duplicate declaration.
	(_bfd_elf_merge_symbol, _bfd_elf_add_default_symbol,
	_bfd_elf_export_symbol, _bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version,
	_bfd_elf_link_create_dynamic_sections, _bfd_elf_link_read_relocs,
	_bfd_elf_link_size_reloc_section, _bfd_elf_link_output_relocs,
	_bfd_elf_fix_symbol_flags, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms): Declare.
	(bfd_elf32_link_create_dynamic_sections): Don't declare.
	(_bfd_elf32_link_read_relocs): Likewise.
	(bfd_elf64_link_create_dynamic_sections): Likewise.
	(_bfd_elf64_link_read_relocs): Likewise.
	* elflink.h: Move lots o' stuff elsewhere.
	* bfd-in.h (bfd_elf32_record_link_assignment): Don't declare.
	(bfd_elf64_record_link_assignment): Likewise.
	(bfd_elf_record_link_assignment): Declare.
	* bfd-in2.h: Regenerate.
	* elfcode.h (elf_link_create_dynamic_sections): Don't declare.
	(NAME(_bfd_elf,size_info)): Adjust for log_file_align.
	* elf.c (_bfd_elf_init_reloc_shdr): Adjust for bed->s->log_file_align.
	(assign_file_positions_for_segments): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(swap_out_syms, elfcore_write_note): Likewise.
	* elf-m10200.c: Adjust for changed function names.
	* elf-m10300.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	(MIPS_ELF_LOG_FILE_ALIGN): Use log_file_align.
	* elf64-alpha.c (alpha_elf_size_info): Adjust for log_file_align.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-mips.c (mips_elf64_size_info): Likewise.
	* elf64-s390.c (s390_elf64_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@a149 21
/* Will references to this symbol always reference the symbol
   in this object?  STV_PROTECTED is excluded from the visibility test
   here so that function pointer comparisons work properly.  Since
   function symbols not defined in an app are set to their .plt entry,
   it's necessary for shared libs to also reference the .plt even
   though the symbol is really local to the shared lib.  */
#define SYMBOL_REFERENCES_LOCAL(INFO, H)				\
  ((! INFO->shared							\
    || INFO->symbolic							\
    || H->dynindx == -1							\
    || ELF_ST_VISIBILITY (H->other) == STV_INTERNAL			\
    || ELF_ST_VISIBILITY (H->other) == STV_HIDDEN)			\
   && (H->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)

/* Will _calls_ to this symbol always call the version in this object?  */
#define SYMBOL_CALLS_LOCAL(INFO, H)					\
  ((! INFO->shared							\
    || INFO->symbolic							\
    || H->dynindx == -1							\
    || ELF_ST_VISIBILITY (H->other) != STV_DEFAULT)			\
   && (H->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0)
d2799 1
d2802 1
a2802 3
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
d4994 1
a4994 4
		       && h->dynindx != -1
		       && (!info->symbolic
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
@


1.77
log
@	* elf32-i386.c (allocate_dynrelocs): For undef weak syms with
	non-default visibility, a) don't make them dynamic, b) discard
	space for dynamic relocs.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.

	* elf32-ppc.c (allocate_dynrelocs): For undef weak syms with
	non-default visibility, a) don't allocate plt entries, b) don't
	allocate .got relocs, c) discard dyn rel space,
	(ppc_elf_relocate_section): d) don't generate .got relocs, e)
	don't generate dynamic relocs.
	* elf64-ppc.c (allocate_dynrelocs): As above.
	(ppc64_elf_relocate_section): As above.
@
text
@d1738 3
a1740 3
	    = _bfd_elf32_link_read_relocs (abfd, isec, (PTR) NULL,
					   (Elf_Internal_Rela *) NULL,
					   link_info->keep_memory);
d3863 3
a3865 3
	    relstart = _bfd_elf32_link_read_relocs (ibfd, sec, (PTR) NULL,
						    (Elf_Internal_Rela *) NULL,
						    info->keep_memory);
@


1.76
log
@	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Test whether the
	weakdef sym has already been adjusted before treating it specially.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Don't copy
	ELF_LINK_NON_GOT_REF for weakdefs when symbol already adjusted.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	(ppc64_elf_check_relocs): Set ELF_LINK_NON_GOT_REF.
@
text
@d2697 3
a2699 1
      && h->plt.refcount > 0)
d2794 4
a2797 2
	  if (info->shared
	      || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, &eh->elf))
d2838 6
d4806 4
a4809 1
		    if (info->shared || indx != 0)
d5011 3
@


1.75
log
@	* elf32-ppc.c: Formatting and comment fixes.
	(ELIMINATE_COPY_RELOCS): Move before ppc_elf_copy_indirect_symbol.
	(ppc_elf_copy_indirect_symbol): Copy flags here for weakdefs.
@
text
@d377 3
a379 1
  if (ELIMINATE_COPY_RELOCS && ind->root.type != bfd_link_hash_indirect)
@


1.75.2.1
log
@	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Test whether the
	weakdef sym has already been adjusted before treating it specially.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Don't copy
	ELF_LINK_NON_GOT_REF for weakdefs when symbol already adjusted.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	(ppc64_elf_check_relocs): Set ELF_LINK_NON_GOT_REF.
@
text
@d377 1
a377 3
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
@


1.75.2.2
log
@	* elf32-ppc.c (allocate_dynrelocs): Use single slot for first 8192
	plt entries, not just 8191.
@
text
@d2741 1
a2741 1
	      > PLT_NUM_SINGLE_ENTRIES)
@


1.74
log
@	* elf32-ppc.c (SYMBOL_REFERENCES_LOCAL): Expand comment.
@
text
@d19 3
a21 2
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d156 1
a156 1
#define SYMBOL_REFERENCES_LOCAL(INFO, H) 				\
d165 1
a165 1
#define SYMBOL_CALLS_LOCAL(INFO, H)				\
d202 1
a202 1
     TLS_GD .. TLS_EXPLICIT bits are or'd into the mask as the
d323 6
d377 10
a386 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1632 3
a1634 1
  for (i = 0; i < sizeof (ppc_elf_howto_raw) / sizeof (ppc_elf_howto_raw[0]); i++)
d1637 3
a1639 1
      BFD_ASSERT (type < sizeof (ppc_elf_howto_table) / sizeof (ppc_elf_howto_table[0]));
d1653 2
a1654 1
      (The EOP limit is 5 by default but may be specified as any value from 1-10.)
a2478 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d2518 1
a2518 1
 	  || SYMBOL_CALLS_LOCAL (info, h)
@


1.74.6.1
log
@Merge from mainline.
@
text
@d19 2
a20 3
   along with this program; if not, write to the
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d155 1
a155 1
#define SYMBOL_REFERENCES_LOCAL(INFO, H)				\
d164 1
a164 1
#define SYMBOL_CALLS_LOCAL(INFO, H)					\
d201 1
a201 1
     TLS_GD .. TLS_TLS bits are or'd into the mask as the
a321 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d370 1
a370 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1616 1
a1616 3
  for (i = 0;
       i < sizeof (ppc_elf_howto_raw) / sizeof (ppc_elf_howto_raw[0]);
       i++)
d1619 1
a1619 3
      if (type >= (sizeof (ppc_elf_howto_table)
		   / sizeof (ppc_elf_howto_table[0])))
	abort ();
d1633 1
a1633 2
      (The EOP limit is 5 by default but may be specified as any value
      from 1-10.)
d2458 6
d2503 1
a2503 1
	  || SYMBOL_CALLS_LOCAL (info, h)
@


1.74.6.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d150 21
d1738 3
a1740 3
	    = _bfd_elf_link_read_relocs (abfd, isec, (PTR) NULL,
					 (Elf_Internal_Rela *) NULL,
					 link_info->keep_memory);
d2519 1
a2519 1
      if (h->plt.refcount <= 0
d2521 1
a2521 2
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d2525 2
a2526 3
	     1. We are not using ld.so; because then the PLT entry
	     can't be set up, so we can't use one.  In this case,
	     ppc_elf_adjust_dynamic_symbol won't even be called.
d2528 2
a2529 1
	     2. GC has rendered the entry unused.
d2531 1
a2531 2
	     3. We know for certain that a call to this symbol
	     will go to this object, or will remain undefined.  */
d2792 2
a2793 4
	  if ((info->shared
	       || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, &eh->elf))
	      && (ELF_ST_VISIBILITY (eh->elf.other) == STV_DEFAULT
		  || eh->elf.root.type != bfd_link_hash_undefweak))
a2815 1

d2818 3
a2820 7
      /* Relocs that use pc_count are those that appear on a call insn,
	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be
	 generated via assembly.  We want calls to protected symbols to
	 resolve directly to the function rather than going via the plt.
	 If people want function pointer comparisons to work as expected
	 then they should avoid writing weird assembly.  */ 
      if (SYMBOL_CALLS_LOCAL (info, h))
a2833 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d3853 3
a3855 3
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, (PTR) NULL,
						  (Elf_Internal_Rela *) NULL,
						  info->keep_memory);
d4796 1
a4796 4
		    if ((info->shared || indx != 0)
			&& (h == NULL
			    || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			    || h->root.type != bfd_link_hash_undefweak))
a4997 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d5000 4
a5003 1
		       && !SYMBOL_CALLS_LOCAL (info, h))))
@


1.73
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Don't use SYMBOL_REFERENCES_LOCAL
	here as it's too early to reliably determine locality.
	(ppc_elf_gc_sweep_hook): Likewise.
@
text
@d150 6
a155 2
   in this object?  */
#define SYMBOL_REFERENCES_LOCAL(INFO, H)				\
@


1.72
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Subtract tls seg vma from
	zero index dynamic tls relocs generated for the GOT.  Tidy code.
	Set "relocation" to 1 on DTPMOD32 relocs.  Optimize HA adjustment.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.

	* ld-powerpc/tlsso.r: Adjust for corrected zero symbol index relocs.
	* ld-powerpc/tlsso32.r: Likewise.
@
text
@d3462 1
a3462 2
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
	      || SYMBOL_REFERENCES_LOCAL (info, h))
d3747 1
a3747 2
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
	      || SYMBOL_REFERENCES_LOCAL (info, h))
@


1.71
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Don't look for a nop after
	a tls_get_addr call.
@
text
@d4782 1
a4785 1
			    outrel.r_addend = 0;
d4793 1
a4795 1
				outrel.r_offset += 4;
a4805 1
			outrel.r_addend = 0;
d4807 5
a4811 1
			  outrel.r_addend += relocation;
d4939 5
a4969 1
	case R_PPC_DTPMOD32:
d5342 3
a5344 2
	    /* Add 0x10000 if sign bit in 0:15 is set.  */
	    addend += ((relocation + addend) & 0x8000) << 1;
@


1.71.2.1
log
@2003-03-16  Mark Kettenis  <kettenis@@gnu.org>

	Merge with mainline.  Tag is kettenis-i386newframe-20030316-mergepoint.
@
text
@a4781 1
			outrel.r_addend = 0;
d4785 1
a4792 1
				outrel.r_offset += 4;
d4795 1
d4806 1
d4808 1
a4808 5
			  {
			    outrel.r_addend += relocation;
			    if (tls_ty & (TLS_GD | TLS_DTPREL | TLS_TPREL))
			      outrel.r_addend -= htab->tls_sec->vma;
			  }
a4935 5
	case R_PPC_DTPMOD32:
	  relocation = 1;
	  addend = 0;
	  goto dodyn;

d4962 1
d5335 2
a5336 3
	    /* Add 0x10000 if sign bit in 0:15 is set.
	       Bits 0:15 are not used.  */
	    addend += 0x8000;
@


1.70
log
@	* elf32-ppc.c (ELIMINATE_COPY_RELOCS): Define as one.
	(ppc_elf_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	* elf64-ppc.c (ELIMINATE_COPY_RELOCS): Define as one.
	(ppc64_elf_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	* elf32-i386.c (ELIMINATE_COPY_RELOCS): Define as one.  Use throughout.
	(elf_i386_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
@
text
@d4527 1
a4527 1
		  bfd_vma insn1, insn2, insn3;
a4553 2
		  insn3 = bfd_get_32 (output_bfd,
				      contents + offset + 4);
a4582 7
		  if (insn3 == NOP
		      || insn3 == CROR_151515 || insn3 == CROR_313131)
		    {
		      insn3 = insn2;
		      insn2 = NOP;
		      rel[1].r_offset += 4;
		    }
a4584 1
		  bfd_put_32 (output_bfd, insn3, contents + offset + 4);
@


1.69
log
@	* elf32-ppc.c (ppc_elf_create_linker_section): Don't capitalize
	error messages.
	(ELIMINATE_COPY_RELOCS): Define to zero.
	(ppc_elf_relocate_section): Don't deref htab->tls_sec when calculating
	TLSLD relocs.  Report reloc types on a number of errors.  Optimize
	LOCAL24PC check for non-local syms.  Don't capitalize error messages.
	* elf64-ppc.c (ELIMINATE_COPY_RELOCS): Define to zero.
	(ppc64_elf_relocate_section): Don't deref htab->tls_sec when
	calculating TLSLD relocs.  Report reloc types on a number of errors.
	Don't capitalize error messages.
@
text
@d2458 1
a2458 1
#define ELIMINATE_COPY_RELOCS 0
d2528 4
@


1.68
log
@	* elf32-ppc.c: Formatting.
	(allocate_dynrelocs): LD and GD relocs against the same sym need
	separate GOT entries.
	(ppc_elf_relocate_section): Correct GOT handling for multiple GOT
	entries per symbol.
@
text
@d2303 1
a2303 1
	  (*_bfd_error_handler) (_("%s: Unknown special linker type %d"),
d2458 1
a2458 1
#define ELIMINATE_COPY_RELOCS 1
d4827 3
a4829 2
			if ((tls_ty & (TLS_GD | TLS_TPREL | TLS_DTPREL
				       | TLS_TPRELGD)) != 0)
d4832 1
a4832 1
			    if ((tls_ty & TLS_TPREL) != 0)
a4833 1
			  }
d4835 6
a4840 5
			if (tls_ty == (TLS_TLS | TLS_GD))
			  {
			    bfd_put_32 (output_bfd, value,
					htab->got->contents + off + 4);
			    value = 1;
a4841 2
			else if (tls_ty == (TLS_TLS | TLS_LD))
			  value = 1;
d4889 1
a4889 1
		(_("%s(%s+0x%lx): non-zero addend on got reloc against `%s'"),
d4893 1
d4902 1
a4902 4
	  if (h != NULL
	      && (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
	      && sec->output_section == NULL)
a5036 2
	      /* h->dynindx may be -1 if this symbol was marked to
		 become local.  */
d5173 1
a5173 1
		(*_bfd_error_handler) (_("%s: The target (%s) of a %s relocation is in the wrong output section (%s)"),
d5197 1
a5197 1
		(*_bfd_error_handler) (_("%s: The target (%s) of a %s relocation is in the wrong output section (%s)"),
d5254 1
a5254 1
		(*_bfd_error_handler) (_("%s: The target (%s) of a %s relocation is in the wrong output section (%s)"),
d5308 1
a5308 1
	    (_("%s: Relocation %s is not yet supported for symbol %s."),
d5337 1
a5337 1
	     that's not actually defined anywhere. In that case,
d5361 1
a5361 1
	    (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
d5365 1
d5411 1
a5411 1
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
d5414 1
a5414 1
		 (long) rel->r_offset, sym_name, (int) r);
@


1.67
log
@	* elf32-ppc.c (struct ppc_elf_dyn_relocs): Add pc_count field.
	(ppc_elf_copy_indirect_symbol): Copy pc_count field.
	(ELIMINATE_COPY_RELOCS): Define.
	(ppc_elf_adjust_dynamic_symbol): Convert copy relocs to dynamic.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead of INFO.
	(MUST_BE_DYN_RELOC): Define.
	(allocate_dynrelocs): Adjust WILL_CALL_FINISH_DYNAMIC_SYMBOL uses,
	and optimize.  Trim dyn_relocs.
	(ppc_elf_check_relocs): Don't generate dyn_relocs when we know they'll
	not be used.  Do generate dyn_relocs for copy reloc avoidance.  Keep
	track of pc_rel dyn relocs.
	(ppc_elf_relocate_section): Remove "will_become_local".  Adjust
	WILL_CALL_FINISH_DYNAMIC_SYMBOL use.  Trim dyn relocs as per
	allocate_dynrelocs.  Don't recalculate "sec".
@
text
@d87 1
a87 1
static asection * ppc_elf_gc_mark_hook
d120 6
a125 3
#define BRANCH_PREDICT_BIT 0x200000		/* Branch prediction bit for branch taken relocs.  */
#define RA_REGISTER_MASK 0x001f0000		/* Mask to set RA in memory instructions.  */
#define RA_REGISTER_SHIFT 16			/* Value to shift register by to insert RA.  */
a128 1

d1676 1
a1676 1
      isec->_cooked_size = isec->_raw_size;
d1688 1
a1688 1
	  contents = elf_section_data (isec)->this_hdr.contents;
d1706 1
a1706 1
          unsigned n;
d1709 9
a1717 8
          /* Get a copy of the native relocations.  */
          internal_relocs = _bfd_elf32_link_read_relocs (
    	    abfd, isec, (PTR) NULL, (Elf_Internal_Rela *) NULL,
    	    link_info->keep_memory);
          if (internal_relocs == NULL)
    	      goto error_return;
          if (! link_info->keep_memory)
    	      free_relocs = internal_relocs;
d1719 1
a1719 1
          /* Setup a faster access method for the reloc info we need.  */
d1722 36
a1757 34
          rela_comb = (Elf_Internal_Rela**) bfd_malloc (amt);
          if (rela_comb == NULL)
              goto error_return;
          for (n = 0; n < isec->reloc_count; ++n)
            {
              long r_type;

              r_type = ELF32_R_TYPE (internal_relocs[n].r_info);
              if (r_type < 0 || r_type >= (int) R_PPC_max)
                  goto error_return;

              /* Prologue constants are sometimes present in the ".text"
              sections and they can be identified by their associated relocation.
              We don't want to process those words and some others which
              can also be identified by their relocations.  However, not all
              conditional branches will have a relocation so we will
              only ignore words that 1) have a reloc, and 2) the reloc
              is not applicable to a conditional branch.
              The array rela_comb is built here for use in the EOP scan loop.  */
              switch (r_type)
                {
                case R_PPC_ADDR14_BRNTAKEN:     /* Absolute, predicted not taken */
                case R_PPC_REL14:               /* Relative cond. br.  */
                case R_PPC_REL14_BRNTAKEN:      /* Rel. cond. br., predicted not taken */
                  /* We should check the instruction.  */
                  break;
                default:
                  /* The word is not a conditional branch - ignore it.  */
                  rela_comb[comb_count++] = &internal_relocs[n];
                  break;
                }
            }
          if (comb_count > 1)
	    qsort (rela_comb, (size_t) comb_count, sizeof (int), ppc_elf_sort_rela);
d1765 4
a1768 2
      if (dot < isec->vma)      /* Increment the start position if this section */
          dot = isec->vma;      /* begins in the middle of its first EOP region.  */
d1770 27
a1796 27
           dot < end_section;
           dot += PAGESIZE, end_page += PAGESIZE)
        {

          /* Check each word in this EOP region.  */
          for (; dot < end_page; dot += 4)
            {
              bfd_vma isec_offset;
              unsigned long insn;
              bfd_boolean skip, modified;

              /* Don't process this word if there is a relocation for it and
		 the relocation indicates the word is not a conditional branch.  */
              skip = FALSE;
              isec_offset = dot - isec->vma;
              for (; comb_curr<comb_count; ++comb_curr)
                {
                  bfd_vma r_offset;

                  r_offset = rela_comb[comb_curr]->r_offset;
                  if (r_offset >= isec_offset)
                    {
                      if (r_offset == isec_offset) skip = TRUE;
                      break;
                    }
                }
              if (skip) continue;
d1798 2
a1799 1
              /* Check the current word for a problematic conditional branch.  */
d1803 10
a1812 9
              insn = (unsigned long) bfd_get_32 (abfd, contents + isec_offset);
              modified = FALSE;
              if ((insn & 0xFc000000) == 0x40000000)
                {
                  /* Instruction is BCx */
                  if ((!BO0(insn) || !BO2(insn)) && !BO4(insn))
                    {
                      bfd_vma target;
                      /* This branch is predicted as "normal".
d1814 17
a1830 16

                      target = insn & 0x0000Fffc;               /*extract*/
                      target = (target ^ 0x8000) - 0x8000;      /*sign extend*/
                      if ((insn & 0x00000002) == 0)
                          target += dot;                        /*convert to abs*/
                      if (target > dot)
                        {
                          insn |= 0x00200000;   /* Set the prediction bit.  */
                          modified = TRUE;
                        }
                    }
                }
              else if ((insn & 0xFc00Fffe) == 0x4c000420)
                {
                  /* Instruction is BCCTRx.  */
                  if ((!BO0(insn) || !BO2(insn)) && !BO4(insn))
d1834 4
a1837 4
			 Since we can't tell statically if it will branch forward,
			 always set the prediction bit.  */
                      insn |= 0x00200000;   /* Set the prediction bit.  */
                      modified = TRUE;
d1839 5
a1843 5
                }
              else if ((insn & 0xFc00Fffe) == 0x4c000020)
                {
                  /* Instruction is BCLRx */
                  if ((!BO0(insn) || !BO2(insn)) && !BO4(insn))
d1847 4
a1850 4
			 Since we can't tell statically if it will branch forward,
			 always set the prediction bit.  */
                      insn |= 0x00200000;   /* Set the prediction bit.  */
                      modified = TRUE;
d1852 1
a1852 1
                }
d1856 3
a1858 3
              if (modified)
	        {
                  bfd_put_32 (abfd, (bfd_vma) insn, contents + isec_offset);
d1860 3
a1862 3
	        }
            }
        }
d1896 1
a1896 1
error_return:
d2148 1
a2148 1
  if (!elf_flags_init (obfd))	/* First call, no flags set.  */
d2150 1
d2155 2
a2156 1
  else if (new_flags == old_flags)	/* Compatible flags are ok.  */
d2159 2
a2160 1
  else					/* Incompatible flags.  */
d2162 2
a2163 2
      /* Warn about -mrelocatable mismatch.  Allow -mrelocatable-lib to be linked
         with either.  */
d2187 1
a2187 1
         but each input file is either -mrelocatable or -mrelocatable-lib.  */
d2193 2
a2194 1
      /* Do not warn about eabi vs. V.4 mismatch, just or in the bit if any module uses it.  */
d2197 2
a2198 2
      new_flags &= ~ (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
      old_flags &= ~ (EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
d2476 2
a2477 1
  fprintf (stderr, "ppc_elf_adjust_dynamic_symbol called for %s\n", h->root.root.string);
d2504 2
a2505 2
	     1. We are not using ld.so; because then the PLT entry
	     can't be set up, so we can't use one.
d2507 2
a2508 2
	     2. We know for certain that a call to this symbol
	     will go to this object.
d2510 1
a2510 1
	     3. GC has rendered the entry unused.  */
d2755 3
a2757 1
	      if ((eh->tls_mask & (TLS_GD | TLS_LD)) != 0)
d2942 3
a2944 3
		   elf_section_data (s)->local_dynrel);
	      p != NULL;
	      p = p->next)
d3284 1
a3284 1
	/* GOT16 relocations */
d3308 1
a3308 1
	/* Indirect .sdata relocation.  */
d3320 1
a3320 1
	/* Indirect .sdata2 relocation.  */
d3358 4
a3361 4
             actually build the entry in finish_dynamic_symbol,
             because this might be a case of linking PIC code without
             linking in any dynamic objects, in which case we don't
             need to generate a procedure linkage table after all.  */
d3366 1
a3366 1
                 table entry for a local symbol.  */
d3526 2
a3527 1
		       (h && h->root.root.string) ? h->root.root.string : "<unknown>");
d4025 3
a4027 3
             want to attach this common section to DYNOBJ.  The linker
             will move the symbols to the appropriate output section
             when it defines common symbols.  */
d4087 1
a4087 1
         it up.  */
d4360 4
a4363 4
		/* Set a flag that will be cleared later if we find a
		   relocation value for this symbol.  output_section
		   is typically NULL for symbols satisfied by a shared
		   library.  */
d4594 1
a4594 1
			 in order to get h, sym, sec etc. right.  */ 
d4744 37
a4780 1
		*offp = off | 1;
d4782 2
a4783 9
		/* Generate relocs for the dynamic linker, except in
		   the case of TLSLD where we'll use one entry per
		   module.  */
		if (info->shared || indx != 0)
		  {
		    outrel.r_offset = (htab->got->output_section->vma
				       + htab->got->output_offset
				       + off);
		    if (tls_type & (TLS_LD | TLS_GD))
d4785 4
a4788 3
			outrel.r_info = ELF32_R_INFO (indx, R_PPC_DTPMOD32);
			outrel.r_addend = 0;
			if (tls_type == (TLS_TLS | TLS_GD))
d4790 13
a4802 8
			    loc = htab->relgot->contents;
			    loc += (htab->relgot->reloc_count++
				    * sizeof (Elf32_External_Rela));
			    bfd_elf32_swap_reloca_out (output_bfd,
						       &outrel, loc);
			    outrel.r_info
			      = ELF32_R_INFO (indx, R_PPC_DTPREL32);
			    outrel.r_offset += 4;
d4804 15
d4820 3
a4822 6
		    else if (tls_type == (TLS_TLS | TLS_DTPREL))
		      outrel.r_info = ELF32_R_INFO (indx, R_PPC_DTPREL32);
		    else if (tls_type == (TLS_TLS | TLS_TPREL))
		      outrel.r_info = ELF32_R_INFO (indx, R_PPC_TPREL32);
		    else if (indx == 0)
		      outrel.r_info = ELF32_R_INFO (indx, R_PPC_RELATIVE);
d4824 10
a4833 9
		      outrel.r_info = ELF32_R_INFO (indx, R_PPC_GLOB_DAT);
		    outrel.r_addend = 0;
		    if (indx == 0)
		      outrel.r_addend += relocation;
		    loc = htab->relgot->contents;
		    loc += (htab->relgot->reloc_count++
			    * sizeof (Elf32_External_Rela));
		    bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		  }
d4835 10
a4844 9
		/* Init the .got section contents if we're not
		   emitting a reloc.  */
		else
		  {
		    if (tls_type != 0)
		      {
			relocation -= htab->tls_sec->vma + DTP_OFFSET;
			if ((tls_type & TLS_TPREL) != 0)
			  relocation += DTP_OFFSET - TP_OFFSET;
d4847 3
a4849 10
		    if (tls_type == (TLS_TLS | TLS_GD))
		      {
			bfd_put_32 (output_bfd, relocation,
				    htab->got->contents + off + 4);
			relocation = 1;
		      }
		    else if (tls_type == (TLS_TLS | TLS_LD))
		      relocation = 1;
		    bfd_put_32 (output_bfd, relocation,
				htab->got->contents + off);
d4851 4
d4860 22
d4896 1
a4896 1
	  break;
d4925 2
a4926 2
	/* Relocations that may need to be propagated if this is a shared
           object.  */
d4956 1
a4956 1
	/* fall through */
d4958 2
a4959 2
	/* Relocations that always need to be propagated if this is a shared
           object.  */
d5000 2
a5001 1
		       (h && h->root.root.string) ? h->root.root.string : "<unknown>");
d5005 2
a5006 2
                 are copied into the output file to be resolved at run
                 time.  */
d5041 1
a5041 1
                 become local.  */
d5082 2
a5083 2
				     indx, osec->name, osec->flags,
				     h->root.root.string);
d5112 1
a5112 1
	/* Indirect .sdata relocation.  */
d5122 1
a5122 1
	/* Indirect .sdata2 relocation.  */
d5132 4
a5135 4
	/* Handle the TOC16 reloc.  We want to use the offset within the .got
	   section, not the actual VMA.  This is appropriate when generating
	   an embedded ELF object, for which the .got section acts like the
	   AIX .toc section.  */
d5142 1
a5142 1
	  addend -= sec->output_section->vma + sec->output_offset + 0x8000;
d5147 1
a5147 1
             procedure linkage table.  */
d5154 2
a5155 2
                 happens when statically linking PIC code, or when
                 using -Bsymbolic.  */
d5165 1
a5165 1
	/* Relocate against _SDA_BASE_.  */
d5191 1
a5191 1
	/* Relocate against _SDA2_BASE_.  */
d5219 1
a5219 1
	/* Relocate against either _SDA_BASE_, _SDA2_BASE_, or 0.  */
d5279 1
a5279 1
	/* Relocate against the beginning of the section.  */
d5288 1
a5288 1
	/* Negative relocations.  */
d5462 2
a5463 2
      default:
	return FALSE;
d5465 10
a5474 10
      case 268:		/* Linux/PPC.  */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	raw_size = 192;
d5476 1
a5476 1
	break;
d5491 2
a5492 2
      default:
	return FALSE;
d5494 5
a5498 5
      case 128:		/* Linux/PPC elf_prpsinfo.  */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
d5519 2
a5520 2
  struct apuinfo_list *	next;
  unsigned long         value;
d5526 3
a5528 3
static void          apuinfo_list_init    PARAMS ((void));
static void          apuinfo_list_add     PARAMS ((unsigned long));
static unsigned      apuinfo_list_length  PARAMS ((void));
d5530 1
a5530 1
static void          apuinfo_list_finish  PARAMS ((void));
d5532 1
a5532 1
extern void          ppc_elf_begin_write_processing
d5534 1
a5534 1
extern void          ppc_elf_final_write_processing
d5536 1
a5536 1
extern bfd_boolean   ppc_elf_write_section
a5539 1

d5550 1
a5550 1
  apuinfo_list * entry = head;
d5571 1
a5571 1
  apuinfo_list * entry;
d5599 1
a5599 1
  apuinfo_list * entry;
d5603 1
a5603 1
      apuinfo_list * next = entry->next;
d5611 2
a5612 2
#define APUINFO_SECTION_NAME ".PPC.EMB.apuinfo"
#define APUINFO_LABEL        "APUinfo"
d5622 4
a5625 4
  bfd *         ibfd;
  asection *    asec;
  char *        buffer;
  unsigned 	num_input_sections;
d5627 2
a5628 2
  unsigned      i;
  unsigned      num_entries;
d5631 1
a5631 1
  const char *  error_message = NULL;
d5671 2
a5672 3
      unsigned long	datum;
      char *		ptr;

d5735 1
a5735 1
  if (! bfd_set_section_size  (abfd, asec, output_section_size))
d5743 2
a5744 2
    _bfd_error_handler (error_message, APUINFO_SECTION_NAME,
			bfd_archive_filename (ibfd));
d5753 3
a5755 3
     bfd * abfd ATTRIBUTE_UNUSED;
     asection * asec;
     bfd_byte * contents ATTRIBUTE_UNUSED;
d5757 2
a5758 1
  return apuinfo_list_length () && strcmp (asec->name, APUINFO_SECTION_NAME) == 0;
d5766 1
a5766 1
     bfd * abfd;
d5769 4
a5772 4
  bfd_byte *    buffer;
  asection *    asec;
  unsigned      i;
  unsigned      num_entries;
d5789 2
a5790 1
      _bfd_error_handler (_("failed to allocate space for new APUinfo section."));
d5809 1
a5809 1
    _bfd_error_handler (_("failed to compute new APUinfo section."));
d5812 1
a5812 1
    _bfd_error_handler (_("failed to install new APUinfo section."));
d5845 1
a5845 1
#define bfd_elf32_bfd_relax_section             ppc_elf_relax_section
d5848 1
a5848 1
#define bfd_elf32_bfd_link_hash_table_create  	ppc_elf_link_hash_table_create
d5869 3
a5871 3
#define elf_backend_begin_write_processing      ppc_elf_begin_write_processing
#define elf_backend_final_write_processing      ppc_elf_final_write_processing
#define elf_backend_write_section               ppc_elf_write_section
@


1.66
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Remove unnecessary test.
	* elf64-ppc.c (ppc64_elf_tls_optimize): Decrement tlsld_got.refcount
	on invalid LD relocs.
	(allocate_dynrelocs): Invalid LD relocs don't use tlsld_got entry.
	(ppc64_elf_relocate_section): Unify new handling of LD relocs and
	tlsld_got entry.  Use IS_PPC64_TLS_RELOC.
@
text
@d180 3
d347 1
d2440 6
d2531 19
d2616 1
a2616 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
d2618 1
a2618 1
   && ((INFO)->shared							\
d2623 11
d2667 2
a2668 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d2750 2
a2751 1
	  if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, &eh->elf))
d2766 58
d3466 1
d3468 35
a3502 1
	  if (info->shared)
d3559 2
a3560 3
		  s = (bfd_section_from_r_symndx
		       (abfd, &ppc_elf_hash_table (info)->sym_sec,
			sec, r_symndx));
d3579 1
d3582 3
a3584 1
	      p->count++;
a4309 1
      bfd_boolean will_become_local;
a4327 2
	  /* Relocs to local symbols are always resolved.  */
	  will_become_local = TRUE;
a4336 2
	  /* Can this relocation be resolved immediately?  */
	  will_become_local = SYMBOL_REFERENCES_LOCAL (info, h);
d4696 1
a4696 1
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d4886 3
d4890 19
a4908 1
	  if (info->shared && r_symndx != 0)
d4955 2
a4956 1
	      else if (! will_become_local)
a4970 10

		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
@


1.65
log
@	* elf32-ppc.h: New file.
	* elf32-ppc.c: Include elf32-ppc.h.
	(NOP, CROR_151515, CROR_313131, TP_OFFSET, DTP_OFFSET): Define.
	(struct ppc_elf_link_hash_entry): Rename "root" to "elf".  Adjust uses.
	Add "tls_mask" field.
	(TLS_GD, TLS_LD, TLS_TPREL, TLS_DTPREL, TLS_TLS, TLS_TPRELGD): Define.
	(struct ppc_elf_link_hash_table): Rename "root" to "elf".  Adjust uses.
	Add got, relgot, plt, relplt, dynbss, relbss, dynsbss, relsbss,
	sdata, sdata2, tls_sec, tls_get_addr, tlsld_got fields.
	Make use of htab shortcuts throughout file.
	(ppc_elf_link_hash_newfunc): Init tls_mask field.
	(ppc_elf_link_hash_table_create): Init new fields.
	(ppc_elf_copy_indirect_symbol): Copy tls_mask.
	(ppc_elf_howto_raw): Add tls relocs.
	(ppc_elf_reloc_type_lookup): Handle them.
	(ppc_elf_unhandled_reloc): New function.
	(ppc_elf_create_got): Stash got section pointer in hash table,
	return status.  Make .rela.got too.
	(ppc_elf_create_dynamic_sections): Stash section pointers in htab.
	(ppc_elf_adjust_dynamic_symbol): Only set up copy relocs when
	NON_GOT_REF set.  Don't allocate space in .plt here..
	(allocate_dynrelocs): ..do so here instead, properly ref-counting and
	not allocating plt entries unnecessarily.  Allocate got entries here.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	(ppc_elf_size_dynamic_sections): Allocate local got entries.  Pass
	"info" during allocate_dynrelocs hash traversal.  Use htab section
	shortcuts rather than searching for named sections.  Get rid of
	"plt" and "strip" booleans.
	(update_local_sym_info, bad_shared_reloc): New functions.
	(ppc_elf_check_relocs): Handle TLS relocs.  Move .rela.got creation to
	ppc_elf_create_got.  Don't mark got or plt reloc syms dynamic, do so
	in allocate_dynreloc.  Use update_local_sym_info and bad_shared_reloc.
	Disallow R_PPC_EMB_RELSDA, R_PPC_EMB_NADDR32, R_PPC_EMB_NADDR16,
	R_PPC_EMB_NADDR16_LO, R_PPC_EMB_NADDR16_HI and R_PPC_EMB_NADDR16_HA
	in shared libs.  R_PPC_PLTREL32 is a plt reloc too.  Refcount all
	relocs that might use a plt entry.  Set NON_GOT_REF too.
	Enumerate all do-nothing relocs.
	(ppc_elf_gc_sweep_hook): Simplify removal of dynrelocs.  Handle
	tls relocs and all plt relocs.
	(ppc_elf_tls_setup, ppc_elf_tls_optimize): New functions.
	(ppc_elf_finish_dynamic_symbol): Don't build got entries here.
	(ppc_elf_finish_dynamic_sections): Rewrite tag code using htab
	shortcuts.
	(ppc_elf_relocate_section): Tidy.  Handle TLS relocs.  Use
	bfd_elf_local_sym_name.  Simplify unresolved reloc code.  Build got
	entries and got relocs here.  Warn on non-zero got reloc addend.
	Split out branch taken/not taken reloc code into a separate switch
	and correct offset calculation. Allow BRTAKEN/BRNTAKEN dynamic relocs.
	Split out HA reloc adjustments to separate switch statement.  Don't
	warn on reloc overflow if we've already warned about undefined.
	Don't rebuild sym name when reporting errors.  Report all possible
	errors from _bfd_final_link_relocate.
	(bfd_elf32_bfd_final_link): Don't define.
@
text
@d4557 1
a4557 2
		&& ((tls_mask & TLS_LD) == 0
		    || h == NULL
@


1.64
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d33 1
d57 2
d69 1
a69 1
static asection *ppc_elf_create_got
d80 4
d138 9
d186 1
a186 1
  struct elf_link_hash_entry root;
d190 13
d211 25
a235 1
  struct elf_link_hash_table root;
d267 4
a270 1
    ppc_elf_hash_entry (entry)->dyn_relocs = NULL;
d288 1
a288 1
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
d295 13
d310 1
a310 1
  return &ret->root.root;
d358 2
d952 30
a981 2
  /* The remaining relocs are from the Embedded ELF ABI, and are not
     in the SVR4 ELF ABI.  */
d983 4
a986 2
  /* 32 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR32,	/* type */
d992 3
a994 3
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR32",	/* name */
d1000 2
a1001 2
  /* 16 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16,	/* type */
d1007 3
a1009 3
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR16",	/* name */
d1015 2
a1016 2
  /* 16 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16_LO,	/* type */
d1022 3
a1024 3
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_ADDR16_LO",	/* name */
d1030 2
a1031 2
  /* The high order 16 bits of the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16_HI,	/* type */
d1038 2
a1039 2
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR16_HI", /* name */
d1045 2
a1046 4
  /* The high order 16 bits of the result of the addend minus the address,
     plus 1 if the contents of the low 16 bits, treated as a signed number,
     is negative.  */
  HOWTO (R_PPC_EMB_NADDR16_HA,	/* type */
d1053 2
a1054 2
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_EMB_NADDR16_HA", /* name */
d1060 18
a1077 4
  /* 16 bit value resulting from allocating a 4 byte word to hold an
     address in the .sdata section, and returning the offset from
     _SDA_BASE_ for that relocation.  */
  HOWTO (R_PPC_EMB_SDAI16,	/* type */
d1083 3
a1085 3
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDAI16",	/* name */
d1091 2
a1092 4
  /* 16 bit value resulting from allocating a 4 byte word to hold an
     address in the .sdata2 section, and returning the offset from
     _SDA2_BASE_ for that relocation */
  HOWTO (R_PPC_EMB_SDA2I16,	/* type */
d1098 33
a1130 3
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA2I16",	/* name */
d1136 4
a1139 3
  /* A sign-extended 16 bit value relative to _SDA2_BASE_, for use with
     small data items.	 */
  HOWTO (R_PPC_EMB_SDA2REL,	/* type */
d1146 2
a1147 2
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA2REL",	/* name */
d1153 2
a1154 4
  /* Relocate against either _SDA_BASE_ or _SDA2_BASE_, filling in the 16 bit
     signed offset from the appropriate base, and filling in the register
     field with the appropriate register (0, 2, or 13).  */
  HOWTO (R_PPC_EMB_SDA21,	/* type */
d1156 16
a1171 1
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
d1175 3
a1177 3
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA21",	/* name */
d1183 14
a1196 6
  /* Relocation not handled: R_PPC_EMB_MRKREF */
  /* Relocation not handled: R_PPC_EMB_RELSEC16 */
  /* Relocation not handled: R_PPC_EMB_RELST_LO */
  /* Relocation not handled: R_PPC_EMB_RELST_HI */
  /* Relocation not handled: R_PPC_EMB_RELST_HA */
  /* Relocation not handled: R_PPC_EMB_BIT_FLD */
d1198 4
a1201 4
  /* PC relative relocation against either _SDA_BASE_ or _SDA2_BASE_, filling
     in the 16 bit signed offset from the appropriate base, and filling in the
     register field with the appropriate register (0, 2, or 13).  */
  HOWTO (R_PPC_EMB_RELSDA,	/* type */
d1205 1
a1205 1
	 TRUE,			/* pc_relative */
d1208 2
a1209 2
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_RELSDA",	/* name */
d1215 2
a1216 2
  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_PPC_GNU_VTINHERIT,	/* type */
d1218 17
a1234 2
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d1238 2
a1239 2
	 NULL,			/* special_function */
	 "R_PPC_GNU_VTINHERIT",	/* name */
d1242 1
a1242 1
	 0,			/* dst_mask */
d1245 5
a1249 5
  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_PPC_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
d1253 2
a1254 2
	 NULL,			/* special_function */
	 "R_PPC_GNU_VTENTRY",	/* name */
d1257 1
a1257 1
	 0,			/* dst_mask */
d1260 3
a1262 2
  /* Phony reloc to handle AIX style TOC entries.  */
  HOWTO (R_PPC_TOC16,		/* type */
d1269 2
a1270 2
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_TOC16",		/* name */
a1274 3
};

/* Initialize the ppc_elf_howto_table, so that linear accesses can be done.  */
d1276 14
a1289 4
static void
ppc_elf_howto_init ()
{
  unsigned int i, type;
d1291 14
a1304 9
  for (i = 0; i < sizeof (ppc_elf_howto_raw) / sizeof (ppc_elf_howto_raw[0]); i++)
    {
      type = ppc_elf_howto_raw[i].type;
      BFD_ASSERT (type < sizeof (ppc_elf_howto_table) / sizeof (ppc_elf_howto_table[0]));
      ppc_elf_howto_table[type] = &ppc_elf_howto_raw[i];
    }
}

/* This function handles relaxing for the PPC with option --mpc860c0[=<n>].
d1306 318
a1623 8
   The MPC860, revision C0 or earlier contains a bug in the die.
   If all of the following conditions are true, the next instruction
   to be executed *may* be treated as a no-op.
   1/ A forward branch is executed.
   2/ The branch is predicted as not taken.
   3/ The branch is taken.
   4/ The branch is located in the last 5 words of a page.
      (The EOP limit is 5 by default but may be specified as any value from 1-10.)
d1897 1
a1897 1
  enum elf_ppc_reloc_type ppc_reloc = R_PPC_NONE;
d1908 81
a1988 53
    case BFD_RELOC_NONE:		ppc_reloc = R_PPC_NONE;			break;
    case BFD_RELOC_32:			ppc_reloc = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC_BA26:		ppc_reloc = R_PPC_ADDR24;		break;
    case BFD_RELOC_16:			ppc_reloc = R_PPC_ADDR16;		break;
    case BFD_RELOC_LO16:		ppc_reloc = R_PPC_ADDR16_LO;		break;
    case BFD_RELOC_HI16:		ppc_reloc = R_PPC_ADDR16_HI;		break;
    case BFD_RELOC_HI16_S:		ppc_reloc = R_PPC_ADDR16_HA;		break;
    case BFD_RELOC_PPC_BA16:		ppc_reloc = R_PPC_ADDR14;		break;
    case BFD_RELOC_PPC_BA16_BRTAKEN:	ppc_reloc = R_PPC_ADDR14_BRTAKEN;	break;
    case BFD_RELOC_PPC_BA16_BRNTAKEN:	ppc_reloc = R_PPC_ADDR14_BRNTAKEN;	break;
    case BFD_RELOC_PPC_B26:		ppc_reloc = R_PPC_REL24;		break;
    case BFD_RELOC_PPC_B16:		ppc_reloc = R_PPC_REL14;		break;
    case BFD_RELOC_PPC_B16_BRTAKEN:	ppc_reloc = R_PPC_REL14_BRTAKEN;	break;
    case BFD_RELOC_PPC_B16_BRNTAKEN:	ppc_reloc = R_PPC_REL14_BRNTAKEN;	break;
    case BFD_RELOC_16_GOTOFF:		ppc_reloc = R_PPC_GOT16;		break;
    case BFD_RELOC_LO16_GOTOFF:		ppc_reloc = R_PPC_GOT16_LO;		break;
    case BFD_RELOC_HI16_GOTOFF:		ppc_reloc = R_PPC_GOT16_HI;		break;
    case BFD_RELOC_HI16_S_GOTOFF:	ppc_reloc = R_PPC_GOT16_HA;		break;
    case BFD_RELOC_24_PLT_PCREL:	ppc_reloc = R_PPC_PLTREL24;		break;
    case BFD_RELOC_PPC_COPY:		ppc_reloc = R_PPC_COPY;			break;
    case BFD_RELOC_PPC_GLOB_DAT:	ppc_reloc = R_PPC_GLOB_DAT;		break;
    case BFD_RELOC_PPC_LOCAL24PC:	ppc_reloc = R_PPC_LOCAL24PC;		break;
    case BFD_RELOC_32_PCREL:		ppc_reloc = R_PPC_REL32;		break;
    case BFD_RELOC_32_PLTOFF:		ppc_reloc = R_PPC_PLT32;		break;
    case BFD_RELOC_32_PLT_PCREL:	ppc_reloc = R_PPC_PLTREL32;		break;
    case BFD_RELOC_LO16_PLTOFF:		ppc_reloc = R_PPC_PLT16_LO;		break;
    case BFD_RELOC_HI16_PLTOFF:		ppc_reloc = R_PPC_PLT16_HI;		break;
    case BFD_RELOC_HI16_S_PLTOFF:	ppc_reloc = R_PPC_PLT16_HA;		break;
    case BFD_RELOC_GPREL16:		ppc_reloc = R_PPC_SDAREL16;		break;
    case BFD_RELOC_16_BASEREL:		ppc_reloc = R_PPC_SECTOFF;		break;
    case BFD_RELOC_LO16_BASEREL:	ppc_reloc = R_PPC_SECTOFF_LO;		break;
    case BFD_RELOC_HI16_BASEREL:	ppc_reloc = R_PPC_SECTOFF_HI;		break;
    case BFD_RELOC_HI16_S_BASEREL:	ppc_reloc = R_PPC_SECTOFF_HA;		break;
    case BFD_RELOC_CTOR:		ppc_reloc = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC_TOC16:		ppc_reloc = R_PPC_TOC16;		break;
    case BFD_RELOC_PPC_EMB_NADDR32:	ppc_reloc = R_PPC_EMB_NADDR32;		break;
    case BFD_RELOC_PPC_EMB_NADDR16:	ppc_reloc = R_PPC_EMB_NADDR16;		break;
    case BFD_RELOC_PPC_EMB_NADDR16_LO:	ppc_reloc = R_PPC_EMB_NADDR16_LO;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HI:	ppc_reloc = R_PPC_EMB_NADDR16_HI;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HA:	ppc_reloc = R_PPC_EMB_NADDR16_HA;	break;
    case BFD_RELOC_PPC_EMB_SDAI16:	ppc_reloc = R_PPC_EMB_SDAI16;		break;
    case BFD_RELOC_PPC_EMB_SDA2I16:	ppc_reloc = R_PPC_EMB_SDA2I16;		break;
    case BFD_RELOC_PPC_EMB_SDA2REL:	ppc_reloc = R_PPC_EMB_SDA2REL;		break;
    case BFD_RELOC_PPC_EMB_SDA21:	ppc_reloc = R_PPC_EMB_SDA21;		break;
    case BFD_RELOC_PPC_EMB_MRKREF:	ppc_reloc = R_PPC_EMB_MRKREF;		break;
    case BFD_RELOC_PPC_EMB_RELSEC16:	ppc_reloc = R_PPC_EMB_RELSEC16;		break;
    case BFD_RELOC_PPC_EMB_RELST_LO:	ppc_reloc = R_PPC_EMB_RELST_LO;		break;
    case BFD_RELOC_PPC_EMB_RELST_HI:	ppc_reloc = R_PPC_EMB_RELST_HI;		break;
    case BFD_RELOC_PPC_EMB_RELST_HA:	ppc_reloc = R_PPC_EMB_RELST_HA;		break;
    case BFD_RELOC_PPC_EMB_BIT_FLD:	ppc_reloc = R_PPC_EMB_BIT_FLD;		break;
    case BFD_RELOC_PPC_EMB_RELSDA:	ppc_reloc = R_PPC_EMB_RELSDA;		break;
    case BFD_RELOC_VTABLE_INHERIT:	ppc_reloc = R_PPC_GNU_VTINHERIT;	break;
    case BFD_RELOC_VTABLE_ENTRY:	ppc_reloc = R_PPC_GNU_VTENTRY;		break;
d1991 1
a1991 1
  return ppc_elf_howto_table[(int) ppc_reloc];
d2048 28
d2354 1
a2354 1
static asection *
d2359 2
a2360 1
  register asection *s;
d2364 1
a2364 1
    return NULL;
d2366 2
a2367 1
  s = bfd_get_section_by_name (abfd, ".got");
d2374 12
a2385 2
    return NULL;
  return s;
d2397 2
a2398 1
  register asection *s;
d2410 3
a2412 1
  s = bfd_make_section (abfd, ".dynsbss");
d2419 2
a2420 1
      s = bfd_make_section (abfd, ".rela.sbss");
d2427 2
a2428 1
  s = bfd_get_section_by_name (abfd, ".plt");
d2447 1
a2447 1
  bfd *dynobj = elf_hash_table (info)->dynobj;
a2449 1
  bfd_vma plt_offset;
d2456 2
a2457 1
  BFD_ASSERT (dynobj != NULL
d2467 1
a2467 3
  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
d2471 3
a2473 1
      if (! elf_hash_table (info)->dynamic_sections_created
d2475 1
a2475 1
	  || (info->shared && h->plt.refcount <= 0))
d2485 1
a2485 5
	     3. GC has rendered the entry unused.
	     Note, however, that in an executable all references to the
	     symbol go to the PLT, so we can't turn it off in that case.
	     ??? The correct thing to do here is to reference count
	     all uses of the symbol, not just those to the GOT or PLT.  */
a2487 1
	  return TRUE;
a2488 52

      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}
      BFD_ASSERT (h->dynindx != -1);

      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->_raw_size == 0)
	s->_raw_size += PLT_INITIAL_ENTRY_SIZE;

      /* The PowerPC PLT is actually composed of two parts, the first part
	 is 2 words (for a load and a jump), and then there is a remaining
	 word available at the end.  */
      plt_offset = (PLT_INITIAL_ENTRY_SIZE
		    + (PLT_SLOT_SIZE
		       * ((s->_raw_size - PLT_INITIAL_ENTRY_SIZE)
			  / PLT_ENTRY_SIZE)));

      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.  This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (! info->shared
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = plt_offset;
	}

      h->plt.offset = plt_offset;

      /* Make room for this entry.  After the 8192nd entry, room
         for two entries is allocated.  */
      if ((s->_raw_size - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
	  >= PLT_NUM_SINGLE_ENTRIES)
	s->_raw_size += 2 * PLT_ENTRY_SIZE;
      else
	s->_raw_size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf32_External_Rela);

d2516 5
d2535 2
a2536 2
  if (h->size <= elf_gp_size (dynobj))
    s = bfd_get_section_by_name (dynobj, ".dynsbss");
d2538 1
a2538 1
    s = bfd_get_section_by_name (dynobj, ".dynbss");
d2549 2
a2550 2
      if (h->size <= elf_gp_size (dynobj))
	srel = bfd_get_section_by_name (dynobj, ".rela.sbss");
d2552 1
a2552 1
	srel = bfd_get_section_by_name (dynobj, ".rela.bss");
d2567 1
a2567 1
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
d2569 1
a2569 1
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
d2583 11
d2596 81
a2676 6
static bfd_boolean
allocate_dynrelocs (h, info)
     struct elf_link_hash_entry *h;
     PTR info ATTRIBUTE_UNUSED;
{
  struct ppc_elf_dyn_relocs *p;
d2678 10
a2687 2
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;
d2689 34
a2722 5
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d2724 1
a2724 1
  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
d2772 1
a2772 1
  bfd *dynobj;
a2773 1
  bfd_boolean plt;
d2781 2
a2782 2
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
d2789 1
a2789 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d2795 2
a2796 1
  else
d2798 4
a2801 16
      /* We may have created entries in the .rela.got, .rela.sdata, and
	 .rela.sdata2 sections.  However, if we are not creating the
	 dynamic sections, we will not actually use these entries.  Reset
	 the size of .rela.got, et al, which will cause it to get
	 stripped from the output file below.  */
      static char *rela_sections[] = { ".rela.got", ".rela.sdata",
				       ".rela.sdata2", ".rela.sbss",
				       (char *) 0 };
      char **p;

      for (p = rela_sections; *p != (char *) 0; p++)
	{
	  s = bfd_get_section_by_name (dynobj, *p);
	  if (s != NULL)
	    s->_raw_size = 0;
	}
d2803 2
d2806 2
a2807 1
  /* Allocate space for local sym dynamic relocs.  */
d2810 7
d2848 48
d2899 1
a2899 1
  elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, NULL);
d2901 2
a2902 4
  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = FALSE;
d2904 1
a2904 1
  for (s = dynobj->sections; s != NULL; s = s->next)
a2905 3
      const char *name;
      bfd_boolean strip;

d2909 4
a2912 7
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);

      strip = FALSE;

      if (strcmp (name, ".plt") == 0)
d2914 2
a2915 11
	  if (s->_raw_size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = TRUE;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = TRUE;
	    }
d2917 1
a2917 1
      else if (strncmp (name, ".rela", 5) == 0)
a2929 1
	      strip = TRUE;
d2941 1
a2941 3
      else if (strcmp (name, ".got") != 0
	       && strcmp (name, ".sdata") != 0
	       && strcmp (name, ".sdata2") != 0)
d2947 1
a2947 1
      if (strip)
d2954 2
a2955 2
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d2959 1
a2959 1
  if (elf_hash_table (info)->dynamic_sections_created)
d2975 1
a2975 1
      if (plt)
d3009 39
d3059 1
a3059 1
  bfd *dynobj;
d3061 1
a3061 1
  struct elf_link_hash_entry **sym_hashes, **sym_hashes_end;
a3063 3
  bfd_signed_vma *local_got_refcounts;
  elf_linker_section_t *sdata;
  elf_linker_section_t *sdata2;
a3064 2
  asection *sgot = NULL;
  asection *srelgot = NULL;
d3078 2
a3079 1
  if ((sdata = elf_linker_section (abfd, LINKER_SECTION_SDATA)) == NULL)
d3081 5
a3085 2
      sdata = ppc_elf_create_linker_section (abfd, info, LINKER_SECTION_SDATA);
      if (!sdata)
d3089 1
a3089 1
  if ((sdata2 = elf_linker_section (abfd, LINKER_SECTION_SDATA2)) == NULL)
d3091 5
a3095 2
      sdata2 = ppc_elf_create_linker_section (abfd, info, LINKER_SECTION_SDATA2);
      if (!sdata2)
a3098 1
  dynobj = elf_hash_table (info)->dynobj;
a3099 2
  local_got_refcounts = elf_local_got_refcounts (abfd);

a3100 4
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof (Elf32_External_Sym);
  if (!elf_bad_symtab (abfd))
    sym_hashes_end -= symtab_hdr->sh_info;

d3107 1
d3109 1
d3122 1
a3122 1
	  if (sgot == NULL)
d3124 3
a3126 4
	      if (dynobj == NULL)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      sgot = ppc_elf_create_got (dynobj, info);
	      if (sgot == NULL)
d3131 2
a3132 1
      switch (ELF32_R_TYPE (rel->r_info))
d3134 33
d3173 1
a3173 2

	  if (sgot == NULL)
d3175 3
a3177 4
	      if (dynobj == NULL)
		elf_hash_table (info)->dynobj = dynobj = abfd;
	      sgot = ppc_elf_create_got (dynobj, info);
	      if (sgot == NULL)
a3179 21

	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

d3182 2
a3183 13
	      if (h->got.refcount == 0)
		{
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1)
		    if (!bfd_elf32_link_record_dynamic_symbol (info, h))
		      return FALSE;

		  /* Allocate space in the .got.  */
		  sgot->_raw_size += 4;
		  /* Allocate relocation space.  */
		  srelgot->_raw_size += sizeof (Elf32_External_Rela);
		}
	      h->got.refcount++;
d3186 3
a3188 26
	    {
	      /* This is a global offset table entry for a local symbol.  */
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;

		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts
		    = (bfd_signed_vma *) bfd_zalloc (abfd, size);
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      if (local_got_refcounts[r_symndx] == 0)
		{
		  sgot->_raw_size += 4;

		  /* If we are generating a shared object, we need to
                     output a R_PPC_RELATIVE reloc so that the
                     dynamic linker can adjust this GOT entry.  */
		  if (info->shared)
		    srelgot->_raw_size += sizeof (Elf32_External_Rela);
		}
	      local_got_refcounts[r_symndx]++;
	    }
d3195 1
a3195 3
	      ((*_bfd_error_handler)
	       (_("%s: relocation %s cannot be used when making a shared object"),
		bfd_archive_filename (abfd), "R_PPC_EMB_SDAI16"));
d3198 2
a3199 21

	  if (srelgot == NULL && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

	  if (!bfd_elf32_create_pointer_linker_section (abfd, info, sdata, h, rel))
a3200 1

d3207 1
a3207 3
	      ((*_bfd_error_handler)
	       (_("%s: relocation %s cannot be used when making a shared object"),
		bfd_archive_filename (abfd), "R_PPC_EMB_SDA2I16"));
d3210 2
a3211 21

	  if (srelgot == NULL && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return FALSE;
		}
	    }

	  if (!bfd_elf32_create_pointer_linker_section (abfd, info, sdata2, h, rel))
a3212 1

d3218 6
d3226 1
a3226 4
	      ((*_bfd_error_handler)
	       (_("%s: relocation %s cannot be used when making a shared object"),
		bfd_archive_filename (abfd),
		ppc_elf_howto_table[(int) ELF32_R_TYPE (rel->r_info)]->name));
d3233 1
d3241 1
a3241 1
             actually build the entry in adjust_dynamic_symbol,
a3253 6
	  /* Make sure this symbol is output as a dynamic symbol.  */
	  if (h->dynindx == -1)
	    {
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
d3265 28
d3313 19
d3346 21
a3366 1
	default:
d3391 1
a3391 1
		  sreloc = bfd_get_section_by_name (dynobj, name);
d3396 1
a3396 1
		      sreloc = bfd_make_section (dynobj, name);
d3402 4
a3405 2
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
d3438 1
a3438 1
		       bfd_alloc (elf_hash_table (info)->dynobj, sizeof *p));
d3497 2
a3498 1
/* Update the got entry reference counts for the section being removed.  */
d3503 1
a3503 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d3507 1
a3511 2
  unsigned long r_symndx;
  struct elf_link_hash_entry *h;
d3515 1
d3522 148
a3669 8
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_PPC_GOT16:
      case R_PPC_GOT16_LO:
      case R_PPC_GOT16_HI:
      case R_PPC_GOT16_HA:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
d3671 72
a3742 10
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount--;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx]--;
	  }
        break;
d3744 33
a3776 13
      case R_PPC_PLT32:
      case R_PPC_PLTREL24:
      case R_PPC_PLT16_LO:
      case R_PPC_PLT16_HI:
      case R_PPC_PLT16_HA:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount--;
	  }
	/* Fall through */
d3778 43
a3820 5
      default:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct ppc_elf_dyn_relocs **pp, *p;
d3822 3
a3824 1
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d3826 2
a3827 9
	    for (pp = &ppc_elf_hash_entry (h)->dyn_relocs;
		 (p = *pp) != NULL;
		 pp = &p->next)
	      if (p->sec == sec)
		{
		  if (--p->count == 0)
		    *pp = p->next;
		  break;
		}
a3828 2
	break;
      }
d3830 9
d3911 1
a3911 1
  bfd *dynobj;
d3918 2
a3919 2
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
a3922 2
      asection *splt;
      asection *srela;
d3935 1
a3935 4

      splt = bfd_get_section_by_name (dynobj, ".plt");
      srela = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && srela != NULL);
d3941 2
a3942 2
      rela.r_offset = (splt->output_section->vma
		       + splt->output_offset
d3950 2
a3951 1
      loc = srela->contents + reloc_index * sizeof (Elf32_External_Rela);
a3968 43
  if (h->got.offset != (bfd_vma) -1)
    {
      asection *sgot;
      asection *srela;
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
         up.  */

      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srela != NULL);

      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + (h->got.offset &~ (bfd_vma) 1));

      /* If this is a -Bsymbolic link, and the symbol is defined
	 locally, we just want to emit a RELATIVE reloc.  The entry in
	 the global offset table will already have been initialized in
	 the relocate_section function.  */
      if (info->shared
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  rela.r_info = ELF32_R_INFO (0, R_PPC_RELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
      else
	{
	  BFD_ASSERT ((h->got.offset & 1) == 0);
	  rela.r_info = ELF32_R_INFO (h->dynindx, R_PPC_GLOB_DAT);
	  rela.r_addend = 0;
	}

      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

d3983 2
a3984 3
      if (h->size <= elf_gp_size (dynobj))
	s = bfd_get_section_by_name (h->root.u.def.section->owner,
				     ".rela.sbss");
d3986 1
a3986 2
	s = bfd_get_section_by_name (h->root.u.def.section->owner,
				     ".rela.bss");
d4019 1
a4019 2
  bfd *dynobj = elf_hash_table (info)->dynobj;
  asection *sgot = bfd_get_section_by_name (dynobj, ".got");
d4025 2
a4026 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
d4028 1
a4028 1
  if (elf_hash_table (info)->dynamic_sections_created)
a4029 1
      asection *splt;
d4032 1
a4032 2
      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);
d4039 1
a4039 2
	  const char *name;
	  bfd_boolean size;
d4041 1
a4041 1
	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);
d4045 8
a4052 5
	    case DT_PLTGOT:   name = ".plt";	  size = FALSE; break;
	    case DT_PLTRELSZ: name = ".rela.plt"; size = TRUE;  break;
	    case DT_JMPREL:   name = ".rela.plt"; size = FALSE; break;
	    default:	      name = NULL;	  size = FALSE; break;
	    }
d4054 4
a4057 3
	  if (name != NULL)
	    {
	      asection *s;
d4059 2
a4060 16
	      s = bfd_get_section_by_name (output_bfd, name);
	      if (s == NULL)
		dyn.d_un.d_val = 0;
	      else
		{
		  if (! size)
		    dyn.d_un.d_ptr = s->vma;
		  else
		    {
		      if (s->_cooked_size != 0)
			dyn.d_un.d_val = s->_cooked_size;
		      else
			dyn.d_un.d_val = s->_raw_size;
		    }
		}
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d4062 2
d4069 1
a4069 1
  if (sgot)
d4071 1
a4071 1
      unsigned char *contents = sgot->contents;
d4075 1
a4075 1
	bfd_put_32 (output_bfd, (bfd_vma) 0, contents+4);
d4079 1
a4079 1
		    contents+4);
d4081 1
a4081 1
      elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;
d4128 7
a4134 7
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
  bfd *dynobj = elf_hash_table (info)->dynobj;
  elf_linker_section_t *sdata = NULL;
  elf_linker_section_t *sdata2 = NULL;
  Elf_Internal_Rela *rel = relocs;
  Elf_Internal_Rela *relend = relocs + input_section->reloc_count;
a4135 2
  asection *splt;
  asection *sgot;
a4137 7
  long insn;

  if (dynobj)
    {
      sdata = elf_linker_section (dynobj, LINKER_SECTION_SDATA);
      sdata2 = elf_linker_section (dynobj, LINKER_SECTION_SDATA2);
    }
d4154 1
d4156 4
a4159 8

  splt = sgot = NULL;
  if (dynobj != NULL)
    {
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got");
    }

d4162 7
a4168 8
      enum elf_ppc_reloc_type r_type	= (enum elf_ppc_reloc_type)ELF32_R_TYPE (rel->r_info);
      bfd_vma offset			= rel->r_offset;
      bfd_vma addend			= rel->r_addend;
      bfd_reloc_status_type r		= bfd_reloc_other;
      Elf_Internal_Sym *sym		= (Elf_Internal_Sym *) 0;
      asection *sec			= (asection *) 0;
      struct elf_link_hash_entry *h	= (struct elf_link_hash_entry *) 0;
      const char *sym_name		= (const char *) 0;
d4172 12
a4183 16
      int will_become_local;

      /* Unknown relocation handling */
      if ((unsigned) r_type >= (unsigned) R_PPC_max
	  || !ppc_elf_howto_table[(int) r_type])
	{
	  (*_bfd_error_handler) (_("%s: unknown relocation type %d"),
				 bfd_archive_filename (input_bfd),
				 (int) r_type);

	  bfd_set_error (bfd_error_bad_value);
	  ret = FALSE;
	  continue;
	}

      howto = ppc_elf_howto_table[(int) r_type];
a4184 1

d4189 1
a4189 1
	  sym_name = "<local symbol>";
a4191 1
	  addend = rel->r_addend;
d4193 1
a4193 1
	  will_become_local = 1;
d4205 1
a4205 1

d4210 6
a4215 71
	      if (((r_type == R_PPC_PLT32
		    || r_type == R_PPC_PLTREL24)
		   && splt != NULL
		   && h->plt.offset != (bfd_vma) -1)
		  || (r_type == R_PPC_LOCAL24PC
		      && sec->output_section == NULL)
		  || ((r_type == R_PPC_GOT16
		       || r_type == R_PPC_GOT16_LO
		       || r_type == R_PPC_GOT16_HI
		       || r_type == R_PPC_GOT16_HA)
		      && elf_hash_table (info)->dynamic_sections_created
		      && (! info->shared || ! will_become_local))
		  || (info->shared
 		      && ! will_become_local
		      && ((input_section->flags & SEC_ALLOC) != 0
			  /* Testing SEC_DEBUGGING here may be wrong.
                             It's here to avoid a crash when
                             generating a shared library with DWARF
                             debugging information.  */
			  || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
		      && (r_type == R_PPC_ADDR32
			  || r_type == R_PPC_ADDR24
			  || r_type == R_PPC_ADDR16
			  || r_type == R_PPC_ADDR16_LO
			  || r_type == R_PPC_ADDR16_HI
			  || r_type == R_PPC_ADDR16_HA
			  || r_type == R_PPC_ADDR14
			  || r_type == R_PPC_ADDR14_BRTAKEN
			  || r_type == R_PPC_ADDR14_BRNTAKEN
			  || r_type == R_PPC_COPY
			  || r_type == R_PPC_GLOB_DAT
			  || r_type == R_PPC_JMP_SLOT
			  || r_type == R_PPC_UADDR32
			  || r_type == R_PPC_UADDR16
			  || r_type == R_PPC_SDAREL16
			  || r_type == R_PPC_EMB_NADDR32
			  || r_type == R_PPC_EMB_NADDR16
			  || r_type == R_PPC_EMB_NADDR16_LO
			  || r_type == R_PPC_EMB_NADDR16_HI
			  || r_type == R_PPC_EMB_NADDR16_HA
			  || r_type == R_PPC_EMB_SDAI16
			  || r_type == R_PPC_EMB_SDA2I16
			  || r_type == R_PPC_EMB_SDA2REL
			  || r_type == R_PPC_EMB_SDA21
			  || r_type == R_PPC_EMB_MRKREF
			  || r_type == R_PPC_EMB_BIT_FLD
			  || r_type == R_PPC_EMB_RELSDA
			  || ((r_type == R_PPC_REL24
			       || r_type == R_PPC_REL32
			       || r_type == R_PPC_REL14
			       || r_type == R_PPC_REL14_BRTAKEN
			       || r_type == R_PPC_REL14_BRNTAKEN
			       || r_type == R_PPC_RELATIVE)
			      && strcmp (h->root.root.string,
					 "_GLOBAL_OFFSET_TABLE_") != 0))))
		{
		  /* In these cases, we don't need the relocation
                     value.  We check specially because in some
                     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
	      else if (sec->output_section == NULL)
		{
                  (*_bfd_error_handler)
                    (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
                     bfd_archive_filename (input_bfd), h->root.root.string,
                     bfd_get_section_name (input_bfd, input_section));
		  relocation = 0;
		}
d4222 1
a4222 1
	    relocation = 0;
d4226 1
a4226 1
	    relocation = 0;
d4229 5
a4233 8
	      if (! (*info->callbacks->undefined_symbol) (info,
							 h->root.root.string,
							 input_bfd,
							 input_section,
							 rel->r_offset,
							 (!info->shared
							  || info->no_undefined
							  || ELF_ST_VISIBILITY (h->other))))
d4235 214
a4448 1
	      relocation = 0;
d4450 33
d4485 6
a4490 1
      switch ((int) r_type)
d4493 3
a4495 3
	  (*_bfd_error_handler) (_("%s: unknown relocation type %d for symbol %s"),
				 bfd_archive_filename (input_bfd),
				 (int) r_type, sym_name);
d4501 5
a4505 1
	case (int) R_PPC_NONE:
d4508 173
d4682 1
a4682 1
	case (int) R_PPC_LOCAL24PC:
d4701 7
d4710 23
a4732 3
	case (int) R_PPC_REL24:
	case (int) R_PPC_REL32:
	case (int) R_PPC_REL14:
d4743 13
a4755 9
	case (int) R_PPC_ADDR32:
	case (int) R_PPC_ADDR24:
	case (int) R_PPC_ADDR16:
	case (int) R_PPC_ADDR16_LO:
	case (int) R_PPC_ADDR16_HI:
	case (int) R_PPC_ADDR16_HA:
	case (int) R_PPC_ADDR14:
	case (int) R_PPC_UADDR32:
	case (int) R_PPC_UADDR16:
a4757 2
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
d4784 1
a4784 1
		  sreloc = bfd_get_section_by_name (dynobj, name);
d4805 1
a4879 126

	  /* Arithmetic adjust relocations that aren't going into a
	     shared object.  */
	  if (r_type == R_PPC_ADDR16_HA
	      /* It's just possible that this symbol is a weak symbol
		 that's not actually defined anywhere. In that case,
		 'sec' would be NULL, and we should leave the symbol
		 alone (it will be set to zero elsewhere in the link).  */
	      && sec != NULL)
	    {
	      addend += ((relocation + addend) & 0x8000) << 1;
	    }
	  break;

	/* Branch taken prediction relocations.  */
	case (int) R_PPC_ADDR14_BRTAKEN:
	case (int) R_PPC_REL14_BRTAKEN:
	  insn = bfd_get_32 (output_bfd, contents + offset);
	  if ((relocation - offset) & 0x8000)
	    insn &= ~BRANCH_PREDICT_BIT;
	  else
	    insn |= BRANCH_PREDICT_BIT;
	  bfd_put_32 (output_bfd, (bfd_vma) insn, contents + offset);
	  break;

	/* Branch not taken predicition relocations.  */
	case (int) R_PPC_ADDR14_BRNTAKEN:
	case (int) R_PPC_REL14_BRNTAKEN:
	  insn = bfd_get_32 (output_bfd, contents + offset);
	  if ((relocation - offset) & 0x8000)
	    insn |= BRANCH_PREDICT_BIT;
	  else
	    insn &= ~BRANCH_PREDICT_BIT;
	  bfd_put_32 (output_bfd, (bfd_vma) insn, contents + offset);
	  break;

	/* GOT16 relocations.  */
	case (int) R_PPC_GOT16:
	case (int) R_PPC_GOT16_LO:
	case (int) R_PPC_GOT16_HI:
	case (int) R_PPC_GOT16_HA:
	  /* Relocation is to the entry for this symbol in the global
             offset table.  */
	  BFD_ASSERT (sgot != NULL);

	  if (h != NULL)
	    {
	      bfd_vma off;

	      off = h->got.offset;
	      BFD_ASSERT (off != (bfd_vma) -1);

	      if (! elf_hash_table (info)->dynamic_sections_created
		  || (info->shared
		      && SYMBOL_REFERENCES_LOCAL (info, h)))
		{
		  /* This is actually a static link, or it is a
                     -Bsymbolic link and the symbol is defined
                     locally.  We must initialize this entry in the
                     global offset table.  Since the offset must
                     always be a multiple of 4, we use the least
                     significant bit to record whether we have
                     initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_32 (output_bfd, relocation,
				  sgot->contents + off);
		      h->got.offset |= 1;
		    }
		}

	      relocation = sgot->output_offset + off - 4;
	    }
	  else
	    {
	      bfd_vma off;

	      BFD_ASSERT (local_got_offsets != NULL
			  && local_got_offsets[r_symndx] != (bfd_vma) -1);

	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 4.  We use
		 the least significant bit to record whether we have
		 already processed this entry.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{

		  if (info->shared)
		    {
		      asection *srelgot;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;

		      /* We need to generate a R_PPC_RELATIVE reloc
			 for the dynamic linker.  */
		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (srelgot != NULL);

		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset
					 + off);
		      outrel.r_info = ELF32_R_INFO (0, R_PPC_RELATIVE);
		      outrel.r_addend = relocation;
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		      relocation = 0;
		    }

		  bfd_put_32 (output_bfd, relocation, sgot->contents + off);
		  local_got_offsets[r_symndx] |= 1;
		}

	      relocation = sgot->output_offset + off - 4;
	    }
	  if (r_type == R_PPC_GOT16_HA)
	    addend += ((relocation + addend) & 0x8000) << 1;
d4883 7
a4889 5
	case (int) R_PPC_EMB_SDAI16:
	  BFD_ASSERT (sdata != NULL);
	  relocation = bfd_elf32_finish_pointer_linker_section (output_bfd, input_bfd, info,
								sdata, h, relocation, rel,
								R_PPC_RELATIVE);
d4893 7
a4899 5
	case (int) R_PPC_EMB_SDA2I16:
	  BFD_ASSERT (sdata2 != NULL);
	  relocation = bfd_elf32_finish_pointer_linker_section (output_bfd, input_bfd, info,
								sdata2, h, relocation, rel,
								R_PPC_RELATIVE);
d4906 1
a4906 1
	case (int) R_PPC_TOC16:			/* phony GOT16 relocations */
d4915 1
a4915 1
	case (int) R_PPC_PLTREL24:
d4921 1
a4921 1
	      || splt == NULL)
d4929 3
a4931 2
	  relocation = (splt->output_section->vma
			+ splt->output_offset
d4936 1
a4936 1
	case (int) R_PPC_SDAREL16:
d4939 1
d4951 1
a4951 1
				       ppc_elf_howto_table[(int) r_type]->name,
d4954 4
a4957 3
	    addend -= (sdata->sym_hash->root.u.def.value
		       + sdata->sym_hash->root.u.def.section->output_section->vma
		       + sdata->sym_hash->root.u.def.section->output_offset);
d4961 2
a4962 2
	/* relocate against _SDA2_BASE_ */
	case (int) R_PPC_EMB_SDA2REL:
d4965 1
d4975 1
a4975 1
				       ppc_elf_howto_table[(int) r_type]->name,
d4982 4
a4985 3
	    addend -= (sdata2->sym_hash->root.u.def.value
		       + sdata2->sym_hash->root.u.def.section->output_section->vma
		       + sdata2->sym_hash->root.u.def.section->output_offset);
d4990 2
a4991 2
	case (int) R_PPC_EMB_SDA21:
	case (int) R_PPC_EMB_RELSDA:
d4994 1
d5005 4
a5008 3
		addend -= (sdata->sym_hash->root.u.def.value
			   + sdata->sym_hash->root.u.def.section->output_section->vma
			   + sdata->sym_hash->root.u.def.section->output_offset);
d5015 4
a5018 3
		addend -= (sdata2->sym_hash->root.u.def.value
			   + sdata2->sym_hash->root.u.def.section->output_section->vma
			   + sdata2->sym_hash->root.u.def.section->output_offset);
d5032 1
a5032 1
				       ppc_elf_howto_table[(int) r_type]->name,
d5042 1
a5042 1
		insn = bfd_get_32 (output_bfd, contents + offset);
d5044 1
a5044 1
		bfd_put_32 (output_bfd, (bfd_vma) insn, contents + offset);
d5050 4
a5053 8
	case (int) R_PPC_SECTOFF:
	case (int) R_PPC_SECTOFF_LO:
	case (int) R_PPC_SECTOFF_HI:
	  BFD_ASSERT (sec != (asection *) 0);
	  addend -= sec->output_section->vma;
	  break;

	case (int) R_PPC_SECTOFF_HA:
a5055 1
	  addend += ((relocation + addend) & 0x8000) << 1;
d5058 6
a5063 5
	/* Negative relocations */
	case (int) R_PPC_EMB_NADDR32:
	case (int) R_PPC_EMB_NADDR16:
	case (int) R_PPC_EMB_NADDR16_LO:
	case (int) R_PPC_EMB_NADDR16_HI:
d5067 20
a5086 28
	case (int) R_PPC_EMB_NADDR16_HA:
	  addend -= 2 * relocation;
	  addend += ((relocation + addend) & 0x8000) << 1;
	  break;

	/* NOP relocation that prevents garbage collecting linkers from omitting a
	   reference.  */
	case (int) R_PPC_EMB_MRKREF:
	  continue;

	case (int) R_PPC_COPY:
	case (int) R_PPC_GLOB_DAT:
	case (int) R_PPC_JMP_SLOT:
	case (int) R_PPC_RELATIVE:
	case (int) R_PPC_PLT32:
	case (int) R_PPC_PLTREL32:
	case (int) R_PPC_PLT16_LO:
	case (int) R_PPC_PLT16_HI:
	case (int) R_PPC_PLT16_HA:
	case (int) R_PPC_EMB_RELSEC16:
	case (int) R_PPC_EMB_RELST_LO:
	case (int) R_PPC_EMB_RELST_HI:
	case (int) R_PPC_EMB_RELST_HA:
	case (int) R_PPC_EMB_BIT_FLD:
	  (*_bfd_error_handler) (_("%s: Relocation %s is not yet supported for symbol %s."),
				 bfd_archive_filename (input_bfd),
				 ppc_elf_howto_table[(int) r_type]->name,
				 sym_name);
d5091 7
d5099 20
a5118 4
	case (int) R_PPC_GNU_VTINHERIT:
	case (int) R_PPC_GNU_VTENTRY:
	  /* These are no-ops in the end.  */
	  continue;
d5127 1
a5127 1
	       (long) offset,
d5131 13
d5148 1
a5148 1
				    offset,
d5152 1
a5152 3
      if (r == bfd_reloc_ok)
	;
      else if (r == bfd_reloc_overflow)
d5154 3
a5156 3
	  const char *name;

	  if (h != NULL)
d5158 4
a5161 1
	      if (h->root.type == bfd_link_hash_undefweak
d5173 8
a5180 1
	      name = h->root.root.string;
d5184 6
a5189 7
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		continue;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
a5190 9

	  if (! (*info->callbacks->reloc_overflow) (info,
						   name,
						   howto->name,
						   (bfd_vma) 0,
						   input_bfd,
						   input_section,
						   offset))
	    return FALSE;
a5191 2
      else
	ret = FALSE;
a5617 1
#define bfd_elf32_bfd_final_link		_bfd_elf32_gc_common_final_link
@


1.63
log
@	* elf32-ppc.c (struct ppc_elf_dyn_relocs): Define.
	(struct ppc_elf_link_hash_entry): Define.
	(ppc_elf_hash_entry): New function.
	(struct ppc_elf_link_hash_table): Define.
	(ppc_elf_hash_table): New function.
	(ppc_elf_link_hash_newfunc): New function.
	(ppc_elf_link_hash_table_create): New function.
	(ppc_elf_copy_indirect_symbol): New function.
	(allocate_dynrelocs): New function.
	(readonly_dynrelocs): New function.
	(ppc_elf_size_dynamic_sections): Allocate space for dynamic
	relocs and determine DT_TEXTREL.
	(ppc_elf_check_relocs): Don't do that here, just count the
	dynamic relocs.
	(ppc_elf_gc_sweep_hook): Discard any dynamic relocs against the
	removed section.
	(bfd_elf32_bfd_link_hash_table_create): Define.
	(elf_backend_copy_indirect_symbol): Define.
@
text
@d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d113 3
a115 3
#define BRANCH_PREDICT_BIT 0x200000		/* branch prediction bit for branch taken relocs */
#define RA_REGISTER_MASK 0x001f0000		/* mask to set RA in memory instructions */
#define RA_REGISTER_SHIFT 16			/* value to shift register by to insert RA */
d884 1
a884 1
  /* 32 bit value resulting from the addend minus the symbol */
d899 1
a899 1
  /* 16 bit value resulting from the addend minus the symbol */
d914 1
a914 1
  /* 16 bit value resulting from the addend minus the symbol */
d929 1
a929 1
  /* The high order 16 bits of the addend minus the symbol */
d963 1
a963 1
     _SDA_BASE_ for that relocation */
d1052 1
a1052 1
  /* GNU extension to record C++ vtable hierarchy */
d1067 1
a1067 1
  /* GNU extension to record C++ vtable member usage */
d1082 1
a1082 1
  /* Phony reloc to handle AIX style TOC entries */
d1132 1
a1132 2
      (ensure it is predicted taken).
*/
d1235 3
a1237 3
                case R_PPC_ADDR14_BRNTAKEN:     /* absolute, predicted not taken */
                case R_PPC_REL14:               /* relative cond. br.  */
                case R_PPC_REL14_BRNTAKEN:      /* rel. cond. br., predicted not taken */
d1270 1
a1270 1
              the relocation indicates the word is not a conditional branch.  */
d1299 1
a1299 1
                      If this is a forward branch, it is problematic.  */
d1307 1
a1307 1
                          insn |= 0x00200000;   /* set the prediction bit */
d1314 1
a1314 1
                  /* Instruction is BCCTRx */
d1318 4
a1321 4
		      If this is a forward branch, it is problematic.
                      Since we can't tell statically if it will branch forward,
                      always set the prediction bit.  */
                      insn |= 0x00200000;   /* set the prediction bit */
d1331 4
a1334 4
		      If this is a forward branch, it is problematic.
                      Since we can't tell statically if it will branch forward,
                      always set the prediction bit.  */
                      insn |= 0x00200000;   /* set the prediction bit */
d1556 2
a1557 1
   object file when linking */
d1567 1
a1567 1
  /* Check if we have the same endianess */
d1577 1
a1577 1
  if (!elf_flags_init (obfd))	/* First call, no flags set */
d1583 1
a1583 1
  else if (new_flags == old_flags)	/* Compatible flags are ok */
d1586 1
a1586 1
  else					/* Incompatible flags */
d1619 1
a1619 1
      /* Do not warn about eabi vs. V.4 mismatch, just or in the bit if any module uses it */
d1625 1
a1625 1
      /* Warn about any other mismatches */
d1698 1
a1698 1
  /* Record the first bfd section that needs the special section */
d1702 1
a1702 1
  /* If this is the first time, create the section */
d2508 1
a2508 1
	/* Indirect .sdata relocation */
d2542 1
a2542 1
	/* Indirect .sdata2 relocation */
d2630 1
a2630 1
	  /* This refers only to functions defined in the shared library */
a3398 1
		   && (!info->symbolic || info->allow_shlib_undefined)
a3488 1

d3614 1
a3614 1
	/* branch taken prediction relocations */
d3625 1
a3625 1
	/* branch not taken predicition relocations */
d3636 1
a3636 1
	/* GOT16 relocations */
d3728 1
a3728 1
	/* Indirect .sdata relocation */
d3736 1
a3736 1
	/* Indirect .sdata2 relocation */
d3776 1
a3776 1
	/* relocate against _SDA_BASE_ */
d3826 1
a3826 1
	/* relocate against either _SDA_BASE_, _SDA2_BASE_, or 0 */
d3883 1
a3883 1
	/* Relocate against the beginning of the section */
d4034 2
a4035 1
/* Support for core dump NOTE sections */
d4049 1
a4049 1
      case 268:		/* Linux/PPC */
d4078 1
a4078 1
      case 128:		/* Linux/PPC elf_prpsinfo */
@


1.62
log
@	* elf32-ppc.c (ppc_elf_check_relocs): Don't set DF_TEXTREL for a
	relocation against a non-allocated readonly section.
@
text
@d36 8
d88 4
d149 143
d2061 59
d2131 1
d2171 39
d2321 6
d2665 3
d2702 24
a2725 3
		  if ((sec->flags & (SEC_READONLY | SEC_ALLOC))
		      == (SEC_READONLY | SEC_ALLOC))
		    info->flags |= DF_TEXTREL;
d2728 12
a2739 1
	      sreloc->_raw_size += sizeof (Elf32_External_Rela);
d2741 1
a2741 6
	      /* FIXME: We should here do what the m68k and i386
		 backends do: if the reloc is pc-relative, record it
		 in case it turns out that the reloc is unnecessary
		 because the symbol is forced local by versioning or
		 we are linking with -Bdynamic.  Fortunately this
		 case is not frequent.  */
d2807 2
d2847 1
a2847 1
	break;
d2850 17
d4434 1
d4443 1
@


1.61
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Adjust addend for GOT16_HA.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.  PLTGOT16_HA too.
@
text
@a2070 1
	  info->flags |= DF_TEXTREL;
d2439 2
a2440 1
		  if (sec->flags & SEC_READONLY)
@


1.60
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Reorganize dynamic reloc
	code a little.  Comment on dynamic relocs against section symbols.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d3417 2
d3951 1
a3951 1
      
d3962 1
a3962 1
      
d4016 1
a4016 1
  
d4076 1
a4076 1
  
d4086 1
a4086 1
  
d4089 1
a4089 1
    
@


1.59
log
@Comment typo fixes.
@
text
@d3224 2
d3227 1
a3227 4
		    {
		      outrel.r_info = ELF32_R_INFO (0, R_PPC_RELATIVE);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
d3241 2
a3242 1
		      if (sec != NULL && bfd_is_abs_section (sec))
d3253 5
a3271 1
		      outrel.r_addend = relocation + rel->r_addend;
@


1.58
log
@Fix typo in ChangeLog entry.
Add paranoia checks to .PPC.EMB.apuinfo merging code.
@
text
@d961 1
a961 1
   If all of the following conditions are TRUE, the next instruction
@


1.57
log
@Fix the merging of .PPC.EMB.apuinfo sections.  Add a test to make sure that
the fix continues to work.
@
text
@d3904 3
d4029 1
a4029 1
  return strcmp (asec->name, APUINFO_SECTION_NAME) == 0;
d4048 3
@


1.56
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3786 297
d4132 3
@


1.55
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d40 6
a45 4
static void ppc_elf_howto_init PARAMS ((void));
static int ppc_elf_sort_rela PARAMS ((const PTR, const PTR));
static boolean ppc_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, boolean *));
d48 10
a57 7
static boolean ppc_elf_object_p PARAMS ((bfd *));
static boolean ppc_elf_set_private_flags PARAMS ((bfd *, flagword));
static boolean ppc_elf_merge_private_bfd_data PARAMS ((bfd *, bfd *));

static int ppc_elf_additional_program_headers PARAMS ((bfd *));
static boolean ppc_elf_modify_segment_map PARAMS ((bfd *));

d60 1
a60 1
static boolean ppc_elf_create_dynamic_sections
d62 3
a64 5

static boolean ppc_elf_section_from_shdr PARAMS ((bfd *,
						  Elf_Internal_Shdr *,
						  const char *));
static boolean ppc_elf_fake_sections
a65 1

d67 1
a67 2
  PARAMS ((bfd *abfd,
	   struct bfd_link_info *info,
d69 25
a93 45

static boolean ppc_elf_check_relocs PARAMS ((bfd *,
					     struct bfd_link_info *,
					     asection *,
					     const Elf_Internal_Rela *));

static asection * ppc_elf_gc_mark_hook PARAMS ((asection *sec,
						struct bfd_link_info *info,
						Elf_Internal_Rela *rel,
						struct elf_link_hash_entry *h,
						Elf_Internal_Sym *sym));

static boolean ppc_elf_gc_sweep_hook PARAMS ((bfd *abfd,
					      struct bfd_link_info *info,
					      asection *sec,
					      const Elf_Internal_Rela *relocs));

static boolean ppc_elf_adjust_dynamic_symbol PARAMS ((struct bfd_link_info *,
						      struct elf_link_hash_entry *));

static boolean ppc_elf_size_dynamic_sections PARAMS ((bfd *, struct bfd_link_info *));

static boolean ppc_elf_relocate_section PARAMS ((bfd *,
						 struct bfd_link_info *info,
						 bfd *,
						 asection *,
						 bfd_byte *,
						 Elf_Internal_Rela *relocs,
						 Elf_Internal_Sym *local_syms,
						 asection **));

static boolean ppc_elf_add_symbol_hook  PARAMS ((bfd *,
						 struct bfd_link_info *,
						 const Elf_Internal_Sym *,
						 const char **,
						 flagword *,
						 asection **,
						 bfd_vma *));

static boolean ppc_elf_finish_dynamic_symbol PARAMS ((bfd *,
						      struct bfd_link_info *,
						      struct elf_link_hash_entry *,
						      Elf_Internal_Sym *));

static boolean ppc_elf_finish_dynamic_sections PARAMS ((bfd *, struct bfd_link_info *));
d96 1
a96 1
static boolean ppc_elf_grok_prstatus
d98 1
a98 1
static boolean ppc_elf_grok_psinfo
d145 1
a145 1
	 false,			/* pc_relative */
d150 1
a150 1
	 false,			/* partial_inplace */
d153 1
a153 1
	 false),		/* pcrel_offset */
d160 1
a160 1
	 false,			/* pc_relative */
d165 1
a165 1
	 false,			/* partial_inplace */
d168 1
a168 1
	 false),		/* pcrel_offset */
d176 1
a176 1
	 false,			/* pc_relative */
d181 1
a181 1
	 false,			/* partial_inplace */
d184 1
a184 1
	 false),		/* pcrel_offset */
d191 1
a191 1
	 false,			/* pc_relative */
d196 1
a196 1
	 false,			/* partial_inplace */
d199 1
a199 1
	 false),		/* pcrel_offset */
d206 1
a206 1
	 false,			/* pc_relative */
d211 1
a211 1
	 false,			/* partial_inplace */
d214 1
a214 1
	 false),		/* pcrel_offset */
d221 1
a221 1
	 false,			/* pc_relative */
d226 1
a226 1
	 false,			/* partial_inplace */
d229 1
a229 1
	 false),		/* pcrel_offset */
d237 1
a237 1
	 false,			/* pc_relative */
d242 1
a242 1
	 false,			/* partial_inplace */
d245 1
a245 1
	 false),		/* pcrel_offset */
d253 1
a253 1
	 false,			/* pc_relative */
d258 1
a258 1
	 false,			/* partial_inplace */
d261 1
a261 1
	 false),		/* pcrel_offset */
d270 1
a270 1
	 false,			/* pc_relative */
d275 1
a275 1
	 false,			/* partial_inplace */
d278 1
a278 1
	 false),		/* pcrel_offset */
d287 1
a287 1
	 false,			/* pc_relative */
d292 1
a292 1
	 false,			/* partial_inplace */
d295 1
a295 1
	 false),		/* pcrel_offset */
d302 1
a302 1
	 true,			/* pc_relative */
d307 1
a307 1
	 false,			/* partial_inplace */
d310 1
a310 1
	 true),			/* pcrel_offset */
d317 1
a317 1
	 true,			/* pc_relative */
d322 1
a322 1
	 false,			/* partial_inplace */
d325 1
a325 1
	 true),			/* pcrel_offset */
d334 1
a334 1
	 true,			/* pc_relative */
d339 1
a339 1
	 false,			/* partial_inplace */
d342 1
a342 1
	 true),			/* pcrel_offset */
d351 1
a351 1
	 true,			/* pc_relative */
d356 1
a356 1
	 false,			/* partial_inplace */
d359 1
a359 1
	 true),			/* pcrel_offset */
d367 1
a367 1
	 false,			/* pc_relative */
d372 1
a372 1
	 false,			/* partial_inplace */
d375 1
a375 1
	 false),		/* pcrel_offset */
d383 1
a383 1
	 false,			/* pc_relative */
d388 1
a388 1
	 false,			/* partial_inplace */
d391 1
a391 1
	 false),		/* pcrel_offset */
d399 1
a399 1
	 false,			/* pc_relative */
d404 1
a404 1
	 false,			/* partial_inplace */
d407 1
a407 1
	 false),		 /* pcrel_offset */
d415 1
a415 1
	 false,			/* pc_relative */
d420 1
a420 1
	 false,			/* partial_inplace */
d423 1
a423 1
	 false),		/* pcrel_offset */
d431 1
a431 1
	 true,			/* pc_relative */
d436 1
a436 1
	 false,			/* partial_inplace */
d439 1
a439 1
	 true),			/* pcrel_offset */
d450 1
a450 1
	 false,			/* pc_relative */
d455 1
a455 1
	 false,			/* partial_inplace */
d458 1
a458 1
	 false),		/* pcrel_offset */
d466 1
a466 1
	 false,			/* pc_relative */
d471 1
a471 1
	 false,			/* partial_inplace */
d474 1
a474 1
	 false),		/* pcrel_offset */
d481 1
a481 1
	 false,			/* pc_relative */
d486 1
a486 1
	 false,			/* partial_inplace */
d489 1
a489 1
	 false),		/* pcrel_offset */
d498 1
a498 1
	 false,			/* pc_relative */
d503 1
a503 1
	 false,			/* partial_inplace */
d506 1
a506 1
	 false),		/* pcrel_offset */
d515 1
a515 1
	 true,			/* pc_relative */
d520 1
a520 1
	 false,			/* partial_inplace */
d523 1
a523 1
	 true),			/* pcrel_offset */
d530 1
a530 1
	 false,			/* pc_relative */
d535 1
a535 1
	 false,			/* partial_inplace */
d538 1
a538 1
	 false),		/* pcrel_offset */
d545 1
a545 1
	 false,			/* pc_relative */
d550 1
a550 1
	 false,			/* partial_inplace */
d553 1
a553 1
	 false),		/* pcrel_offset */
d560 1
a560 1
	 true,			/* pc_relative */
d565 1
a565 1
	 false,			/* partial_inplace */
d568 1
a568 1
	 true),			/* pcrel_offset */
d576 1
a576 1
	 false,			/* pc_relative */
d581 1
a581 1
	 false,			/* partial_inplace */
d584 1
a584 1
	 false),		/* pcrel_offset */
d592 1
a592 1
	 true,			/* pc_relative */
d597 1
a597 1
	 false,			/* partial_inplace */
d600 1
a600 1
	 true),			/* pcrel_offset */
d608 1
a608 1
	 false,			/* pc_relative */
d613 1
a613 1
	 false,			/* partial_inplace */
d616 1
a616 1
	 false),		/* pcrel_offset */
d624 1
a624 1
	 false,			/* pc_relative */
d629 1
a629 1
	 false,			/* partial_inplace */
d632 1
a632 1
	 false),		 /* pcrel_offset */
d640 1
a640 1
	 false,			/* pc_relative */
d645 1
a645 1
	 false,			/* partial_inplace */
d648 1
a648 1
	 false),		/* pcrel_offset */
d656 1
a656 1
	 false,			/* pc_relative */
d661 1
a661 1
	 false,			/* partial_inplace */
d664 1
a664 1
	 false),		/* pcrel_offset */
d671 1
a671 1
	 false,			/* pc_relative */
d676 1
a676 1
	 false,			/* partial_inplace */
d679 1
a679 1
	 false),		/* pcrel_offset */
d686 1
a686 1
	 false,			/* pc_relative */
d691 1
a691 1
	 false,			/* partial_inplace */
d694 1
a694 1
	 false),		/* pcrel_offset */
d701 1
a701 1
	 false,			/* pc_relative */
d706 1
a706 1
	 false,			/* partial_inplace */
d709 1
a709 1
	 false),		 /* pcrel_offset */
d716 1
a716 1
	 false,			/* pc_relative */
d721 1
a721 1
	 false,			/* partial_inplace */
d724 1
a724 1
	 false),		/* pcrel_offset */
d734 1
a734 1
	 false,			/* pc_relative */
d739 1
a739 1
	 false,			/* partial_inplace */
d742 1
a742 1
	 false),		/* pcrel_offset */
d749 1
a749 1
	 false,			/* pc_relative */
d754 1
a754 1
	 false,			/* partial_inplace */
d757 1
a757 1
	 false),		/* pcrel_offset */
d764 1
a764 1
	 false,			/* pc_relative */
d769 1
a769 1
	 false,			/* partial_inplace */
d772 1
a772 1
	 false),		/* pcrel_offset */
d779 1
a779 1
	 false,			/* pc_relative */
d784 1
a784 1
	 false,			/* partial_inplace */
d787 1
a787 1
	 false),		/* pcrel_offset */
d796 1
a796 1
	 false,			/* pc_relative */
d801 1
a801 1
	 false,			/* partial_inplace */
d804 1
a804 1
	 false),		/* pcrel_offset */
d813 1
a813 1
	 false,			/* pc_relative */
d818 1
a818 1
	 false,			/* partial_inplace */
d821 1
a821 1
	 false),		/* pcrel_offset */
d830 1
a830 1
	 false,			/* pc_relative */
d835 1
a835 1
	 false,			/* partial_inplace */
d838 1
a838 1
	 false),		/* pcrel_offset */
d846 1
a846 1
	 false,			/* pc_relative */
d851 1
a851 1
	 false,			/* partial_inplace */
d854 1
a854 1
	 false),		/* pcrel_offset */
d863 1
a863 1
	 false,			/* pc_relative */
d868 1
a868 1
	 false,			/* partial_inplace */
d871 1
a871 1
	 false),		/* pcrel_offset */
d887 1
a887 1
	 true,			/* pc_relative */
d892 1
a892 1
	 false,			/* partial_inplace */
d895 1
a895 1
	 false),		/* pcrel_offset */
d902 1
a902 1
	 false,			/* pc_relative */
d907 1
a907 1
	 false,			/* partial_inplace */
d910 1
a910 1
	 false),		/* pcrel_offset */
d917 1
a917 1
	 false,			/* pc_relative */
d922 1
a922 1
	 false,			/* partial_inplace */
d925 1
a925 1
	 false),		/* pcrel_offset */
d932 1
a932 1
	 false,			/* pc_relative */
d937 1
a937 1
	 false,			/* partial_inplace */
d940 1
a940 1
	 false),		/* pcrel_offset */
d961 1
a961 1
   If all of the following conditions are true, the next instruction
d994 1
a994 1
static boolean
d999 1
a999 1
     boolean *again;
d1011 1
a1011 1
  *again = false;
d1022 1
a1022 1
      boolean section_modified;
d1100 1
a1100 1
      section_modified = false;
d1113 1
a1113 1
              boolean skip, modified;
d1117 1
a1117 1
              skip = false;
d1126 1
a1126 1
                      if (r_offset == isec_offset) skip = true;
d1137 1
a1137 1
              modified = false;
d1154 1
a1154 1
                          modified = true;
d1168 1
a1168 1
                      modified = true;
d1181 1
a1181 1
                      modified = true;
d1190 1
a1190 1
		  section_modified = true;
d1225 1
a1225 1
  return true;
d1234 1
a1234 1
  return false;
d1368 1
a1368 1
static boolean
d1383 1
a1383 1
  return true;
d1388 1
a1388 1
static boolean
d1397 2
a1398 2
  elf_flags_init (abfd) = true;
  return true;
d1403 1
a1403 1
static boolean
d1410 1
a1410 1
  boolean error;
d1414 1
a1414 1
    return false;
d1418 1
a1418 1
    return true;
d1424 1
a1424 1
      elf_flags_init (obfd) = true;
d1435 1
a1435 1
      error = false;
d1439 1
a1439 1
	  error = true;
d1447 1
a1447 1
	  error = true;
d1473 1
a1473 1
	  error = true;
d1482 1
a1482 1
	  return false;
d1486 1
a1486 1
  return true;
d1492 1
a1492 1
static boolean
d1502 1
a1502 1
    return false;
d1513 1
a1513 1
  return true;
d1518 1
a1518 1
static boolean
d1530 1
a1530 1
  return true;
d1556 1
a1556 1
      defaults.hole_written_p = false;
d1633 1
a1633 1
static boolean
d1637 1
a1637 1
  return true;
d1668 1
a1668 1
static boolean
d1677 1
a1677 1
    return false;
d1680 1
a1680 1
    return false;
d1688 1
a1688 1
    return false;
d1696 1
a1696 1
	return false;
d1713 1
a1713 1
static boolean
d1763 1
a1763 1
	  return true;
d1770 1
a1770 1
	    return false;
d1817 1
a1817 1
      return true;
d1831 1
a1831 1
      return true;
d1842 1
a1842 1
    return true;
d1893 1
a1893 1
	return false;
d1903 1
a1903 1
  return true;
d1908 1
a1908 1
static boolean
d1915 2
a1916 2
  boolean plt;
  boolean relocs;
d1959 2
a1960 2
  plt = false;
  relocs = false;
d1964 1
a1964 1
      boolean strip;
d1973 1
a1973 1
      strip = false;
d1981 1
a1981 1
	      strip = true;
d1986 1
a1986 1
	      plt = true;
d2002 1
a2002 1
	      strip = true;
d2007 1
a2007 1
	      relocs = true;
d2031 1
a2031 1
	return false;
d2047 1
a2047 1
	    return false;
d2056 1
a2056 1
	    return false;
d2064 1
a2064 1
	    return false;
d2070 1
a2070 1
	    return false;
d2076 1
a2076 1
  return true;
d2083 1
a2083 1
static boolean
d2103 1
a2103 1
    return true;
d2118 1
a2118 1
	return false;
d2125 1
a2125 1
	return false;
d2162 1
a2162 1
		return false;
d2181 1
a2181 1
		return false;
d2200 1
a2200 1
		    return false;
d2211 1
a2211 1
		      return false;
d2232 1
a2232 1
		    return false;
d2256 1
a2256 1
	      return false;
d2274 1
a2274 1
		    return false;
d2279 1
a2279 1
	    return false;
d2290 1
a2290 1
	      return false;
d2308 1
a2308 1
		    return false;
d2313 1
a2313 1
	    return false;
d2326 1
a2326 1
	      return false;
d2349 1
a2349 1
	      return false;
d2356 1
a2356 1
		return false;
d2379 1
a2379 1
	    return false;
d2386 1
a2386 1
	    return false;
d2419 1
a2419 1
		    return false;
d2438 1
a2438 1
			return false;
d2458 1
a2458 1
  return true;
d2503 1
a2503 1
static boolean
d2561 1
a2561 1
  return true;
d2567 1
a2567 1
static boolean
d2598 1
a2598 1
	    return false;
d2609 1
a2609 1
	    return false;
d2620 1
a2620 1
  return true;
d2626 1
a2626 1
static boolean
d2779 1
a2779 1
  return true;
d2784 1
a2784 1
static boolean
d2813 1
a2813 1
	  boolean size;
d2819 4
a2822 4
	    case DT_PLTGOT:   name = ".plt";	  size = false; break;
	    case DT_PLTRELSZ: name = ".rela.plt"; size = true;  break;
	    case DT_JMPREL:   name = ".rela.plt"; size = false; break;
	    default:	      name = NULL;	  size = false; break;
d2866 1
a2866 1
  return true;
d2898 1
a2898 1
static boolean
d2910 1
a2910 1
  Elf_Internal_Shdr *symtab_hdr		  = &elf_tdata (input_bfd)->symtab_hdr;
d2912 6
a2917 6
  bfd *dynobj				  = elf_hash_table (info)->dynobj;
  elf_linker_section_t *sdata		  = (dynobj) ? elf_linker_section (dynobj, LINKER_SECTION_SDATA)  : NULL;
  elf_linker_section_t *sdata2		  = (dynobj) ? elf_linker_section (dynobj, LINKER_SECTION_SDATA2) : NULL;
  Elf_Internal_Rela *rel		  = relocs;
  Elf_Internal_Rela *relend		  = relocs + input_section->reloc_count;
  asection *sreloc			  = NULL;
d2921 1
a2921 1
  boolean ret				  = true;
d2924 6
d2939 1
a2939 1
    return true;
d2978 1
a2978 1
	  ret = false;
d3104 1
a3104 1
		return false;
d3117 1
a3117 1
	  ret = false;
d3137 2
a3138 2
							  true))
		return false;
d3191 1
a3191 1
		    return false;
d3247 1
a3247 1
			  return false;
d3504 1
a3504 1
		ret = false;
d3522 1
a3522 1
	    if (((strncmp (name, ".sdata", 6) == 0	
d3557 1
a3557 1
		ret = false;
d3622 1
a3622 1
	  ret = false;
d3689 1
a3689 1
	    return false;
d3692 1
a3692 1
	ret = false;
d3722 1
a3722 1
static boolean
d3733 1
a3733 1
	return false;
d3754 1
a3754 1
static boolean
d3762 1
a3762 1
	return false;
d3783 1
a3783 1
  return true;
@


1.54
log
@	* Makefile.am: Remove entries for elf32-qnx.[ch].
	* Makefile.in: Regenerate.
	* config.bfd: Change arm-nto to use bfd_elf32_{big|little}arm_vec,
	ppc-nto to use bfd_elf32_powerpc{le}_vec, sh-nto to use
	bfd_elf32_sh{l}_vec, and i386-nto to use bfd_elf32_i386_vec.
	* configure.in: Remove support for bfd_elf32_sh{l}qnx_vec,
	bfd_elf32_powerpc{le}qnx_vec, bfd_elf32_{big|little}armqnx_vec,
	and bfd_elf32_i386qnx_vec, and removed elf32-qnx.lo from other targets.
	bfd_elf32_sh{l}_vec, and i386-nto to use bfd_elf32_i386_vec.
	* configure: Regenerate.
	* elf32-qnx.c: Remove.
	* elf32-qnx.h: Remove.
	* elf.c: Remove calls to QNX specific set_nonloadable_filepos,
	is_contained_by_filepos, and copy_private_bfd_data_p.
	* elf32-i386.c: Remove QNX extended bfd support.
	* elf32-ppc.c: Remove QNX extended bfd support.
	* elf32-sh.c: Remove QNX extended bfd support.
	* elfarm-nabi.c: Remove QNX extended bfd support.
	* targets.c: Remove qnx vectors.
	* elfxx-target.h (elf_backend_set_nonloadable_filepos): Remove
	(elf_backend_is_contained_by_filepos): Remove.
	(elf_backend_copy_private_bfd_data_p): Remove.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@d39 1
a39 1
  PARAMS ((bfd *abfd, arelent *cache_ptr, Elf32_Internal_Rela *dst));
d59 1
a59 1
						  Elf32_Internal_Shdr *,
d62 1
a62 1
  PARAMS ((bfd *, Elf32_Internal_Shdr *, asection *));
d1336 1
a1336 1
     Elf32_Internal_Rela *dst;
d1514 1
a1514 1
     Elf32_Internal_Shdr *hdr;
d1540 1
a1540 1
     Elf32_Internal_Shdr *shdr;
d2667 1
d2696 2
a2697 3
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) srela->contents
				  + reloc_index));
d2719 1
d2752 3
a2754 4
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) srela->contents
				  + srela->reloc_count));
      ++srela->reloc_count;
d2761 1
d2784 2
a2785 4
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
d3183 1
d3284 3
a3286 5
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
					 (((Elf32_External_Rela *)
					   sreloc->contents)
					  + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d3402 1
d3414 3
a3416 5
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
						 (((Elf32_External_Rela *)
						   srelgot->contents)
						  + srelgot->reloc_count));
		      ++srelgot->reloc_count;
@


1.53
log
@	* Makefile.am (BFD32_BACKENDS): Remove elfarmqnx-nabi.lo,
	elf32-i386-fbsd.lo, elf32-i386qnx.lo, elf32-ppcqnx.lo,
	elf32-sh-lin.lo, elf32-sh64-lin.lo, elf32-sh-nbsd.lo,
	elf32-sh64-nbsd.lo, elf32-shqnx.lo.  Add elf32-qnx.lo.
	(BFD32_BACKENDS_CFILES): Likewise for corresponding C files.
	(BFD64_BACKENDS): Remove elf64-sh64-lin.lo, elf64-sh64-nbsd.lo.
	(BFD64_BACKENDS_CFILES): Likewise for corresponding C files.
	(SOURCE_HFILES): Add elf32-qnx.h.
	(BUILD_HFILES): Add bfdver.h.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* configure.in Update bfd vector dependencies.
	* configure: Regenerate.
	* elf32-i386-fbsd.c: Delete.  Move code to elf32-i386.c.
	* elf32-i386qnx.c: Likewise.
	* elf32-ppcqnx.c: Delete.  Move code to elf32-ppc.c.
	* elf32-sh-nbsd.c: Delete.  Move code to elf32-sh.c.
	* elf32-sh-lin.c: Likewise.
	* elf32-shqnx.c: Likewise.
	* elf32-sh64-lin.c: Delete.  Move code to elf32-sh64.c.
	* elf32-sh64-nbsd.c: Likewise.
	* elf64-sh64-lin.c: Delete.  Move code to elf64-sh64.c.
	* elf64-sh64-nbsd.c: Likewise.
	* elfarmqnx-nabi.c: Delete.  Move code to elfarm-nabi.c.
	* elf32-arm.h (ELF_MAXPAGESIZE): Always define.
	* elf32-i386.c: Remove ELF_ARCH and ELF32_I386_C_INCLUDED tests.
	* elf32-ppc.c: Remove ELF32_PPC_C_INCLUDED tests.
	* elf32-qnx.h (elf_backend_set_nonloadable_filepos): Always define.
	(elf_backend_is_contained_by_filepos): Likewise.
	(elf_backend_copy_private_bfd_data_p): Likewise.
	Globalize and move functions to..
	* elf32-qnx.c: ..here.  New file.
	* elf32-sh.c: Remove ELF_ARCH and ELF32_SH_C_INCLUDED tests.  Don't
	emit target vectors when INCLUDE_SHMEDIA.
	* elf32-sh64.c: Remove ELF_ARCH test.  Move TARGET_* etc. defines to
	end of file.
	* elf64-sh64.c: Remove ELF_ARCH test.
	* elfarm-nabi.c: Remove ELFARM_NABI_C_INCLUDED test.
	* po/BLD-POTFILES.in: Regenerate.
	* po/SRC-POTFILES.in: Regenerate.
@
text
@a3852 21

/* QNX support.  */
#include "elf32-qnx.h"

#undef	TARGET_LITTLE_SYM 
#define	TARGET_LITTLE_SYM		bfd_elf32_powerpcleqnx_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-powerpcle-nto"
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_powerpcqnx_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-powerpc-nto"

#define	elf32_bed			elf32_ppc_qnx_bed

#include "elf32-target.h"

#undef	elf_backend_set_nonloadable_filepos
#undef	elf_backend_is_contained_by_filepos
#undef	elf_backend_copy_private_bfd_data_p
#undef	elf32_bed
@


1.52
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Allow ".sbss.*" and
	".sdata.*" for R_PPC_SDAREL16, ".sbss2*" and ".sdata2*" for
	R_PPC_EMB_SDA2REL.  Similarly for R_PPC_EMB_SDA21 and
	R_PPC_EMB_RELSDA.
@
text
@a3851 1
#ifndef ELF32_PPC_C_INCLUDED
a3852 1
#endif
d3854 20
@


1.52.2.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d3852 1
d3854 1
a3855 20
/* QNX support.  */
#include "elf32-qnx.h"

#undef	TARGET_LITTLE_SYM 
#define	TARGET_LITTLE_SYM		bfd_elf32_powerpcleqnx_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-powerpcle-nto"
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_powerpcqnx_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-powerpc-nto"

#define	elf32_bed			elf32_ppc_qnx_bed

#include "elf32-target.h"

#undef	elf_backend_set_nonloadable_filepos
#undef	elf_backend_is_contained_by_filepos
#undef	elf_backend_copy_private_bfd_data_p
#undef	elf32_bed
@


1.52.2.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 14
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
a32 1
#include "elf32-ppc.h"
d36 8
d45 78
a122 10
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_reloc_status_type ppc_elf_unhandled_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);

/* Branch prediction bit for branch taken relocs.  */
#define BRANCH_PREDICT_BIT 0x200000
/* Mask to set RA in memory instructions.  */
#define RA_REGISTER_MASK 0x001f0000
/* Value to shift register by to insert RA.  */
#define RA_REGISTER_SHIFT 16
d126 1
d138 17
a154 281
/* Some nop instructions.  */
#define NOP		0x60000000
#define CROR_151515	0x4def7b82
#define CROR_313131	0x4ffffb82

/* Offset of tp and dtp pointers from start of TLS block.  */
#define TP_OFFSET	0x7000
#define DTP_OFFSET	0x8000


/* Enumeration to specify the special section.  */
enum elf_linker_section_enum
{
  LINKER_SECTION_SDATA,
  LINKER_SECTION_SDATA2
};

/* Sections created by the linker.  */

typedef struct elf_linker_section
{
  /* pointer to the section */
  asection *section;
  /* pointer to the relocations needed for this section */
  asection *rel_section;
  /* pointer to the created symbol hash value */
  struct elf_link_hash_entry *sym_hash;
  /* offset of symbol from beginning of section */
  bfd_vma sym_offset;
} elf_linker_section_t;

/* Linked list of allocated pointer entries.  This hangs off of the
   symbol lists, and provides allows us to return different pointers,
   based on different addend's.  */

typedef struct elf_linker_section_pointers
{
  /* next allocated pointer for this symbol */
  struct elf_linker_section_pointers *next;
  /* offset of pointer from beginning of section */
  bfd_vma offset;
  /* addend used */
  bfd_vma addend;
  /* which linker section this is */
  elf_linker_section_t *lsect;
  /* whether address was written yet */
  bfd_boolean written_address_p;
} elf_linker_section_pointers_t;

struct ppc_elf_obj_tdata
{
  struct elf_obj_tdata elf;

  /* A mapping from local symbols to offsets into the various linker
     sections added.  This is index by the symbol index.  */
  elf_linker_section_pointers_t **linker_section_pointers;
};

#define ppc_elf_tdata(bfd) \
  ((struct ppc_elf_obj_tdata *) (bfd)->tdata.any)

#define elf_local_ptr_offsets(bfd) \
  (ppc_elf_tdata (bfd)->linker_section_pointers)

/* Override the generic function because we store some extras.  */

static bfd_boolean
ppc_elf_mkobject (bfd *abfd)
{
  bfd_size_type amt = sizeof (struct ppc_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

/* The PPC linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct ppc_elf_dyn_relocs
{
  struct ppc_elf_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};

/* PPC ELF linker hash entry.  */

struct ppc_elf_link_hash_entry
{
  struct elf_link_hash_entry elf;

  /* If this symbol is used in the linker created sections, the processor
     specific backend uses this field to map the field into the offset
     from the beginning of the section.  */
  elf_linker_section_pointers_t *linker_section_pointer;

  /* Track dynamic relocs copied for this symbol.  */
  struct ppc_elf_dyn_relocs *dyn_relocs;

  /* Contexts in which symbol is used in the GOT (or TOC).
     TLS_GD .. TLS_TLS bits are or'd into the mask as the
     corresponding relocs are encountered during check_relocs.
     tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to
     indicate the corresponding GOT entry type is not needed.  */
#define TLS_GD		 1	/* GD reloc. */
#define TLS_LD		 2	/* LD reloc. */
#define TLS_TPREL	 4	/* TPREL reloc, => IE. */
#define TLS_DTPREL	 8	/* DTPREL reloc, => LD. */
#define TLS_TLS		16	/* Any TLS reloc.  */
#define TLS_TPRELGD	32	/* TPREL reloc resulting from GD->IE. */
  char tls_mask;
};

#define ppc_elf_hash_entry(ent) ((struct ppc_elf_link_hash_entry *) (ent))

/* PPC ELF linker hash table.  */

struct ppc_elf_link_hash_table
{
  struct elf_link_hash_table elf;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *got;
  asection *relgot;
  asection *plt;
  asection *relplt;
  asection *dynbss;
  asection *relbss;
  asection *dynsbss;
  asection *relsbss;
  elf_linker_section_t *sdata;
  elf_linker_section_t *sdata2;
  asection *sbss;

  /* Shortcut to .__tls_get_addr.  */
  struct elf_link_hash_entry *tls_get_addr;

  /* TLS local dynamic got entry handling.  */
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tlsld_got;

  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};

/* Get the PPC ELF linker hash table from a link_info structure.  */

#define ppc_elf_hash_table(p) \
  ((struct ppc_elf_link_hash_table *) (p)->hash)

/* Create an entry in a PPC ELF linker hash table.  */

static struct bfd_hash_entry *
ppc_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			   struct bfd_hash_table *table,
			   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct ppc_elf_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      ppc_elf_hash_entry (entry)->linker_section_pointer = NULL;
      ppc_elf_hash_entry (entry)->dyn_relocs = NULL;
      ppc_elf_hash_entry (entry)->tls_mask = 0;
    }

  return entry;
}

/* Create a PPC ELF linker hash table.  */

static struct bfd_link_hash_table *
ppc_elf_link_hash_table_create (bfd *abfd)
{
  struct ppc_elf_link_hash_table *ret;

  ret = bfd_zmalloc (sizeof (struct ppc_elf_link_hash_table));
  if (ret == NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd,
				       ppc_elf_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  return &ret->elf.root;
}

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
ppc_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
			      struct elf_link_hash_entry *dir,
			      struct elf_link_hash_entry *ind)
{
  struct ppc_elf_link_hash_entry *edir, *eind;

  edir = (struct ppc_elf_link_hash_entry *) dir;
  eind = (struct ppc_elf_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct ppc_elf_dyn_relocs **pp;
	  struct ppc_elf_dyn_relocs *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct ppc_elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  edir->tls_mask |= eind->tls_mask;

  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}
d156 1
a156 1
static reloc_howto_type *ppc_elf_howto_table[R_PPC_max];
d164 1
a164 1
	 FALSE,			/* pc_relative */
d169 1
a169 1
	 FALSE,			/* partial_inplace */
d172 1
a172 1
	 FALSE),		/* pcrel_offset */
d179 1
a179 1
	 FALSE,			/* pc_relative */
d184 1
a184 1
	 FALSE,			/* partial_inplace */
d187 1
a187 1
	 FALSE),		/* pcrel_offset */
d195 1
a195 1
	 FALSE,			/* pc_relative */
d200 1
a200 1
	 FALSE,			/* partial_inplace */
d203 1
a203 1
	 FALSE),		/* pcrel_offset */
d210 1
a210 1
	 FALSE,			/* pc_relative */
d215 1
a215 1
	 FALSE,			/* partial_inplace */
d218 1
a218 1
	 FALSE),		/* pcrel_offset */
d225 1
a225 1
	 FALSE,			/* pc_relative */
d230 1
a230 1
	 FALSE,			/* partial_inplace */
d233 1
a233 1
	 FALSE),		/* pcrel_offset */
d240 1
a240 1
	 FALSE,			/* pc_relative */
d245 1
a245 1
	 FALSE,			/* partial_inplace */
d248 1
a248 1
	 FALSE),		/* pcrel_offset */
d256 1
a256 1
	 FALSE,			/* pc_relative */
d261 1
a261 1
	 FALSE,			/* partial_inplace */
d264 1
a264 1
	 FALSE),		/* pcrel_offset */
d272 1
a272 1
	 FALSE,			/* pc_relative */
d277 1
a277 1
	 FALSE,			/* partial_inplace */
d280 1
a280 1
	 FALSE),		/* pcrel_offset */
d289 1
a289 1
	 FALSE,			/* pc_relative */
d294 1
a294 1
	 FALSE,			/* partial_inplace */
d297 1
a297 1
	 FALSE),		/* pcrel_offset */
d306 1
a306 1
	 FALSE,			/* pc_relative */
d311 1
a311 1
	 FALSE,			/* partial_inplace */
d314 1
a314 1
	 FALSE),		/* pcrel_offset */
d321 1
a321 1
	 TRUE,			/* pc_relative */
d326 1
a326 1
	 FALSE,			/* partial_inplace */
d329 1
a329 1
	 TRUE),			/* pcrel_offset */
d336 1
a336 1
	 TRUE,			/* pc_relative */
d341 1
a341 1
	 FALSE,			/* partial_inplace */
d344 1
a344 1
	 TRUE),			/* pcrel_offset */
d353 1
a353 1
	 TRUE,			/* pc_relative */
d358 1
a358 1
	 FALSE,			/* partial_inplace */
d361 1
a361 1
	 TRUE),			/* pcrel_offset */
d370 1
a370 1
	 TRUE,			/* pc_relative */
d375 1
a375 1
	 FALSE,			/* partial_inplace */
d378 1
a378 1
	 TRUE),			/* pcrel_offset */
d386 1
a386 1
	 FALSE,			/* pc_relative */
d391 1
a391 1
	 FALSE,			/* partial_inplace */
d394 1
a394 1
	 FALSE),		/* pcrel_offset */
d402 1
a402 1
	 FALSE,			/* pc_relative */
d407 1
a407 1
	 FALSE,			/* partial_inplace */
d410 1
a410 1
	 FALSE),		/* pcrel_offset */
d418 1
a418 1
	 FALSE,			/* pc_relative */
d423 1
a423 1
	 FALSE,			/* partial_inplace */
d426 1
a426 1
	 FALSE),		 /* pcrel_offset */
d434 1
a434 1
	 FALSE,			/* pc_relative */
d439 1
a439 1
	 FALSE,			/* partial_inplace */
d442 1
a442 1
	 FALSE),		/* pcrel_offset */
d450 1
a450 1
	 TRUE,			/* pc_relative */
d455 1
a455 1
	 FALSE,			/* partial_inplace */
d458 1
a458 1
	 TRUE),			/* pcrel_offset */
d469 1
a469 1
	 FALSE,			/* pc_relative */
d474 1
a474 1
	 FALSE,			/* partial_inplace */
d477 1
a477 1
	 FALSE),		/* pcrel_offset */
d485 1
a485 1
	 FALSE,			/* pc_relative */
d490 1
a490 1
	 FALSE,			/* partial_inplace */
d493 1
a493 1
	 FALSE),		/* pcrel_offset */
d500 1
a500 1
	 FALSE,			/* pc_relative */
d505 1
a505 1
	 FALSE,			/* partial_inplace */
d508 1
a508 1
	 FALSE),		/* pcrel_offset */
d517 1
a517 1
	 FALSE,			/* pc_relative */
d522 1
a522 1
	 FALSE,			/* partial_inplace */
d525 1
a525 1
	 FALSE),		/* pcrel_offset */
d534 1
a534 1
	 TRUE,			/* pc_relative */
d539 1
a539 1
	 FALSE,			/* partial_inplace */
d542 1
a542 1
	 TRUE),			/* pcrel_offset */
d549 1
a549 1
	 FALSE,			/* pc_relative */
d554 1
a554 1
	 FALSE,			/* partial_inplace */
d557 1
a557 1
	 FALSE),		/* pcrel_offset */
d564 1
a564 1
	 FALSE,			/* pc_relative */
d569 1
a569 1
	 FALSE,			/* partial_inplace */
d572 1
a572 1
	 FALSE),		/* pcrel_offset */
d579 1
a579 1
	 TRUE,			/* pc_relative */
d584 1
a584 1
	 FALSE,			/* partial_inplace */
d587 1
a587 1
	 TRUE),			/* pcrel_offset */
d595 1
a595 1
	 FALSE,			/* pc_relative */
d600 1
a600 1
	 FALSE,			/* partial_inplace */
d603 1
a603 1
	 FALSE),		/* pcrel_offset */
d611 1
a611 1
	 TRUE,			/* pc_relative */
d616 1
a616 1
	 FALSE,			/* partial_inplace */
d619 1
a619 1
	 TRUE),			/* pcrel_offset */
d627 1
a627 1
	 FALSE,			/* pc_relative */
d632 1
a632 1
	 FALSE,			/* partial_inplace */
d635 1
a635 1
	 FALSE),		/* pcrel_offset */
d643 1
a643 1
	 FALSE,			/* pc_relative */
d648 1
a648 1
	 FALSE,			/* partial_inplace */
d651 1
a651 1
	 FALSE),		 /* pcrel_offset */
d659 1
a659 1
	 FALSE,			/* pc_relative */
d664 1
a664 1
	 FALSE,			/* partial_inplace */
d667 1
a667 1
	 FALSE),		/* pcrel_offset */
d675 1
a675 1
	 FALSE,			/* pc_relative */
d680 1
a680 1
	 FALSE,			/* partial_inplace */
d683 1
a683 1
	 FALSE),		/* pcrel_offset */
d690 1
a690 1
	 FALSE,			/* pc_relative */
d695 1
a695 1
	 FALSE,			/* partial_inplace */
d698 1
a698 1
	 FALSE),		/* pcrel_offset */
d705 1
a705 1
	 FALSE,			/* pc_relative */
d710 1
a710 1
	 FALSE,			/* partial_inplace */
d713 1
a713 1
	 FALSE),		/* pcrel_offset */
d720 1
a720 1
	 FALSE,			/* pc_relative */
d725 1
a725 1
	 FALSE,			/* partial_inplace */
d728 1
a728 1
	 FALSE),		 /* pcrel_offset */
d735 1
a735 1
	 FALSE,			/* pc_relative */
d740 1
a740 1
	 FALSE,			/* partial_inplace */
d743 4
a746 1
	 FALSE),		/* pcrel_offset */
d748 2
a749 2
  /* Marker reloc for TLS.  */
  HOWTO (R_PPC_TLS,
d753 1
a753 1
	 FALSE,			/* pc_relative */
d755 1
a755 1
	 complain_overflow_dont, /* complain_on_overflow */
d757 2
a758 18
	 "R_PPC_TLS",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes the load module index of the load module that contains the
     definition of its TLS sym.  */
  HOWTO (R_PPC_DTPMOD32,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPMOD32",	/* name */
	 FALSE,			/* partial_inplace */
d761 1
a761 1
	 FALSE),		/* pcrel_offset */
d763 2
a764 19
  /* Computes a dtv-relative displacement, the difference between the value
     of sym+add and the base address of the thread-local storage block that
     contains the definition of sym, minus 0x8000.  */
  HOWTO (R_PPC_DTPREL32,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit dtprel reloc.  */
  HOWTO (R_PPC_DTPREL16,
d768 1
a768 1
	 FALSE,			/* pc_relative */
d770 4
a773 4
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16",	/* name */
	 FALSE,			/* partial_inplace */
d776 1
a776 1
	 FALSE),		/* pcrel_offset */
d778 2
a779 2
  /* Like DTPREL16, but no overflow.  */
  HOWTO (R_PPC_DTPREL16_LO,
d783 1
a783 1
	 FALSE,			/* pc_relative */
d785 4
a788 4
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
d791 1
a791 1
	 FALSE),		/* pcrel_offset */
d793 2
a794 2
  /* Like DTPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_DTPREL16_HI,
d798 1
a798 1
	 FALSE,			/* pc_relative */
d801 3
a803 3
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
d806 1
a806 1
	 FALSE),		/* pcrel_offset */
d808 4
a811 2
  /* Like DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_DTPREL16_HA,
d815 1
a815 1
	 FALSE,			/* pc_relative */
d818 3
a820 3
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
d823 1
a823 1
	 FALSE),		/* pcrel_offset */
d825 4
a828 18
  /* Computes a tp-relative displacement, the difference between the value of
     sym+add and the value of the thread pointer (r13).  */
  HOWTO (R_PPC_TPREL32,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit tprel reloc.  */
  HOWTO (R_PPC_TPREL16,
d832 1
a832 1
	 FALSE,			/* pc_relative */
d834 4
a837 4
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16",	/* name */
	 FALSE,			/* partial_inplace */
d840 1
a840 1
	 FALSE),		/* pcrel_offset */
d842 4
a845 2
  /* Like TPREL16, but no overflow.  */
  HOWTO (R_PPC_TPREL16_LO,
d849 1
a849 1
	 FALSE,			/* pc_relative */
d851 4
a854 4
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16_LO",	/* name */
	 FALSE,			/* partial_inplace */
d857 1
a857 1
	 FALSE),		/* pcrel_offset */
d859 3
a861 34
  /* Like TPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and (sym+add)@@dtprel, and computes the offset
     to the first entry.  */
  HOWTO (R_PPC_GOT_TLSGD16,
d865 1
a865 1
	 FALSE,			/* pc_relative */
d868 3
a870 3
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16",	/* name */
	 FALSE,			/* partial_inplace */
d873 1
a873 1
	 FALSE),		/* pcrel_offset */
d875 4
a878 2
  /* Like GOT_TLSGD16, but no overflow.  */
  HOWTO (R_PPC_GOT_TLSGD16_LO,
d880 1
a880 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d882 1
a882 1
	 FALSE,			/* pc_relative */
d884 4
a887 4
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16_LO", /* name */
	 FALSE,			/* partial_inplace */
d890 1
a890 1
	 FALSE),		/* pcrel_offset */
d892 6
a897 14
  /* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_TLSGD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d899 4
a902 19
  /* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_TLSGD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and zero, and computes the offset to the
     first entry.  */
  HOWTO (R_PPC_GOT_TLSLD16,
d906 1
a906 1
	 FALSE,			/* pc_relative */
d909 3
a911 3
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16",	/* name */
	 FALSE,			/* partial_inplace */
d914 1
a914 1
	 FALSE),		/* pcrel_offset */
d916 2
a917 2
  /* Like GOT_TLSLD16, but no overflow.  */
  HOWTO (R_PPC_GOT_TLSLD16_LO,
d919 3
a921 3
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
d924 3
a926 3
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16_LO", /* name */
	 FALSE,			/* partial_inplace */
d928 2
a929 2
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d931 6
a936 6
  /* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_TLSLD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
d939 3
a941 3
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16_HI", /* name */
	 FALSE,			/* partial_inplace */
d943 2
a944 2
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d946 2
a947 18
  /* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_TLSLD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@dtprel, and computes
     the offset to the entry.  */
  HOWTO (R_PPC_GOT_DTPREL16,
d951 1
a951 1
	 FALSE,			/* pc_relative */
d954 3
a956 3
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16",	/* name */
	 FALSE,			/* partial_inplace */
d959 4
a962 1
	 FALSE),		/* pcrel_offset */
d964 4
a967 14
  /* Like GOT_DTPREL16, but no overflow.  */
  HOWTO (R_PPC_GOT_DTPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d969 9
a977 14
  /* Like GOT_DTPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_DTPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d979 19
a997 14
  /* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d999 1
a999 15
  /* Allocates an entry in the GOT with value (sym+add)@@tprel, and computes the
     offset to the entry.  */
  HOWTO (R_PPC_GOT_TPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1001 4
a1004 295
  /* Like GOT_TPREL16, but no overflow.  */
  HOWTO (R_PPC_GOT_TPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The remaining relocs are from the Embedded ELF ABI, and are not
     in the SVR4 ELF ABI.  */

  /* 32 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_ADDR16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of the result of the addend minus the address,
     plus 1 if the contents of the low 16 bits, treated as a signed number,
     is negative.  */
  HOWTO (R_PPC_EMB_NADDR16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_EMB_NADDR16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from allocating a 4 byte word to hold an
     address in the .sdata section, and returning the offset from
     _SDA_BASE_ for that relocation.  */
  HOWTO (R_PPC_EMB_SDAI16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDAI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from allocating a 4 byte word to hold an
     address in the .sdata2 section, and returning the offset from
     _SDA2_BASE_ for that relocation.  */
  HOWTO (R_PPC_EMB_SDA2I16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA2I16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A sign-extended 16 bit value relative to _SDA2_BASE_, for use with
     small data items.	 */
  HOWTO (R_PPC_EMB_SDA2REL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA2REL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Relocate against either _SDA_BASE_ or _SDA2_BASE_, filling in the 16 bit
     signed offset from the appropriate base, and filling in the register
     field with the appropriate register (0, 2, or 13).  */
  HOWTO (R_PPC_EMB_SDA21,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA21",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Relocation not handled: R_PPC_EMB_MRKREF */
  /* Relocation not handled: R_PPC_EMB_RELSEC16 */
  /* Relocation not handled: R_PPC_EMB_RELST_LO */
  /* Relocation not handled: R_PPC_EMB_RELST_HI */
  /* Relocation not handled: R_PPC_EMB_RELST_HA */
  /* Relocation not handled: R_PPC_EMB_BIT_FLD */

  /* PC relative relocation against either _SDA_BASE_ or _SDA2_BASE_, filling
     in the 16 bit signed offset from the appropriate base, and filling in the
     register field with the appropriate register (0, 2, or 13).  */
  HOWTO (R_PPC_EMB_RELSDA,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_RELSDA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Phony relocs to handle branch stubs.  */
  HOWTO (R_PPC_RELAX32,		/* type */
	 0,			/* rightshift */
	 0,			/* size */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_RELAX32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC_RELAX32PC,	/* type */
	 0,			/* rightshift */
	 0,			/* size */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_RELAX32PC",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_PPC_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC_GNU_VTINHERIT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_PPC_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Phony reloc to handle AIX style TOC entries.  */
  HOWTO (R_PPC_TOC16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_TOC16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* Initialize the ppc_elf_howto_table, so that linear accesses can be done.  */

static void
ppc_elf_howto_init (void)
d1006 2
a1007 1
  unsigned int i, type;
d1009 2
a1010 10
  for (i = 0;
       i < sizeof (ppc_elf_howto_raw) / sizeof (ppc_elf_howto_raw[0]);
       i++)
    {
      type = ppc_elf_howto_raw[i].type;
      if (type >= (sizeof (ppc_elf_howto_table)
		   / sizeof (ppc_elf_howto_table[0])))
	abort ();
      ppc_elf_howto_table[type] = &ppc_elf_howto_raw[i];
    }
a1011 22

#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))

static const int shared_stub_entry[] =
  {
    0x7c0802a6, /* mflr 0 */
    0x429f0005, /* bcl 20, 31, .Lxxx */
    0x7d6802a6, /* mflr 11 */
    0x3d6b0000, /* addis 11, 11, (xxx-.Lxxx)@@ha */
    0x396b0018, /* addi 11, 11, (xxx-.Lxxx)@@l */
    0x7c0803a6, /* mtlr 0 */
    0x7d6903a6, /* mtctr 11 */
    0x4e800420, /* bctr */
  };

static const int stub_entry[] =
  {
    0x3d600000, /* lis 11,xxx@@ha */
    0x396b0000, /* addi 11,11,xxx@@l */
    0x7d6903a6, /* mtctr 11 */
    0x4e800420, /* bctr */
  };
d1013 6
a1018 6

static bfd_boolean
ppc_elf_relax_section (bfd *abfd,
		       asection *isec,
		       struct bfd_link_info *link_info,
		       bfd_boolean *again)
d1020 1
a1020 7
  struct one_fixup
  {
    struct one_fixup *next;
    asection *tsec;
    bfd_vma toff;
    bfd_vma trampoff;
  };
a1021 1
  Elf_Internal_Shdr *symtab_hdr;
d1023 1
a1023 1
  Elf_Internal_Sym *isymbuf = NULL;
d1025 6
a1030 11
  Elf_Internal_Rela *irel, *irelend;
  struct one_fixup *fixups = NULL;
  bfd_boolean changed;
  struct ppc_elf_link_hash_table *ppc_info;
  bfd_size_type trampoff;

  *again = FALSE;

  /* Nothing to do if there are no relocations.  */
  if ((isec->flags & SEC_RELOC) == 0 || isec->reloc_count == 0)
    return TRUE;
d1034 1
a1034 87
    isec->_cooked_size = isec->_raw_size;

  trampoff = (isec->_cooked_size + 3) & (bfd_vma) -4;
  /* Space for a branch around any trampolines.  */
  trampoff += 4;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL,
					       link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;

  ppc_info = ppc_elf_hash_table (link_info);
  irelend = internal_relocs + isec->reloc_count;

  /* Get the section contents.  */
  /* Get cached copy if it exists.  */
  if (elf_section_data (isec)->this_hdr.contents != NULL)
    contents = elf_section_data (isec)->this_hdr.contents;
  else
    {
      /* Go get them off disk.  */
      contents = bfd_malloc (isec->_raw_size);
      if (contents == NULL)
	goto error_return;

      if (!bfd_get_section_contents (abfd, isec, contents, 0, isec->_raw_size))
	goto error_return;
    }

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      unsigned long r_type = ELF32_R_TYPE (irel->r_info);
      bfd_vma symaddr, reladdr, toff, roff;
      asection *tsec;
      struct one_fixup *f;
      size_t insn_offset = 0;
      bfd_vma max_branch_offset, val;
      bfd_byte *hit_addr;
      unsigned long t0;

      switch (r_type)
	{
	case R_PPC_REL24:
	case R_PPC_LOCAL24PC:
	case R_PPC_PLTREL24:
	  max_branch_offset = 1 << 25;
	  break;

	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  max_branch_offset = 1 << 15;
	  break;

	default:
	  continue;
	}

      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == 0)
		goto error_return;
	    }
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    continue;	/* We can't do anything with undefined symbols.  */
	  else if (isym->st_shndx == SHN_ABS)
	    tsec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    tsec = bfd_com_section_ptr;
	  else
	    tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d1036 11
a1046 2
	  toff = isym->st_value;
	}
d1049 165
a1213 58
	  /* Global symbol handling.  */
	  unsigned long indx;
	  struct elf_link_hash_entry *h;

	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];

	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if (r_type == R_PPC_PLTREL24
	      && ppc_info->plt != NULL
	      && h->plt.offset != (bfd_vma) -1)
	    {
	      tsec = ppc_info->plt;
	      toff = h->plt.offset;
	    }
	  else if (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
	    {
	      tsec = h->root.u.def.section;
	      toff = h->root.u.def.value;
	    }
	  else
	    continue;
	}

      /* If the branch and target are in the same section, you have
	 no hope of adding stubs.  We'll error out later should the
	 branch overflow.  */
      if (tsec == isec)
	continue;

      toff += irel->r_addend;
      if (tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	toff = _bfd_merged_section_offset (abfd, &tsec,
					   elf_section_data (tsec)->sec_info,
					   toff, 0);

      symaddr = tsec->output_section->vma + tsec->output_offset + toff;

      roff = irel->r_offset;

      reladdr = (isec->output_section->vma
		 + isec->output_offset
		 + roff);

      /* If the branch is in range, no need to do anything.  */
      if (symaddr - reladdr + max_branch_offset < 2 * max_branch_offset)
	continue;

      /* Look for an existing fixup to this address.  */
      for (f = fixups; f ; f = f->next)
	if (f->tsec == tsec && f->toff == toff)
	  break;

      if (f == NULL)
d1215 2
a1216 69
	  size_t size;
	  unsigned long stub_rtype;

	  val = trampoff - roff;
	  if (val >= max_branch_offset)
	    /* Oh dear, we can't reach a trampoline.  Don't try to add
	       one.  We'll report an error later.  */
	    continue;

	  if (link_info->shared)
	    {
	      size = 4 * ARRAY_SIZE (shared_stub_entry);
	      insn_offset = 12;
	      stub_rtype = R_PPC_RELAX32PC;
	    }
	  else
	    {
	      size = 4 * ARRAY_SIZE (stub_entry);
	      insn_offset = 0;
	      stub_rtype = R_PPC_RELAX32;
	    }

	  /* Hijack the old relocation.  Since we need two
	     relocations for this use a "composite" reloc.  */
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       stub_rtype);
	  irel->r_offset = trampoff + insn_offset;

	  /* Record the fixup so we don't do it again this section.  */
	  f = bfd_malloc (sizeof (*f));
	  f->next = fixups;
	  f->tsec = tsec;
	  f->toff = toff;
	  f->trampoff = trampoff;
	  fixups = f;

	  trampoff += size;
	}
      else
	{
	  val = f->trampoff - roff;
	  if (val >= max_branch_offset)
	    continue;

	  /* Nop out the reloc, since we're finalizing things here.  */
	  irel->r_info = ELF32_R_INFO (0, R_PPC_NONE);
	}

      /* Fix up the existing branch to hit the trampoline.  */
      hit_addr = contents + roff;
      switch (r_type)
	{
	case R_PPC_REL24:
	case R_PPC_LOCAL24PC:
	case R_PPC_PLTREL24:
	  t0 = bfd_get_32 (abfd, hit_addr);
	  t0 &= ~0x3fffffc;
	  t0 |= val & 0x3fffffc;
	  bfd_put_32 (abfd, t0, hit_addr);
	  break;

	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  t0 = bfd_get_32 (abfd, hit_addr);
	  t0 &= ~0xfffc;
	  t0 |= val & 0xfffc;
	  bfd_put_32 (abfd, t0, hit_addr);
	  break;
d1220 1
a1220 3
  /* Write out the trampolines.  */
  changed = fixups != NULL;
  if (fixups != NULL)
d1222 2
a1223 46
      const int *stub;
      bfd_byte *dest;
      bfd_vma val;
      int i, size;

      do
	{
	  struct one_fixup *f = fixups;
	  fixups = fixups->next;
	  free (f);
	}
      while (fixups);

      contents = bfd_realloc (contents, trampoff);
      if (contents == NULL)
	goto error_return;

      isec->_cooked_size = (isec->_cooked_size + 3) & (bfd_vma) -4;
      /* Branch around the trampolines.  */
      val = trampoff - isec->_cooked_size + 0x48000000;
      dest = contents + isec->_cooked_size;
      isec->_cooked_size = trampoff;
      bfd_put_32 (abfd, val, dest);
      dest += 4;

      if (link_info->shared)
	{
	  stub = shared_stub_entry;
	  size = ARRAY_SIZE (shared_stub_entry);
	}
      else
	{
	  stub = stub_entry;
	  size = ARRAY_SIZE (stub_entry);
	}

      i = 0;
      while (dest < contents + trampoff)
	{
	  bfd_put_32 (abfd, stub[i], dest);
	  i++;
	  if (i == size)
	    i = 0;
	  dest += 4;
	}
      BFD_ASSERT (i == 0);
d1226 1
a1226 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d1228 2
a1229 7
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
d1232 1
a1232 2
  if (contents != NULL
      && elf_section_data (isec)->this_hdr.contents != contents)
d1234 2
a1235 2
      if (!changed && !link_info->keep_memory)
	free (contents);
d1241 1
d1244 1
a1244 7
  if (elf_section_data (isec)->relocs != internal_relocs)
    {
      if (!changed)
	free (internal_relocs);
      else
	elf_section_data (isec)->relocs = internal_relocs;
    }
d1246 8
a1253 13
  *again = changed;
  return TRUE;

 error_return:
  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (isec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (isec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
d1257 3
a1259 2
ppc_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   bfd_reloc_code_real_type code)
d1261 1
a1261 1
  enum elf_ppc_reloc_type r;
a1262 1
  /* Initialize howto table if not already done.  */
d1264 1
d1267 1
a1267 1
  switch (code)
d1270 1
a1270 1
      return NULL;
d1272 53
a1324 81
    case BFD_RELOC_NONE:		r = R_PPC_NONE;			break;
    case BFD_RELOC_32:			r = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC_BA26:		r = R_PPC_ADDR24;		break;
    case BFD_RELOC_16:			r = R_PPC_ADDR16;		break;
    case BFD_RELOC_LO16:		r = R_PPC_ADDR16_LO;		break;
    case BFD_RELOC_HI16:		r = R_PPC_ADDR16_HI;		break;
    case BFD_RELOC_HI16_S:		r = R_PPC_ADDR16_HA;		break;
    case BFD_RELOC_PPC_BA16:		r = R_PPC_ADDR14;		break;
    case BFD_RELOC_PPC_BA16_BRTAKEN:	r = R_PPC_ADDR14_BRTAKEN;	break;
    case BFD_RELOC_PPC_BA16_BRNTAKEN:	r = R_PPC_ADDR14_BRNTAKEN;	break;
    case BFD_RELOC_PPC_B26:		r = R_PPC_REL24;		break;
    case BFD_RELOC_PPC_B16:		r = R_PPC_REL14;		break;
    case BFD_RELOC_PPC_B16_BRTAKEN:	r = R_PPC_REL14_BRTAKEN;	break;
    case BFD_RELOC_PPC_B16_BRNTAKEN:	r = R_PPC_REL14_BRNTAKEN;	break;
    case BFD_RELOC_16_GOTOFF:		r = R_PPC_GOT16;		break;
    case BFD_RELOC_LO16_GOTOFF:		r = R_PPC_GOT16_LO;		break;
    case BFD_RELOC_HI16_GOTOFF:		r = R_PPC_GOT16_HI;		break;
    case BFD_RELOC_HI16_S_GOTOFF:	r = R_PPC_GOT16_HA;		break;
    case BFD_RELOC_24_PLT_PCREL:	r = R_PPC_PLTREL24;		break;
    case BFD_RELOC_PPC_COPY:		r = R_PPC_COPY;			break;
    case BFD_RELOC_PPC_GLOB_DAT:	r = R_PPC_GLOB_DAT;		break;
    case BFD_RELOC_PPC_LOCAL24PC:	r = R_PPC_LOCAL24PC;		break;
    case BFD_RELOC_32_PCREL:		r = R_PPC_REL32;		break;
    case BFD_RELOC_32_PLTOFF:		r = R_PPC_PLT32;		break;
    case BFD_RELOC_32_PLT_PCREL:	r = R_PPC_PLTREL32;		break;
    case BFD_RELOC_LO16_PLTOFF:		r = R_PPC_PLT16_LO;		break;
    case BFD_RELOC_HI16_PLTOFF:		r = R_PPC_PLT16_HI;		break;
    case BFD_RELOC_HI16_S_PLTOFF:	r = R_PPC_PLT16_HA;		break;
    case BFD_RELOC_GPREL16:		r = R_PPC_SDAREL16;		break;
    case BFD_RELOC_16_BASEREL:		r = R_PPC_SECTOFF;		break;
    case BFD_RELOC_LO16_BASEREL:	r = R_PPC_SECTOFF_LO;		break;
    case BFD_RELOC_HI16_BASEREL:	r = R_PPC_SECTOFF_HI;		break;
    case BFD_RELOC_HI16_S_BASEREL:	r = R_PPC_SECTOFF_HA;		break;
    case BFD_RELOC_CTOR:		r = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC_TOC16:		r = R_PPC_TOC16;		break;
    case BFD_RELOC_PPC_TLS:		r = R_PPC_TLS;			break;
    case BFD_RELOC_PPC_DTPMOD:		r = R_PPC_DTPMOD32;		break;
    case BFD_RELOC_PPC_TPREL16:		r = R_PPC_TPREL16;		break;
    case BFD_RELOC_PPC_TPREL16_LO:	r = R_PPC_TPREL16_LO;		break;
    case BFD_RELOC_PPC_TPREL16_HI:	r = R_PPC_TPREL16_HI;		break;
    case BFD_RELOC_PPC_TPREL16_HA:	r = R_PPC_TPREL16_HA;		break;
    case BFD_RELOC_PPC_TPREL:		r = R_PPC_TPREL32;		break;
    case BFD_RELOC_PPC_DTPREL16:	r = R_PPC_DTPREL16;		break;
    case BFD_RELOC_PPC_DTPREL16_LO:	r = R_PPC_DTPREL16_LO;		break;
    case BFD_RELOC_PPC_DTPREL16_HI:	r = R_PPC_DTPREL16_HI;		break;
    case BFD_RELOC_PPC_DTPREL16_HA:	r = R_PPC_DTPREL16_HA;		break;
    case BFD_RELOC_PPC_DTPREL:		r = R_PPC_DTPREL32;		break;
    case BFD_RELOC_PPC_GOT_TLSGD16:	r = R_PPC_GOT_TLSGD16;		break;
    case BFD_RELOC_PPC_GOT_TLSGD16_LO:	r = R_PPC_GOT_TLSGD16_LO;	break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HI:	r = R_PPC_GOT_TLSGD16_HI;	break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HA:	r = R_PPC_GOT_TLSGD16_HA;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16:	r = R_PPC_GOT_TLSLD16;		break;
    case BFD_RELOC_PPC_GOT_TLSLD16_LO:	r = R_PPC_GOT_TLSLD16_LO;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HI:	r = R_PPC_GOT_TLSLD16_HI;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HA:	r = R_PPC_GOT_TLSLD16_HA;	break;
    case BFD_RELOC_PPC_GOT_TPREL16:	r = R_PPC_GOT_TPREL16;		break;
    case BFD_RELOC_PPC_GOT_TPREL16_LO:	r = R_PPC_GOT_TPREL16_LO;	break;
    case BFD_RELOC_PPC_GOT_TPREL16_HI:	r = R_PPC_GOT_TPREL16_HI;	break;
    case BFD_RELOC_PPC_GOT_TPREL16_HA:	r = R_PPC_GOT_TPREL16_HA;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16:	r = R_PPC_GOT_DTPREL16;		break;
    case BFD_RELOC_PPC_GOT_DTPREL16_LO:	r = R_PPC_GOT_DTPREL16_LO;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HI:	r = R_PPC_GOT_DTPREL16_HI;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HA:	r = R_PPC_GOT_DTPREL16_HA;	break;
    case BFD_RELOC_PPC_EMB_NADDR32:	r = R_PPC_EMB_NADDR32;		break;
    case BFD_RELOC_PPC_EMB_NADDR16:	r = R_PPC_EMB_NADDR16;		break;
    case BFD_RELOC_PPC_EMB_NADDR16_LO:	r = R_PPC_EMB_NADDR16_LO;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HI:	r = R_PPC_EMB_NADDR16_HI;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HA:	r = R_PPC_EMB_NADDR16_HA;	break;
    case BFD_RELOC_PPC_EMB_SDAI16:	r = R_PPC_EMB_SDAI16;		break;
    case BFD_RELOC_PPC_EMB_SDA2I16:	r = R_PPC_EMB_SDA2I16;		break;
    case BFD_RELOC_PPC_EMB_SDA2REL:	r = R_PPC_EMB_SDA2REL;		break;
    case BFD_RELOC_PPC_EMB_SDA21:	r = R_PPC_EMB_SDA21;		break;
    case BFD_RELOC_PPC_EMB_MRKREF:	r = R_PPC_EMB_MRKREF;		break;
    case BFD_RELOC_PPC_EMB_RELSEC16:	r = R_PPC_EMB_RELSEC16;		break;
    case BFD_RELOC_PPC_EMB_RELST_LO:	r = R_PPC_EMB_RELST_LO;		break;
    case BFD_RELOC_PPC_EMB_RELST_HI:	r = R_PPC_EMB_RELST_HI;		break;
    case BFD_RELOC_PPC_EMB_RELST_HA:	r = R_PPC_EMB_RELST_HA;		break;
    case BFD_RELOC_PPC_EMB_BIT_FLD:	r = R_PPC_EMB_BIT_FLD;		break;
    case BFD_RELOC_PPC_EMB_RELSDA:	r = R_PPC_EMB_RELSDA;		break;
    case BFD_RELOC_VTABLE_INHERIT:	r = R_PPC_GNU_VTINHERIT;	break;
    case BFD_RELOC_VTABLE_ENTRY:	r = R_PPC_GNU_VTENTRY;		break;
d1327 1
a1327 1
  return ppc_elf_howto_table[r];
d1333 4
a1336 3
ppc_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *cache_ptr,
		       Elf_Internal_Rela *dst)
a1337 1
  /* Initialize howto table if not already done.  */
d1339 1
d1349 9
a1357 7
ppc_elf_addr16_ha_reloc (bfd *abfd ATTRIBUTE_UNUSED,
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void *data ATTRIBUTE_UNUSED,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message ATTRIBUTE_UNUSED)
a1383 26
static bfd_reloc_status_type
ppc_elf_unhandled_reloc (bfd *abfd,
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void *data,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message)
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  if (error_message != NULL)
    {
      static char buf[60];
      sprintf (buf, _("generic linker can't handle %s"),
	       reloc_entry->howto->name);
      *error_message = buf;
    }
  return bfd_reloc_dangerous;
}

d1387 3
a1389 2
static bfd_boolean
ppc_elf_object_p (bfd *abfd)
d1402 1
a1402 1
  return TRUE;
d1407 4
a1410 2
static bfd_boolean
ppc_elf_set_private_flags (bfd *abfd, flagword flags)
d1416 2
a1417 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d1421 5
a1425 4
   object file when linking.  */

static bfd_boolean
ppc_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
d1429 1
a1429 1
  bfd_boolean error;
d1431 1
a1431 1
  /* Check if we have the same endianess.  */
d1433 1
a1433 1
    return FALSE;
d1437 1
a1437 1
    return TRUE;
d1441 1
a1441 1
  if (!elf_flags_init (obfd))
d1443 1
a1443 2
      /* First call, no flags set.  */
      elf_flags_init (obfd) = TRUE;
d1447 1
a1447 2
  /* Compatible flags are ok.  */
  else if (new_flags == old_flags)
d1450 1
a1450 2
  /* Incompatible flags.  */
  else
d1452 3
a1454 3
      /* Warn about -mrelocatable mismatch.  Allow -mrelocatable-lib
	 to be linked with either.  */
      error = FALSE;
d1458 1
a1458 1
	  error = TRUE;
d1460 1
a1460 2
	    (_("%s: compiled with -mrelocatable and linked with "
	       "modules compiled normally"),
d1466 1
a1466 1
	  error = TRUE;
d1468 1
a1468 2
	    (_("%s: compiled normally and linked with "
	       "modules compiled with -mrelocatable"),
d1477 1
a1477 1
	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
d1483 2
a1484 134
      /* Do not warn about eabi vs. V.4 mismatch, just or in the bit if
	 any module uses it.  */
      elf_elfheader (obfd)->e_flags |= (new_flags & EF_PPC_EMB);

      new_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
      old_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);

      /* Warn about any other mismatches.  */
      if (new_flags != old_flags)
	{
	  error = TRUE;
	  (*_bfd_error_handler)
	    (_("%s: uses different e_flags (0x%lx) fields "
	       "than previous modules (0x%lx)"),
	     bfd_archive_filename (ibfd), (long) new_flags, (long) old_flags);
	}

      if (error)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}
    }

  return TRUE;
}

/* Handle a PowerPC specific section when reading an object file.  This
   is called when elfcode.h finds a section with an unknown type.  */

static bfd_boolean
ppc_elf_section_from_shdr (bfd *abfd, Elf_Internal_Shdr *hdr, const char *name)
{
  asection *newsect;
  flagword flags;

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
    return FALSE;

  newsect = hdr->bfd_section;
  flags = bfd_get_section_flags (abfd, newsect);
  if (hdr->sh_flags & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;

  if (hdr->sh_type == SHT_ORDERED)
    flags |= SEC_SORT_ENTRIES;

  bfd_set_section_flags (abfd, newsect, flags);
  return TRUE;
}

/* Set up any other section flags and such that may be necessary.  */

static bfd_boolean
ppc_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
		       Elf_Internal_Shdr *shdr,
		       asection *asect)
{
  if ((asect->flags & SEC_EXCLUDE) != 0)
    shdr->sh_flags |= SHF_EXCLUDE;

  if ((asect->flags & SEC_SORT_ENTRIES) != 0)
    shdr->sh_type = SHT_ORDERED;

  return TRUE;
}

/* Find a linker generated pointer with a given addend and type.  */

static elf_linker_section_pointers_t *
elf_find_pointer_linker_section
  (elf_linker_section_pointers_t *linker_pointers,
   bfd_vma addend,
   elf_linker_section_t *lsect)
{
  for ( ; linker_pointers != NULL; linker_pointers = linker_pointers->next)
    if (lsect == linker_pointers->lsect && addend == linker_pointers->addend)
      return linker_pointers;

  return NULL;
}

/* Allocate a pointer to live in a linker created section.  */

static bfd_boolean
elf_create_pointer_linker_section (bfd *abfd,
				   struct bfd_link_info *info,
				   elf_linker_section_t *lsect,
				   struct elf_link_hash_entry *h,
				   const Elf_Internal_Rela *rel)
{
  elf_linker_section_pointers_t **ptr_linker_section_ptr = NULL;
  elf_linker_section_pointers_t *linker_section_ptr;
  unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
  bfd_size_type amt;

  BFD_ASSERT (lsect != NULL);

  /* Is this a global symbol?  */
  if (h != NULL)
    {
      struct ppc_elf_link_hash_entry *eh;

      /* Has this symbol already been allocated?  If so, our work is done.  */
      eh = (struct ppc_elf_link_hash_entry *) h;
      if (elf_find_pointer_linker_section (eh->linker_section_pointer,
					   rel->r_addend,
					   lsect))
	return TRUE;

      ptr_linker_section_ptr = &eh->linker_section_pointer;
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (lsect->rel_section)
	lsect->rel_section->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    {
      /* Allocation of a pointer to a local symbol.  */
      elf_linker_section_pointers_t **ptr = elf_local_ptr_offsets (abfd);

      /* Allocate a table to hold the local symbols if first time.  */
      if (!ptr)
	{
	  unsigned int num_symbols = elf_tdata (abfd)->symtab_hdr.sh_info;

	  amt = num_symbols;
	  amt *= sizeof (elf_linker_section_pointers_t *);
	  ptr = bfd_zalloc (abfd, amt);
d1486 2
a1487 2
	  if (!ptr)
	    return FALSE;
d1489 7
a1495 1
	  elf_local_ptr_offsets (abfd) = ptr;
d1498 1
a1498 9
      /* Has this symbol already been allocated?  If so, our work is done.  */
      if (elf_find_pointer_linker_section (ptr[r_symndx],
					   rel->r_addend,
					   lsect))
	return TRUE;

      ptr_linker_section_ptr = &ptr[r_symndx];

      if (info->shared)
d1500 2
a1501 5
	  /* If we are generating a shared object, we need to
	     output a R_<xxx>_RELATIVE reloc so that the
	     dynamic linker can adjust this GOT entry.  */
	  BFD_ASSERT (lsect->rel_section != NULL);
	  lsect->rel_section->_raw_size += sizeof (Elf32_External_Rela);
d1505 1
a1505 26
  /* Allocate space for a pointer in the linker section, and allocate
     a new pointer record from internal memory.  */
  BFD_ASSERT (ptr_linker_section_ptr != NULL);
  amt = sizeof (elf_linker_section_pointers_t);
  linker_section_ptr = bfd_alloc (abfd, amt);

  if (!linker_section_ptr)
    return FALSE;

  linker_section_ptr->next = *ptr_linker_section_ptr;
  linker_section_ptr->addend = rel->r_addend;
  linker_section_ptr->lsect = lsect;
  linker_section_ptr->written_address_p = FALSE;
  *ptr_linker_section_ptr = linker_section_ptr;

  linker_section_ptr->offset = lsect->section->_raw_size;
  lsect->section->_raw_size += 4;

#ifdef DEBUG
  fprintf (stderr,
	   "Create pointer in linker section %s, offset = %ld, section size = %ld\n",
	   lsect->name, (long) linker_section_ptr->offset,
	   (long) lsect->section->_raw_size);
#endif

  return TRUE;
d1508 2
a1509 1
#define bfd_put_ptr(BFD, VAL, ADDR) bfd_put_32 (BFD, VAL, ADDR)
d1511 5
a1515 11
/* Fill in the address for a pointer generated in a linker section.  */

static bfd_vma
elf_finish_pointer_linker_section (bfd *output_bfd,
				   bfd *input_bfd,
				   struct bfd_link_info *info,
				   elf_linker_section_t *lsect,
				   struct elf_link_hash_entry *h,
				   bfd_vma relocation,
				   const Elf_Internal_Rela *rel,
				   int relative_reloc)
d1517 2
a1518 1
  elf_linker_section_pointers_t *linker_section_ptr;
d1520 2
a1521 1
  BFD_ASSERT (lsect != NULL);
d1523 4
a1526 4
  if (h != NULL)
    {
      /* Handle global symbol.  */
      struct ppc_elf_link_hash_entry *eh;
d1528 2
a1529 5
      eh = (struct ppc_elf_link_hash_entry *) h;
      linker_section_ptr
	= elf_find_pointer_linker_section (eh->linker_section_pointer,
					   rel->r_addend,
					   lsect);
d1531 5
a1535 1
      BFD_ASSERT (linker_section_ptr != NULL);
d1537 8
a1544 33
      if (! elf_hash_table (info)->dynamic_sections_created
	  || (info->shared
	      && info->symbolic
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	{
	  /* This is actually a static link, or it is a
	     -Bsymbolic link and the symbol is defined
	     locally.  We must initialize this entry in the
	     global section.

	     When doing a dynamic link, we create a .rela.<xxx>
	     relocation entry to initialize the value.  This
	     is done in the finish_dynamic_symbol routine.  */
	  if (!linker_section_ptr->written_address_p)
	    {
	      linker_section_ptr->written_address_p = TRUE;
	      bfd_put_ptr (output_bfd,
			   relocation + linker_section_ptr->addend,
			   (lsect->section->contents
			    + linker_section_ptr->offset));
	    }
	}
    }
  else
    {
      /* Handle local symbol.  */
      unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd) != NULL);
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd)[r_symndx] != NULL);
      linker_section_ptr = (elf_find_pointer_linker_section
			    (elf_local_ptr_offsets (input_bfd)[r_symndx],
			     rel->r_addend,
			     lsect));
d1546 2
a1547 49
      BFD_ASSERT (linker_section_ptr != NULL);

      /* Write out pointer if it hasn't been rewritten out before.  */
      if (!linker_section_ptr->written_address_p)
	{
	  linker_section_ptr->written_address_p = TRUE;
	  bfd_put_ptr (output_bfd, relocation + linker_section_ptr->addend,
		       lsect->section->contents + linker_section_ptr->offset);

	  if (info->shared)
	    {
	      /* We need to generate a relative reloc for the dynamic
		 linker.  */

	      asection *srel = lsect->rel_section;
	      Elf_Internal_Rela outrel[MAX_INT_RELS_PER_EXT_REL];
	      bfd_byte *erel;
	      const struct elf_backend_data *bed;
	      unsigned int i;

	      BFD_ASSERT (srel != NULL);

	      bed = get_elf_backend_data (output_bfd);
	      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
		{
		  outrel[i].r_offset = (lsect->section->output_section->vma
					+ lsect->section->output_offset
					+ linker_section_ptr->offset);
		  outrel[i].r_info = 0;
		  outrel[i].r_addend = 0;
		}
	      outrel[0].r_info = ELF32_R_INFO (0, relative_reloc);
	      erel = lsect->section->contents;
	      erel += (elf_section_data (lsect->section)->rel_count++
		       * sizeof (Elf32_External_Rela));
	      bfd_elf32_swap_reloca_out (output_bfd, outrel, erel);
	    }
	}
    }

  relocation = (lsect->section->output_offset
		+ linker_section_ptr->offset
		- lsect->sym_offset);

#ifdef DEBUG
  fprintf (stderr,
	   "Finish pointer in linker section %s, offset = %ld (0x%lx)\n",
	   lsect->name, (long) relocation, (long) relocation);
#endif
d1549 1
a1549 3
  /* Subtract out the addend, because it will get added back in by the normal
     processing.  */
  return relocation - linker_section_ptr->addend;
d1554 4
a1557 3
ppc_elf_create_linker_section (bfd *abfd,
			       struct bfd_link_info *info,
			       enum elf_linker_section_enum which)
d1559 1
a1560 19
  struct ppc_elf_link_hash_table *htab = ppc_elf_hash_table (info);
  asection *s;
  bfd_size_type amt;
  flagword flags;
  const char *name;
  const char *rel_name;
  const char *sym_name;
  bfd_vma sym_offset;

  /* Both of these sections are (technically) created by the user
     putting data in them, so they shouldn't be marked
     SEC_LINKER_CREATED.

     The linker creates them so it has somewhere to attach their
     respective symbols. In fact, if they were empty it would
     be OK to leave the symbol set to 0 (or any random number), because
     the appropriate register should never be used.  */
  flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
  sym_offset = 32768;
d1562 26
a1587 5
  switch (which)
    {
    default:
      abort ();
      return NULL;
d1589 6
a1594 13
    case LINKER_SECTION_SDATA:	/* .sdata/.sbss section */
      name	= ".sdata";
      rel_name	= ".rela.sdata";
      sym_name	= "_SDA_BASE_";
      break;

    case LINKER_SECTION_SDATA2:	/* .sdata2/.sbss2 section */
      name	= ".sdata2";
      rel_name	= ".rela.sdata2";
      sym_name	= "_SDA2_BASE_";
      flags    |= SEC_READONLY;
      break;
    }
d1596 2
a1597 19
  /* Record the first bfd that needs the special sections.  */
  if (!htab->elf.dynobj)
    htab->elf.dynobj = abfd;

  amt = sizeof (elf_linker_section_t);
  lsect = bfd_zalloc (htab->elf.dynobj, amt);

  lsect->sym_offset = sym_offset;

  /* See if the sections already exist.  */
  s = bfd_get_section_by_name (htab->elf.dynobj, name);
  if (s == NULL || (s->flags & flags) != flags)
    {
      s = bfd_make_section_anyway (htab->elf.dynobj, name);
      if (s == NULL
	  || !bfd_set_section_flags (htab->elf.dynobj, s, flags))
	return NULL;
    }
  lsect->section = s;
d1599 7
a1605 3
  if (bfd_get_section_alignment (htab->elf.dynobj, s) < 2
      && !bfd_set_section_alignment (htab->elf.dynobj, s, 2))
    return NULL;
d1607 9
a1615 6
  s->_raw_size = align_power (s->_raw_size, 2);

#ifdef DEBUG
  fprintf (stderr, "Creating section %s, current size = %ld\n",
	   name, (long) s->_raw_size);
#endif
d1617 1
a1617 36
  if (sym_name)
    {
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh;

#ifdef DEBUG
      fprintf (stderr, "Adding %s to section %s\n", sym_name, name);
#endif
      bh = bfd_link_hash_lookup (info->hash, sym_name,
				 FALSE, FALSE, FALSE);

      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	  && !(_bfd_generic_link_add_one_symbol
	       (info, abfd, sym_name, BSF_GLOBAL, s, sym_offset, NULL,
		FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return NULL;
      h = (struct elf_link_hash_entry *) bh;

      h->type = STT_OBJECT;
      lsect->sym_hash = h;

      if (info->shared
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
	return NULL;
    }

  if (info->shared)
    {
      s = bfd_make_section_anyway (htab->elf.dynobj, rel_name);
      lsect->rel_section = s;
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_LINKER_CREATED | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_flags (htab->elf.dynobj, s, flags)
	  || ! bfd_set_section_alignment (htab->elf.dynobj, s, 2))
	return NULL;
d1627 2
a1628 1
ppc_elf_additional_program_headers (bfd *abfd)
d1652 3
a1654 3
static bfd_boolean
ppc_elf_modify_segment_map (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED)
d1656 1
a1656 1
  return TRUE;
d1661 4
a1664 2
static bfd_boolean
ppc_elf_create_got (bfd *abfd, struct bfd_link_info *info)
d1666 1
a1666 2
  struct ppc_elf_link_hash_table *htab;
  asection *s;
d1670 1
a1670 1
    return FALSE;
d1672 1
a1672 2
  htab = ppc_elf_hash_table (info);
  htab->got = s = bfd_get_section_by_name (abfd, ".got");
d1679 2
a1680 12
    return FALSE;

  htab->relgot = bfd_make_section (abfd, ".rela.got");
  if (!htab->relgot
      || ! bfd_set_section_flags (abfd, htab->relgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, htab->relgot, 2))
    return FALSE;

  return TRUE;
d1687 4
a1690 2
static bfd_boolean
ppc_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d1692 1
a1692 2
  struct ppc_elf_link_hash_table *htab;
  asection *s;
d1695 2
a1696 5
  htab = ppc_elf_hash_table (info);

  if (htab->got == NULL
      && !ppc_elf_create_got (abfd, info))
    return FALSE;
d1699 1
a1699 1
    return FALSE;
d1704 1
a1704 2
  htab->dynbss = bfd_get_section_by_name (abfd, ".dynbss");
  htab->dynsbss = s = bfd_make_section (abfd, ".dynsbss");
d1707 1
a1707 1
    return FALSE;
d1711 1
a1711 2
      htab->relbss = bfd_get_section_by_name (abfd, ".rela.bss");
      htab->relsbss = s = bfd_make_section (abfd, ".rela.sbss");
d1715 1
a1715 1
	return FALSE;
d1718 1
a1718 2
  htab->relplt = bfd_get_section_by_name (abfd, ".rela.plt");
  htab->plt = s = bfd_get_section_by_name (abfd, ".plt");
d1732 4
a1735 3
static bfd_boolean
ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
			       struct elf_link_hash_entry *h)
d1737 1
a1737 1
  struct ppc_elf_link_hash_table *htab;
d1740 1
d1743 1
a1743 2
  fprintf (stderr, "ppc_elf_adjust_dynamic_symbol called for %s\n",
	   h->root.root.string);
d1747 1
a1747 2
  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL
d1757 3
a1759 1
  /* Deal with function syms.  */
d1763 3
a1765 6
      /* Clear procedure linkage table information for any symbol that
	 won't need a .plt entry.  */
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d1770 1
a1770 2
	     can't be set up, so we can't use one.  In this case,
	     ppc_elf_adjust_dynamic_symbol won't even be called.
d1772 2
a1773 1
	     2. GC has rendered the entry unused.
d1775 5
a1779 2
	     3. We know for certain that a call to this symbol
	     will go to this object, or will remain undefined.  */
d1782 37
d1820 17
a1836 1
      return TRUE;
d1850 1
a1850 5
      if (ELIMINATE_COPY_RELOCS)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
      return TRUE;
d1861 1
a1861 25
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
    return TRUE;

  if (ELIMINATE_COPY_RELOCS)
    {
      struct ppc_elf_dyn_relocs *p;
      for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
    }
d1877 2
a1878 2
  if (h->size <= elf_gp_size (htab->elf.dynobj))
    s = htab->dynsbss;
d1880 1
a1880 1
    s = htab->dynbss;
d1891 2
a1892 2
      if (h->size <= elf_gp_size (htab->elf.dynobj))
	srel = htab->relsbss;
d1894 1
a1894 1
	srel = htab->relbss;
d1909 1
a1909 1
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
d1911 2
a1912 2
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
	return FALSE;
d1922 1
a1922 1
  return TRUE;
a1924 264
/* This is the condition under which finish_dynamic_symbol will be
   called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* Of those relocs that might be copied as dynamic relocs, this macro
   selects those that must be copied when linking a shared library,
   even when the symbol is local.  */

#define MUST_BE_DYN_RELOC(RTYPE)		\
  ((RTYPE) != R_PPC_REL24			\
   && (RTYPE) != R_PPC_REL14			\
   && (RTYPE) != R_PPC_REL14_BRTAKEN		\
   && (RTYPE) != R_PPC_REL14_BRNTAKEN		\
   && (RTYPE) != R_PPC_REL32)

/* Allocate space in associated reloc sections for dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
{
  struct bfd_link_info *info = inf;
  struct ppc_elf_link_hash_entry *eh;
  struct ppc_elf_link_hash_table *htab;
  struct ppc_elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  htab = ppc_elf_hash_table (info);
  if (htab->elf.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->plt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_INITIAL_ENTRY_SIZE;

	  /* The PowerPC PLT is actually composed of two parts, the
	     first part is 2 words (for a load and a jump), and then
	     there is a remaining word available at the end.  */
	  h->plt.offset = (PLT_INITIAL_ENTRY_SIZE
			   + (PLT_SLOT_SIZE
			      * ((s->_raw_size - PLT_INITIAL_ENTRY_SIZE)
				 / PLT_ENTRY_SIZE)));

	  /* If this symbol is not defined in a regular file, and we
	     are not generating a shared library, then set the symbol
	     to this location in the .plt.  This is required to make
	     function pointers compare as equal between the normal
	     executable and the shared library.  */
	  if (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  After the 8192nd entry, room
	     for two entries is allocated.  */
	  s->_raw_size += PLT_ENTRY_SIZE;
	  if ((s->_raw_size - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
	      > PLT_NUM_SINGLE_ENTRIES)
	    s->_raw_size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->relplt->_raw_size += sizeof (Elf32_External_Rela);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  eh = (struct ppc_elf_link_hash_entry *) h;
  if (eh->elf.got.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (eh->elf.dynindx == -1
	  && (eh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (!bfd_elf32_link_record_dynamic_symbol (info, &eh->elf))
	    return FALSE;
	}

      if (eh->tls_mask == (TLS_TLS | TLS_LD)
	  && !(eh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
	/* If just an LD reloc, we'll just use htab->tlsld_got.offset.  */
	eh->elf.got.offset = (bfd_vma) -1;
      else
	{
	  bfd_boolean dyn;
	  eh->elf.got.offset = htab->got->_raw_size;
	  if ((eh->tls_mask & TLS_TLS) != 0)
	    {
	      if ((eh->tls_mask & TLS_LD) != 0)
		htab->got->_raw_size += 8;
	      if ((eh->tls_mask & TLS_GD) != 0)
		htab->got->_raw_size += 8;
	      if ((eh->tls_mask & (TLS_TPREL | TLS_TPRELGD)) != 0)
		htab->got->_raw_size += 4;
	      if ((eh->tls_mask & TLS_DTPREL) != 0)
		htab->got->_raw_size += 4;
	    }
	  else
	    htab->got->_raw_size += 4;
	  dyn = htab->elf.dynamic_sections_created;
	  if ((info->shared
	       || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, &eh->elf))
	      && (ELF_ST_VISIBILITY (eh->elf.other) == STV_DEFAULT
		  || eh->elf.root.type != bfd_link_hash_undefweak))
	    {
	      /* All the entries we allocated need relocs.  */
	      htab->relgot->_raw_size
		+= ((htab->got->_raw_size - eh->elf.got.offset) / 4
		    * sizeof (Elf32_External_Rela));
	      /* Except LD only needs one.  */
	      if ((eh->tls_mask & TLS_LD) != 0)
		htab->relgot->_raw_size -= sizeof (Elf32_External_Rela);
	    }
	}
    }
  else
    eh->elf.got.offset = (bfd_vma) -1;

  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for relocs that have become local due to symbol visibility
     changes.  */

  if (info->shared)
    {
      /* Relocs that use pc_count are those that appear on a call insn,
	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be
	 generated via assembly.  We want calls to protected symbols to
	 resolve directly to the function rather than going via the plt.
	 If people want function pointer comparisons to work as expected
	 then they should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct ppc_elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
    }
  else if (ELIMINATE_COPY_RELOCS)
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
    }

  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void *info)
{
  struct ppc_elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL
	  && ((s->flags & (SEC_READONLY | SEC_ALLOC))
	      == (SEC_READONLY | SEC_ALLOC)))
	{
	  ((struct bfd_link_info *) info)->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

d1927 4
a1930 3
static bfd_boolean
ppc_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			       struct bfd_link_info *info)
d1932 1
a1932 1
  struct ppc_elf_link_hash_table *htab;
d1934 2
a1935 2
  bfd_boolean relocs;
  bfd *ibfd;
d1941 2
a1942 2
  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL);
d1947 1
a1947 1
      if (info->executable)
d1949 1
a1949 1
	  s = bfd_get_section_by_name (htab->elf.dynobj, ".interp");
d1955 1
a1955 2

  if (htab->tlsld_got.refcount > 0)
d1957 16
a1972 4
      htab->tlsld_got.offset = htab->got->_raw_size;
      htab->got->_raw_size += 8;
      if (info->shared)
	htab->relgot->_raw_size += sizeof (Elf32_External_Rela);
a1973 2
  else
    htab->tlsld_got.offset = (bfd_vma) -1;
d1975 6
a1980 3
  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
d1982 2
a1983 6
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *lgot_masks;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
d1985 1
a1985 1
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
d1988 7
a1994 1
      for (s = ibfd->sections; s != NULL; s = s->next)
d1996 7
a2002 6
	  struct ppc_elf_dyn_relocs *p;

	  for (p = ((struct ppc_elf_dyn_relocs *)
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
d2004 2
a2005 17
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  elf_section_data (p->sec)->sreloc->_raw_size
		    += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags
		       & (SEC_READONLY | SEC_ALLOC))
		      == (SEC_READONLY | SEC_ALLOC))
		    info->flags |= DF_TEXTREL;
		}
d2008 1
a2008 70

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      lgot_masks = (char *) end_local_got;
      s = htab->got;
      srel = htab->relgot;
      for (; local_got < end_local_got; ++local_got, ++lgot_masks)
	if (*local_got > 0)
	  {
	    if (*lgot_masks == (TLS_TLS | TLS_LD))
	      {
		/* If just an LD reloc, we'll just use
		   htab->tlsld_got.offset.  */
		if (htab->tlsld_got.offset == (bfd_vma) -1)
		  {
		    htab->tlsld_got.offset = s->_raw_size;
		    s->_raw_size += 8;
		    if (info->shared)
		      srel->_raw_size += sizeof (Elf32_External_Rela);
		  }
		*local_got = (bfd_vma) -1;
	      }
	    else
	      {
		*local_got = s->_raw_size;
		if ((*lgot_masks & TLS_TLS) != 0)
		  {
		    if ((*lgot_masks & TLS_GD) != 0)
		      s->_raw_size += 8;
		    if ((*lgot_masks & (TLS_TPREL | TLS_TPRELGD)) != 0)
		      s->_raw_size += 4;
		    if ((*lgot_masks & TLS_DTPREL) != 0)
		      s->_raw_size += 4;
		  }
		else
		  s->_raw_size += 4;
		if (info->shared)
		  srel->_raw_size += ((s->_raw_size - *local_got) / 4
				      * sizeof (Elf32_External_Rela));
	      }
	  }
	else
	  *local_got = (bfd_vma) -1;
    }

  /* Allocate space for global sym dynamic relocs.  */
  elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, info);

  /* We've now determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = htab->elf.dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->plt
	  || s == htab->got
	  || (htab->sdata != NULL && s == htab->sdata->section)
	  || (htab->sdata2 != NULL && s == htab->sdata2->section))
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
d2021 1
d2026 1
a2026 1
	      relocs = TRUE;
d2033 3
a2035 1
      else
d2041 1
a2041 1
      if (s->_raw_size == 0)
d2048 3
a2050 3
      s->contents = bfd_zalloc (htab->elf.dynobj, s->_raw_size);
      if (s->contents == NULL)
	return FALSE;
d2053 1
a2053 1
  if (htab->elf.dynamic_sections_created)
d2061 1
a2061 1
  bfd_elf32_add_dynamic_entry (info, (TAG), (VAL))
d2063 1
a2063 1
      if (info->executable)
d2066 1
a2066 1
	    return FALSE;
d2069 1
a2069 1
      if (htab->plt != NULL && htab->plt->_raw_size != 0)
d2075 1
a2075 1
	    return FALSE;
d2083 1
a2083 1
	    return FALSE;
a2085 6
      /* If any dynamic relocs apply to a read-only section, then we
	 need a DT_TEXTREL entry.  */
      if ((info->flags & DF_TEXTREL) == 0)
	elf_link_hash_traverse (elf_hash_table (info), readonly_dynrelocs,
				info);

d2089 2
a2090 1
	    return FALSE;
d2095 1
a2095 1
  return TRUE;
a2097 36
static bfd_boolean
update_local_sym_info (bfd *abfd,
		       Elf_Internal_Shdr *symtab_hdr,
		       unsigned long r_symndx,
		       int tls_type)
{
  bfd_signed_vma *local_got_refcounts = elf_local_got_refcounts (abfd);
  char *local_got_tls_masks;

  if (local_got_refcounts == NULL)
    {
      bfd_size_type size = symtab_hdr->sh_info;

      size *= sizeof (*local_got_refcounts) + sizeof (*local_got_tls_masks);
      local_got_refcounts = bfd_zalloc (abfd, size);
      if (local_got_refcounts == NULL)
	return FALSE;
      elf_local_got_refcounts (abfd) = local_got_refcounts;
    }

  local_got_refcounts[r_symndx] += 1;
  local_got_tls_masks = (char *) (local_got_refcounts + symtab_hdr->sh_info);
  local_got_tls_masks[r_symndx] |= tls_type;
  return TRUE;
}

static void
bad_shared_reloc (bfd *abfd, enum elf_ppc_reloc_type r_type)
{
  (*_bfd_error_handler)
    (_("%s: relocation %s cannot be used when making a shared object"),
     bfd_archive_filename (abfd),
     ppc_elf_howto_table[r_type]->name);
  bfd_set_error (bfd_error_bad_value);
}

d2102 6
a2107 5
static bfd_boolean
ppc_elf_check_relocs (bfd *abfd,
		      struct bfd_link_info *info,
		      asection *sec,
		      const Elf_Internal_Rela *relocs)
d2109 1
a2109 1
  struct ppc_elf_link_hash_table *htab;
d2111 1
a2111 1
  struct elf_link_hash_entry **sym_hashes;
d2114 3
d2118 2
d2121 2
a2122 2
  if (info->relocatable)
    return TRUE;
a2129 4
  /* Initialize howto table if not already done.  */
  if (!ppc_elf_howto_table[R_PPC_ADDR32])
    ppc_elf_howto_init ();

d2132 2
a2133 2
  htab = ppc_elf_hash_table (info);
  if (htab->sdata == NULL)
d2135 3
a2137 4
      htab->sdata = ppc_elf_create_linker_section (abfd, info,
						   LINKER_SECTION_SDATA);
      if (htab->sdata == NULL)
	return FALSE;
d2140 1
a2140 1
  if (htab->sdata2 == NULL)
d2142 3
a2144 4
      htab->sdata2 = ppc_elf_create_linker_section (abfd, info,
						    LINKER_SECTION_SDATA2);
      if (htab->sdata2 == NULL)
	return FALSE;
d2147 1
d2149 2
d2152 4
a2161 1
      enum elf_ppc_reloc_type r_type;
a2162 1
      int tls_type = 0;
d2175 1
a2175 1
	  if (htab->got == NULL)
d2177 5
a2181 4
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!ppc_elf_create_got (htab->elf.dynobj, info))
		return FALSE;
d2185 1
a2185 2
      r_type = ELF32_R_TYPE (rel->r_info);
      switch (r_type)
d2187 1
a2187 34
	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  htab->tlsld_got.refcount += 1;
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogottls;

	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogottls;

	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogottls;

	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	dogottls:
	  sec->has_tls_reloc = 1;
	  /* Fall thru */

	  /* GOT16 relocations */
d2193 12
a2204 1
	  if (htab->got == NULL)
d2206 15
a2220 4
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!ppc_elf_create_got (htab->elf.dynobj, info))
		return FALSE;
d2222 1
d2225 13
a2237 2
	      h->got.refcount += 1;
	      ppc_elf_hash_entry (h)->tls_mask |= tls_type;
d2240 26
a2265 3
	    /* This is a global offset table entry for a local symbol.  */
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx, tls_type))
	      return FALSE;
d2268 1
a2268 1
	  /* Indirect .sdata relocation.  */
d2272 23
a2294 2
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
d2296 4
a2299 3
	  if (!elf_create_pointer_linker_section (abfd, info,
						  htab->sdata, h, rel))
	    return FALSE;
d2302 1
a2302 1
	  /* Indirect .sdata2 relocation.  */
d2306 23
a2328 2
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
d2330 4
a2333 3
	  if (!elf_create_pointer_linker_section (abfd, info,
						  htab->sdata2, h, rel))
	    return FALSE;
a2338 6
	case R_PPC_EMB_RELSDA:
	case R_PPC_EMB_NADDR32:
	case R_PPC_EMB_NADDR16:
	case R_PPC_EMB_NADDR16_LO:
	case R_PPC_EMB_NADDR16_HI:
	case R_PPC_EMB_NADDR16_HA:
d2341 5
a2345 2
	      bad_shared_reloc (abfd, r_type);
	      return FALSE;
a2350 1
	case R_PPC_PLTREL32:
d2358 4
a2361 4
	     actually build the entry in finish_dynamic_symbol,
	     because this might be a case of linking PIC code without
	     linking in any dynamic objects, in which case we don't
	     need to generate a procedure linkage table after all.  */
d2366 1
a2366 7
		 table entry for a local symbol.  */
	      (*_bfd_error_handler) (_("%s(%s+0x%lx): %s reloc against "
				       "local symbol"),
				     bfd_archive_filename (abfd),
				     sec->name,
				     (long) rel->r_offset,
				     ppc_elf_howto_table[r_type]->name);
d2368 1
a2368 1
	      return FALSE;
d2371 6
a2387 28
	case R_PPC_DTPREL16:
	case R_PPC_DTPREL16_LO:
	case R_PPC_DTPREL16_HI:
	case R_PPC_DTPREL16_HA:
	case R_PPC_TOC16:
	  break;

	  /* This are just markers.  */
	case R_PPC_TLS:
	case R_PPC_EMB_MRKREF:
	case R_PPC_NONE:
	case R_PPC_max:
	  break;

	  /* These should only appear in dynamic objects.  */
	case R_PPC_COPY:
	case R_PPC_GLOB_DAT:
	case R_PPC_JMP_SLOT:
	case R_PPC_RELATIVE:
	  break;

	  /* These aren't handled yet.  We'll report an error later.  */
	case R_PPC_ADDR30:
	case R_PPC_EMB_RELSEC16:
	case R_PPC_EMB_RELST_LO:
	case R_PPC_EMB_RELST_HI:
	case R_PPC_EMB_RELST_HA:
	case R_PPC_EMB_BIT_FLD:
d2390 1
a2390 1
	  /* This refers only to functions defined in the shared library.  */
d2398 1
a2398 1
	    return FALSE;
d2405 1
a2405 1
	    return FALSE;
a2407 19
	  /* We shouldn't really be seeing these.  */
	case R_PPC_TPREL32:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  goto dodyn;

	  /* Nor these.  */
	case R_PPC_DTPMOD32:
	case R_PPC_DTPREL32:
	  goto dodyn;

	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_TPREL16_HI:
	case R_PPC_TPREL16_HA:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  goto dodyn;

d2417 2
a2418 1
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d2422 2
a2423 57
	case R_PPC_ADDR32:
	case R_PPC_ADDR24:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	  if (h != NULL && !info->shared)
	    {
	      /* We may need a plt entry if the symbol turns out to be
		 a function defined in a dynamic object.  */
	      h->plt.refcount++;

	      /* We may need a copy reloc too.  */
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
	    }

	dodyn:
	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library.  We account for that possibility below by
	     storing information in the dyn_relocs field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (MUST_BE_DYN_RELOC (r_type)
		   || (h != NULL
		       && (! info->symbolic
			   || h->root.type == bfd_link_hash_defweak
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
a2424 3
	      struct ppc_elf_dyn_relocs *p;
	      struct ppc_elf_dyn_relocs **head;

d2426 2
a2427 5
	      fprintf (stderr,
		       "ppc_elf_check_relocs needs to "
		       "create relocation for %s\n",
		       (h && h->root.root.string
			? h->root.root.string : "<unknown>"));
d2438 1
a2438 1
		    return FALSE;
d2444 1
a2444 1
		  sreloc = bfd_get_section_by_name (htab->elf.dynobj, name);
d2449 1
a2449 1
		      sreloc = bfd_make_section (htab->elf.dynobj, name);
d2455 3
a2457 5
			  || ! bfd_set_section_flags (htab->elf.dynobj,
						      sreloc, flags)
			  || ! bfd_set_section_alignment (htab->elf.dynobj,
							  sreloc, 2))
			return FALSE;
d2459 2
a2460 23
		  elf_section_data (sec)->sreloc = sreloc;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		{
		  head = &ppc_elf_hash_entry (h)->dyn_relocs;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */

		  asection *s;
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return FALSE;

		  head = ((struct ppc_elf_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
d2463 1
a2463 12
	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}
d2465 6
a2470 3
	      p->count += 1;
	      if (!MUST_BE_DYN_RELOC (r_type))
		p->pc_count += 1;
d2477 1
a2477 1
  return TRUE;
d2484 6
a2489 5
ppc_elf_gc_mark_hook (asection *sec,
		      struct bfd_link_info *info ATTRIBUTE_UNUSED,
		      Elf_Internal_Rela *rel,
		      struct elf_link_hash_entry *h,
		      Elf_Internal_Sym *sym)
d2520 1
a2520 2
/* Update the got, plt and dynamic reloc reference counts for the
   section being removed.  */
d2522 6
a2527 5
static bfd_boolean
ppc_elf_gc_sweep_hook (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
a2528 1
  struct ppc_elf_link_hash_table *htab;
d2533 2
a2535 3
  elf_section_data (sec)->local_dynrel = NULL;

  htab = ppc_elf_hash_table (info);
d2542 19
a2560 117
    {
      unsigned long r_symndx;
      enum elf_ppc_reloc_type r_type;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct ppc_elf_dyn_relocs **pp, *p;
	  struct ppc_elf_link_hash_entry *eh;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct ppc_elf_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF32_R_TYPE (rel->r_info);
      switch (r_type)
	{
	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  htab->tlsld_got.refcount -= 1;
	  /* Fall thru */

	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_GOT16_HI:
	case R_PPC_GOT16_HA:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount--;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx]--;
	    }
	  break;

	case R_PPC_REL24:
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	case R_PPC_REL32:
	  if (h == NULL
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* Fall thru */

	case R_PPC_ADDR32:
	case R_PPC_ADDR24:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	case R_PPC_PLT32:
	case R_PPC_PLTREL24:
	case R_PPC_PLT16_LO:
	case R_PPC_PLT16_HI:
	case R_PPC_PLT16_HA:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount--;
	    }
	  break;

	default:
	  break;
	}
    }
  return TRUE;
}

/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */

asection *
ppc_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
{
  struct ppc_elf_link_hash_table *htab;

  htab = ppc_elf_hash_table (info);
  htab->tls_get_addr = elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
					     FALSE, FALSE, TRUE);

  return _bfd_elf_tls_setup (obfd, info);
}

/* Run through all the TLS relocs looking for optimization
   opportunities.  */
d2562 7
a2568 19
bfd_boolean
ppc_elf_tls_optimize (bfd *obfd ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info)
{
  bfd *ibfd;
  asection *sec;
  struct ppc_elf_link_hash_table *htab;

  if (info->relocatable || info->shared)
    return TRUE;

  htab = ppc_elf_hash_table (info);
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      Elf_Internal_Sym *locsyms = NULL;
      Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	if (sec->has_tls_reloc && !bfd_is_abs_section (sec->output_section))
d2570 5
a2574 2
	    Elf_Internal_Rela *relstart, *rel, *relend;
	    int expecting_tls_get_addr;
d2576 3
a2578 154
	    /* Read the relocations.  */
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
						  info->keep_memory);
	    if (relstart == NULL)
	      return FALSE;

	    expecting_tls_get_addr = 0;
	    relend = relstart + sec->reloc_count;
	    for (rel = relstart; rel < relend; rel++)
	      {
		enum elf_ppc_reloc_type r_type;
		unsigned long r_symndx;
		struct elf_link_hash_entry *h = NULL;
		char *tls_mask;
		char tls_set, tls_clear;
		bfd_boolean is_local;

		r_symndx = ELF32_R_SYM (rel->r_info);
		if (r_symndx >= symtab_hdr->sh_info)
		  {
		    struct elf_link_hash_entry **sym_hashes;

		    sym_hashes = elf_sym_hashes (ibfd);
		    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
		    while (h->root.type == bfd_link_hash_indirect
			   || h->root.type == bfd_link_hash_warning)
		      h = (struct elf_link_hash_entry *) h->root.u.i.link;
		  }

		is_local = FALSE;
		if (h == NULL
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
		  is_local = TRUE;

		r_type = ELF32_R_TYPE (rel->r_info);
		switch (r_type)
		  {
		  case R_PPC_GOT_TLSLD16:
		  case R_PPC_GOT_TLSLD16_LO:
		  case R_PPC_GOT_TLSLD16_HI:
		  case R_PPC_GOT_TLSLD16_HA:
		    /* These relocs should never be against a symbol
		       defined in a shared lib.  Leave them alone if
		       that turns out to be the case.  */
		    expecting_tls_get_addr = 0;
		    htab->tlsld_got.refcount -= 1;
		    if (!is_local)
		      continue;

		    /* LD -> LE */
		    tls_set = 0;
		    tls_clear = TLS_LD;
		    expecting_tls_get_addr = 1;
		    break;

		  case R_PPC_GOT_TLSGD16:
		  case R_PPC_GOT_TLSGD16_LO:
		  case R_PPC_GOT_TLSGD16_HI:
		  case R_PPC_GOT_TLSGD16_HA:
		    if (is_local)
		      /* GD -> LE */
		      tls_set = 0;
		    else
		      /* GD -> IE */
		      tls_set = TLS_TLS | TLS_TPRELGD;
		    tls_clear = TLS_GD;
		    expecting_tls_get_addr = 1;
		    break;

		  case R_PPC_GOT_TPREL16:
		  case R_PPC_GOT_TPREL16_LO:
		  case R_PPC_GOT_TPREL16_HI:
		  case R_PPC_GOT_TPREL16_HA:
		    expecting_tls_get_addr = 0;
		    if (is_local)
		      {
			/* IE -> LE */
			tls_set = 0;
			tls_clear = TLS_TPREL;
			break;
		      }
		    else
		      continue;

		  case R_PPC_REL14:
		  case R_PPC_REL14_BRTAKEN:
		  case R_PPC_REL14_BRNTAKEN:
		  case R_PPC_REL24:
		    if (expecting_tls_get_addr
			&& h != NULL
			&& h == htab->tls_get_addr)
		      {
			if (h->plt.refcount > 0)
			  h->plt.refcount -= 1;
		      }
		    expecting_tls_get_addr = 0;
		    continue;

		  default:
		    expecting_tls_get_addr = 0;
		    continue;
		  }

		if (h != NULL)
		  {
		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (h->got.refcount > 0)
			  h->got.refcount -= 1;
		      }
		    tls_mask = &ppc_elf_hash_entry (h)->tls_mask;
		  }
		else
		  {
		    Elf_Internal_Sym *sym;
		    bfd_signed_vma *lgot_refs;
		    char *lgot_masks;

		    if (locsyms == NULL)
		      {
			locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
			if (locsyms == NULL)
			  locsyms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
							  symtab_hdr->sh_info,
							  0, NULL, NULL, NULL);
			if (locsyms == NULL)
			  {
			    if (elf_section_data (sec)->relocs != relstart)
			      free (relstart);
			    return FALSE;
			  }
		      }
		    sym = locsyms + r_symndx;
		    lgot_refs = elf_local_got_refcounts (ibfd);
		    if (lgot_refs == NULL)
		      abort ();
		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (lgot_refs[r_symndx] > 0)
			  lgot_refs[r_symndx] -= 1;
		      }
		    lgot_masks = (char *) (lgot_refs + symtab_hdr->sh_info);
		    tls_mask = &lgot_masks[r_symndx];
		  }

		*tls_mask |= tls_set;
		*tls_mask &= ~tls_clear;
	      }

	    if (elf_section_data (sec)->relocs != relstart)
	      free (relstart);
	  }
d2580 1
a2580 10
      if (locsyms != NULL
	  && (symtab_hdr->contents != (unsigned char *) locsyms))
	{
	  if (!info->keep_memory)
	    free (locsyms);
	  else
	    symtab_hdr->contents = (unsigned char *) locsyms;
	}
    }
  return TRUE;
d2586 9
a2594 8
static bfd_boolean
ppc_elf_add_symbol_hook (bfd *abfd,
			 struct bfd_link_info *info,
			 const Elf_Internal_Sym *sym,
			 const char **namep ATTRIBUTE_UNUSED,
			 flagword *flagsp ATTRIBUTE_UNUSED,
			 asection **secp,
			 bfd_vma *valp)
d2597 1
a2597 1
      && !info->relocatable
d2599 1
a2599 2
      && (info->hash->creator == abfd->xvec
	  || info->hash->creator == abfd->xvec->alternative_target))
d2602 31
a2632 12
	 put into .sbss.  */
      struct ppc_elf_link_hash_table *htab;

      htab = ppc_elf_hash_table (info);
      if (htab->sbss == NULL)
	{
	  flagword flags = SEC_IS_COMMON;

	  htab->sbss = bfd_make_section_anyway (abfd, ".sbss");
	  if (htab->sbss == NULL
	      || ! bfd_set_section_flags (abfd, htab->sbss, flags))
	    return FALSE;
d2635 1
a2635 1
      *secp = htab->sbss;
d2639 1
a2639 1
  return TRUE;
d2645 6
a2650 5
static bfd_boolean
ppc_elf_finish_dynamic_symbol (bfd *output_bfd,
			       struct bfd_link_info *info,
			       struct elf_link_hash_entry *h,
			       Elf_Internal_Sym *sym)
d2652 1
a2652 1
  struct ppc_elf_link_hash_table *htab;
d2659 2
a2660 2
  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL);
d2664 2
a2666 1
      bfd_byte *loc;
d2674 1
a2674 1
	 it up.  */
d2677 4
a2680 1
      BFD_ASSERT (htab->plt != NULL && htab->relplt != NULL);
d2686 2
a2687 2
      rela.r_offset = (htab->plt->output_section->vma
		       + htab->plt->output_offset
d2695 3
a2697 3
      loc = (htab->relplt->contents
	     + reloc_index * sizeof (Elf32_External_Rela));
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d2714 43
a2760 1
      bfd_byte *loc;
d2770 3
a2772 2
      if (h->size <= elf_gp_size (htab->elf.dynobj))
	s = htab->relsbss;
d2774 2
a2775 1
	s = htab->relbss;
d2783 4
a2786 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d2799 1
a2799 1
  return TRUE;
d2804 4
a2807 3
static bfd_boolean
ppc_elf_finish_dynamic_sections (bfd *output_bfd,
				 struct bfd_link_info *info)
d2810 2
a2811 1
  struct ppc_elf_link_hash_table *htab;
d2817 1
a2817 2
  htab = ppc_elf_hash_table (info);
  sdyn = bfd_get_section_by_name (htab->elf.dynobj, ".dynamic");
d2819 1
a2819 1
  if (htab->elf.dynamic_sections_created)
d2821 1
d2824 2
a2825 1
      BFD_ASSERT (htab->plt != NULL && sdyn != NULL);
d2832 2
a2833 1
	  asection *s;
d2835 1
a2835 1
	  bfd_elf32_swap_dyn_in (htab->elf.dynobj, dyncon, &dyn);
d2839 5
a2843 4
	    case DT_PLTGOT:
	      s = htab->plt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;
d2845 3
a2847 3
	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = htab->relplt->_raw_size;
	      break;
d2849 16
a2864 7
	    case DT_JMPREL:
	      s = htab->relplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    default:
	      continue;
a2865 2

	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d2871 1
a2871 1
  if (htab->got)
d2873 2
a2874 2
      unsigned char *contents = htab->got->contents;
      bfd_put_32 (output_bfd, 0x4e800021 /* blrl */, contents);
d2877 1
a2877 1
	bfd_put_32 (output_bfd, 0, contents + 4);
d2881 1
a2881 1
		    contents + 4);
d2883 1
a2883 1
      elf_section_data (htab->got->output_section)->this_hdr.sh_entsize = 4;
d2886 1
a2886 1
  return TRUE;
d2898 1
a2898 1
   relocatable output file) adjusting the reloc addend as
d2912 1
a2912 1
   When generating relocatable output, this function must handle
d2918 22
a2939 18
static bfd_boolean
ppc_elf_relocate_section (bfd *output_bfd,
			  struct bfd_link_info *info,
			  bfd *input_bfd,
			  asection *input_section,
			  bfd_byte *contents,
			  Elf_Internal_Rela *relocs,
			  Elf_Internal_Sym *local_syms,
			  asection **local_sections)
{
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct ppc_elf_link_hash_table *htab;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  Elf_Internal_Rela outrel;
  bfd_byte *loc;
  asection *sreloc = NULL;
d2941 2
a2942 1
  bfd_boolean ret = TRUE;
d2945 1
a2945 2
  fprintf (stderr, "ppc_elf_relocate_section called for %s section %s, "
	   "%ld relocations%s\n",
d2949 1
a2949 1
	   (info->relocatable) ? " (relocatable)" : "");
d2952 2
a2953 2
  if (info->relocatable)
    return TRUE;
a2954 1
  /* Initialize howto table if not already done.  */
d2956 1
a2958 1
  htab = ppc_elf_hash_table (info);
d2960 8
a2967 4
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  rel = relocs;
  relend = relocs + input_section->reloc_count;
d2970 8
a2977 7
      enum elf_ppc_reloc_type r_type;
      bfd_vma addend;
      bfd_reloc_status_type r;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      const char *sym_name;
d2981 16
a2996 11
      bfd_vma branch_bit, insn, from;
      bfd_boolean unresolved_reloc;
      bfd_boolean warned;
      unsigned int tls_type, tls_mask, tls_gd;

      r_type = ELF32_R_TYPE (rel->r_info);
      sym = NULL;
      sec = NULL;
      h = NULL;
      unresolved_reloc = FALSE;
      warned = FALSE;
d3003 1
a3003 1
	  sym_name = bfd_elf_local_sym_name (input_bfd, sym);
d3005 4
a3008 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d3012 4
a3015 5
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);

a3016 93
	}

      /* TLS optimizations.  Replace instruction sequences and relocs
	 based on information we collected in tls_optimize.  We edit
	 RELOCS so that --emit-relocs will output something sensible
	 for the final instruction stream.  */
      tls_mask = 0;
      tls_gd = 0;
      if (IS_PPC_TLS_RELOC (r_type))
	{
	  if (h != NULL)
	    tls_mask = ((struct ppc_elf_link_hash_entry *) h)->tls_mask;
	  else if (local_got_offsets != NULL)
	    {
	      char *lgot_masks;
	      lgot_masks = (char *) (local_got_offsets + symtab_hdr->sh_info);
	      tls_mask = lgot_masks[r_symndx];
	    }
	}

      /* Ensure reloc mapping code below stays sane.  */
      if ((R_PPC_GOT_TLSLD16 & 3)    != (R_PPC_GOT_TLSGD16 & 3)
	  || (R_PPC_GOT_TLSLD16_LO & 3) != (R_PPC_GOT_TLSGD16_LO & 3)
	  || (R_PPC_GOT_TLSLD16_HI & 3) != (R_PPC_GOT_TLSGD16_HI & 3)
	  || (R_PPC_GOT_TLSLD16_HA & 3) != (R_PPC_GOT_TLSGD16_HA & 3)
	  || (R_PPC_GOT_TLSLD16 & 3)    != (R_PPC_GOT_TPREL16 & 3)
	  || (R_PPC_GOT_TLSLD16_LO & 3) != (R_PPC_GOT_TPREL16_LO & 3)
	  || (R_PPC_GOT_TLSLD16_HI & 3) != (R_PPC_GOT_TPREL16_HI & 3)
	  || (R_PPC_GOT_TLSLD16_HA & 3) != (R_PPC_GOT_TPREL16_HA & 3))
	abort ();
      switch (r_type)
	{
	default:
	  break;

	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	      bfd_vma insn;
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset - 2);
	      insn &= 31 << 21;
	      insn |= 0x3c020000;	/* addis 0,2,0 */
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset - 2);
	      r_type = R_PPC_TPREL16_HA;
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC_TLS:
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	      bfd_vma insn, rtra;
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	      if ((insn & ((31 << 26) | (31 << 11)))
		  == ((31 << 26) | (2 << 11)))
		rtra = insn & ((1 << 26) - (1 << 16));
	      else if ((insn & ((31 << 26) | (31 << 16)))
		       == ((31 << 26) | (2 << 16)))
		rtra = (insn & (31 << 21)) | ((insn & (31 << 11)) << 5);
	      else
		abort ();
	      if ((insn & ((1 << 11) - (1 << 1))) == 266 << 1)
		/* add -> addi.  */
		insn = 14 << 26;
	      else if ((insn & (31 << 1)) == 23 << 1
		       && ((insn & (31 << 6)) < 14 << 6
			   || ((insn & (31 << 6)) >= 16 << 6
			       && (insn & (31 << 6)) < 24 << 6)))
		/* load and store indexed -> dform.  */
		insn = (32 | ((insn >> 6) & 31)) << 26;
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & (0x1a << 6)) == 0)
		/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
		insn = (((58 | ((insn >> 6) & 4)) << 26)
			| ((insn >> 6) & 1));
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & ((1 << 11) - (1 << 1))) == 341 << 1)
		/* lwax -> lwa.  */
		insn = (58 << 26) | 2;
	      else
		abort ();
	      insn |= rtra;
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	      r_type = R_PPC_TPREL16_LO;
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      /* Was PPC_TLS which sits on insn boundary, now
		 PPC_TPREL16_LO which is at insn+2.  */
	      rel->r_offset += 2;
	    }
	  break;
d3018 2
a3019 6
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_gdld_hi;
	  break;
d3021 2
a3022 3
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
d3024 58
a3081 5
	    tls_gdld_hi:
	      if ((tls_mask & tls_gd) != 0)
		r_type = (((r_type - (R_PPC_GOT_TLSGD16 & 3)) & 3)
			  + R_PPC_GOT_TPREL16);
	      else
d3083 4
a3086 3
		  bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
		  rel->r_offset -= 2;
		  r_type = R_PPC_NONE;
d3088 1
a3088 17
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_get_addr_check;
	  break;

	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
	    {
	    tls_get_addr_check:
	      if (rel + 1 < relend)
d3090 5
a3094 67
		  enum elf_ppc_reloc_type r_type2;
		  unsigned long r_symndx2;
		  struct elf_link_hash_entry *h2;
		  bfd_vma insn1, insn2;
		  bfd_vma offset;

		  /* The next instruction should be a call to
		     __tls_get_addr.  Peek at the reloc to be sure.  */
		  r_type2 = ELF32_R_TYPE (rel[1].r_info);
		  r_symndx2 = ELF32_R_SYM (rel[1].r_info);
		  if (r_symndx2 < symtab_hdr->sh_info
		      || (r_type2 != R_PPC_REL14
			  && r_type2 != R_PPC_REL14_BRTAKEN
			  && r_type2 != R_PPC_REL14_BRNTAKEN
			  && r_type2 != R_PPC_REL24
			  && r_type2 != R_PPC_PLTREL24))
		    break;

		  h2 = sym_hashes[r_symndx2 - symtab_hdr->sh_info];
		  while (h2->root.type == bfd_link_hash_indirect
			 || h2->root.type == bfd_link_hash_warning)
		    h2 = (struct elf_link_hash_entry *) h2->root.u.i.link;
		  if (h2 == NULL || h2 != htab->tls_get_addr)
		    break;

		  /* OK, it checks out.  Replace the call.  */
		  offset = rel[1].r_offset;
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - 2);
		  if ((tls_mask & tls_gd) != 0)
		    {
		      /* IE */
		      insn1 &= (1 << 26) - 1;
		      insn1 |= 32 << 26;	/* lwz */
		      insn2 = 0x7c631214;	/* add 3,3,2 */
		      rel[1].r_info = ELF32_R_INFO (r_symndx2, R_PPC_NONE);
		      r_type = (((r_type - (R_PPC_GOT_TLSGD16 & 3)) & 3)
				+ R_PPC_GOT_TPREL16);
		      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
		    }
		  else
		    {
		      /* LE */
		      insn1 = 0x3c620000;	/* addis 3,2,0 */
		      insn2 = 0x38630000;	/* addi 3,3,0 */
		      if (tls_gd == 0)
			{
			  /* Was an LD reloc.  */
			  r_symndx = 0;
			  rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
			  rel[1].r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
			}
		      r_type = R_PPC_TPREL16_HA;
		      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
		      rel[1].r_info = ELF32_R_INFO (r_symndx,
						    R_PPC_TPREL16_LO);
		      rel[1].r_offset += 2;
		    }
		  bfd_put_32 (output_bfd, insn1, contents + rel->r_offset - 2);
		  bfd_put_32 (output_bfd, insn2, contents + offset);
		  if (tls_gd == 0)
		    {
		      /* We changed the symbol on an LD reloc.  Start over
			 in order to get h, sym, sec etc. right.  */
		      rel--;
		      continue;
		    }
d3096 24
a3120 33
	  break;
	}

      /* Handle other relocations that tweak non-addend part of insn.  */
      branch_bit = 0;
      switch (r_type)
	{
	default:
	  break;

	  /* Branch taken prediction relocations.  */
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_REL14_BRTAKEN:
	  branch_bit = BRANCH_PREDICT_BIT;
	  /* Fall thru */

	  /* Branch not taken prediction relocations.  */
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	  insn &= ~BRANCH_PREDICT_BIT;
	  insn |= branch_bit;

	  from = (rel->r_offset
		  + input_section->output_offset
		  + input_section->output_section->vma);

	  /* Invert 'y' bit if not the default.  */
	  if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
	    insn ^= BRANCH_PREDICT_BIT;

	  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	  break;
d3123 1
a3123 6
      addend = rel->r_addend;
      tls_type = 0;
      howto = NULL;
      if (r_type < R_PPC_max)
	howto = ppc_elf_howto_table[r_type];
      switch (r_type)
d3126 3
a3128 3
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d for symbol %s"),
	     bfd_archive_filename (input_bfd), (int) r_type, sym_name);
d3131 1
a3131 1
	  ret = FALSE;
d3134 1
a3134 5
	case R_PPC_NONE:
	case R_PPC_TLS:
	case R_PPC_EMB_MRKREF:
	case R_PPC_GNU_VTINHERIT:
	case R_PPC_GNU_VTENTRY:
a3136 246
	  /* GOT16 relocations.  Like an ADDR16 using the symbol's
	     address in the GOT as relocation value instead of the
	     symbol's value itself.  Also, create a GOT entry for the
	     symbol and put the symbol value there.  */
	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogot;

	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogot;

	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogot;

	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	  goto dogot;

	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_GOT16_HI:
	case R_PPC_GOT16_HA:
	dogot:
	  {
	    /* Relocation is to the entry for this symbol in the global
	       offset table.  */
	    bfd_vma off;
	    bfd_vma *offp;
	    unsigned long indx;

	    if (htab->got == NULL)
	      abort ();

	    indx = 0;
	    if (tls_type == (TLS_TLS | TLS_LD)
		&& (h == NULL
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
	      offp = &htab->tlsld_got.offset;
	    else if (h != NULL)
	      {
		bfd_boolean dyn;
		dyn = htab->elf.dynamic_sections_created;
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		    || (info->shared
			&& SYMBOL_REFERENCES_LOCAL (info, h)))
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  */
		  ;
		else
		  {
		    indx = h->dynindx;
		    unresolved_reloc = FALSE;
		  }
		offp = &h->got.offset;
	      }
	    else
	      {
		if (local_got_offsets == NULL)
		  abort ();
		offp = &local_got_offsets[r_symndx];
	      }

	    /* The offset must always be a multiple of 4.  We use the
	       least significant bit to record whether we have already
	       processed this entry.  */
	    off = *offp;
	    if ((off & 1) != 0)
	      off &= ~1;
	    else
	      {
		unsigned int tls_m = (tls_mask
				      & (TLS_LD | TLS_GD | TLS_DTPREL
					 | TLS_TPREL | TLS_TPRELGD));

		if (offp == &htab->tlsld_got.offset)
		  tls_m = TLS_LD;
		else if (h == NULL
			 || !(h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC))
		  tls_m &= ~TLS_LD;

		/* We might have multiple got entries for this sym.
		   Initialize them all.  */
		do
		  {
		    int tls_ty = 0;

		    if ((tls_m & TLS_LD) != 0)
		      {
			tls_ty = TLS_TLS | TLS_LD;
			tls_m &= ~TLS_LD;
		      }
		    else if ((tls_m & TLS_GD) != 0)
		      {
			tls_ty = TLS_TLS | TLS_GD;
			tls_m &= ~TLS_GD;
		      }
		    else if ((tls_m & TLS_DTPREL) != 0)
		      {
			tls_ty = TLS_TLS | TLS_DTPREL;
			tls_m &= ~TLS_DTPREL;
		      }
		    else if ((tls_m & (TLS_TPREL | TLS_TPRELGD)) != 0)
		      {
			tls_ty = TLS_TLS | TLS_TPREL;
			tls_m = 0;
		      }

		    /* Generate relocs for the dynamic linker.  */
		    if ((info->shared || indx != 0)
			&& (h == NULL
			    || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			    || h->root.type != bfd_link_hash_undefweak))
		      {
			outrel.r_offset = (htab->got->output_section->vma
					   + htab->got->output_offset
					   + off);
			outrel.r_addend = 0;
			if (tls_ty & (TLS_LD | TLS_GD))
			  {
			    outrel.r_info = ELF32_R_INFO (indx, R_PPC_DTPMOD32);
			    if (tls_ty == (TLS_TLS | TLS_GD))
			      {
				loc = htab->relgot->contents;
				loc += (htab->relgot->reloc_count++
					* sizeof (Elf32_External_Rela));
				bfd_elf32_swap_reloca_out (output_bfd,
							   &outrel, loc);
				outrel.r_offset += 4;
				outrel.r_info
				  = ELF32_R_INFO (indx, R_PPC_DTPREL32);
			      }
			  }
			else if (tls_ty == (TLS_TLS | TLS_DTPREL))
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_DTPREL32);
			else if (tls_ty == (TLS_TLS | TLS_TPREL))
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_TPREL32);
			else if (indx == 0)
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_RELATIVE);
			else
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_GLOB_DAT);
			if (indx == 0)
			  {
			    outrel.r_addend += relocation;
			    if (tls_ty & (TLS_GD | TLS_DTPREL | TLS_TPREL))
			      outrel.r_addend -= htab->elf.tls_sec->vma;
			  }
			loc = htab->relgot->contents;
			loc += (htab->relgot->reloc_count++
				* sizeof (Elf32_External_Rela));
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		      }

		    /* Init the .got section contents if we're not
		       emitting a reloc.  */
		    else
		      {
			bfd_vma value = relocation;

			if (tls_ty == (TLS_TLS | TLS_LD))
			  value = 1;
			else if (tls_ty != 0)
			  {
			    value -= htab->elf.tls_sec->vma + DTP_OFFSET;
			    if (tls_ty == (TLS_TLS | TLS_TPREL))
			      value += DTP_OFFSET - TP_OFFSET;

			    if (tls_ty == (TLS_TLS | TLS_GD))
			      {
				bfd_put_32 (output_bfd, value,
					    htab->got->contents + off + 4);
				value = 1;
			      }
			  }
			bfd_put_32 (output_bfd, value,
				    htab->got->contents + off);
		      }

		    off += 4;
		    if (tls_ty & (TLS_LD | TLS_GD))
		      off += 4;
		  }
		while (tls_m != 0);

		off = *offp;
		*offp = off | 1;
	      }

	    if (off >= (bfd_vma) -2)
	      abort ();

	    if ((tls_type & TLS_TLS) != 0)
	      {
		if (tls_type != (TLS_TLS | TLS_LD))
		  {
		    if ((tls_mask & TLS_LD) != 0
			&& !(h == NULL
			     || !(h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC)))
		      off += 8;
		    if (tls_type != (TLS_TLS | TLS_GD))
		      {
			if ((tls_mask & TLS_GD) != 0)
			  off += 8;
			if (tls_type != (TLS_TLS | TLS_DTPREL))
			  {
			    if ((tls_mask & TLS_DTPREL) != 0)
			      off += 4;
			  }
		      }
		  }
	      }

	    relocation = htab->got->output_offset + off - 4;

	    /* Addends on got relocations don't make much sense.
	       x+off@@got is actually x@@got+off, and since the got is
	       generated by a hash table traversal, the value in the
	       got at entry m+n bears little relation to the entry m.  */
	    if (addend != 0)
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): non-zero addend on %s reloc against `%s'"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
		 (long) rel->r_offset,
		 howto->name,
		 sym_name);
	  }
	break;

d3138 1
a3138 1
	case R_PPC_LOCAL24PC:
d3141 4
a3144 1
	  if (unresolved_reloc)
d3151 2
a3152 2
							  TRUE))
		return FALSE;
d3157 5
a3161 37
	case R_PPC_DTPREL16:
	case R_PPC_DTPREL16_LO:
	case R_PPC_DTPREL16_HI:
	case R_PPC_DTPREL16_HA:
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
	  break;

	  /* Relocations that may need to be propagated if this is a shared
	     object.  */
	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_TPREL16_HI:
	case R_PPC_TPREL16_HA:
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
	  /* The TPREL16 relocs shouldn't really be used in shared
	     libs as they will result in DT_TEXTREL being set, but
	     support them anyway.  */
	  goto dodyn;

	case R_PPC_TPREL32:
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
	  goto dodyn;

	case R_PPC_DTPREL32:
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
	  goto dodyn;

	case R_PPC_DTPMOD32:
	  relocation = 1;
	  addend = 0;
	  goto dodyn;

	case R_PPC_REL24:
	case R_PPC_REL32:
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
d3164 3
a3166 23
	  if (SYMBOL_REFERENCES_LOCAL (info, h)
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
	    break;
	  /* fall through */

	  /* Relocations that always need to be propagated if this is a shared
	     object.  */
	case R_PPC_ADDR32:
	case R_PPC_ADDR24:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	dodyn:
	  if (r_symndx == 0)
d3168 1
a3168 1
	  /* Fall thru.  */
d3170 12
a3181 14
	  if ((info->shared
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
	       && (MUST_BE_DYN_RELOC (r_type)
		   || !SYMBOL_CALLS_LOCAL (info, h)))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (input_section->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && h->dynindx != -1
		  && (h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
d3183 1
d3187 2
a3188 4
	      fprintf (stderr, "ppc_elf_relocate_section needs to "
		       "create relocation for %s\n",
		       (h && h->root.root.string
			? h->root.root.string : "<unknown>"));
d3192 3
a3194 2
		 are copied into the output file to be resolved at run
		 time.  */
d3204 1
a3204 1
		    return FALSE;
d3211 1
a3211 1
		  sreloc = bfd_get_section_by_name (htab->elf.dynobj, name);
d3228 3
a3230 1
	      else if (!SYMBOL_REFERENCES_LOCAL (info, h))
a3231 1
		  unresolved_reloc = FALSE;
a3236 2
		  outrel.r_addend = relocation + rel->r_addend;

d3238 4
a3241 1
		    outrel.r_info = ELF32_R_INFO (0, R_PPC_RELATIVE);
d3246 10
a3255 1
		      if (bfd_is_abs_section (sec))
d3260 1
a3260 1
			  return FALSE;
a3265 5
			  /* We are turning this relocation into one
			     against a section symbol.  It would be
			     proper to subtract the symbol's value,
			     osec->vma, from the emitted reloc addend,
			     but ld.so expects buggy relocs.  */
d3271 5
a3275 3
			    printf ("indx=%d section=%s flags=%08x name=%s\n",
				    indx, osec->name, osec->flags,
				    h->root.root.string);
d3280 1
d3284 5
a3288 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d3304 34
d3340 64
a3403 9
	case R_PPC_RELAX32PC:
	  relocation -= (input_section->output_section->vma
			 + input_section->output_offset
			 + rel->r_offset - 4);
	  /* Fall thru */
	case R_PPC_RELAX32:
	  {
	    unsigned long t0;
	    unsigned long t1;
d3405 17
a3421 2
	    t0 = bfd_get_32 (output_bfd, contents + rel->r_offset);
	    t1 = bfd_get_32 (output_bfd, contents + rel->r_offset + 4);
d3423 3
a3425 9
	    /* We're clearing the bits for R_PPC_ADDR16_HA
	       and R_PPC_ADDR16_LO here.  */
	    t0 &= ~0xffff;
	    t1 &= ~0xffff;

	    /* t0 is HA, t1 is LO */
	    relocation += addend;
	    t0 |= ((relocation + 0x8000) >> 16) & 0xffff;
	    t1 |= relocation & 0xffff;
d3427 3
a3429 4
	    bfd_put_32 (output_bfd, t0, contents + rel->r_offset);
	    bfd_put_32 (output_bfd, t1, contents + rel->r_offset + 4);
	  }
	  continue;
d3431 6
a3436 7
	  /* Indirect .sdata relocation.  */
	case R_PPC_EMB_SDAI16:
	  BFD_ASSERT (htab->sdata != NULL);
	  relocation
	    = elf_finish_pointer_linker_section (output_bfd, input_bfd, info,
						 htab->sdata, h, relocation,
						 rel, R_PPC_RELATIVE);
d3439 6
a3444 7
	  /* Indirect .sdata2 relocation.  */
	case R_PPC_EMB_SDA2I16:
	  BFD_ASSERT (htab->sdata2 != NULL);
	  relocation
	    = elf_finish_pointer_linker_section (output_bfd, input_bfd, info,
						 htab->sdata2, h, relocation,
						 rel, R_PPC_RELATIVE);
d3447 6
a3452 6
	  /* Handle the TOC16 reloc.  We want to use the offset within the .got
	     section, not the actual VMA.  This is appropriate when generating
	     an embedded ELF object, for which the .got section acts like the
	     AIX .toc section.  */
	case R_PPC_TOC16:			/* phony GOT16 relocations */
	  BFD_ASSERT (sec != NULL);
d3457 1
a3457 1
	    addend -= sec->output_section->vma + sec->output_offset + 0x8000;
d3460 1
a3460 1
	case R_PPC_PLTREL24:
d3462 1
a3462 1
	     procedure linkage table.  */
d3466 1
a3466 1
	      || htab->plt == NULL)
d3469 2
a3470 2
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
d3474 2
a3475 3
	  unresolved_reloc = FALSE;
	  relocation = (htab->plt->output_section->vma
			+ htab->plt->output_offset
d3479 2
a3480 2
	  /* Relocate against _SDA_BASE_.  */
	case R_PPC_SDAREL16:
a3482 1
	    const struct elf_link_hash_entry *sh;
d3484 1
a3484 1
	    BFD_ASSERT (sec != NULL);
d3491 5
a3495 7
		(*_bfd_error_handler)
		  (_("%s: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)"),
		   bfd_archive_filename (input_bfd),
		   sym_name,
		   howto->name,
		   name);
d3497 3
a3499 4
	    sh = htab->sdata->sym_hash;
	    addend -= (sh->root.u.def.value
		       + sh->root.u.def.section->output_section->vma
		       + sh->root.u.def.section->output_offset);
d3503 2
a3504 2
	  /* Relocate against _SDA2_BASE_.  */
	case R_PPC_EMB_SDA2REL:
a3506 1
	    const struct elf_link_hash_entry *sh;
d3508 1
a3508 1
	    BFD_ASSERT (sec != NULL);
d3513 5
a3517 7
		(*_bfd_error_handler)
		  (_("%s: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)"),
		   bfd_archive_filename (input_bfd),
		   sym_name,
		   howto->name,
		   name);
d3520 1
a3520 1
		ret = FALSE;
d3523 3
a3525 4
	    sh = htab->sdata2->sym_hash;
	    addend -= (sh->root.u.def.value
		       + sh->root.u.def.section->output_section->vma
		       + sh->root.u.def.section->output_offset);
d3529 3
a3531 3
	  /* Relocate against either _SDA_BASE_, _SDA2_BASE_, or 0.  */
	case R_PPC_EMB_SDA21:
	case R_PPC_EMB_RELSDA:
a3533 1
	    const struct elf_link_hash_entry *sh;
d3536 1
a3536 1
	    BFD_ASSERT (sec != NULL);
d3538 1
a3538 1
	    if (((strncmp (name, ".sdata", 6) == 0
d3544 3
a3546 4
		sh = htab->sdata->sym_hash;
		addend -= (sh->root.u.def.value
			   + sh->root.u.def.section->output_section->vma
			   + sh->root.u.def.section->output_offset);
d3553 3
a3555 4
		sh = htab->sdata2->sym_hash;
		addend -= (sh->root.u.def.value
			   + sh->root.u.def.section->output_section->vma
			   + sh->root.u.def.section->output_offset);
d3566 5
a3570 7
		(*_bfd_error_handler)
		  (_("%s: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)"),
		   bfd_archive_filename (input_bfd),
		   sym_name,
		   howto->name,
		   name);
d3573 1
a3573 1
		ret = FALSE;
d3579 1
a3579 1
		insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
d3581 1
a3581 1
		bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
d3586 10
a3595 6
	  /* Relocate against the beginning of the section.  */
	case R_PPC_SECTOFF:
	case R_PPC_SECTOFF_LO:
	case R_PPC_SECTOFF_HI:
	case R_PPC_SECTOFF_HA:
	  BFD_ASSERT (sec != NULL);
d3597 9
d3608 1
a3608 6
	  /* Negative relocations.  */
	case R_PPC_EMB_NADDR32:
	case R_PPC_EMB_NADDR16:
	case R_PPC_EMB_NADDR16_LO:
	case R_PPC_EMB_NADDR16_HI:
	case R_PPC_EMB_NADDR16_HA:
d3610 1
d3613 23
a3635 20
	case R_PPC_COPY:
	case R_PPC_GLOB_DAT:
	case R_PPC_JMP_SLOT:
	case R_PPC_RELATIVE:
	case R_PPC_PLT32:
	case R_PPC_PLTREL32:
	case R_PPC_PLT16_LO:
	case R_PPC_PLT16_HI:
	case R_PPC_PLT16_HA:
	case R_PPC_ADDR30:
	case R_PPC_EMB_RELSEC16:
	case R_PPC_EMB_RELST_LO:
	case R_PPC_EMB_RELST_HI:
	case R_PPC_EMB_RELST_HA:
	case R_PPC_EMB_BIT_FLD:
	  (*_bfd_error_handler)
	    (_("%s: relocation %s is not yet supported for symbol %s."),
	     bfd_archive_filename (input_bfd),
	     howto->name,
	     sym_name);
d3638 1
a3638 1
	  ret = FALSE;
a3639 1
	}
d3641 4
a3644 27
      /* Do any further special processing.  */
      switch (r_type)
	{
	default:
	  break;

	case R_PPC_ADDR16_HA:
	case R_PPC_GOT16_HA:
	case R_PPC_PLT16_HA:
	case R_PPC_SECTOFF_HA:
	case R_PPC_TPREL16_HA:
	case R_PPC_DTPREL16_HA:
	case R_PPC_GOT_TLSGD16_HA:
	case R_PPC_GOT_TLSLD16_HA:
	case R_PPC_GOT_TPREL16_HA:
	case R_PPC_GOT_DTPREL16_HA:
	case R_PPC_EMB_NADDR16_HA:
	case R_PPC_EMB_RELST_HA:
	  /* It's just possible that this symbol is a weak symbol
	     that's not actually defined anywhere.  In that case,
	     'sec' would be NULL, and we should leave the symbol
	     alone (it will be set to zero elsewhere in the link).  */
	  if (sec != NULL)
	    /* Add 0x10000 if sign bit in 0:15 is set.
	       Bits 0:15 are not used.  */
	    addend += 0x8000;
	  break;
d3648 1
a3648 2
      fprintf (stderr, "\ttype = %s (%d), name = %s, symbol index = %ld, "
	       "offset = %ld, addend = %ld\n",
d3653 1
a3653 1
	       (long) rel->r_offset,
a3656 14
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     bfd_archive_filename (input_bfd),
	     bfd_get_section_name (input_bfd, input_section),
	     (long) rel->r_offset,
	     howto->name,
	     sym_name);
	  ret = FALSE;
	}

d3661 1
a3661 1
				    rel->r_offset,
d3665 3
a3667 1
      if (r != bfd_reloc_ok)
d3669 3
a3671 3
	  if (sym_name == NULL)
	    sym_name = "(null)";
	  if (r == bfd_reloc_overflow)
d3673 1
a3673 4
	      if (warned)
		continue;
	      if (h != NULL
		  && h->root.type == bfd_link_hash_undefweak
d3685 1
a3685 8
	      if (! (*info->callbacks->reloc_overflow) (info,
							sym_name,
							howto->name,
							rel->r_addend,
							input_bfd,
							input_section,
							rel->r_offset))
		return FALSE;
d3689 7
a3695 6
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): %s reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
		 (long) rel->r_offset, howto->name, sym_name, (int) r);
	      ret = FALSE;
d3697 9
d3707 2
d3719 2
a3720 1
ppc_elf_reloc_type_class (const Elf_Internal_Rela *rela)
d3722 1
a3722 1
  switch (ELF32_R_TYPE (rela->r_info))
d3737 5
a3741 4
/* Support for core dump NOTE sections.  */

static bfd_boolean
ppc_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d3748 2
a3749 2
    default:
      return FALSE;
d3751 10
a3760 3
    case 268:		/* Linux/PPC.  */
      /* pr_cursig */
      elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d3762 1
a3762 8
      /* pr_pid */
      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

      /* pr_reg */
      offset = 72;
      raw_size = 192;

      break;
d3770 4
a3773 2
static bfd_boolean
ppc_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d3777 2
a3778 2
    default:
      return FALSE;
d3780 5
a3784 5
    case 128:		/* Linux/PPC elf_prpsinfo.  */
      elf_tdata (abfd)->core_program
	= _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
      elf_tdata (abfd)->core_command
	= _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
d3799 1
a3799 284
  return TRUE;
}

/* Very simple linked list structure for recording apuinfo values.  */
typedef struct apuinfo_list
{
  struct apuinfo_list *next;
  unsigned long value;
}
apuinfo_list;

static apuinfo_list *head;


static void
apuinfo_list_init (void)
{
  head = NULL;
}

static void
apuinfo_list_add (unsigned long value)
{
  apuinfo_list *entry = head;

  while (entry != NULL)
    {
      if (entry->value == value)
	return;
      entry = entry->next;
    }

  entry = bfd_malloc (sizeof (* entry));
  if (entry == NULL)
    return;

  entry->value = value;
  entry->next  = head;
  head = entry;
}

static unsigned
apuinfo_list_length (void)
{
  apuinfo_list *entry;
  unsigned long count;

  for (entry = head, count = 0;
       entry;
       entry = entry->next)
    ++ count;

  return count;
}

static inline unsigned long
apuinfo_list_element (unsigned long number)
{
  apuinfo_list * entry;

  for (entry = head;
       entry && number --;
       entry = entry->next)
    ;

  return entry ? entry->value : 0;
}

static void
apuinfo_list_finish (void)
{
  apuinfo_list *entry;

  for (entry = head; entry;)
    {
      apuinfo_list *next = entry->next;
      free (entry);
      entry = next;
    }

  head = NULL;
}

#define APUINFO_SECTION_NAME	".PPC.EMB.apuinfo"
#define APUINFO_LABEL		"APUinfo"

/* Scan the input BFDs and create a linked list of
   the APUinfo values that will need to be emitted.  */

static void
ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)
{
  bfd *ibfd;
  asection *asec;
  char *buffer;
  unsigned num_input_sections;
  bfd_size_type	output_section_size;
  unsigned i;
  unsigned num_entries;
  unsigned long	offset;
  unsigned long length;
  const char *error_message = NULL;

  if (link_info == NULL)
    return;

  /* Scan the input bfds, looking for apuinfo sections.  */
  num_input_sections = 0;
  output_section_size = 0;

  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);
      if (asec)
	{
	  ++ num_input_sections;
	  output_section_size += asec->_raw_size;
	}
    }

  /* We need at least one input sections
     in order to make merging worthwhile.  */
  if (num_input_sections < 1)
    return;

  /* Just make sure that the output section exists as well.  */
  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);
  if (asec == NULL)
    return;

  /* Allocate a buffer for the contents of the input sections.  */
  buffer = bfd_malloc (output_section_size);
  if (buffer == NULL)
    return;

  offset = 0;
  apuinfo_list_init ();

  /* Read in the input sections contents.  */
  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      unsigned long datum;
      char *ptr;

      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);
      if (asec == NULL)
	continue;

      length = asec->_raw_size;
      if (length < 24)
	{
	  error_message = _("corrupt or empty %s section in %s");
	  goto fail;
	}

      if (bfd_seek (ibfd, asec->filepos, SEEK_SET) != 0
	  || (bfd_bread (buffer + offset, length, ibfd) != length))
	{
	  error_message = _("unable to read in %s section from %s");
	  goto fail;
	}

      /* Process the contents of the section.  */
      ptr = buffer + offset;
      error_message = _("corrupt %s section in %s");

      /* Verify the contents of the header.  Note - we have to
	 extract the values this way in order to allow for a
	 host whose endian-ness is different from the target.  */
      datum = bfd_get_32 (ibfd, ptr);
      if (datum != sizeof APUINFO_LABEL)
	goto fail;

      datum = bfd_get_32 (ibfd, ptr + 8);
      if (datum != 0x2)
	goto fail;

      if (strcmp (ptr + 12, APUINFO_LABEL) != 0)
	goto fail;

      /* Get the number of bytes used for apuinfo entries.  */
      datum = bfd_get_32 (ibfd, ptr + 4);
      if (datum + 20 != length)
	goto fail;

      /* Make sure that we do not run off the end of the section.  */
      if (offset + length > output_section_size)
	goto fail;

      /* Scan the apuinfo section, building a list of apuinfo numbers.  */
      for (i = 0; i < datum; i += 4)
	apuinfo_list_add (bfd_get_32 (ibfd, ptr + 20 + i));

      /* Update the offset.  */
      offset += length;
    }

  error_message = NULL;

  /* Compute the size of the output section.  */
  num_entries = apuinfo_list_length ();
  output_section_size = 20 + num_entries * 4;

  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);

  if (! bfd_set_section_size (abfd, asec, output_section_size))
    ibfd = abfd,
      error_message = _("warning: unable to set size of %s section in %s");

 fail:
  free (buffer);

  if (error_message)
    (*_bfd_error_handler) (error_message, APUINFO_SECTION_NAME,
			   bfd_archive_filename (ibfd));
}


/* Prevent the output section from accumulating the input sections'
   contents.  We have already stored this in our linked list structure.  */

static bfd_boolean
ppc_elf_write_section (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *asec,
		       bfd_byte *contents ATTRIBUTE_UNUSED)
{
  return (apuinfo_list_length ()
	  && strcmp (asec->name, APUINFO_SECTION_NAME) == 0);
}


/* Finally we can generate the output section.  */

static void
ppc_elf_final_write_processing (bfd *abfd, bfd_boolean linker ATTRIBUTE_UNUSED)
{
  bfd_byte *buffer;
  asection *asec;
  unsigned i;
  unsigned num_entries;
  bfd_size_type length;

  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);
  if (asec == NULL)
    return;

  if (apuinfo_list_length () == 0)
    return;

  length = asec->_raw_size;
  if (length < 20)
    return;

  buffer = bfd_malloc (length);
  if (buffer == NULL)
    {
      (*_bfd_error_handler)
	(_("failed to allocate space for new APUinfo section."));
      return;
    }

  /* Create the apuinfo header.  */
  num_entries = apuinfo_list_length ();
  bfd_put_32 (abfd, sizeof APUINFO_LABEL, buffer);
  bfd_put_32 (abfd, num_entries * 4, buffer + 4);
  bfd_put_32 (abfd, 0x2, buffer + 8);
  strcpy (buffer + 12, APUINFO_LABEL);

  length = 20;
  for (i = 0; i < num_entries; i++)
    {
      bfd_put_32 (abfd, apuinfo_list_element (i), buffer + length);
      length += 4;
    }

  if (length != asec->_raw_size)
    (*_bfd_error_handler) (_("failed to compute new APUinfo section."));

  if (! bfd_set_section_contents (abfd, asec, buffer, (file_ptr) 0, length))
    (*_bfd_error_handler) (_("failed to install new APUinfo section."));

  free (buffer);

  apuinfo_list_finish ();
a3800 19

/* Add extra PPC sections -- Note, for now, make .sbss2 and
   .PPC.EMB.sbss0 a normal section, and not a bss section so
   that the linker doesn't crater when trying to make more than
   2 sections.  */

static struct bfd_elf_special_section const ppc_elf_special_sections[]=
{
  { ".tags",             5,  0, SHT_ORDERED,  SHF_ALLOC },
  { ".sdata",            6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".sbss",             5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".sdata2",           7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".sbss2",            6, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".PPC.EMB.apuinfo", 16,  0, SHT_NOTE,     0 },
  { ".PPC.EMB.sdata0",  15,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".PPC.EMB.sbss0",   14,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".plt",              4,  0, SHT_NOBITS,   SHF_ALLOC + SHF_EXECINSTR },
  { NULL,                0,  0, 0,            0 }
};
a3807 3
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE		0x1000
#else
a3808 1
#endif
d3824 1
a3826 1
#define bfd_elf32_mkobject			ppc_elf_mkobject
d3828 1
a3828 1
#define bfd_elf32_bfd_relax_section		ppc_elf_relax_section
d3831 1
a3831 1
#define bfd_elf32_bfd_link_hash_table_create	ppc_elf_link_hash_table_create
a3839 1
#define elf_backend_copy_indirect_symbol	ppc_elf_copy_indirect_symbol
a3850 4
#define elf_backend_begin_write_processing	ppc_elf_begin_write_processing
#define elf_backend_final_write_processing	ppc_elf_final_write_processing
#define elf_backend_write_section		ppc_elf_write_section
#define elf_backend_special_sections		ppc_elf_special_sections
d3853 21
@


1.51
log
@2002-09-19  Jakub Jelinek  <jakub@@redhat.com>

	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed
	if skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.
@
text
@d3486 4
a3489 2
	    if (strcmp (name, ".sdata") != 0
		&& strcmp (name, ".sbss") != 0)
d3510 2
a3511 1
	    if (strcmp (name, ".sdata2") != 0 && strcmp (name, ".sbss2") != 0)
d3538 4
a3541 1
	    if (strcmp (name, ".sdata") == 0 || strcmp (name, ".sbss") == 0)
d3549 2
a3550 2
	    else if (strcmp (name, ".sdata2") == 0
		     || strcmp (name, ".sbss2") == 0)
@


1.51.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d3486 2
a3487 4
	    if (! ((strncmp (name, ".sdata", 6) == 0
		    && (name[6] == 0 || name[6] == '.'))
		   || (strncmp (name, ".sbss", 5) == 0
		       && (name[5] == 0 || name[5] == '.'))))
d3508 1
a3508 2
	    if (! (strncmp (name, ".sdata2", 7) == 0
		   || strncmp (name, ".sbss2", 6) == 0))
d3535 1
a3535 4
	    if (((strncmp (name, ".sdata", 6) == 0	
		  && (name[6] == 0 || name[6] == '.'))
		 || (strncmp (name, ".sbss", 5) == 0
		     && (name[5] == 0 || name[5] == '.'))))
d3543 2
a3544 2
	    else if (strncmp (name, ".sdata2", 7) == 0
		     || strncmp (name, ".sbss2", 6) == 0)
@


1.51.2.2
log
@2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c (lookup_symbol_aux_block): New function.
	(lookup_symbol_aux_local): Call lookup_symbol_aux_block.
	(lookup_symbol_aux): Ditto.

	* Merge from mainline; tag is carlton_dictionary-20021025-merge.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* cp-support.c: Add comment to demangled name pitfalls.
	* symtab.c (lookup_transparent_type): Add FIXME comment at
	beginning.

2002-10-23  David Carlton  <carlton@@math.stanford.edu>

	* symtab.c: Delete cplusplus_hint.
	Delete prototype for find_template_name_end.
	* dwarf2read.c (scan_partial_symbols): Add in a gdb_assert from a
	later version of my namespace_minimal patch.

2002-10-25  David Carlton  <carlton@@math.stanford.edu>

	* gdb.c++/namespace.exp: Change all of the setup_xfail tests that
	I added into setup_kfails.
@
text
@d3852 1
d3854 1
a3855 20
/* QNX support.  */
#include "elf32-qnx.h"

#undef	TARGET_LITTLE_SYM 
#define	TARGET_LITTLE_SYM		bfd_elf32_powerpcleqnx_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-powerpcle-nto"
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_powerpcqnx_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-powerpc-nto"

#define	elf32_bed			elf32_ppc_qnx_bed

#include "elf32-target.h"

#undef	elf_backend_set_nonloadable_filepos
#undef	elf_backend_is_contained_by_filepos
#undef	elf_backend_copy_private_bfd_data_p
#undef	elf32_bed
@


1.51.2.3
log
@2002-11-15  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021115-merge.
@
text
@d3853 21
@


1.51.2.4
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d39 5
a43 7
  PARAMS ((bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst));
static void ppc_elf_howto_init
  PARAMS ((void));
static int ppc_elf_sort_rela
  PARAMS ((const PTR, const PTR));
static bfd_boolean ppc_elf_relax_section
  PARAMS ((bfd *, asection *, struct bfd_link_info *, bfd_boolean *));
d46 7
a52 10
static bfd_boolean ppc_elf_object_p
  PARAMS ((bfd *));
static bfd_boolean ppc_elf_set_private_flags
  PARAMS ((bfd *, flagword));
static bfd_boolean ppc_elf_merge_private_bfd_data
  PARAMS ((bfd *, bfd *));
static int ppc_elf_additional_program_headers
  PARAMS ((bfd *));
static bfd_boolean ppc_elf_modify_segment_map
  PARAMS ((bfd *));
d55 1
a55 1
static bfd_boolean ppc_elf_create_dynamic_sections
d57 7
a63 4
static bfd_boolean ppc_elf_section_from_shdr
  PARAMS ((bfd *, Elf_Internal_Shdr *, const char *));
static bfd_boolean ppc_elf_fake_sections
  PARAMS ((bfd *, Elf_Internal_Shdr *, asection *));
d65 2
a66 1
  PARAMS ((bfd *abfd, struct bfd_link_info *info,
d68 45
a112 25
static bfd_boolean ppc_elf_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
static asection * ppc_elf_gc_mark_hook
  PARAMS ((asection *sec, struct bfd_link_info *info, Elf_Internal_Rela *rel,
	   struct elf_link_hash_entry *h, Elf_Internal_Sym *sym));
static bfd_boolean ppc_elf_gc_sweep_hook
  PARAMS ((bfd *abfd, struct bfd_link_info *info, asection *sec,
	   const Elf_Internal_Rela *relocs));
static bfd_boolean ppc_elf_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean ppc_elf_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean ppc_elf_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *info, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *relocs, Elf_Internal_Sym *local_syms,
	   asection **));
static bfd_boolean ppc_elf_add_symbol_hook
  PARAMS ((bfd *, struct bfd_link_info *, const Elf_Internal_Sym *,
	   const char **, flagword *, asection **, bfd_vma *));
static bfd_boolean ppc_elf_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static bfd_boolean ppc_elf_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
d115 1
a115 1
static bfd_boolean ppc_elf_grok_prstatus
d117 1
a117 1
static bfd_boolean ppc_elf_grok_psinfo
d164 1
a164 1
	 FALSE,			/* pc_relative */
d169 1
a169 1
	 FALSE,			/* partial_inplace */
d172 1
a172 1
	 FALSE),		/* pcrel_offset */
d179 1
a179 1
	 FALSE,			/* pc_relative */
d184 1
a184 1
	 FALSE,			/* partial_inplace */
d187 1
a187 1
	 FALSE),		/* pcrel_offset */
d195 1
a195 1
	 FALSE,			/* pc_relative */
d200 1
a200 1
	 FALSE,			/* partial_inplace */
d203 1
a203 1
	 FALSE),		/* pcrel_offset */
d210 1
a210 1
	 FALSE,			/* pc_relative */
d215 1
a215 1
	 FALSE,			/* partial_inplace */
d218 1
a218 1
	 FALSE),		/* pcrel_offset */
d225 1
a225 1
	 FALSE,			/* pc_relative */
d230 1
a230 1
	 FALSE,			/* partial_inplace */
d233 1
a233 1
	 FALSE),		/* pcrel_offset */
d240 1
a240 1
	 FALSE,			/* pc_relative */
d245 1
a245 1
	 FALSE,			/* partial_inplace */
d248 1
a248 1
	 FALSE),		/* pcrel_offset */
d256 1
a256 1
	 FALSE,			/* pc_relative */
d261 1
a261 1
	 FALSE,			/* partial_inplace */
d264 1
a264 1
	 FALSE),		/* pcrel_offset */
d272 1
a272 1
	 FALSE,			/* pc_relative */
d277 1
a277 1
	 FALSE,			/* partial_inplace */
d280 1
a280 1
	 FALSE),		/* pcrel_offset */
d289 1
a289 1
	 FALSE,			/* pc_relative */
d294 1
a294 1
	 FALSE,			/* partial_inplace */
d297 1
a297 1
	 FALSE),		/* pcrel_offset */
d306 1
a306 1
	 FALSE,			/* pc_relative */
d311 1
a311 1
	 FALSE,			/* partial_inplace */
d314 1
a314 1
	 FALSE),		/* pcrel_offset */
d321 1
a321 1
	 TRUE,			/* pc_relative */
d326 1
a326 1
	 FALSE,			/* partial_inplace */
d329 1
a329 1
	 TRUE),			/* pcrel_offset */
d336 1
a336 1
	 TRUE,			/* pc_relative */
d341 1
a341 1
	 FALSE,			/* partial_inplace */
d344 1
a344 1
	 TRUE),			/* pcrel_offset */
d353 1
a353 1
	 TRUE,			/* pc_relative */
d358 1
a358 1
	 FALSE,			/* partial_inplace */
d361 1
a361 1
	 TRUE),			/* pcrel_offset */
d370 1
a370 1
	 TRUE,			/* pc_relative */
d375 1
a375 1
	 FALSE,			/* partial_inplace */
d378 1
a378 1
	 TRUE),			/* pcrel_offset */
d386 1
a386 1
	 FALSE,			/* pc_relative */
d391 1
a391 1
	 FALSE,			/* partial_inplace */
d394 1
a394 1
	 FALSE),		/* pcrel_offset */
d402 1
a402 1
	 FALSE,			/* pc_relative */
d407 1
a407 1
	 FALSE,			/* partial_inplace */
d410 1
a410 1
	 FALSE),		/* pcrel_offset */
d418 1
a418 1
	 FALSE,			/* pc_relative */
d423 1
a423 1
	 FALSE,			/* partial_inplace */
d426 1
a426 1
	 FALSE),		 /* pcrel_offset */
d434 1
a434 1
	 FALSE,			/* pc_relative */
d439 1
a439 1
	 FALSE,			/* partial_inplace */
d442 1
a442 1
	 FALSE),		/* pcrel_offset */
d450 1
a450 1
	 TRUE,			/* pc_relative */
d455 1
a455 1
	 FALSE,			/* partial_inplace */
d458 1
a458 1
	 TRUE),			/* pcrel_offset */
d469 1
a469 1
	 FALSE,			/* pc_relative */
d474 1
a474 1
	 FALSE,			/* partial_inplace */
d477 1
a477 1
	 FALSE),		/* pcrel_offset */
d485 1
a485 1
	 FALSE,			/* pc_relative */
d490 1
a490 1
	 FALSE,			/* partial_inplace */
d493 1
a493 1
	 FALSE),		/* pcrel_offset */
d500 1
a500 1
	 FALSE,			/* pc_relative */
d505 1
a505 1
	 FALSE,			/* partial_inplace */
d508 1
a508 1
	 FALSE),		/* pcrel_offset */
d517 1
a517 1
	 FALSE,			/* pc_relative */
d522 1
a522 1
	 FALSE,			/* partial_inplace */
d525 1
a525 1
	 FALSE),		/* pcrel_offset */
d534 1
a534 1
	 TRUE,			/* pc_relative */
d539 1
a539 1
	 FALSE,			/* partial_inplace */
d542 1
a542 1
	 TRUE),			/* pcrel_offset */
d549 1
a549 1
	 FALSE,			/* pc_relative */
d554 1
a554 1
	 FALSE,			/* partial_inplace */
d557 1
a557 1
	 FALSE),		/* pcrel_offset */
d564 1
a564 1
	 FALSE,			/* pc_relative */
d569 1
a569 1
	 FALSE,			/* partial_inplace */
d572 1
a572 1
	 FALSE),		/* pcrel_offset */
d579 1
a579 1
	 TRUE,			/* pc_relative */
d584 1
a584 1
	 FALSE,			/* partial_inplace */
d587 1
a587 1
	 TRUE),			/* pcrel_offset */
d595 1
a595 1
	 FALSE,			/* pc_relative */
d600 1
a600 1
	 FALSE,			/* partial_inplace */
d603 1
a603 1
	 FALSE),		/* pcrel_offset */
d611 1
a611 1
	 TRUE,			/* pc_relative */
d616 1
a616 1
	 FALSE,			/* partial_inplace */
d619 1
a619 1
	 TRUE),			/* pcrel_offset */
d627 1
a627 1
	 FALSE,			/* pc_relative */
d632 1
a632 1
	 FALSE,			/* partial_inplace */
d635 1
a635 1
	 FALSE),		/* pcrel_offset */
d643 1
a643 1
	 FALSE,			/* pc_relative */
d648 1
a648 1
	 FALSE,			/* partial_inplace */
d651 1
a651 1
	 FALSE),		 /* pcrel_offset */
d659 1
a659 1
	 FALSE,			/* pc_relative */
d664 1
a664 1
	 FALSE,			/* partial_inplace */
d667 1
a667 1
	 FALSE),		/* pcrel_offset */
d675 1
a675 1
	 FALSE,			/* pc_relative */
d680 1
a680 1
	 FALSE,			/* partial_inplace */
d683 1
a683 1
	 FALSE),		/* pcrel_offset */
d690 1
a690 1
	 FALSE,			/* pc_relative */
d695 1
a695 1
	 FALSE,			/* partial_inplace */
d698 1
a698 1
	 FALSE),		/* pcrel_offset */
d705 1
a705 1
	 FALSE,			/* pc_relative */
d710 1
a710 1
	 FALSE,			/* partial_inplace */
d713 1
a713 1
	 FALSE),		/* pcrel_offset */
d720 1
a720 1
	 FALSE,			/* pc_relative */
d725 1
a725 1
	 FALSE,			/* partial_inplace */
d728 1
a728 1
	 FALSE),		 /* pcrel_offset */
d735 1
a735 1
	 FALSE,			/* pc_relative */
d740 1
a740 1
	 FALSE,			/* partial_inplace */
d743 1
a743 1
	 FALSE),		/* pcrel_offset */
d753 1
a753 1
	 FALSE,			/* pc_relative */
d758 1
a758 1
	 FALSE,			/* partial_inplace */
d761 1
a761 1
	 FALSE),		/* pcrel_offset */
d768 1
a768 1
	 FALSE,			/* pc_relative */
d773 1
a773 1
	 FALSE,			/* partial_inplace */
d776 1
a776 1
	 FALSE),		/* pcrel_offset */
d783 1
a783 1
	 FALSE,			/* pc_relative */
d788 1
a788 1
	 FALSE,			/* partial_inplace */
d791 1
a791 1
	 FALSE),		/* pcrel_offset */
d798 1
a798 1
	 FALSE,			/* pc_relative */
d803 1
a803 1
	 FALSE,			/* partial_inplace */
d806 1
a806 1
	 FALSE),		/* pcrel_offset */
d815 1
a815 1
	 FALSE,			/* pc_relative */
d820 1
a820 1
	 FALSE,			/* partial_inplace */
d823 1
a823 1
	 FALSE),		/* pcrel_offset */
d832 1
a832 1
	 FALSE,			/* pc_relative */
d837 1
a837 1
	 FALSE,			/* partial_inplace */
d840 1
a840 1
	 FALSE),		/* pcrel_offset */
d849 1
a849 1
	 FALSE,			/* pc_relative */
d854 1
a854 1
	 FALSE,			/* partial_inplace */
d857 1
a857 1
	 FALSE),		/* pcrel_offset */
d865 1
a865 1
	 FALSE,			/* pc_relative */
d870 1
a870 1
	 FALSE,			/* partial_inplace */
d873 1
a873 1
	 FALSE),		/* pcrel_offset */
d882 1
a882 1
	 FALSE,			/* pc_relative */
d887 1
a887 1
	 FALSE,			/* partial_inplace */
d890 1
a890 1
	 FALSE),		/* pcrel_offset */
d906 1
a906 1
	 TRUE,			/* pc_relative */
d911 1
a911 1
	 FALSE,			/* partial_inplace */
d914 1
a914 1
	 FALSE),		/* pcrel_offset */
d921 1
a921 1
	 FALSE,			/* pc_relative */
d926 1
a926 1
	 FALSE,			/* partial_inplace */
d929 1
a929 1
	 FALSE),		/* pcrel_offset */
d936 1
a936 1
	 FALSE,			/* pc_relative */
d941 1
a941 1
	 FALSE,			/* partial_inplace */
d944 1
a944 1
	 FALSE),		/* pcrel_offset */
d951 1
a951 1
	 FALSE,			/* pc_relative */
d956 1
a956 1
	 FALSE,			/* partial_inplace */
d959 1
a959 1
	 FALSE),		/* pcrel_offset */
d1013 1
a1013 1
static bfd_boolean
d1018 1
a1018 1
     bfd_boolean *again;
d1030 1
a1030 1
  *again = FALSE;
d1041 1
a1041 1
      bfd_boolean section_modified;
d1119 1
a1119 1
      section_modified = FALSE;
d1132 1
a1132 1
              bfd_boolean skip, modified;
d1136 1
a1136 1
              skip = FALSE;
d1145 1
a1145 1
                      if (r_offset == isec_offset) skip = TRUE;
d1156 1
a1156 1
              modified = FALSE;
d1173 1
a1173 1
                          modified = TRUE;
d1187 1
a1187 1
                      modified = TRUE;
d1200 1
a1200 1
                      modified = TRUE;
d1209 1
a1209 1
		  section_modified = TRUE;
d1244 1
a1244 1
  return TRUE;
d1253 1
a1253 1
  return FALSE;
d1336 1
a1336 1
     Elf_Internal_Rela *dst;
d1387 1
a1387 1
static bfd_boolean
d1402 1
a1402 1
  return TRUE;
d1407 1
a1407 1
static bfd_boolean
d1416 2
a1417 2
  elf_flags_init (abfd) = TRUE;
  return TRUE;
d1422 1
a1422 1
static bfd_boolean
d1429 1
a1429 1
  bfd_boolean error;
d1433 1
a1433 1
    return FALSE;
d1437 1
a1437 1
    return TRUE;
d1443 1
a1443 1
      elf_flags_init (obfd) = TRUE;
d1454 1
a1454 1
      error = FALSE;
d1458 1
a1458 1
	  error = TRUE;
d1466 1
a1466 1
	  error = TRUE;
d1492 1
a1492 1
	  error = TRUE;
d1501 1
a1501 1
	  return FALSE;
d1505 1
a1505 1
  return TRUE;
d1511 1
a1511 1
static bfd_boolean
d1514 1
a1514 1
     Elf_Internal_Shdr *hdr;
d1521 1
a1521 1
    return FALSE;
d1532 1
a1532 1
  return TRUE;
d1537 1
a1537 1
static bfd_boolean
d1540 1
a1540 1
     Elf_Internal_Shdr *shdr;
d1549 1
a1549 1
  return TRUE;
d1575 1
a1575 1
      defaults.hole_written_p = FALSE;
d1652 1
a1652 1
static bfd_boolean
d1656 1
a1656 1
  return TRUE;
d1687 1
a1687 1
static bfd_boolean
d1696 1
a1696 1
    return FALSE;
d1699 1
a1699 1
    return FALSE;
d1707 1
a1707 1
    return FALSE;
d1715 1
a1715 1
	return FALSE;
d1732 1
a1732 1
static bfd_boolean
d1782 1
a1782 1
	  return TRUE;
d1789 1
a1789 1
	    return FALSE;
d1836 1
a1836 1
      return TRUE;
d1850 1
a1850 1
      return TRUE;
d1861 1
a1861 1
    return TRUE;
d1912 1
a1912 1
	return FALSE;
d1922 1
a1922 1
  return TRUE;
d1927 1
a1927 1
static bfd_boolean
d1934 2
a1935 2
  bfd_boolean plt;
  bfd_boolean relocs;
d1978 2
a1979 2
  plt = FALSE;
  relocs = FALSE;
d1983 1
a1983 1
      bfd_boolean strip;
d1992 1
a1992 1
      strip = FALSE;
d2000 1
a2000 1
	      strip = TRUE;
d2005 1
a2005 1
	      plt = TRUE;
d2021 1
a2021 1
	      strip = TRUE;
d2026 1
a2026 1
	      relocs = TRUE;
d2050 1
a2050 1
	return FALSE;
d2066 1
a2066 1
	    return FALSE;
d2075 1
a2075 1
	    return FALSE;
d2083 1
a2083 1
	    return FALSE;
d2089 1
a2089 1
	    return FALSE;
d2095 1
a2095 1
  return TRUE;
d2102 1
a2102 1
static bfd_boolean
d2122 1
a2122 1
    return TRUE;
d2137 1
a2137 1
	return FALSE;
d2144 1
a2144 1
	return FALSE;
d2181 1
a2181 1
		return FALSE;
d2200 1
a2200 1
		return FALSE;
d2219 1
a2219 1
		    return FALSE;
d2230 1
a2230 1
		      return FALSE;
d2251 1
a2251 1
		    return FALSE;
d2275 1
a2275 1
	      return FALSE;
d2293 1
a2293 1
		    return FALSE;
d2298 1
a2298 1
	    return FALSE;
d2309 1
a2309 1
	      return FALSE;
d2327 1
a2327 1
		    return FALSE;
d2332 1
a2332 1
	    return FALSE;
d2345 1
a2345 1
	      return FALSE;
d2368 1
a2368 1
	      return FALSE;
d2375 1
a2375 1
		return FALSE;
d2398 1
a2398 1
	    return FALSE;
d2405 1
a2405 1
	    return FALSE;
d2438 1
a2438 1
		    return FALSE;
d2457 1
a2457 1
			return FALSE;
d2477 1
a2477 1
  return TRUE;
d2522 1
a2522 1
static bfd_boolean
d2580 1
a2580 1
  return TRUE;
d2586 1
a2586 1
static bfd_boolean
d2617 1
a2617 1
	    return FALSE;
d2628 1
a2628 1
	    return FALSE;
d2639 1
a2639 1
  return TRUE;
d2645 1
a2645 1
static bfd_boolean
a2666 1
      bfd_byte *loc;
d2695 3
a2697 2
      loc = srela->contents + reloc_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a2718 1
      bfd_byte *loc;
d2751 4
a2754 3
      loc = srela->contents;
      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
a2760 1
      bfd_byte *loc;
d2783 4
a2786 2
      loc = s->contents + s->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d2799 1
a2799 1
  return TRUE;
d2804 1
a2804 1
static bfd_boolean
d2833 1
a2833 1
	  bfd_boolean size;
d2839 4
a2842 4
	    case DT_PLTGOT:   name = ".plt";	  size = FALSE; break;
	    case DT_PLTRELSZ: name = ".rela.plt"; size = TRUE;  break;
	    case DT_JMPREL:   name = ".rela.plt"; size = FALSE; break;
	    default:	      name = NULL;	  size = FALSE; break;
d2886 1
a2886 1
  return TRUE;
d2918 1
a2918 1
static bfd_boolean
d2930 1
a2930 1
  Elf_Internal_Shdr *symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
d2932 6
a2937 6
  bfd *dynobj = elf_hash_table (info)->dynobj;
  elf_linker_section_t *sdata = NULL;
  elf_linker_section_t *sdata2 = NULL;
  Elf_Internal_Rela *rel = relocs;
  Elf_Internal_Rela *relend = relocs + input_section->reloc_count;
  asection *sreloc = NULL;
d2941 1
a2941 1
  bfd_boolean ret = TRUE;
a2943 6
  if (dynobj)
    {
      sdata = elf_linker_section (dynobj, LINKER_SECTION_SDATA);
      sdata2 = elf_linker_section (dynobj, LINKER_SECTION_SDATA2);
    }

d2953 1
a2953 1
    return TRUE;
d2992 1
a2992 1
	  ret = FALSE;
d3118 1
a3118 1
		return FALSE;
d3131 1
a3131 1
	  ret = FALSE;
d3151 2
a3152 2
							  TRUE))
		return FALSE;
a3183 1
	      bfd_byte *loc;
d3204 1
a3204 1
		    return FALSE;
a3236 2
		  outrel.r_addend = relocation + rel->r_addend;

d3238 4
a3241 1
		    outrel.r_info = ELF32_R_INFO (0, R_PPC_RELATIVE);
d3255 1
a3255 2

		      if (bfd_is_abs_section (sec))
d3260 1
a3260 1
			  return FALSE;
a3265 5
			  /* We are turning this relocation into one
			     against a section symbol.  It would be
			     proper to subtract the symbol's value,
			     osec->vma, from the emitted reloc addend,
			     but ld.so expects buggy relocs.  */
d3280 1
d3284 5
a3288 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
a3403 1
		      bfd_byte *loc;
d3415 5
a3419 3
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
d3520 1
a3520 1
		ret = FALSE;
d3538 1
a3538 1
	    if (((strncmp (name, ".sdata", 6) == 0
d3573 1
a3573 1
		ret = FALSE;
d3638 1
a3638 1
	  ret = FALSE;
d3705 1
a3705 1
	    return FALSE;
d3708 1
a3708 1
	ret = FALSE;
d3738 1
a3738 1
static bfd_boolean
d3749 1
a3749 1
	return FALSE;
d3770 1
a3770 1
static bfd_boolean
d3778 1
a3778 1
	return FALSE;
d3799 1
a3799 304
  return TRUE;
}

/* Very simple linked list structure for recording apuinfo values.  */
typedef struct apuinfo_list
{
  struct apuinfo_list *	next;
  unsigned long         value;
}
apuinfo_list;

static apuinfo_list * head;

static void          apuinfo_list_init    PARAMS ((void));
static void          apuinfo_list_add     PARAMS ((unsigned long));
static unsigned      apuinfo_list_length  PARAMS ((void));
static unsigned long apuinfo_list_element PARAMS ((unsigned long));
static void          apuinfo_list_finish  PARAMS ((void));

extern void          ppc_elf_begin_write_processing
  PARAMS ((bfd *, struct bfd_link_info *));
extern void          ppc_elf_final_write_processing
  PARAMS ((bfd *, bfd_boolean));
extern bfd_boolean   ppc_elf_write_section
  PARAMS ((bfd *, asection *, bfd_byte *));



static void
apuinfo_list_init PARAMS ((void))
{
  head = NULL;
}

static void
apuinfo_list_add (value)
     unsigned long value;
{
  apuinfo_list * entry = head;

  while (entry != NULL)
    {
      if (entry->value == value)
	return;
      entry = entry->next;
    }

  entry = bfd_malloc (sizeof (* entry));
  if (entry == NULL)
    return;

  entry->value = value;
  entry->next  = head;
  head = entry;
}

static unsigned
apuinfo_list_length PARAMS ((void))
{
  apuinfo_list * entry;
  unsigned long count;

  for (entry = head, count = 0;
       entry;
       entry = entry->next)
    ++ count;

  return count;
}

static inline unsigned long
apuinfo_list_element (number)
     unsigned long number;
{
  apuinfo_list * entry;

  for (entry = head;
       entry && number --;
       entry = entry->next)
    ;

  return entry ? entry->value : 0;
}

static void
apuinfo_list_finish PARAMS ((void))
{
  apuinfo_list * entry;

  for (entry = head; entry;)
    {
      apuinfo_list * next = entry->next;
      free (entry);
      entry = next;
    }

  head = NULL;
}

#define APUINFO_SECTION_NAME ".PPC.EMB.apuinfo"
#define APUINFO_LABEL        "APUinfo"

/* Scan the input BFDs and create a linked list of
   the APUinfo values that will need to be emitted.  */

void
ppc_elf_begin_write_processing (abfd, link_info)
     bfd *abfd;
     struct bfd_link_info *link_info;
{
  bfd *         ibfd;
  asection *    asec;
  char *        buffer;
  unsigned 	num_input_sections;
  bfd_size_type	output_section_size;
  unsigned      i;
  unsigned      num_entries;
  unsigned long	offset;
  unsigned long length;
  const char *  error_message = NULL;

  if (link_info == NULL)
    return;

  /* Scan the input bfds, looking for apuinfo sections.  */
  num_input_sections = 0;
  output_section_size = 0;

  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);
      if (asec)
	{
	  ++ num_input_sections;
	  output_section_size += asec->_raw_size;
	}
    }

  /* We need at least one input sections
     in order to make merging worthwhile.  */
  if (num_input_sections < 1)
    return;

  /* Just make sure that the output section exists as well.  */
  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);
  if (asec == NULL)
    return;

  /* Allocate a buffer for the contents of the input sections.  */
  buffer = bfd_malloc (output_section_size);
  if (buffer == NULL)
    return;

  offset = 0;
  apuinfo_list_init ();

  /* Read in the input sections contents.  */
  for (ibfd = link_info->input_bfds; ibfd; ibfd = ibfd->link_next)
    {
      unsigned long	datum;
      char *		ptr;

      
      asec = bfd_get_section_by_name (ibfd, APUINFO_SECTION_NAME);
      if (asec == NULL)
	continue;

      length = asec->_raw_size;
      if (length < 24)
	{
	  error_message = _("corrupt or empty %s section in %s");
	  goto fail;
	}
      
      if (bfd_seek (ibfd, asec->filepos, SEEK_SET) != 0
	  || (bfd_bread (buffer + offset, length, ibfd) != length))
	{
	  error_message = _("unable to read in %s section from %s");
	  goto fail;
	}

      /* Process the contents of the section.  */
      ptr = buffer + offset;
      error_message = _("corrupt %s section in %s");

      /* Verify the contents of the header.  Note - we have to
	 extract the values this way in order to allow for a
	 host whose endian-ness is different from the target.  */
      datum = bfd_get_32 (ibfd, ptr);
      if (datum != sizeof APUINFO_LABEL)
	goto fail;

      datum = bfd_get_32 (ibfd, ptr + 8);
      if (datum != 0x2)
	goto fail;

      if (strcmp (ptr + 12, APUINFO_LABEL) != 0)
	goto fail;

      /* Get the number of apuinfo entries.  */
      datum = bfd_get_32 (ibfd, ptr + 4);
      if ((datum * 4 + 20) != length)
	goto fail;

      /* Make sure that we do not run off the end of the section.  */
      if (offset + length > output_section_size)
	goto fail;

      /* Scan the apuinfo section, building a list of apuinfo numbers.  */
      for (i = 0; i < datum; i++)
	apuinfo_list_add (bfd_get_32 (ibfd, ptr + 20 + (i * 4)));

      /* Update the offset.  */
      offset += length;
    }

  error_message = NULL;

  /* Compute the size of the output section.  */
  num_entries = apuinfo_list_length ();
  output_section_size = 20 + num_entries * 4;

  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);

  if (! bfd_set_section_size  (abfd, asec, output_section_size))
    ibfd = abfd,
      error_message = _("warning: unable to set size of %s section in %s");
  
 fail:
  free (buffer);

  if (error_message)
    _bfd_error_handler (error_message, APUINFO_SECTION_NAME,
			bfd_archive_filename (ibfd));
}


/* Prevent the output section from accumulating the input sections'
   contents.  We have already stored this in our linked list structure.  */

bfd_boolean
ppc_elf_write_section (abfd, asec, contents)
     bfd * abfd ATTRIBUTE_UNUSED;
     asection * asec;
     bfd_byte * contents ATTRIBUTE_UNUSED;
{
  return apuinfo_list_length () && strcmp (asec->name, APUINFO_SECTION_NAME) == 0;
}


/* Finally we can generate the output section.  */

void
ppc_elf_final_write_processing (abfd, linker)
     bfd * abfd;
     bfd_boolean linker ATTRIBUTE_UNUSED;
{
  bfd_byte *    buffer;
  asection *    asec;
  unsigned      i;
  unsigned      num_entries;
  bfd_size_type length;

  asec = bfd_get_section_by_name (abfd, APUINFO_SECTION_NAME);
  if (asec == NULL)
    return;

  if (apuinfo_list_length () == 0)
    return;

  length = asec->_raw_size;
  if (length < 20)
    return;

  buffer = bfd_malloc (length);
  if (buffer == NULL)
    {
      _bfd_error_handler (_("failed to allocate space for new APUinfo section."));
      return;
    }

  /* Create the apuinfo header.  */
  num_entries = apuinfo_list_length ();
  bfd_put_32 (abfd, sizeof APUINFO_LABEL, buffer);
  bfd_put_32 (abfd, num_entries, buffer + 4);
  bfd_put_32 (abfd, 0x2, buffer + 8);
  strcpy (buffer + 12, APUINFO_LABEL);
  
  length = 20;
  for (i = 0; i < num_entries; i++)
    {
      bfd_put_32 (abfd, apuinfo_list_element (i), buffer + length);
      length += 4;
    }

  if (length != asec->_raw_size)
    _bfd_error_handler (_("failed to compute new APUinfo section."));
  
  if (! bfd_set_section_contents (abfd, asec, buffer, (file_ptr) 0, length))
    _bfd_error_handler (_("failed to install new APUinfo section."));
    
  free (buffer);

  apuinfo_list_finish ();
a3850 3
#define elf_backend_begin_write_processing      ppc_elf_begin_write_processing
#define elf_backend_final_write_processing      ppc_elf_final_write_processing
#define elf_backend_write_section               ppc_elf_write_section
@


1.51.2.5
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
a35 8
static struct bfd_hash_entry *ppc_elf_link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *entry, struct bfd_hash_table *table,
	   const char *string));
static struct bfd_link_hash_table *ppc_elf_link_hash_table_create
  PARAMS ((bfd *abfd));
static void ppc_elf_copy_indirect_symbol
  PARAMS ((struct elf_backend_data *bed, struct elf_link_hash_entry *dir,
	   struct elf_link_hash_entry *ind));
a79 4
static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
a136 143
/* The PPC linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct ppc_elf_dyn_relocs
{
  struct ppc_elf_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;
};

/* PPC ELF linker hash entry.  */

struct ppc_elf_link_hash_entry
{
  struct elf_link_hash_entry root;

  /* Track dynamic relocs copied for this symbol.  */
  struct ppc_elf_dyn_relocs *dyn_relocs;
};

#define ppc_elf_hash_entry(ent) ((struct ppc_elf_link_hash_entry *) (ent))

/* PPC ELF linker hash table.  */

struct ppc_elf_link_hash_table
{
  struct elf_link_hash_table root;

  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};

/* Get the PPC ELF linker hash table from a link_info structure.  */

#define ppc_elf_hash_table(p) \
  ((struct ppc_elf_link_hash_table *) (p)->hash)

/* Create an entry in a PPC ELF linker hash table.  */

static struct bfd_hash_entry *
ppc_elf_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct ppc_elf_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    ppc_elf_hash_entry (entry)->dyn_relocs = NULL;

  return entry;
}

/* Create a PPC ELF linker hash table.  */

static struct bfd_link_hash_table *
ppc_elf_link_hash_table_create (abfd)
     bfd *abfd;
{
  struct ppc_elf_link_hash_table *ret;

  ret = ((struct ppc_elf_link_hash_table *)
	 bfd_malloc (sizeof (struct ppc_elf_link_hash_table)));
  if (ret == NULL)
    return NULL;

  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       ppc_elf_link_hash_newfunc))
    {
      free (ret);
      return NULL;
    }

  ret->sym_sec.abfd = NULL;

  return &ret->root.root;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
ppc_elf_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
{
  struct ppc_elf_link_hash_entry *edir, *eind;

  edir = (struct ppc_elf_link_hash_entry *) dir;
  eind = (struct ppc_elf_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct ppc_elf_dyn_relocs **pp;
	  struct ppc_elf_dyn_relocs *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct ppc_elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

a1905 59
/* Allocate space in associated reloc sections for dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (h, info)
     struct elf_link_hash_entry *h;
     PTR info ATTRIBUTE_UNUSED;
{
  struct ppc_elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
    }

  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (h, info)
     struct elf_link_hash_entry *h;
     PTR info;
{
  struct ppc_elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL
	  && ((s->flags & (SEC_READONLY | SEC_ALLOC))
	      == (SEC_READONLY | SEC_ALLOC)))
	{
	  ((struct bfd_link_info *) info)->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

a1916 1
  bfd *ibfd;
a1955 39
  /* Allocate space for local sym dynamic relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct ppc_elf_dyn_relocs *p;

	  for (p = ((struct ppc_elf_dyn_relocs *)
		   elf_section_data (s)->local_dynrel);
	      p != NULL;
	      p = p->next)
	    {
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  elf_section_data (p->sec)->sreloc->_raw_size
		    += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags
		       & (SEC_READONLY | SEC_ALLOC))
		      == (SEC_READONLY | SEC_ALLOC))
		    info->flags |= DF_TEXTREL;
		}
	    }
	}
    }

  /* Allocate space for global sym dynamic relocs.  */
  elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, NULL);

a2066 6
      /* If any dynamic relocs apply to a read-only section, then we
	 need a DT_TEXTREL entry.  */
      if ((info->flags & DF_TEXTREL) == 0)
	elf_link_hash_traverse (elf_hash_table (info), readonly_dynrelocs,
				(PTR) info);

d2071 1
a2405 3
	      struct ppc_elf_dyn_relocs *p;
	      struct ppc_elf_dyn_relocs **head;

d2440 2
a2441 1
		  elf_section_data (sec)->sreloc = sreloc;
d2444 1
a2444 35
	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		{
		  head = &ppc_elf_hash_entry (h)->dyn_relocs;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */

		  asection *s;
		  s = (bfd_section_from_r_symndx
		       (abfd, &ppc_elf_hash_table (info)->sym_sec,
			sec, r_symndx));
		  if (s == NULL)
		    return FALSE;

		  head = ((struct ppc_elf_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  p = ((struct ppc_elf_dyn_relocs *)
		       bfd_alloc (elf_hash_table (info)->dynobj, sizeof *p));
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		}
d2446 6
a2451 1
	      p->count++;
a2516 2
  elf_section_data (sec)->local_dynrel = NULL;

d2555 1
a2555 1
	/* Fall through */
a2557 17
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct ppc_elf_dyn_relocs **pp, *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    for (pp = &ppc_elf_hash_entry (h)->dyn_relocs;
		 (p = *pp) != NULL;
		 pp = &p->next)
	      if (p->sec == sec)
		{
		  if (--p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
a3416 2
	  if (r_type == R_PPC_GOT16_HA)
	    addend += ((relocation + addend) & 0x8000) << 1;
d3949 1
a3949 1

d3960 1
a3960 1

d4014 1
a4014 1

d4074 1
a4074 1

d4084 1
a4084 1

d4087 1
a4087 1

a4122 1
#define bfd_elf32_bfd_link_hash_table_create  	ppc_elf_link_hash_table_create
a4130 1
#define elf_backend_copy_indirect_symbol	ppc_elf_copy_indirect_symbol
@


1.51.2.6
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a32 1
#include "elf32-ppc.h"
a55 2
static bfd_reloc_status_type ppc_elf_unhandled_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d66 1
a66 1
static bfd_boolean ppc_elf_create_got
a76 4
static bfd_boolean update_local_sym_info
  PARAMS ((bfd *, Elf_Internal_Shdr *, unsigned long, int));
static void bad_shared_reloc
  PARAMS ((bfd *, enum elf_ppc_reloc_type));
d80 1
a80 1
static asection *ppc_elf_gc_mark_hook
d113 3
a115 6
/* Branch prediction bit for branch taken relocs.  */
#define BRANCH_PREDICT_BIT 0x200000
/* Mask to set RA in memory instructions.  */
#define RA_REGISTER_MASK 0x001f0000
/* Value to shift register by to insert RA.  */
#define RA_REGISTER_SHIFT 16
d119 1
a130 9
/* Some nop instructions.  */
#define NOP		0x60000000
#define CROR_151515	0x4def7b82
#define CROR_313131	0x4ffffb82

/* Offset of tp and dtp pointers from start of TLS block.  */
#define TP_OFFSET	0x7000
#define DTP_OFFSET	0x8000

a163 3

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
d170 1
a170 1
  struct elf_link_hash_entry elf;
a173 13

  /* Contexts in which symbol is used in the GOT (or TOC).
     TLS_GD .. TLS_EXPLICIT bits are or'd into the mask as the
     corresponding relocs are encountered during check_relocs.
     tls_optimize clears TLS_GD .. TLS_TPREL when optimizing to
     indicate the corresponding GOT entry type is not needed.  */
#define TLS_GD		 1	/* GD reloc. */
#define TLS_LD		 2	/* LD reloc. */
#define TLS_TPREL	 4	/* TPREL reloc, => IE. */
#define TLS_DTPREL	 8	/* DTPREL reloc, => LD. */
#define TLS_TLS		16	/* Any TLS reloc.  */
#define TLS_TPRELGD	32	/* TPREL reloc resulting from GD->IE. */
  char tls_mask;
d182 1
a182 25
  struct elf_link_hash_table elf;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *got;
  asection *relgot;
  asection *plt;
  asection *relplt;
  asection *dynbss;
  asection *relbss;
  asection *dynsbss;
  asection *relsbss;
  elf_linker_section_t *sdata;
  elf_linker_section_t *sdata2;

  /* Short-cut to first output tls section.  */
  asection *tls_sec;

  /* Shortcut to .__tls_get_addr.  */
  struct elf_link_hash_entry *tls_get_addr;

  /* TLS local dynamic got entry handling.  */
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tlsld_got;
d214 1
a214 4
    {
      ppc_elf_hash_entry (entry)->dyn_relocs = NULL;
      ppc_elf_hash_entry (entry)->tls_mask = 0;
    }
d232 1
a232 1
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd,
a238 13
  ret->got = NULL;
  ret->relgot = NULL;
  ret->plt = NULL;
  ret->relplt = NULL;
  ret->dynbss = NULL;
  ret->relbss = NULL;
  ret->dynsbss = NULL;
  ret->relsbss = NULL;
  ret->sdata = NULL;
  ret->sdata2 = NULL;
  ret->tls_sec = NULL;
  ret->tls_get_addr = NULL;
  ret->tlsld_got.refcount = 0;
d241 1
a241 1
  return &ret->elf.root;
a274 1
		    q->pc_count += p->pc_count;
a288 2
  edir->tls_mask |= eind->tls_mask;

d881 5
a885 2
  /* Marker reloc for TLS.  */
  HOWTO (R_PPC_TLS,
d891 1
a891 1
	 complain_overflow_dont, /* complain_on_overflow */
d893 1
a893 17
	 "R_PPC_TLS",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Computes the load module index of the load module that contains the
     definition of its TLS sym.  */
  HOWTO (R_PPC_DTPMOD32,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPMOD32",	/* name */
d899 2
a900 19
  /* Computes a dtv-relative displacement, the difference between the value
     of sym+add and the base address of the thread-local storage block that
     contains the definition of sym, minus 0x8000.  */
  HOWTO (R_PPC_DTPREL32,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit dtprel reloc.  */
  HOWTO (R_PPC_DTPREL16,
d906 3
a908 3
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16",	/* name */
d914 2
a915 2
  /* Like DTPREL16, but no overflow.  */
  HOWTO (R_PPC_DTPREL16_LO,
d921 3
a923 3
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16_LO",	/* name */
d929 2
a930 2
  /* Like DTPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_DTPREL16_HI,
d937 2
a938 2
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16_HI",	/* name */
d944 4
a947 2
  /* Like DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_DTPREL16_HA,
d954 2
a955 2
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_DTPREL16_HA",	/* name */
d961 4
a964 18
  /* Computes a tp-relative displacement, the difference between the value of
     sym+add and the value of the thread pointer (r13).  */
  HOWTO (R_PPC_TPREL32,
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A 16 bit tprel reloc.  */
  HOWTO (R_PPC_TPREL16,
d970 3
a972 3
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16",	/* name */
d978 4
a981 2
  /* Like TPREL16, but no overflow.  */
  HOWTO (R_PPC_TPREL16_LO,
d987 3
a989 3
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16_LO",	/* name */
d995 3
a997 34
  /* Like TPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16_HI",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_TPREL16_HA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and (sym+add)@@dtprel, and computes the offset
     to the first entry.  */
  HOWTO (R_PPC_GOT_TLSGD16,
d1004 2
a1005 2
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16",	/* name */
d1011 4
a1014 2
  /* Like GOT_TLSGD16, but no overflow.  */
  HOWTO (R_PPC_GOT_TLSGD16_LO,
d1016 1
a1016 1
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
d1020 3
a1022 3
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16_LO", /* name */
d1028 6
a1033 14
  /* Like GOT_TLSGD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_TLSGD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1035 4
a1038 19
  /* Like GOT_TLSGD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_TLSGD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSGD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates two contiguous entries in the GOT to hold a tls_index structure,
     with values (sym+add)@@dtpmod and zero, and computes the offset to the
     first entry.  */
  HOWTO (R_PPC_GOT_TLSLD16,
d1042 1
a1042 1
	 FALSE,			/* pc_relative */
d1045 2
a1046 2
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16",	/* name */
d1052 2
a1053 2
  /* Like GOT_TLSLD16, but no overflow.  */
  HOWTO (R_PPC_GOT_TLSLD16_LO,
d1055 2
a1056 2
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
d1060 2
a1061 2
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16_LO", /* name */
d1064 1
a1064 1
	 0xffff,		/* dst_mask */
d1067 5
a1071 5
  /* Like GOT_TLSLD16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_TLSLD16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
d1075 2
a1076 2
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16_HI", /* name */
d1079 1
a1079 1
	 0xffff,		/* dst_mask */
d1082 2
a1083 18
  /* Like GOT_TLSLD16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_TLSLD16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TLSLD16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@dtprel, and computes
     the offset to the entry.  */
  HOWTO (R_PPC_GOT_DTPREL16,
d1090 2
a1091 2
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16",	/* name */
d1096 8
d1105 9
a1113 14
  /* Like GOT_DTPREL16, but no overflow.  */
  HOWTO (R_PPC_GOT_DTPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1115 8
a1122 14
  /* Like GOT_DTPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_DTPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
d1124 10
a1133 328
  /* Like GOT_DTPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_DTPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_DTPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Allocates an entry in the GOT with value (sym+add)@@tprel, and computes the
     offset to the entry.  */
  HOWTO (R_PPC_GOT_TPREL16,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16, but no overflow.  */
  HOWTO (R_PPC_GOT_TPREL16_LO,
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16_LO", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_LO, but next higher group of 16 bits.  */
  HOWTO (R_PPC_GOT_TPREL16_HI,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Like GOT_TPREL16_HI, but adjust for low 16 bits.  */
  HOWTO (R_PPC_GOT_TPREL16_HA,
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_unhandled_reloc, /* special_function */
	 "R_PPC_GOT_TPREL16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The remaining relocs are from the Embedded ELF ABI, and are not
     in the SVR4 ELF ABI.  */

  /* 32 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR32,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffffffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16_LO,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont,/* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_ADDR16_LO",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of the addend minus the symbol.  */
  HOWTO (R_PPC_EMB_NADDR16_HI,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_NADDR16_HI", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* The high order 16 bits of the result of the addend minus the address,
     plus 1 if the contents of the low 16 bits, treated as a signed number,
     is negative.  */
  HOWTO (R_PPC_EMB_NADDR16_HA,	/* type */
	 16,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 ppc_elf_addr16_ha_reloc, /* special_function */
	 "R_PPC_EMB_NADDR16_HA", /* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from allocating a 4 byte word to hold an
     address in the .sdata section, and returning the offset from
     _SDA_BASE_ for that relocation.  */
  HOWTO (R_PPC_EMB_SDAI16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDAI16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* 16 bit value resulting from allocating a 4 byte word to hold an
     address in the .sdata2 section, and returning the offset from
     _SDA2_BASE_ for that relocation.  */
  HOWTO (R_PPC_EMB_SDA2I16,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_bitfield, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA2I16",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* A sign-extended 16 bit value relative to _SDA2_BASE_, for use with
     small data items.	 */
  HOWTO (R_PPC_EMB_SDA2REL,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA2REL",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Relocate against either _SDA_BASE_ or _SDA2_BASE_, filling in the 16 bit
     signed offset from the appropriate base, and filling in the register
     field with the appropriate register (0, 2, or 13).  */
  HOWTO (R_PPC_EMB_SDA21,	/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_SDA21",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Relocation not handled: R_PPC_EMB_MRKREF */
  /* Relocation not handled: R_PPC_EMB_RELSEC16 */
  /* Relocation not handled: R_PPC_EMB_RELST_LO */
  /* Relocation not handled: R_PPC_EMB_RELST_HI */
  /* Relocation not handled: R_PPC_EMB_RELST_HA */
  /* Relocation not handled: R_PPC_EMB_BIT_FLD */

  /* PC relative relocation against either _SDA_BASE_ or _SDA2_BASE_, filling
     in the 16 bit signed offset from the appropriate base, and filling in the
     register field with the appropriate register (0, 2, or 13).  */
  HOWTO (R_PPC_EMB_RELSDA,	/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_EMB_RELSDA",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_PPC_GNU_VTINHERIT,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC_GNU_VTINHERIT",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_PPC_GNU_VTENTRY,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 NULL,			/* special_function */
	 "R_PPC_GNU_VTENTRY",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  /* Phony reloc to handle AIX style TOC entries.  */
  HOWTO (R_PPC_TOC16,		/* type */
	 0,			/* rightshift */
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_TOC16",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0xffff,		/* dst_mask */
	 FALSE),		/* pcrel_offset */
};

/* Initialize the ppc_elf_howto_table, so that linear accesses can be done.  */

static void
ppc_elf_howto_init ()
{
  unsigned int i, type;

  for (i = 0; i < sizeof (ppc_elf_howto_raw) / sizeof (ppc_elf_howto_raw[0]); i++)
    {
      type = ppc_elf_howto_raw[i].type;
      BFD_ASSERT (type < sizeof (ppc_elf_howto_table) / sizeof (ppc_elf_howto_table[0]));
      ppc_elf_howto_table[type] = &ppc_elf_howto_raw[i];
    }
}

/* This function handles relaxing for the PPC with option --mpc860c0[=<n>].

   The MPC860, revision C0 or earlier contains a bug in the die.
   If all of the following conditions are true, the next instruction
   to be executed *may* be treated as a no-op.
   1/ A forward branch is executed.
   2/ The branch is predicted as not taken.
   3/ The branch is taken.
   4/ The branch is located in the last 5 words of a page.
      (The EOP limit is 5 by default but may be specified as any value from 1-10.)

   Our software solution is to detect these problematic branches in a
   linker pass and modify them as follows:
   1/ Unconditional branches - Since these are always predicted taken,
      there is no problem and no action is required.
   2/ Conditional backward branches - No problem, no action required.
   3/ Conditional forward branches - Ensure that the "inverse prediction
      bit" is set (ensure it is predicted taken).
   4/ Conditional register branches - Ensure that the "y bit" is set
      (ensure it is predicted taken).  */
d1170 1
a1170 1
    isec->_cooked_size = isec->_raw_size;
d1182 1
a1182 1
	contents = elf_section_data (isec)->this_hdr.contents;
d1200 1
a1200 1
	  unsigned n;
d1203 8
a1210 9
	  /* Get a copy of the native relocations.  */
	  internal_relocs
	    = _bfd_elf32_link_read_relocs (abfd, isec, (PTR) NULL,
					   (Elf_Internal_Rela *) NULL,
					   link_info->keep_memory);
	  if (internal_relocs == NULL)
	    goto error_return;
	  if (! link_info->keep_memory)
	    free_relocs = internal_relocs;
d1212 1
a1212 1
	  /* Setup a faster access method for the reloc info we need.  */
d1215 34
a1248 36
	  rela_comb = (Elf_Internal_Rela**) bfd_malloc (amt);
	  if (rela_comb == NULL)
	    goto error_return;
	  for (n = 0; n < isec->reloc_count; ++n)
	    {
	      long r_type;

	      r_type = ELF32_R_TYPE (internal_relocs[n].r_info);
	      if (r_type < 0 || r_type >= (int) R_PPC_max)
		goto error_return;

	      /* Prologue constants are sometimes present in the ".text"
		 sections and they can be identified by their associated
		 relocation.  We don't want to process those words and
		 some others which can also be identified by their
		 relocations.  However, not all conditional branches will
		 have a relocation so we will only ignore words that
		 1) have a reloc, and 2) the reloc is not applicable to a
		 conditional branch.  The array rela_comb is built here
		 for use in the EOP scan loop.  */
	      switch (r_type)
		{
		case R_PPC_ADDR14_BRNTAKEN:
		case R_PPC_REL14:
		case R_PPC_REL14_BRNTAKEN:
		  /* We should check the instruction.  */
		  break;
		default:
		  /* The word is not a conditional branch - ignore it.  */
		  rela_comb[comb_count++] = &internal_relocs[n];
		  break;
		}
	    }
	  if (comb_count > 1)
	    qsort (rela_comb, (size_t) comb_count, sizeof (int),
		   ppc_elf_sort_rela);
d1256 2
a1257 4
      /* Increment the start position if this section begins in the
	 middle of its first EOP region.  */
      if (dot < isec->vma)
	dot = isec->vma;
d1259 27
a1285 18
	   dot < end_section;
	   dot += PAGESIZE, end_page += PAGESIZE)
	{
	  /* Check each word in this EOP region.  */
	  for (; dot < end_page; dot += 4)
	    {
	      bfd_vma isec_offset;
	      unsigned long insn;
	      bfd_boolean skip, modified;

	      /* Don't process this word if there is a relocation for it
		 and the relocation indicates the word is not a
		 conditional branch.  */
	      skip = FALSE;
	      isec_offset = dot - isec->vma;
	      for (; comb_curr<comb_count; ++comb_curr)
		{
		  bfd_vma r_offset;
d1287 1
a1287 11
		  r_offset = rela_comb[comb_curr]->r_offset;
		  if (r_offset >= isec_offset)
		    {
		      if (r_offset == isec_offset) skip = TRUE;
		      break;
		    }
		}
	      if (skip) continue;

	      /* Check the current word for a problematic conditional
		 branch.  */
d1291 26
a1316 28
	      insn = (unsigned long) bfd_get_32 (abfd, contents + isec_offset);
	      modified = FALSE;
	      if ((insn & 0xFc000000) == 0x40000000)
		{
		  /* Instruction is BCx */
		  if ((!BO0(insn) || !BO2(insn)) && !BO4(insn))
		    {
		      bfd_vma target;

		      /* This branch is predicted as "normal".
			 If this is a forward branch, it is problematic.  */
		      target = insn & 0x0000Fffc;
		      target = (target ^ 0x8000) - 0x8000;
		      if ((insn & 0x00000002) == 0)
			/* Convert to abs.  */
			target += dot;
		      if (target > dot)
			{
			  /* Set the prediction bit.  */
			  insn |= 0x00200000;
			  modified = TRUE;
			}
		    }
		}
	      else if ((insn & 0xFc00Fffe) == 0x4c000420)
		{
		  /* Instruction is BCCTRx.  */
		  if ((!BO0(insn) || !BO2(insn)) && !BO4(insn))
d1319 5
a1323 5
			 If this is a forward branch, it is problematic.
			 Since we can't tell statically if it will branch
			 forward, always set the prediction bit.  */
		      insn |= 0x00200000;
		      modified = TRUE;
d1325 5
a1329 5
		}
	      else if ((insn & 0xFc00Fffe) == 0x4c000020)
		{
		  /* Instruction is BCLRx */
		  if ((!BO0(insn) || !BO2(insn)) && !BO4(insn))
d1332 5
a1336 5
			 If this is a forward branch, it is problematic.
			 Since we can't tell statically if it will branch
			 forward, always set the prediction bit.  */
		      insn |= 0x00200000;
		      modified = TRUE;
d1338 1
a1338 1
		}
d1342 3
a1344 3
	      if (modified)
		{
		  bfd_put_32 (abfd, (bfd_vma) insn, contents + isec_offset);
d1346 3
a1348 3
		}
	    }
	}
d1382 1
a1382 1
 error_return:
d1397 1
a1397 1
  enum elf_ppc_reloc_type r;
d1408 53
a1460 81
    case BFD_RELOC_NONE:		r = R_PPC_NONE;			break;
    case BFD_RELOC_32:			r = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC_BA26:		r = R_PPC_ADDR24;		break;
    case BFD_RELOC_16:			r = R_PPC_ADDR16;		break;
    case BFD_RELOC_LO16:		r = R_PPC_ADDR16_LO;		break;
    case BFD_RELOC_HI16:		r = R_PPC_ADDR16_HI;		break;
    case BFD_RELOC_HI16_S:		r = R_PPC_ADDR16_HA;		break;
    case BFD_RELOC_PPC_BA16:		r = R_PPC_ADDR14;		break;
    case BFD_RELOC_PPC_BA16_BRTAKEN:	r = R_PPC_ADDR14_BRTAKEN;	break;
    case BFD_RELOC_PPC_BA16_BRNTAKEN:	r = R_PPC_ADDR14_BRNTAKEN;	break;
    case BFD_RELOC_PPC_B26:		r = R_PPC_REL24;		break;
    case BFD_RELOC_PPC_B16:		r = R_PPC_REL14;		break;
    case BFD_RELOC_PPC_B16_BRTAKEN:	r = R_PPC_REL14_BRTAKEN;	break;
    case BFD_RELOC_PPC_B16_BRNTAKEN:	r = R_PPC_REL14_BRNTAKEN;	break;
    case BFD_RELOC_16_GOTOFF:		r = R_PPC_GOT16;		break;
    case BFD_RELOC_LO16_GOTOFF:		r = R_PPC_GOT16_LO;		break;
    case BFD_RELOC_HI16_GOTOFF:		r = R_PPC_GOT16_HI;		break;
    case BFD_RELOC_HI16_S_GOTOFF:	r = R_PPC_GOT16_HA;		break;
    case BFD_RELOC_24_PLT_PCREL:	r = R_PPC_PLTREL24;		break;
    case BFD_RELOC_PPC_COPY:		r = R_PPC_COPY;			break;
    case BFD_RELOC_PPC_GLOB_DAT:	r = R_PPC_GLOB_DAT;		break;
    case BFD_RELOC_PPC_LOCAL24PC:	r = R_PPC_LOCAL24PC;		break;
    case BFD_RELOC_32_PCREL:		r = R_PPC_REL32;		break;
    case BFD_RELOC_32_PLTOFF:		r = R_PPC_PLT32;		break;
    case BFD_RELOC_32_PLT_PCREL:	r = R_PPC_PLTREL32;		break;
    case BFD_RELOC_LO16_PLTOFF:		r = R_PPC_PLT16_LO;		break;
    case BFD_RELOC_HI16_PLTOFF:		r = R_PPC_PLT16_HI;		break;
    case BFD_RELOC_HI16_S_PLTOFF:	r = R_PPC_PLT16_HA;		break;
    case BFD_RELOC_GPREL16:		r = R_PPC_SDAREL16;		break;
    case BFD_RELOC_16_BASEREL:		r = R_PPC_SECTOFF;		break;
    case BFD_RELOC_LO16_BASEREL:	r = R_PPC_SECTOFF_LO;		break;
    case BFD_RELOC_HI16_BASEREL:	r = R_PPC_SECTOFF_HI;		break;
    case BFD_RELOC_HI16_S_BASEREL:	r = R_PPC_SECTOFF_HA;		break;
    case BFD_RELOC_CTOR:		r = R_PPC_ADDR32;		break;
    case BFD_RELOC_PPC_TOC16:		r = R_PPC_TOC16;		break;
    case BFD_RELOC_PPC_TLS:		r = R_PPC_TLS;			break;
    case BFD_RELOC_PPC_DTPMOD:		r = R_PPC_DTPMOD32;		break;
    case BFD_RELOC_PPC_TPREL16:		r = R_PPC_TPREL16;		break;
    case BFD_RELOC_PPC_TPREL16_LO:	r = R_PPC_TPREL16_LO;		break;
    case BFD_RELOC_PPC_TPREL16_HI:	r = R_PPC_TPREL16_HI;		break;
    case BFD_RELOC_PPC_TPREL16_HA:	r = R_PPC_TPREL16_HA;		break;
    case BFD_RELOC_PPC_TPREL:		r = R_PPC_TPREL32;		break;
    case BFD_RELOC_PPC_DTPREL16:	r = R_PPC_DTPREL16;		break;
    case BFD_RELOC_PPC_DTPREL16_LO:	r = R_PPC_DTPREL16_LO;		break;
    case BFD_RELOC_PPC_DTPREL16_HI:	r = R_PPC_DTPREL16_HI;		break;
    case BFD_RELOC_PPC_DTPREL16_HA:	r = R_PPC_DTPREL16_HA;		break;
    case BFD_RELOC_PPC_DTPREL:		r = R_PPC_DTPREL32;		break;
    case BFD_RELOC_PPC_GOT_TLSGD16:	r = R_PPC_GOT_TLSGD16;		break;
    case BFD_RELOC_PPC_GOT_TLSGD16_LO:	r = R_PPC_GOT_TLSGD16_LO;	break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HI:	r = R_PPC_GOT_TLSGD16_HI;	break;
    case BFD_RELOC_PPC_GOT_TLSGD16_HA:	r = R_PPC_GOT_TLSGD16_HA;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16:	r = R_PPC_GOT_TLSLD16;		break;
    case BFD_RELOC_PPC_GOT_TLSLD16_LO:	r = R_PPC_GOT_TLSLD16_LO;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HI:	r = R_PPC_GOT_TLSLD16_HI;	break;
    case BFD_RELOC_PPC_GOT_TLSLD16_HA:	r = R_PPC_GOT_TLSLD16_HA;	break;
    case BFD_RELOC_PPC_GOT_TPREL16:	r = R_PPC_GOT_TPREL16;		break;
    case BFD_RELOC_PPC_GOT_TPREL16_LO:	r = R_PPC_GOT_TPREL16_LO;	break;
    case BFD_RELOC_PPC_GOT_TPREL16_HI:	r = R_PPC_GOT_TPREL16_HI;	break;
    case BFD_RELOC_PPC_GOT_TPREL16_HA:	r = R_PPC_GOT_TPREL16_HA;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16:	r = R_PPC_GOT_DTPREL16;		break;
    case BFD_RELOC_PPC_GOT_DTPREL16_LO:	r = R_PPC_GOT_DTPREL16_LO;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HI:	r = R_PPC_GOT_DTPREL16_HI;	break;
    case BFD_RELOC_PPC_GOT_DTPREL16_HA:	r = R_PPC_GOT_DTPREL16_HA;	break;
    case BFD_RELOC_PPC_EMB_NADDR32:	r = R_PPC_EMB_NADDR32;		break;
    case BFD_RELOC_PPC_EMB_NADDR16:	r = R_PPC_EMB_NADDR16;		break;
    case BFD_RELOC_PPC_EMB_NADDR16_LO:	r = R_PPC_EMB_NADDR16_LO;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HI:	r = R_PPC_EMB_NADDR16_HI;	break;
    case BFD_RELOC_PPC_EMB_NADDR16_HA:	r = R_PPC_EMB_NADDR16_HA;	break;
    case BFD_RELOC_PPC_EMB_SDAI16:	r = R_PPC_EMB_SDAI16;		break;
    case BFD_RELOC_PPC_EMB_SDA2I16:	r = R_PPC_EMB_SDA2I16;		break;
    case BFD_RELOC_PPC_EMB_SDA2REL:	r = R_PPC_EMB_SDA2REL;		break;
    case BFD_RELOC_PPC_EMB_SDA21:	r = R_PPC_EMB_SDA21;		break;
    case BFD_RELOC_PPC_EMB_MRKREF:	r = R_PPC_EMB_MRKREF;		break;
    case BFD_RELOC_PPC_EMB_RELSEC16:	r = R_PPC_EMB_RELSEC16;		break;
    case BFD_RELOC_PPC_EMB_RELST_LO:	r = R_PPC_EMB_RELST_LO;		break;
    case BFD_RELOC_PPC_EMB_RELST_HI:	r = R_PPC_EMB_RELST_HI;		break;
    case BFD_RELOC_PPC_EMB_RELST_HA:	r = R_PPC_EMB_RELST_HA;		break;
    case BFD_RELOC_PPC_EMB_BIT_FLD:	r = R_PPC_EMB_BIT_FLD;		break;
    case BFD_RELOC_PPC_EMB_RELSDA:	r = R_PPC_EMB_RELSDA;		break;
    case BFD_RELOC_VTABLE_INHERIT:	r = R_PPC_GNU_VTINHERIT;	break;
    case BFD_RELOC_VTABLE_ENTRY:	r = R_PPC_GNU_VTENTRY;		break;
d1463 1
a1463 1
  return ppc_elf_howto_table[(int) r];
a1519 28
static bfd_reloc_status_type
ppc_elf_unhandled_reloc (abfd, reloc_entry, symbol, data,
			 input_section, output_bfd, error_message)
     bfd *abfd;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data;
     asection *input_section;
     bfd *output_bfd;
     char **error_message;
{
  /* If this is a relocatable link (output_bfd test tells us), just
     call the generic function.  Any adjustment will be done at final
     link time.  */
  if (output_bfd != NULL)
    return bfd_elf_generic_reloc (abfd, reloc_entry, symbol, data,
				  input_section, output_bfd, error_message);

  if (error_message != NULL)
    {
      static char buf[60];
      sprintf (buf, "generic linker can't handle %s",
	       reloc_entry->howto->name);
      *error_message = buf;
    }
  return bfd_reloc_dangerous;
}

d1557 1
a1557 2
   object file when linking.  */

d1567 1
a1567 1
  /* Check if we have the same endianess.  */
d1577 1
a1577 1
  if (!elf_flags_init (obfd))
a1578 1
      /* First call, no flags set.  */
d1583 1
a1583 2
  /* Compatible flags are ok.  */
  else if (new_flags == old_flags)
d1586 1
a1586 2
  /* Incompatible flags.  */
  else
d1588 2
a1589 2
      /* Warn about -mrelocatable mismatch.  Allow -mrelocatable-lib
	 to be linked with either.  */
d1613 1
a1613 1
	 but each input file is either -mrelocatable or -mrelocatable-lib.  */
d1619 1
a1619 2
      /* Do not warn about eabi vs. V.4 mismatch, just or in the bit if
	 any module uses it.  */
d1622 2
a1623 2
      new_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
      old_flags &= ~(EF_PPC_RELOCATABLE | EF_PPC_RELOCATABLE_LIB | EF_PPC_EMB);
d1625 1
a1625 1
      /* Warn about any other mismatches.  */
d1698 1
a1698 1
  /* Record the first bfd section that needs the special section.  */
d1702 1
a1702 1
  /* If this is the first time, create the section.  */
d1797 1
a1797 1
static bfd_boolean
d1802 1
a1802 2
  struct ppc_elf_link_hash_table *htab;
  asection *s;
d1806 1
a1806 1
    return FALSE;
d1808 1
a1808 2
  htab = ppc_elf_hash_table (info);
  htab->got = s = bfd_get_section_by_name (abfd, ".got");
d1815 2
a1816 12
    return FALSE;

  htab->relgot = bfd_make_section (abfd, ".rela.got");
  if (!htab->relgot
      || ! bfd_set_section_flags (abfd, htab->relgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (abfd, htab->relgot, 2))
    return FALSE;

  return TRUE;
d1828 1
a1828 2
  struct ppc_elf_link_hash_table *htab;
  asection *s;
d1840 1
a1840 3
  htab = ppc_elf_hash_table (info);
  htab->dynbss = bfd_get_section_by_name (abfd, ".dynbss");
  htab->dynsbss = s = bfd_make_section (abfd, ".dynsbss");
d1847 1
a1847 2
      htab->relbss = bfd_get_section_by_name (abfd, ".rela.bss");
      htab->relsbss = s = bfd_make_section (abfd, ".rela.sbss");
d1854 1
a1854 2
  htab->relplt = bfd_get_section_by_name (abfd, ".rela.plt");
  htab->plt = s = bfd_get_section_by_name (abfd, ".plt");
a1861 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d1873 1
a1873 1
  struct ppc_elf_link_hash_table *htab;
d1876 1
d1879 1
a1879 2
  fprintf (stderr, "ppc_elf_adjust_dynamic_symbol called for %s\n",
	   h->root.root.string);
d1883 1
a1883 2
  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL
d1893 3
a1895 1
  /* Deal with function syms.  */
d1899 1
a1899 3
      /* Clear procedure linkage table information for any symbol that
	 won't need a .plt entry.  */
      if (! htab->elf.dynamic_sections_created
d1901 1
a1901 1
	  || h->plt.refcount <= 0)
d1905 2
a1906 2
	  1. We are not using ld.so; because then the PLT entry
	  can't be set up, so we can't use one.
d1908 2
a1909 2
	  2. We know for certain that a call to this symbol
	  will go to this object.
d1911 5
a1915 1
	  3. GC has rendered the entry unused.  */
d1918 1
d1920 52
a1998 24
  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
    return TRUE;

  if (ELIMINATE_COPY_RELOCS)
    {
      struct ppc_elf_dyn_relocs *p;
      for (p = ppc_elf_hash_entry (h)->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
    }

d2013 2
a2014 2
  if (h->size <= elf_gp_size (htab->elf.dynobj))
    s = htab->dynsbss;
d2016 1
a2016 1
    s = htab->dynbss;
d2027 2
a2028 2
      if (h->size <= elf_gp_size (htab->elf.dynobj))
	srel = htab->relsbss;
d2030 1
a2030 1
	srel = htab->relbss;
d2045 1
a2045 1
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
d2047 1
a2047 1
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
a2060 22
/* This is the condition under which finish_dynamic_symbol will be
   called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* Of those relocs that might be copied as dynamic relocs, this macro
   selects those that must be copied when linking a shared library,
   even when the symbol is local.  */

#define MUST_BE_DYN_RELOC(RTYPE)		\
  ((RTYPE) != R_PPC_REL24			\
   && (RTYPE) != R_PPC_REL14			\
   && (RTYPE) != R_PPC_REL14_BRTAKEN		\
   && (RTYPE) != R_PPC_REL14_BRNTAKEN		\
   && (RTYPE) != R_PPC_REL32)

d2064 1
a2064 1
allocate_dynrelocs (h, inf)
d2066 1
a2066 1
     PTR inf;
a2067 3
  struct bfd_link_info *info = (struct bfd_link_info *) inf;
  struct ppc_elf_link_hash_entry *eh;
  struct ppc_elf_link_hash_table *htab;
d2070 2
a2071 173
  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  htab = ppc_elf_hash_table (info);
  if (htab->elf.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->plt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_INITIAL_ENTRY_SIZE;

	  /* The PowerPC PLT is actually composed of two parts, the
	     first part is 2 words (for a load and a jump), and then
	     there is a remaining word available at the end.  */
	  h->plt.offset = (PLT_INITIAL_ENTRY_SIZE
			   + (PLT_SLOT_SIZE
			      * ((s->_raw_size - PLT_INITIAL_ENTRY_SIZE)
				 / PLT_ENTRY_SIZE)));

	  /* If this symbol is not defined in a regular file, and we
	     are not generating a shared library, then set the symbol
	     to this location in the .plt.  This is required to make
	     function pointers compare as equal between the normal
	     executable and the shared library.  */
	  if (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  After the 8192nd entry, room
	     for two entries is allocated.  */
	  s->_raw_size += PLT_ENTRY_SIZE;
	  if ((s->_raw_size - PLT_INITIAL_ENTRY_SIZE) / PLT_ENTRY_SIZE
	      >= PLT_NUM_SINGLE_ENTRIES)
	    s->_raw_size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->relplt->_raw_size += sizeof (Elf32_External_Rela);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  eh = (struct ppc_elf_link_hash_entry *) h;
  if (eh->elf.got.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (eh->elf.dynindx == -1
	  && (eh->elf.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (!bfd_elf32_link_record_dynamic_symbol (info, &eh->elf))
	    return FALSE;
	}

      if (eh->tls_mask == (TLS_TLS | TLS_LD)
	  && !(eh->elf.elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
	/* If just an LD reloc, we'll just use htab->tlsld_got.offset.  */
	eh->elf.got.offset = (bfd_vma) -1;
      else
	{
	  bfd_boolean dyn;
	  eh->elf.got.offset = htab->got->_raw_size;
	  if ((eh->tls_mask & TLS_TLS) != 0)
	    {
	      if ((eh->tls_mask & TLS_LD) != 0)
		htab->got->_raw_size += 8;
	      if ((eh->tls_mask & TLS_GD) != 0)
		htab->got->_raw_size += 8;
	      if ((eh->tls_mask & (TLS_TPREL | TLS_TPRELGD)) != 0)
		htab->got->_raw_size += 4;
	      if ((eh->tls_mask & TLS_DTPREL) != 0)
		htab->got->_raw_size += 4;
	    }
	  else
	    htab->got->_raw_size += 4;
	  dyn = htab->elf.dynamic_sections_created;
	  if (info->shared
	      || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, &eh->elf))
	    {
	      /* All the entries we allocated need relocs.  */
	      htab->relgot->_raw_size
		+= ((htab->got->_raw_size - eh->elf.got.offset) / 4
		    * sizeof (Elf32_External_Rela));
	      /* Except LD only needs one.  */
	      if ((eh->tls_mask & TLS_LD) != 0)
		htab->relgot->_raw_size -= sizeof (Elf32_External_Rela);
	    }
	}
    }
  else
    eh->elf.got.offset = (bfd_vma) -1;

  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for relocs that have become local due to symbol visibility
     changes.  */
  if (info->shared)
    {
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
	{
	  struct ppc_elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}
    }
  else if (ELIMINATE_COPY_RELOCS)
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}
d2073 5
a2077 1
      eh->dyn_relocs = NULL;
d2079 1
a2079 5
    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d2127 1
a2127 1
  struct ppc_elf_link_hash_table *htab;
d2129 1
d2137 2
a2138 2
  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL);
d2145 1
a2145 1
	  s = bfd_get_section_by_name (htab->elf.dynobj, ".interp");
d2151 11
d2163 6
a2168 6
  if (htab->tlsld_got.refcount > 0)
    {
      htab->tlsld_got.offset = htab->got->_raw_size;
      htab->got->_raw_size += 8;
      if (info->shared)
	htab->relgot->_raw_size += sizeof (Elf32_External_Rela);
a2169 2
  else
    htab->tlsld_got.offset = (bfd_vma) -1;
d2171 1
a2171 2
  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
a2173 7
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *lgot_masks;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

d2182 3
a2184 3
		    elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
a2204 48

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      lgot_masks = (char *) end_local_got;
      s = htab->got;
      srel = htab->relgot;
      for (; local_got < end_local_got; ++local_got, ++lgot_masks)
	if (*local_got > 0)
	  {
	    if (*lgot_masks == (TLS_TLS | TLS_LD))
	      {
		/* If just an LD reloc, we'll just use
		   htab->tlsld_got.offset.  */
		if (htab->tlsld_got.offset == (bfd_vma) -1)
		  {
		    htab->tlsld_got.offset = s->_raw_size;
		    s->_raw_size += 8;
		    if (info->shared)
		      srel->_raw_size += sizeof (Elf32_External_Rela);
		  }
		*local_got = (bfd_vma) -1;
	      }
	    else
	      {
		*local_got = s->_raw_size;
		if ((*lgot_masks & TLS_TLS) != 0)
		  {
		    if ((*lgot_masks & TLS_GD) != 0)
		      s->_raw_size += 8;
		    if ((*lgot_masks & (TLS_TPREL | TLS_TPRELGD)) != 0)
		      s->_raw_size += 4;
		    if ((*lgot_masks & TLS_DTPREL) != 0)
		      s->_raw_size += 4;
		  }
		else
		  s->_raw_size += 4;
		if (info->shared)
		  srel->_raw_size += ((s->_raw_size - *local_got) / 4
				      * sizeof (Elf32_External_Rela));
	      }
	  }
	else
	  *local_got = (bfd_vma) -1;
d2208 1
a2208 1
  elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, info);
d2210 4
a2213 2
  /* We've now determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
d2215 1
a2215 1
  for (s = htab->elf.dynobj->sections; s != NULL; s = s->next)
d2217 3
d2223 7
a2229 4
      if (s == htab->plt
	  || s == htab->got
	  || (htab->sdata != NULL && s == htab->sdata->section)
	  || (htab->sdata2 != NULL && s == htab->sdata2->section))
d2231 11
a2241 2
	  /* Strip this section if we don't need it; see the
	     comment below.  */
d2243 1
a2243 1
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
d2256 1
d2268 3
a2270 1
      else
d2276 1
a2276 1
      if (s->_raw_size == 0)
d2283 2
a2284 2
      s->contents = (bfd_byte *) bfd_zalloc (htab->elf.dynobj, s->_raw_size);
      if (s->contents == NULL)
d2288 1
a2288 1
  if (htab->elf.dynamic_sections_created)
d2304 1
a2304 1
      if (htab->plt != NULL && htab->plt->_raw_size != 0)
a2337 39
static bfd_boolean
update_local_sym_info (abfd, symtab_hdr, r_symndx, tls_type)
     bfd *abfd;
     Elf_Internal_Shdr *symtab_hdr;
     unsigned long r_symndx;
     int tls_type;
{
  bfd_signed_vma *local_got_refcounts = elf_local_got_refcounts (abfd);
  char *local_got_tls_masks;

  if (local_got_refcounts == NULL)
    {
      bfd_size_type size = symtab_hdr->sh_info;

      size *= sizeof (*local_got_refcounts) + sizeof (*local_got_tls_masks);
      local_got_refcounts = (bfd_signed_vma *) bfd_zalloc (abfd, size);
      if (local_got_refcounts == NULL)
	return FALSE;
      elf_local_got_refcounts (abfd) = local_got_refcounts;
    }

  local_got_refcounts[r_symndx] += 1;
  local_got_tls_masks = (char *) (local_got_refcounts + symtab_hdr->sh_info);
  local_got_tls_masks[r_symndx] |= tls_type;
  return TRUE;
}

static void
bad_shared_reloc (abfd, r_type)
     bfd *abfd;
     enum elf_ppc_reloc_type r_type;
{
  (*_bfd_error_handler)
    (_("%s: relocation %s cannot be used when making a shared object"),
     bfd_archive_filename (abfd),
     ppc_elf_howto_table[(int) r_type]->name);
  bfd_set_error (bfd_error_bad_value);
}

d2349 1
a2349 1
  struct ppc_elf_link_hash_table *htab;
d2351 1
a2351 1
  struct elf_link_hash_entry **sym_hashes;
d2354 3
d2358 2
d2373 1
a2373 2
  htab = ppc_elf_hash_table (info);
  if (htab->sdata == NULL)
d2375 2
a2376 5
      htab->sdata = elf_linker_section (abfd, LINKER_SECTION_SDATA);
      if (htab->sdata == NULL)
	htab->sdata = ppc_elf_create_linker_section (abfd, info,
						     LINKER_SECTION_SDATA);
      if (htab->sdata == NULL)
d2380 1
a2380 1
  if (htab->sdata2 == NULL)
d2382 2
a2383 5
      htab->sdata2 = elf_linker_section (abfd, LINKER_SECTION_SDATA2);
      if (htab->sdata2 == NULL)
	htab->sdata2 = ppc_elf_create_linker_section (abfd, info,
						      LINKER_SECTION_SDATA2);
      if (htab->sdata2 == NULL)
d2387 1
d2389 2
d2392 4
a2401 1
      enum elf_ppc_reloc_type r_type;
a2402 1
      int tls_type = 0;
d2415 1
a2415 1
	  if (htab->got == NULL)
d2417 4
a2420 3
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!ppc_elf_create_got (htab->elf.dynobj, info))
d2425 1
a2425 2
      r_type = (enum elf_ppc_reloc_type) ELF32_R_TYPE (rel->r_info);
      switch (r_type)
d2427 1
a2427 34
	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  htab->tlsld_got.refcount += 1;
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogottls;

	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogottls;

	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogottls;

	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	dogottls:
	  sec->has_tls_reloc = 1;
	  /* Fall thru */

	  /* GOT16 relocations */
d2433 2
a2434 1
	  if (htab->got == NULL)
d2436 4
a2439 3
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!ppc_elf_create_got (htab->elf.dynobj, info))
d2442 21
d2465 13
a2477 2
	      h->got.refcount += 1;
	      ppc_elf_hash_entry (h)->tls_mask |= tls_type;
d2480 26
a2505 3
	    /* This is a global offset table entry for a local symbol.  */
	    if (!update_local_sym_info (abfd, symtab_hdr, r_symndx, tls_type))
	      return FALSE;
d2508 1
a2508 1
	  /* Indirect .sdata relocation.  */
d2512 3
a2514 1
	      bad_shared_reloc (abfd, r_type);
d2517 21
a2537 2
	  if (!bfd_elf32_create_pointer_linker_section (abfd, info,
							htab->sdata, h, rel))
d2539 1
d2542 1
a2542 1
	  /* Indirect .sdata2 relocation.  */
d2546 3
a2548 1
	      bad_shared_reloc (abfd, r_type);
d2551 21
a2571 2
	  if (!bfd_elf32_create_pointer_linker_section (abfd, info,
							htab->sdata2, h, rel))
d2573 1
a2578 6
	case R_PPC_EMB_RELSDA:
	case R_PPC_EMB_NADDR32:
	case R_PPC_EMB_NADDR16:
	case R_PPC_EMB_NADDR16_LO:
	case R_PPC_EMB_NADDR16_HI:
	case R_PPC_EMB_NADDR16_HA:
d2581 4
a2584 1
	      bad_shared_reloc (abfd, r_type);
a2590 1
	case R_PPC_PLTREL32:
d2598 4
a2601 4
	     actually build the entry in finish_dynamic_symbol,
	     because this might be a case of linking PIC code without
	     linking in any dynamic objects, in which case we don't
	     need to generate a procedure linkage table after all.  */
d2606 1
a2606 1
		 table entry for a local symbol.  */
d2611 6
a2627 5
	case R_PPC_DTPREL16:
	case R_PPC_DTPREL16_LO:
	case R_PPC_DTPREL16_HI:
	case R_PPC_DTPREL16_HA:
	case R_PPC_TOC16:
d2630 1
a2630 24
	  /* This are just markers.  */
	case R_PPC_TLS:
	case R_PPC_EMB_MRKREF:
	case R_PPC_NONE:
	case R_PPC_max:
	  break;

	  /* These should only appear in dynamic objects.  */
	case R_PPC_COPY:
	case R_PPC_GLOB_DAT:
	case R_PPC_JMP_SLOT:
	case R_PPC_RELATIVE:
	  break;

	  /* These aren't handled yet.  We'll report an error later.  */
	case R_PPC_ADDR30:
	case R_PPC_EMB_RELSEC16:
	case R_PPC_EMB_RELST_LO:
	case R_PPC_EMB_RELST_HI:
	case R_PPC_EMB_RELST_HA:
	case R_PPC_EMB_BIT_FLD:
	  break;

	  /* This refers only to functions defined in the shared library.  */
a2647 19
	  /* We shouldn't really be seeing these.  */
	case R_PPC_TPREL32:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  goto dodyn;

	  /* Nor these.  */
	case R_PPC_DTPMOD32:
	case R_PPC_DTPREL32:
	  goto dodyn;

	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_TPREL16_HI:
	case R_PPC_TPREL16_HA:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  goto dodyn;

d2662 2
a2663 57
	case R_PPC_ADDR32:
	case R_PPC_ADDR24:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	  if (h != NULL && !info->shared)
	    {
	      /* We may need a plt entry if the symbol turns out to be
		 a function defined in a dynamic object.  */
	      h->plt.refcount++;

	      /* We may need a copy reloc too.  */
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
	    }

	dodyn:
	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library.  We account for that possibility below by
	     storing information in the dyn_relocs field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (MUST_BE_DYN_RELOC (r_type)
		   || (h != NULL
		       && (! info->symbolic
			   || h->root.type == bfd_link_hash_defweak
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d2670 1
a2670 2
		       (h && h->root.root.string
			? h->root.root.string : "<unknown>"));
d2687 1
a2687 1
		  sreloc = bfd_get_section_by_name (htab->elf.dynobj, name);
d2692 1
a2692 1
		      sreloc = bfd_make_section (htab->elf.dynobj, name);
d2698 2
a2699 4
			  || ! bfd_set_section_flags (htab->elf.dynobj,
						      sreloc, flags)
			  || ! bfd_set_section_alignment (htab->elf.dynobj,
							  sreloc, 2))
d2718 3
a2720 2
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
d2732 1
a2732 1
		       bfd_alloc (htab->elf.dynobj, sizeof *p));
a2738 1
		  p->pc_count = 0;
d2741 1
a2741 3
	      p->count += 1;
	      if (!MUST_BE_DYN_RELOC (r_type))
		p->pc_count += 1;
d2791 1
a2791 2
/* Update the got, plt and dynamic reloc reference counts for the
   section being removed.  */
d2796 1
a2796 1
     struct bfd_link_info *info;
a2799 1
  struct ppc_elf_link_hash_table *htab;
d2804 2
a2808 1
  htab = ppc_elf_hash_table (info);
d2815 19
a2833 4
    {
      unsigned long r_symndx;
      enum elf_ppc_reloc_type r_type;
      struct elf_link_hash_entry *h = NULL;
d2835 13
a2847 110
      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct ppc_elf_dyn_relocs **pp, *p;
	  struct ppc_elf_link_hash_entry *eh;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct ppc_elf_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = (enum elf_ppc_reloc_type) ELF32_R_TYPE (rel->r_info);
      switch (r_type)
	{
	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  htab->tlsld_got.refcount -= 1;
	  /* Fall thru */

	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_GOT16_HI:
	case R_PPC_GOT16_HA:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount--;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx]--;
	    }
	  break;

	case R_PPC_REL24:
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	case R_PPC_REL32:
	  if (h == NULL
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
	      || SYMBOL_REFERENCES_LOCAL (info, h))
	    break;
	  /* Fall thru */

	case R_PPC_ADDR32:
	case R_PPC_ADDR24:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	case R_PPC_PLT32:
	case R_PPC_PLTREL24:
	case R_PPC_PLT16_LO:
	case R_PPC_PLT16_HI:
	case R_PPC_PLT16_HA:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount--;
	    }
	  break;

	default:
	  break;
	}
    }
  return TRUE;
}

/* Set htab->tls_sec and htab->tls_get_addr.  */

bfd_boolean
ppc_elf_tls_setup (obfd, info)
     bfd *obfd;
     struct bfd_link_info *info;
{
  asection *tls;
  struct ppc_elf_link_hash_table *htab;

  htab = ppc_elf_hash_table (info);
  htab->tls_get_addr = elf_link_hash_lookup (&htab->elf, "__tls_get_addr",
					     FALSE, FALSE, TRUE);
d2849 3
a2851 32
  for (tls = obfd->sections; tls != NULL; tls = tls->next)
    if ((tls->flags & (SEC_THREAD_LOCAL | SEC_LOAD))
	== (SEC_THREAD_LOCAL | SEC_LOAD))
      break;
  htab->tls_sec = tls;

  return tls != NULL;
}

/* Run through all the TLS relocs looking for optimization
   opportunities.  */

bfd_boolean
ppc_elf_tls_optimize (obfd, info)
     bfd *obfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
{
  bfd *ibfd;
  asection *sec;
  struct ppc_elf_link_hash_table *htab;

  if (info->relocateable || info->shared)
    return TRUE;

  htab = ppc_elf_hash_table (info);
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      Elf_Internal_Sym *locsyms = NULL;
      Elf_Internal_Shdr *symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;

      for (sec = ibfd->sections; sec != NULL; sec = sec->next)
	if (sec->has_tls_reloc && !bfd_is_abs_section (sec->output_section))
d2853 1
a2853 9
	    Elf_Internal_Rela *relstart, *rel, *relend;
	    int expecting_tls_get_addr;

	    /* Read the relocations.  */
	    relstart = _bfd_elf32_link_read_relocs (ibfd, sec, (PTR) NULL,
						    (Elf_Internal_Rela *) NULL,
						    info->keep_memory);
	    if (relstart == NULL)
	      return FALSE;
d2855 1
a2855 10
	    expecting_tls_get_addr = 0;
	    relend = relstart + sec->reloc_count;
	    for (rel = relstart; rel < relend; rel++)
	      {
		enum elf_ppc_reloc_type r_type;
		unsigned long r_symndx;
		struct elf_link_hash_entry *h = NULL;
		char *tls_mask;
		char tls_set, tls_clear;
		bfd_boolean is_local;
d2857 9
a2865 136
		r_symndx = ELF32_R_SYM (rel->r_info);
		if (r_symndx >= symtab_hdr->sh_info)
		  {
		    struct elf_link_hash_entry **sym_hashes;

		    sym_hashes = elf_sym_hashes (ibfd);
		    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
		    while (h->root.type == bfd_link_hash_indirect
			   || h->root.type == bfd_link_hash_warning)
		      h = (struct elf_link_hash_entry *) h->root.u.i.link;
		  }

		is_local = FALSE;
		if (h == NULL
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC))
		  is_local = TRUE;

		r_type = (enum elf_ppc_reloc_type) ELF32_R_TYPE (rel->r_info);
		switch (r_type)
		  {
		  case R_PPC_GOT_TLSLD16:
		  case R_PPC_GOT_TLSLD16_LO:
		  case R_PPC_GOT_TLSLD16_HI:
		  case R_PPC_GOT_TLSLD16_HA:
		    /* These relocs should never be against a symbol
		       defined in a shared lib.  Leave them alone if
		       that turns out to be the case.  */
		    expecting_tls_get_addr = 0;
		    htab->tlsld_got.refcount -= 1;
		    if (!is_local)
		      continue;

		    /* LD -> LE */
		    tls_set = 0;
		    tls_clear = TLS_LD;
		    expecting_tls_get_addr = 1;
		    break;

		  case R_PPC_GOT_TLSGD16:
		  case R_PPC_GOT_TLSGD16_LO:
		  case R_PPC_GOT_TLSGD16_HI:
		  case R_PPC_GOT_TLSGD16_HA:
		    if (is_local)
		      /* GD -> LE */
		      tls_set = 0;
		    else
		      /* GD -> IE */
		      tls_set = TLS_TLS | TLS_TPRELGD;
		    tls_clear = TLS_GD;
		    expecting_tls_get_addr = 1;
		    break;

		  case R_PPC_GOT_TPREL16:
		  case R_PPC_GOT_TPREL16_LO:
		  case R_PPC_GOT_TPREL16_HI:
		  case R_PPC_GOT_TPREL16_HA:
		    expecting_tls_get_addr = 0;
		    if (is_local)
		      {
			/* IE -> LE */
			tls_set = 0;
			tls_clear = TLS_TPREL;
			break;
		      }
		    else
		      continue;

		  case R_PPC_REL14:
		  case R_PPC_REL14_BRTAKEN:
		  case R_PPC_REL14_BRNTAKEN:
		  case R_PPC_REL24:
		    if (expecting_tls_get_addr
			&& h != NULL
			&& h == htab->tls_get_addr)
		      {
			if (h->plt.refcount > 0)
			  h->plt.refcount -= 1;
		      }
		    expecting_tls_get_addr = 0;
		    continue;

		  default:
		    expecting_tls_get_addr = 0;
		    continue;
		  }

		if (h != NULL)
		  {
		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (h->got.refcount > 0)
			  h->got.refcount -= 1;
		      }
		    tls_mask = &ppc_elf_hash_entry (h)->tls_mask;
		  }
		else
		  {
		    Elf_Internal_Sym *sym;
		    bfd_signed_vma *lgot_refs;
		    char *lgot_masks;

		    if (locsyms == NULL)
		      {
			locsyms = (Elf_Internal_Sym *) symtab_hdr->contents;
			if (locsyms == NULL)
			  locsyms = bfd_elf_get_elf_syms (ibfd, symtab_hdr,
							  symtab_hdr->sh_info,
							  0, NULL, NULL, NULL);
			if (locsyms == NULL)
			  {
			    if (elf_section_data (sec)->relocs != relstart)
			      free (relstart);
			    return FALSE;
			  }
		      }
		    sym = locsyms + r_symndx;
		    lgot_refs = elf_local_got_refcounts (ibfd);
		    if (lgot_refs == NULL)
		      abort ();
		    if (tls_set == 0)
		      {
			/* We managed to get rid of a got entry.  */
			if (lgot_refs[r_symndx] > 0)
			  lgot_refs[r_symndx] -= 1;
		      }
		    lgot_masks = (char *) (lgot_refs + symtab_hdr->sh_info);
		    tls_mask = &lgot_masks[r_symndx];
		  }

		*tls_mask |= tls_set;
		*tls_mask &= ~tls_clear;
	      }

	    if (elf_section_data (sec)->relocs != relstart)
	      free (relstart);
d2867 2
a2869 9
      if (locsyms != NULL
	  && (symtab_hdr->contents != (unsigned char *) locsyms))
	{
	  if (!info->keep_memory)
	    free (locsyms);
	  else
	    symtab_hdr->contents = (unsigned char *) locsyms;
	}
    }
d2901 3
a2903 3
	     want to attach this common section to DYNOBJ.  The linker
	     will move the symbols to the appropriate output section
	     when it defines common symbols.  */
d2942 1
a2942 1
  struct ppc_elf_link_hash_table *htab;
d2949 2
a2950 2
  htab = ppc_elf_hash_table (info);
  BFD_ASSERT (htab->elf.dynobj != NULL);
d2954 2
d2965 1
a2965 1
	 it up.  */
d2968 4
a2971 1
      BFD_ASSERT (htab->plt != NULL && htab->relplt != NULL);
d2977 2
a2978 2
      rela.r_offset = (htab->plt->output_section->vma
		       + htab->plt->output_offset
d2986 1
a2986 2
      loc = (htab->relplt->contents
	     + reloc_index * sizeof (Elf32_External_Rela));
d3004 43
d3061 3
a3063 2
      if (h->size <= elf_gp_size (htab->elf.dynobj))
	s = htab->relsbss;
d3065 2
a3066 1
	s = htab->relbss;
d3099 2
a3100 1
  struct ppc_elf_link_hash_table *htab;
d3106 1
a3106 2
  htab = ppc_elf_hash_table (info);
  sdyn = bfd_get_section_by_name (htab->elf.dynobj, ".dynamic");
d3108 1
a3108 1
  if (htab->elf.dynamic_sections_created)
d3110 1
d3113 2
a3114 1
      BFD_ASSERT (htab->plt != NULL && sdyn != NULL);
d3121 2
a3122 1
	  asection *s;
d3124 1
a3124 1
	  bfd_elf32_swap_dyn_in (htab->elf.dynobj, dyncon, &dyn);
d3128 5
a3132 4
	    case DT_PLTGOT:
	      s = htab->plt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;
d3134 3
a3136 3
	    case DT_PLTRELSZ:
	      dyn.d_un.d_val = htab->relplt->_raw_size;
	      break;
d3138 16
a3153 7
	    case DT_JMPREL:
	      s = htab->relplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    default:
	      continue;
a3154 2

	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d3160 1
a3160 1
  if (htab->got)
d3162 1
a3162 1
      unsigned char *contents = htab->got->contents;
d3166 1
a3166 1
	bfd_put_32 (output_bfd, (bfd_vma) 0, contents + 4);
d3170 1
a3170 1
		    contents + 4);
d3172 1
a3172 1
      elf_section_data (htab->got->output_section)->this_hdr.sh_entsize = 4;
d3219 7
a3225 7
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  struct ppc_elf_link_hash_table *htab;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  Elf_Internal_Rela outrel;
  bfd_byte *loc;
d3227 2
d3231 7
a3253 1
  htab = ppc_elf_hash_table (info);
d3255 8
a3262 4
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (input_bfd);
  rel = relocs;
  relend = relocs + input_section->reloc_count;
d3265 8
a3272 7
      enum elf_ppc_reloc_type r_type;
      bfd_vma addend;
      bfd_reloc_status_type r;
      Elf_Internal_Sym *sym;
      asection *sec;
      struct elf_link_hash_entry *h;
      const char *sym_name;
d3276 16
a3291 11
      bfd_vma branch_bit, insn, from;
      bfd_boolean unresolved_reloc;
      bfd_boolean warned;
      unsigned int tls_type, tls_mask, tls_gd;

      r_type = (enum elf_ppc_reloc_type)ELF32_R_TYPE (rel->r_info);
      sym = (Elf_Internal_Sym *) 0;
      sec = (asection *) 0;
      h = (struct elf_link_hash_entry *) 0;
      unresolved_reloc = FALSE;
      warned = FALSE;
d3293 1
d3298 1
a3298 1
	  sym_name = bfd_elf_local_sym_name (input_bfd, sym);
d3301 3
d3313 3
a3315 1
	  relocation = 0;
d3320 71
a3390 6
	      /* Set a flag that will be cleared later if we find a
		 relocation value for this symbol.  output_section
		 is typically NULL for symbols satisfied by a shared
		 library.  */
	      if (sec->output_section == NULL)
		unresolved_reloc = TRUE;
d3397 1
a3397 1
	    ;
d3399 1
d3402 1
a3402 1
	    ;
d3405 8
a3412 5
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_offset, (!info->shared
				      || info->no_undefined
				      || ELF_ST_VISIBILITY (h->other)))))
d3414 1
a3414 214
	      warned = TRUE;
	    }
	}

      /* TLS optimizations.  Replace instruction sequences and relocs
	 based on information we collected in tls_optimize.  We edit
	 RELOCS so that --emit-relocs will output something sensible
	 for the final instruction stream.  */
      tls_mask = 0;
      tls_gd = 0;
      if (IS_PPC_TLS_RELOC (r_type))
	{
	  if (h != NULL)
	    tls_mask = ((struct ppc_elf_link_hash_entry *) h)->tls_mask;
	  else if (local_got_offsets != NULL)
	    {
	      char *lgot_masks;
	      lgot_masks = (char *) (local_got_offsets + symtab_hdr->sh_info);
	      tls_mask = lgot_masks[r_symndx];
	    }
	}

      /* Ensure reloc mapping code below stays sane.  */
      if ((R_PPC_GOT_TLSLD16 & 3)    != (R_PPC_GOT_TLSGD16 & 3)
	  || (R_PPC_GOT_TLSLD16_LO & 3) != (R_PPC_GOT_TLSGD16_LO & 3)
	  || (R_PPC_GOT_TLSLD16_HI & 3) != (R_PPC_GOT_TLSGD16_HI & 3)
	  || (R_PPC_GOT_TLSLD16_HA & 3) != (R_PPC_GOT_TLSGD16_HA & 3)
	  || (R_PPC_GOT_TLSLD16 & 3)    != (R_PPC_GOT_TPREL16 & 3)
	  || (R_PPC_GOT_TLSLD16_LO & 3) != (R_PPC_GOT_TPREL16_LO & 3)
	  || (R_PPC_GOT_TLSLD16_HI & 3) != (R_PPC_GOT_TPREL16_HI & 3)
	  || (R_PPC_GOT_TLSLD16_HA & 3) != (R_PPC_GOT_TPREL16_HA & 3))
	abort ();
      switch (r_type)
	{
	default:
	  break;

	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	      bfd_vma insn;
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset - 2);
	      insn &= 31 << 21;
	      insn |= 0x3c020000;	/* addis 0,2,0 */
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset - 2);
	      r_type = R_PPC_TPREL16_HA;
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC_TLS:
	  if (tls_mask != 0
	      && (tls_mask & TLS_TPREL) == 0)
	    {
	      bfd_vma insn, rtra;
	      insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	      if ((insn & ((31 << 26) | (31 << 11)))
		  == ((31 << 26) | (2 << 11)))
		rtra = insn & ((1 << 26) - (1 << 16));
	      else if ((insn & ((31 << 26) | (31 << 16)))
		       == ((31 << 26) | (2 << 16)))
		rtra = (insn & (31 << 21)) | ((insn & (31 << 11)) << 5);
	      else
		abort ();
	      if ((insn & ((1 << 11) - (1 << 1))) == 266 << 1)
		/* add -> addi.  */
		insn = 14 << 26;
	      else if ((insn & (31 << 1)) == 23 << 1
		       && ((insn & (31 << 6)) < 14 << 6
			   || ((insn & (31 << 6)) >= 16 << 6
			       && (insn & (31 << 6)) < 24 << 6)))
		/* load and store indexed -> dform.  */
		insn = (32 | ((insn >> 6) & 31)) << 26;
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & (0x1a << 6)) == 0)
		/* ldx, ldux, stdx, stdux -> ld, ldu, std, stdu.  */
		insn = (((58 | ((insn >> 6) & 4)) << 26)
			| ((insn >> 6) & 1));
	      else if ((insn & (31 << 1)) == 21 << 1
		       && (insn & ((1 << 11) - (1 << 1))) == 341 << 1)
		/* lwax -> lwa.  */
		insn = (58 << 26) | 2;
	      else
		abort ();
	      insn |= rtra;
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	      r_type = R_PPC_TPREL16_LO;
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	      /* Was PPC_TLS which sits on insn boundary, now
		 PPC_TPREL16_LO which is at insn+2.  */
	      rel->r_offset += 2;
	    }
	  break;

	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_gdld_hi;
	  break;

	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
	    {
	    tls_gdld_hi:
	      if ((tls_mask & tls_gd) != 0)
		r_type = (((r_type - (R_PPC_GOT_TLSGD16 & 3)) & 3)
			  + R_PPC_GOT_TPREL16);
	      else
		{
		  bfd_put_32 (output_bfd, NOP, contents + rel->r_offset);
		  rel->r_offset -= 2;
		  r_type = R_PPC_NONE;
		}
	      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
	    }
	  break;

	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	  tls_gd = TLS_TPRELGD;
	  if (tls_mask != 0 && (tls_mask & TLS_GD) == 0)
	    goto tls_get_addr_check;
	  break;

	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	  if (tls_mask != 0 && (tls_mask & TLS_LD) == 0)
	    {
	    tls_get_addr_check:
	      if (rel + 1 < relend)
		{
		  enum elf_ppc_reloc_type r_type2;
		  unsigned long r_symndx2;
		  struct elf_link_hash_entry *h2;
		  bfd_vma insn1, insn2, insn3;
		  bfd_vma offset;

		  /* The next instruction should be a call to
		     __tls_get_addr.  Peek at the reloc to be sure.  */
		  r_type2
		    = (enum elf_ppc_reloc_type) ELF32_R_TYPE (rel[1].r_info);
		  r_symndx2 = ELF32_R_SYM (rel[1].r_info);
		  if (r_symndx2 < symtab_hdr->sh_info
		      || (r_type2 != R_PPC_REL14
			  && r_type2 != R_PPC_REL14_BRTAKEN
			  && r_type2 != R_PPC_REL14_BRNTAKEN
			  && r_type2 != R_PPC_REL24
			  && r_type2 != R_PPC_PLTREL24))
		    break;

		  h2 = sym_hashes[r_symndx2 - symtab_hdr->sh_info];
		  while (h2->root.type == bfd_link_hash_indirect
			 || h2->root.type == bfd_link_hash_warning)
		    h2 = (struct elf_link_hash_entry *) h2->root.u.i.link;
		  if (h2 == NULL || h2 != htab->tls_get_addr)
		    break;

		  /* OK, it checks out.  Replace the call.  */
		  offset = rel[1].r_offset;
		  insn1 = bfd_get_32 (output_bfd,
				      contents + rel->r_offset - 2);
		  insn3 = bfd_get_32 (output_bfd,
				      contents + offset + 4);
		  if ((tls_mask & tls_gd) != 0)
		    {
		      /* IE */
		      insn1 &= (1 << 26) - 1;
		      insn1 |= 32 << 26;	/* lwz */
		      insn2 = 0x7c631214;	/* add 3,3,2 */
		      rel[1].r_info = ELF32_R_INFO (r_symndx2, R_PPC_NONE);
		      r_type = (((r_type - (R_PPC_GOT_TLSGD16 & 3)) & 3)
				+ R_PPC_GOT_TPREL16);
		      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
		    }
		  else
		    {
		      /* LE */
		      insn1 = 0x3c620000;	/* addis 3,2,0 */
		      insn2 = 0x38630000;	/* addi 3,3,0 */
		      if (tls_gd == 0)
			{
			  /* Was an LD reloc.  */
			  r_symndx = 0;
			  rel->r_addend = htab->tls_sec->vma + DTP_OFFSET;
			  rel[1].r_addend = htab->tls_sec->vma + DTP_OFFSET;
			}
		      r_type = R_PPC_TPREL16_HA;
		      rel->r_info = ELF32_R_INFO (r_symndx, r_type);
		      rel[1].r_info = ELF32_R_INFO (r_symndx,
						    R_PPC_TPREL16_LO);
		      rel[1].r_offset += 2;
		    }
		  if (insn3 == NOP
		      || insn3 == CROR_151515 || insn3 == CROR_313131)
		    {
		      insn3 = insn2;
		      insn2 = NOP;
		      rel[1].r_offset += 4;
		    }
		  bfd_put_32 (output_bfd, insn1, contents + rel->r_offset - 2);
		  bfd_put_32 (output_bfd, insn2, contents + offset);
		  bfd_put_32 (output_bfd, insn3, contents + offset + 4);
		  if (tls_gd == 0)
		    {
		      /* We changed the symbol on an LD reloc.  Start over
			 in order to get h, sym, sec etc. right.  */
		      rel--;
		      continue;
		    }
		}
a3415 33
	  break;
	}

      /* Handle other relocations that tweak non-addend part of insn.  */
      branch_bit = 0;
      switch (r_type)
	{
	default:
	  break;

	  /* Branch taken prediction relocations.  */
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_REL14_BRTAKEN:
	  branch_bit = BRANCH_PREDICT_BIT;
	  /* Fall thru */

	  /* Branch not taken predicition relocations.  */
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
	  insn &= ~BRANCH_PREDICT_BIT;
	  insn |= branch_bit;

	  from = (rel->r_offset
		  + input_section->output_offset
		  + input_section->output_section->vma);

	  /* Invert 'y' bit if not the default.  */
	  if ((bfd_signed_vma) (relocation + rel->r_addend - from) < 0)
	    insn ^= BRANCH_PREDICT_BIT;

	  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	  break;
d3418 1
a3418 6
      addend = rel->r_addend;
      tls_type = 0;
      howto = NULL;
      if ((unsigned) r_type < (unsigned) R_PPC_max)
	howto = ppc_elf_howto_table[(int) r_type];
      switch (r_type)
d3421 3
a3423 3
	  (*_bfd_error_handler)
	    (_("%s: unknown relocation type %d for symbol %s"),
	     bfd_archive_filename (input_bfd), (int) r_type, sym_name);
d3429 1
a3429 5
	case R_PPC_NONE:
	case R_PPC_TLS:
	case R_PPC_EMB_MRKREF:
	case R_PPC_GNU_VTINHERIT:
	case R_PPC_GNU_VTENTRY:
a3431 240
	  /* GOT16 relocations.  Like an ADDR16 using the symbol's
	     address in the GOT as relocation value instead of the
	     symbol's value itself.  Also, create a GOT entry for the
	     symbol and put the symbol value there.  */
	case R_PPC_GOT_TLSGD16:
	case R_PPC_GOT_TLSGD16_LO:
	case R_PPC_GOT_TLSGD16_HI:
	case R_PPC_GOT_TLSGD16_HA:
	  tls_type = TLS_TLS | TLS_GD;
	  goto dogot;

	case R_PPC_GOT_TLSLD16:
	case R_PPC_GOT_TLSLD16_LO:
	case R_PPC_GOT_TLSLD16_HI:
	case R_PPC_GOT_TLSLD16_HA:
	  tls_type = TLS_TLS | TLS_LD;
	  goto dogot;

	case R_PPC_GOT_TPREL16:
	case R_PPC_GOT_TPREL16_LO:
	case R_PPC_GOT_TPREL16_HI:
	case R_PPC_GOT_TPREL16_HA:
	  tls_type = TLS_TLS | TLS_TPREL;
	  goto dogot;

	case R_PPC_GOT_DTPREL16:
	case R_PPC_GOT_DTPREL16_LO:
	case R_PPC_GOT_DTPREL16_HI:
	case R_PPC_GOT_DTPREL16_HA:
	  tls_type = TLS_TLS | TLS_DTPREL;
	  goto dogot;

	case R_PPC_GOT16:
	case R_PPC_GOT16_LO:
	case R_PPC_GOT16_HI:
	case R_PPC_GOT16_HA:
	dogot:
	  {
	    /* Relocation is to the entry for this symbol in the global
	       offset table.  */
	    bfd_vma off;
	    bfd_vma *offp;
	    unsigned long indx;

	    if (htab->got == NULL)
	      abort ();

	    indx = 0;
	    if (tls_type == (TLS_TLS | TLS_LD)
		&& (h == NULL
		    || !(h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC)))
	      offp = &htab->tlsld_got.offset;
	    else if (h != NULL)
	      {
		bfd_boolean dyn;
		dyn = htab->elf.dynamic_sections_created;
		if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		    || (info->shared
			&& SYMBOL_REFERENCES_LOCAL (info, h)))
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  */
		  ;
		else
		  {
		    indx = h->dynindx;
		    unresolved_reloc = FALSE;
		  }
		offp = &h->got.offset;
	      }
	    else
	      {
		if (local_got_offsets == NULL)
		  abort ();
		offp = &local_got_offsets[r_symndx];
	      }

	    /* The offset must always be a multiple of 4.  We use the
	       least significant bit to record whether we have already
	       processed this entry.  */
	    off = *offp;
	    if ((off & 1) != 0)
	      off &= ~1;
	    else
	      {
		unsigned int tls_m = (tls_mask
				      & (TLS_LD | TLS_GD | TLS_DTPREL
					 | TLS_TPREL | TLS_TPRELGD));

		if (offp == &htab->tlsld_got.offset)
		  tls_m = TLS_LD;
		else if (h == NULL
			 || !(h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_DYNAMIC))
		  tls_m &= ~TLS_LD;

		/* We might have multiple got entries for this sym.
		   Initialize them all.  */
		do
		  {
		    int tls_ty = 0;

		    if ((tls_m & TLS_LD) != 0)
		      {
			tls_ty = TLS_TLS | TLS_LD;
			tls_m &= ~TLS_LD;
		      }
		    else if ((tls_m & TLS_GD) != 0)
		      {
			tls_ty = TLS_TLS | TLS_GD;
			tls_m &= ~TLS_GD;
		      }
		    else if ((tls_m & TLS_DTPREL) != 0)
		      {
			tls_ty = TLS_TLS | TLS_DTPREL;
			tls_m &= ~TLS_DTPREL;
		      }
		    else if ((tls_m & (TLS_TPREL | TLS_TPRELGD)) != 0)
		      {
			tls_ty = TLS_TLS | TLS_TPREL;
			tls_m = 0;
		      }

		    /* Generate relocs for the dynamic linker.  */
		    if (info->shared || indx != 0)
		      {
			outrel.r_offset = (htab->got->output_section->vma
					   + htab->got->output_offset
					   + off);
			if (tls_ty & (TLS_LD | TLS_GD))
			  {
			    outrel.r_info = ELF32_R_INFO (indx, R_PPC_DTPMOD32);
			    outrel.r_addend = 0;
			    if (tls_ty == (TLS_TLS | TLS_GD))
			      {
				loc = htab->relgot->contents;
				loc += (htab->relgot->reloc_count++
					* sizeof (Elf32_External_Rela));
				bfd_elf32_swap_reloca_out (output_bfd,
							   &outrel, loc);
				outrel.r_info
				  = ELF32_R_INFO (indx, R_PPC_DTPREL32);
				outrel.r_offset += 4;
			      }
			  }
			else if (tls_ty == (TLS_TLS | TLS_DTPREL))
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_DTPREL32);
			else if (tls_ty == (TLS_TLS | TLS_TPREL))
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_TPREL32);
			else if (indx == 0)
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_RELATIVE);
			else
			  outrel.r_info = ELF32_R_INFO (indx, R_PPC_GLOB_DAT);
			outrel.r_addend = 0;
			if (indx == 0)
			  outrel.r_addend += relocation;
			loc = htab->relgot->contents;
			loc += (htab->relgot->reloc_count++
				* sizeof (Elf32_External_Rela));
			bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		      }

		    /* Init the .got section contents if we're not
		       emitting a reloc.  */
		    else
		      {
			bfd_vma value = relocation;

			if ((tls_ty & (TLS_GD | TLS_TPREL | TLS_DTPREL
				       | TLS_TPRELGD)) != 0)
			  {
			    value -= htab->tls_sec->vma + DTP_OFFSET;
			    if ((tls_ty & TLS_TPREL) != 0)
			      value += DTP_OFFSET - TP_OFFSET;
			  }

			if (tls_ty == (TLS_TLS | TLS_GD))
			  {
			    bfd_put_32 (output_bfd, value,
					htab->got->contents + off + 4);
			    value = 1;
			  }
			else if (tls_ty == (TLS_TLS | TLS_LD))
			  value = 1;
			bfd_put_32 (output_bfd, value,
				    htab->got->contents + off);
		      }

		    off += 4;
		    if (tls_ty & (TLS_LD | TLS_GD))
		      off += 4;
		  }
		while (tls_m != 0);

		off = *offp;
		*offp = off | 1;
	      }

	    if (off >= (bfd_vma) -2)
	      abort ();

	    if ((tls_type & TLS_TLS) != 0)
	      {
		if (tls_type != (TLS_TLS | TLS_LD))
		  {
		    if ((tls_mask & TLS_LD) != 0
			&& !(h == NULL
			     || !(h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC)))
		      off += 8;
		    if (tls_type != (TLS_TLS | TLS_GD))
		      {
			if ((tls_mask & TLS_GD) != 0)
			  off += 8;
			if (tls_type != (TLS_TLS | TLS_DTPREL))
			  {
			    if ((tls_mask & TLS_DTPREL) != 0)
			      off += 4;
			  }
		      }
		  }
	      }

	    relocation = htab->got->output_offset + off - 4;

	    /* Addends on got relocations don't make much sense.
	       x+off@@got is actually x@@got+off, and since the got is
	       generated by a hash table traversal, the value in the
	       got at entry m+n bears little relation to the entry m.  */
	    if (addend != 0)
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): non-zero addend on got reloc against `%s'"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
		 (long) rel->r_offset,
		 sym_name);
	  }
	break;

d3433 1
a3433 1
	case R_PPC_LOCAL24PC:
d3452 5
a3456 32
	case R_PPC_DTPREL16:
	case R_PPC_DTPREL16_LO:
	case R_PPC_DTPREL16_HI:
	case R_PPC_DTPREL16_HA:
	  addend -= htab->tls_sec->vma + DTP_OFFSET;
	  break;

	  /* Relocations that may need to be propagated if this is a shared
	     object.  */
	case R_PPC_TPREL16:
	case R_PPC_TPREL16_LO:
	case R_PPC_TPREL16_HI:
	case R_PPC_TPREL16_HA:
	  addend -= htab->tls_sec->vma + TP_OFFSET;
	  /* The TPREL16 relocs shouldn't really be used in shared
	     libs as they will result in DT_TEXTREL being set, but
	     support them anyway.  */
	  goto dodyn;

	case R_PPC_TPREL32:
	  addend -= htab->tls_sec->vma + TP_OFFSET;
	  goto dodyn;

	case R_PPC_DTPREL32:
	  addend -= htab->tls_sec->vma + DTP_OFFSET;
	  goto dodyn;

	case R_PPC_REL24:
	case R_PPC_REL32:
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
d3463 1
a3463 23
	  /* fall through */

	  /* Relocations that always need to be propagated if this is a shared
	     object.  */
	case R_PPC_ADDR32:
	case R_PPC_ADDR24:
	case R_PPC_ADDR16:
	case R_PPC_ADDR16_LO:
	case R_PPC_ADDR16_HI:
	case R_PPC_ADDR16_HA:
	case R_PPC_ADDR14:
	case R_PPC_ADDR14_BRTAKEN:
	case R_PPC_ADDR14_BRNTAKEN:
	case R_PPC_UADDR32:
	case R_PPC_UADDR16:
	case R_PPC_DTPMOD32:
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	dodyn:
	  if (r_symndx == 0)
	    break;
	  /* Fall thru.  */
d3465 12
a3476 15
	  if ((info->shared
	       && (MUST_BE_DYN_RELOC (r_type)
		   || (h != NULL
		       && h->dynindx != -1
		       && (!info->symbolic
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (input_section->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && h->dynindx != -1
		  && (h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0))
d3478 2
d3484 1
a3484 2
		       (h && h->root.root.string
			? h->root.root.string : "<unknown>"));
d3488 3
a3490 2
		 are copied into the output file to be resolved at run
		 time.  */
d3507 1
a3507 1
		  sreloc = bfd_get_section_by_name (htab->elf.dynobj, name);
d3525 2
a3526 3
		 become local.  */
	      else if (h != NULL
		       && !SYMBOL_REFERENCES_LOCAL (info, h))
a3527 1
		  unresolved_reloc = FALSE;
d3541 10
d3574 2
a3575 2
				      indx, osec->name, osec->flags,
				      h->root.root.string);
d3602 23
d3627 9
a3635 8
	  /* Indirect .sdata relocation.  */
	case R_PPC_EMB_SDAI16:
	  BFD_ASSERT (htab->sdata != NULL);
	  relocation
	    = bfd_elf32_finish_pointer_linker_section (output_bfd, input_bfd,
						       info, htab->sdata, h,
						       relocation, rel,
						       R_PPC_RELATIVE);
d3638 90
a3727 8
	  /* Indirect .sdata2 relocation.  */
	case R_PPC_EMB_SDA2I16:
	  BFD_ASSERT (htab->sdata2 != NULL);
	  relocation
	    = bfd_elf32_finish_pointer_linker_section (output_bfd, input_bfd,
						       info, htab->sdata2, h,
						       relocation, rel,
						       R_PPC_RELATIVE);
d3730 21
a3750 5
	  /* Handle the TOC16 reloc.  We want to use the offset within the .got
	     section, not the actual VMA.  This is appropriate when generating
	     an embedded ELF object, for which the .got section acts like the
	     AIX .toc section.  */
	case R_PPC_TOC16:			/* phony GOT16 relocations */
d3756 1
a3756 1
	    addend -= sec->output_section->vma + sec->output_offset + 0x8000;
d3759 1
a3759 1
	case R_PPC_PLTREL24:
d3761 1
a3761 1
	     procedure linkage table.  */
d3765 1
a3765 1
	      || htab->plt == NULL)
d3768 2
a3769 2
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
d3773 2
a3774 3
	  unresolved_reloc = FALSE;
	  relocation = (htab->plt->output_section->vma
			+ htab->plt->output_offset
d3778 2
a3779 2
	  /* Relocate against _SDA_BASE_.  */
	case R_PPC_SDAREL16:
a3781 1
	    const struct elf_link_hash_entry *sh;
d3793 1
a3793 1
				       howto->name,
d3796 3
a3798 4
	    sh = htab->sdata->sym_hash;
	    addend -= (sh->root.u.def.value
		       + sh->root.u.def.section->output_section->vma
		       + sh->root.u.def.section->output_offset);
d3802 2
a3803 2
	  /* Relocate against _SDA2_BASE_.  */
	case R_PPC_EMB_SDA2REL:
a3805 1
	    const struct elf_link_hash_entry *sh;
d3815 1
a3815 1
				       howto->name,
d3822 3
a3824 4
	    sh = htab->sdata2->sym_hash;
	    addend -= (sh->root.u.def.value
		       + sh->root.u.def.section->output_section->vma
		       + sh->root.u.def.section->output_offset);
d3828 3
a3830 3
	  /* Relocate against either _SDA_BASE_, _SDA2_BASE_, or 0.  */
	case R_PPC_EMB_SDA21:
	case R_PPC_EMB_RELSDA:
a3832 1
	    const struct elf_link_hash_entry *sh;
d3843 3
a3845 4
		sh = htab->sdata->sym_hash;
		addend -= (sh->root.u.def.value
			   + sh->root.u.def.section->output_section->vma
			   + sh->root.u.def.section->output_offset);
d3852 3
a3854 4
		sh = htab->sdata2->sym_hash;
		addend -= (sh->root.u.def.value
			   + sh->root.u.def.section->output_section->vma
			   + sh->root.u.def.section->output_offset);
d3868 1
a3868 1
				       howto->name,
d3878 1
a3878 1
		insn = bfd_get_32 (output_bfd, contents + rel->r_offset);
d3880 1
a3880 1
		bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
d3885 9
a3893 5
	  /* Relocate against the beginning of the section.  */
	case R_PPC_SECTOFF:
	case R_PPC_SECTOFF_LO:
	case R_PPC_SECTOFF_HI:
	case R_PPC_SECTOFF_HA:
d3896 9
d3907 1
a3907 6
	  /* Negative relocations.  */
	case R_PPC_EMB_NADDR32:
	case R_PPC_EMB_NADDR16:
	case R_PPC_EMB_NADDR16_LO:
	case R_PPC_EMB_NADDR16_HI:
	case R_PPC_EMB_NADDR16_HA:
d3909 1
d3912 23
a3934 20
	case R_PPC_COPY:
	case R_PPC_GLOB_DAT:
	case R_PPC_JMP_SLOT:
	case R_PPC_RELATIVE:
	case R_PPC_PLT32:
	case R_PPC_PLTREL32:
	case R_PPC_PLT16_LO:
	case R_PPC_PLT16_HI:
	case R_PPC_PLT16_HA:
	case R_PPC_ADDR30:
	case R_PPC_EMB_RELSEC16:
	case R_PPC_EMB_RELST_LO:
	case R_PPC_EMB_RELST_HI:
	case R_PPC_EMB_RELST_HA:
	case R_PPC_EMB_BIT_FLD:
	  (*_bfd_error_handler)
	    (_("%s: Relocation %s is not yet supported for symbol %s."),
	     bfd_archive_filename (input_bfd),
	     howto->name,
	     sym_name);
a3938 1
	}
d3940 4
a3943 26
      /* Do any further special processing.  */
      switch (r_type)
	{
	default:
	  break;

	case R_PPC_ADDR16_HA:
	case R_PPC_GOT16_HA:
	case R_PPC_PLT16_HA:
	case R_PPC_SECTOFF_HA:
	case R_PPC_TPREL16_HA:
	case R_PPC_DTPREL16_HA:
	case R_PPC_GOT_TLSGD16_HA:
	case R_PPC_GOT_TLSLD16_HA:
	case R_PPC_GOT_TPREL16_HA:
	case R_PPC_GOT_DTPREL16_HA:
	case R_PPC_EMB_NADDR16_HA:
	case R_PPC_EMB_RELST_HA:
	  /* It's just possible that this symbol is a weak symbol
	     that's not actually defined anywhere. In that case,
	     'sec' would be NULL, and we should leave the symbol
	     alone (it will be set to zero elsewhere in the link).  */
	  if (sec != NULL)
	    /* Add 0x10000 if sign bit in 0:15 is set.  */
	    addend += ((relocation + addend) & 0x8000) << 1;
	  break;
d3952 1
a3952 1
	       (long) rel->r_offset,
a3955 13
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
	{
	  (*_bfd_error_handler)
	    (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	     bfd_archive_filename (input_bfd),
	     bfd_get_section_name (input_bfd, input_section),
	     (long) rel->r_offset,
	     sym_name);
	  ret = FALSE;
	}

d3960 1
a3960 1
				    rel->r_offset,
d3964 3
a3966 1
      if (r != bfd_reloc_ok)
d3968 3
a3970 3
	  if (sym_name == NULL)
	    sym_name = "(null)";
	  if (r == bfd_reloc_overflow)
d3972 1
a3972 4
	      if (warned)
		continue;
	      if (h != NULL
		  && h->root.type == bfd_link_hash_undefweak
d3984 1
a3984 8
	      if (! (*info->callbacks->reloc_overflow) (info,
							sym_name,
							howto->name,
							rel->r_addend,
							input_bfd,
							input_section,
							rel->r_offset))
		return FALSE;
d3988 7
a3994 6
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
		 (long) rel->r_offset, sym_name, (int) r);
	      ret = FALSE;
d3996 9
d4006 2
d4036 1
a4036 2
/* Support for core dump NOTE sections.  */

d4047 2
a4048 2
    default:
      return FALSE;
d4050 10
a4059 3
    case 268:		/* Linux/PPC.  */
      /* pr_cursig */
      elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d4061 1
a4061 8
      /* pr_pid */
      elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);

      /* pr_reg */
      offset = 72;
      raw_size = 192;

      break;
d4076 2
a4077 2
    default:
      return FALSE;
d4079 5
a4083 5
    case 128:		/* Linux/PPC elf_prpsinfo.  */
      elf_tdata (abfd)->core_program
	= _bfd_elfcore_strndup (abfd, note->descdata + 32, 16);
      elf_tdata (abfd)->core_command
	= _bfd_elfcore_strndup (abfd, note->descdata + 48, 80);
d4104 2
a4105 2
  struct apuinfo_list *next;
  unsigned long value;
d4111 3
a4113 3
static void apuinfo_list_init PARAMS ((void));
static void apuinfo_list_add PARAMS ((unsigned long));
static unsigned apuinfo_list_length PARAMS ((void));
d4115 1
a4115 1
static void apuinfo_list_finish PARAMS ((void));
d4117 1
a4117 1
extern void ppc_elf_begin_write_processing
d4119 1
a4119 1
extern void ppc_elf_final_write_processing
d4121 1
a4121 1
extern bfd_boolean ppc_elf_write_section
d4125 1
d4136 1
a4136 1
  apuinfo_list *entry = head;
d4157 1
a4157 1
  apuinfo_list *entry;
d4185 1
a4185 1
  apuinfo_list *entry;
d4189 1
a4189 1
      apuinfo_list *next = entry->next;
d4197 2
a4198 2
#define APUINFO_SECTION_NAME	".PPC.EMB.apuinfo"
#define APUINFO_LABEL		"APUinfo"
d4208 4
a4211 4
  bfd *ibfd;
  asection *asec;
  char *buffer;
  unsigned num_input_sections;
d4213 2
a4214 2
  unsigned i;
  unsigned num_entries;
d4217 1
a4217 1
  const char *error_message = NULL;
d4257 3
a4259 2
      unsigned long datum;
      char *ptr;
d4322 1
a4322 1
  if (! bfd_set_section_size (abfd, asec, output_section_size))
d4330 2
a4331 2
    (*_bfd_error_handler) (error_message, APUINFO_SECTION_NAME,
			   bfd_archive_filename (ibfd));
d4340 3
a4342 3
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *asec;
     bfd_byte *contents ATTRIBUTE_UNUSED;
d4344 1
a4344 2
  return (apuinfo_list_length ()
	  && strcmp (asec->name, APUINFO_SECTION_NAME) == 0);
d4352 1
a4352 1
     bfd *abfd;
d4355 4
a4358 4
  bfd_byte *buffer;
  asection *asec;
  unsigned i;
  unsigned num_entries;
d4375 1
a4375 2
      (*_bfd_error_handler)
	(_("failed to allocate space for new APUinfo section."));
d4394 1
a4394 1
    (*_bfd_error_handler) (_("failed to compute new APUinfo section."));
d4397 1
a4397 1
    (*_bfd_error_handler) (_("failed to install new APUinfo section."));
d4430 1
a4430 1
#define bfd_elf32_bfd_relax_section		ppc_elf_relax_section
d4433 2
a4434 1
#define bfd_elf32_bfd_link_hash_table_create	ppc_elf_link_hash_table_create
d4455 3
a4457 3
#define elf_backend_begin_write_processing	ppc_elf_begin_write_processing
#define elf_backend_final_write_processing	ppc_elf_final_write_processing
#define elf_backend_write_section		ppc_elf_write_section
@


1.51.2.7
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d150 2
a151 6
   in this object?  STV_PROTECTED is excluded from the visibility test
   here so that function pointer comparisons work properly.  Since
   function symbols not defined in an app are set to their .plt entry,
   it's necessary for shared libs to also reference the .plt even
   though the symbol is really local to the shared lib.  */
#define SYMBOL_REFERENCES_LOCAL(INFO, H) 				\
d2303 1
a2303 1
	  (*_bfd_error_handler) (_("%s: unknown special linker type %d"),
a2527 4
      if (ELIMINATE_COPY_RELOCS)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d3458 2
a3459 1
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d3744 2
a3745 1
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d4523 1
a4523 1
		  bfd_vma insn1, insn2;
d4550 2
d4581 7
d4590 1
a4787 1
			outrel.r_addend = 0;
d4791 1
a4798 1
				outrel.r_offset += 4;
d4801 1
d4812 1
d4814 1
a4814 5
			  {
			    outrel.r_addend += relocation;
			    if (tls_ty & (TLS_GD | TLS_DTPREL | TLS_TPREL))
			      outrel.r_addend -= htab->tls_sec->vma;
			  }
d4827 2
a4828 3
			if (tls_ty == (TLS_TLS | TLS_LD))
			  value = 1;
			else if (tls_ty != 0)
d4831 1
a4831 1
			    if (tls_ty == (TLS_TLS | TLS_TPREL))
d4833 1
d4835 5
a4839 6
			    if (tls_ty == (TLS_TLS | TLS_GD))
			      {
				bfd_put_32 (output_bfd, value,
					    htab->got->contents + off + 4);
				value = 1;
			      }
d4841 2
d4890 1
a4890 1
		(_("%s(%s+0x%lx): non-zero addend on %s reloc against `%s'"),
a4893 1
		 howto->name,
d4902 4
a4905 1
	  if (unresolved_reloc)
a4944 5
	case R_PPC_DTPMOD32:
	  relocation = 1;
	  addend = 0;
	  goto dodyn;

d4971 1
d5040 2
d5178 1
a5178 1
		(*_bfd_error_handler) (_("%s: the target (%s) of a %s relocation is in the wrong output section (%s)"),
d5202 1
a5202 1
		(*_bfd_error_handler) (_("%s: the target (%s) of a %s relocation is in the wrong output section (%s)"),
d5259 1
a5259 1
		(*_bfd_error_handler) (_("%s: the target (%s) of a %s relocation is in the wrong output section (%s)"),
d5313 1
a5313 1
	    (_("%s: relocation %s is not yet supported for symbol %s."),
d5342 1
a5342 1
	     that's not actually defined anywhere.  In that case,
d5346 2
a5347 3
	    /* Add 0x10000 if sign bit in 0:15 is set.
	       Bits 0:15 are not used.  */
	    addend += 0x8000;
d5366 1
a5366 1
	    (_("%s(%s+0x%lx): unresolvable %s relocation against symbol `%s'"),
a5369 1
	     howto->name,
d5415 1
a5415 1
		(_("%s(%s+0x%lx): %s reloc against `%s': error %d"),
d5418 1
a5418 1
		 (long) rel->r_offset, howto->name, sym_name, (int) r);
@


1.51.2.8
log
@2003-04-30  David Carlton  <carlton@@bactrian.org>

	* cp-namespace.c (get_namespace_objfile): Copy the namespace
	objfile's name.

	* block.h (ALL_BLOCK_SYMBOLS): Move here from dictionary.h.
	* dictionary.c: Sync up with mainline version I just posted.
	Specifically, update some commments, and:
	(dict_create_hashed): Fiddle with nsyms updating.
	(dict_create_linear): Ditto.
	(dict_lookup): Delete.
	(iterator_next_hashed): Delete FIXME comment.
	(iter_name_first_hashed): Replace 'sym' by 'sym != NULL'.
	(iter_name_next_hashed): Replate 'next' by 'next != NULL'.
	* dictionary.h: Sync up with mainline version I just posted: add
	inclusion guards, delete declaration of dict_lookup, delete
	ALL_BLOCK_SYMBOLs.

	* Merge with mainline; tag is carlton_dictionary-20030430-merge.
@
text
@d19 2
a20 3
   along with this program; if not, write to the
   Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
d155 1
a155 1
#define SYMBOL_REFERENCES_LOCAL(INFO, H)				\
d164 1
a164 1
#define SYMBOL_CALLS_LOCAL(INFO, H)					\
d201 1
a201 1
     TLS_GD .. TLS_TLS bits are or'd into the mask as the
a321 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d370 1
a370 10
  if (ELIMINATE_COPY_RELOCS && ind->root.type != bfd_link_hash_indirect)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1616 1
a1616 3
  for (i = 0;
       i < sizeof (ppc_elf_howto_raw) / sizeof (ppc_elf_howto_raw[0]);
       i++)
d1619 1
a1619 3
      if (type >= (sizeof (ppc_elf_howto_table)
		   / sizeof (ppc_elf_howto_table[0])))
	abort ();
d1633 1
a1633 2
      (The EOP limit is 5 by default but may be specified as any value
      from 1-10.)
d2458 6
d2503 1
a2503 1
	  || SYMBOL_CALLS_LOCAL (info, h)
@


1.51.2.9
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@d150 21
d377 1
a377 3
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
d1736 3
a1738 3
	    = _bfd_elf_link_read_relocs (abfd, isec, (PTR) NULL,
					 (Elf_Internal_Rela *) NULL,
					 link_info->keep_memory);
d2517 1
a2517 1
      if (h->plt.refcount <= 0
d2519 1
a2519 2
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d2523 2
a2524 3
	     1. We are not using ld.so; because then the PLT entry
	     can't be set up, so we can't use one.  In this case,
	     ppc_elf_adjust_dynamic_symbol won't even be called.
d2526 2
a2527 1
	     2. GC has rendered the entry unused.
d2529 1
a2529 2
	     3. We know for certain that a call to this symbol
	     will go to this object, or will remain undefined.  */
d2790 2
a2791 4
	  if ((info->shared
	       || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, &eh->elf))
	      && (ELF_ST_VISIBILITY (eh->elf.other) == STV_DEFAULT
		  || eh->elf.root.type != bfd_link_hash_undefweak))
a2813 1

d2816 3
a2818 7
      /* Relocs that use pc_count are those that appear on a call insn,
	 or certain REL relocs (see MUST_BE_DYN_RELOC) that can be
	 generated via assembly.  We want calls to protected symbols to
	 resolve directly to the function rather than going via the plt.
	 If people want function pointer comparisons to work as expected
	 then they should avoid writing weird assembly.  */ 
      if (SYMBOL_CALLS_LOCAL (info, h))
a2831 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d3851 3
a3853 3
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, (PTR) NULL,
						  (Elf_Internal_Rela *) NULL,
						  info->keep_memory);
d4794 1
a4794 4
		    if ((info->shared || indx != 0)
			&& (h == NULL
			    || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
			    || h->root.type != bfd_link_hash_undefweak))
a4995 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d4998 4
a5001 1
		       && !SYMBOL_CALLS_LOCAL (info, h))))
@


1.51.2.10
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d38 18
d57 1
a57 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d59 61
a119 1
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
d238 4
a241 3
ppc_elf_link_hash_newfunc (struct bfd_hash_entry *entry,
			   struct bfd_hash_table *table,
			   const char *string)
d267 2
a268 1
ppc_elf_link_hash_table_create (bfd *abfd)
d272 2
a273 1
  ret = bfd_malloc (sizeof (struct ppc_elf_link_hash_table));
d311 3
a313 3
ppc_elf_copy_indirect_symbol (struct elf_backend_data *bed,
			      struct elf_link_hash_entry *dir,
			      struct elf_link_hash_entry *ind)
d370 1
a370 1
static reloc_howto_type *ppc_elf_howto_table[R_PPC_max];
d1609 1
a1609 1
ppc_elf_howto_init (void)
d1650 3
a1652 1
ppc_elf_sort_rela (const void *arg1, const void *arg2)
d1654 2
a1655 2
  const Elf_Internal_Rela * const *rela1 = arg1;
  const Elf_Internal_Rela * const *rela2 = arg2;
d1662 5
a1666 4
ppc_elf_relax_section (bfd *abfd,
		       asection *isec,
		       struct bfd_link_info *link_info,
		       bfd_boolean *again)
d1698 1
a1698 1
	  contents = bfd_malloc (isec->_raw_size);
d1717 2
a1718 1
	    = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL,
d1728 1
a1728 1
	  rela_comb = bfd_malloc (amt);
d1733 1
a1733 1
	      enum elf_ppc_reloc_type r_type;
d1736 1
a1736 1
	      if (r_type >= R_PPC_max)
d1864 1
a1864 1
		  bfd_put_32 (abfd, insn, contents + isec_offset);
d1913 3
a1915 2
ppc_elf_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   bfd_reloc_code_real_type code)
a1918 1
  /* Initialize howto table if not already done.  */
d1920 1
d1923 1
a1923 1
  switch (code)
d1926 1
a1926 1
      return NULL;
d2011 1
a2011 1
  return ppc_elf_howto_table[r];
d2017 4
a2020 3
ppc_elf_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
		       arelent *cache_ptr,
		       Elf_Internal_Rela *dst)
a2021 1
  /* Initialize howto table if not already done.  */
d2023 1
d2033 9
a2041 7
ppc_elf_addr16_ha_reloc (bfd *abfd ATTRIBUTE_UNUSED,
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void *data ATTRIBUTE_UNUSED,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message ATTRIBUTE_UNUSED)
d2069 9
a2077 7
ppc_elf_unhandled_reloc (bfd *abfd,
			 arelent *reloc_entry,
			 asymbol *symbol,
			 void *data,
			 asection *input_section,
			 bfd *output_bfd,
			 char **error_message)
d2089 1
a2089 1
      sprintf (buf, _("generic linker can't handle %s"),
d2100 2
a2101 1
ppc_elf_object_p (bfd *abfd)
d2120 3
a2122 1
ppc_elf_set_private_flags (bfd *abfd, flagword flags)
d2136 3
a2138 1
ppc_elf_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
d2176 1
a2176 2
	    (_("%s: compiled with -mrelocatable and linked with "
	       "modules compiled normally"),
d2184 1
a2184 2
	    (_("%s: compiled normally and linked with "
	       "modules compiled with -mrelocatable"),
d2211 1
a2211 2
	    (_("%s: uses different e_flags (0x%lx) fields "
	       "than previous modules (0x%lx)"),
d2229 4
a2232 1
ppc_elf_section_from_shdr (bfd *abfd, Elf_Internal_Shdr *hdr, const char *name)
d2255 4
a2258 3
ppc_elf_fake_sections (bfd *abfd ATTRIBUTE_UNUSED,
		       Elf_Internal_Shdr *shdr,
		       asection *asect)
d2271 4
a2274 3
ppc_elf_create_linker_section (bfd *abfd,
			       struct bfd_link_info *info,
			       enum elf_linker_section_enum which)
d2314 1
a2314 1
	  return NULL;
d2344 2
a2345 1
ppc_elf_additional_program_headers (bfd *abfd)
d2370 2
a2371 1
ppc_elf_modify_segment_map (bfd *abfd ATTRIBUTE_UNUSED)
d2379 3
a2381 1
ppc_elf_create_got (bfd *abfd, struct bfd_link_info *info)
d2417 3
a2419 1
ppc_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
d2467 3
a2469 2
ppc_elf_adjust_dynamic_symbol (struct bfd_link_info *info,
			       struct elf_link_hash_entry *h)
d2658 3
a2660 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
d2662 1
a2662 1
  struct bfd_link_info *info = inf;
d2722 1
a2722 1
	      > PLT_NUM_SINGLE_ENTRIES)
d2807 1
a2807 1
	 then they should avoid writing weird assembly.  */
d2872 3
a2874 1
readonly_dynrelocs (struct elf_link_hash_entry *h, void *info)
d2904 3
a2906 2
ppc_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
			       struct bfd_link_info *info)
d2923 1
a2923 1
      if (info->executable)
d3090 1
a3090 1
      s->contents = bfd_zalloc (htab->elf.dynobj, s->_raw_size);
d3103 1
a3103 1
  bfd_elf32_add_dynamic_entry (info, (TAG), (VAL))
d3105 1
a3105 1
      if (info->executable)
d3132 1
a3132 1
				info);
d3146 5
a3150 4
update_local_sym_info (bfd *abfd,
		       Elf_Internal_Shdr *symtab_hdr,
		       unsigned long r_symndx,
		       int tls_type)
d3160 1
a3160 1
      local_got_refcounts = bfd_zalloc (abfd, size);
d3173 3
a3175 1
bad_shared_reloc (bfd *abfd, enum elf_ppc_reloc_type r_type)
d3180 1
a3180 1
     ppc_elf_howto_table[r_type]->name);
d3189 5
a3193 4
ppc_elf_check_relocs (bfd *abfd,
		      struct bfd_link_info *info,
		      asection *sec,
		      const Elf_Internal_Rela *relocs)
d3202 1
a3202 1
  if (info->relocatable)
a3210 4
  /* Initialize howto table if not already done.  */
  if (!ppc_elf_howto_table[R_PPC_ADDR32])
    ppc_elf_howto_init ();

d3213 1
d3267 1
a3267 1
      r_type = ELF32_R_TYPE (rel->r_info);
a3385 6
	      (*_bfd_error_handler) (_("%s(%s+0x%lx): %s reloc against "
				       "local symbol"),
				     bfd_archive_filename (abfd),
				     sec->name,
				     (long) rel->r_offset,
				     ppc_elf_howto_table[r_type]->name);
d3543 1
a3543 3
	      fprintf (stderr,
		       "ppc_elf_check_relocs needs to "
		       "create relocation for %s\n",
d3607 2
a3608 1
		  p = bfd_alloc (htab->elf.dynobj, sizeof *p);
d3634 6
a3639 5
ppc_elf_gc_mark_hook (asection *sec,
		      struct bfd_link_info *info ATTRIBUTE_UNUSED,
		      Elf_Internal_Rela *rel,
		      struct elf_link_hash_entry *h,
		      Elf_Internal_Sym *sym)
d3674 5
a3678 4
ppc_elf_gc_sweep_hook (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
d3718 1
a3718 1
      r_type = ELF32_R_TYPE (rel->r_info);
d3799 3
a3801 1
ppc_elf_tls_setup (bfd *obfd, struct bfd_link_info *info)
d3823 3
a3825 2
ppc_elf_tls_optimize (bfd *obfd ATTRIBUTE_UNUSED,
		      struct bfd_link_info *info)
d3831 1
a3831 1
  if (info->relocatable || info->shared)
d3847 2
a3848 1
	    relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
d3881 1
a3881 1
		r_type = ELF32_R_TYPE (rel->r_info);
d4018 8
a4025 7
ppc_elf_add_symbol_hook (bfd *abfd,
			 struct bfd_link_info *info,
			 const Elf_Internal_Sym *sym,
			 const char **namep ATTRIBUTE_UNUSED,
			 flagword *flagsp ATTRIBUTE_UNUSED,
			 asection **secp,
			 bfd_vma *valp)
d4028 1
a4028 1
      && !info->relocatable
d4046 1
a4046 1
	  sdata->bss_section = bfd_zalloc (abfd, amt);
d4053 1
a4053 1
	  sdata->bss_section->symbol = bfd_zalloc (abfd, amt);
d4055 2
a4056 1
	  sdata->bss_section->symbol_ptr_ptr = bfd_zalloc (abfd, amt);
d4077 5
a4081 4
ppc_elf_finish_dynamic_symbol (bfd *output_bfd,
			       struct bfd_link_info *info,
			       struct elf_link_hash_entry *h,
			       Elf_Internal_Sym *sym)
d4186 3
a4188 2
ppc_elf_finish_dynamic_sections (bfd *output_bfd,
				 struct bfd_link_info *info)
d4244 1
a4244 1
      bfd_put_32 (output_bfd, 0x4e800021 /* blrl */, contents);
d4247 1
a4247 1
	bfd_put_32 (output_bfd, 0, contents + 4);
d4268 1
a4268 1
   relocatable output file) adjusting the reloc addend as
d4282 1
a4282 1
   When generating relocatable output, this function must handle
d4289 10
a4298 8
ppc_elf_relocate_section (bfd *output_bfd,
			  struct bfd_link_info *info,
			  bfd *input_bfd,
			  asection *input_section,
			  bfd_byte *contents,
			  Elf_Internal_Rela *relocs,
			  Elf_Internal_Sym *local_syms,
			  asection **local_sections)
d4312 1
a4312 2
  fprintf (stderr, "ppc_elf_relocate_section called for %s section %s, "
	   "%ld relocations%s\n",
d4316 1
a4316 1
	   (info->relocatable) ? " (relocatable)" : "");
d4319 1
a4319 1
  if (info->relocatable)
a4321 1
  /* Initialize howto table if not already done.  */
d4323 1
d4349 4
a4352 4
      r_type = ELF32_R_TYPE (rel->r_info);
      sym = NULL;
      sec = NULL;
      h = NULL;
d4545 2
a4546 1
		  r_type2 = ELF32_R_TYPE (rel[1].r_info);
d4645 2
a4646 2
      if (r_type < R_PPC_max)
	howto = ppc_elf_howto_table[r_type];
d5013 1
a5013 2
	      fprintf (stderr, "ppc_elf_relocate_section needs to "
		       "create relocation for %s\n",
d5092 5
a5096 3
			    printf ("indx=%d section=%s flags=%08x name=%s\n",
				    indx, osec->name, osec->flags,
				    h->root.root.string);
d5149 1
a5149 1
	  BFD_ASSERT (sec != NULL);
d5183 1
a5183 1
	    BFD_ASSERT (sec != NULL);
d5190 5
a5194 7
		(*_bfd_error_handler)
		  (_("%s: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)"),
		   bfd_archive_filename (input_bfd),
		   sym_name,
		   howto->name,
		   name);
d5209 1
a5209 1
	    BFD_ASSERT (sec != NULL);
d5214 5
a5218 7
		(*_bfd_error_handler)
		  (_("%s: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)"),
		   bfd_archive_filename (input_bfd),
		   sym_name,
		   howto->name,
		   name);
d5239 1
a5239 1
	    BFD_ASSERT (sec != NULL);
d5271 5
a5275 7
		(*_bfd_error_handler)
		  (_("%s: the target (%s) of a %s relocation is "
		     "in the wrong output section (%s)"),
		   bfd_archive_filename (input_bfd),
		   sym_name,
		   howto->name,
		   name);
d5296 1
a5296 1
	  BFD_ASSERT (sec != NULL);
d5365 1
a5365 2
      fprintf (stderr, "\ttype = %s (%d), name = %s, symbol index = %ld, "
	       "offset = %ld, addend = %ld\n",
d5446 2
a5447 1
ppc_elf_reloc_type_class (const Elf_Internal_Rela *rela)
d5449 1
a5449 1
  switch (ELF32_R_TYPE (rela->r_info))
d5467 3
a5469 1
ppc_elf_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d5499 3
a5501 1
ppc_elf_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d5538 14
a5551 1
static apuinfo_list *head;
d5555 1
a5555 1
apuinfo_list_init (void)
d5561 2
a5562 1
apuinfo_list_add (unsigned long value)
d5583 1
a5583 1
apuinfo_list_length (void)
d5597 2
a5598 1
apuinfo_list_element (unsigned long number)
d5611 1
a5611 1
apuinfo_list_finish (void)
d5631 4
a5634 2
static void
ppc_elf_begin_write_processing (bfd *abfd, struct bfd_link_info *link_info)
d5724 1
a5724 1
      /* Get the number of bytes used for apuinfo entries.  */
d5726 1
a5726 1
      if (datum + 20 != length)
d5734 2
a5735 2
      for (i = 0; i < datum; i += 4)
	apuinfo_list_add (bfd_get_32 (ibfd, ptr + 20 + i));
d5765 5
a5769 4
static bfd_boolean
ppc_elf_write_section (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *asec,
		       bfd_byte *contents ATTRIBUTE_UNUSED)
d5778 4
a5781 2
static void
ppc_elf_final_write_processing (bfd *abfd, bfd_boolean linker ATTRIBUTE_UNUSED)
d5811 1
a5811 1
  bfd_put_32 (abfd, num_entries * 4, buffer + 4);
@


1.51.2.11
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a72 66
/* Enumeration to specify the special section.  */
enum elf_linker_section_enum
{
  LINKER_SECTION_SDATA,
  LINKER_SECTION_SDATA2
};

/* Sections created by the linker.  */

typedef struct elf_linker_section
{
  /* pointer to the section */
  asection *section;
  /* pointer to the relocations needed for this section */
  asection *rel_section;
  /* pointer to the created symbol hash value */
  struct elf_link_hash_entry *sym_hash;
  /* offset of symbol from beginning of section */
  bfd_vma sym_offset;
} elf_linker_section_t;

/* Linked list of allocated pointer entries.  This hangs off of the
   symbol lists, and provides allows us to return different pointers,
   based on different addend's.  */

typedef struct elf_linker_section_pointers
{
  /* next allocated pointer for this symbol */
  struct elf_linker_section_pointers *next;
  /* offset of pointer from beginning of section */
  bfd_vma offset;
  /* addend used */
  bfd_vma addend;
  /* which linker section this is */
  elf_linker_section_t *lsect;
  /* whether address was written yet */
  bfd_boolean written_address_p;
} elf_linker_section_pointers_t;

struct ppc_elf_obj_tdata
{
  struct elf_obj_tdata elf;

  /* A mapping from local symbols to offsets into the various linker
     sections added.  This is index by the symbol index.  */
  elf_linker_section_pointers_t **linker_section_pointers;
};

#define ppc_elf_tdata(bfd) \
  ((struct ppc_elf_obj_tdata *) (bfd)->tdata.any)

#define elf_local_ptr_offsets(bfd) \
  (ppc_elf_tdata (bfd)->linker_section_pointers)

/* Override the generic function because we store some extras.  */

static bfd_boolean
ppc_elf_mkobject (bfd *abfd)
{
  bfd_size_type amt = sizeof (struct ppc_elf_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

a98 5
  /* If this symbol is used in the linker created sections, the processor
     specific backend uses this field to map the field into the offset
     from the beginning of the section.  */
  elf_linker_section_pointers_t *linker_section_pointer;

a134 1
  asection *sbss;
a177 1
      ppc_elf_hash_entry (entry)->linker_section_pointer = NULL;
d192 1
a192 1
  ret = bfd_zmalloc (sizeof (struct ppc_elf_link_hash_table));
d203 15
a1478 15
  /* Phony reloc to handle branch stubs.  */
  HOWTO (R_PPC_RELAX32,         /* type */
	 0,                     /* rightshift */
	 0,                     /* size */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_RELAX32",      	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,	        	/* dst_mask */
	 FALSE),		/* pcrel_offset */

d1544 1
a1544 12
static bfd_reloc_status_type
ppc_elf_install_value (bfd *abfd,
		       bfd_byte *hit_addr,
		       bfd_vma v,
		       unsigned int r_type)
{
  bfd_vma t0, t1;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val = (BFD_HOST_U_64_BIT) v;
#else
  bfd_vma val = v;
#endif
d1546 19
a1564 15
  switch (r_type)
    {
    case R_PPC_RELAX32:
      /* Do stuff here.  */
      t0 = bfd_get_32 (abfd, hit_addr);
      t1 = bfd_get_32 (abfd, hit_addr + 4);

      /* We're clearing the bits for R_PPC_ADDR16_HA
	 and R_PPC_ADDR16_LO here.  */
      t0 &= ~0xffff;
      t1 &= ~0xffff;

      /* t0 is HA, t1 is lo */
      t0 |= ((val + 0x8000) >> 16) & 0xffff;
      t1 |= val & 0xffff;
d1566 1
a1566 3
      bfd_put_32 (abfd, t0, hit_addr);
      bfd_put_32 (abfd, t1, hit_addr + 4);
      break;
d1568 5
a1572 15
    case R_PPC_REL24:
      t0 = bfd_get_32 (abfd, hit_addr);
      t0 &= ~0x3fffffc;
      t0 |= val & 0x3fffffc;
      bfd_put_32 (abfd, t0, hit_addr);
      break;

    case R_PPC_REL14:
    case R_PPC_REL14_BRTAKEN:
    case R_PPC_REL14_BRNTAKEN:
      t0 = bfd_get_32 (abfd, hit_addr);
      t0 &= ~0xfffc;
      t0 |= val & 0xfffc;
      bfd_put_32 (abfd, t0, hit_addr);
      break;
d1574 2
a1575 13
    case R_PPC_LOCAL24PC:
    case R_PPC_PLTREL24:
      t0 = bfd_get_32 (abfd, hit_addr);
      t0 &= ~0x3fffffc;
      t0 |= val & 0x3fffffc;
      bfd_put_32 (abfd, t0, hit_addr);
      break;

    default:
      return bfd_reloc_notsupported;
    }

  return bfd_reloc_ok;
a1577 23
static const bfd_byte shared_stub_entry[] =
  {
    0x48, 0x00, 0x00, 0x24, /* b .+36 */
    0x7c, 0x08, 0x02, 0xa6, /* mflr 0 */
    0x42, 0x9f, 0x00, 0x05, /* bcl 20, 31, .Lxxx */
    0x7d, 0x68, 0x02, 0xa6, /* mflr 11 */
    0x3d, 0x60, 0x00, 0x00, /* addis 11, 11, (xxx-.Lxxx)@@ha */
    0x39, 0x6b, 0x00, 0x18, /* addi 11, 11, (xxx-.Lxxx)@@l */
    0x7c, 0x08, 0x03, 0xa6, /* mtlr 0 */
    0x7d, 0x69, 0x03, 0xa6, /* mtctr 11 */
    0x4e, 0x80, 0x04, 0x20, /* bctr */
  };

static const bfd_byte stub_entry[] =
  {
    0x48, 0x00, 0x00, 0x14, /* b .+20 */
    0x3d, 0x60, 0x00, 0x00, /* lis 11,xxx@@ha */
    0x39, 0x6b, 0x00, 0x00, /* addi 11,11,xxx@@l */
    0x7d, 0x69, 0x03, 0xa6, /* mtctr 11 */
    0x4e, 0x80, 0x04, 0x20, /* bctr */
  };


d1584 1
a1584 7
  struct one_fixup
  {
    struct one_fixup *next;
    asection *tsec;
    bfd_vma toff;
    bfd_vma trampoff;
  };
a1585 1
  Elf_Internal_Shdr *symtab_hdr;
d1587 1
a1587 1
  Elf_Internal_Sym *isymbuf = NULL;
d1589 3
a1591 5
  Elf_Internal_Rela *irel, *irelend;
  struct one_fixup *fixups = NULL;
  bfd_boolean changed_contents = FALSE;
  bfd_boolean changed_relocs = FALSE;
  struct ppc_elf_link_hash_table *ppc_info;
d1593 1
a1595 7
  /* Nothing to do if there are no relocations and no need for
     the relax finalize pass.  */
  if ((isec->flags & SEC_RELOC) == 0
      || isec->reloc_count == 0
      || link_info->relax_finalizing)
    return TRUE;

d1600 12
a1611 37
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Get a copy of the native relocations.  */
  internal_relocs = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL,
					       link_info->keep_memory);
  if (internal_relocs == NULL)
    goto error_return;

  ppc_info = ppc_elf_hash_table (link_info);
  irelend = internal_relocs + isec->reloc_count;

  /* Get the section contents.  */
  /* Get cached copy if it exists.  */
  if (elf_section_data (isec)->this_hdr.contents != NULL)
    contents = elf_section_data (isec)->this_hdr.contents;
  else
    {
      /* Go get them off disk.  */
      contents = bfd_malloc (isec->_raw_size);
      if (contents == NULL)
	goto error_return;

      if (!bfd_get_section_contents (abfd, isec, contents, 0, isec->_raw_size))
	goto error_return;
    }

  for (irel = internal_relocs; irel < irelend; irel++)
    {
      unsigned long r_type = ELF32_R_TYPE (irel->r_info);
      bfd_vma symaddr, reladdr, trampoff, toff, roff;
      asection *tsec;
      bfd_size_type amt;
      struct one_fixup *f;
      size_t insn_offset = 0;
      bfd_vma max_branch_offset;

      switch (r_type)
d1613 5
a1617 7
	case R_PPC_REL24:
	case R_PPC_LOCAL24PC:
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	case R_PPC_PLTREL24:
	  break;
d1619 30
a1648 3
	default:
	  continue;
	}
d1650 3
a1652 5
      /* Get the value of the symbol referred to by the reloc.  */
      if (ELF32_R_SYM (irel->r_info) < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;
d1654 21
a1674 10
	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == 0)
		goto error_return;
d1676 33
a1708 9
	  isym = isymbuf + ELF32_R_SYM (irel->r_info);
	  if (isym->st_shndx == SHN_UNDEF)
	    continue;	/* We can't do anthing with undefined symbols.  */
	  else if (isym->st_shndx == SHN_ABS)
	    tsec = bfd_abs_section_ptr;
	  else if (isym->st_shndx == SHN_COMMON)
	    tsec = bfd_com_section_ptr;
	  else
	    tsec = bfd_section_from_elf_index (abfd, isym->st_shndx);
d1710 8
a1717 7
	  toff = isym->st_value;
	}
      else
	{
	  /* Need dynamic symbol handling.  */
	  unsigned long indx;
	  struct elf_link_hash_entry *h;
d1719 13
a1731 2
	  indx = ELF32_R_SYM (irel->r_info) - symtab_hdr->sh_info;
	  h = elf_sym_hashes (abfd)[indx];
d1733 29
a1761 10
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  if (r_type == R_PPC_PLTREL24)
	    {
	      Elf_Internal_Sym *isym;

	      if (h->plt.offset == (bfd_vma) -1
		  || ppc_info->plt == NULL)
d1763 2
a1764 3

		  /* Read this BFD's local symbols.  */
		  if (isymbuf == NULL)
d1766 6
a1771 7
		      isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
		      if (isymbuf == NULL)
			isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
							symtab_hdr->sh_info, 0,
							NULL, NULL, NULL);
		      if (isymbuf == 0)
			goto error_return;
a1772 13
		  isym = isymbuf + ELF32_R_SYM (irel->r_info);

		  if (isym->st_shndx == SHN_UNDEF)
		    /* We can't do anthing with undefined symbols.  */
		    continue;
		  else if (isym->st_shndx == SHN_ABS)
		    tsec = bfd_abs_section_ptr;
		  else if (isym->st_shndx == SHN_COMMON)
		    tsec = bfd_com_section_ptr;
		  else
		    tsec = h->root.u.def.section;

		  toff = h->root.u.def.value;
d1774 4
a1777 1
	      else
d1779 2
a1780 2
		  tsec = ppc_info->plt;
		  toff = h->plt.offset;
a1782 93
	  else if (h->root.type == bfd_link_hash_undefined
		   || h->root.type == bfd_link_hash_undefweak)
	    continue;

	  else
	    {
	      tsec = h->root.u.def.section;
	      toff = h->root.u.def.value;
	    }
	}

      if (tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
	toff = _bfd_merged_section_offset (abfd, &tsec,
					   elf_section_data (tsec)->sec_info,
					   toff + irel->r_addend, 0);
      else
	toff += irel->r_addend;

      symaddr = tsec->output_section->vma + tsec->output_offset + toff;

      roff = irel->r_offset;

      reladdr = (isec->output_section->vma
		 + isec->output_offset
		 + roff) & (bfd_vma) -4;

      /* If the branch is in range, no need to do anything.  */
      max_branch_offset = 1 << 25;
      if (r_type != R_PPC_REL24
	  && r_type != R_PPC_LOCAL24PC
	  && r_type != R_PPC_PLTREL24)
	max_branch_offset = 1 << 15;

      if ((bfd_vma) (symaddr - reladdr) + max_branch_offset
	  <= 2 * max_branch_offset)
	continue;

      /* If the branch and target are in the same section, you have
	 no hope.  We'll error out later.  */
      if (tsec == isec)
	continue;

      /* Look for an existing fixup to this address.  */
      for (f = fixups; f ; f = f->next)
	if (f->tsec == tsec && f->toff == toff)
	  break;

      if (f == NULL)
	{
	  size_t size;

	  if (link_info->shared
	      || tsec == ppc_info->plt
	      || r_type == R_PPC_LOCAL24PC)
	    {
	      size = sizeof (shared_stub_entry);
	      insn_offset = 16;
	    }
	  else
	    {
	      size = sizeof (stub_entry);
	      insn_offset = 4;
	    }

	  /* Resize the current section to make room for the new branch.  */
	  trampoff = (isec->_cooked_size + 3) & (bfd_vma) - 4;
	  amt = trampoff + size;
	  contents = bfd_realloc (contents, amt);
	  if (contents == NULL)
	    abort ();

	  isec->_cooked_size = amt;

	  if (link_info->shared
	      || tsec == ppc_info->plt
	      || r_type == R_PPC_LOCAL24PC)
	    memcpy (contents + trampoff, shared_stub_entry, size);
	  else
	    memcpy (contents + trampoff, stub_entry, size);

	  /* Hijack the old relocation.  Since we need two
	     relocations for this use a "composite" reloc.  */
	  irel->r_info = ELF32_R_INFO (ELF32_R_SYM (irel->r_info),
				       R_PPC_RELAX32);
	  irel->r_offset = trampoff + insn_offset;

	  /* Record the fixup so we don't do it again this section.  */
	  f = bfd_malloc (sizeof (*f));
	  f->next = fixups;
	  f->tsec = tsec;
	  f->toff = toff;
	  f->trampoff = trampoff;
	  fixups = f;
d1784 1
a1784 1
      else
d1786 2
a1787 2
	  /* Nop out the reloc, since we're finalizing things here.  */
	  irel->r_info = ELF32_R_INFO (0, R_PPC_NONE);
a1788 10

      /* Fix up the existing branch to hit the trampoline.  Hope like
	 hell this doesn't overflow too.  */
      if (ppc_elf_install_value (abfd, contents + roff,
				 f->trampoff - (roff & (bfd_vma) -3) + 4,
				 r_type) != bfd_reloc_ok)
	abort ();

      changed_contents = TRUE;
      changed_relocs = TRUE;
d1791 1
a1791 2
  /* Clean up.  */
  while (fixups)
d1793 2
a1794 3
      struct one_fixup *f = fixups;
      fixups = fixups->next;
      free (f);
d1796 2
a1797 2
  if (isymbuf != NULL
      && symtab_hdr->contents != (unsigned char *) isymbuf)
d1799 2
a1800 7
      if (! link_info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
d1803 1
a1803 2
  if (contents != NULL
      && elf_section_data (isec)->this_hdr.contents != contents)
d1805 2
a1806 2
      if (!changed_contents && !link_info->keep_memory)
	free (contents);
d1812 1
a1814 9
  if (elf_section_data (isec)->relocs != internal_relocs)
    {
      if (!changed_relocs)
	free (internal_relocs);
      else
	elf_section_data (isec)->relocs = internal_relocs;
    }

  *again = changed_contents || changed_relocs;
d1818 6
a1823 8
  if (isymbuf != NULL && (unsigned char *) isymbuf != symtab_hdr->contents)
    free (isymbuf);
  if (contents != NULL
      && elf_section_data (isec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (isec)->relocs != internal_relocs)
    free (internal_relocs);
a2171 239
/* Find a linker generated pointer with a given addend and type.  */

static elf_linker_section_pointers_t *
elf_find_pointer_linker_section
  (elf_linker_section_pointers_t *linker_pointers,
   bfd_vma addend,
   elf_linker_section_t *lsect)
{
  for ( ; linker_pointers != NULL; linker_pointers = linker_pointers->next)
    if (lsect == linker_pointers->lsect && addend == linker_pointers->addend)
      return linker_pointers;

  return NULL;
}

/* Allocate a pointer to live in a linker created section.  */

static bfd_boolean
elf_create_pointer_linker_section (bfd *abfd,
				   struct bfd_link_info *info,
				   elf_linker_section_t *lsect,
				   struct elf_link_hash_entry *h,
				   const Elf_Internal_Rela *rel)
{
  elf_linker_section_pointers_t **ptr_linker_section_ptr = NULL;
  elf_linker_section_pointers_t *linker_section_ptr;
  unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
  bfd_size_type amt;

  BFD_ASSERT (lsect != NULL);

  /* Is this a global symbol?  */
  if (h != NULL)
    {
      struct ppc_elf_link_hash_entry *eh;

      /* Has this symbol already been allocated?  If so, our work is done.  */
      eh = (struct ppc_elf_link_hash_entry *) h;
      if (elf_find_pointer_linker_section (eh->linker_section_pointer,
					   rel->r_addend,
					   lsect))
	return TRUE;

      ptr_linker_section_ptr = &eh->linker_section_pointer;
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! _bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (lsect->rel_section)
	lsect->rel_section->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    {
      /* Allocation of a pointer to a local symbol.  */
      elf_linker_section_pointers_t **ptr = elf_local_ptr_offsets (abfd);

      /* Allocate a table to hold the local symbols if first time.  */
      if (!ptr)
	{
	  unsigned int num_symbols = elf_tdata (abfd)->symtab_hdr.sh_info;

	  amt = num_symbols;
	  amt *= sizeof (elf_linker_section_pointers_t *);
	  ptr = bfd_zalloc (abfd, amt);

	  if (!ptr)
	    return FALSE;

	  elf_local_ptr_offsets (abfd) = ptr;
	}

      /* Has this symbol already been allocated?  If so, our work is done.  */
      if (elf_find_pointer_linker_section (ptr[r_symndx],
					   rel->r_addend,
					   lsect))
	return TRUE;

      ptr_linker_section_ptr = &ptr[r_symndx];

      if (info->shared)
	{
	  /* If we are generating a shared object, we need to
	     output a R_<xxx>_RELATIVE reloc so that the
	     dynamic linker can adjust this GOT entry.  */
	  BFD_ASSERT (lsect->rel_section != NULL);
	  lsect->rel_section->_raw_size += sizeof (Elf32_External_Rela);
	}
    }

  /* Allocate space for a pointer in the linker section, and allocate
     a new pointer record from internal memory.  */
  BFD_ASSERT (ptr_linker_section_ptr != NULL);
  amt = sizeof (elf_linker_section_pointers_t);
  linker_section_ptr = bfd_alloc (abfd, amt);

  if (!linker_section_ptr)
    return FALSE;

  linker_section_ptr->next = *ptr_linker_section_ptr;
  linker_section_ptr->addend = rel->r_addend;
  linker_section_ptr->lsect = lsect;
  linker_section_ptr->written_address_p = FALSE;
  *ptr_linker_section_ptr = linker_section_ptr;

  linker_section_ptr->offset = lsect->section->_raw_size;
  lsect->section->_raw_size += 4;

#ifdef DEBUG
  fprintf (stderr,
	   "Create pointer in linker section %s, offset = %ld, section size = %ld\n",
	   lsect->name, (long) linker_section_ptr->offset,
	   (long) lsect->section->_raw_size);
#endif

  return TRUE;
}

#define bfd_put_ptr(BFD, VAL, ADDR) bfd_put_32 (BFD, VAL, ADDR)

/* Fill in the address for a pointer generated in a linker section.  */

static bfd_vma
elf_finish_pointer_linker_section (bfd *output_bfd,
				   bfd *input_bfd,
				   struct bfd_link_info *info,
				   elf_linker_section_t *lsect,
				   struct elf_link_hash_entry *h,
				   bfd_vma relocation,
				   const Elf_Internal_Rela *rel,
				   int relative_reloc)
{
  elf_linker_section_pointers_t *linker_section_ptr;

  BFD_ASSERT (lsect != NULL);

  if (h != NULL)
    {
      /* Handle global symbol.  */
      struct ppc_elf_link_hash_entry *eh;

      eh = (struct ppc_elf_link_hash_entry *) h;
      linker_section_ptr
	= elf_find_pointer_linker_section (eh->linker_section_pointer,
					   rel->r_addend,
					   lsect);

      BFD_ASSERT (linker_section_ptr != NULL);

      if (! elf_hash_table (info)->dynamic_sections_created
	  || (info->shared
	      && info->symbolic
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	{
	  /* This is actually a static link, or it is a
	     -Bsymbolic link and the symbol is defined
	     locally.  We must initialize this entry in the
	     global section.

	     When doing a dynamic link, we create a .rela.<xxx>
	     relocation entry to initialize the value.  This
	     is done in the finish_dynamic_symbol routine.  */
	  if (!linker_section_ptr->written_address_p)
	    {
	      linker_section_ptr->written_address_p = TRUE;
	      bfd_put_ptr (output_bfd,
			   relocation + linker_section_ptr->addend,
			   (lsect->section->contents
			    + linker_section_ptr->offset));
	    }
	}
    }
  else
    {
      /* Handle local symbol.  */
      unsigned long r_symndx = ELF32_R_SYM (rel->r_info);
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd) != NULL);
      BFD_ASSERT (elf_local_ptr_offsets (input_bfd)[r_symndx] != NULL);
      linker_section_ptr = (elf_find_pointer_linker_section
			    (elf_local_ptr_offsets (input_bfd)[r_symndx],
			     rel->r_addend,
			     lsect));

      BFD_ASSERT (linker_section_ptr != NULL);

      /* Write out pointer if it hasn't been rewritten out before.  */
      if (!linker_section_ptr->written_address_p)
	{
	  linker_section_ptr->written_address_p = TRUE;
	  bfd_put_ptr (output_bfd, relocation + linker_section_ptr->addend,
		       lsect->section->contents + linker_section_ptr->offset);

	  if (info->shared)
	    {
	      /* We need to generate a relative reloc for the dynamic
		 linker.  */

	      asection *srel = lsect->rel_section;
	      Elf_Internal_Rela outrel[MAX_INT_RELS_PER_EXT_REL];
	      bfd_byte *erel;
	      struct elf_backend_data *bed = get_elf_backend_data (output_bfd);
	      unsigned int i;

	      BFD_ASSERT (srel != NULL);

	      for (i = 0; i < bed->s->int_rels_per_ext_rel; i++)
		{
		  outrel[i].r_offset = (lsect->section->output_section->vma
					+ lsect->section->output_offset
					+ linker_section_ptr->offset);
		  outrel[i].r_info = 0;
		  outrel[i].r_addend = 0;
		}
	      outrel[0].r_info = ELF32_R_INFO (0, relative_reloc);
	      erel = lsect->section->contents;
	      erel += (elf_section_data (lsect->section)->rel_count++
		       * sizeof (Elf32_External_Rela));
	      bfd_elf32_swap_reloca_out (output_bfd, outrel, erel);
	    }
	}
    }

  relocation = (lsect->section->output_offset
		+ linker_section_ptr->offset
		- lsect->sym_offset);

#ifdef DEBUG
  fprintf (stderr,
	   "Finish pointer in linker section %s, offset = %ld (0x%lx)\n",
	   lsect->name, (long) relocation, (long) relocation);
#endif

  /* Subtract out the addend, because it will get added back in by the normal
     processing.  */
  return relocation - linker_section_ptr->addend;
}

d2178 1
a2179 25
  struct ppc_elf_link_hash_table *htab = ppc_elf_hash_table (info);
  asection *s;
  bfd_size_type amt;
  flagword flags;
  const char *name;
  const char *rel_name;
  const char *sym_name;
  bfd_vma sym_offset;

  /* Both of these sections are (technically) created by the user
     putting data in them, so they shouldn't be marked
     SEC_LINKER_CREATED.

     The linker creates them so it has somewhere to attach their
     respective symbols. In fact, if they were empty it would
     be OK to leave the symbol set to 0 (or any random number), because
     the appropriate register should never be used.  */
  flags = SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY;
  sym_offset = 32768;

  switch (which)
    {
    default:
      abort ();
      return NULL;
d2181 26
a2206 5
    case LINKER_SECTION_SDATA:	/* .sdata/.sbss section */
      name	= ".sdata";
      rel_name	= ".rela.sdata";
      sym_name	= "_SDA_BASE_";
      break;
d2208 6
a2213 7
    case LINKER_SECTION_SDATA2:	/* .sdata2/.sbss2 section */
      name	= ".sdata2";
      rel_name	= ".rela.sdata2";
      sym_name	= "_SDA2_BASE_";
      flags    |= SEC_READONLY;
      break;
    }
d2215 2
a2216 3
  /* Record the first bfd that needs the special sections.  */
  if (!htab->elf.dynobj)
    htab->elf.dynobj = abfd;
d2218 7
a2224 2
  amt = sizeof (elf_linker_section_t);
  lsect = bfd_zalloc (htab->elf.dynobj, amt);
d2226 9
a2234 44
  lsect->sym_offset = sym_offset;

  /* See if the sections already exist.  */
  s = bfd_get_section_by_name (htab->elf.dynobj, name);
  if (s == NULL || (s->flags & flags) != flags)
    {
      s = bfd_make_section_anyway (htab->elf.dynobj, name);
      if (s == NULL
	  || !bfd_set_section_flags (htab->elf.dynobj, s, flags))
	return NULL;
    }
  lsect->section = s;

  if (bfd_get_section_alignment (htab->elf.dynobj, s) < 2
      && !bfd_set_section_alignment (htab->elf.dynobj, s, 2))
    return NULL;

  s->_raw_size = align_power (s->_raw_size, 2);

#ifdef DEBUG
  fprintf (stderr, "Creating section %s, current size = %ld\n",
	   name, (long) s->_raw_size);
#endif

  if (sym_name)
    {
      struct elf_link_hash_entry *h;
      struct bfd_link_hash_entry *bh;

#ifdef DEBUG
      fprintf (stderr, "Adding %s to section %s\n", sym_name, name);
#endif
      bh = bfd_link_hash_lookup (info->hash, sym_name,
				 FALSE, FALSE, FALSE);

      if ((bh == NULL || bh->type == bfd_link_hash_undefined)
	  && !(_bfd_generic_link_add_one_symbol
	       (info, abfd, sym_name, BSF_GLOBAL, s, sym_offset, NULL,
		FALSE, get_elf_backend_data (abfd)->collect, &bh)))
	return NULL;
      h = (struct elf_link_hash_entry *) bh;

      h->type = STT_OBJECT;
      lsect->sym_hash = h;
d2236 1
a2236 15
      if (info->shared
	  && ! _bfd_elf_link_record_dynamic_symbol (info, h))
	return NULL;
    }

  if (info->shared)
    {
      s = bfd_make_section_anyway (htab->elf.dynobj, rel_name);
      lsect->rel_section = s;
      flags = (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	       | SEC_LINKER_CREATED | SEC_READONLY);
      if (s == NULL
	  || ! bfd_set_section_flags (htab->elf.dynobj, s, flags)
	  || ! bfd_set_section_alignment (htab->elf.dynobj, s, 2))
	return NULL;
d2321 1
a2321 4
  htab = ppc_elf_hash_table (info);

  if (htab->got == NULL
      && !ppc_elf_create_got (abfd, info))
d2330 1
d3106 4
a3109 2
      htab->sdata = ppc_elf_create_linker_section (abfd, info,
						   LINKER_SECTION_SDATA);
d3116 4
a3119 2
      htab->sdata2 = ppc_elf_create_linker_section (abfd, info,
						    LINKER_SECTION_SDATA2);
d3223 2
a3224 2
	  if (!elf_create_pointer_linker_section (abfd, info,
						  htab->sdata, h, rel))
d3235 2
a3236 2
	  if (!elf_create_pointer_linker_section (abfd, info,
						  htab->sdata2, h, rel))
d3919 1
a3919 2
      && (info->hash->creator == abfd->xvec
	  || info->hash->creator == abfd->xvec->alternative_target))
d3922 25
a3946 11
	 put into .sbss.  */
      struct ppc_elf_link_hash_table *htab;

      htab = ppc_elf_hash_table (info);
      if (htab->sbss == NULL)
	{
	  flagword flags = SEC_IS_COMMON;

	  htab->sbss = bfd_make_section_anyway (abfd, ".sbss");
	  if (htab->sbss == NULL
	      || ! bfd_set_section_flags (abfd, htab->sbss, flags))
d3948 4
d3954 1
a3954 1
      *secp = htab->sbss;
d4275 1
a4275 1
	  else if (!info->executable
d4851 3
a4853 2
	  if (SYMBOL_REFERENCES_LOCAL (info, h)
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d4883 2
a4884 1
		   || !SYMBOL_CALLS_LOCAL (info, h)))
d4939 2
a4940 1
	      else if (!SYMBOL_REFERENCES_LOCAL (info, h))
a5006 73
	case R_PPC_RELAX32:
	  {
	    unsigned long r_symndx;
	    Elf_Internal_Sym *sym;
	    asection *sym_sec;
	    bfd_byte *hit_addr = 0;
	    bfd_vma value = 0;

	    r_symndx = ELF32_R_SYM (rel->r_info);

	    if (r_symndx < symtab_hdr->sh_info)
	      {
		sym = local_syms + r_symndx;
		sym_sec = local_sections[r_symndx];

		value = _bfd_elf_rela_local_sym (output_bfd, sym, sym_sec, rel);
	      }
	    else
	      {
		long indx;

		indx = r_symndx - symtab_hdr->sh_info;
		h = elf_sym_hashes (input_bfd)[indx];
		while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
		  h = (struct elf_link_hash_entry *) h->root.u.i.link;

		value = 0;
		if (h->root.type == bfd_link_hash_defined
		    || h->root.type == bfd_link_hash_defweak)
		  {
		    sym_sec = h->root.u.def.section;

		    /* Detect the cases that sym_sec->output_section is
		       expected to be NULL -- all cases in which the symbol
		       is defined in another shared module.  This includes
		       PLT relocs for which we've created a PLT entry and
		       other relocs for which we're prepared to create
		       dynamic relocations.  */
		    /* ??? Just accept it NULL and continue.  */

		    if (sym_sec->output_section != NULL)
		      {
			value = (h->root.u.def.value
				 + sym_sec->output_section->vma
				 + sym_sec->output_offset);
		      }
		  }
		else if (info->shared
			 && !info->no_undefined
			 && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
		  ;
		else
		  {
		    if (! ((*info->callbacks->undefined_symbol)
			   (info, h->root.root.string, input_bfd,
			    input_section, rel->r_offset,
			    (!info->shared || info->no_undefined
			     || ELF_ST_VISIBILITY (h->other)))))
		      return FALSE;
		    continue;
		  }
	      }
	    hit_addr = contents + rel->r_offset;
	    value += rel->r_addend;

	    r = ppc_elf_install_value (output_bfd, hit_addr, value, r_type);
	    if (r != bfd_reloc_ok)
	      break;
	    else
	      continue;
	  }

d5011 4
a5014 3
	    = elf_finish_pointer_linker_section (output_bfd, input_bfd, info,
						 htab->sdata, h, relocation,
						 rel, R_PPC_RELATIVE);
d5021 4
a5024 3
	    = elf_finish_pointer_linker_section (output_bfd, input_bfd, info,
						 htab->sdata2, h, relocation,
						 rel, R_PPC_RELATIVE);
a5696 29

/* Add extra PPC sections -- Note, for now, make .sbss2 and
   .PPC.EMB.sbss0 a normal section, and not a bss section so
   that the linker doesn't crater when trying to make more than
   2 sections.  */

static struct bfd_elf_special_section const ppc_elf_special_sections[]=
{
  { ".tags",		0,	NULL,	0,
    SHT_ORDERED,	SHF_ALLOC },
  { ".sdata",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC + SHF_WRITE },
  { ".sbss",		0,	NULL,	0,
    SHT_NOBITS,		SHF_ALLOC + SHF_WRITE },
  { ".sdata2",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".sbss2",		0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".PPC.EMB.apuinfo",	0,	NULL,	0,
    SHT_NOTE,		0 },
  { ".PPC.EMB.sdata0",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".PPC.EMB.sbss0",	0,	NULL,	0,
    SHT_PROGBITS,	SHF_ALLOC },
  { ".plt",		0,	NULL,	0,
    SHT_NOBITS,		0 },
  { NULL,		0,	NULL,	0,
    0,			0 }
};
a5703 3
#ifdef __QNXTARGET__
#define ELF_MAXPAGESIZE		0x1000
#else
a5704 1
#endif
a5722 1
#define bfd_elf32_mkobject			ppc_elf_mkobject
a5750 1
#define elf_backend_special_sections		ppc_elf_special_sections
@


1.51.2.12
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d288 1
a288 1
ppc_elf_copy_indirect_symbol (const struct elf_backend_data *bed,
d2584 1
a2584 1
	      const struct elf_backend_data *bed;
a2588 1
	      bed = get_elf_backend_data (output_bfd);
a4719 1

d4730 4
a4733 5
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
	  
d4735 33
d5502 1
a5502 2
		bfd_boolean warned;
		bfd_boolean unresolved_reloc;
d5504 41
a5544 7
		RELOC_FOR_GLOBAL_SYMBOL (h, elf_sym_hashes (input_bfd),
					 r_symndx, symtab_hdr,
					 value, sym_sec,
					 unresolved_reloc, info,
					 warned);
		if (warned)
		  continue;
@


1.51.2.13
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d208 3
d1537 4
a1540 18
  /* Phony relocs to handle branch stubs.  */
  HOWTO (R_PPC_RELAX32,		/* type */
	 0,			/* rightshift */
	 0,			/* size */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc,	/* special_function */
	 "R_PPC_RELAX32",	/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO (R_PPC_RELAX32PC,	/* type */
	 0,			/* rightshift */
	 0,			/* size */
d1546 1
a1546 1
	 "R_PPC_RELAX32PC",	/* name */
d1549 1
a1549 1
	 0,			/* dst_mask */
d1617 60
a1676 1
#define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))
d1678 4
a1681 1
static const int shared_stub_entry[] =
d1683 9
a1691 8
    0x7c0802a6, /* mflr 0 */
    0x429f0005, /* bcl 20, 31, .Lxxx */
    0x7d6802a6, /* mflr 11 */
    0x3d6b0000, /* addis 11, 11, (xxx-.Lxxx)@@ha */
    0x396b0018, /* addi 11, 11, (xxx-.Lxxx)@@l */
    0x7c0803a6, /* mtlr 0 */
    0x7d6903a6, /* mtctr 11 */
    0x4e800420, /* bctr */
d1694 1
a1694 1
static const int stub_entry[] =
d1696 5
a1700 4
    0x3d600000, /* lis 11,xxx@@ha */
    0x396b0000, /* addi 11,11,xxx@@l */
    0x7d6903a6, /* mtctr 11 */
    0x4e800420, /* bctr */
d1724 2
a1725 1
  bfd_boolean changed;
a1726 1
  bfd_size_type trampoff;
a1740 4
  trampoff = (isec->_cooked_size + 3) & (bfd_vma) -4;
  /* Space for a branch around any trampolines.  */
  trampoff += 4;

d1770 1
a1770 1
      bfd_vma symaddr, reladdr, toff, roff;
d1772 1
d1775 1
a1775 3
      bfd_vma max_branch_offset, val;
      bfd_byte *hit_addr;
      unsigned long t0;
a1780 4
	case R_PPC_PLTREL24:
	  max_branch_offset = 1 << 25;
	  break;

d1784 1
a1784 1
	  max_branch_offset = 1 << 15;
d1822 1
a1822 1
	  /* Global symbol handling.  */
d1833 1
a1833 3
	  if (r_type == R_PPC_PLTREL24
	      && ppc_info->plt != NULL
	      && h->plt.offset != (bfd_vma) -1)
d1835 36
a1870 2
	      tsec = ppc_info->plt;
	      toff = h->plt.offset;
d1872 5
a1876 2
	  else if (h->root.type == bfd_link_hash_defined
		   || h->root.type == bfd_link_hash_defweak)
a1880 2
	  else
	    continue;
a1882 7
      /* If the branch and target are in the same section, you have
	 no hope of adding stubs.  We'll error out later should the
	 branch overflow.  */
      if (tsec == isec)
	continue;

      toff += irel->r_addend;
d1886 3
a1888 1
					   toff, 0);
d1896 1
a1896 1
		 + roff);
d1899 13
a1911 1
      if (symaddr - reladdr + max_branch_offset < 2 * max_branch_offset)
a1921 7
	  unsigned long stub_rtype;

	  val = trampoff - roff;
	  if (val >= max_branch_offset)
	    /* Oh dear, we can't reach a trampoline.  Don't try to add
	       one.  We'll report an error later.  */
	    continue;
d1923 3
a1925 1
	  if (link_info->shared)
d1927 2
a1928 3
	      size = 4 * ARRAY_SIZE (shared_stub_entry);
	      insn_offset = 12;
	      stub_rtype = R_PPC_RELAX32PC;
d1932 2
a1933 3
	      size = 4 * ARRAY_SIZE (stub_entry);
	      insn_offset = 0;
	      stub_rtype = R_PPC_RELAX32;
d1936 16
d1955 1
a1955 1
				       stub_rtype);
a1964 2

	  trampoff += size;
a1967 4
	  val = f->trampoff - roff;
	  if (val >= max_branch_offset)
	    continue;

d1972 6
a1977 12
      /* Fix up the existing branch to hit the trampoline.  */
      hit_addr = contents + roff;
      switch (r_type)
	{
	case R_PPC_REL24:
	case R_PPC_LOCAL24PC:
	case R_PPC_PLTREL24:
	  t0 = bfd_get_32 (abfd, hit_addr);
	  t0 &= ~0x3fffffc;
	  t0 |= val & 0x3fffffc;
	  bfd_put_32 (abfd, t0, hit_addr);
	  break;
d1979 2
a1980 9
	case R_PPC_REL14:
	case R_PPC_REL14_BRTAKEN:
	case R_PPC_REL14_BRNTAKEN:
	  t0 = bfd_get_32 (abfd, hit_addr);
	  t0 &= ~0xfffc;
	  t0 |= val & 0xfffc;
	  bfd_put_32 (abfd, t0, hit_addr);
	  break;
	}
d1983 2
a1984 3
  /* Write out the trampolines.  */
  changed = fixups != NULL;
  if (fixups != NULL)
d1986 3
a1988 46
      const int *stub;
      bfd_byte *dest;
      bfd_vma val;
      int i, size;

      do
	{
	  struct one_fixup *f = fixups;
	  fixups = fixups->next;
	  free (f);
	}
      while (fixups);

      contents = bfd_realloc (contents, trampoff);
      if (contents == NULL)
	goto error_return;

      isec->_cooked_size = (isec->_cooked_size + 3) & (bfd_vma) -4;
      /* Branch around the trampolines.  */
      val = trampoff - isec->_cooked_size + 0x48000000;
      dest = contents + isec->_cooked_size;
      isec->_cooked_size = trampoff;
      bfd_put_32 (abfd, val, dest);
      dest += 4;

      if (link_info->shared)
	{
	  stub = shared_stub_entry;
	  size = ARRAY_SIZE (shared_stub_entry);
	}
      else
	{
	  stub = stub_entry;
	  size = ARRAY_SIZE (stub_entry);
	}

      i = 0;
      while (dest < contents + trampoff)
	{
	  bfd_put_32 (abfd, stub[i], dest);
	  i++;
	  if (i == size)
	    i = 0;
	  dest += 4;
	}
      BFD_ASSERT (i == 0);
a1989 1

d2005 1
a2005 1
      if (!changed && !link_info->keep_memory)
d2016 1
a2016 1
      if (!changed)
d2022 1
a2022 1
  *again = changed;
d4187 1
a4187 1
/* Set htab->tls_get_addr and call the generic ELF tls_setup function.  */
d4189 1
a4189 1
asection *
d4192 1
d4199 7
a4205 1
  return _bfd_elf_tls_setup (obfd, info);
d4728 1
a4728 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d4736 1
a4736 1

d4920 2
a4921 2
			  rel->r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
			  rel[1].r_addend = htab->elf.tls_sec->vma + DTP_OFFSET;
d5159 1
a5159 1
			      outrel.r_addend -= htab->elf.tls_sec->vma;
d5177 1
a5177 1
			    value -= htab->elf.tls_sec->vma + DTP_OFFSET;
d5265 1
a5265 1
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
d5274 1
a5274 1
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
d5281 1
a5281 1
	  addend -= htab->elf.tls_sec->vma + TP_OFFSET;
d5285 1
a5285 1
	  addend -= htab->elf.tls_sec->vma + DTP_OFFSET;
a5452 5
	case R_PPC_RELAX32PC:
	  relocation -= (input_section->output_section->vma
			 + input_section->output_offset
			 + rel->r_offset - 4);
	  /* Fall thru */
d5455 7
a5461 2
	    unsigned long t0;
	    unsigned long t1;
d5463 4
a5466 2
	    t0 = bfd_get_32 (output_bfd, contents + rel->r_offset);
	    t1 = bfd_get_32 (output_bfd, contents + rel->r_offset + 4);
d5468 6
a5473 9
	    /* We're clearing the bits for R_PPC_ADDR16_HA
	       and R_PPC_ADDR16_LO here.  */
	    t0 &= ~0xffff;
	    t1 &= ~0xffff;

	    /* t0 is HA, t1 is LO */
	    relocation += addend;
	    t0 |= ((relocation + 0x8000) >> 16) & 0xffff;
	    t1 |= relocation & 0xffff;
d5475 16
a5490 2
	    bfd_put_32 (output_bfd, t0, contents + rel->r_offset);
	    bfd_put_32 (output_bfd, t1, contents + rel->r_offset + 4);
a5491 1
	  continue;
d6189 20
a6208 10
  { ".tags",             5,  0, SHT_ORDERED,  SHF_ALLOC },
  { ".sdata",            6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE },
  { ".sbss",             5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE },
  { ".sdata2",           7, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".sbss2",            6, -2, SHT_PROGBITS, SHF_ALLOC },
  { ".PPC.EMB.apuinfo", 16,  0, SHT_NOTE,     0 },
  { ".PPC.EMB.sdata0",  15,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".PPC.EMB.sbss0",   14,  0, SHT_PROGBITS, SHF_ALLOC },
  { ".plt",              4,  0, SHT_NOBITS,   SHF_ALLOC + SHF_EXECINSTR },
  { NULL,                0,  0, 0,            0 }
d6237 1
@


1.51.2.14
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d339 1
a339 2
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d1677 5
a1681 2
  /* Nothing to do if there are no relocations.  */
  if ((isec->flags & SEC_RELOC) == 0 || isec->reloc_count == 0)
d1766 1
a1766 1
	    continue;	/* We can't do anything with undefined symbols.  */
d2741 1
a2741 2
ppc_elf_modify_segment_map (bfd *abfd ATTRIBUTE_UNUSED,
			    struct bfd_link_info *info ATTRIBUTE_UNUSED)
d4920 1
a4920 1
	  /* Branch not taken prediction relocations.  */
@


1.50
log
@Add QNX Neutrino PowerPC support and common up QNX functions
@
text
@a2745 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
d2750 1
d3290 1
a3290 6
	      /* This reloc will be computed at runtime, so there's no
                 need to do anything now, unless this is a RELATIVE
                 reloc in an unallocated section.  */
	      if (skip != -1
		  || (input_section->flags & SEC_ALLOC) != 0
		  || ELF32_R_TYPE (outrel.r_info) != R_PPC_RELATIVE)
d3292 11
a3398 1
		  bfd_put_32 (output_bfd, relocation, sgot->contents + off);
d3420 1
d3423 1
@


1.49
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d3839 1
d3841 2
@


1.48
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d34 1
a34 1
#define USE_RELA		/* we want RELA relocations, not REL */
@


1.48.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Zero relocs
	for discarded FDEs.  Remove redundant assignment.
	* elflink.h (elf_bfd_discard_info): Save edited relocs.

	2002-09-23  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (decode_line_info): Update to correctly decode
	the (non-standard DWARF2) out-of-order address sequences
	generated by the Intel C++ 6.0 compiler for ia64-Linux.

	2002-09-22  H.J. Lu <hjl@@gnu.org>
	* elf64-alpha.c (elf64_alpha_merge_ind_symbols): Don't merge
	the relocation count between different .reloc sections.

	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* config.bfd: For DJGPP targets, match with any cpu and any machine.

	2002-09-21  Alan Modra  <amodra@@bigpond.net.au>
	* elfcode.h (elf_slurp_reloc_table_from_section): Make "symcount"
	unsigned.  Move "symcount" assignment out of loop.

	2002-09-19  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): If address length is
	zero, set it to 8 for (non-standard) 64-bit DWARF2 formats
	(e.g. IRIX64).

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* reloc.c (BFD_RELOC_386_TLS_TPOFF, BFD_RELOC_386_TLS_IE,
	BFD_RELOC_386_TLS_GOTIE): Add.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf32-i386.c (elf_howto_table): Add R_386_TLS_TPOFF, R_386_TLS_IE
	and R_386_TLS_GOTIE.
	(elf_i386_reloc_type_lookup): Handle it.
	(struct elf_i386_link_hash_entry): Change tls_type type to unsigned
	char instead of enum, change GOT_* into defines.
	(GOT_TLS_IE_POS, GOT_TLS_IE_NEG, GOT_TLS_IE_BOTH): Define.
	(elf_i386_tls_transition): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	(elf_i386_check_relocs): Likewise.  Avoid crash if local symbol is
	accessed both as normal and TLS symbol.  Move R_386_TLS_LDM and
	R_386_PLT32 cases so that R_386_TLS_IE can fall through.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_gc_sweep_hook): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(allocate_dynrelocs): Allocate 2 .got and 2 .rel.got entries if
	tls_type is GOT_TLS_IE_BOTH.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Handle R_386_TLS_IE and R_386_TLS_GOTIE.
	Handle R_386_TLS_LE_32 and R_386_TLS_LE in shared libs.
	(elf_i386_finish_dynamic_symbol): Use tls_type & GOT_TLS_IE to catch
	all 4 GOT_TLS_* TLS types.

	2002-09-18  Daniel Jacobowitz  <drow@@mvista.com>
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	correct relocation count.

	2002-09-17  Daniel Jacobowitz  <drow@@mvista.com>
	* bfd-in.h (bfd_get_dynamic_symcount): Define.
	* bfd.c (struct _bfd): Add dynsymcount.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_canonicalize_dynamic_symtab): Set
	abfd->dynsymcount.
	* elfcode.h (elf_slurp_reloc_table_from_section): Check
	for overflow.

	2002-09-17  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-alpha.c (alpha_elf_size_info): Make static.

	2002-09-17  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Clear .got word
	even if generating R_PPC_RELATIVE reloc.
	(ppc_elf_relocate_section): Make sure relocation is performed if
	skip == -2.  Clear memory at r_offset when creating dynamic
	relocation.

	2002-09-16  David O'Brien  <obrien@@FreeBSD.org>
	* elf32-i386-fbsd.c: Always label using the EI_OSABI method.
	It is benign for FreeBSD < 4.1.  Minor reformatting.
	* elf64-alpha-fbsd.c: Likewise.

	2002-09-16  Nathan Tallent  <eraxxon@@alumni.rice.edu>
	* ecoff.c (_bfd_ecoff_slurp_symbolic_info) <ioptMax>: Fix error
	reading ECOFF information: 'ioptMax' refers to the actual *size*
	of the optimization symtab, not the number of entries.

	2002-09-16  Jakub Jelinek  <jakub@@redhat.com>
	* elf_i386_relocate_section (R_386_TLS_TPOFF32): Negate addend.

	2002-09-13  Daniel Jacobowitz  <drow@@mvista.com>
	* elf32-arm.h (elf32_arm_adjust_dynamic_symbol): Update
	ELF_LINK_HASH_NEEDS_PLT logic.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/da.po: New Danish translation file.
	* configure.in (LINGUAS): Add 'da'.
	* configure: Regenerate.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (dtpoff_base, tpoff): Don't crash if tls_segment is
	NULL.
	(elf_i386_relocate_section): Return false after printing error about
	unresolvable relocation.

	2002-09-11  Jeffrey Law  <law@@redhat.com>
	* elf32-h8300.c (elf32_h8_relax_section): Fix typo.

	2002-09-06  Andrew Haley  <aph@@cambridge.redhat.com>
	* elf.c (_bfd_elf_find_nearest_line): Check functionname_ptr and
	line_ptr before deciding we've found a symbol.

	2002-08-29  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* bfd-in.h (align_power): Cast constants to bfd_vma type.
	* bfd-in2.h (align_power): Likewise.

	2002-08-24  Kaz Kojima  <kkojima@@rr.iij4u.or.jp>
	* elf32-sh.c (sh_elf_copy_indirect_symbol): New.
	(create_got_section, allocate_dynrelocs, readonly_dynrelocs):
	Likewise.
	(struct elf_sh_pcrel_relocs_copied): Removed.
	(struct elf_sh_dyn_relocs): New.
	(struct elf_sh_link_hash_entry): Replace pcrel_relocs_copied
	field with dyn_relocs.
	(struct elf_sh_link_hash_table): Add short-cuts to get dynamic
	sections and sym_sec.
	(sh_elf_link_hash_newfunc): Clear dyn_relocs.
	(sh_elf_link_hash_table_create): Clear shorts-cuts and sym_sec.
	(sh_elf_create_dynamic_sections): Use create_got_section instead
	of _bfd_elf_create_got_section.
	(sh_elf_check_relocs): Likewise.
	(sh_elf_create_dynamic_sections): Use short-cuts to the dynamic
	sections.
	(sh_elf_adjust_dynamic_symbol, sh_elf_size_dynamic_sections,
	sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_finish_dynamic_symbol, sh_elf_finish_dynamic_sections):
	Likewise.
	(sh_elf_adjust_dynamic_symbol): Handle nocopyreloc. Keep the
	dynamic relocations and avoiding the copy relocation when we
	didn't find any dynamic relocations in the section which has
	contents or is read-only.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(sh_elf_size_dynamic_sections): Don't reset the size of
	.rela.got section even if dynamic_sections_created flag is off.
	Don't use sh_elf_discard_copies. Scan all input bfd and use
	allocate_dynrelocs. Call readonly_dynrelocs to determine
	whether we need DT_TEXTREL.
	(sh_elf_adjust_dynamic_symbol): Use plt.refcount to determine
	whether the symbol was never referred to.
	(sh_elf_relocate_section): Use WILL_CALL_FINISH_DYNAMIC_SYMBOL.
	(sh_elf_gc_sweep_hook): Fill with the real sweep function.
	(sh_elf_check_relocs): Call create_got_section if the short-cut
	to .got is null. Increment reference counters only instead of
	allocating space on dynamic sections here. Don't conditionalize
	uninitialized got.offset value when marking the symbol as a
	global offset table entry. Keep relocations for symbols satisfied
	by a dynamic library to avoid copy relocations for the symbol.
	Set dynobj field of an elf hash table if needed.
	(sh_elf_finish_dynamic_sections): Handle null section pointer
	correctly.
	(elf_backend_copy_indirect_symbol): Defined.
	(elf_backend_can_refcount): Defined.

	2002-08-22  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-21  Stephen Clarke <stephen.clarke@@superh.com>
	* bfd/elf32-sh.c (sh_elf_size_dynamic_sections): Zero
	initialize dynamic section.
	* bfd/elf64-sh64.c (sh64_elf64_size_dynamic_sections):
	Likewise.

	2002-08-13  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections): Don't count
	definitions in shared objects when checking symbol with
	undefined version.

	2002-08-10  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Preserve section across
	elf_merge_symbol.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-08-08  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h (elf_link_output_extsym): Don't output symbols from
	SEC_EXCLUDE sections.

	* aoutx.h (aout_link_write_symbols): Correct handling of warning syms.

	2002-08-08  H.J. Lu <hjl@@gnu.org>
	* elflink.h (elf_add_default_symbol): Don't warn a defintion
	overrides an indirect versioned symbol.

	2002-08-07  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (edit_opd): Arrange to drop symbols for discarded .opd
	entries.

	2002-08-07  Jakub Jelinek  <jakub@@redhat.com>
	* elf32-i386.c (elf_i386_relocate_section): Fill in proper addend
	for R_386_TLS_TPOFF32 relocs against symndx 0.

	2002-08-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* elfxx-mips.c (mips_elf_global_got_index): Avoid segfault if
	g->global_gotsym is NULL.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* xcofflink.c (xcoff_write_global_symbol): Set n_scnum for abs_section.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* elf64-ppc.c (ppc64_elf_howto_raw): Zero all src_mask entries.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Check symbol
	with undefined version if needed.
	(elf_link_assign_sym_version): Match a default symbol with a
	version without definition. No need to hide the default
	definition separately.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: Formatting fixes.
	(xcoff_calculate_relocation): Use PARAMS in declaration.
	(xcoff_complain_overflow): Likewise.
	(xcoff_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff_vec): Likewise.
	(bfd_pmac_xcoff_backend_data): Likewise.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c: Formatting fixes.
	(xcoff64_calculate_relocation): Use PARAMS in declaration.
	(xcoff64_ppc_relocate_section): Use old-style function pointer call.
	(bfd_xcoff_backend_data): Remove useless comments.
	(rs6000coff64_vec): Likewise.
	(bfd_xcoff_aix5_backend_data): Likewise.
	(aix5coff64_vec): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c: (xcoff_rtype2howto): Don't place reloc address in
	addend.
	* coff64-rs6000.c: (xcoff64_rtype2howto): Likewise.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* coff-rs6000.c (xcoff_howto_table): Revert some of last change to
	mask entries.  Use complain_overflow_dont for R_REF.
	(xcoff_reloc_type_ba): Revert last change.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Likewise.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Likewise.
	(xcoff64_ppc_relocate_section): Likewise.
	(xcoff64_howto_table): Revert some of last change to mask entries.
	Use complain_overflow_dont for R_REF.

	* coff-rs6000.c (xcoff_howto_table): Fix src_mask entries.  Make all
	relocs with bitsize == 16 have size = 1.
	(xcoff_reloc_type_ba): Correct src_mask and dst_mask adjustment.
	(xcoff_reloc_type_br): Likewise.
	(xcoff_reloc_type_crel): Likewise.
	(xcoff_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	* coff64-rs6000.c (xcoff64_reloc_type_br): Correct src_mask and
	dst_mask adjustment.
	(xcoff64_ppc_relocate_section): Set up src_mask and dst_mask correctly.
	(xcoff64_howto_table): Fix src_mask entries.  Make all relocs with
	bitsize == 16 have size = 1.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* bfd.c (bfd_alt_mach_code): Rename parameter 'index' to
	'alternative' in order to avoid shadowing global symbol of the
	same name.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	2002-07-30  Alan Modra  <amodra@@bigpond.net.au>
	* aoutx.h (some_aout_object_p): Clean up tdata properly on error.
	* archive.c (bfd_generic_archive_p): Likewise.
	* coff-rs6000.c (_bfd_xcoff_archive_p): Likewise.
	(_bfd_xcoff_archive_p): Use bfd_scan_vma in place of strtol.
	* coff64-rs6000.c (xcoff64_slurp_armap): Likewise.
	(xcoff64_archive_p): Likewise.
	(xcoff64_openr_next_archived_file): Likewise.
	(xcoff64_archive_p): Clean up tdata properly on error.
	* coffgen.c (coff_real_object_p): Likewise.
	(coff_object_p): Release filehdr and opthdr.
	* ecoff.c (_bfd_ecoff_archive_p): Clean up tdata properly on error.
	* ieee.c (ieee_archive_p): Likewise.
	* ihex.c (ihex_object_p): Likewise.
	(ihex_mkobject): Always allocate tdata.
	* peicode.h (pe_ILF_object_p): Release bfd_alloc'd buffer on error.
	* srec.c (srec_mkobject): Always allocate tdata.
	(srec_object_p): Clean up tdata properly on error.
	(symbolsrec_object_p): Likewise.
	* versados.c (versados_object_p): Likewise.
	* vms-misc.c (_bfd_vms_get_record): Use bfd_malloc instead of malloc,
	and bfd_realloc instead of realloc.
	(add_new_contents): Use bfd_alloc instead of bfd_malloc for sections.
	* vms.c (vms_initialize): Always allocate tdata.  Use bfd_alloc in
	place of bfd_malloc, simplifying error freeing.  Free hash table too.
	(vms_object_p): Clean up tdata on error.
	(vms_mkobject): Don't complain on stderr if vms_initialize fails.
	(vms_close_and_cleanup): Adjust for bfd_alloc use.

	2002-07-17  Ian Rickards  <irickard@@arm.com>
	* dwarf2.c (concat_filename): If we can't establish the directory
	just return the filename.

	2002-07-16  Alan Modra  <amodra@@bigpond.net.au>
	* elflink.h: Formatting fixes, tidy prototypes.
	(elf_link_assign_sym_version): Move common code out of loop.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* elf32-i386.c: Don't defined ELF_ARCH etc. if this file is included
	by a target variant implementation.
	* elf64-alpha.c: Likewise.
	* elf32-i386-fbsd.c: New file.
	* elf64-alpha-fbsd.c: New file.
	* targets.c: Support bfd_elf32_i386_freebsd_vec and
	bfd_elf64_alpha_freebsd_vec.
	* configure.in: Accept the vectors bfd_elf32_i386_freebsd_vec,
	bfd_elf64_alpha_freebsd_vec.
	* Makefile.am (BFD32_BACKENDS): Add elf32-i386-fbsd.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-i386-fbsd.c.
	(BFD64_BACKENDS): Add elf64-alpha-fbsd.lo.
	(BFD64_BACKENDS_CFILES): Add elf64-alpha-fbsd.c.
	(elf32-i386-fbsd.lo, elf64-alpha-fbsd.lo): Add dependencies.
	* config.bfd: For FreeBSD targets, set targ_defvec to a FreeBSD
	specific targets. Define OLD_FREEBSD_ABI_LABEL if appropriate.
@
text
@d2746 1
a2750 1
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
d3290 6
a3295 1
	      if (skip == -1)
a3296 11

	      /* This reloc will be computed at runtime.  We clear the memory
		 so that it contains predictable value.  */
	      if (! skip
		  && ((input_section->flags & SEC_ALLOC) != 0
		      || ELF32_R_TYPE (outrel.r_info) != R_PPC_RELATIVE))
		{
		  relocation = howto->pc_relative ? outrel.r_offset : 0;
		  addend = 0;
		  break;
		}
d3393 1
a3414 1
		      relocation = 0;
a3416 1
		  bfd_put_32 (output_bfd, relocation, sgot->contents + off);
@


1.47
log
@	* cpu-powerpc.c: Comment on ordering of arch_info.
	* elf32-ppc.c (ppc_elf_object_p): New function.
	(elf_backend_object_p): Define.
	* elf64-ppc.c (ppc64_elf_object_p): New function.
	(elf_backend_object_p): Define.
@
text
@d74 1
a74 1
static asection * ppc_elf_gc_mark_hook PARAMS ((bfd *abfd,
d2484 2
a2485 2
ppc_elf_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d2515 1
a2515 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.46
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d46 1
d1384 21
d3822 1
@


1.45
log
@	* elf.c (bfd_section_from_shdr): Make "name" const.
	* elf-bfd.h (elf_backend_section_from_shdr): Likewise.
	* elf32-i370.c (i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-ppc.c (ppc64_elf_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d1410 1
a1410 1
  if (_bfd_generic_verify_endian_match (ibfd, obfd) == false)
@


1.44
log
@	* elf32-ppc.c (ppc_elf_create_got): New function.
	(ppc_elf_create_dynamic_sections): Call ppc_elf_create_got before
	_bfd_elf_create_dynamic_sections.  Correct .plt flags.
	(ppc_elf_check_relocs): Use ppc_elf_create_got in place of
	_bfd_elf_create_got_section.
@
text
@d59 1
a59 1
						  char *));
d1493 1
a1493 1
     char *name;
@


1.44.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d59 1
a59 1
						  const char *));
d1493 1
a1493 1
     const char *name;
@


1.44.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a45 1
static boolean ppc_elf_object_p PARAMS ((bfd *));
d73 1
a73 1
static asection * ppc_elf_gc_mark_hook PARAMS ((asection *sec,
a1382 21
/* Fix bad default arch selected for a 32 bit input bfd when the
   default is 64 bit.  */

static boolean
ppc_elf_object_p (abfd)
     bfd *abfd;
{
  if (abfd->arch_info->the_default && abfd->arch_info->bits_per_word == 64)
    {
      Elf_Internal_Ehdr *i_ehdr = elf_elfheader (abfd);

      if (i_ehdr->e_ident[EI_CLASS] == ELFCLASS32)
	{
	  /* Relies on arch after 64 bit default being 32 bit default.  */
	  abfd->arch_info = abfd->arch_info->next;
	  BFD_ASSERT (abfd->arch_info->bits_per_word == 32);
	}
    }
  return true;
}

d1410 1
a1410 1
  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
d2462 2
a2463 2
ppc_elf_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d2493 3
a2495 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
a3799 1
#define elf_backend_object_p			ppc_elf_object_p
@


1.44.4.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d34 1
a34 1
/* RELA relocations are used here.  */
a3838 1
#ifndef ELF32_PPC_C_INCLUDED
a3839 2
#endif

@


1.44.4.4
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d2746 1
a2750 1
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
d3290 6
a3295 1
	      if (skip == -1)
a3296 11

	      /* This reloc will be computed at runtime.  We clear the memory
		 so that it contains predictable value.  */
	      if (! skip
		  && ((input_section->flags & SEC_ALLOC) != 0
		      || ELF32_R_TYPE (outrel.r_info) != R_PPC_RELATIVE))
		{
		  relocation = howto->pc_relative ? outrel.r_offset : 0;
		  addend = 0;
		  break;
		}
d3393 1
a3414 1
		      relocation = 0;
a3416 1
		  bfd_put_32 (output_bfd, relocation, sgot->contents + off);
d3479 2
a3480 4
	    if (! ((strncmp (name, ".sdata", 6) == 0
		    && (name[6] == 0 || name[6] == '.'))
		   || (strncmp (name, ".sbss", 5) == 0
		       && (name[5] == 0 || name[5] == '.'))))
d3501 1
a3501 2
	    if (! (strncmp (name, ".sdata2", 7) == 0
		   || strncmp (name, ".sbss2", 6) == 0))
d3528 1
a3528 4
	    if (((strncmp (name, ".sdata", 6) == 0	
		  && (name[6] == 0 || name[6] == '.'))
		 || (strncmp (name, ".sbss", 5) == 0
		     && (name[5] == 0 || name[5] == '.'))))
d3536 2
a3537 2
	    else if (strncmp (name, ".sdata2", 7) == 0
		     || strncmp (name, ".sbss2", 6) == 0)
@


1.44.4.5
log
@merge from mainline
@
text
@d3852 1
d3854 1
a3855 20
/* QNX support.  */
#include "elf32-qnx.h"

#undef	TARGET_LITTLE_SYM 
#define	TARGET_LITTLE_SYM		bfd_elf32_powerpcleqnx_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf32-powerpcle-nto"
#undef	TARGET_BIG_SYM
#define	TARGET_BIG_SYM			bfd_elf32_powerpcqnx_vec
#undef	TARGET_BIG_NAME
#define	TARGET_BIG_NAME			"elf32-powerpc-nto"

#define	elf32_bed			elf32_ppc_qnx_bed

#include "elf32-target.h"

#undef	elf_backend_set_nonloadable_filepos
#undef	elf_backend_is_contained_by_filepos
#undef	elf_backend_copy_private_bfd_data_p
#undef	elf32_bed
@


1.44.2.1
log
@merge from trunk
@
text
@d59 1
a59 1
						  const char *));
d1493 1
a1493 1
     const char *name;
@


1.43
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@d52 2
d1637 24
d1673 3
d1695 7
a1701 1
  return true;
d2157 2
a2158 1
	      if (! _bfd_elf_create_got_section (dynobj, info))
a2159 2
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
d2176 2
a2177 1
	      if (! _bfd_elf_create_got_section (dynobj, info))
a2178 2
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
@


1.42
log
@	* elf64-ppc.c (ppc64_elf_howto_raw <R_PPC64_SECTOFF>): Change to a
	16 bit reloc.
	<R_PPC64_SECTOFF_DS>: Likewise.
	(ppc64_elf_reloc_type_lookup): Map from BFD_RELOC_16_BASEREL to
	SECTOFF reloc.
	* elf32-ppc.c (ppc_elf_howto_raw <R_PPC_SECTOFF>): Correct.
	(ppc_elf_reloc_type_lookup): Map from BFD_RELOC_16_BASEREL to
	SECTOFF reloc.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d2899 3
a2945 28
      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if ((unsigned) ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  addend = rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

#ifdef DEBUG
	  fprintf (stderr, "\ttype = %s (%d), symbol index = %ld, offset = %ld, addend = %ld\n",
		   howto->name,
		   (int) r_type,
		   r_symndx,
		   (long) offset,
		   (long) addend);
#endif
	  continue;
	}

      /* This is a final link.  */
d3759 1
@


1.41
log
@	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.
@
text
@d682 1
a682 1
  /* 32-bit section relative relocation.  */
d685 3
a687 3
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 true,			/* pc_relative */
d694 2
a695 2
	 0,			/* dst_mask */
	 true),			/* pcrel_offset */
d1298 1
a1298 1
    case BFD_RELOC_32_BASEREL:		ppc_reloc = R_PPC_SECTOFF;		break;
@


1.40
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d2545 2
a2546 1
      && sym->st_size <= elf_gp_size (abfd))
@


1.39
log
@2001-12-18  H.J. Lu <hjl@@gnu.org>

	* elf-bfd.h (_bfd_elf_copy_private_bfd_data): New. Prototype.
	(_bfd_mips_elf_copy_private_bfd_data): Removed.

	* elf.c (_bfd_elf_copy_private_bfd_data): New. Copy e_flags in
	the ELF header.

	* elf32-i370.c (??_elf_copy_private_bfd_data): Removed.
	(bfd_elf??_bfd_copy_private_bfd_data): Removed.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-ia64.c: Likewise.

	* elf64-mips.c (bfd_elf64_bfd_copy_private_bfd_data): Removed.

	* elfxx-target.h (bfd_elfNN_bfd_copy_private_bfd_data): Defined
	to _bfd_elf_copy_private_bfd_data.
@
text
@d3155 1
a3155 1
	      boolean skip;
d3186 1
a3186 1
	      skip = false;
d3191 3
a3193 2
	      if (outrel.r_offset == (bfd_vma) -1)
		skip = true;
d3264 1
a3264 1
	      if (skip
@


1.39.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d3155 1
a3155 1
	      int skip;
d3186 1
a3186 1
	      skip = 0;
d3191 2
a3192 3
	      if (outrel.r_offset == (bfd_vma) -1
		  || outrel.r_offset == (bfd_vma) -2)
		skip = (int) outrel.r_offset;
d3263 1
a3263 1
	      if (skip != -1
@


1.39.2.2
log
@	* reloc.c: Move sh relocs to where they belong.
	* libbfd.h, bfd-in2.h: Regenerate.

	Merge from mainline
	2002-04-26  Alan Modra  <amodra@@bigpond.net.au>
	* opncls.c (bfd_make_readable): Call bfd_section_list_clear.
	* xcofflink.c (xcoff_link_add_dynamic_symbols): Likewise.
	* elflink.h (elf_bfd_final_link): Ensure input bfd class is the
	same as the output before calling elf_link_input_bfd.
	* coffcode.h (coff_compute_section_file_positions): Set
	section_tail after shuffling section list.

	2002-04-23  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-hppa.c (hppa_type_of_stub): Correct and simplify condition
	under which a plt call stub is used.
	(final_link_relocate): Similarly.
	(allocate_plt_static): Clear h-plabel except when plt entry is
	exclusively used for a plabel.
	(allocate_dynrelocs): Use the above to simplify plt sizing.
	(struct elf32_hppa_link_hash_table): Add has_22bit_branch.
	(elf32_hppa_link_hash_table_create): Init.
	(BL22_RP): Define.
	(hppa_build_one_stub): Use BL22_RP if has_22bit_branch.
	(elf32_hppa_check_relocs): Set has_22bit_branch.
	* elf32-hppa.c (elf32_hppa_check_relocs): Remove debug message.
	(final_link_relocate): Likewise.

	2002-04-20  Alan Modra  <amodra@@bigpond.net.au>
	* archures.c (bfd_arch_info): Add comment on list order.
	(bfd_default_set_arch_mach): Use bfd_lookup_arch.
	* cpu-powerpc.c (bfd_powerpc_archs): Re-order so that the default
	is always at head of list.
	* bfd-in2.h: Regenerate.

	2002-04-16  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Check the hash table
	type rather than just assuming entries are ELF.
	* elf32-sh64.c (sh64_elf_add_symbol_hook): Likewise.
	* elf64-sh64.c (sh64_elf64_add_symbol_hook): Likewise.
	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Likewise.
	* elf64-mmix.c (mmix_elf_add_symbol_hook): Use bfd_link_hash_entry
	rather than elf_link_hash_entry.

	2002-04-15  Alan Modra  <amodra@@bigpond.net.au>
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Check the hash table type.

	2002-04-08  Randolph Chung  <tausq@@debian.org>
	* elf32-hppa.c (hppa_unwind_entry_compare): Move to elf-hppa.h.
	(elf32_hppa_final_link): Split out sorting logic to..
	* elf-hppa.h (elf_hppa_sort_unwind): ..here.
	(elf_hppa_final_link): Call elf_hppa_sort_unwind.
@
text
@d2545 1
a2545 2
      && sym->st_size <= elf_gp_size (abfd)
      && info->hash->creator->flavour == bfd_target_elf_flavour)
@


1.39.2.3
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
a51 2
static asection *ppc_elf_create_got
  PARAMS ((bfd *, struct bfd_link_info *));
d682 1
a682 1
  /* 16-bit section relative relocation.  */
d685 3
a687 3
	 1,			/* size (0 = byte, 1 = short, 2 = long) */
	 16,			/* bitsize */
	 false,			/* pc_relative */
d694 2
a695 2
	 0xffff,		/* dst_mask */
	 false),		/* pcrel_offset */
d1298 1
a1298 1
    case BFD_RELOC_16_BASEREL:		ppc_reloc = R_PPC_SECTOFF;		break;
a1634 24
/* The powerpc .got has a blrl instruction in it.  Mark it executable.  */

static asection *
ppc_elf_create_got (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
{
  register asection *s;
  flagword flags;

  if (!_bfd_elf_create_got_section (abfd, info))
    return NULL;

  s = bfd_get_section_by_name (abfd, ".got");
  if (s == NULL)
    abort ();

  flags = (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_HAS_CONTENTS | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED);
  if (!bfd_set_section_flags (abfd, s, flags))
    return NULL;
  return s;
}

a1646 3
  if (!ppc_elf_create_got (abfd, info))
    return false;

d1666 1
a1666 7

  s = bfd_get_section_by_name (abfd, ".plt");
  if (s == NULL)
    abort ();

  flags = SEC_ALLOC | SEC_CODE | SEC_IN_MEMORY | SEC_LINKER_CREATED;
  return bfd_set_section_flags (abfd, s, flags);
d2122 1
a2122 2
	      sgot = ppc_elf_create_got (dynobj, info);
	      if (sgot == NULL)
d2124 2
d2142 1
a2142 2
	      sgot = ppc_elf_create_got (dynobj, info);
	      if (sgot == NULL)
d2144 2
a2898 3
  if (info->relocateable)
    return true;

d2943 28
a3783 1
#define elf_backend_rela_normal		1
@


1.38
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@a46 1
static boolean ppc_elf_copy_private_bfd_data PARAMS ((bfd *, bfd *));
a1395 18
/* Copy backend specific data from one object module to another */
static boolean
ppc_elf_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
{
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return true;

  BFD_ASSERT (!elf_flags_init (obfd)
	      || elf_elfheader (obfd)->e_flags == elf_elfheader (ibfd)->e_flags);

  elf_elfheader (obfd)->e_flags = elf_elfheader (ibfd)->e_flags;
  elf_flags_init (obfd) = true;
  return true;
}

a3782 1
#define bfd_elf32_bfd_copy_private_bfd_data	ppc_elf_copy_private_bfd_data
@


1.37
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d2480 1
a2480 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
@


1.36
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d3213 5
a3217 16
	      if (elf_section_data (input_section)->stab_info == NULL)
		outrel.r_offset = rel->r_offset;
	      else
		{
		  bfd_vma off;

		  off = (_bfd_stab_section_offset
			 (output_bfd, &elf_hash_table (info)->stab_info,
			  input_section,
			  &elf_section_data (input_section)->stab_info,
			  rel->r_offset));
		  if (off == (bfd_vma) -1)
		    skip = true;
		  outrel.r_offset = off;
		}

@


1.35
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d3001 2
a3002 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.34
log
@2001-10-18  H.J. Lu <hjl@@gnu.org>

	* elf32-i370.c (i370_elf_relocate_section): Ignore R_XXX_NONE.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
@
text
@d3178 1
a3178 1
	  if (info->shared)
@


1.33
log
@	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Merge dyn_reloc
	counts for aliases instead of aborting.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.

	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Set plt.offset
	to -1 for non-function symbols.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Refer to
	plt.offset instead of plt.refcount when setting to -1.
@
text
@d3131 3
a3168 1
	case (int) R_PPC_NONE:
@


1.32
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): Add init_refcount.
	(struct elf_backend_data): Add can_refcount.
	* elf.c (_bfd_elf_link_hash_newfunc): Get rid of a few casts.  Set
	got.refcount and plt.refcount from init_refcount.
	(_bfd_elf_link_hash_table_init): Set up init_refcount.
	(_bfd_elf_link_hash_copy_indirect): Reference got/plt.refcount
	rather than got/plt.offset, and test for <= 0 rather than -1.
	* elflink.h (size_dynamic_sections): Set init_refcount to -1.
	* elfxx-target.h (elf_backend_can_refcount): Define.
	(elfNN_bed): Init can_refcount.
	* linker.c (_bfd_link_hash_newfunc): Get rid of a few casts.
	(_bfd_generic_link_hash_newfunc): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-hppa.c (elf32_hppa_check_relocs): Modify for refcounts
	starting from zero.
	(elf32_hppa_copy_indirect_symbol): Make static to agree with
	prototype.
	(elf_backend_can_refcount): Define.
	* elf32-i386.c (elf_i386_check_relocs): Modify for refcounts
	starting from zero.
	(allocate_dynrelocs): Set plt/got.offset rather than *.refcount.
	(elf_i386_finish_dynamic_symbol): Expand SHN_UNDEF comment.
	(elf_i386_finish_dynamic_sections): Use local var so line < 80 chars.
	(elf_backend_can_refcount): Define.
	(elf_i386_copy_indirect_symbol): Make static to agree with
	prototype.  Formatting fix.
	* elf32-m68k.c (elf_m68k_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-ppc.c (ppc_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
@
text
@d1800 2
@


1.31
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d2187 1
a2187 1
	      if (h->got.refcount == -1)
a2197 2

		  h->got.refcount = 1;
d2199 1
a2199 2
	      else
		h->got.refcount++;
d2211 1
a2211 1
		    = (bfd_signed_vma *) bfd_alloc (abfd, size);
a2214 1
		  memset (local_got_refcounts, -1, (size_t) size);
d2216 1
a2216 1
	      if (local_got_refcounts[r_symndx] == -1)
a2224 2

		  local_got_refcounts[r_symndx] = 1;
d2226 1
a2226 2
	      else
		local_got_refcounts[r_symndx]++;
d2339 2
a2340 7
	  if (h->plt.refcount == -1)
	    {
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount = 1;
	    }
	  else
	    h->plt.refcount++;
d3812 1
@


1.30
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d111 2
a112 1
static enum elf_reloc_type_class ppc_elf_reloc_type_class PARAMS ((int));
d3721 2
a3722 2
ppc_elf_reloc_type_class (type)
     int type;
d3724 1
a3724 1
  switch (type)
@


1.29
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d1455 1
a1455 1
	     bfd_get_filename (ibfd));
d1463 1
a1463 1
	     bfd_get_filename (ibfd));
d1489 1
a1489 1
	     bfd_get_filename (ibfd), (long) new_flags, (long) old_flags);
d2086 1
a2086 1
	   bfd_get_filename (abfd));
d2242 1
a2242 1
		bfd_get_filename (abfd), "R_PPC_EMB_SDAI16"));
d2276 1
a2276 1
		bfd_get_filename (abfd), "R_PPC_EMB_SDA2I16"));
d2311 1
a2311 1
		bfd_get_filename (abfd),
d2926 1
a2926 1
	   bfd_get_filename (input_bfd),
d2965 1
a2965 1
				 bfd_get_filename (input_bfd),
d3098 1
a3098 1
                     bfd_get_filename (input_bfd), h->root.root.string,
d3133 1
a3133 1
				 bfd_get_filename (input_bfd),
d3497 1
a3497 1
				       bfd_get_filename (input_bfd),
d3518 1
a3518 1
				       bfd_get_filename (input_bfd),
d3568 1
a3568 1
				       bfd_get_filename (input_bfd),
d3634 1
a3634 1
				 bfd_get_filename (input_bfd),
@


1.28
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d3109 3
a3111 1
	  else if (info->shared && !info->symbolic && !info->no_undefined
@


1.27
log
@        * elf32-i386.c: Add missing prototypes.
        * elf32-ppc.c: Likewise.
        * elf32-sh-lin.c: Likewise.
        * elfarm-nabi.c: Likewise.
@
text
@d1062 1
d1074 3
a1076 2
          rela_comb = (Elf_Internal_Rela**)
	    bfd_malloc (isec->reloc_count*sizeof (Elf_Internal_Rela*));
d1205 1
a1205 1
                  bfd_put_32 (abfd, insn, contents + isec_offset);
d2019 4
a2022 1
      if (! info->shared)
d2024 1
a2024 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
d2030 4
a2033 4
	  if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
d2039 3
a2041 4
	  if (! bfd_elf32_add_dynamic_entry (info, DT_RELA, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELASZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_RELAENT,
						sizeof (Elf32_External_Rela)))
d2047 1
a2047 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
d2052 1
d2208 1
a2208 1
		  size_t size;
d2210 4
a2213 3
		  size = symtab_hdr->sh_info * sizeof (bfd_signed_vma);
		  local_got_refcounts = (bfd_signed_vma *)
		    bfd_alloc (abfd, size);
d2217 1
a2217 1
		  memset (local_got_refcounts, -1, size);
d2588 2
d2594 2
a2595 2
	  sdata->bss_section = ((asection *)
				bfd_zalloc (abfd, sizeof (asection)));
d2601 3
a2603 2
	  sdata->bss_section->symbol =
	    (asymbol *) bfd_zalloc (abfd, sizeof (asymbol));
d2605 1
a2605 1
	    (asymbol **) bfd_zalloc (abfd, sizeof (asymbol *));
d2709 1
a2709 1
		       + (h->got.offset &~ 1));
d2854 1
a2854 1
      bfd_put_32 (output_bfd, 0x4e800021 /* blrl */, contents);
d3332 1
a3332 1
	  bfd_put_32 (output_bfd, insn, contents + offset);
d3343 1
a3343 1
	  bfd_put_32 (output_bfd, insn, contents + offset);
d3580 1
a3580 1
		bfd_put_32 (output_bfd, insn, contents + offset);
d3743 1
a3743 1
  int raw_size;
@


1.26
log
@        * elf32-i386.c (elf_i386_grok_prstatus): New function.
        (elf_i386_grok_psinfo): New function.
        (elf_backend_grok_prstatus): Define.
        (elf_backend_grok_psinfo): Likewise.
        * elf32-ppc.c (ppc_elf_grok_prstatus): New function.
        (ppc_elf_grok_psinfo): New function.
        (elf_backend_grok_prstatus): Define.
        (elf_backend_grok_psinfo): Likewise.
        * elf32-sh-lin.c (elf32_shlin_grok_prstatus): New function.
        (elf32_shlin_grok_psinfo): New function.
        (elf_backend_grok_prstatus): Define.
        (elf_backend_grok_psinfo): Likewise.
        * elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): New function.
        (elf32_arm_nabi_grok_psinfo): New function.
        (elf_backend_grok_prstatus): Define.
        (elf_backend_grok_psinfo): Likewise.
@
text
@d112 4
@


1.25
log
@	* elf64-s390.c (elf_s390_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf_s390_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_s390_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.

	* elf32-s390.c (elf_s390_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf_s390_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_s390_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.

	* elf32-ppc.c (ppc_elf_check_relocs): Set DF_TEXTREL if the reloc
	is against read-only section.
	(ppc_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(ppc_elf_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
@
text
@d3723 65
d3832 2
@


1.24
log
@	* bfd.c (bfd_get_gp_size): Return an unsigned int.
	(bfd_set_gp_size): Make param unsigned.
	* bfd-in2.h: Regenerate.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Use elf_gp_size rather
	than calling bfd_get_gp_size.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
@
text
@d111 1
d1882 1
a1882 1
     bfd *output_bfd;
a1888 1
  boolean reltext;
a1932 1
  reltext = false;
a1977 3
	      asection *target;
	      const char *outname;

a1980 10
	      /* If this relocation section applies to a read only
		 section, then we probably need a DT_TEXTREL entry.  */
	      outname = bfd_get_section_name (output_bfd,
					      s->output_section);
	      target = bfd_get_section_by_name (output_bfd, outname + 5);
	      if (target != NULL
		  && (target->flags & SEC_READONLY) != 0
		  && (target->flags & SEC_ALLOC) != 0)
		reltext = true;

d2037 1
a2037 1
      if (reltext)
d2422 2
d3703 19
d3767 1
@


1.23
log
@	* coff-rs6000.c: Add missing prototypes.
	(xcoff_ppc_relocate_section, xcoff_is_lineno_count_overflow,
	xcoff_is_reloc_count_overflow, xcoff_loader_symbol_offset,
	xcoff_loader_reloc_offset): Make static.
	* dwarf1.c: Add missing prototypes.
	* dwarf2.c: Add missing prototypes.
	(struct abbrev_info): Move definition.
	(struct attr_abbrev, ABBREV_HASH_SIZE, ATTR_ALLOC_CHUNK): Likewise.
	* elf.c: Add missing prototypes.
	* elf32-gen.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-ppc.c: Likewise.
	(ppc_elf_sort_rela): Use PTR instead of "void *".
	* elflink.h: Add missing prototypes.  Formatting fixes.
	* merge.c: Add missing prototypes.
	(last4_eq): Use PTR instead of "void *".
	(last_eq): Likewise.
	* syms.c: Add missing prototypes.
@
text
@d2581 1
a2581 1
      && sym->st_size <= (bfd_vma) bfd_get_gp_size (abfd))
@


1.22
log
@Update copyright notices
@
text
@d41 3
d995 2
a996 2
     const void *arg1;
     const void *arg2;
@


1.21
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
@


1.21.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.20
log
@2000-12-08  Kazu Hirata  <kazu@@hxi.com>

	* coffgen.c: Fix formatting.
	* elf32-i386.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf-m10300.c: Likewise.
@
text
@a1489 1

a1516 1

a1533 1

a2056 1

@


1.19
log
@2000-12-07  Kazu Hirata  <kazu@@hxi.com>

	* elf32-ppc.c: Fix formatting.
	* elf64-x86-64.c: Likewise.
@
text
@a2568 1
/*ARGSUSED*/
@


1.18
log
@2000-12-06  Kazu Hirata  <kazu@@hxi.com>

	* elf32-m32r.c: Fix formatting.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-pj.c: Likewise.
	* elf32-ppc.c: Likewise.
@
text
@d144 1
a144 1
static reloc_howto_type *ppc_elf_howto_table[ (int)R_PPC_max ];
d146 1
a146 2
static reloc_howto_type ppc_elf_howto_raw[] =
{
d239 1
a239 1
     the low 16 bits, treated as a signed number, is negative.	*/
d272 1
a272 1
     bits must be zero.	 */
d304 1
a304 1
  /* A relative 26 bit branch; the lower two bits must be zero.	 */
d319 1
a319 1
  /* A relative 16 bit branch; the lower two bits must be zero.	 */
d334 1
a334 1
  /* A relative 16 bit branch.	Bit 10 should be set to indicate that
d351 1
a351 1
  /* A relative 16 bit branch.	Bit 10 should be set to indicate that
a948 1

a963 1

d991 2
a992 2
    const void *arg1;
    const void *arg2;
d1003 4
a1006 4
    bfd *abfd;
    asection *isec;
    struct bfd_link_info *link_info;
    boolean *again;
d1025 1
a1025 1
  troublesome area at the end of a page.  */
d1040 1
a1040 1
	      goto error_return;
d1045 1
a1045 1
	      goto error_return;
d1051 1
a1051 1
        {
d1068 1
a1068 1
          for (n=0; n<isec->reloc_count; ++n)
d1073 1
a1073 1
              if (r_type < 0 || r_type >= (int)R_PPC_max)
d1098 2
a1099 2
              qsort (rela_comb, (size_t) comb_count, sizeof (int), ppc_elf_sort_rela);
        }
a1240 1

d1250 1
a1250 1
    /* Initialize howto table if needed */
d1253 1
a1253 1
  switch ((int)code)
d1256 1
a1256 1
      return (reloc_howto_type *)NULL;
d1313 1
a1313 1
  return ppc_elf_howto_table[ (int)ppc_reloc ];
d1324 2
a1325 1
  if (!ppc_elf_howto_table[ R_PPC_ADDR32 ])	/* Initialize howto table if needed */
d1478 1
a1478 1
	     bfd_get_filename (ibfd), (long)new_flags, (long)old_flags);
d1580 1
a1580 1
				 (int)which);
d1583 1
a1583 1
	  return (elf_linker_section_t *)0;
a1607 1

d1609 2
a1610 2
/* If we have a non-zero sized .sbss2 or .PPC.EMB.sbss0 sections, we need to bump up
   the number of section headers.  */
d1636 1
a1636 1
/* Modify the segment map if needed */
d1657 1
a1657 1
  if (!_bfd_elf_create_dynamic_sections(abfd, info))
a1874 1

d1916 1
a1916 1
				       (char *)0 };
d1919 1
a1919 1
      for (p = rela_sections; *p != (char *)0; p++)
d2247 1
a2247 1
	       return false;
d2316 1
a2316 1
		ppc_elf_howto_table[(int)ELF32_R_TYPE (rel->r_info)]->name));
a2620 1

d2725 1
a2725 1
	  BFD_ASSERT((h->got.offset & 1) == 0);
a2780 1

a2867 1

d2928 1
a2928 1
	   (long)input_section->reloc_count,
d2932 2
a2933 1
  if (!ppc_elf_howto_table[ R_PPC_ADDR32 ])	/* Initialize howto table if needed */
d2951 4
a2954 4
      Elf_Internal_Sym *sym		= (Elf_Internal_Sym *)0;
      asection *sec			= (asection *)0;
      struct elf_link_hash_entry *h	= (struct elf_link_hash_entry *)0;
      const char *sym_name		= (const char *)0;
d2961 2
a2962 1
      if ((unsigned)r_type >= (unsigned)R_PPC_max || !ppc_elf_howto_table[(int)r_type])
d2966 1
a2966 1
				 (int)r_type);
d2973 1
a2973 1
      howto = ppc_elf_howto_table[(int)r_type];
d2985 1
a2985 1
	      if ((unsigned)ELF_ST_TYPE (sym->st_info) == STT_SECTION)
d2995 1
a2995 1
		   (int)r_type,
d2997 2
a2998 2
		   (long)offset,
		   (long)addend);
d3095 1
a3095 1
	        {
d3101 1
a3101 1
	        }
d3127 1
a3127 1
      switch ((int)r_type)
d3132 1
a3132 1
				 (int)r_type, sym_name);
d3139 1
a3139 1
	case (int)R_PPC_LOCAL24PC:
d3160 3
a3162 3
	case (int)R_PPC_REL24:
	case (int)R_PPC_REL32:
	case (int)R_PPC_REL14:
d3173 10
a3182 10
	case (int)R_PPC_NONE:
	case (int)R_PPC_ADDR32:
	case (int)R_PPC_ADDR24:
	case (int)R_PPC_ADDR16:
	case (int)R_PPC_ADDR16_LO:
	case (int)R_PPC_ADDR16_HI:
	case (int)R_PPC_ADDR16_HA:
	case (int)R_PPC_ADDR14:
	case (int)R_PPC_UADDR32:
	case (int)R_PPC_UADDR16:
d3280 1
a3280 1
			  BFD_ASSERT(indx > 0);
d3325 2
a3326 2
	case (int)R_PPC_ADDR14_BRTAKEN:
	case (int)R_PPC_REL14_BRTAKEN:
d3336 2
a3337 2
	case (int)R_PPC_ADDR14_BRNTAKEN:
	case (int)R_PPC_REL14_BRNTAKEN:
d3347 4
a3350 4
	case (int)R_PPC_GOT16:
	case (int)R_PPC_GOT16_LO:
	case (int)R_PPC_GOT16_HI:
	case (int)R_PPC_GOT16_HA:
d3437 1
a3437 1
	case (int)R_PPC_EMB_SDAI16:
d3445 1
a3445 1
	case (int)R_PPC_EMB_SDA2I16:
d3456 2
a3457 2
	case (int)R_PPC_TOC16:			/* phony GOT16 relocations */
	  BFD_ASSERT (sec != (asection *)0);
d3465 1
a3465 1
	case (int)R_PPC_PLTREL24:
d3482 1
a3482 1
 	  break;
d3485 1
a3485 1
	case (int)R_PPC_SDAREL16:
d3489 1
a3489 1
	    BFD_ASSERT (sec != (asection *)0);
d3497 1
a3497 1
				       ppc_elf_howto_table[ (int)r_type ]->name,
d3507 1
a3507 1
	case (int)R_PPC_EMB_SDA2REL:
d3511 1
a3511 1
	    BFD_ASSERT (sec != (asection *)0);
d3518 1
a3518 1
				       ppc_elf_howto_table[ (int)r_type ]->name,
d3532 2
a3533 2
	case (int)R_PPC_EMB_SDA21:
	case (int)R_PPC_EMB_RELSDA:
d3538 1
a3538 1
	    BFD_ASSERT (sec != (asection *)0);
d3548 2
a3549 1
	    else if (strcmp (name, ".sdata2") == 0 || strcmp (name, ".sbss2") == 0)
d3557 2
a3558 1
	    else if (strcmp (name, ".PPC.EMB.sdata0") == 0 || strcmp (name, ".PPC.EMB.sbss0") == 0)
d3568 1
a3568 1
				       ppc_elf_howto_table[ (int)r_type ]->name,
d3586 4
a3589 4
	case (int)R_PPC_SECTOFF:
	case (int)R_PPC_SECTOFF_LO:
	case (int)R_PPC_SECTOFF_HI:
	  BFD_ASSERT (sec != (asection *)0);
d3593 2
a3594 2
	case (int)R_PPC_SECTOFF_HA:
	  BFD_ASSERT (sec != (asection *)0);
d3600 5
a3604 5
	case (int)R_PPC_EMB_NADDR32:
	case (int)R_PPC_EMB_NADDR16:
	case (int)R_PPC_EMB_NADDR16_LO:
	case (int)R_PPC_EMB_NADDR16_HI:
	  addend -= 2*relocation;
d3607 2
a3608 2
	case (int)R_PPC_EMB_NADDR16_HA:
	  addend -= 2*relocation;
d3614 1
a3614 1
	case (int)R_PPC_EMB_MRKREF:
d3617 14
a3630 14
	case (int)R_PPC_COPY:
	case (int)R_PPC_GLOB_DAT:
	case (int)R_PPC_JMP_SLOT:
	case (int)R_PPC_RELATIVE:
	case (int)R_PPC_PLT32:
	case (int)R_PPC_PLTREL32:
	case (int)R_PPC_PLT16_LO:
	case (int)R_PPC_PLT16_HI:
	case (int)R_PPC_PLT16_HA:
	case (int)R_PPC_EMB_RELSEC16:
	case (int)R_PPC_EMB_RELST_LO:
	case (int)R_PPC_EMB_RELST_HI:
	case (int)R_PPC_EMB_RELST_HA:
	case (int)R_PPC_EMB_BIT_FLD:
d3633 1
a3633 1
				 ppc_elf_howto_table[ (int)r_type ]->name,
d3640 2
a3641 2
	case (int)R_PPC_GNU_VTINHERIT:
	case (int)R_PPC_GNU_VTENTRY:
d3649 1
a3649 1
	       (int)r_type,
d3652 2
a3653 2
	       (long)offset,
	       (long)addend);
a3715 1

@


1.17
log
@	* elf32-ppc.c (SYMBOL_REFERENCES_LOCAL): New macro.
	(SYMBOL_CALLS_LOCAL): New macro.
	(ppc_elf_adjust_dynamic_symbol): Use SYMBOL_CALLS_LOCAL.
	(ppc_elf_check_relocs): Use SYMBOL_REFERENCES_LOCAL.
	(ppc_elf_finish_dynamic_symbol): Use SYMBOL_REFERENCES_LOCAL.
	(ppc_elf_relocate_section): Use flag variable to determine
	whether the relocation refers to a local symbol.
	Test whether a PLTREL24 reloc will produce a reloc by looking
	to see whether a PLT entry was made.
@
text
@a34 1

d579 1
a579 1
     FIXME: not supported. */
d595 1
a595 1
     FIXME: not supported. */
d674 1
a674 1
  /* 32-bit section relative relocation. */
d689 1
a689 1
  /* 16-bit lower half section relative relocation. */
d704 1
a704 1
  /* 16-bit upper half section relative relocation. */
d719 1
a719 1
  /* 16-bit upper half adjusted section relative relocation. */
d962 1
a962 1
      BFD_ASSERT (type < sizeof(ppc_elf_howto_table) / sizeof(ppc_elf_howto_table[0]));
d978 1
a978 1
   
d1000 1
a1000 1
  /* Sort by offset. */
d1020 1
a1020 1
  /* We never have to do this more than once per input section. */
d1028 1
a1028 1
  troublesome area at the end of a page. */
d1034 1
a1034 1
      /* Get the section contents. */
d1059 1
a1059 1
    	    abfd, isec, (PTR) NULL, (Elf_Internal_Rela *) NULL, 
d1065 2
a1066 2
    
          /* Setup a faster access method for the reloc info we need. */
d1068 1
a1068 1
	    bfd_malloc (isec->reloc_count*sizeof(Elf_Internal_Rela*));
d1074 1
a1074 1
    
d1078 1
a1078 1
    
d1086 1
a1086 1
              The array rela_comb is built here for use in the EOP scan loop. */
d1090 1
a1090 1
                case R_PPC_REL14:               /* relative cond. br. */
d1092 1
a1092 1
                  /* We should check the instruction. */
d1095 1
a1095 1
                  /* The word is not a conditional branch - ignore it. */
d1104 1
a1104 1
      /* Enumerate each EOP region that overlaps this section. */
d1110 1
a1110 1
          dot = isec->vma;      /* begins in the middle of its first EOP region. */
d1116 1
a1116 1
          /* Check each word in this EOP region. */
d1124 1
a1124 1
              the relocation indicates the word is not a conditional branch. */
d1140 1
a1140 1
              /* Check the current word for a problematic conditional branch. */
d1153 1
a1153 1
                      If this is a forward branch, it is problematic. */
d1174 1
a1174 1
                      always set the prediction bit. */
d1187 1
a1187 1
                      always set the prediction bit. */
d1373 1
a1373 1
/* Function to set whether a module needs the -mrelocatable bit set. */
a1713 1

d1986 1
a1986 1
	      /* Remember whether there are any relocation sections. */
a2108 1

d2121 1
a2121 1
  sym_hashes_end = sym_hashes + symtab_hdr->sh_size/sizeof(Elf32_External_Sym);
d2694 1
a2694 1
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) 
d3120 1
a3120 1
	      if (! (*info->callbacks->undefined_symbol)(info,
d3290 1
a3290 1
			      printf("indx=%d section=%s flags=%08x name=%s\n",
a3511 1

d3526 1
a3526 1
		
a3536 1

a3649 1

d3701 1
a3701 1
	  if (! (*info->callbacks->reloc_overflow)(info,
@


1.16
log
@	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Don't make PLT
	entries that could serve as a definition for a weak symbol.
@
text
@d127 17
d1723 1
a1723 3
	  || ((!info->shared || info->symbolic || h->dynindx == -1)
	      && (h->elf_link_hash_flags
		  & ELF_LINK_HASH_DEF_REGULAR) != 0)
d1731 2
a1732 4
	     2. We know for certain that a symbol is defined in
	     this object, because this object is the application,
	     is linked with -Bsymbolic, the symbol is local,
	     or because the symbol is protected or hidden.
d2402 2
a2403 1
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d2725 1
a2725 2
	  && (info->symbolic || h->dynindx == -1)
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d2968 1
d3022 2
d3032 4
d3040 2
a3041 1
	      if ((r_type == R_PPC_PLT32
d3051 1
a3051 4
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
d3053 1
a3053 3
		      && ((! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
a3070 1
			  || r_type == R_PPC_PLTREL24
d3118 1
a3118 2
	  else if (info->shared && !info->symbolic
		   && !info->no_undefined
d3175 2
a3176 1
	      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
d3251 1
a3251 4
	      else if (h != NULL
		       && ((! info->symbolic && h->dynindx != -1)
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
a3252 1
		  BFD_ASSERT (h->dynindx != -1);
d3373 1
a3373 2
		      && (info->symbolic || h->dynindx == -1)
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
@


1.15
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* elf32-arm.h (elf32_arm_size_dynamic_sections): Also set
	DF_TEXTREL if DT_TEXTREL is set.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Likewise.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Likewise.
	* elf32-mips.c (_bfd_mips_elf_size_dynamic_sections): Likewise.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Likewise.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Likewise.
	* elf64-ia64.c (elf64_ia64_size_dynamic_sections): Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections): Likewise.

	* bfd/elflink.h (NAME(bfd_elf,size_dynamic_sections)): Also
	set DF_SYMBOLIC for symbolic link. Also set DT_RUNPATH if
	DT_RPATH is set.
	Set the DT_FLAGS and DT_FLAGS_1 entries if necessary.
@
text
@d1718 2
a1719 1
	     is linked with -Bsymbolic, or because the symbol is local.
d2679 7
@


1.14
log
@2000-05-23  H.J. Lu  <hjl@@gnu.org>

	* elf32-mips.c (mips_elf_calculate_relocation): Check
	h->root.other not h->other.

	* elf32-ppc.c (ppc_elf_relocate_section): Fix a typo.
@
text
@d2047 1
@


1.13
log
@2000-05-23  H.J. Lu  <hjl@@gnu.org>

	* elf32-i386.c (elf_i386_relocate_section): Don't allow the
	undefined symbol with the non-default visibility attributes.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ia64.c (elf64_ia64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d3107 1
a3107 1
							  ELF_ST_VISIBILITY (h->other))))
@


1.12
log
@Use bfd_generic_verify_endian_match() and fix it to only check when endianness
is known.
@
text
@d3094 3
a3096 1
	  else if (info->shared && !info->symbolic && !info->no_undefined)
d3106 2
a3107 1
							  || info->no_undefined)))
@


1.11
log
@Reference count .plt and .got on x86 for garbage collection code.  Fix a
couple of m68k and ppc bugs discovered while testing x86 gc.
@
text
@d1402 2
a1403 15
  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    {
      const char *msg;

      if (bfd_big_endian (ibfd))
	msg = _("%s: compiled for a big endian system and target is little endian");
      else
	msg = _("%s: compiled for a little endian system and target is big endian");

      (*_bfd_error_handler) (msg, bfd_get_filename (ibfd));

      bfd_set_error (bfd_error_wrong_format);
      return false;
    }
@


1.10
log
@H.J's x86 fix for "nm -l" on shared libraries, applied to ppc too.
@
text
@d2543 1
a2543 1
	else
d3025 1
@


1.9
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d3046 3
a3048 1
		          || (input_section->flags & SEC_DEBUGGING) != 0)
@


1.9.2.1
log
@	From 2000-10-14  Geoffrey Keating  <geoffk@@cygnus.com>
	* elf32-ppc.c (ppc_elf_finish_dynamic_symbol): Don't make PLT
	entries that could serve as a definition for a weak symbol.
@
text
@a2689 7
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK) 
	      == 0)
	    sym->st_value = 0;
@


1.9.2.2
log
@Merge from mainline
@
text
@d3111 1
a3111 3
	  else if (info->shared && !info->symbolic
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
d3121 1
a3121 2
							  || info->no_undefined
							  ELF_ST_VISIBILITY (h->other))))
@


1.9.2.3
log
@2000-10-31  Philip Blundell  <philb@@gnu.org>

	* elf32-arm.h (elf32_arm_merge_private_bfd_data): Only handle
	EF_SOFT_FLOAT if it is defined.

	From 2000-05-23  H.J. Lu  <hjl@@gnu.org>
	* elf32-ppc.c (ppc_elf_relocate_section): Fix a typo.
@
text
@d3124 1
a3124 1
							  || ELF_ST_VISIBILITY (h->other))))
@


1.8
log
@	* section.c (_bfd_strip_section_from_output): Add info parameter.
	If it passed as non-NULL, use it to check whether any input BFD
	has an input section which uses this output section.  Change all
	callers.
	* bfd-in2.h: Rebuild.

	* bfd-in.h: Move declarations of bfd_get_elf_phdr_upper_bound and
	bfd_get_elf_phdrs in from bfd-in2.h, correcting patch of
	1999-11-29.
	* bfd-in2.h: Rebuild.
@
text
@d3112 3
a3114 1
							 rel->r_offset))
d3144 2
a3145 1
							  rel->r_offset))
@


1.7
log
@	* elf32-ppc.c (ppc_elf_relocate_section): Don't use the relocation
	value of a symbol in a SEC_DEBUGGING section.  Warn when doing a
	relocation against a symbol in an input section with no output
	section.  From Daniel Jacobowitz <drow@@false.org>.
@
text
@d2015 1
a2015 1
	  _bfd_strip_section_from_output (s);
@


1.6
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): New.
	(struct elf_link_hash_table): Add dynlocal.
	(_bfd_elf_link_lookup_local_dynindx): Prototype.
	(_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_renumber_dynsyms): Prototype.
	(_bfd_elf,link_record_local_dynamic_symbol): Prototype.
	* elfcode.h (elf_link_record_local_dynamic_symbol): New alias.
	* elflink.c (_bfd_elf_link_adjust_dynindx): Delete.
	(_bfd_elf_link_lookup_local_dynindx): New function.
	(elf_link_renumber_hash_table_dynsyms): New function.
	(_bfd_elf_link_renumber_dynsyms): New function.
	* elflink.h (elf_link_record_local_dynamic_symbol): New function.
	(struct elf_assign_sym_version_info): Delete removed_dynamic.
	(bfd_elf,size_dynamic_sections): Use _bfd_strip_section_from_output
	instead of elf_link_remove_section_and_adjust_dynindices.
	Remove removed_dynamic code.  Use _bfd_elf_link_renumber_dynsyms.
	(elf_link_assign_sym_version): Remove removed_dynamic code.
	(elf_link_renumber_dynsyms): Delete.
	(elf_bfd_final_link): Install section and local symbols into .dynsym.
	* elf32-m68k.c (elf_m68k_adjust_dynindx): Delete.
	(elf_m68k_size_dynamic_sections): Don't set section dynindicies.
	(elf_m68k_finish_dynamic_sections): Don't write section dynsyms.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf64-alpha.c: Similarly.
	* elf64-sparc.c: Similarly.
@
text
@d3041 6
a3046 1
		      && (input_section->flags & SEC_ALLOC) != 0
d3089 8
@


1.5
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@a82 2
static boolean ppc_elf_adjust_dynindx PARAMS ((struct elf_link_hash_entry *, PTR));

a1881 21
/* Increment the index of a dynamic symbol by a given amount.  Called
   via elf_link_hash_traverse.  */

static boolean
ppc_elf_adjust_dynindx (h, cparg)
     struct elf_link_hash_entry *h;
     PTR cparg;
{
  int *cp = (int *) cparg;

#ifdef DEBUG
  fprintf (stderr, "ppc_elf_adjust_dynindx called, h->dynindx = %d, *cp = %d\n", h->dynindx, *cp);
#endif

  if (h->dynindx != -1)
    h->dynindx += *cp;

  return true;
}


a2062 37
  /* If we are generating a shared library, we generate a section
     symbol for each output section.  These are local symbols, which
     means that they must come first in the dynamic symbol table.
     That means we must increment the dynamic symbol index of every
     other dynamic symbol.

     FIXME: We assume that there will never be relocations to
     locations in linker-created sections that do not have
     externally-visible names. Instead, we should work out precisely
     which sections relocations are targetted at.  */
  if (info->shared)
    {
      int c;

      for (c = 0, s = output_bfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_LINKER_CREATED) != 0
	      || (s->flags & SEC_ALLOC) == 0)
	    {
	      elf_section_data (s)->dynindx = 0;
	      continue;
	    }

	  /* These symbols will have no names, so we don't need to
	     fiddle with dynstr_index.  */

	  elf_section_data (s)->dynindx = c + 1;

	  c++;
	}

      elf_link_hash_traverse (elf_hash_table (info),
			      ppc_elf_adjust_dynindx,
			      (PTR) &c);
      elf_hash_table (info)->dynsymcount += c;
    }

a2864 48
    }

  if (info->shared)
    {
      asection *sdynsym;
      asection *s;
      Elf_Internal_Sym sym;
      int maxdindx = 0;

      /* Set up the section symbols for the output sections.  */

      sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
      BFD_ASSERT (sdynsym != NULL);

      sym.st_size = 0;
      sym.st_name = 0;
      sym.st_info = ELF_ST_INFO (STB_LOCAL, STT_SECTION);
      sym.st_other = 0;

      for (s = output_bfd->sections; s != NULL; s = s->next)
	{
	  int indx, dindx;

	  sym.st_value = s->vma;

	  indx = elf_section_data (s)->this_idx;
	  dindx = elf_section_data (s)->dynindx;
	  if (dindx > 0)
	    {
	      BFD_ASSERT(indx > 0);
	      BFD_ASSERT(dindx > 0);

	      if (dindx > maxdindx)
		maxdindx = dindx;

	      sym.st_shndx = indx;

	      bfd_elf32_swap_symbol_out (output_bfd, &sym,
					 (PTR) (((Elf32_External_Sym *)
						 sdynsym->contents)
						+ dindx));
	    }
	}

      /* Set the sh_info field of the output .dynsym section to the
         index of the first global symbol.  */
      elf_section_data (sdynsym->output_section)->this_hdr.sh_info =
	maxdindx + 1;
@


1.4
log
@	From Franz Sirl <Franz.Sirl-kernel@@lauterbach.com>:
	* elf32-ppc.c (ppc_elf_relocate_section): Fix last patch.
@
text
@d1234 1
a1234 1
     bfd *abfd;
d1310 1
a1310 1
     bfd *abfd;
d1326 1
a1326 1
     bfd *abfd;
d1329 1
a1329 1
     PTR data;
d1332 1
a1332 1
     char **error_message;
d1526 1
a1526 1
     bfd *abfd;
d1643 1
a1643 1
     bfd *abfd;
d2526 1
a2526 1
     struct bfd_link_info *info;
d2573 1
a2573 1
     struct bfd_link_info *info;
d2640 2
a2641 2
     const char **namep;
     flagword *flagsp;
@


1.3
log
@	From Franz Sirl <Franz.Sirl-kernel@@lauterbach.com>:
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Set unused dynindx
	field to 0, not -1.
	(ppc_elf_finish_dynamic_sections): Check for positive section
	dynindx field, rather than comparing against -1.
	(ppc_elf_relocate_section): Only return false if undefined_symbol
	or reloc_overflow fail, not always upon encountering an error.
@
text
@a3209 1
	      continue;
@


1.2
log
@Franz Sirl <Franz.Sirl-kernel@@lauterbach.com>
        * elf32-ppc.c (ppc_elf_relocate_section): Don't barf on out of
        range undefweak symbols.
        * hash.c: Add missing comma after @@xref{}
        * linker.c: Likewise.
@
text
@d2105 1
a2105 1
	      elf_section_data (s)->dynindx = -1;
d2952 1
a2952 1
	  if (dindx != -1)
d3203 7
a3209 6
	      (*info->callbacks->undefined_symbol)(info,
						   h->root.root.string,
						   input_bfd,
						   input_section,
						   rel->r_offset);
	      ret = false;
d3234 6
a3239 6
	      (*info->callbacks->undefined_symbol) (info,
						    h->root.root.string,
						    input_bfd,
						    input_section,
						    rel->r_offset);
	      ret = false;
d3788 8
a3795 8
	  (*info->callbacks->reloc_overflow)(info,
					     name,
					     howto->name,
					     (bfd_vma) 0,
					     input_bfd,
					     input_section,
					     offset);
	  ret = false;
@


1.1
log
@Initial revision
@
text
@d3754 3
a3756 1
      if (r != bfd_reloc_ok)
d3758 3
a3760 2
	  ret = false;
	  switch (r)
d3762 8
a3769 2
	    default:
	      break;
d3771 2
a3772 3
	    case bfd_reloc_overflow:
	      {
		const char *name;
d3774 12
a3785 9
		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      break;
d3787 8
a3794 15
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }

		(*info->callbacks->reloc_overflow)(info,
						   name,
						   howto->name,
						   (bfd_vma) 0,
						   input_bfd,
						   input_section,
						   offset);
	      }
	      break;

	    }
d3796 2
a3798 1

@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

