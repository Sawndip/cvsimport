head	1.301;
access;
symbols
	sid-snapshot-20180601:1.301
	sid-snapshot-20180501:1.301
	sid-snapshot-20180401:1.301
	sid-snapshot-20180301:1.301
	sid-snapshot-20180201:1.301
	sid-snapshot-20180101:1.301
	sid-snapshot-20171201:1.301
	sid-snapshot-20171101:1.301
	sid-snapshot-20171001:1.301
	sid-snapshot-20170901:1.301
	sid-snapshot-20170801:1.301
	sid-snapshot-20170701:1.301
	sid-snapshot-20170601:1.301
	sid-snapshot-20170501:1.301
	sid-snapshot-20170401:1.301
	sid-snapshot-20170301:1.301
	sid-snapshot-20170201:1.301
	sid-snapshot-20170101:1.301
	sid-snapshot-20161201:1.301
	sid-snapshot-20161101:1.301
	sid-snapshot-20160901:1.301
	sid-snapshot-20160801:1.301
	sid-snapshot-20160701:1.301
	sid-snapshot-20160601:1.301
	sid-snapshot-20160501:1.301
	sid-snapshot-20160401:1.301
	sid-snapshot-20160301:1.301
	sid-snapshot-20160201:1.301
	sid-snapshot-20160101:1.301
	sid-snapshot-20151201:1.301
	sid-snapshot-20151101:1.301
	sid-snapshot-20151001:1.301
	sid-snapshot-20150901:1.301
	sid-snapshot-20150801:1.301
	sid-snapshot-20150701:1.301
	sid-snapshot-20150601:1.301
	sid-snapshot-20150501:1.301
	sid-snapshot-20150401:1.301
	sid-snapshot-20150301:1.301
	sid-snapshot-20150201:1.301
	sid-snapshot-20150101:1.301
	sid-snapshot-20141201:1.301
	sid-snapshot-20141101:1.301
	sid-snapshot-20141001:1.301
	sid-snapshot-20140901:1.301
	sid-snapshot-20140801:1.301
	sid-snapshot-20140701:1.301
	sid-snapshot-20140601:1.301
	sid-snapshot-20140501:1.301
	sid-snapshot-20140401:1.301
	sid-snapshot-20140301:1.301
	sid-snapshot-20140201:1.301
	sid-snapshot-20140101:1.301
	sid-snapshot-20131201:1.301
	sid-snapshot-20131101:1.301
	sid-snapshot-20131001:1.301
	binutils-2_24-branch:1.301.0.2
	binutils-2_24-branchpoint:1.301
	binutils-2_21_1:1.202.2.2
	sid-snapshot-20130901:1.301
	gdb_7_6_1-2013-08-30-release:1.293
	sid-snapshot-20130801:1.298
	sid-snapshot-20130701:1.298
	sid-snapshot-20130601:1.297
	sid-snapshot-20130501:1.296
	gdb_7_6-2013-04-26-release:1.293
	sid-snapshot-20130401:1.296
	binutils-2_23_2:1.270.4.4
	gdb_7_6-branch:1.293.0.2
	gdb_7_6-2013-03-12-branchpoint:1.293
	sid-snapshot-20130301:1.293
	sid-snapshot-20130201:1.289
	sid-snapshot-20130101:1.283
	sid-snapshot-20121201:1.278
	gdb_7_5_1-2012-11-29-release:1.270
	binutils-2_23_1:1.270
	sid-snapshot-20121101:1.278
	binutils-2_23:1.270
	sid-snapshot-20121001:1.276
	sid-snapshot-20120901:1.273
	gdb_7_5-2012-08-17-release:1.270
	sid-snapshot-20120801:1.270
	binutils-2_23-branch:1.270.0.4
	binutils-2_23-branchpoint:1.270
	gdb_7_5-branch:1.270.0.2
	gdb_7_5-2012-07-18-branchpoint:1.270
	sid-snapshot-20120701:1.270
	sid-snapshot-20120601:1.268
	sid-snapshot-20120501:1.257
	binutils-2_22_branch:1.239.2.1.0.2
	gdb_7_4_1-2012-04-26-release:1.244.2.1
	sid-snapshot-20120401:1.254
	sid-snapshot-20120301:1.247
	sid-snapshot-20120201:1.247
	gdb_7_4-2012-01-24-release:1.244.2.1
	sid-snapshot-20120101:1.245
	gdb_7_4-branch:1.244.0.2
	gdb_7_4-2011-12-13-branchpoint:1.244
	sid-snapshot-20111201:1.244
	binutils-2_22:1.239.2.1
	sid-snapshot-20111101:1.244
	sid-snapshot-20111001:1.239
	binutils-2_22-branch:1.239.0.2
	binutils-2_22-branchpoint:1.239
	gdb_7_3_1-2011-09-04-release:1.216
	sid-snapshot-20110901:1.239
	sid-snapshot-20110801:1.237
	gdb_7_3-2011-07-26-release:1.216
	sid-snapshot-20110701:1.235
	sid-snapshot-20110601:1.226
	sid-snapshot-20110501:1.225
	gdb_7_3-branch:1.216.0.2
	gdb_7_3-2011-04-01-branchpoint:1.216
	sid-snapshot-20110401:1.216
	sid-snapshot-20110301:1.212
	sid-snapshot-20110201:1.210
	sid-snapshot-20110101:1.204
	binutils-2_21:1.202
	sid-snapshot-20101201:1.202
	binutils-2_21-branch:1.202.0.2
	binutils-2_21-branchpoint:1.202
	sid-snapshot-20101101:1.202
	sid-snapshot-20101001:1.201
	binutils-2_20_1:1.185.2.1
	gdb_7_2-2010-09-02-release:1.195
	sid-snapshot-20100901:1.200
	sid-snapshot-20100801:1.197
	gdb_7_2-branch:1.195.0.2
	gdb_7_2-2010-07-07-branchpoint:1.195
	sid-snapshot-20100701:1.195
	sid-snapshot-20100601:1.195
	sid-snapshot-20100501:1.195
	sid-snapshot-20100401:1.193
	gdb_7_1-2010-03-18-release:1.190
	sid-snapshot-20100301:1.192
	gdb_7_1-branch:1.190.0.2
	gdb_7_1-2010-02-18-branchpoint:1.190
	sid-snapshot-20100201:1.188
	sid-snapshot-20100101:1.188
	gdb_7_0_1-2009-12-22-release:1.186
	sid-snapshot-20091201:1.187
	sid-snapshot-20091101:1.187
	binutils-2_20:1.185.2.1
	gdb_7_0-2009-10-06-release:1.186
	sid-snapshot-20091001:1.187
	gdb_7_0-branch:1.186.0.2
	gdb_7_0-2009-09-16-branchpoint:1.186
	arc-sim-20090309:1.146
	binutils-arc-20081103-branch:1.148.0.10
	binutils-arc-20081103-branchpoint:1.148
	binutils-2_20-branch:1.185.0.2
	binutils-2_20-branchpoint:1.185
	sid-snapshot-20090901:1.183
	sid-snapshot-20090801:1.180
	msnyder-checkpoint-072509-branch:1.180.0.2
	msnyder-checkpoint-072509-branchpoint:1.180
	sid-snapshot-20090701:1.176
	dje-cgen-play1-branch:1.176.0.2
	dje-cgen-play1-branchpoint:1.176
	sid-snapshot-20090601:1.156
	sid-snapshot-20090501:1.153
	sid-snapshot-20090401:1.152
	arc-20081103-branch:1.148.0.8
	arc-20081103-branchpoint:1.148
	arc-insight_6_8-branch:1.146.0.6
	arc-insight_6_8-branchpoint:1.146
	insight_6_8-branch:1.146.0.4
	insight_6_8-branchpoint:1.146
	sid-snapshot-20090301:1.151
	binutils-2_19_1:1.148
	sid-snapshot-20090201:1.151
	sid-snapshot-20090101:1.151
	reverse-20081226-branch:1.151.0.2
	reverse-20081226-branchpoint:1.151
	sid-snapshot-20081201:1.149
	multiprocess-20081120-branch:1.148.0.6
	multiprocess-20081120-branchpoint:1.148
	sid-snapshot-20081101:1.148
	binutils-2_19:1.148
	sid-snapshot-20081001:1.148
	reverse-20080930-branch:1.148.0.4
	reverse-20080930-branchpoint:1.148
	binutils-2_19-branch:1.148.0.2
	binutils-2_19-branchpoint:1.148
	sid-snapshot-20080901:1.148
	sid-snapshot-20080801:1.148
	reverse-20080717-branch:1.147.0.4
	reverse-20080717-branchpoint:1.147
	sid-snapshot-20080701:1.147
	msnyder-reverse-20080609-branch:1.147.0.2
	msnyder-reverse-20080609-branchpoint:1.147
	drow-reverse-20070409-branch:1.131.0.2
	drow-reverse-20070409-branchpoint:1.131
	sid-snapshot-20080601:1.147
	sid-snapshot-20080501:1.147
	sid-snapshot-20080403:1.147
	sid-snapshot-20080401:1.147
	gdb_6_8-2008-03-27-release:1.146
	sid-snapshot-20080301:1.146
	gdb_6_8-branch:1.146.0.2
	gdb_6_8-2008-02-26-branchpoint:1.146
	sid-snapshot-20080201:1.145
	sid-snapshot-20080101:1.144
	sid-snapshot-20071201:1.144
	sid-snapshot-20071101:1.144
	gdb_6_7_1-2007-10-29-release:1.140
	gdb_6_7-2007-10-10-release:1.140
	sid-snapshot-20071001:1.142
	gdb_6_7-branch:1.140.0.2
	gdb_6_7-2007-09-07-branchpoint:1.140
	binutils-2_18:1.134
	binutils-2_18-branch:1.134.0.2
	binutils-2_18-branchpoint:1.134
	insight_6_6-20070208-release:1.128
	binutils-csl-coldfire-4_1-32:1.112.2.2
	binutils-csl-sourcerygxx-4_1-32:1.112.2.2
	gdb_6_6-2006-12-18-release:1.128
	binutils-csl-innovasic-fido-3_4_4-33:1.112.2.2
	binutils-csl-sourcerygxx-3_4_4-32:1.89
	binutils-csl-coldfire-4_1-30:1.112.2.1
	binutils-csl-sourcerygxx-4_1-30:1.112.2.1
	binutils-csl-coldfire-4_1-28:1.112.2.1
	binutils-csl-sourcerygxx-4_1-29:1.112.2.2
	binutils-csl-sourcerygxx-4_1-28:1.112.2.1
	gdb_6_6-branch:1.128.0.2
	gdb_6_6-2006-11-15-branchpoint:1.128
	binutils-csl-arm-2006q3-27:1.112.2.1
	binutils-csl-sourcerygxx-4_1-27:1.112.2.1
	binutils-csl-arm-2006q3-26:1.112.2.1
	binutils-csl-sourcerygxx-4_1-26:1.112.2.1
	binutils-csl-sourcerygxx-4_1-25:1.112.2.1
	binutils-csl-sourcerygxx-4_1-24:1.112.2.1
	binutils-csl-sourcerygxx-4_1-23:1.112.2.1
	insight_6_5-20061003-release:1.113
	gdb-csl-symbian-6_4_50_20060226-12:1.110
	binutils-csl-sourcerygxx-4_1-21:1.112.2.1
	binutils-csl-arm-2006q3-21:1.112.2.1
	binutils-csl-sourcerygxx-4_1-22:1.112.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.112.2.1
	binutils-csl-sourcerygxx-4_1-20:1.112.2.1
	binutils-csl-arm-2006q3-19:1.112.2.1
	binutils-csl-sourcerygxx-4_1-19:1.112.2.1
	binutils-csl-sourcerygxx-4_1-18:1.112.2.1
	binutils-csl-renesas-4_1-9:1.112.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.108
	binutils-csl-sourcerygxx-3_4_4-25:1.89
	nickrob-async-20060828-mergepoint:1.122
	gdb-csl-symbian-6_4_50_20060226-11:1.110
	binutils-csl-renesas-4_1-8:1.112
	binutils-csl-renesas-4_1-7:1.112
	binutils-csl-renesas-4_1-6:1.112
	gdb-csl-sourcerygxx-4_1-17:1.110
	binutils-csl-sourcerygxx-4_1-17:1.112
	gdb-csl-20060226-branch-local-2:1.110
	gdb-csl-sourcerygxx-4_1-14:1.110
	binutils-csl-sourcerygxx-4_1-14:1.112
	binutils-csl-sourcerygxx-4_1-15:1.112
	gdb-csl-sourcerygxx-4_1-13:1.110
	binutils-csl-sourcerygxx-4_1-13:1.112
	binutils-2_17:1.113
	gdb-csl-sourcerygxx-4_1-12:1.110
	binutils-csl-sourcerygxx-4_1-12:1.112
	gdb-csl-sourcerygxx-3_4_4-21:1.110
	binutils-csl-sourcerygxx-3_4_4-21:1.112
	gdb_6_5-20060621-release:1.113
	binutils-csl-wrs-linux-3_4_4-24:1.89
	binutils-csl-wrs-linux-3_4_4-23:1.89
	gdb-csl-sourcerygxx-4_1-9:1.110
	binutils-csl-sourcerygxx-4_1-9:1.112
	gdb-csl-sourcerygxx-4_1-8:1.110
	binutils-csl-sourcerygxx-4_1-8:1.112
	gdb-csl-sourcerygxx-4_1-7:1.110
	binutils-csl-sourcerygxx-4_1-7:1.112
	gdb-csl-arm-2006q1-6:1.110
	binutils-csl-arm-2006q1-6:1.112
	gdb-csl-sourcerygxx-4_1-6:1.110
	binutils-csl-sourcerygxx-4_1-6:1.112
	binutils-csl-wrs-linux-3_4_4-22:1.89
	gdb-csl-symbian-6_4_50_20060226-10:1.110
	gdb-csl-symbian-6_4_50_20060226-9:1.110
	gdb-csl-symbian-6_4_50_20060226-8:1.110
	gdb-csl-coldfire-4_1-11:1.110
	binutils-csl-coldfire-4_1-11:1.112
	gdb-csl-sourcerygxx-3_4_4-19:1.110
	binutils-csl-sourcerygxx-3_4_4-19:1.112
	gdb-csl-coldfire-4_1-10:1.110
	gdb_6_5-branch:1.113.0.12
	gdb_6_5-2006-05-14-branchpoint:1.113
	binutils-csl-coldfire-4_1-10:1.112
	gdb-csl-sourcerygxx-4_1-5:1.110
	binutils-csl-sourcerygxx-4_1-5:1.112
	nickrob-async-20060513-branch:1.113.0.10
	nickrob-async-20060513-branchpoint:1.113
	gdb-csl-sourcerygxx-4_1-4:1.110
	binutils-csl-sourcerygxx-4_1-4:1.112
	msnyder-reverse-20060502-branch:1.113.0.8
	msnyder-reverse-20060502-branchpoint:1.113
	binutils-csl-wrs-linux-3_4_4-21:1.89
	gdb-csl-morpho-4_1-4:1.110
	binutils-csl-morpho-4_1-4:1.112
	gdb-csl-sourcerygxx-3_4_4-17:1.110
	binutils-csl-sourcerygxx-3_4_4-17:1.112
	binutils-csl-wrs-linux-3_4_4-20:1.89
	readline_5_1-import-branch:1.113.0.6
	readline_5_1-import-branchpoint:1.113
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.110
	binutils-2_17-branch:1.113.0.4
	binutils-2_17-branchpoint:1.113
	gdb-csl-symbian-20060226-branch:1.110.0.4
	gdb-csl-symbian-20060226-branchpoint:1.110
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.110
	msnyder-reverse-20060331-branch:1.113.0.2
	msnyder-reverse-20060331-branchpoint:1.113
	binutils-csl-2_17-branch:1.112.0.2
	binutils-csl-2_17-branchpoint:1.112
	gdb-csl-available-20060303-branch:1.111.0.2
	gdb-csl-available-20060303-branchpoint:1.111
	gdb-csl-20060226-branch:1.110.0.2
	gdb-csl-20060226-branchpoint:1.110
	gdb_6_4-20051202-release:1.108
	msnyder-fork-checkpoint-branch:1.108.0.6
	msnyder-fork-checkpoint-branchpoint:1.108
	gdb-csl-gxxpro-6_3-branch:1.108.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.108
	gdb_6_4-branch:1.108.0.2
	gdb_6_4-2005-11-01-branchpoint:1.108
	gdb-csl-arm-20051020-branch:1.107.0.2
	gdb-csl-arm-20051020-branchpoint:1.107
	binutils-csl-gxxpro-3_4-branch:1.89.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.89
	binutils-2_16_1:1.89
	msnyder-tracepoint-checkpoint-branch:1.95.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.95
	gdb-csl-arm-20050325-2005-q1b:1.90
	binutils-csl-arm-2005q1b:1.89
	binutils-2_16:1.89
	gdb-csl-arm-20050325-2005-q1a:1.90
	binutils-csl-arm-2005q1a:1.89
	csl-arm-20050325-branch:1.90.0.2
	csl-arm-20050325-branchpoint:1.90
	binutils-csl-arm-2005q1-branch:1.89.0.4
	binutils-csl-arm-2005q1-branchpoint:1.89
	binutils-2_16-branch:1.89.0.2
	binutils-2_16-branchpoint:1.89
	csl-arm-2004-q3d:1.87
	gdb_6_3-20041109-release:1.86
	gdb_6_3-branch:1.86.0.2
	gdb_6_3-20041019-branchpoint:1.86
	csl-arm-2004-q3:1.85
	drow_intercu-merge-20040921:1.85
	drow_intercu-merge-20040915:1.83
	jimb-gdb_6_2-e500-branch:1.81.0.6
	jimb-gdb_6_2-e500-branchpoint:1.81
	gdb_6_2-20040730-release:1.81
	gdb_6_2-branch:1.81.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.81
	gdb_6_1_1-20040616-release:1.72
	binutils-2_15:1.72.6.1
	binutils-2_15-branchpoint:1.72
	csl-arm-2004-q1a:1.77
	csl-arm-2004-q1:1.75
	gdb_6_1-2004-04-05-release:1.72
	drow_intercu-merge-20040402:1.75
	drow_intercu-merge-20040327:1.74
	ezannoni_pie-20040323-branch:1.73.0.2
	ezannoni_pie-20040323-branchpoint:1.73
	cagney_tramp-20040321-mergepoint:1.72
	cagney_tramp-20040309-branch:1.72.0.12
	cagney_tramp-20040309-branchpoint:1.72
	gdb_6_1-branch:1.72.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.72
	drow_intercu-20040221-branch:1.72.0.8
	drow_intercu-20040221-branchpoint:1.72
	binutils-2_15-branch:1.72.0.6
	cagney_bfdfile-20040213-branch:1.72.0.4
	cagney_bfdfile-20040213-branchpoint:1.72
	drow-cplus-merge-20040208:1.72
	carlton_dictionary-20040126-merge:1.72
	cagney_bigcore-20040122-branch:1.72.0.2
	cagney_bigcore-20040122-branchpoint:1.72
	drow-cplus-merge-20040113:1.72
	csl-arm-2003-q4:1.72
	drow-cplus-merge-20031224:1.72
	drow-cplus-merge-20031220:1.72
	carlton_dictionary-20031215-merge:1.72
	drow-cplus-merge-20031214:1.72
	carlton-dictionary-20031111-merge:1.70
	gdb_6_0-2003-10-04-release:1.60
	kettenis_sparc-20030918-branch:1.67.0.6
	kettenis_sparc-20030918-branchpoint:1.67
	carlton_dictionary-20030917-merge:1.67
	ezannoni_pie-20030916-branchpoint:1.67
	ezannoni_pie-20030916-branch:1.67.0.4
	cagney_x86i386-20030821-branch:1.67.0.2
	cagney_x86i386-20030821-branchpoint:1.67
	carlton_dictionary-20030805-merge:1.64
	carlton_dictionary-20030627-merge:1.61
	gdb_6_0-branch:1.60.0.6
	gdb_6_0-2003-06-23-branchpoint:1.60
	jimb-ppc64-linux-20030613-branch:1.60.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.60
	binutils-2_14:1.56.18.1
	cagney_convert-20030606-branch:1.60.0.2
	cagney_convert-20030606-branchpoint:1.60
	cagney_writestrings-20030508-branch:1.59.0.8
	cagney_writestrings-20030508-branchpoint:1.59
	jimb-ppc64-linux-20030528-branch:1.59.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.59
	carlton_dictionary-20030523-merge:1.59
	cagney_fileio-20030521-branch:1.59.0.4
	cagney_fileio-20030521-branchpoint:1.59
	kettenis_i386newframe-20030517-mergepoint:1.59
	jimb-ppc64-linux-20030509-branch:1.59.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.59
	kettenis_i386newframe-20030504-mergepoint:1.57
	carlton_dictionary-20030430-merge:1.56
	binutils-2_14-branch:1.56.0.18
	binutils-2_14-branchpoint:1.56
	kettenis_i386newframe-20030419-branch:1.56.0.16
	kettenis_i386newframe-20030419-branchpoint:1.56
	carlton_dictionary-20030416-merge:1.56
	cagney_frameaddr-20030409-mergepoint:1.56
	kettenis_i386newframe-20030406-branch:1.56.0.14
	kettenis_i386newframe-20030406-branchpoint:1.56
	cagney_frameaddr-20030403-branchpoint:1.56
	cagney_frameaddr-20030403-branch:1.56.0.12
	cagney_framebase-20030330-mergepoint:1.56
	cagney_framebase-20030326-branch:1.56.0.10
	cagney_framebase-20030326-branchpoint:1.56
	cagney_lazyid-20030317-branch:1.56.0.8
	cagney_lazyid-20030317-branchpoint:1.56
	kettenis-i386newframe-20030316-mergepoint:1.56
	offbyone-20030313-branch:1.56.0.6
	offbyone-20030313-branchpoint:1.56
	kettenis-i386newframe-20030308-branch:1.56.0.4
	kettenis-i386newframe-20030308-branchpoint:1.56
	carlton_dictionary-20030305-merge:1.56
	cagney_offbyone-20030303-branch:1.56.0.2
	cagney_offbyone-20030303-branchpoint:1.56
	carlton_dictionary-20030207-merge:1.54
	interps-20030202-branch:1.54.0.4
	interps-20030202-branchpoint:1.54
	cagney-unwind-20030108-branch:1.54.0.2
	cagney-unwind-20030108-branchpoint:1.54
	binutils-2_13_2_1:1.47.2.1
	binutils-2_13_2:1.47.2.1
	carlton_dictionary-20021223-merge:1.54
	gdb_5_3-2002-12-12-release:1.49
	carlton_dictionary-20021115-merge:1.52
	binutils-2_13_1:1.47.2.1
	kseitz_interps-20021105-merge:1.52
	kseitz_interps-20021103-merge:1.52
	drow-cplus-merge-20021020:1.52
	drow-cplus-merge-20021025:1.52
	carlton_dictionary-20021025-merge:1.52
	carlton_dictionary-20021011-merge:1.52
	drow-cplus-branch:1.52.0.2
	drow-cplus-branchpoint:1.52
	kseitz_interps-20020930-merge:1.50
	carlton_dictionary-20020927-merge:1.50
	carlton_dictionary-branch:1.49.0.10
	carlton_dictionary-20020920-branchpoint:1.49
	sid-20020905-branchpoint:1.49
	sid-20020905-branch:1.49.0.8
	gdb_5_3-branch:1.49.0.6
	gdb_5_3-2002-09-04-branchpoint:1.49
	kseitz_interps-20020829-merge:1.49
	cagney_sysregs-20020825-branch:1.49.0.4
	cagney_sysregs-20020825-branchpoint:1.49
	readline_4_3-import-branch:1.49.0.2
	readline_4_3-import-branchpoint:1.49
	binutils-2_13:1.47
	gdb_5_2_1-2002-07-23-release:1.37
	binutils-2_13-branchpoint:1.47
	binutils-2_13-branch:1.47.0.2
	kseitz_interps-20020528-branch:1.42.0.2
	kseitz_interps-20020528-branchpoint:1.42
	cagney_regbuf-20020515-branch:1.41.0.2
	cagney_regbuf-20020515-branchpoint:1.41
	binutils-2_12_1:1.34.2.5
	jimb-macro-020506-branch:1.40.0.2
	jimb-macro-020506-branchpoint:1.40
	gdb_5_2-2002-04-29-release:1.37
	binutils-2_12:1.34.2.2
	gdb_5_2-branch:1.37.0.2
	gdb_5_2-2002-03-03-branchpoint:1.37
	binutils-2_12-branch:1.34.0.2
	binutils-2_12-branchpoint:1.34
	gdb_5_1_1-2002-01-24-release:1.21
	gdb_5_1_0_1-2002-01-03-release:1.21
	cygnus_cvs_20020108_pre:1.34
	gdb_5_1_0_1-2002-01-03-branch:1.21.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.21
	gdb_5_1-2001-11-21-release:1.21
	gdb_s390-2001-09-26-branch:1.21.0.4
	gdb_s390-2001-09-26-branchpoint:1.21
	gdb_5_1-2001-07-29-branch:1.21.0.2
	gdb_5_1-2001-07-29-branchpoint:1.21
	binutils-2_11_2:1.4.2.11
	binutils-2_11_1:1.4.2.10
	binutils-2_11:1.4.2.7
	x86_64versiong3:1.10
	binutils-2_11-branch:1.4.0.2
	insight-precleanup-2001-01-01:1.2
	binutils_latest_snapshot:1.301;
locks; strict;
comment	@ * @;


1.301
date	2013.08.29.10.25.26;	author jakub;	state Exp;
branches;
next	1.300;

1.300
date	2013.08.26.19.27.24;	author roland;	state Exp;
branches;
next	1.299;

1.299
date	2013.08.23.19.29.13;	author hjl;	state Exp;
branches;
next	1.298;

1.298
date	2013.06.28.15.07.55;	author hjl;	state Exp;
branches;
next	1.297;

1.297
date	2013.05.07.17.03.52;	author willnewton;	state Exp;
branches;
next	1.296;

1.296
date	2013.03.30.00.38.39;	author hjl;	state Exp;
branches;
next	1.295;

1.295
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.294;

1.294
date	2013.03.25.06.00.06;	author amodra;	state Exp;
branches;
next	1.293;

1.293
date	2013.02.21.03.02.30;	author amodra;	state Exp;
branches;
next	1.292;

1.292
date	2013.02.11.05.30.54;	author amodra;	state Exp;
branches;
next	1.291;

1.291
date	2013.02.10.04.36.32;	author amodra;	state Exp;
branches;
next	1.290;

1.290
date	2013.02.07.02.15.29;	author hjl;	state Exp;
branches;
next	1.289;

1.289
date	2013.01.18.22.50.29;	author hjl;	state Exp;
branches;
next	1.288;

1.288
date	2013.01.17.23.36.09;	author hjl;	state Exp;
branches;
next	1.287;

1.287
date	2013.01.16.22.41.03;	author hjl;	state Exp;
branches;
next	1.286;

1.286
date	2013.01.16.21.34.46;	author hjl;	state Exp;
branches;
next	1.285;

1.285
date	2013.01.15.17.30.49;	author hjl;	state Exp;
branches;
next	1.284;

1.284
date	2013.01.13.00.30.20;	author hjl;	state Exp;
branches;
next	1.283;

1.283
date	2012.12.21.20.54.59;	author hjl;	state Exp;
branches;
next	1.282;

1.282
date	2012.12.21.18.15.22;	author hjl;	state Exp;
branches;
next	1.281;

1.281
date	2012.12.16.23.01.13;	author hjl;	state Exp;
branches;
next	1.280;

1.280
date	2012.12.16.20.31.07;	author hjl;	state Exp;
branches;
next	1.279;

1.279
date	2012.12.13.21.07.15;	author hjl;	state Exp;
branches;
next	1.278;

1.278
date	2012.10.30.08.36.10;	author hjl;	state Exp;
branches;
next	1.277;

1.277
date	2012.10.25.13.36.08;	author hjl;	state Exp;
branches;
next	1.276;

1.276
date	2012.09.18.00.41.59;	author hjl;	state Exp;
branches;
next	1.275;

1.275
date	2012.09.17.18.31.15;	author hjl;	state Exp;
branches;
next	1.274;

1.274
date	2012.09.02.12.17.27;	author hjl;	state Exp;
branches;
next	1.273;

1.273
date	2012.09.01.02.50.12;	author hjl;	state Exp;
branches;
next	1.272;

1.272
date	2012.08.31.20.41.40;	author hjl;	state Exp;
branches;
next	1.271;

1.271
date	2012.08.31.04.26.16;	author hjl;	state Exp;
branches;
next	1.270;

1.270
date	2012.06.29.21.54.44;	author hjl;	state Exp;
branches
	1.270.4.1;
next	1.269;

1.269
date	2012.06.29.14.46.02;	author amodra;	state Exp;
branches;
next	1.268;

1.268
date	2012.05.25.16.20.15;	author hjl;	state Exp;
branches;
next	1.267;

1.267
date	2012.05.25.01.12.20;	author amodra;	state Exp;
branches;
next	1.266;

1.266
date	2012.05.22.15.54.58;	author hjl;	state Exp;
branches;
next	1.265;

1.265
date	2012.05.22.14.46.43;	author hjl;	state Exp;
branches;
next	1.264;

1.264
date	2012.05.22.14.05.17;	author hjl;	state Exp;
branches;
next	1.263;

1.263
date	2012.05.18.22.26.17;	author hjl;	state Exp;
branches;
next	1.262;

1.262
date	2012.05.11.00.50.42;	author hjl;	state Exp;
branches;
next	1.261;

1.261
date	2012.05.10.20.46.33;	author hjl;	state Exp;
branches;
next	1.260;

1.260
date	2012.05.10.17.15.16;	author hjl;	state Exp;
branches;
next	1.259;

1.259
date	2012.05.10.03.25.17;	author hjl;	state Exp;
branches;
next	1.258;

1.258
date	2012.05.07.03.27.52;	author macro;	state Exp;
branches;
next	1.257;

1.257
date	2012.04.24.05.12.36;	author amodra;	state Exp;
branches;
next	1.256;

1.256
date	2012.04.17.19.53.19;	author roland;	state Exp;
branches;
next	1.255;

1.255
date	2012.04.03.16.01.28;	author roland;	state Exp;
branches;
next	1.254;

1.254
date	2012.03.20.18.16.29;	author hjl;	state Exp;
branches;
next	1.253;

1.253
date	2012.03.16.23.19.46;	author roland;	state Exp;
branches;
next	1.252;

1.252
date	2012.03.15.18.20.22;	author roland;	state Exp;
branches;
next	1.251;

1.251
date	2012.03.15.16.37.25;	author roland;	state Exp;
branches;
next	1.250;

1.250
date	2012.03.13.06.04.36;	author amodra;	state Exp;
branches;
next	1.249;

1.249
date	2012.03.09.16.28.36;	author hjl;	state Exp;
branches;
next	1.248;

1.248
date	2012.03.06.20.15.56;	author jakub;	state Exp;
branches;
next	1.247;

1.247
date	2012.01.10.20.18.16;	author hjl;	state Exp;
branches;
next	1.246;

1.246
date	2012.01.05.07.50.44;	author jkratoch;	state Exp;
branches;
next	1.245;

1.245
date	2011.12.15.17.30.58;	author hjl;	state Exp;
branches;
next	1.244;

1.244
date	2011.10.21.19.37.14;	author hjl;	state Exp;
branches
	1.244.2.1;
next	1.243;

1.243
date	2011.10.21.16.16.51;	author hjl;	state Exp;
branches;
next	1.242;

1.242
date	2011.10.21.15.13.36;	author hjl;	state Exp;
branches;
next	1.241;

1.241
date	2011.10.19.23.02.50;	author amodra;	state Exp;
branches;
next	1.240;

1.240
date	2011.10.19.07.17.19;	author amodra;	state Exp;
branches;
next	1.239;

1.239
date	2011.08.12.19.42.39;	author hjl;	state Exp;
branches
	1.239.2.1;
next	1.238;

1.238
date	2011.08.01.23.04.21;	author hjl;	state Exp;
branches;
next	1.237;

1.237
date	2011.07.22.20.22.31;	author hjl;	state Exp;
branches;
next	1.236;

1.236
date	2011.07.05.19.04.41;	author hjl;	state Exp;
branches;
next	1.235;

1.235
date	2011.06.25.18.03.03;	author hjl;	state Exp;
branches;
next	1.234;

1.234
date	2011.06.25.00.43.15;	author jkratoch;	state Exp;
branches;
next	1.233;

1.233
date	2011.06.20.13.18.47;	author jakub;	state Exp;
branches;
next	1.232;

1.232
date	2011.06.19.21.22.15;	author hjl;	state Exp;
branches;
next	1.231;

1.231
date	2011.06.16.22.08.11;	author hjl;	state Exp;
branches;
next	1.230;

1.230
date	2011.06.16.17.42.59;	author hjl;	state Exp;
branches;
next	1.229;

1.229
date	2011.06.13.00.59.13;	author amodra;	state Exp;
branches;
next	1.228;

1.228
date	2011.06.09.05.51.09;	author hjl;	state Exp;
branches;
next	1.227;

1.227
date	2011.06.01.19.42.01;	author hjl;	state Exp;
branches;
next	1.226;

1.226
date	2011.05.26.13.22.04;	author hjl;	state Exp;
branches;
next	1.225;

1.225
date	2011.05.01.12.04.10;	author amodra;	state Exp;
branches;
next	1.224;

1.224
date	2011.04.30.17.56.35;	author hjl;	state Exp;
branches;
next	1.223;

1.223
date	2011.04.23.01.16.31;	author hjl;	state Exp;
branches;
next	1.222;

1.222
date	2011.04.21.22.25.39;	author hjl;	state Exp;
branches;
next	1.221;

1.221
date	2011.04.21.21.16.51;	author hjl;	state Exp;
branches;
next	1.220;

1.220
date	2011.04.11.08.13.21;	author nickc;	state Exp;
branches;
next	1.219;

1.219
date	2011.04.09.16.48.39;	author hjl;	state Exp;
branches;
next	1.218;

1.218
date	2011.04.09.15.41.41;	author hjl;	state Exp;
branches;
next	1.217;

1.217
date	2011.04.09.15.37.57;	author hjl;	state Exp;
branches;
next	1.216;

1.216
date	2011.03.12.14.38.31;	author hjl;	state Exp;
branches;
next	1.215;

1.215
date	2011.03.06.18.27.03;	author msnyder;	state Exp;
branches;
next	1.214;

1.214
date	2011.03.04.00.38.29;	author msnyder;	state Exp;
branches;
next	1.213;

1.213
date	2011.03.03.22.11.32;	author hjl;	state Exp;
branches;
next	1.212;

1.212
date	2011.02.17.13.51.52;	author hjl;	state Exp;
branches;
next	1.211;

1.211
date	2011.02.16.14.58.18;	author hjl;	state Exp;
branches;
next	1.210;

1.210
date	2011.01.18.20.45.06;	author hjl;	state Exp;
branches;
next	1.209;

1.209
date	2011.01.18.20.41.08;	author hjl;	state Exp;
branches;
next	1.208;

1.208
date	2011.01.15.15.49.48;	author hjl;	state Exp;
branches;
next	1.207;

1.207
date	2011.01.14.22.48.11;	author hjl;	state Exp;
branches;
next	1.206;

1.206
date	2011.01.14.04.23.59;	author hjl;	state Exp;
branches;
next	1.205;

1.205
date	2011.01.06.18.45.05;	author hjl;	state Exp;
branches;
next	1.204;

1.204
date	2010.12.31.00.34.59;	author hjl;	state Exp;
branches;
next	1.203;

1.203
date	2010.12.31.00.33.32;	author hjl;	state Exp;
branches;
next	1.202;

1.202
date	2010.10.21.12.29.02;	author ro;	state Exp;
branches
	1.202.2.1;
next	1.201;

1.201
date	2010.10.01.04.28.04;	author hjl;	state Exp;
branches;
next	1.200;

1.200
date	2010.08.25.14.53.45;	author hjl;	state Exp;
branches;
next	1.199;

1.199
date	2010.08.18.12.24.06;	author palves;	state Exp;
branches;
next	1.198;

1.198
date	2010.08.13.20.50.25;	author hjl;	state Exp;
branches;
next	1.197;

1.197
date	2010.07.14.00.30.57;	author hjl;	state Exp;
branches;
next	1.196;

1.196
date	2010.07.13.16.59.13;	author hjl;	state Exp;
branches;
next	1.195;

1.195
date	2010.04.30.18.27.31;	author hjl;	state Exp;
branches;
next	1.194;

1.194
date	2010.04.19.08.46.48;	author nickc;	state Exp;
branches;
next	1.193;

1.193
date	2010.03.05.19.48.55;	author ro;	state Exp;
branches;
next	1.192;

1.192
date	2010.02.20.15.47.03;	author hjl;	state Exp;
branches;
next	1.191;

1.191
date	2010.02.19.05.07.49;	author hjl;	state Exp;
branches;
next	1.190;

1.190
date	2010.02.05.14.58.11;	author hjl;	state Exp;
branches;
next	1.189;

1.189
date	2010.02.04.09.16.41;	author nickc;	state Exp;
branches;
next	1.188;

1.188
date	2009.12.11.13.42.03;	author nickc;	state Exp;
branches;
next	1.187;

1.187
date	2009.09.29.14.37.57;	author hjl;	state Exp;
branches;
next	1.186;

1.186
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.185;

1.185
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches
	1.185.2.1;
next	1.184;

1.184
date	2009.09.01.21.27.47;	author hjl;	state Exp;
branches;
next	1.183;

1.183
date	2009.08.30.18.31.53;	author hjl;	state Exp;
branches;
next	1.182;

1.182
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.181;

1.181
date	2009.08.02.23.55.49;	author hjl;	state Exp;
branches;
next	1.180;

1.180
date	2009.07.25.14.58.53;	author hjl;	state Exp;
branches;
next	1.179;

1.179
date	2009.07.23.21.22.17;	author hjl;	state Exp;
branches;
next	1.178;

1.178
date	2009.07.16.14.23.10;	author hjl;	state Exp;
branches;
next	1.177;

1.177
date	2009.07.10.10.04.20;	author amodra;	state Exp;
branches;
next	1.176;

1.176
date	2009.06.20.00.43.21;	author hjl;	state Exp;
branches;
next	1.175;

1.175
date	2009.06.19.16.00.32;	author hjl;	state Exp;
branches;
next	1.174;

1.174
date	2009.06.18.15.49.39;	author hjl;	state Exp;
branches;
next	1.173;

1.173
date	2009.06.18.14.18.29;	author amodra;	state Exp;
branches;
next	1.172;

1.172
date	2009.06.18.12.49.41;	author hjl;	state Exp;
branches;
next	1.171;

1.171
date	2009.06.18.00.45.14;	author hjl;	state Exp;
branches;
next	1.170;

1.170
date	2009.06.16.17.45.08;	author hjl;	state Exp;
branches;
next	1.169;

1.169
date	2009.06.16.13.41.10;	author hjl;	state Exp;
branches;
next	1.168;

1.168
date	2009.06.15.18.25.20;	author hjl;	state Exp;
branches;
next	1.167;

1.167
date	2009.06.15.17.23.43;	author hjl;	state Exp;
branches;
next	1.166;

1.166
date	2009.06.15.13.12.33;	author hjl;	state Exp;
branches;
next	1.165;

1.165
date	2009.06.14.22.13.30;	author hjl;	state Exp;
branches;
next	1.164;

1.164
date	2009.06.14.05.53.55;	author hjl;	state Exp;
branches;
next	1.163;

1.163
date	2009.06.14.05.45.09;	author hjl;	state Exp;
branches;
next	1.162;

1.162
date	2009.06.14.01.39.45;	author hjl;	state Exp;
branches;
next	1.161;

1.161
date	2009.06.06.22.39.24;	author hjl;	state Exp;
branches;
next	1.160;

1.160
date	2009.06.06.11.48.11;	author hjl;	state Exp;
branches;
next	1.159;

1.159
date	2009.06.03.16.58.12;	author hjl;	state Exp;
branches;
next	1.158;

1.158
date	2009.06.03.12.35.18;	author hjl;	state Exp;
branches;
next	1.157;

1.157
date	2009.06.02.17.31.41;	author hjl;	state Exp;
branches;
next	1.156;

1.156
date	2009.06.01.13.11.52;	author hjl;	state Exp;
branches;
next	1.155;

1.155
date	2009.05.29.18.30.30;	author hjl;	state Exp;
branches;
next	1.154;

1.154
date	2009.05.26.22.18.22;	author hjl;	state Exp;
branches;
next	1.153;

1.153
date	2009.04.30.15.47.10;	author nickc;	state Exp;
branches;
next	1.152;

1.152
date	2009.03.12.17.13.41;	author hjl;	state Exp;
branches;
next	1.151;

1.151
date	2008.12.23.09.01.45;	author nickc;	state Exp;
branches;
next	1.150;

1.150
date	2008.12.03.14.50.57;	author nickc;	state Exp;
branches;
next	1.149;

1.149
date	2008.11.25.13.03.56;	author nickc;	state Exp;
branches;
next	1.148;

1.148
date	2008.07.28.18.07.05;	author aoliva;	state Exp;
branches;
next	1.147;

1.147
date	2008.03.16.22.26.23;	author hjl;	state Exp;
branches;
next	1.146;

1.146
date	2008.02.12.11.32.31;	author nickc;	state Exp;
branches;
next	1.145;

1.145
date	2008.01.11.09.07.04;	author gingold;	state Exp;
branches;
next	1.144;

1.144
date	2007.10.18.09.13.51;	author amodra;	state Exp;
branches;
next	1.143;

1.143
date	2007.10.04.13.41.29;	author nickc;	state Exp;
branches;
next	1.142;

1.142
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.141;

1.141
date	2007.09.11.15.44.19;	author jbeulich;	state Exp;
branches;
next	1.140;

1.140
date	2007.08.24.21.47.53;	author hjl;	state Exp;
branches;
next	1.139;

1.139
date	2007.08.23.16.13.37;	author hjl;	state Exp;
branches;
next	1.138;

1.138
date	2007.08.22.13.44.37;	author hjl;	state Exp;
branches;
next	1.137;

1.137
date	2007.08.21.13.52.54;	author hjl;	state Exp;
branches;
next	1.136;

1.136
date	2007.08.20.19.13.04;	author hjl;	state Exp;
branches;
next	1.135;

1.135
date	2007.08.14.19.48.21;	author hjl;	state Exp;
branches;
next	1.134;

1.134
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	2007.05.15.13.55.54;	author hjl;	state Exp;
branches;
next	1.132;

1.132
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2007.03.26.12.23.02;	author amodra;	state Exp;
branches;
next	1.130;

1.130
date	2007.03.14.02.56.45;	author hjl;	state Exp;
branches;
next	1.129;

1.129
date	2007.03.07.08.54.35;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2006.11.03.00.58.09;	author drow;	state Exp;
branches;
next	1.127;

1.127
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2006.09.29.13.24.11;	author hjl;	state Exp;
branches;
next	1.125;

1.125
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.123;

1.123
date	2006.09.07.17.16.31;	author hjl;	state Exp;
branches;
next	1.122;

1.122
date	2006.08.02.16.25.13;	author nickc;	state Exp;
branches;
next	1.121;

1.121
date	2006.07.10.21.40.23;	author jakub;	state Exp;
branches;
next	1.120;

1.120
date	2006.06.30.14.16.13;	author hjl;	state Exp;
branches;
next	1.119;

1.119
date	2006.06.23.02.58.01;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.116;

1.116
date	2006.05.26.14.01.08;	author hjl;	state Exp;
branches;
next	1.115;

1.115
date	2006.05.26.03.04.09;	author hjl;	state Exp;
branches;
next	1.114;

1.114
date	2006.05.26.02.44.14;	author hjl;	state Exp;
branches;
next	1.113;

1.113
date	2006.03.23.08.23.09;	author aj;	state Exp;
branches;
next	1.112;

1.112
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches
	1.112.2.1;
next	1.111;

1.111
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.110;

1.110
date	2006.02.21.01.51.59;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2006.01.18.21.07.48;	author aoliva;	state Exp;
branches;
next	1.108;

1.108
date	2005.10.25.16.19.07;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2005.08.31.23.45.46;	author dj;	state Exp;
branches;
next	1.106;

1.106
date	2005.08.25.02.32.11;	author hjl;	state Exp;
branches;
next	1.105;

1.105
date	2005.08.18.01.28.26;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2005.08.04.14.49.55;	author hjl;	state Exp;
branches;
next	1.103;

1.103
date	2005.08.03.16.30.32;	author hjl;	state Exp;
branches;
next	1.102;

1.102
date	2005.07.27.07.01.30;	author jbeulich;	state Exp;
branches;
next	1.101;

1.101
date	2005.07.25.15.41.03;	author hjl;	state Exp;
branches;
next	1.100;

1.100
date	2005.07.18.06.23.39;	author jbeulich;	state Exp;
branches;
next	1.99;

1.99
date	2005.07.08.06.20.05;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2005.07.05.09.44.20;	author jakub;	state Exp;
branches;
next	1.97;

1.97
date	2005.06.20.12.59.49;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2005.06.17.08.03.48;	author jbeulich;	state Exp;
branches;
next	1.95;

1.95
date	2005.05.17.16.43.02;	author hjl;	state Exp;
branches;
next	1.94;

1.94
date	2005.05.05.14.33.59;	author hjl;	state Exp;
branches;
next	1.93;

1.93
date	2005.05.04.15.53.27;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	2005.05.04.11.00.19;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2005.05.04.07.19.25;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	2005.03.20.23.36.18;	author hjl;	state Exp;
branches;
next	1.89;

1.89
date	2005.02.06.18.11.30;	author hjl;	state Exp;
branches;
next	1.88;

1.88
date	2005.01.11.09.32.53;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2004.10.21.15.28.26;	author hjl;	state Exp;
branches;
next	1.86;

1.86
date	2004.10.08.13.54.57;	author drow;	state Exp;
branches;
next	1.85;

1.85
date	2004.09.17.07.14.30;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2004.09.16.14.52.07;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2004.08.13.03.15.59;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2004.08.09.08.53.51;	author jakub;	state Exp;
branches;
next	1.81;

1.81
date	2004.06.24.15.07.02;	author hjl;	state Exp;
branches;
next	1.80;

1.80
date	2004.06.24.04.46.22;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2004.06.12.11.30.10;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2004.05.11.17.08.37;	author jakub;	state Exp;
branches;
next	1.77;

1.77
date	2004.04.23.08.51.10;	author jakub;	state Exp;
branches;
next	1.76;

1.76
date	2004.04.22.14.45.31;	author jakub;	state Exp;
branches;
next	1.75;

1.75
date	2004.03.27.10.58.07;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2004.03.25.12.48.41;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2004.03.22.02.28.17;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2003.12.04.03.03.27;	author amodra;	state Exp;
branches
	1.72.6.1
	1.72.8.1;
next	1.71;

1.71
date	2003.11.17.21.31.11;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2003.11.04.06.16.35;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.67;

1.67
date	2003.08.20.08.37.18;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2003.08.11.14.26.11;	author jakub;	state Exp;
branches;
next	1.65;

1.65
date	2003.08.07.08.38.08;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2003.07.21.00.24.10;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2003.07.04.13.53.37;	author jakub;	state Exp;
branches;
next	1.62;

1.62
date	2003.06.29.05.57.36;	author aj;	state Exp;
branches;
next	1.61;

1.61
date	2003.06.25.06.40.24;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.30.15.50.10;	author jakub;	state Exp;
branches;
next	1.59;

1.59
date	2003.05.05.14.12.05;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2003.05.05.08.50.43;	author aj;	state Exp;
branches;
next	1.57;

1.57
date	2003.05.02.08.19.12;	author aj;	state Exp;
branches;
next	1.56;

1.56
date	2003.02.19.14.14.16;	author amodra;	state Exp;
branches
	1.56.16.1
	1.56.18.1;
next	1.55;

1.55
date	2003.02.17.18.24.40;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2002.11.30.08.39.39;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2002.11.28.11.55.42;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2002.10.01.09.15.34;	author jakub;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2002.10.01.09.10.45;	author jakub;	state Exp;
branches;
next	1.50;

1.50
date	2002.09.27.19.29.16;	author jakub;	state Exp;
branches;
next	1.49;

1.49
date	2002.08.22.01.27.20;	author amodra;	state Exp;
branches
	1.49.10.1;
next	1.48;

1.48
date	2002.07.23.12.29.33;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.11.05.33.28;	author amodra;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2002.07.01.08.47.13;	author schwab;	state Exp;
branches;
next	1.45;

1.45
date	2002.07.01.08.06.46;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2002.07.01.06.42.27;	author aj;	state Exp;
branches;
next	1.43;

1.43
date	2002.06.03.01.57.10;	author kazu;	state Exp;
branches;
next	1.42;

1.42
date	2002.05.24.14.25.08;	author mludvig;	state Exp;
branches
	1.42.2.1;
next	1.41;

1.41
date	2002.05.07.00.16.52;	author amodra;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2002.04.28.12.29.46;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2002.04.04.19.53.37;	author drow;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.28.03.27.45;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.22.10.03.03;	author jakub;	state Exp;
branches;
next	1.36;

1.36
date	2002.02.21.15.31.53;	author aj;	state Exp;
branches;
next	1.35;

1.35
date	2002.02.19.12.40.29;	author jakub;	state Exp;
branches;
next	1.34;

1.34
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.32;

1.32
date	2001.11.23.12.17.17;	author jakub;	state Exp;
branches;
next	1.31;

1.31
date	2001.11.10.00.23.34;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.15.07.28.45;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.09.29.06.21.59;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.28.12.54.53;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.20.23.30.36;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.23.18.14.29;	author aj;	state Exp;
branches;
next	1.22;

1.22
date	2001.08.10.19.29.59;	author aj;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.21.16.33.13;	author aj;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.19.13.30.40;	author aj;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.07.14.45.36;	author aj;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.01.11.52.11;	author aj;	state Exp;
branches;
next	1.17;

1.17
date	2001.05.30.18.44.46;	author aj;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.28.15.45.47;	author aj;	state Exp;
branches;
next	1.15;

1.15
date	2001.04.30.10.30.05;	author aj;	state Exp;
branches;
next	1.14;

1.14
date	2001.04.29.13.42.45;	author aj;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.23.08.00.13;	author aj;	state Exp;
branches;
next	1.12;

1.12
date	2001.04.19.09.39.28;	author aj;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.07.13.49.11;	author aj;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.28.12.32.10;	author aj;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.26.07.50.22;	author aj;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.20.08.01.32;	author aj;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.14.10.57.47;	author aj;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.12.16.54.08;	author hubicka;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.12.16.47.13;	author hubicka;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.23.20.27.53;	author kazu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.01.23.10.49.50;	author aj;	state Exp;
branches;
next	1.2;

1.2
date	2000.12.07.19.31.48;	author kazu;	state Exp;
branches;
next	1.1;

1.1
date	2000.11.30.19.16.54;	author nickc;	state Exp;
branches;
next	;

1.270.4.1
date	2012.12.20.18.51.09;	author hjl;	state Exp;
branches;
next	1.270.4.2;

1.270.4.2
date	2012.12.20.18.52.20;	author hjl;	state Exp;
branches;
next	1.270.4.3;

1.270.4.3
date	2012.12.21.18.21.06;	author hjl;	state Exp;
branches;
next	1.270.4.4;

1.270.4.4
date	2012.12.22.18.25.09;	author hjl;	state Exp;
branches;
next	1.270.4.5;

1.270.4.5
date	2013.08.26.19.28.36;	author roland;	state Exp;
branches;
next	;

1.244.2.1
date	2012.01.05.07.57.23;	author jkratoch;	state Exp;
branches;
next	;

1.239.2.1
date	2011.10.25.03.14.16;	author amodra;	state Exp;
branches;
next	1.239.2.2;

1.239.2.2
date	2012.01.10.20.34.59;	author hjl;	state Exp;
branches;
next	1.239.2.3;

1.239.2.3
date	2012.05.11.12.24.30;	author nickc;	state Exp;
branches;
next	;

1.202.2.1
date	2011.04.27.07.17.38;	author amodra;	state Exp;
branches;
next	1.202.2.2;

1.202.2.2
date	2011.05.25.17.41.35;	author hjl;	state Exp;
branches;
next	;

1.185.2.1
date	2009.09.09.21.40.19;	author nickc;	state Exp;
branches;
next	;

1.112.2.1
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	1.112.2.2;

1.112.2.2
date	2006.11.29.16.31.07;	author shinwell;	state Exp;
branches;
next	;

1.72.6.1
date	2004.04.08.12.41.45;	author amodra;	state Exp;
branches;
next	;

1.72.8.1
date	2004.03.27.17.37.35;	author drow;	state Exp;
branches;
next	1.72.8.2;

1.72.8.2
date	2004.04.02.16.47.36;	author drow;	state Exp;
branches;
next	1.72.8.3;

1.72.8.3
date	2004.09.16.17.00.32;	author drow;	state Exp;
branches;
next	1.72.8.4;

1.72.8.4
date	2004.09.21.20.44.03;	author drow;	state Exp;
branches;
next	;

1.56.16.1
date	2003.05.04.11.37.37;	author kettenis;	state Exp;
branches;
next	1.56.16.2;

1.56.16.2
date	2003.05.18.09.43.47;	author kettenis;	state Exp;
branches;
next	;

1.56.18.1
date	2003.05.02.08.27.55;	author aj;	state Exp;
branches;
next	;

1.52.2.1
date	2003.12.14.20.26.44;	author drow;	state Exp;
branches;
next	;

1.49.10.1
date	2002.09.27.20.02.55;	author carlton;	state Exp;
branches;
next	1.49.10.2;

1.49.10.2
date	2002.10.11.22.22.48;	author carlton;	state Exp;
branches;
next	1.49.10.3;

1.49.10.3
date	2002.12.23.19.37.49;	author carlton;	state Exp;
branches;
next	1.49.10.4;

1.49.10.4
date	2003.03.06.00.56.17;	author carlton;	state Exp;
branches;
next	1.49.10.5;

1.49.10.5
date	2003.05.23.18.40.27;	author carlton;	state Exp;
branches;
next	1.49.10.6;

1.49.10.6
date	2003.06.27.21.49.24;	author carlton;	state Exp;
branches;
next	1.49.10.7;

1.49.10.7
date	2003.08.05.17.12.52;	author carlton;	state Exp;
branches;
next	1.49.10.8;

1.49.10.8
date	2003.09.17.21.27.56;	author carlton;	state Exp;
branches;
next	1.49.10.9;

1.49.10.9
date	2003.11.11.23.50.24;	author carlton;	state Exp;
branches;
next	1.49.10.10;

1.49.10.10
date	2003.12.15.23.59.41;	author carlton;	state Exp;
branches;
next	;

1.47.2.1
date	2002.08.22.01.34.15;	author amodra;	state Exp;
branches;
next	;

1.42.2.1
date	2002.06.20.01.30.44;	author kseitz;	state Exp;
branches;
next	1.42.2.2;

1.42.2.2
date	2002.07.22.21.46.46;	author kseitz;	state Exp;
branches;
next	1.42.2.3;

1.42.2.3
date	2002.08.09.18.34.16;	author kseitz;	state Exp;
branches;
next	1.42.2.4;

1.42.2.4
date	2002.08.30.22.52.37;	author kseitz;	state Exp;
branches;
next	1.42.2.5;

1.42.2.5
date	2002.10.01.00.45.48;	author kseitz;	state Exp;
branches;
next	1.42.2.6;

1.42.2.6
date	2002.11.03.22.01.36;	author ezannoni;	state Exp;
branches;
next	;

1.41.2.1
date	2002.06.15.16.42.38;	author cagney;	state Exp;
branches;
next	;

1.34.2.1
date	2002.02.19.13.10.28;	author jakub;	state Exp;
branches;
next	1.34.2.2;

1.34.2.2
date	2002.02.22.10.06.18;	author jakub;	state Exp;
branches;
next	1.34.2.3;

1.34.2.3
date	2002.04.04.14.53.00;	author amodra;	state Exp;
branches;
next	1.34.2.4;

1.34.2.4
date	2002.04.27.09.10.32;	author amodra;	state Exp;
branches;
next	1.34.2.5;

1.34.2.5
date	2002.05.09.11.50.28;	author amodra;	state Exp;
branches;
next	;

1.4.2.1
date	2001.02.12.16.45.22;	author hubicka;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.02.12.16.52.27;	author hubicka;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.02.14.11.00.04;	author aj;	state Exp;
branches;
next	1.4.2.4;

1.4.2.4
date	2001.02.20.08.02.07;	author aj;	state Exp;
branches;
next	1.4.2.5;

1.4.2.5
date	2001.02.26.07.51.13;	author aj;	state Exp;
branches;
next	1.4.2.6;

1.4.2.6
date	2001.02.28.12.33.07;	author aj;	state Exp;
branches;
next	1.4.2.7;

1.4.2.7
date	2001.03.07.13.47.47;	author aj;	state Exp;
branches;
next	1.4.2.8;

1.4.2.8
date	2001.04.19.09.41.02;	author aj;	state Exp;
branches;
next	1.4.2.9;

1.4.2.9
date	2001.05.04.12.21.46;	author aj;	state Exp;
branches;
next	1.4.2.10;

1.4.2.10
date	2001.05.30.18.48.54;	author aj;	state Exp;
branches;
next	1.4.2.11;

1.4.2.11
date	2001.06.19.13.47.21;	author aj;	state Exp;
branches;
next	1.4.2.12;

1.4.2.12
date	2001.06.22.07.08.00;	author aj;	state Exp;
branches;
next	;


desc
@@


1.301
log
@	* elf64-x86-64.c (elf_x86_64_check_tls_transition): Allow
	64-bit -mcmodel=large -fpic TLS GD and LD sequences.
	(elf_x86_64_relocate_section): Handle -mcmodel=large -fpic
	TLS GD and LD sequences in GD->LE, GD->IE and LD->LE transitions.
ld/testsuite/
	* ld-x86-64/x86-64.exp: Add tlsld3, tlsgd7 and tlsgd8 tests.
	* ld-x86-64/tlspic1.s: Add -mcmodel=large -fpic TLS GD and LD
	sequences.
	* ld-x86-64/tlspic.dd: Adjusted.
	* ld-x86-64/tlspic.rd: Adjusted.
	* ld-x86-64/tlspic-nacl.rd: Adjusted.
	* ld-x86-64/tlsld3.dd: New test.
	* ld-x86-64/tlsld3.s: New file.
	* ld-x86-64/tlsgd7.dd: New test.
	* ld-x86-64/tlsgd7.s: New file.
	* ld-x86-64/tlsgd8.dd: New test.
	* ld-x86-64/tlsgd8.s: New file.
@
text
@/* X86-64 specific support for ELF
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
   Contributed by Jan Hubicka <jh@@suse.cz>.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf-nacl.h"
#include "bfd_stdint.h"
#include "objalloc.h"
#include "hashtab.h"
#include "dwarf2.h"
#include "libiberty.h"

#include "elf/x86-64.h"

#ifdef CORE_HEADER
#include <stdarg.h>
#include CORE_HEADER
#endif

/* In case we're on a 32-bit machine, construct a 64-bit "-1" value.  */
#define MINUS_ONE (~ (bfd_vma) 0)

/* Since both 32-bit and 64-bit x86-64 encode relocation type in the
   identical manner, we use ELF32_R_TYPE instead of ELF64_R_TYPE to get
   relocation type.  We also use ELF_ST_TYPE instead of ELF64_ST_TYPE
   since they are the same.  */

#define ABI_64_P(abfd) \
  (get_elf_backend_data (abfd)->s->elfclass == ELFCLASS64)

/* The relocation "howto" table.  Order of fields:
   type, rightshift, size, bitsize, pc_relative, bitpos, complain_on_overflow,
   special_function, name, partial_inplace, src_mask, dst_mask, pcrel_offset.  */
static reloc_howto_type x86_64_elf_howto_table[] =
{
  HOWTO(R_X86_64_NONE, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_X86_64_NONE",	FALSE, 0x00000000, 0x00000000,
	FALSE),
  HOWTO(R_X86_64_64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_64", FALSE, MINUS_ONE, MINUS_ONE,
	FALSE),
  HOWTO(R_X86_64_PC32, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC32", FALSE, 0xffffffff, 0xffffffff,
	TRUE),
  HOWTO(R_X86_64_GOT32, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOT32", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_PLT32, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PLT32", FALSE, 0xffffffff, 0xffffffff,
	TRUE),
  HOWTO(R_X86_64_COPY, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_COPY", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_GLOB_DAT, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_GLOB_DAT", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_JUMP_SLOT, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_RELATIVE, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_GOTPCREL, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_32, 0, 2, 32, FALSE, 0, complain_overflow_unsigned,
	bfd_elf_generic_reloc, "R_X86_64_32", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_32S, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_32S", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_16, 0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_16", FALSE, 0xffff, 0xffff, FALSE),
  HOWTO(R_X86_64_PC16,0, 1, 16, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_PC16", FALSE, 0xffff, 0xffff, TRUE),
  HOWTO(R_X86_64_8, 0, 0, 8, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_8", FALSE, 0xff, 0xff, FALSE),
  HOWTO(R_X86_64_PC8, 0, 0, 8, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC8", FALSE, 0xff, 0xff, TRUE),
  HOWTO(R_X86_64_DTPMOD64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPMOD64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_DTPOFF64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_TPOFF64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_TLSGD, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSGD", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_TLSLD, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSLD", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_DTPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF32", FALSE, 0xffffffff,
	0xffffffff, FALSE),
  HOWTO(R_X86_64_GOTTPOFF, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTTPOFF", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_TPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF32", FALSE, 0xffffffff,
	0xffffffff, FALSE),
  HOWTO(R_X86_64_PC64, 0, 4, 64, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_PC64", FALSE, MINUS_ONE, MINUS_ONE,
	TRUE),
  HOWTO(R_X86_64_GOTOFF64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_GOTOFF64",
	FALSE, MINUS_ONE, MINUS_ONE, FALSE),
  HOWTO(R_X86_64_GOTPC32, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPC32",
	FALSE, 0xffffffff, 0xffffffff, TRUE),
  HOWTO(R_X86_64_GOT64, 0, 4, 64, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOT64", FALSE, MINUS_ONE, MINUS_ONE,
	FALSE),
  HOWTO(R_X86_64_GOTPCREL64, 0, 4, 64, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL64", FALSE, MINUS_ONE,
	MINUS_ONE, TRUE),
  HOWTO(R_X86_64_GOTPC64, 0, 4, 64, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPC64",
	FALSE, MINUS_ONE, MINUS_ONE, TRUE),
  HOWTO(R_X86_64_GOTPLT64, 0, 4, 64, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPLT64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_PLTOFF64, 0, 4, 64, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PLTOFF64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_SIZE32, 0, 2, 32, FALSE, 0, complain_overflow_unsigned,
	bfd_elf_generic_reloc, "R_X86_64_SIZE32", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_SIZE64, 0, 4, 64, FALSE, 0, complain_overflow_unsigned,
	bfd_elf_generic_reloc, "R_X86_64_SIZE64", FALSE, MINUS_ONE, MINUS_ONE,
	FALSE),
  HOWTO(R_X86_64_GOTPC32_TLSDESC, 0, 2, 32, TRUE, 0,
	complain_overflow_bitfield, bfd_elf_generic_reloc,
	"R_X86_64_GOTPC32_TLSDESC",
	FALSE, 0xffffffff, 0xffffffff, TRUE),
  HOWTO(R_X86_64_TLSDESC_CALL, 0, 0, 0, FALSE, 0,
	complain_overflow_dont, bfd_elf_generic_reloc,
	"R_X86_64_TLSDESC_CALL",
	FALSE, 0, 0, FALSE),
  HOWTO(R_X86_64_TLSDESC, 0, 4, 64, FALSE, 0,
	complain_overflow_bitfield, bfd_elf_generic_reloc,
	"R_X86_64_TLSDESC",
	FALSE, MINUS_ONE, MINUS_ONE, FALSE),
  HOWTO(R_X86_64_IRELATIVE, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_IRELATIVE", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_RELATIVE64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_RELATIVE64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),

  /* We have a gap in the reloc numbers here.
     R_X86_64_standard counts the number up to this point, and
     R_X86_64_vt_offset is the value to subtract from a reloc type of
     R_X86_64_GNU_VT* to form an index into this table.  */
#define R_X86_64_standard (R_X86_64_RELATIVE64 + 1)
#define R_X86_64_vt_offset (R_X86_64_GNU_VTINHERIT - R_X86_64_standard)

/* GNU extension to record C++ vtable hierarchy.  */
  HOWTO (R_X86_64_GNU_VTINHERIT, 0, 4, 0, FALSE, 0, complain_overflow_dont,
	 NULL, "R_X86_64_GNU_VTINHERIT", FALSE, 0, 0, FALSE),

/* GNU extension to record C++ vtable member usage.  */
  HOWTO (R_X86_64_GNU_VTENTRY, 0, 4, 0, FALSE, 0, complain_overflow_dont,
	 _bfd_elf_rel_vtable_reloc_fn, "R_X86_64_GNU_VTENTRY", FALSE, 0, 0,
	 FALSE),

/* Use complain_overflow_bitfield on R_X86_64_32 for x32.  */
  HOWTO(R_X86_64_32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_32", FALSE, 0xffffffff, 0xffffffff,
	FALSE)
};

#define IS_X86_64_PCREL_TYPE(TYPE)	\
  (   ((TYPE) == R_X86_64_PC8)		\
   || ((TYPE) == R_X86_64_PC16)		\
   || ((TYPE) == R_X86_64_PC32)		\
   || ((TYPE) == R_X86_64_PC64))

/* Map BFD relocs to the x86_64 elf relocs.  */
struct elf_reloc_map
{
  bfd_reloc_code_real_type bfd_reloc_val;
  unsigned char elf_reloc_val;
};

static const struct elf_reloc_map x86_64_reloc_map[] =
{
  { BFD_RELOC_NONE,		R_X86_64_NONE, },
  { BFD_RELOC_64,		R_X86_64_64,   },
  { BFD_RELOC_32_PCREL,		R_X86_64_PC32, },
  { BFD_RELOC_X86_64_GOT32,	R_X86_64_GOT32,},
  { BFD_RELOC_X86_64_PLT32,	R_X86_64_PLT32,},
  { BFD_RELOC_X86_64_COPY,	R_X86_64_COPY, },
  { BFD_RELOC_X86_64_GLOB_DAT,	R_X86_64_GLOB_DAT, },
  { BFD_RELOC_X86_64_JUMP_SLOT, R_X86_64_JUMP_SLOT, },
  { BFD_RELOC_X86_64_RELATIVE,	R_X86_64_RELATIVE, },
  { BFD_RELOC_X86_64_GOTPCREL,	R_X86_64_GOTPCREL, },
  { BFD_RELOC_32,		R_X86_64_32, },
  { BFD_RELOC_X86_64_32S,	R_X86_64_32S, },
  { BFD_RELOC_16,		R_X86_64_16, },
  { BFD_RELOC_16_PCREL,		R_X86_64_PC16, },
  { BFD_RELOC_8,		R_X86_64_8, },
  { BFD_RELOC_8_PCREL,		R_X86_64_PC8, },
  { BFD_RELOC_X86_64_DTPMOD64,	R_X86_64_DTPMOD64, },
  { BFD_RELOC_X86_64_DTPOFF64,	R_X86_64_DTPOFF64, },
  { BFD_RELOC_X86_64_TPOFF64,	R_X86_64_TPOFF64, },
  { BFD_RELOC_X86_64_TLSGD,	R_X86_64_TLSGD, },
  { BFD_RELOC_X86_64_TLSLD,	R_X86_64_TLSLD, },
  { BFD_RELOC_X86_64_DTPOFF32,	R_X86_64_DTPOFF32, },
  { BFD_RELOC_X86_64_GOTTPOFF,	R_X86_64_GOTTPOFF, },
  { BFD_RELOC_X86_64_TPOFF32,	R_X86_64_TPOFF32, },
  { BFD_RELOC_64_PCREL,		R_X86_64_PC64, },
  { BFD_RELOC_X86_64_GOTOFF64,	R_X86_64_GOTOFF64, },
  { BFD_RELOC_X86_64_GOTPC32,	R_X86_64_GOTPC32, },
  { BFD_RELOC_X86_64_GOT64,	R_X86_64_GOT64, },
  { BFD_RELOC_X86_64_GOTPCREL64,R_X86_64_GOTPCREL64, },
  { BFD_RELOC_X86_64_GOTPC64,	R_X86_64_GOTPC64, },
  { BFD_RELOC_X86_64_GOTPLT64,	R_X86_64_GOTPLT64, },
  { BFD_RELOC_X86_64_PLTOFF64,	R_X86_64_PLTOFF64, },
  { BFD_RELOC_SIZE32,		R_X86_64_SIZE32, },
  { BFD_RELOC_SIZE64,		R_X86_64_SIZE64, },
  { BFD_RELOC_X86_64_GOTPC32_TLSDESC, R_X86_64_GOTPC32_TLSDESC, },
  { BFD_RELOC_X86_64_TLSDESC_CALL, R_X86_64_TLSDESC_CALL, },
  { BFD_RELOC_X86_64_TLSDESC,	R_X86_64_TLSDESC, },
  { BFD_RELOC_X86_64_IRELATIVE,	R_X86_64_IRELATIVE, },
  { BFD_RELOC_VTABLE_INHERIT,	R_X86_64_GNU_VTINHERIT, },
  { BFD_RELOC_VTABLE_ENTRY,	R_X86_64_GNU_VTENTRY, },
};

static reloc_howto_type *
elf_x86_64_rtype_to_howto (bfd *abfd, unsigned r_type)
{
  unsigned i;

  if (r_type == (unsigned int) R_X86_64_32)
    {
      if (ABI_64_P (abfd))
	i = r_type;
      else
	i = ARRAY_SIZE (x86_64_elf_howto_table) - 1;
    }
  else if (r_type < (unsigned int) R_X86_64_GNU_VTINHERIT
	   || r_type >= (unsigned int) R_X86_64_max)
    {
      if (r_type >= (unsigned int) R_X86_64_standard)
	{
	  (*_bfd_error_handler) (_("%B: invalid relocation type %d"),
				 abfd, (int) r_type);
	  r_type = R_X86_64_NONE;
	}
      i = r_type;
    }
  else
    i = r_type - (unsigned int) R_X86_64_vt_offset;
  BFD_ASSERT (x86_64_elf_howto_table[i].type == r_type);
  return &x86_64_elf_howto_table[i];
}

/* Given a BFD reloc type, return a HOWTO structure.  */
static reloc_howto_type *
elf_x86_64_reloc_type_lookup (bfd *abfd,
			      bfd_reloc_code_real_type code)
{
  unsigned int i;

  for (i = 0; i < sizeof (x86_64_reloc_map) / sizeof (struct elf_reloc_map);
       i++)
    {
      if (x86_64_reloc_map[i].bfd_reloc_val == code)
	return elf_x86_64_rtype_to_howto (abfd,
					  x86_64_reloc_map[i].elf_reloc_val);
    }
  return 0;
}

static reloc_howto_type *
elf_x86_64_reloc_name_lookup (bfd *abfd,
			      const char *r_name)
{
  unsigned int i;

  if (!ABI_64_P (abfd) && strcasecmp (r_name, "R_X86_64_32") == 0)
    {
      /* Get x32 R_X86_64_32.  */
      reloc_howto_type *reloc
	= &x86_64_elf_howto_table[ARRAY_SIZE (x86_64_elf_howto_table) - 1];
      BFD_ASSERT (reloc->type == (unsigned int) R_X86_64_32);
      return reloc;
    }

  for (i = 0; i < ARRAY_SIZE (x86_64_elf_howto_table); i++)
    if (x86_64_elf_howto_table[i].name != NULL
	&& strcasecmp (x86_64_elf_howto_table[i].name, r_name) == 0)
      return &x86_64_elf_howto_table[i];

  return NULL;
}

/* Given an x86_64 ELF reloc type, fill in an arelent structure.  */

static void
elf_x86_64_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			  Elf_Internal_Rela *dst)
{
  unsigned r_type;

  r_type = ELF32_R_TYPE (dst->r_info);
  cache_ptr->howto = elf_x86_64_rtype_to_howto (abfd, r_type);
  BFD_ASSERT (r_type == cache_ptr->howto->type);
}

/* Support for core dump NOTE sections.  */
static bfd_boolean
elf_x86_64_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
{
  int offset;
  size_t size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 296:		/* sizeof(istruct elf_prstatus) on Linux/x32 */
	/* pr_cursig */
	elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	size = 216;

	break;

      case 336:		/* sizeof(istruct elf_prstatus) on Linux/x86_64 */
	/* pr_cursig */
	elf_tdata (abfd)->core->signal
	  = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core->lwpid
	  = bfd_get_32 (abfd, note->descdata + 32);

	/* pr_reg */
	offset = 112;
	size = 216;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

static bfd_boolean
elf_x86_64_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
{
  switch (note->descsz)
    {
      default:
	return FALSE;

      case 124:		/* sizeof(struct elf_prpsinfo) on Linux/x32 */
	elf_tdata (abfd)->core->pid
	  = bfd_get_32 (abfd, note->descdata + 12);
	elf_tdata (abfd)->core->program
	  = _bfd_elfcore_strndup (abfd, note->descdata + 28, 16);
	elf_tdata (abfd)->core->command
	  = _bfd_elfcore_strndup (abfd, note->descdata + 44, 80);
	break;

      case 136:		/* sizeof(struct elf_prpsinfo) on Linux/x86_64 */
	elf_tdata (abfd)->core->pid
	  = bfd_get_32 (abfd, note->descdata + 24);
	elf_tdata (abfd)->core->program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
	elf_tdata (abfd)->core->command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core->command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return TRUE;
}

#ifdef CORE_HEADER
static char *
elf_x86_64_write_core_note (bfd *abfd, char *buf, int *bufsiz,
			    int note_type, ...)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  va_list ap;
  const char *fname, *psargs;
  long pid;
  int cursig;
  const void *gregs;

  switch (note_type)
    {
    default:
      return NULL;

    case NT_PRPSINFO:
      va_start (ap, note_type);
      fname = va_arg (ap, const char *);
      psargs = va_arg (ap, const char *);
      va_end (ap);

      if (bed->s->elfclass == ELFCLASS32)
	{
	  prpsinfo32_t data;
	  memset (&data, 0, sizeof (data));
	  strncpy (data.pr_fname, fname, sizeof (data.pr_fname));
	  strncpy (data.pr_psargs, psargs, sizeof (data.pr_psargs));
	  return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
				     &data, sizeof (data));
	}
      else
	{
	  prpsinfo64_t data;
	  memset (&data, 0, sizeof (data));
	  strncpy (data.pr_fname, fname, sizeof (data.pr_fname));
	  strncpy (data.pr_psargs, psargs, sizeof (data.pr_psargs));
	  return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
				     &data, sizeof (data));
	}
      /* NOTREACHED */

    case NT_PRSTATUS:
      va_start (ap, note_type);
      pid = va_arg (ap, long);
      cursig = va_arg (ap, int);
      gregs = va_arg (ap, const void *);
      va_end (ap);

      if (bed->s->elfclass == ELFCLASS32)
	{
	  if (bed->elf_machine_code == EM_X86_64)
	    {
	      prstatusx32_t prstat;
	      memset (&prstat, 0, sizeof (prstat));
	      prstat.pr_pid = pid;
	      prstat.pr_cursig = cursig;
	      memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
	      return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
					 &prstat, sizeof (prstat));
	    }
	  else
	    {
	      prstatus32_t prstat;
	      memset (&prstat, 0, sizeof (prstat));
	      prstat.pr_pid = pid;
	      prstat.pr_cursig = cursig;
	      memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
	      return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
					 &prstat, sizeof (prstat));
	    }
	}
      else
	{
	  prstatus64_t prstat;
	  memset (&prstat, 0, sizeof (prstat));
	  prstat.pr_pid = pid;
	  prstat.pr_cursig = cursig;
	  memcpy (&prstat.pr_reg, gregs, sizeof (prstat.pr_reg));
	  return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
				     &prstat, sizeof (prstat));
	}
    }
  /* NOTREACHED */
}
#endif

/* Functions for the x86-64 ELF linker.	 */

/* The name of the dynamic interpreter.	 This is put in the .interp
   section.  */

#define ELF64_DYNAMIC_INTERPRETER "/lib/ld64.so.1"
#define ELF32_DYNAMIC_INTERPRETER "/lib/ldx32.so.1"

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

/* The size in bytes of an entry in the global offset table.  */

#define GOT_ENTRY_SIZE 8

/* The size in bytes of an entry in the procedure linkage table.  */

#define PLT_ENTRY_SIZE 16

/* The first entry in a procedure linkage table looks like this.  See the
   SVR4 ABI i386 supplement and the x86-64 ABI to see how this works.  */

static const bfd_byte elf_x86_64_plt0_entry[PLT_ENTRY_SIZE] =
{
  0xff, 0x35, 8, 0, 0, 0,	/* pushq GOT+8(%rip)  */
  0xff, 0x25, 16, 0, 0, 0,	/* jmpq *GOT+16(%rip) */
  0x0f, 0x1f, 0x40, 0x00	/* nopl 0(%rax)       */
};

/* Subsequent entries in a procedure linkage table look like this.  */

static const bfd_byte elf_x86_64_plt_entry[PLT_ENTRY_SIZE] =
{
  0xff, 0x25,	/* jmpq *name@@GOTPC(%rip) */
  0, 0, 0, 0,	/* replaced with offset to this symbol in .got.	 */
  0x68,		/* pushq immediate */
  0, 0, 0, 0,	/* replaced with index into relocation table.  */
  0xe9,		/* jmp relative */
  0, 0, 0, 0	/* replaced with offset to start of .plt0.  */
};

/* .eh_frame covering the .plt section.  */

static const bfd_byte elf_x86_64_eh_frame_plt[] =
{
#define PLT_CIE_LENGTH		20
#define PLT_FDE_LENGTH		36
#define PLT_FDE_START_OFFSET	4 + PLT_CIE_LENGTH + 8
#define PLT_FDE_LEN_OFFSET	4 + PLT_CIE_LENGTH + 12
  PLT_CIE_LENGTH, 0, 0, 0,	/* CIE length */
  0, 0, 0, 0,			/* CIE ID */
  1,				/* CIE version */
  'z', 'R', 0,			/* Augmentation string */
  1,				/* Code alignment factor */
  0x78,				/* Data alignment factor */
  16,				/* Return address column */
  1,				/* Augmentation size */
  DW_EH_PE_pcrel | DW_EH_PE_sdata4, /* FDE encoding */
  DW_CFA_def_cfa, 7, 8,		/* DW_CFA_def_cfa: r7 (rsp) ofs 8 */
  DW_CFA_offset + 16, 1,	/* DW_CFA_offset: r16 (rip) at cfa-8 */
  DW_CFA_nop, DW_CFA_nop,

  PLT_FDE_LENGTH, 0, 0, 0,	/* FDE length */
  PLT_CIE_LENGTH + 8, 0, 0, 0,	/* CIE pointer */
  0, 0, 0, 0,			/* R_X86_64_PC32 .plt goes here */
  0, 0, 0, 0,			/* .plt size goes here */
  0,				/* Augmentation size */
  DW_CFA_def_cfa_offset, 16,	/* DW_CFA_def_cfa_offset: 16 */
  DW_CFA_advance_loc + 6,	/* DW_CFA_advance_loc: 6 to __PLT__+6 */
  DW_CFA_def_cfa_offset, 24,	/* DW_CFA_def_cfa_offset: 24 */
  DW_CFA_advance_loc + 10,	/* DW_CFA_advance_loc: 10 to __PLT__+16 */
  DW_CFA_def_cfa_expression,	/* DW_CFA_def_cfa_expression */
  11,				/* Block length */
  DW_OP_breg7, 8,		/* DW_OP_breg7 (rsp): 8 */
  DW_OP_breg16, 0,		/* DW_OP_breg16 (rip): 0 */
  DW_OP_lit15, DW_OP_and, DW_OP_lit11, DW_OP_ge,
  DW_OP_lit3, DW_OP_shl, DW_OP_plus,
  DW_CFA_nop, DW_CFA_nop, DW_CFA_nop, DW_CFA_nop
};

/* Architecture-specific backend data for x86-64.  */

struct elf_x86_64_backend_data
{
  /* Templates for the initial PLT entry and for subsequent entries.  */
  const bfd_byte *plt0_entry;
  const bfd_byte *plt_entry;
  unsigned int plt_entry_size;          /* Size of each PLT entry.  */

  /* Offsets into plt0_entry that are to be replaced with GOT[1] and GOT[2].  */
  unsigned int plt0_got1_offset;
  unsigned int plt0_got2_offset;

  /* Offset of the end of the PC-relative instruction containing
     plt0_got2_offset.  */
  unsigned int plt0_got2_insn_end;

  /* Offsets into plt_entry that are to be replaced with...  */
  unsigned int plt_got_offset;    /* ... address of this symbol in .got. */
  unsigned int plt_reloc_offset;  /* ... offset into relocation table. */
  unsigned int plt_plt_offset;    /* ... offset to start of .plt. */

  /* Length of the PC-relative instruction containing plt_got_offset.  */
  unsigned int plt_got_insn_size;

  /* Offset of the end of the PC-relative jump to plt0_entry.  */
  unsigned int plt_plt_insn_end;

  /* Offset into plt_entry where the initial value of the GOT entry points.  */
  unsigned int plt_lazy_offset;

  /* .eh_frame covering the .plt section.  */
  const bfd_byte *eh_frame_plt;
  unsigned int eh_frame_plt_size;
};

#define get_elf_x86_64_arch_data(bed) \
  ((const struct elf_x86_64_backend_data *) (bed)->arch_data)

#define get_elf_x86_64_backend_data(abfd) \
  get_elf_x86_64_arch_data (get_elf_backend_data (abfd))

#define GET_PLT_ENTRY_SIZE(abfd) \
  get_elf_x86_64_backend_data (abfd)->plt_entry_size

/* These are the standard parameters.  */
static const struct elf_x86_64_backend_data elf_x86_64_arch_bed =
  {
    elf_x86_64_plt0_entry,              /* plt0_entry */
    elf_x86_64_plt_entry,               /* plt_entry */
    sizeof (elf_x86_64_plt_entry),      /* plt_entry_size */
    2,                                  /* plt0_got1_offset */
    8,                                  /* plt0_got2_offset */
    12,                                 /* plt0_got2_insn_end */
    2,                                  /* plt_got_offset */
    7,                                  /* plt_reloc_offset */
    12,                                 /* plt_plt_offset */
    6,                                  /* plt_got_insn_size */
    PLT_ENTRY_SIZE,                     /* plt_plt_insn_end */
    6,                                  /* plt_lazy_offset */
    elf_x86_64_eh_frame_plt,            /* eh_frame_plt */
    sizeof (elf_x86_64_eh_frame_plt),   /* eh_frame_plt_size */
  };

#define	elf_backend_arch_data	&elf_x86_64_arch_bed

/* x86-64 ELF linker hash entry.  */

struct elf_x86_64_link_hash_entry
{
  struct elf_link_hash_entry elf;

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_dyn_relocs *dyn_relocs;

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	3
#define GOT_TLS_GDESC	4
#define GOT_TLS_GD_BOTH_P(type) \
  ((type) == (GOT_TLS_GD | GOT_TLS_GDESC))
#define GOT_TLS_GD_P(type) \
  ((type) == GOT_TLS_GD || GOT_TLS_GD_BOTH_P (type))
#define GOT_TLS_GDESC_P(type) \
  ((type) == GOT_TLS_GDESC || GOT_TLS_GD_BOTH_P (type))
#define GOT_TLS_GD_ANY_P(type) \
  (GOT_TLS_GD_P (type) || GOT_TLS_GDESC_P (type))
  unsigned char tls_type;

  /* Offset of the GOTPLT entry reserved for the TLS descriptor,
     starting at the end of the jump table.  */
  bfd_vma tlsdesc_got;
};

#define elf_x86_64_hash_entry(ent) \
  ((struct elf_x86_64_link_hash_entry *)(ent))

struct elf_x86_64_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;

  /* GOTPLT entries for TLS descriptors.  */
  bfd_vma *local_tlsdesc_gotent;
};

#define elf_x86_64_tdata(abfd) \
  ((struct elf_x86_64_obj_tdata *) (abfd)->tdata.any)

#define elf_x86_64_local_got_tls_type(abfd) \
  (elf_x86_64_tdata (abfd)->local_got_tls_type)

#define elf_x86_64_local_tlsdesc_gotent(abfd) \
  (elf_x86_64_tdata (abfd)->local_tlsdesc_gotent)

#define is_x86_64_elf(bfd)				\
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour	\
   && elf_tdata (bfd) != NULL				\
   && elf_object_id (bfd) == X86_64_ELF_DATA)

static bfd_boolean
elf_x86_64_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct elf_x86_64_obj_tdata),
				  X86_64_ELF_DATA);
}

/* x86-64 ELF linker hash table.  */

struct elf_x86_64_link_hash_table
{
  struct elf_link_hash_table elf;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sdynbss;
  asection *srelbss;
  asection *plt_eh_frame;

  union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ld_got;

  /* The amount of space used by the jump slots in the GOT.  */
  bfd_vma sgotplt_jump_table_size;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;

  bfd_vma (*r_info) (bfd_vma, bfd_vma);
  bfd_vma (*r_sym) (bfd_vma);
  unsigned int pointer_r_type;
  const char *dynamic_interpreter;
  int dynamic_interpreter_size;

  /* _TLS_MODULE_BASE_ symbol.  */
  struct bfd_link_hash_entry *tls_module_base;

  /* Used by local STT_GNU_IFUNC symbols.  */
  htab_t loc_hash_table;
  void * loc_hash_memory;

  /* The offset into splt of the PLT entry for the TLS descriptor
     resolver.  Special values are 0, if not necessary (or not found
     to be necessary yet), and -1 if needed but not determined
     yet.  */
  bfd_vma tlsdesc_plt;
  /* The offset into sgot of the GOT entry used by the PLT entry
     above.  */
  bfd_vma tlsdesc_got;

  /* The index of the next R_X86_64_JUMP_SLOT entry in .rela.plt.  */
  bfd_vma next_jump_slot_index;
  /* The index of the next R_X86_64_IRELATIVE entry in .rela.plt.  */
  bfd_vma next_irelative_index;
};

/* Get the x86-64 ELF linker hash table from a link_info structure.  */

#define elf_x86_64_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == X86_64_ELF_DATA ? ((struct elf_x86_64_link_hash_table *) ((p)->hash)) : NULL)

#define elf_x86_64_compute_jump_table_size(htab) \
  ((htab)->elf.srelplt->reloc_count * GOT_ENTRY_SIZE)

/* Create an entry in an x86-64 ELF linker hash table.	*/

static struct bfd_hash_entry *
elf_x86_64_link_hash_newfunc (struct bfd_hash_entry *entry,
			      struct bfd_hash_table *table,
			      const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = (struct bfd_hash_entry *)
	  bfd_hash_allocate (table,
			     sizeof (struct elf_x86_64_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf_x86_64_link_hash_entry *eh;

      eh = (struct elf_x86_64_link_hash_entry *) entry;
      eh->dyn_relocs = NULL;
      eh->tls_type = GOT_UNKNOWN;
      eh->tlsdesc_got = (bfd_vma) -1;
    }

  return entry;
}

/* Compute a hash of a local hash entry.  We use elf_link_hash_entry
  for local symbol so that we can handle local STT_GNU_IFUNC symbols
  as global symbol.  We reuse indx and dynstr_index for local symbol
  hash since they aren't used by global symbols in this backend.  */

static hashval_t
elf_x86_64_local_htab_hash (const void *ptr)
{
  struct elf_link_hash_entry *h
    = (struct elf_link_hash_entry *) ptr;
  return ELF_LOCAL_SYMBOL_HASH (h->indx, h->dynstr_index);
}

/* Compare local hash entries.  */

static int
elf_x86_64_local_htab_eq (const void *ptr1, const void *ptr2)
{
  struct elf_link_hash_entry *h1
     = (struct elf_link_hash_entry *) ptr1;
  struct elf_link_hash_entry *h2
    = (struct elf_link_hash_entry *) ptr2;

  return h1->indx == h2->indx && h1->dynstr_index == h2->dynstr_index;
}

/* Find and/or create a hash entry for local symbol.  */

static struct elf_link_hash_entry *
elf_x86_64_get_local_sym_hash (struct elf_x86_64_link_hash_table *htab,
			       bfd *abfd, const Elf_Internal_Rela *rel,
			       bfd_boolean create)
{
  struct elf_x86_64_link_hash_entry e, *ret;
  asection *sec = abfd->sections;
  hashval_t h = ELF_LOCAL_SYMBOL_HASH (sec->id,
				       htab->r_sym (rel->r_info));
  void **slot;

  e.elf.indx = sec->id;
  e.elf.dynstr_index = htab->r_sym (rel->r_info);
  slot = htab_find_slot_with_hash (htab->loc_hash_table, &e, h,
				   create ? INSERT : NO_INSERT);

  if (!slot)
    return NULL;

  if (*slot)
    {
      ret = (struct elf_x86_64_link_hash_entry *) *slot;
      return &ret->elf;
    }

  ret = (struct elf_x86_64_link_hash_entry *)
	objalloc_alloc ((struct objalloc *) htab->loc_hash_memory,
			sizeof (struct elf_x86_64_link_hash_entry));
  if (ret)
    {
      memset (ret, 0, sizeof (*ret));
      ret->elf.indx = sec->id;
      ret->elf.dynstr_index = htab->r_sym (rel->r_info);
      ret->elf.dynindx = -1;
      *slot = ret;
    }
  return &ret->elf;
}

/* Create an X86-64 ELF linker hash table.  */

static struct bfd_link_hash_table *
elf_x86_64_link_hash_table_create (bfd *abfd)
{
  struct elf_x86_64_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_x86_64_link_hash_table);

  ret = (struct elf_x86_64_link_hash_table *) bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd,
				      elf_x86_64_link_hash_newfunc,
				      sizeof (struct elf_x86_64_link_hash_entry),
				      X86_64_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  if (ABI_64_P (abfd))
    {
      ret->r_info = elf64_r_info;
      ret->r_sym = elf64_r_sym;
      ret->pointer_r_type = R_X86_64_64;
      ret->dynamic_interpreter = ELF64_DYNAMIC_INTERPRETER;
      ret->dynamic_interpreter_size = sizeof ELF64_DYNAMIC_INTERPRETER;
    }
  else
    {
      ret->r_info = elf32_r_info;
      ret->r_sym = elf32_r_sym;
      ret->pointer_r_type = R_X86_64_32;
      ret->dynamic_interpreter = ELF32_DYNAMIC_INTERPRETER;
      ret->dynamic_interpreter_size = sizeof ELF32_DYNAMIC_INTERPRETER;
    }

  ret->loc_hash_table = htab_try_create (1024,
					 elf_x86_64_local_htab_hash,
					 elf_x86_64_local_htab_eq,
					 NULL);
  ret->loc_hash_memory = objalloc_create ();
  if (!ret->loc_hash_table || !ret->loc_hash_memory)
    {
      free (ret);
      return NULL;
    }

  return &ret->elf.root;
}

/* Destroy an X86-64 ELF linker hash table.  */

static void
elf_x86_64_link_hash_table_free (struct bfd_link_hash_table *hash)
{
  struct elf_x86_64_link_hash_table *htab
    = (struct elf_x86_64_link_hash_table *) hash;

  if (htab->loc_hash_table)
    htab_delete (htab->loc_hash_table);
  if (htab->loc_hash_memory)
    objalloc_free ((struct objalloc *) htab->loc_hash_memory);
  _bfd_elf_link_hash_table_free (hash);
}

/* Create .plt, .rela.plt, .got, .got.plt, .rela.got, .dynbss, and
   .rela.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static bfd_boolean
elf_x86_64_create_dynamic_sections (bfd *dynobj,
				    struct bfd_link_info *info)
{
  struct elf_x86_64_link_hash_table *htab;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return FALSE;

  htab->sdynbss = bfd_get_linker_section (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_linker_section (dynobj, ".rela.bss");

  if (!htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  if (!info->no_ld_generated_unwind_info
      && htab->plt_eh_frame == NULL
      && htab->elf.splt != NULL)
    {
      flagword flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY
			| SEC_HAS_CONTENTS | SEC_IN_MEMORY
			| SEC_LINKER_CREATED);
      htab->plt_eh_frame
	= bfd_make_section_anyway_with_flags (dynobj, ".eh_frame", flags);
      if (htab->plt_eh_frame == NULL
	  || !bfd_set_section_alignment (dynobj, htab->plt_eh_frame, 3))
	return FALSE;
    }
  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf_x86_64_copy_indirect_symbol (struct bfd_link_info *info,
				 struct elf_link_hash_entry *dir,
				 struct elf_link_hash_entry *ind)
{
  struct elf_x86_64_link_hash_entry *edir, *eind;

  edir = (struct elf_x86_64_link_hash_entry *) dir;
  eind = (struct elf_x86_64_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  /* Add reloc counts against the indirect sym to the direct sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
      dir->pointer_equality_needed |= ind->pointer_equality_needed;
    }
  else
    _bfd_elf_link_hash_copy_indirect (info, dir, ind);
}

static bfd_boolean
elf64_x86_64_elf_object_p (bfd *abfd)
{
  /* Set the right machine number for an x86-64 elf64 file.  */
  bfd_default_set_arch_mach (abfd, bfd_arch_i386, bfd_mach_x86_64);
  return TRUE;
}

static bfd_boolean
elf32_x86_64_elf_object_p (bfd *abfd)
{
  /* Set the right machine number for an x86-64 elf32 file.  */
  bfd_default_set_arch_mach (abfd, bfd_arch_i386, bfd_mach_x64_32);
  return TRUE;
}

/* Return TRUE if the TLS access code sequence support transition
   from R_TYPE.  */

static bfd_boolean
elf_x86_64_check_tls_transition (bfd *abfd,
				 struct bfd_link_info *info,
				 asection *sec,
				 bfd_byte *contents,
				 Elf_Internal_Shdr *symtab_hdr,
				 struct elf_link_hash_entry **sym_hashes,
				 unsigned int r_type,
				 const Elf_Internal_Rela *rel,
				 const Elf_Internal_Rela *relend)
{
  unsigned int val;
  unsigned long r_symndx;
  bfd_boolean largepic = FALSE;
  struct elf_link_hash_entry *h;
  bfd_vma offset;
  struct elf_x86_64_link_hash_table *htab;

  /* Get the section contents.  */
  if (contents == NULL)
    {
      if (elf_section_data (sec)->this_hdr.contents != NULL)
	contents = elf_section_data (sec)->this_hdr.contents;
      else
	{
	  /* FIXME: How to better handle error condition?  */
	  if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	    return FALSE;

	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  htab = elf_x86_64_hash_table (info);
  offset = rel->r_offset;
  switch (r_type)
    {
    case R_X86_64_TLSGD:
    case R_X86_64_TLSLD:
      if ((rel + 1) >= relend)
	return FALSE;

      if (r_type == R_X86_64_TLSGD)
	{
	  /* Check transition from GD access model.  For 64bit, only
		.byte 0x66; leaq foo@@tlsgd(%rip), %rdi
		.word 0x6666; rex64; call __tls_get_addr
	     can transit to different access model.  For 32bit, only
		leaq foo@@tlsgd(%rip), %rdi
		.word 0x6666; rex64; call __tls_get_addr
	     can transit to different access model.  For largepic
	     we also support:
	        leaq foo@@tlsgd(%rip), %rdi
	        movabsq $__tls_get_addr@@pltoff, %rax
	        addq $rbx, %rax
	        call *%rax.  */

	  static const unsigned char call[] = { 0x66, 0x66, 0x48, 0xe8 };
	  static const unsigned char leaq[] = { 0x66, 0x48, 0x8d, 0x3d };

	  if ((offset + 12) > sec->size)
	    return FALSE;

	  if (memcmp (contents + offset + 4, call, 4) != 0)
	    {
	      if (!ABI_64_P (abfd)
		  || (offset + 19) > sec->size
		  || offset < 3
		  || memcmp (contents + offset - 3, leaq + 1, 3) != 0
		  || memcmp (contents + offset + 4, "\x48\xb8", 2) != 0
		  || memcmp (contents + offset + 14, "\x48\x01\xd8\xff\xd0", 5)
		     != 0)
		return FALSE;
	      largepic = TRUE;
	    }
	  else if (ABI_64_P (abfd))
	    {
	      if (offset < 4
		  || memcmp (contents + offset - 4, leaq, 4) != 0)
		return FALSE;
	    }
	  else
	    {
	      if (offset < 3
		  || memcmp (contents + offset - 3, leaq + 1, 3) != 0)
		return FALSE;
	    }
	}
      else
	{
	  /* Check transition from LD access model.  Only
		leaq foo@@tlsld(%rip), %rdi;
		call __tls_get_addr
	     can transit to different access model.  For largepic
	     we also support:
	        leaq foo@@tlsld(%rip), %rdi
	        movabsq $__tls_get_addr@@pltoff, %rax
	        addq $rbx, %rax
	        call *%rax.  */

	  static const unsigned char lea[] = { 0x48, 0x8d, 0x3d };

	  if (offset < 3 || (offset + 9) > sec->size)
	    return FALSE;

	  if (memcmp (contents + offset - 3, lea, 3) != 0)
	    return FALSE;

	  if (0xe8 != *(contents + offset + 4))
	    {
	      if (!ABI_64_P (abfd)
		  || (offset + 19) > sec->size
		  || memcmp (contents + offset + 4, "\x48\xb8", 2) != 0
		  || memcmp (contents + offset + 14, "\x48\x01\xd8\xff\xd0", 5)
		     != 0)
		return FALSE;
	      largepic = TRUE;
	    }
	}

      r_symndx = htab->r_sym (rel[1].r_info);
      if (r_symndx < symtab_hdr->sh_info)
	return FALSE;

      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
      /* Use strncmp to check __tls_get_addr since __tls_get_addr
	 may be versioned.  */
      return (h != NULL
	      && h->root.root.string != NULL
	      && (largepic
		  ? ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PLTOFF64
		  : (ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PC32
		     || ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PLT32))
	      && (strncmp (h->root.root.string,
			   "__tls_get_addr", 14) == 0));

    case R_X86_64_GOTTPOFF:
      /* Check transition from IE access model:
		mov foo@@gottpoff(%rip), %reg
		add foo@@gottpoff(%rip), %reg
       */

      /* Check REX prefix first.  */
      if (offset >= 3 && (offset + 4) <= sec->size)
	{
	  val = bfd_get_8 (abfd, contents + offset - 3);
	  if (val != 0x48 && val != 0x4c)
	    {
	      /* X32 may have 0x44 REX prefix or no REX prefix.  */
	      if (ABI_64_P (abfd))
		return FALSE;
	    }
	}
      else
	{
	  /* X32 may not have any REX prefix.  */
	  if (ABI_64_P (abfd))
	    return FALSE;
	  if (offset < 2 || (offset + 3) > sec->size)
	    return FALSE;
	}

      val = bfd_get_8 (abfd, contents + offset - 2);
      if (val != 0x8b && val != 0x03)
	return FALSE;

      val = bfd_get_8 (abfd, contents + offset - 1);
      return (val & 0xc7) == 5;

    case R_X86_64_GOTPC32_TLSDESC:
      /* Check transition from GDesc access model:
		leaq x@@tlsdesc(%rip), %rax

	 Make sure it's a leaq adding rip to a 32-bit offset
	 into any register, although it's probably almost always
	 going to be rax.  */

      if (offset < 3 || (offset + 4) > sec->size)
	return FALSE;

      val = bfd_get_8 (abfd, contents + offset - 3);
      if ((val & 0xfb) != 0x48)
	return FALSE;

      if (bfd_get_8 (abfd, contents + offset - 2) != 0x8d)
	return FALSE;

      val = bfd_get_8 (abfd, contents + offset - 1);
      return (val & 0xc7) == 0x05;

    case R_X86_64_TLSDESC_CALL:
      /* Check transition from GDesc access model:
		call *x@@tlsdesc(%rax)
       */
      if (offset + 2 <= sec->size)
	{
	  /* Make sure that it's a call *x@@tlsdesc(%rax).  */
	  static const unsigned char call[] = { 0xff, 0x10 };
	  return memcmp (contents + offset, call, 2) == 0;
	}

      return FALSE;

    default:
      abort ();
    }
}

/* Return TRUE if the TLS access transition is OK or no transition
   will be performed.  Update R_TYPE if there is a transition.  */

static bfd_boolean
elf_x86_64_tls_transition (struct bfd_link_info *info, bfd *abfd,
			   asection *sec, bfd_byte *contents,
			   Elf_Internal_Shdr *symtab_hdr,
			   struct elf_link_hash_entry **sym_hashes,
			   unsigned int *r_type, int tls_type,
			   const Elf_Internal_Rela *rel,
			   const Elf_Internal_Rela *relend,
			   struct elf_link_hash_entry *h,
			   unsigned long r_symndx)
{
  unsigned int from_type = *r_type;
  unsigned int to_type = from_type;
  bfd_boolean check = TRUE;

  /* Skip TLS transition for functions.  */
  if (h != NULL
      && (h->type == STT_FUNC
	  || h->type == STT_GNU_IFUNC))
    return TRUE;

  switch (from_type)
    {
    case R_X86_64_TLSGD:
    case R_X86_64_GOTPC32_TLSDESC:
    case R_X86_64_TLSDESC_CALL:
    case R_X86_64_GOTTPOFF:
      if (info->executable)
	{
	  if (h == NULL)
	    to_type = R_X86_64_TPOFF32;
	  else
	    to_type = R_X86_64_GOTTPOFF;
	}

      /* When we are called from elf_x86_64_relocate_section,
	 CONTENTS isn't NULL and there may be additional transitions
	 based on TLS_TYPE.  */
      if (contents != NULL)
	{
	  unsigned int new_to_type = to_type;

	  if (info->executable
	      && h != NULL
	      && h->dynindx == -1
	      && tls_type == GOT_TLS_IE)
	    new_to_type = R_X86_64_TPOFF32;

	  if (to_type == R_X86_64_TLSGD
	      || to_type == R_X86_64_GOTPC32_TLSDESC
	      || to_type == R_X86_64_TLSDESC_CALL)
	    {
	      if (tls_type == GOT_TLS_IE)
		new_to_type = R_X86_64_GOTTPOFF;
	    }

	  /* We checked the transition before when we were called from
	     elf_x86_64_check_relocs.  We only want to check the new
	     transition which hasn't been checked before.  */
	  check = new_to_type != to_type && from_type == to_type;
	  to_type = new_to_type;
	}

      break;

    case R_X86_64_TLSLD:
      if (info->executable)
	to_type = R_X86_64_TPOFF32;
      break;

    default:
      return TRUE;
    }

  /* Return TRUE if there is no transition.  */
  if (from_type == to_type)
    return TRUE;

  /* Check if the transition can be performed.  */
  if (check
      && ! elf_x86_64_check_tls_transition (abfd, info, sec, contents,
					    symtab_hdr, sym_hashes,
					    from_type, rel, relend))
    {
      reloc_howto_type *from, *to;
      const char *name;

      from = elf_x86_64_rtype_to_howto (abfd, from_type);
      to = elf_x86_64_rtype_to_howto (abfd, to_type);

      if (h)
	name = h->root.root.string;
      else
	{
	  struct elf_x86_64_link_hash_table *htab;

	  htab = elf_x86_64_hash_table (info);
	  if (htab == NULL)
	    name = "*unknown*";
	  else
	    {
	      Elf_Internal_Sym *isym;

	      isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					    abfd, r_symndx);
	      name = bfd_elf_sym_name (abfd, symtab_hdr, isym, NULL);
	    }
	}

      (*_bfd_error_handler)
	(_("%B: TLS transition from %s to %s against `%s' at 0x%lx "
	   "in section `%A' failed"),
	 abfd, sec, from->name, to->name, name,
	 (unsigned long) rel->r_offset);
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  *r_type = to_type;
  return TRUE;
}

/* Look through the relocs for a section during the first phase, and
   calculate needed space in the global offset table, procedure
   linkage table, and dynamic reloc sections.  */

static bfd_boolean
elf_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,
			 asection *sec,
			 const Elf_Internal_Rela *relocs)
{
  struct elf_x86_64_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sreloc;

  if (info->relocatable)
    return TRUE;

  BFD_ASSERT (is_x86_64_elf (abfd));

  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return FALSE;

  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);

  sreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned int r_type;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *isym;
      const char *name;
      bfd_boolean size_reloc;

      r_symndx = htab->r_sym (rel->r_info);
      r_type = ELF32_R_TYPE (rel->r_info);

      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
				 abfd, r_symndx);
	  return FALSE;
	}

      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					abfd, r_symndx);
	  if (isym == NULL)
	    return FALSE;

	  /* Check relocation against local STT_GNU_IFUNC symbol.  */
	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
	    {
	      h = elf_x86_64_get_local_sym_hash (htab, abfd, rel,
						 TRUE);
	      if (h == NULL)
		return FALSE;

	      /* Fake a STT_GNU_IFUNC symbol.  */
	      h->type = STT_GNU_IFUNC;
	      h->def_regular = 1;
	      h->ref_regular = 1;
	      h->forced_local = 1;
	      h->root.type = bfd_link_hash_defined;
	    }
	  else
	    h = NULL;
	}
      else
	{
	  isym = NULL;
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}

      /* Check invalid x32 relocations.  */
      if (!ABI_64_P (abfd))
	switch (r_type)
	  {
	  default:
	    break;

	  case R_X86_64_DTPOFF64:
	  case R_X86_64_TPOFF64:
	  case R_X86_64_PC64:
	  case R_X86_64_GOTOFF64:
	  case R_X86_64_GOT64:
	  case R_X86_64_GOTPCREL64:
	  case R_X86_64_GOTPC64:
	  case R_X86_64_GOTPLT64:
	  case R_X86_64_PLTOFF64:
	      {
		if (h)
		  name = h->root.root.string;
		else
		  name = bfd_elf_sym_name (abfd, symtab_hdr, isym,
					   NULL);
		(*_bfd_error_handler)
		  (_("%B: relocation %s against symbol `%s' isn't "
		     "supported in x32 mode"), abfd,
		   x86_64_elf_howto_table[r_type].name, name);
		bfd_set_error (bfd_error_bad_value);
		return FALSE;
	      }
	    break;
	  }

      if (h != NULL)
	{
	  /* Create the ifunc sections for static executables.  If we
	     never see an indirect function symbol nor we are building
	     a static executable, those sections will be empty and
	     won't appear in output.  */
	  switch (r_type)
	    {
	    default:
	      break;

	    case R_X86_64_32S:
	    case R_X86_64_32:
	    case R_X86_64_64:
	    case R_X86_64_PC32:
	    case R_X86_64_PC64:
	    case R_X86_64_PLT32:
	    case R_X86_64_GOTPCREL:
	    case R_X86_64_GOTPCREL64:
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!_bfd_elf_create_ifunc_sections (htab->elf.dynobj, info))
		return FALSE;
	      break;
	    }

	  /* It is referenced by a non-shared object. */
	  h->ref_regular = 1;
	  h->root.non_ir_ref = 1;
	}

      if (! elf_x86_64_tls_transition (info, abfd, sec, NULL,
				       symtab_hdr, sym_hashes,
				       &r_type, GOT_UNKNOWN,
				       rel, rel_end, h, r_symndx))
	return FALSE;

      switch (r_type)
	{
	case R_X86_64_TLSLD:
	  htab->tls_ld_got.refcount += 1;
	  goto create_got;

	case R_X86_64_TPOFF32:
	  if (!info->executable && ABI_64_P (abfd))
	    {
	      if (h)
		name = h->root.root.string;
	      else
		name = bfd_elf_sym_name (abfd, symtab_hdr, isym,
					 NULL);
	      (*_bfd_error_handler)
		(_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 abfd,
		 x86_64_elf_howto_table[r_type].name, name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  break;

	case R_X86_64_GOTTPOFF:
	  if (!info->executable)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through */

	case R_X86_64_GOT32:
	case R_X86_64_GOTPCREL:
	case R_X86_64_TLSGD:
	case R_X86_64_GOT64:
	case R_X86_64_GOTPCREL64:
	case R_X86_64_GOTPLT64:
	case R_X86_64_GOTPC32_TLSDESC:
	case R_X86_64_TLSDESC_CALL:
	  /* This symbol requires a global offset table entry.	*/
	  {
	    int tls_type, old_tls_type;

	    switch (r_type)
	      {
	      default: tls_type = GOT_NORMAL; break;
	      case R_X86_64_TLSGD: tls_type = GOT_TLS_GD; break;
	      case R_X86_64_GOTTPOFF: tls_type = GOT_TLS_IE; break;
	      case R_X86_64_GOTPC32_TLSDESC:
	      case R_X86_64_TLSDESC_CALL:
		tls_type = GOT_TLS_GDESC; break;
	      }

	    if (h != NULL)
	      {
		if (r_type == R_X86_64_GOTPLT64)
		  {
		    /* This relocation indicates that we also need
		       a PLT entry, as this is a function.  We don't need
		       a PLT entry for local symbols.  */
		    h->needs_plt = 1;
		    h->plt.refcount += 1;
		  }
		h->got.refcount += 1;
		old_tls_type = elf_x86_64_hash_entry (h)->tls_type;
	      }
	    else
	      {
		bfd_signed_vma *local_got_refcounts;

		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
		  {
		    bfd_size_type size;

		    size = symtab_hdr->sh_info;
		    size *= sizeof (bfd_signed_vma)
		      + sizeof (bfd_vma) + sizeof (char);
		    local_got_refcounts = ((bfd_signed_vma *)
					   bfd_zalloc (abfd, size));
		    if (local_got_refcounts == NULL)
		      return FALSE;
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
		    elf_x86_64_local_tlsdesc_gotent (abfd)
		      = (bfd_vma *) (local_got_refcounts + symtab_hdr->sh_info);
		    elf_x86_64_local_got_tls_type (abfd)
		      = (char *) (local_got_refcounts + 2 * symtab_hdr->sh_info);
		  }
		local_got_refcounts[r_symndx] += 1;
		old_tls_type
		  = elf_x86_64_local_got_tls_type (abfd) [r_symndx];
	      }

	    /* If a TLS symbol is accessed using IE at least once,
	       there is no point to use dynamic model for it.  */
	    if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
		&& (! GOT_TLS_GD_ANY_P (old_tls_type)
		    || tls_type != GOT_TLS_IE))
	      {
		if (old_tls_type == GOT_TLS_IE && GOT_TLS_GD_ANY_P (tls_type))
		  tls_type = old_tls_type;
		else if (GOT_TLS_GD_ANY_P (old_tls_type)
			 && GOT_TLS_GD_ANY_P (tls_type))
		  tls_type |= old_tls_type;
		else
		  {
		    if (h)
		      name = h->root.root.string;
		    else
		      name = bfd_elf_sym_name (abfd, symtab_hdr,
					       isym, NULL);
		    (*_bfd_error_handler)
		      (_("%B: '%s' accessed both as normal and thread local symbol"),
		       abfd, name);
		    bfd_set_error (bfd_error_bad_value);
		    return FALSE;
		  }
	      }

	    if (old_tls_type != tls_type)
	      {
		if (h != NULL)
		  elf_x86_64_hash_entry (h)->tls_type = tls_type;
		else
		  elf_x86_64_local_got_tls_type (abfd) [r_symndx] = tls_type;
	      }
	  }
	  /* Fall through */

	case R_X86_64_GOTOFF64:
	case R_X86_64_GOTPC32:
	case R_X86_64_GOTPC64:
	create_got:
	  if (htab->elf.sgot == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!_bfd_elf_create_got_section (htab->elf.dynobj,
						info))
		return FALSE;
	    }
	  break;

	case R_X86_64_PLT32:
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.	 */

	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.	*/
	  if (h == NULL)
	    continue;

	  h->needs_plt = 1;
	  h->plt.refcount += 1;
	  break;

	case R_X86_64_PLTOFF64:
	  /* This tries to form the 'address' of a function relative
	     to GOT.  For global symbols we need a PLT entry.  */
	  if (h != NULL)
	    {
	      h->needs_plt = 1;
	      h->plt.refcount += 1;
	    }
	  goto create_got;

	case R_X86_64_SIZE32:
	case R_X86_64_SIZE64:
	  size_reloc = TRUE;
	  goto do_size;

	case R_X86_64_32:
	  if (!ABI_64_P (abfd))
	    goto pointer;
	case R_X86_64_8:
	case R_X86_64_16:
	case R_X86_64_32S:
	  /* Let's help debug shared library creation.  These relocs
	     cannot be used in shared libs.  Don't error out for
	     sections we don't care about, such as debug sections or
	     non-constant sections.  */
	  if (info->shared
	      && (sec->flags & SEC_ALLOC) != 0
	      && (sec->flags & SEC_READONLY) != 0)
	    {
	      if (h)
		name = h->root.root.string;
	      else
		name = bfd_elf_sym_name (abfd, symtab_hdr, isym, NULL);
	      (*_bfd_error_handler)
		(_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 abfd, x86_64_elf_howto_table[r_type].name, name);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  /* Fall through.  */

	case R_X86_64_PC8:
	case R_X86_64_PC16:
	case R_X86_64_PC32:
	case R_X86_64_PC64:
	case R_X86_64_64:
pointer:
	  if (h != NULL && info->executable)
	    {
	      /* If this reloc is in a read-only section, we might
		 need a copy reloc.  We can't check reliably at this
		 stage whether the section is read-only, as input
		 sections have not yet been mapped to output sections.
		 Tentatively set the flag for now, and correct in
		 adjust_dynamic_symbol.  */
	      h->non_got_ref = 1;

	      /* We may need a .plt entry if the function this reloc
		 refers to is in a shared lib.  */
	      h->plt.refcount += 1;
	      if (r_type != R_X86_64_PC32 && r_type != R_X86_64_PC64)
		h->pointer_equality_needed = 1;
	    }

	  size_reloc = FALSE;
do_size:
	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).	At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library.  We account for that possibility below by
	     storing information in the relocs_copied field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && (! IS_X86_64_PCREL_TYPE (r_type)
		   || (h != NULL
		       && (! SYMBOLIC_BIND (info, h)
			   || h->root.type == bfd_link_hash_defweak
			   || !h->def_regular))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || !h->def_regular)))
	    {
	      struct elf_dyn_relocs *p;
	      struct elf_dyn_relocs **head;

	      /* We must copy these reloc types into the output file.
		 Create a reloc section in dynobj and make room for
		 this reloc.  */
	      if (sreloc == NULL)
		{
		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;

		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, htab->elf.dynobj, ABI_64_P (abfd) ? 3 : 2,
		     abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		{
		  head = &((struct elf_x86_64_link_hash_entry *) h)->dyn_relocs;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */
		  asection *s;
		  void **vpp;

		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						abfd, r_symndx);
		  if (isym == NULL)
		    return FALSE;

		  s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  if (s == NULL)
		    s = sec;

		  /* Beware of type punned pointers vs strict aliasing
		     rules.  */
		  vpp = &(elf_section_data (s)->local_dynrel);
		  head = (struct elf_dyn_relocs **)vpp;
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof *p;

		  p = ((struct elf_dyn_relocs *)
		       bfd_alloc (htab->elf.dynobj, amt));
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      /* Count size relocation as PC-relative relocation.  */
	      if (IS_X86_64_PCREL_TYPE (r_type) || size_reloc)
		p->pc_count += 1;
	    }
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_X86_64_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_X86_64_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.	*/

static asection *
elf_x86_64_gc_mark_hook (asection *sec,
			 struct bfd_link_info *info,
			 Elf_Internal_Rela *rel,
			 struct elf_link_hash_entry *h,
			 Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_X86_64_GNU_VTINHERIT:
      case R_X86_64_GNU_VTENTRY:
	return NULL;
      }

  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);
}

/* Update the got entry reference counts for the section being removed.	 */

static bfd_boolean
elf_x86_64_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
			  asection *sec,
			  const Elf_Internal_Rela *relocs)
{
  struct elf_x86_64_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;

  if (info->relocatable)
    return TRUE;

  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return FALSE;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  htab = elf_x86_64_hash_table (info);
  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = htab->r_sym (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	}
      else
	{
	  /* A local symbol.  */
	  Elf_Internal_Sym *isym;

	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					abfd, r_symndx);

	  /* Check relocation against local STT_GNU_IFUNC symbol.  */
	  if (isym != NULL
	      && ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
	    {
	      h = elf_x86_64_get_local_sym_hash (htab, abfd, rel, FALSE);
	      if (h == NULL)
		abort ();
	    }
	}

      if (h)
	{
	  struct elf_x86_64_link_hash_entry *eh;
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  eh = (struct elf_x86_64_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF32_R_TYPE (rel->r_info);
      if (! elf_x86_64_tls_transition (info, abfd, sec, NULL,
				       symtab_hdr, sym_hashes,
				       &r_type, GOT_UNKNOWN,
				       rel, relend, h, r_symndx))
	return FALSE;

      switch (r_type)
	{
	case R_X86_64_TLSLD:
	  if (htab->tls_ld_got.refcount > 0)
	    htab->tls_ld_got.refcount -= 1;
	  break;

	case R_X86_64_TLSGD:
	case R_X86_64_GOTPC32_TLSDESC:
	case R_X86_64_TLSDESC_CALL:
	case R_X86_64_GOTTPOFF:
	case R_X86_64_GOT32:
	case R_X86_64_GOTPCREL:
	case R_X86_64_GOT64:
	case R_X86_64_GOTPCREL64:
	case R_X86_64_GOTPLT64:
	  if (h != NULL)
	    {
	      if (r_type == R_X86_64_GOTPLT64 && h->plt.refcount > 0)
		h->plt.refcount -= 1;
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	      if (h->type == STT_GNU_IFUNC)
		{
		  if (h->plt.refcount > 0)
		    h->plt.refcount -= 1;
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_X86_64_8:
	case R_X86_64_16:
	case R_X86_64_32:
	case R_X86_64_64:
	case R_X86_64_32S:
	case R_X86_64_PC8:
	case R_X86_64_PC16:
	case R_X86_64_PC32:
	case R_X86_64_PC64:
	case R_X86_64_SIZE32:
	case R_X86_64_SIZE64:
	  if (info->shared
	      && (h == NULL || h->type != STT_GNU_IFUNC))
	    break;
	  /* Fall thru */

	case R_X86_64_PLT32:
	case R_X86_64_PLTOFF64:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.	*/

static bfd_boolean
elf_x86_64_adjust_dynamic_symbol (struct bfd_link_info *info,
				  struct elf_link_hash_entry *h)
{
  struct elf_x86_64_link_hash_table *htab;
  asection *s;
  struct elf_x86_64_link_hash_entry *eh;
  struct elf_dyn_relocs *p;

  /* STT_GNU_IFUNC symbol must go through PLT. */
  if (h->type == STT_GNU_IFUNC)
    {
      /* All local STT_GNU_IFUNC references must be treate as local
	 calls via local PLT.  */
      if (h->ref_regular
	  && SYMBOL_CALLS_LOCAL (info, h))
	{
	  bfd_size_type pc_count = 0, count = 0;
	  struct elf_dyn_relocs **pp;

	  eh = (struct elf_x86_64_link_hash_entry *) h;
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      pc_count += p->pc_count;
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      count += p->count;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }

	  if (pc_count || count)
	    {
	      h->needs_plt = 1;
	      h->non_got_ref = 1;
	      if (h->plt.refcount <= 0)
		h->plt.refcount = 1;
	      else
		h->plt.refcount += 1;
	    }
	}

      if (h->plt.refcount <= 0)
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}
      return TRUE;
    }

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later,
     when we know the address of the .got section.  */
  if (h->type == STT_FUNC
      || h->needs_plt)
    {
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
	{
	  /* This case can occur if we saw a PLT32 reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PC32 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}

      return TRUE;
    }
  else
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_X86_64_PC32 reloc to a non-function sym in
       check_relocs.  We can't decide accurately between function and
       non-function syms in check-relocs;  Objects loaded later in
       the link may change h->type.  So fix it now.  */
    h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.	 */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->non_got_ref = h->u.weakdef->non_got_ref;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.	 */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.	*/
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->non_got_ref = 0;
      return TRUE;
    }

  if (ELIMINATE_COPY_RELOCS)
    {
      eh = (struct elf_x86_64_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->non_got_ref = 0;
	  return TRUE;
	}
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.	 There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return FALSE;

  /* We must generate a R_X86_64_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
     runtime process image.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      const struct elf_backend_data *bed;
      bed = get_elf_backend_data (info->output_bfd);
      htab->srelbss->size += bed->s->sizeof_rela;
      h->needs_copy = 1;
    }

  s = htab->sdynbss;

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
elf_x86_64_allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
{
  struct bfd_link_info *info;
  struct elf_x86_64_link_hash_table *htab;
  struct elf_x86_64_link_hash_entry *eh;
  struct elf_dyn_relocs *p;
  const struct elf_backend_data *bed;
  unsigned int plt_entry_size;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  eh = (struct elf_x86_64_link_hash_entry *) h;

  info = (struct bfd_link_info *) inf;
  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return FALSE;
  bed = get_elf_backend_data (info->output_bfd);
  plt_entry_size = GET_PLT_ENTRY_SIZE (info->output_bfd);

  /* Since STT_GNU_IFUNC symbol must go through PLT, we handle it
     here if it is defined and referenced in a non-shared object.  */
  if (h->type == STT_GNU_IFUNC
      && h->def_regular)
    return _bfd_elf_allocate_ifunc_dyn_relocs (info, h,
					       &eh->dyn_relocs,
					       plt_entry_size,
					       plt_entry_size,
					       GOT_ENTRY_SIZE);
  else if (htab->elf.dynamic_sections_created
	   && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->elf.splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->size == 0)
	    s->size += plt_entry_size;

	  h->plt.offset = s->size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && !h->def_regular)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->size += plt_entry_size;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->elf.sgotplt->size += GOT_ENTRY_SIZE;

	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->elf.srelplt->size += bed->s->sizeof_rela;
	  htab->elf.srelplt->reloc_count++;
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
    }

  eh->tlsdesc_got = (bfd_vma) -1;

  /* If R_X86_64_GOTTPOFF symbol is now local to the binary,
     make it a R_X86_64_TPOFF32 requiring no GOT entry.  */
  if (h->got.refcount > 0
      && info->executable
      && h->dynindx == -1
      && elf_x86_64_hash_entry (h)->tls_type == GOT_TLS_IE)
    {
      h->got.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
    {
      asection *s;
      bfd_boolean dyn;
      int tls_type = elf_x86_64_hash_entry (h)->tls_type;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (GOT_TLS_GDESC_P (tls_type))
	{
	  eh->tlsdesc_got = htab->elf.sgotplt->size
	    - elf_x86_64_compute_jump_table_size (htab);
	  htab->elf.sgotplt->size += 2 * GOT_ENTRY_SIZE;
	  h->got.offset = (bfd_vma) -2;
	}
      if (! GOT_TLS_GDESC_P (tls_type)
	  || GOT_TLS_GD_P (tls_type))
	{
	  s = htab->elf.sgot;
	  h->got.offset = s->size;
	  s->size += GOT_ENTRY_SIZE;
	  if (GOT_TLS_GD_P (tls_type))
	    s->size += GOT_ENTRY_SIZE;
	}
      dyn = htab->elf.dynamic_sections_created;
      /* R_X86_64_TLSGD needs one dynamic relocation if local symbol
	 and two if global.
	 R_X86_64_GOTTPOFF needs one dynamic relocation.  */
      if ((GOT_TLS_GD_P (tls_type) && h->dynindx == -1)
	  || tls_type == GOT_TLS_IE)
	htab->elf.srelgot->size += bed->s->sizeof_rela;
      else if (GOT_TLS_GD_P (tls_type))
	htab->elf.srelgot->size += 2 * bed->s->sizeof_rela;
      else if (! GOT_TLS_GDESC_P (tls_type)
	       && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	htab->elf.srelgot->size += bed->s->sizeof_rela;
      if (GOT_TLS_GDESC_P (tls_type))
	{
	  htab->elf.srelplt->size += bed->s->sizeof_rela;
	  htab->tlsdesc_plt = (bfd_vma) -1;
	}
    }
  else
    h->got.offset = (bfd_vma) -1;

  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      /* Relocs that use pc_count are those that appear on a call
	 insn, or certain REL relocs that can generated via assembly.
	 We want calls to protected symbols to resolve directly to the
	 function rather than going via the plt.  If people want
	 function pointer comparisons to work as expected then they
	 should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (eh->dyn_relocs != NULL
	  && h->root.type == bfd_link_hash_undefweak)
	{
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    eh->dyn_relocs = NULL;

	  /* Make sure undefined weak symbols are output as a dynamic
	     symbol in PIEs.  */
	  else if (h->dynindx == -1
		   && ! h->forced_local
		   && ! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

    }
  else if (ELIMINATE_COPY_RELOCS)
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
	      || (htab->elf.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && ! h->forced_local
	      && ! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection * sreloc;

      sreloc = elf_section_data (p->sec)->sreloc;

      BFD_ASSERT (sreloc != NULL);

      sreloc->size += p->count * bed->s->sizeof_rela;
    }

  return TRUE;
}

/* Allocate space in .plt, .got and associated reloc sections for
   local dynamic relocs.  */

static bfd_boolean
elf_x86_64_allocate_local_dynrelocs (void **slot, void *inf)
{
  struct elf_link_hash_entry *h
    = (struct elf_link_hash_entry *) *slot;

  if (h->type != STT_GNU_IFUNC
      || !h->def_regular
      || !h->ref_regular
      || !h->forced_local
      || h->root.type != bfd_link_hash_defined)
    abort ();

  return elf_x86_64_allocate_dynrelocs (h, inf);
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
elf_x86_64_readonly_dynrelocs (struct elf_link_hash_entry *h,
			       void * inf)
{
  struct elf_x86_64_link_hash_entry *eh;
  struct elf_dyn_relocs *p;

  /* Skip local IFUNC symbols. */
  if (h->forced_local && h->type == STT_GNU_IFUNC)
    return TRUE;

  eh = (struct elf_x86_64_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  if (info->warn_shared_textrel && info->shared)
	    info->callbacks->einfo (_("%P: %B: warning: relocation against `%s' in readonly section `%A'.\n"),
				    p->sec->owner, h->root.root.string,
				    p->sec);

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

/* Convert
   mov foo@@GOTPCREL(%rip), %reg
   to
   lea foo(%rip), %reg
   with the local symbol, foo.  */

static bfd_boolean
elf_x86_64_convert_mov_to_lea (bfd *abfd, asection *sec,
			       struct bfd_link_info *link_info)
{
  Elf_Internal_Shdr *symtab_hdr;
  Elf_Internal_Rela *internal_relocs;
  Elf_Internal_Rela *irel, *irelend;
  bfd_byte *contents;
  struct elf_x86_64_link_hash_table *htab;
  bfd_boolean changed_contents;
  bfd_boolean changed_relocs;
  bfd_signed_vma *local_got_refcounts;

  /* Don't even try to convert non-ELF outputs.  */
  if (!is_elf_hash_table (link_info->hash))
    return FALSE;

  /* Nothing to do if there are no codes, no relocations or no output.  */
  if ((sec->flags & (SEC_CODE | SEC_RELOC)) != (SEC_CODE | SEC_RELOC)
      || sec->reloc_count == 0
      || discarded_section (sec))
    return TRUE;

  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;

  /* Load the relocations for this section.  */
  internal_relocs = (_bfd_elf_link_read_relocs
		     (abfd, sec, NULL, (Elf_Internal_Rela *) NULL,
		      link_info->keep_memory));
  if (internal_relocs == NULL)
    return FALSE;

  htab = elf_x86_64_hash_table (link_info);
  changed_contents = FALSE;
  changed_relocs = FALSE;
  local_got_refcounts = elf_local_got_refcounts (abfd);

  /* Get the section contents.  */
  if (elf_section_data (sec)->this_hdr.contents != NULL)
    contents = elf_section_data (sec)->this_hdr.contents;
  else
    {
      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
	goto error_return;
    }

  irelend = internal_relocs + sec->reloc_count;
  for (irel = internal_relocs; irel < irelend; irel++)
    {
      unsigned int r_type = ELF32_R_TYPE (irel->r_info);
      unsigned int r_symndx = htab->r_sym (irel->r_info);
      unsigned int indx;
      struct elf_link_hash_entry *h;

      if (r_type != R_X86_64_GOTPCREL)
	continue;

      /* Get the symbol referred to by the reloc.  */
      if (r_symndx < symtab_hdr->sh_info)
	{
	  Elf_Internal_Sym *isym;

	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					abfd, r_symndx);

	  /* STT_GNU_IFUNC must keep R_X86_64_GOTPCREL relocation.  */
	  if (ELF_ST_TYPE (isym->st_info) != STT_GNU_IFUNC
	      && bfd_get_8 (input_bfd,
			    contents + irel->r_offset - 2) == 0x8b)
	    {
	      bfd_put_8 (output_bfd, 0x8d,
			 contents + irel->r_offset - 2);
	      irel->r_info = htab->r_info (r_symndx, R_X86_64_PC32);
	      if (local_got_refcounts != NULL
		  && local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	      changed_contents = TRUE;
	      changed_relocs = TRUE;
	    }
	  continue;
	}

      indx = r_symndx - symtab_hdr->sh_info;
      h = elf_sym_hashes (abfd)[indx];
      BFD_ASSERT (h != NULL);

      while (h->root.type == bfd_link_hash_indirect
	     || h->root.type == bfd_link_hash_warning)
	h = (struct elf_link_hash_entry *) h->root.u.i.link;

      /* STT_GNU_IFUNC must keep R_X86_64_GOTPCREL relocation.  We also
	 avoid optimizing _DYNAMIC since ld.so may use its link-time
	 address.  */
      if (h->def_regular
	  && h->type != STT_GNU_IFUNC
	  && h != htab->elf.hdynamic
	  && SYMBOL_REFERENCES_LOCAL (link_info, h)
	  && bfd_get_8 (input_bfd,
			contents + irel->r_offset - 2) == 0x8b)
	{
	  bfd_put_8 (output_bfd, 0x8d,
		     contents + irel->r_offset - 2);
	  irel->r_info = htab->r_info (r_symndx, R_X86_64_PC32);
	  if (h->got.refcount > 0)
	    h->got.refcount -= 1;
	  changed_contents = TRUE;
	  changed_relocs = TRUE;
	}
    }

  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    {
      if (!changed_contents && !link_info->keep_memory)
	free (contents);
      else
	{
	  /* Cache the section contents for elf_link_input_bfd.  */
	  elf_section_data (sec)->this_hdr.contents = contents;
	}
    }

  if (elf_section_data (sec)->relocs != internal_relocs)
    {
      if (!changed_relocs)
	free (internal_relocs);
      else
	elf_section_data (sec)->relocs = internal_relocs;
    }

  return TRUE;

 error_return:
  if (contents != NULL
      && elf_section_data (sec)->this_hdr.contents != contents)
    free (contents);
  if (internal_relocs != NULL
      && elf_section_data (sec)->relocs != internal_relocs)
    free (internal_relocs);
  return FALSE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf_x86_64_size_dynamic_sections (bfd *output_bfd,
				  struct bfd_link_info *info)
{
  struct elf_x86_64_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;
  const struct elf_backend_data *bed;

  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return FALSE;
  bed = get_elf_backend_data (output_bfd);

  dynobj = htab->elf.dynobj;
  if (dynobj == NULL)
    abort ();

  if (htab->elf.dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  if (s == NULL)
	    abort ();
	  s->size = htab->dynamic_interpreter_size;
	  s->contents = (unsigned char *) htab->dynamic_interpreter;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *local_tls_type;
      bfd_vma *local_tlsdesc_gotent;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;

      if (! is_x86_64_elf (ibfd))
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf_dyn_relocs *p;

	  if (!elf_x86_64_convert_mov_to_lea (ibfd, s, info))
	    return FALSE;

	  for (p = (struct elf_dyn_relocs *)
		    (elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
	    {
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->sec)->sreloc;
		  srel->size += p->count * bed->s->sizeof_rela;
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0
		      && (info->flags & DF_TEXTREL) == 0)
		    {
		      info->flags |= DF_TEXTREL;
		      if (info->warn_shared_textrel && info->shared)
			info->callbacks->einfo (_("%P: %B: warning: relocation in readonly section `%A'.\n"),
						p->sec->owner, p->sec);
		    }
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_symtab_hdr (ibfd);
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      local_tls_type = elf_x86_64_local_got_tls_type (ibfd);
      local_tlsdesc_gotent = elf_x86_64_local_tlsdesc_gotent (ibfd);
      s = htab->elf.sgot;
      srel = htab->elf.srelgot;
      for (; local_got < end_local_got;
	   ++local_got, ++local_tls_type, ++local_tlsdesc_gotent)
	{
	  *local_tlsdesc_gotent = (bfd_vma) -1;
	  if (*local_got > 0)
	    {
	      if (GOT_TLS_GDESC_P (*local_tls_type))
		{
		  *local_tlsdesc_gotent = htab->elf.sgotplt->size
		    - elf_x86_64_compute_jump_table_size (htab);
		  htab->elf.sgotplt->size += 2 * GOT_ENTRY_SIZE;
		  *local_got = (bfd_vma) -2;
		}
	      if (! GOT_TLS_GDESC_P (*local_tls_type)
		  || GOT_TLS_GD_P (*local_tls_type))
		{
		  *local_got = s->size;
		  s->size += GOT_ENTRY_SIZE;
		  if (GOT_TLS_GD_P (*local_tls_type))
		    s->size += GOT_ENTRY_SIZE;
		}
	      if (info->shared
		  || GOT_TLS_GD_ANY_P (*local_tls_type)
		  || *local_tls_type == GOT_TLS_IE)
		{
		  if (GOT_TLS_GDESC_P (*local_tls_type))
		    {
		      htab->elf.srelplt->size
			+= bed->s->sizeof_rela;
		      htab->tlsdesc_plt = (bfd_vma) -1;
		    }
		  if (! GOT_TLS_GDESC_P (*local_tls_type)
		      || GOT_TLS_GD_P (*local_tls_type))
		    srel->size += bed->s->sizeof_rela;
		}
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}
    }

  if (htab->tls_ld_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_X86_64_TLSLD
	 relocs.  */
      htab->tls_ld_got.offset = htab->elf.sgot->size;
      htab->elf.sgot->size += 2 * GOT_ENTRY_SIZE;
      htab->elf.srelgot->size += bed->s->sizeof_rela;
    }
  else
    htab->tls_ld_got.offset = -1;

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->elf, elf_x86_64_allocate_dynrelocs,
			  info);

  /* Allocate .plt and .got entries, and space for local symbols.  */
  htab_traverse (htab->loc_hash_table,
		 elf_x86_64_allocate_local_dynrelocs,
		 info);

  /* For every jump slot reserved in the sgotplt, reloc_count is
     incremented.  However, when we reserve space for TLS descriptors,
     it's not incremented, so in order to compute the space reserved
     for them, it suffices to multiply the reloc count by the jump
     slot size.

     PR ld/13302: We start next_irelative_index at the end of .rela.plt
     so that R_X86_64_IRELATIVE entries come last.  */
  if (htab->elf.srelplt)
    {
      htab->sgotplt_jump_table_size
	= elf_x86_64_compute_jump_table_size (htab);
      htab->next_irelative_index = htab->elf.srelplt->reloc_count - 1;
    }
  else if (htab->elf.irelplt)
    htab->next_irelative_index = htab->elf.irelplt->reloc_count - 1;

  if (htab->tlsdesc_plt)
    {
      /* If we're not using lazy TLS relocations, don't generate the
	 PLT and GOT entries they require.  */
      if ((info->flags & DF_BIND_NOW))
	htab->tlsdesc_plt = 0;
      else
	{
	  htab->tlsdesc_got = htab->elf.sgot->size;
	  htab->elf.sgot->size += GOT_ENTRY_SIZE;
	  /* Reserve room for the initial entry.
	     FIXME: we could probably do away with it in this case.  */
	  if (htab->elf.splt->size == 0)
	    htab->elf.splt->size += GET_PLT_ENTRY_SIZE (output_bfd);
	  htab->tlsdesc_plt = htab->elf.splt->size;
	  htab->elf.splt->size += GET_PLT_ENTRY_SIZE (output_bfd);
	}
    }

  if (htab->elf.sgotplt)
    {
      /* Don't allocate .got.plt section if there are no GOT nor PLT
	 entries and there is no refeence to _GLOBAL_OFFSET_TABLE_.  */
      if ((htab->elf.hgot == NULL
	   || !htab->elf.hgot->ref_regular_nonweak)
	  && (htab->elf.sgotplt->size
	      == get_elf_backend_data (output_bfd)->got_header_size)
	  && (htab->elf.splt == NULL
	      || htab->elf.splt->size == 0)
	  && (htab->elf.sgot == NULL
	      || htab->elf.sgot->size == 0)
	  && (htab->elf.iplt == NULL
	      || htab->elf.iplt->size == 0)
	  && (htab->elf.igotplt == NULL
	      || htab->elf.igotplt->size == 0))
	htab->elf.sgotplt->size = 0;
    }

  if (htab->plt_eh_frame != NULL
      && htab->elf.splt != NULL
      && htab->elf.splt->size != 0
      && !bfd_is_abs_section (htab->elf.splt->output_section)
      && _bfd_elf_eh_frame_present (info))
    {
      const struct elf_x86_64_backend_data *arch_data
	= get_elf_x86_64_arch_data (bed);
      htab->plt_eh_frame->size = arch_data->eh_frame_plt_size;
    }

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->elf.splt
	  || s == htab->elf.sgot
	  || s == htab->elf.sgotplt
	  || s == htab->elf.iplt
	  || s == htab->elf.igotplt
	  || s == htab->plt_eh_frame
	  || s == htab->sdynbss)
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
	{
	  if (s->size != 0 && s != htab->elf.srelplt)
	    relocs = TRUE;

	  /* We use the reloc_count field as a counter if we need
	     to copy relocs into the output file.  */
	  if (s != htab->elf.srelplt)
	    s->reloc_count = 0;
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */

	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  We use bfd_zalloc
	 here in case unused entries are not reclaimed before the
	 section's contents are written out.  This should not happen,
	 but this way if it does, we get a R_X86_64_NONE reloc instead
	 of garbage.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  if (htab->plt_eh_frame != NULL
      && htab->plt_eh_frame->contents != NULL)
    {
      const struct elf_x86_64_backend_data *arch_data
	= get_elf_x86_64_arch_data (bed);

      memcpy (htab->plt_eh_frame->contents,
	      arch_data->eh_frame_plt, htab->plt_eh_frame->size);
      bfd_put_32 (dynobj, htab->elf.splt->size,
		  htab->plt_eh_frame->contents + PLT_FDE_LEN_OFFSET);
    }

  if (htab->elf.dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_x86_64_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.	The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->elf.splt->size != 0)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;

	  if (htab->tlsdesc_plt
	      && (!add_dynamic_entry (DT_TLSDESC_PLT, 0)
		  || !add_dynamic_entry (DT_TLSDESC_GOT, 0)))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, bed->s->sizeof_rela))
	    return FALSE;

	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->elf,
				    elf_x86_64_readonly_dynrelocs,
				    info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (!add_dynamic_entry (DT_TEXTREL, 0))
		return FALSE;
	    }
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

static bfd_boolean
elf_x86_64_always_size_sections (bfd *output_bfd,
				 struct bfd_link_info *info)
{
  asection *tls_sec = elf_hash_table (info)->tls_sec;

  if (tls_sec)
    {
      struct elf_link_hash_entry *tlsbase;

      tlsbase = elf_link_hash_lookup (elf_hash_table (info),
				      "_TLS_MODULE_BASE_",
				      FALSE, FALSE, FALSE);

      if (tlsbase && tlsbase->type == STT_TLS)
	{
	  struct elf_x86_64_link_hash_table *htab;
	  struct bfd_link_hash_entry *bh = NULL;
	  const struct elf_backend_data *bed
	    = get_elf_backend_data (output_bfd);

	  htab = elf_x86_64_hash_table (info);
	  if (htab == NULL)
	    return FALSE;

	  if (!(_bfd_generic_link_add_one_symbol
		(info, output_bfd, "_TLS_MODULE_BASE_", BSF_LOCAL,
		 tls_sec, 0, NULL, FALSE,
		 bed->collect, &bh)))
	    return FALSE;

	  htab->tls_module_base = bh;

	  tlsbase = (struct elf_link_hash_entry *)bh;
	  tlsbase->def_regular = 1;
	  tlsbase->other = STV_HIDDEN;
	  (*bed->elf_backend_hide_symbol) (info, tlsbase, TRUE);
	}
    }

  return TRUE;
}

/* _TLS_MODULE_BASE_ needs to be treated especially when linking
   executables.  Rather than setting it to the beginning of the TLS
   section, we have to set it to the end.  This function may be called
   multiple times, it is idempotent.  */

static void
elf_x86_64_set_tls_module_base (struct bfd_link_info *info)
{
  struct elf_x86_64_link_hash_table *htab;
  struct bfd_link_hash_entry *base;

  if (!info->executable)
    return;

  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return;

  base = htab->tls_module_base;
  if (base == NULL)
    return;

  base->u.def.value = htab->elf.tls_size;
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
elf_x86_64_dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
elf_x86_64_tpoff (struct bfd_link_info *info, bfd_vma address)
{
  struct elf_link_hash_table *htab = elf_hash_table (info);
  const struct elf_backend_data *bed = get_elf_backend_data (info->output_bfd);
  bfd_vma static_tls_size;

  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;

  /* Consider special static TLS alignment requirements.  */
  static_tls_size = BFD_ALIGN (htab->tls_size, bed->static_tls_alignment);
  return address - static_tls_size - htab->tls_sec->vma;
}

/* Is the instruction before OFFSET in CONTENTS a 32bit relative
   branch?  */

static bfd_boolean
is_32bit_relative_branch (bfd_byte *contents, bfd_vma offset)
{
  /* Opcode		Instruction
     0xe8		call
     0xe9		jump
     0x0f 0x8x		conditional jump */
  return ((offset > 0
	   && (contents [offset - 1] == 0xe8
	       || contents [offset - 1] == 0xe9))
	  || (offset > 1
	      && contents [offset - 2] == 0x0f
	      && (contents [offset - 1] & 0xf0) == 0x80));
}

/* Relocate an x86_64 ELF section.  */

static bfd_boolean
elf_x86_64_relocate_section (bfd *output_bfd,
			     struct bfd_link_info *info,
			     bfd *input_bfd,
			     asection *input_section,
			     bfd_byte *contents,
			     Elf_Internal_Rela *relocs,
			     Elf_Internal_Sym *local_syms,
			     asection **local_sections)
{
  struct elf_x86_64_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  bfd_vma *local_tlsdesc_gotents;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;
  const unsigned int plt_entry_size = GET_PLT_ENTRY_SIZE (info->output_bfd);

  BFD_ASSERT (is_x86_64_elf (input_bfd));

  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return FALSE;
  symtab_hdr = &elf_symtab_hdr (input_bfd);
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);
  local_tlsdesc_gotents = elf_x86_64_local_tlsdesc_gotent (input_bfd);

  elf_x86_64_set_tls_module_base (info);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      unsigned int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma off, offplt;
      bfd_vma relocation;
      bfd_boolean unresolved_reloc;
      bfd_reloc_status_type r;
      int tls_type;
      asection *base_got;
      bfd_vma st_size;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type == (int) R_X86_64_GNU_VTINHERIT
	  || r_type == (int) R_X86_64_GNU_VTENTRY)
	continue;

      if (r_type >= (int) R_X86_64_standard)
	{
	  (*_bfd_error_handler)
	    (_("%B: unrecognized relocation (0x%x) in section `%A'"),
	     input_bfd, input_section, r_type);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      if (r_type != (int) R_X86_64_32
	  || ABI_64_P (output_bfd))
	howto = x86_64_elf_howto_table + r_type;
      else
	howto = (x86_64_elf_howto_table
		 + ARRAY_SIZE (x86_64_elf_howto_table) - 1);
      r_symndx = htab->r_sym (rel->r_info);
      h = NULL;
      sym = NULL;
      sec = NULL;
      unresolved_reloc = FALSE;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];

	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym,
						&sec, rel);
	  st_size = sym->st_size;

	  /* Relocate against local STT_GNU_IFUNC symbol.  */
	  if (!info->relocatable
	      && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
	    {
	      h = elf_x86_64_get_local_sym_hash (htab, input_bfd,
						 rel, FALSE);
	      if (h == NULL)
		abort ();

	      /* Set STT_GNU_IFUNC symbol value.  */
	      h->root.u.def.value = sym->st_value;
	      h->root.u.def.section = sec;
	    }
	}
      else
	{
	  bfd_boolean warned ATTRIBUTE_UNUSED;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	  st_size = h->size;
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      if (rel->r_addend == 0 && !ABI_64_P (output_bfd))
	{
	  if (r_type == R_X86_64_64)
	    {
	      /* For x32, treat R_X86_64_64 like R_X86_64_32 and
		 zero-extend it to 64bit if addend is zero.  */
	      r_type = R_X86_64_32;
	      memset (contents + rel->r_offset + 4, 0, 4);
	    }
	  else if (r_type == R_X86_64_SIZE64)
	    {
	      /* For x32, treat R_X86_64_SIZE64 like R_X86_64_SIZE32 and
		 zero-extend it to 64bit if addend is zero.  */
	      r_type = R_X86_64_SIZE32;
	      memset (contents + rel->r_offset + 4, 0, 4);
	    }
	}

      /* Since STT_GNU_IFUNC symbol must go through PLT, we handle
	 it here if it is defined in a non-shared object.  */
      if (h != NULL
	  && h->type == STT_GNU_IFUNC
	  && h->def_regular)
	{
	  asection *plt;
	  bfd_vma plt_index;
	  const char *name;

	  if ((input_section->flags & SEC_ALLOC) == 0
	      || h->plt.offset == (bfd_vma) -1)
	    abort ();

	  /* STT_GNU_IFUNC symbol must go through PLT.  */
	  plt = htab->elf.splt ? htab->elf.splt : htab->elf.iplt;
	  relocation = (plt->output_section->vma
			+ plt->output_offset + h->plt.offset);

	  switch (r_type)
	    {
	    default:
	      if (h->root.root.string)
		name = h->root.root.string;
	      else
		name = bfd_elf_sym_name (input_bfd, symtab_hdr, sym,
					 NULL);
	      (*_bfd_error_handler)
		(_("%B: relocation %s against STT_GNU_IFUNC "
		   "symbol `%s' isn't handled by %s"), input_bfd,
		 x86_64_elf_howto_table[r_type].name,
		 name, __FUNCTION__);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;

	    case R_X86_64_32S:
	      if (info->shared)
		abort ();
	      goto do_relocation;

	    case R_X86_64_32:
	      if (ABI_64_P (output_bfd))
		goto do_relocation;
	      /* FALLTHROUGH */
	    case R_X86_64_64:
	      if (rel->r_addend != 0)
		{
		  if (h->root.root.string)
		    name = h->root.root.string;
		  else
		    name = bfd_elf_sym_name (input_bfd, symtab_hdr,
					     sym, NULL);
		  (*_bfd_error_handler)
		    (_("%B: relocation %s against STT_GNU_IFUNC "
		       "symbol `%s' has non-zero addend: %d"),
		     input_bfd, x86_64_elf_howto_table[r_type].name,
		     name, rel->r_addend);
		  bfd_set_error (bfd_error_bad_value);
		  return FALSE;
		}

	      /* Generate dynamic relcoation only when there is a
		 non-GOT reference in a shared object.  */
	      if (info->shared && h->non_got_ref)
		{
		  Elf_Internal_Rela outrel;
		  asection *sreloc;

		  /* Need a dynamic relocation to get the real function
		     address.  */
		  outrel.r_offset = _bfd_elf_section_offset (output_bfd,
							     info,
							     input_section,
							     rel->r_offset);
		  if (outrel.r_offset == (bfd_vma) -1
		      || outrel.r_offset == (bfd_vma) -2)
		    abort ();

		  outrel.r_offset += (input_section->output_section->vma
				      + input_section->output_offset);

		  if (h->dynindx == -1
		      || h->forced_local
		      || info->executable)
		    {
		      /* This symbol is resolved locally.  */
		      outrel.r_info = htab->r_info (0, R_X86_64_IRELATIVE);
		      outrel.r_addend = (h->root.u.def.value
					 + h->root.u.def.section->output_section->vma
					 + h->root.u.def.section->output_offset);
		    }
		  else
		    {
		      outrel.r_info = htab->r_info (h->dynindx, r_type);
		      outrel.r_addend = 0;
		    }

		  sreloc = htab->elf.irelifunc;
		  elf_append_rela (output_bfd, sreloc, &outrel);

		  /* If this reloc is against an external symbol, we
		     do not want to fiddle with the addend.  Otherwise,
		     we need to include the symbol value so that it
		     becomes an addend for the dynamic reloc.  For an
		     internal symbol, we have updated addend.  */
		  continue;
		}
	      /* FALLTHROUGH */
	    case R_X86_64_PC32:
	    case R_X86_64_PC64:
	    case R_X86_64_PLT32:
	      goto do_relocation;

	    case R_X86_64_GOTPCREL:
	    case R_X86_64_GOTPCREL64:
	      base_got = htab->elf.sgot;
	      off = h->got.offset;

	      if (base_got == NULL)
		abort ();

	      if (off == (bfd_vma) -1)
		{
		  /* We can't use h->got.offset here to save state, or
		     even just remember the offset, as finish_dynamic_symbol
		     would use that as offset into .got.  */

		  if (htab->elf.splt != NULL)
		    {
		      plt_index = h->plt.offset / plt_entry_size - 1;
		      off = (plt_index + 3) * GOT_ENTRY_SIZE;
		      base_got = htab->elf.sgotplt;
		    }
		  else
		    {
		      plt_index = h->plt.offset / plt_entry_size;
		      off = plt_index * GOT_ENTRY_SIZE;
		      base_got = htab->elf.igotplt;
		    }

		  if (h->dynindx == -1
		      || h->forced_local
		      || info->symbolic)
		    {
		      /* This references the local defitionion.  We must
			 initialize this entry in the global offset table.
			 Since the offset must always be a multiple of 8,
			 we use the least significant bit to record
			 whether we have initialized it already.

			 When doing a dynamic link, we create a .rela.got
			 relocation entry to initialize the value.  This
			 is done in the finish_dynamic_symbol routine.	 */
		      if ((off & 1) != 0)
			off &= ~1;
		      else
			{
			  bfd_put_64 (output_bfd, relocation,
				      base_got->contents + off);
			  /* Note that this is harmless for the GOTPLT64
			     case, as -1 | 1 still is -1.  */
			  h->got.offset |= 1;
			}
		    }
		}

	      relocation = (base_got->output_section->vma
			    + base_got->output_offset + off);

	      goto do_relocation;
	    }
	}

      /* When generating a shared object, the relocations handled here are
	 copied into the output file to be resolved at run time.  */
      switch (r_type)
	{
	case R_X86_64_GOT32:
	case R_X86_64_GOT64:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	case R_X86_64_GOTPCREL:
	case R_X86_64_GOTPCREL64:
	  /* Use global offset table entry as symbol value.  */
	case R_X86_64_GOTPLT64:
	  /* This is the same as GOT64 for relocation purposes, but
	     indicates the existence of a PLT entry.  The difficulty is,
	     that we must calculate the GOT slot offset from the PLT
	     offset, if this symbol got a PLT entry (it was global).
	     Additionally if it's computed from the PLT entry, then that
	     GOT offset is relative to .got.plt, not to .got.  */
	  base_got = htab->elf.sgot;

	  if (htab->elf.sgot == NULL)
	    abort ();

	  if (h != NULL)
	    {
	      bfd_boolean dyn;

	      off = h->got.offset;
	      if (h->needs_plt
		  && h->plt.offset != (bfd_vma)-1
		  && off == (bfd_vma)-1)
		{
		  /* We can't use h->got.offset here to save
		     state, or even just remember the offset, as
		     finish_dynamic_symbol would use that as offset into
		     .got.  */
		  bfd_vma plt_index = h->plt.offset / plt_entry_size - 1;
		  off = (plt_index + 3) * GOT_ENTRY_SIZE;
		  base_got = htab->elf.sgotplt;
		}

	      dyn = htab->elf.dynamic_sections_created;

	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		  || (info->shared
		      && SYMBOL_REFERENCES_LOCAL (info, h))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
		{
		  /* This is actually a static link, or it is a -Bsymbolic
		     link and the symbol is defined locally, or the symbol
		     was forced to be local because of a version file.	We
		     must initialize this entry in the global offset table.
		     Since the offset must always be a multiple of 8, we
		     use the least significant bit to record whether we
		     have initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.	This is
		     done in the finish_dynamic_symbol routine.	 */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_64 (output_bfd, relocation,
				  base_got->contents + off);
		      /* Note that this is harmless for the GOTPLT64 case,
			 as -1 | 1 still is -1.  */
		      h->got.offset |= 1;
		    }
		}
	      else
		unresolved_reloc = FALSE;
	    }
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 8.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.	 */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_64 (output_bfd, relocation,
			      base_got->contents + off);

		  if (info->shared)
		    {
		      asection *s;
		      Elf_Internal_Rela outrel;

		      /* We need to generate a R_X86_64_RELATIVE reloc
			 for the dynamic linker.  */
		      s = htab->elf.srelgot;
		      if (s == NULL)
			abort ();

		      outrel.r_offset = (base_got->output_section->vma
					 + base_got->output_offset
					 + off);
		      outrel.r_info = htab->r_info (0, R_X86_64_RELATIVE);
		      outrel.r_addend = relocation;
		      elf_append_rela (output_bfd, s, &outrel);
		    }

		  local_got_offsets[r_symndx] |= 1;
		}
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();

	  relocation = base_got->output_section->vma
		       + base_got->output_offset + off;
	  if (r_type != R_X86_64_GOTPCREL && r_type != R_X86_64_GOTPCREL64)
	    relocation -= htab->elf.sgotplt->output_section->vma
			  - htab->elf.sgotplt->output_offset;

	  break;

	case R_X86_64_GOTOFF64:
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  /* Check to make sure it isn't a protected function symbol
	     for shared library since it may not be local when used
	     as function address.  */
	  if (!info->executable
	      && h
	      && !SYMBOLIC_BIND (info, h)
	      && h->def_regular
	      && h->type == STT_FUNC
	      && ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
	    {
	      (*_bfd_error_handler)
		(_("%B: relocation R_X86_64_GOTOFF64 against protected function `%s' can not be used when making a shared object"),
		 input_bfd, h->root.root.string);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }

	  /* Note that sgot is not involved in this
	     calculation.  We always want the start of .got.plt.  If we
	     defined _GLOBAL_OFFSET_TABLE_ in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  relocation -= htab->elf.sgotplt->output_section->vma
			+ htab->elf.sgotplt->output_offset;
	  break;

	case R_X86_64_GOTPC32:
	case R_X86_64_GOTPC64:
	  /* Use global offset table as symbol value.  */
	  relocation = htab->elf.sgotplt->output_section->vma
		       + htab->elf.sgotplt->output_offset;
	  unresolved_reloc = FALSE;
	  break;

	case R_X86_64_PLTOFF64:
	  /* Relocation is PLT entry relative to GOT.  For local
	     symbols it's the symbol itself relative to GOT.  */
	  if (h != NULL
	      /* See PLT32 handling.  */
	      && h->plt.offset != (bfd_vma) -1
	      && htab->elf.splt != NULL)
	    {
	      relocation = (htab->elf.splt->output_section->vma
			    + htab->elf.splt->output_offset
			    + h->plt.offset);
	      unresolved_reloc = FALSE;
	    }

	  relocation -= htab->elf.sgotplt->output_section->vma
			+ htab->elf.sgotplt->output_offset;
	  break;

	case R_X86_64_PLT32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT32 reloc against a local symbol directly,
	     without using the procedure linkage table.	 */
	  if (h == NULL)
	    break;

	  if (h->plt.offset == (bfd_vma) -1
	      || htab->elf.splt == NULL)
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }

	  relocation = (htab->elf.splt->output_section->vma
			+ htab->elf.splt->output_offset
			+ h->plt.offset);
	  unresolved_reloc = FALSE;
	  break;

	case R_X86_64_SIZE32:
	case R_X86_64_SIZE64:
	  /* Set to symbol size.  */
	  relocation = st_size;
	  goto direct;

	case R_X86_64_PC8:
	case R_X86_64_PC16:
	case R_X86_64_PC32:
	  if (info->shared
	      && (input_section->flags & SEC_ALLOC) != 0
	      && (input_section->flags & SEC_READONLY) != 0
	      && h != NULL)
	    {
	      bfd_boolean fail = FALSE;
	      bfd_boolean branch
		= (r_type == R_X86_64_PC32
		   && is_32bit_relative_branch (contents, rel->r_offset));

	      if (SYMBOL_REFERENCES_LOCAL (info, h))
		{
		  /* Symbol is referenced locally.  Make sure it is
		     defined locally or for a branch.  */
		  fail = !h->def_regular && !branch;
		}
	      else
		{
		  /* Symbol isn't referenced locally.  We only allow
		     branch to symbol with non-default visibility. */
		  fail = (!branch
			  || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT);
		}

	      if (fail)
		{
		  const char *fmt;
		  const char *v;
		  const char *pic = "";

		  switch (ELF_ST_VISIBILITY (h->other))
		    {
		    case STV_HIDDEN:
		      v = _("hidden symbol");
		      break;
		    case STV_INTERNAL:
		      v = _("internal symbol");
		      break;
		    case STV_PROTECTED:
		      v = _("protected symbol");
		      break;
		    default:
		      v = _("symbol");
		      pic = _("; recompile with -fPIC");
		      break;
		    }

		  if (h->def_regular)
		    fmt = _("%B: relocation %s against %s `%s' can not be used when making a shared object%s");
		  else
		    fmt = _("%B: relocation %s against undefined %s `%s' can not be used when making a shared object%s");

		  (*_bfd_error_handler) (fmt, input_bfd,
					 x86_64_elf_howto_table[r_type].name,
					 v,  h->root.root.string, pic);
		  bfd_set_error (bfd_error_bad_value);
		  return FALSE;
		}
	    }
	  /* Fall through.  */

	case R_X86_64_8:
	case R_X86_64_16:
	case R_X86_64_32:
	case R_X86_64_PC64:
	case R_X86_64_64:
	  /* FIXME: The ABI says the linker should make sure the value is
	     the same when it's zeroextended to 64 bit.	 */

direct:
	  if ((input_section->flags & SEC_ALLOC) == 0)
	    break;

	  if ((info->shared
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
	       && ((! IS_X86_64_PCREL_TYPE (r_type)
		      && r_type != R_X86_64_SIZE32
		      && r_type != R_X86_64_SIZE64)
		   || ! SYMBOL_CALLS_LOCAL (info, h)))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && h != NULL
		  && h->dynindx != -1
		  && !h->non_got_ref
		  && ((h->def_dynamic
		       && !h->def_regular)
		      || h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined)))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate;
	      asection *sreloc;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.	*/
	      skip = FALSE;
	      relocate = FALSE;

	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		skip = TRUE;
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;

	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		memset (&outrel, 0, sizeof outrel);

	      /* h->dynindx may be -1 if this symbol was marked to
		 become local.  */
	      else if (h != NULL
		       && h->dynindx != -1
		       && (IS_X86_64_PCREL_TYPE (r_type)
			   || ! info->shared
			   || ! SYMBOLIC_BIND (info, h)
			   || ! h->def_regular))
		{
		  outrel.r_info = htab->r_info (h->dynindx, r_type);
		  outrel.r_addend = rel->r_addend;
		}
	      else
		{
		  /* This symbol is local, or marked to become local.  */
		  if (r_type == htab->pointer_r_type)
		    {
		      relocate = TRUE;
		      outrel.r_info = htab->r_info (0, R_X86_64_RELATIVE);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
		  else if (r_type == R_X86_64_64
			   && !ABI_64_P (output_bfd))
		    {
		      relocate = TRUE;
		      outrel.r_info = htab->r_info (0,
						    R_X86_64_RELATIVE64);
		      outrel.r_addend = relocation + rel->r_addend;
		      /* Check addend overflow.  */
		      if ((outrel.r_addend & 0x80000000)
			  != (rel->r_addend & 0x80000000))
			{
			  const char *name;
			  int addend = rel->r_addend;
			  if (h && h->root.root.string)
			    name = h->root.root.string;
			  else
			    name = bfd_elf_sym_name (input_bfd, symtab_hdr,
						     sym, NULL);
			  if (addend < 0)
			    (*_bfd_error_handler)
			      (_("%B: addend -0x%x in relocation %s against "
				 "symbol `%s' at 0x%lx in section `%A' is "
				 "out of range"),
			       input_bfd, input_section, addend,
			       x86_64_elf_howto_table[r_type].name,
			       name, (unsigned long) rel->r_offset);
			  else
			    (*_bfd_error_handler)
			      (_("%B: addend 0x%x in relocation %s against "
				 "symbol `%s' at 0x%lx in section `%A' is "
				 "out of range"),
			       input_bfd, input_section, addend,
			       x86_64_elf_howto_table[r_type].name,
			       name, (unsigned long) rel->r_offset);
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		    }
		  else
		    {
		      long sindx;

		      if (bfd_is_abs_section (sec))
			sindx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  /* We are turning this relocation into one
			     against a section symbol.  It would be
			     proper to subtract the symbol's value,
			     osec->vma, from the emitted reloc addend,
			     but ld.so expects buggy relocs.  */
			  osec = sec->output_section;
			  sindx = elf_section_data (osec)->dynindx;
			  if (sindx == 0)
			    {
			      asection *oi = htab->elf.text_index_section;
			      sindx = elf_section_data (oi)->dynindx;
			    }
			  BFD_ASSERT (sindx != 0);
			}

		      outrel.r_info = htab->r_info (sindx, r_type);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
		}

	      sreloc = elf_section_data (input_section)->sreloc;

	      if (sreloc == NULL || sreloc->contents == NULL)
		{
		  r = bfd_reloc_notsupported;
		  goto check_relocation_error;
		}

	      elf_append_rela (output_bfd, sreloc, &outrel);

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }

	  break;

	case R_X86_64_TLSGD:
	case R_X86_64_GOTPC32_TLSDESC:
	case R_X86_64_TLSDESC_CALL:
	case R_X86_64_GOTTPOFF:
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_x86_64_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    tls_type = elf_x86_64_hash_entry (h)->tls_type;

	  if (! elf_x86_64_tls_transition (info, input_bfd,
					   input_section, contents,
					   symtab_hdr, sym_hashes,
					   &r_type, tls_type, rel,
					   relend, h, r_symndx))
	    return FALSE;

	  if (r_type == R_X86_64_TPOFF32)
	    {
	      bfd_vma roff = rel->r_offset;

	      BFD_ASSERT (! unresolved_reloc);

	      if (ELF32_R_TYPE (rel->r_info) == R_X86_64_TLSGD)
		{
		  /* GD->LE transition.  For 64bit, change
		     .byte 0x66; leaq foo@@tlsgd(%rip), %rdi
		     .word 0x6666; rex64; call __tls_get_addr
		     into:
		     movq %fs:0, %rax
		     leaq foo@@tpoff(%rax), %rax
		     For 32bit, change
		     leaq foo@@tlsgd(%rip), %rdi
		     .word 0x6666; rex64; call __tls_get_addr
		     into:
		     movl %fs:0, %eax
		     leaq foo@@tpoff(%rax), %rax
		     For largepic, change:
		     leaq foo@@tlsgd(%rip), %rdi
		     movabsq $__tls_get_addr@@pltoff, %rax
		     addq %rbx, %rax
		     call *%rax
		     into:
		     movq %fs:0, %rax
		     leaq foo@@tpoff(%rax), %rax
		     nopw 0x0(%rax,%rax,1) */
		  int largepic = 0;
		  if (ABI_64_P (output_bfd)
		      && contents[roff + 5] == (bfd_byte) '\xb8')
		    {
		      memcpy (contents + roff - 3,
			      "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x8d\x80"
			      "\0\0\0\0\x66\x0f\x1f\x44\0", 22);
		      largepic = 1;
		    }
		  else if (ABI_64_P (output_bfd))
		    memcpy (contents + roff - 4,
			    "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0",
			    16);
		  else
		    memcpy (contents + roff - 3,
			    "\x64\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0",
			    15);
		  bfd_put_32 (output_bfd,
			      elf_x86_64_tpoff (info, relocation),
			      contents + roff + 8 + largepic);
		  /* Skip R_X86_64_PC32/R_X86_64_PLT32/R_X86_64_PLTOFF64.  */
		  rel++;
		  continue;
		}
	      else if (ELF32_R_TYPE (rel->r_info) == R_X86_64_GOTPC32_TLSDESC)
		{
		  /* GDesc -> LE transition.
		     It's originally something like:
		     leaq x@@tlsdesc(%rip), %rax

		     Change it to:
		     movl $x@@tpoff, %rax.  */

		  unsigned int val, type;

		  type = bfd_get_8 (input_bfd, contents + roff - 3);
		  val = bfd_get_8 (input_bfd, contents + roff - 1);
		  bfd_put_8 (output_bfd, 0x48 | ((type >> 2) & 1),
			     contents + roff - 3);
		  bfd_put_8 (output_bfd, 0xc7, contents + roff - 2);
		  bfd_put_8 (output_bfd, 0xc0 | ((val >> 3) & 7),
			     contents + roff - 1);
		  bfd_put_32 (output_bfd,
			      elf_x86_64_tpoff (info, relocation),
			      contents + roff);
		  continue;
		}
	      else if (ELF32_R_TYPE (rel->r_info) == R_X86_64_TLSDESC_CALL)
		{
		  /* GDesc -> LE transition.
		     It's originally:
		     call *(%rax)
		     Turn it into:
		     xchg %ax,%ax.  */
		  bfd_put_8 (output_bfd, 0x66, contents + roff);
		  bfd_put_8 (output_bfd, 0x90, contents + roff + 1);
		  continue;
		}
	      else if (ELF32_R_TYPE (rel->r_info) == R_X86_64_GOTTPOFF)
		{
		  /* IE->LE transition:
		     Originally it can be one of:
		     movq foo@@gottpoff(%rip), %reg
		     addq foo@@gottpoff(%rip), %reg
		     We change it into:
		     movq $foo, %reg
		     leaq foo(%reg), %reg
		     addq $foo, %reg.  */

		  unsigned int val, type, reg;

		  val = bfd_get_8 (input_bfd, contents + roff - 3);
		  type = bfd_get_8 (input_bfd, contents + roff - 2);
		  reg = bfd_get_8 (input_bfd, contents + roff - 1);
		  reg >>= 3;
		  if (type == 0x8b)
		    {
		      /* movq */
		      if (val == 0x4c)
			bfd_put_8 (output_bfd, 0x49,
				   contents + roff - 3);
		      else if (!ABI_64_P (output_bfd) && val == 0x44)
			bfd_put_8 (output_bfd, 0x41,
				   contents + roff - 3);
		      bfd_put_8 (output_bfd, 0xc7,
				 contents + roff - 2);
		      bfd_put_8 (output_bfd, 0xc0 | reg,
				 contents + roff - 1);
		    }
		  else if (reg == 4)
		    {
		      /* addq -> addq - addressing with %rsp/%r12 is
			 special  */
		      if (val == 0x4c)
			bfd_put_8 (output_bfd, 0x49,
				   contents + roff - 3);
		      else if (!ABI_64_P (output_bfd) && val == 0x44)
			bfd_put_8 (output_bfd, 0x41,
				   contents + roff - 3);
		      bfd_put_8 (output_bfd, 0x81,
				 contents + roff - 2);
		      bfd_put_8 (output_bfd, 0xc0 | reg,
				 contents + roff - 1);
		    }
		  else
		    {
		      /* addq -> leaq */
		      if (val == 0x4c)
			bfd_put_8 (output_bfd, 0x4d,
				   contents + roff - 3);
		      else if (!ABI_64_P (output_bfd) && val == 0x44)
			bfd_put_8 (output_bfd, 0x45,
				   contents + roff - 3);
		      bfd_put_8 (output_bfd, 0x8d,
				 contents + roff - 2);
		      bfd_put_8 (output_bfd, 0x80 | reg | (reg << 3),
				 contents + roff - 1);
		    }
		  bfd_put_32 (output_bfd,
			      elf_x86_64_tpoff (info, relocation),
			      contents + roff);
		  continue;
		}
	      else
		BFD_ASSERT (FALSE);
	    }

	  if (htab->elf.sgot == NULL)
	    abort ();

	  if (h != NULL)
	    {
	      off = h->got.offset;
	      offplt = elf_x86_64_hash_entry (h)->tlsdesc_got;
	    }
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	      offplt = local_tlsdesc_gotents[r_symndx];
	    }

	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      int dr_type, indx;
	      asection *sreloc;

	      if (htab->elf.srelgot == NULL)
		abort ();

	      indx = h && h->dynindx != -1 ? h->dynindx : 0;

	      if (GOT_TLS_GDESC_P (tls_type))
		{
		  outrel.r_info = htab->r_info (indx, R_X86_64_TLSDESC);
		  BFD_ASSERT (htab->sgotplt_jump_table_size + offplt
			      + 2 * GOT_ENTRY_SIZE <= htab->elf.sgotplt->size);
		  outrel.r_offset = (htab->elf.sgotplt->output_section->vma
				     + htab->elf.sgotplt->output_offset
				     + offplt
				     + htab->sgotplt_jump_table_size);
		  sreloc = htab->elf.srelplt;
		  if (indx == 0)
		    outrel.r_addend = relocation - elf_x86_64_dtpoff_base (info);
		  else
		    outrel.r_addend = 0;
		  elf_append_rela (output_bfd, sreloc, &outrel);
		}

	      sreloc = htab->elf.srelgot;

	      outrel.r_offset = (htab->elf.sgot->output_section->vma
				 + htab->elf.sgot->output_offset + off);

	      if (GOT_TLS_GD_P (tls_type))
		dr_type = R_X86_64_DTPMOD64;
	      else if (GOT_TLS_GDESC_P (tls_type))
		goto dr_done;
	      else
		dr_type = R_X86_64_TPOFF64;

	      bfd_put_64 (output_bfd, 0, htab->elf.sgot->contents + off);
	      outrel.r_addend = 0;
	      if ((dr_type == R_X86_64_TPOFF64
		   || dr_type == R_X86_64_TLSDESC) && indx == 0)
		outrel.r_addend = relocation - elf_x86_64_dtpoff_base (info);
	      outrel.r_info = htab->r_info (indx, dr_type);

	      elf_append_rela (output_bfd, sreloc, &outrel);

	      if (GOT_TLS_GD_P (tls_type))
		{
		  if (indx == 0)
		    {
		      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_64 (output_bfd,
				  relocation - elf_x86_64_dtpoff_base (info),
				  htab->elf.sgot->contents + off + GOT_ENTRY_SIZE);
		    }
		  else
		    {
		      bfd_put_64 (output_bfd, 0,
				  htab->elf.sgot->contents + off + GOT_ENTRY_SIZE);
		      outrel.r_info = htab->r_info (indx,
						    R_X86_64_DTPOFF64);
		      outrel.r_offset += GOT_ENTRY_SIZE;
		      elf_append_rela (output_bfd, sreloc,
						&outrel);
		    }
		}

	    dr_done:
	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2
	      && ! GOT_TLS_GDESC_P (tls_type))
	    abort ();
	  if (r_type == ELF32_R_TYPE (rel->r_info))
	    {
	      if (r_type == R_X86_64_GOTPC32_TLSDESC
		  || r_type == R_X86_64_TLSDESC_CALL)
		relocation = htab->elf.sgotplt->output_section->vma
		  + htab->elf.sgotplt->output_offset
		  + offplt + htab->sgotplt_jump_table_size;
	      else
		relocation = htab->elf.sgot->output_section->vma
		  + htab->elf.sgot->output_offset + off;
	      unresolved_reloc = FALSE;
	    }
	  else
	    {
	      bfd_vma roff = rel->r_offset;

	      if (ELF32_R_TYPE (rel->r_info) == R_X86_64_TLSGD)
		{
		  /* GD->IE transition.  For 64bit, change
		     .byte 0x66; leaq foo@@tlsgd(%rip), %rdi
		     .word 0x6666; rex64; call __tls_get_addr@@plt
		     into:
		     movq %fs:0, %rax
		     addq foo@@gottpoff(%rip), %rax
		     For 32bit, change
		     leaq foo@@tlsgd(%rip), %rdi
		     .word 0x6666; rex64; call __tls_get_addr@@plt
		     into:
		     movl %fs:0, %eax
		     addq foo@@gottpoff(%rip), %rax
		     For largepic, change:
		     leaq foo@@tlsgd(%rip), %rdi
		     movabsq $__tls_get_addr@@pltoff, %rax
		     addq %rbx, %rax
		     call *%rax
		     into:
		     movq %fs:0, %rax
		     addq foo@@gottpoff(%rax), %rax
		     nopw 0x0(%rax,%rax,1) */
		  int largepic = 0;
		  if (ABI_64_P (output_bfd)
		      && contents[roff + 5] == (bfd_byte) '\xb8')
		    {
		      memcpy (contents + roff - 3,
			      "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05"
			      "\0\0\0\0\x66\x0f\x1f\x44\0", 22);
		      largepic = 1;
		    }
		  else if (ABI_64_P (output_bfd))
		    memcpy (contents + roff - 4,
			    "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0",
			    16);
		  else
		    memcpy (contents + roff - 3,
			    "\x64\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0",
			    15);

		  relocation = (htab->elf.sgot->output_section->vma
				+ htab->elf.sgot->output_offset + off
				- roff
				- largepic
				- input_section->output_section->vma
				- input_section->output_offset
				- 12);
		  bfd_put_32 (output_bfd, relocation,
			      contents + roff + 8 + largepic);
		  /* Skip R_X86_64_PLT32/R_X86_64_PLTOFF64.  */
		  rel++;
		  continue;
		}
	      else if (ELF32_R_TYPE (rel->r_info) == R_X86_64_GOTPC32_TLSDESC)
		{
		  /* GDesc -> IE transition.
		     It's originally something like:
		     leaq x@@tlsdesc(%rip), %rax

		     Change it to:
		     movq x@@gottpoff(%rip), %rax # before xchg %ax,%ax.  */

		  /* Now modify the instruction as appropriate. To
		     turn a leaq into a movq in the form we use it, it
		     suffices to change the second byte from 0x8d to
		     0x8b.  */
		  bfd_put_8 (output_bfd, 0x8b, contents + roff - 2);

		  bfd_put_32 (output_bfd,
			      htab->elf.sgot->output_section->vma
			      + htab->elf.sgot->output_offset + off
			      - rel->r_offset
			      - input_section->output_section->vma
			      - input_section->output_offset
			      - 4,
			      contents + roff);
		  continue;
		}
	      else if (ELF32_R_TYPE (rel->r_info) == R_X86_64_TLSDESC_CALL)
		{
		  /* GDesc -> IE transition.
		     It's originally:
		     call *(%rax)

		     Change it to:
		     xchg %ax, %ax.  */

		  bfd_put_8 (output_bfd, 0x66, contents + roff);
		  bfd_put_8 (output_bfd, 0x90, contents + roff + 1);
		  continue;
		}
	      else
		BFD_ASSERT (FALSE);
	    }
	  break;

	case R_X86_64_TLSLD:
	  if (! elf_x86_64_tls_transition (info, input_bfd,
					   input_section, contents,
					   symtab_hdr, sym_hashes,
					   &r_type, GOT_UNKNOWN,
					   rel, relend, h, r_symndx))
	    return FALSE;

	  if (r_type != R_X86_64_TLSLD)
	    {
	      /* LD->LE transition:
		 leaq foo@@tlsld(%rip), %rdi; call __tls_get_addr.
		 For 64bit, we change it into:
		 .word 0x6666; .byte 0x66; movq %fs:0, %rax.
		 For 32bit, we change it into:
		 nopl 0x0(%rax); movl %fs:0, %eax.
		 For largepic, change:
		 leaq foo@@tlsgd(%rip), %rdi
		 movabsq $__tls_get_addr@@pltoff, %rax
		 addq %rbx, %rax
		 call *%rax
		 into:
		 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
		 movq %fs:0, %eax */

	      BFD_ASSERT (r_type == R_X86_64_TPOFF32);
	      if (ABI_64_P (output_bfd)
		  && contents[rel->r_offset + 5] == (bfd_byte) '\xb8')
		memcpy (contents + rel->r_offset - 3,
			"\x66\x66\x66\x66\x2e\x0f\x1f\x84\0\0\0\0\0"
			"\x64\x48\x8b\x04\x25\0\0\0", 22);
	      else if (ABI_64_P (output_bfd))
		memcpy (contents + rel->r_offset - 3,
			"\x66\x66\x66\x64\x48\x8b\x04\x25\0\0\0", 12);
	      else
		memcpy (contents + rel->r_offset - 3,
			"\x0f\x1f\x40\x00\x64\x8b\x04\x25\0\0\0", 12);
	      /* Skip R_X86_64_PC32/R_X86_64_PLT32/R_X86_64_PLTOFF64.  */
	      rel++;
	      continue;
	    }

	  if (htab->elf.sgot == NULL)
	    abort ();

	  off = htab->tls_ld_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;

	      if (htab->elf.srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->elf.sgot->output_section->vma
				 + htab->elf.sgot->output_offset + off);

	      bfd_put_64 (output_bfd, 0,
			  htab->elf.sgot->contents + off);
	      bfd_put_64 (output_bfd, 0,
			  htab->elf.sgot->contents + off + GOT_ENTRY_SIZE);
	      outrel.r_info = htab->r_info (0, R_X86_64_DTPMOD64);
	      outrel.r_addend = 0;
	      elf_append_rela (output_bfd, htab->elf.srelgot,
					&outrel);
	      htab->tls_ld_got.offset |= 1;
	    }
	  relocation = htab->elf.sgot->output_section->vma
		       + htab->elf.sgot->output_offset + off;
	  unresolved_reloc = FALSE;
	  break;

	case R_X86_64_DTPOFF32:
	  if (!info->executable|| (input_section->flags & SEC_CODE) == 0)
	    relocation -= elf_x86_64_dtpoff_base (info);
	  else
	    relocation = elf_x86_64_tpoff (info, relocation);
	  break;

	case R_X86_64_TPOFF32:
	case R_X86_64_TPOFF64:
	  BFD_ASSERT (info->executable);
	  relocation = elf_x86_64_tpoff (info, relocation);
	  break;

	case R_X86_64_DTPOFF64:
	  BFD_ASSERT ((input_section->flags & SEC_CODE) == 0);
	  relocation -= elf_x86_64_dtpoff_base (info);
	  break;

	default:
	  break;
	}

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic)
	  && _bfd_elf_section_offset (output_bfd, info, input_section,
				      rel->r_offset) != (bfd_vma) -1)
	{
	  (*_bfd_error_handler)
	    (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	     input_bfd,
	     input_section,
	     (long) rel->r_offset,
	     howto->name,
	     h->root.root.string);
	  return FALSE;
	}

do_relocation:
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);

check_relocation_error:
      if (r != bfd_reloc_ok)
	{
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  if (r == bfd_reloc_overflow)
	    {
	      if (! ((*info->callbacks->reloc_overflow)
		     (info, (h ? &h->root : NULL), name, howto->name,
		      (bfd_vma) 0, input_bfd, input_section,
		      rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
				  struct bfd_link_info *info,
				  struct elf_link_hash_entry *h,
				  Elf_Internal_Sym *sym ATTRIBUTE_UNUSED)
{
  struct elf_x86_64_link_hash_table *htab;
  const struct elf_x86_64_backend_data *const abed
    = get_elf_x86_64_backend_data (output_bfd);

  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return FALSE;

  if (h->plt.offset != (bfd_vma) -1)
    {
      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rela;
      bfd_byte *loc;
      asection *plt, *gotplt, *relplt;
      const struct elf_backend_data *bed;

      /* When building a static executable, use .iplt, .igot.plt and
	 .rela.iplt sections for STT_GNU_IFUNC symbols.  */
      if (htab->elf.splt != NULL)
	{
	  plt = htab->elf.splt;
	  gotplt = htab->elf.sgotplt;
	  relplt = htab->elf.srelplt;
	}
      else
	{
	  plt = htab->elf.iplt;
	  gotplt = htab->elf.igotplt;
	  relplt = htab->elf.irelplt;
	}

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.	 */
      if ((h->dynindx == -1
	   && !((h->forced_local || info->executable)
		&& h->def_regular
		&& h->type == STT_GNU_IFUNC))
	  || plt == NULL
	  || gotplt == NULL
	  || relplt == NULL)
	abort ();

      /* Get the index in the procedure linkage table which
	 corresponds to this symbol.  This is the index of this symbol
	 in all the symbols for which we are making plt entries.  The
	 first entry in the procedure linkage table is reserved.

	 Get the offset into the .got table of the entry that
	 corresponds to this function.	Each .got entry is GOT_ENTRY_SIZE
	 bytes. The first three are reserved for the dynamic linker.

	 For static executables, we don't reserve anything.  */

      if (plt == htab->elf.splt)
	{
	  got_offset = h->plt.offset / abed->plt_entry_size - 1;
	  got_offset = (got_offset + 3) * GOT_ENTRY_SIZE;
	}
      else
	{
	  got_offset = h->plt.offset / abed->plt_entry_size;
	  got_offset = got_offset * GOT_ENTRY_SIZE;
	}

      /* Fill in the entry in the procedure linkage table.  */
      memcpy (plt->contents + h->plt.offset, abed->plt_entry,
	      abed->plt_entry_size);

      /* Insert the relocation positions of the plt section.  */

      /* Put offset the PC-relative instruction referring to the GOT entry,
	 subtracting the size of that instruction.  */
      bfd_put_32 (output_bfd,
		  (gotplt->output_section->vma
		   + gotplt->output_offset
		   + got_offset
		   - plt->output_section->vma
		   - plt->output_offset
		   - h->plt.offset
		   - abed->plt_got_insn_size),
		  plt->contents + h->plt.offset + abed->plt_got_offset);

      /* Fill in the entry in the global offset table, initially this
	 points to the second part of the PLT entry.  */
      bfd_put_64 (output_bfd, (plt->output_section->vma
			       + plt->output_offset
			       + h->plt.offset + abed->plt_lazy_offset),
		  gotplt->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (gotplt->output_section->vma
		       + gotplt->output_offset
		       + got_offset);
      if (h->dynindx == -1
	  || ((info->executable
	       || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	      && h->def_regular
	      && h->type == STT_GNU_IFUNC))
	{
	  /* If an STT_GNU_IFUNC symbol is locally defined, generate
	     R_X86_64_IRELATIVE instead of R_X86_64_JUMP_SLOT.  */
	  rela.r_info = htab->r_info (0, R_X86_64_IRELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	  /* R_X86_64_IRELATIVE comes last.  */
	  plt_index = htab->next_irelative_index--;
	}
      else
	{
	  rela.r_info = htab->r_info (h->dynindx, R_X86_64_JUMP_SLOT);
	  rela.r_addend = 0;
	  plt_index = htab->next_jump_slot_index++;
	}

      /* Don't fill PLT entry for static executables.  */
      if (plt == htab->elf.splt)
	{
	  /* Put relocation index.  */
	  bfd_put_32 (output_bfd, plt_index,
		      plt->contents + h->plt.offset + abed->plt_reloc_offset);
	  /* Put offset for jmp .PLT0.  */
	  bfd_put_32 (output_bfd, - (h->plt.offset + abed->plt_plt_insn_end),
		      plt->contents + h->plt.offset + abed->plt_plt_offset);
	}

      bed = get_elf_backend_data (output_bfd);
      loc = relplt->contents + plt_index * bed->s->sizeof_rela;
      bed->s->swap_reloca_out (output_bfd, &rela, loc);

      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value if there were any
	     relocations where pointer equality matters (this is a clue
	     for the dynamic linker, to make function pointer
	     comparisons work between an application and shared
	     library), otherwise set it to zero.  If a function is only
	     called from a binary, there is no need to slow down
	     shared libraries because of that.  */
	  sym->st_shndx = SHN_UNDEF;
	  if (!h->pointer_equality_needed)
	    sym->st_value = 0;
	}
    }

  if (h->got.offset != (bfd_vma) -1
      && ! GOT_TLS_GD_ANY_P (elf_x86_64_hash_entry (h)->tls_type)
      && elf_x86_64_hash_entry (h)->tls_type != GOT_TLS_IE)
    {
      Elf_Internal_Rela rela;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */
      if (htab->elf.sgot == NULL || htab->elf.srelgot == NULL)
	abort ();

      rela.r_offset = (htab->elf.sgot->output_section->vma
		       + htab->elf.sgot->output_offset
		       + (h->got.offset &~ (bfd_vma) 1));

      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (h->def_regular
	  && h->type == STT_GNU_IFUNC)
	{
	  if (info->shared)
	    {
	      /* Generate R_X86_64_GLOB_DAT.  */
	      goto do_glob_dat;
	    }
	  else
	    {
	      asection *plt;

	      if (!h->pointer_equality_needed)
		abort ();

	      /* For non-shared object, we can't use .got.plt, which
		 contains the real function addres if we need pointer
		 equality.  We load the GOT entry with the PLT entry.  */
	      plt = htab->elf.splt ? htab->elf.splt : htab->elf.iplt;
	      bfd_put_64 (output_bfd, (plt->output_section->vma
				       + plt->output_offset
				       + h->plt.offset),
			  htab->elf.sgot->contents + h->got.offset);
	      return TRUE;
	    }
	}
      else if (info->shared
	       && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  if (!h->def_regular)
	    return FALSE;
	  BFD_ASSERT((h->got.offset & 1) != 0);
	  rela.r_info = htab->r_info (0, R_X86_64_RELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
      else
	{
	  BFD_ASSERT((h->got.offset & 1) == 0);
do_glob_dat:
	  bfd_put_64 (output_bfd, (bfd_vma) 0,
		      htab->elf.sgot->contents + h->got.offset);
	  rela.r_info = htab->r_info (h->dynindx, R_X86_64_GLOB_DAT);
	  rela.r_addend = 0;
	}

      elf_append_rela (output_bfd, htab->elf.srelgot, &rela);
    }

  if (h->needs_copy)
    {
      Elf_Internal_Rela rela;

      /* This symbol needs a copy reloc.  Set it up.  */

      if (h->dynindx == -1
	  || (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	  || htab->srelbss == NULL)
	abort ();

      rela.r_offset = (h->root.u.def.value
		       + h->root.u.def.section->output_section->vma
		       + h->root.u.def.section->output_offset);
      rela.r_info = htab->r_info (h->dynindx, R_X86_64_COPY);
      rela.r_addend = 0;
      elf_append_rela (output_bfd, htab->srelbss, &rela);
    }

  return TRUE;
}

/* Finish up local dynamic symbol handling.  We set the contents of
   various dynamic sections here.  */

static bfd_boolean
elf_x86_64_finish_local_dynamic_symbol (void **slot, void *inf)
{
  struct elf_link_hash_entry *h
    = (struct elf_link_hash_entry *) *slot;
  struct bfd_link_info *info
    = (struct bfd_link_info *) inf;

  return elf_x86_64_finish_dynamic_symbol (info->output_bfd,
					     info, h, NULL);
}

/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
elf_x86_64_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			     const asection *rel_sec ATTRIBUTE_UNUSED,
			     const Elf_Internal_Rela *rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_X86_64_RELATIVE:
    case R_X86_64_RELATIVE64:
      return reloc_class_relative;
    case R_X86_64_JUMP_SLOT:
      return reloc_class_plt;
    case R_X86_64_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf_x86_64_finish_dynamic_sections (bfd *output_bfd,
				    struct bfd_link_info *info)
{
  struct elf_x86_64_link_hash_table *htab;
  bfd *dynobj;
  asection *sdyn;
  const struct elf_x86_64_backend_data *const abed
    = get_elf_x86_64_backend_data (output_bfd);

  htab = elf_x86_64_hash_table (info);
  if (htab == NULL)
    return FALSE;

  dynobj = htab->elf.dynobj;
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (htab->elf.dynamic_sections_created)
    {
      bfd_byte *dyncon, *dynconend;
      const struct elf_backend_data *bed;
      bfd_size_type sizeof_dyn;

      if (sdyn == NULL || htab->elf.sgot == NULL)
	abort ();

      bed = get_elf_backend_data (dynobj);
      sizeof_dyn = bed->s->sizeof_dyn;
      dyncon = sdyn->contents;
      dynconend = sdyn->contents + sdyn->size;
      for (; dyncon < dynconend; dyncon += sizeof_dyn)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  (*bed->s->swap_dyn_in) (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;

	    case DT_PLTGOT:
	      s = htab->elf.sgotplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
	      break;

	    case DT_JMPREL:
	      dyn.d_un.d_ptr = htab->elf.srelplt->output_section->vma;
	      break;

	    case DT_PLTRELSZ:
	      s = htab->elf.srelplt->output_section;
	      dyn.d_un.d_val = s->size;
	      break;

	    case DT_RELASZ:
	      /* The procedure linkage table relocs (DT_JMPREL) should
		 not be included in the overall relocs (DT_RELA).
		 Therefore, we override the DT_RELASZ entry here to
		 make it not include the JMPREL relocs.  Since the
		 linker script arranges for .rela.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_RELA entry.  */
	      if (htab->elf.srelplt != NULL)
		{
		  s = htab->elf.srelplt->output_section;
		  dyn.d_un.d_val -= s->size;
		}
	      break;

	    case DT_TLSDESC_PLT:
	      s = htab->elf.splt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset
		+ htab->tlsdesc_plt;
	      break;

	    case DT_TLSDESC_GOT:
	      s = htab->elf.sgot;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset
		+ htab->tlsdesc_got;
	      break;
	    }

	  (*bed->s->swap_dyn_out) (output_bfd, &dyn, dyncon);
	}

      /* Fill in the special first entry in the procedure linkage table.  */
      if (htab->elf.splt && htab->elf.splt->size > 0)
	{
	  /* Fill in the first entry in the procedure linkage table.  */
	  memcpy (htab->elf.splt->contents,
		  abed->plt0_entry, abed->plt_entry_size);
	  /* Add offset for pushq GOT+8(%rip), since the instruction
	     uses 6 bytes subtract this value.  */
	  bfd_put_32 (output_bfd,
		      (htab->elf.sgotplt->output_section->vma
		       + htab->elf.sgotplt->output_offset
		       + 8
		       - htab->elf.splt->output_section->vma
		       - htab->elf.splt->output_offset
		       - 6),
		      htab->elf.splt->contents + abed->plt0_got1_offset);
	  /* Add offset for the PC-relative instruction accessing GOT+16,
	     subtracting the offset to the end of that instruction.  */
	  bfd_put_32 (output_bfd,
		      (htab->elf.sgotplt->output_section->vma
		       + htab->elf.sgotplt->output_offset
		       + 16
		       - htab->elf.splt->output_section->vma
		       - htab->elf.splt->output_offset
		       - abed->plt0_got2_insn_end),
		      htab->elf.splt->contents + abed->plt0_got2_offset);

	  elf_section_data (htab->elf.splt->output_section)
	    ->this_hdr.sh_entsize = abed->plt_entry_size;

	  if (htab->tlsdesc_plt)
	    {
	      bfd_put_64 (output_bfd, (bfd_vma) 0,
			  htab->elf.sgot->contents + htab->tlsdesc_got);

	      memcpy (htab->elf.splt->contents + htab->tlsdesc_plt,
		      abed->plt0_entry, abed->plt_entry_size);

	      /* Add offset for pushq GOT+8(%rip), since the
		 instruction uses 6 bytes subtract this value.  */
	      bfd_put_32 (output_bfd,
			  (htab->elf.sgotplt->output_section->vma
			   + htab->elf.sgotplt->output_offset
			   + 8
			   - htab->elf.splt->output_section->vma
			   - htab->elf.splt->output_offset
			   - htab->tlsdesc_plt
			   - 6),
			  htab->elf.splt->contents
			  + htab->tlsdesc_plt + abed->plt0_got1_offset);
	  /* Add offset for the PC-relative instruction accessing GOT+TDG,
	     where TGD stands for htab->tlsdesc_got, subtracting the offset
	     to the end of that instruction.  */
	      bfd_put_32 (output_bfd,
			  (htab->elf.sgot->output_section->vma
			   + htab->elf.sgot->output_offset
			   + htab->tlsdesc_got
			   - htab->elf.splt->output_section->vma
			   - htab->elf.splt->output_offset
			   - htab->tlsdesc_plt
			   - abed->plt0_got2_insn_end),
			  htab->elf.splt->contents
			  + htab->tlsdesc_plt + abed->plt0_got2_offset);
	    }
	}
    }

  if (htab->elf.sgotplt)
    {
      if (bfd_is_abs_section (htab->elf.sgotplt->output_section))
	{
	  (*_bfd_error_handler)
	    (_("discarded output section: `%A'"), htab->elf.sgotplt);
	  return FALSE;
	}

      /* Fill in the first three entries in the global offset table.  */
      if (htab->elf.sgotplt->size > 0)
	{
	  /* Set the first entry in the global offset table to the address of
	     the dynamic section.  */
	  if (sdyn == NULL)
	    bfd_put_64 (output_bfd, (bfd_vma) 0, htab->elf.sgotplt->contents);
	  else
	    bfd_put_64 (output_bfd,
			sdyn->output_section->vma + sdyn->output_offset,
			htab->elf.sgotplt->contents);
	  /* Write GOT[1] and GOT[2], needed for the dynamic linker.  */
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->elf.sgotplt->contents + GOT_ENTRY_SIZE);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->elf.sgotplt->contents + GOT_ENTRY_SIZE*2);
	}

      elf_section_data (htab->elf.sgotplt->output_section)->this_hdr.sh_entsize =
	GOT_ENTRY_SIZE;
    }

  /* Adjust .eh_frame for .plt section.  */
  if (htab->plt_eh_frame != NULL
      && htab->plt_eh_frame->contents != NULL)
    {
      if (htab->elf.splt != NULL
	  && htab->elf.splt->size != 0
	  && (htab->elf.splt->flags & SEC_EXCLUDE) == 0
	  && htab->elf.splt->output_section != NULL
	  && htab->plt_eh_frame->output_section != NULL)
	{
	  bfd_vma plt_start = htab->elf.splt->output_section->vma;
	  bfd_vma eh_frame_start = htab->plt_eh_frame->output_section->vma
				   + htab->plt_eh_frame->output_offset
				   + PLT_FDE_START_OFFSET;
	  bfd_put_signed_32 (dynobj, plt_start - eh_frame_start,
			     htab->plt_eh_frame->contents
			     + PLT_FDE_START_OFFSET);
	}
      if (htab->plt_eh_frame->sec_info_type == SEC_INFO_TYPE_EH_FRAME)
	{
	  if (! _bfd_elf_write_section_eh_frame (output_bfd, info,
						 htab->plt_eh_frame,
						 htab->plt_eh_frame->contents))
	    return FALSE;
	}
    }

  if (htab->elf.sgot && htab->elf.sgot->size > 0)
    elf_section_data (htab->elf.sgot->output_section)->this_hdr.sh_entsize
      = GOT_ENTRY_SIZE;

  /* Fill PLT and GOT entries for local STT_GNU_IFUNC symbols.  */
  htab_traverse (htab->loc_hash_table,
		 elf_x86_64_finish_local_dynamic_symbol,
		 info);

  return TRUE;
}

/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
elf_x86_64_plt_sym_val (bfd_vma i, const asection *plt,
			const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + (i + 1) * GET_PLT_ENTRY_SIZE (plt->owner);
}

/* Handle an x86-64 specific section when reading an object file.  This
   is called when elfcode.h finds a section with an unknown type.  */

static bfd_boolean
elf_x86_64_section_from_shdr (bfd *abfd,
				Elf_Internal_Shdr *hdr,
				const char *name,
				int shindex)
{
  if (hdr->sh_type != SHT_X86_64_UNWIND)
    return FALSE;

  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name, shindex))
    return FALSE;

  return TRUE;
}

/* Hook called by the linker routine which adds symbols from an object
   file.  We use it to put SHN_X86_64_LCOMMON items in .lbss, instead
   of .bss.  */

static bfd_boolean
elf_x86_64_add_symbol_hook (bfd *abfd,
			    struct bfd_link_info *info,
			    Elf_Internal_Sym *sym,
			    const char **namep ATTRIBUTE_UNUSED,
			    flagword *flagsp ATTRIBUTE_UNUSED,
			    asection **secp,
			    bfd_vma *valp)
{
  asection *lcomm;

  switch (sym->st_shndx)
    {
    case SHN_X86_64_LCOMMON:
      lcomm = bfd_get_section_by_name (abfd, "LARGE_COMMON");
      if (lcomm == NULL)
	{
	  lcomm = bfd_make_section_with_flags (abfd,
					       "LARGE_COMMON",
					       (SEC_ALLOC
						| SEC_IS_COMMON
						| SEC_LINKER_CREATED));
	  if (lcomm == NULL)
	    return FALSE;
	  elf_section_flags (lcomm) |= SHF_X86_64_LARGE;
	}
      *secp = lcomm;
      *valp = sym->st_size;
      return TRUE;
    }

  if ((abfd->flags & DYNAMIC) == 0
      && (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC
	  || ELF_ST_BIND (sym->st_info) == STB_GNU_UNIQUE))
    elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;

  return TRUE;
}


/* Given a BFD section, try to locate the corresponding ELF section
   index.  */

static bfd_boolean
elf_x86_64_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
					 asection *sec, int *index_return)
{
  if (sec == &_bfd_elf_large_com_section)
    {
      *index_return = SHN_X86_64_LCOMMON;
      return TRUE;
    }
  return FALSE;
}

/* Process a symbol.  */

static void
elf_x86_64_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED,
			      asymbol *asym)
{
  elf_symbol_type *elfsym = (elf_symbol_type *) asym;

  switch (elfsym->internal_elf_sym.st_shndx)
    {
    case SHN_X86_64_LCOMMON:
      asym->section = &_bfd_elf_large_com_section;
      asym->value = elfsym->internal_elf_sym.st_size;
      /* Common symbol doesn't set BSF_GLOBAL.  */
      asym->flags &= ~BSF_GLOBAL;
      break;
    }
}

static bfd_boolean
elf_x86_64_common_definition (Elf_Internal_Sym *sym)
{
  return (sym->st_shndx == SHN_COMMON
	  || sym->st_shndx == SHN_X86_64_LCOMMON);
}

static unsigned int
elf_x86_64_common_section_index (asection *sec)
{
  if ((elf_section_flags (sec) & SHF_X86_64_LARGE) == 0)
    return SHN_COMMON;
  else
    return SHN_X86_64_LCOMMON;
}

static asection *
elf_x86_64_common_section (asection *sec)
{
  if ((elf_section_flags (sec) & SHF_X86_64_LARGE) == 0)
    return bfd_com_section_ptr;
  else
    return &_bfd_elf_large_com_section;
}

static bfd_boolean
elf_x86_64_merge_symbol (struct elf_link_hash_entry *h,
			 const Elf_Internal_Sym *sym,
			 asection **psec,
			 bfd_boolean newdef,
			 bfd_boolean olddef,
			 bfd *oldbfd,
			 const asection *oldsec)
{
  /* A normal common symbol and a large common symbol result in a
     normal common symbol.  We turn the large common symbol into a
     normal one.  */
  if (!olddef
      && h->root.type == bfd_link_hash_common
      && !newdef
      && bfd_is_com_section (*psec)
      && oldsec != *psec)
    {
      if (sym->st_shndx == SHN_COMMON
	  && (elf_section_flags (oldsec) & SHF_X86_64_LARGE) != 0)
	{
	  h->root.u.c.p->section
	    = bfd_make_section_old_way (oldbfd, "COMMON");
	  h->root.u.c.p->section->flags = SEC_ALLOC;
	}
      else if (sym->st_shndx == SHN_X86_64_LCOMMON
	       && (elf_section_flags (oldsec) & SHF_X86_64_LARGE) == 0)
	*psec = bfd_com_section_ptr;
    }

  return TRUE;
}

static int
elf_x86_64_additional_program_headers (bfd *abfd,
				       struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  asection *s;
  int count = 0;

  /* Check to see if we need a large readonly segment.  */
  s = bfd_get_section_by_name (abfd, ".lrodata");
  if (s && (s->flags & SEC_LOAD))
    count++;

  /* Check to see if we need a large data segment.  Since .lbss sections
     is placed right after the .bss section, there should be no need for
     a large data segment just because of .lbss.  */
  s = bfd_get_section_by_name (abfd, ".ldata");
  if (s && (s->flags & SEC_LOAD))
    count++;

  return count;
}

/* Return TRUE if symbol should be hashed in the `.gnu.hash' section.  */

static bfd_boolean
elf_x86_64_hash_symbol (struct elf_link_hash_entry *h)
{
  if (h->plt.offset != (bfd_vma) -1
      && !h->def_regular
      && !h->pointer_equality_needed)
    return FALSE;

  return _bfd_elf_hash_symbol (h);
}

/* Return TRUE iff relocations for INPUT are compatible with OUTPUT. */

static bfd_boolean
elf_x86_64_relocs_compatible (const bfd_target *input,
			      const bfd_target *output)
{
  return ((xvec_get_elf_backend_data (input)->s->elfclass
	   == xvec_get_elf_backend_data (output)->s->elfclass)
	  && _bfd_elf_relocs_compatible (input, output));
}

static const struct bfd_elf_special_section
  elf_x86_64_special_sections[]=
{
  { STRING_COMMA_LEN (".gnu.linkonce.lb"), -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_X86_64_LARGE},
  { STRING_COMMA_LEN (".gnu.linkonce.lr"), -2, SHT_PROGBITS, SHF_ALLOC + SHF_X86_64_LARGE},
  { STRING_COMMA_LEN (".gnu.linkonce.lt"), -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR + SHF_X86_64_LARGE},
  { STRING_COMMA_LEN (".lbss"),	           -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_X86_64_LARGE},
  { STRING_COMMA_LEN (".ldata"),	   -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_X86_64_LARGE},
  { STRING_COMMA_LEN (".lrodata"),	   -2, SHT_PROGBITS, SHF_ALLOC + SHF_X86_64_LARGE},
  { NULL,	                0,          0, 0,            0 }
};

#define TARGET_LITTLE_SYM		    bfd_elf64_x86_64_vec
#define TARGET_LITTLE_NAME		    "elf64-x86-64"
#define ELF_ARCH			    bfd_arch_i386
#define ELF_TARGET_ID			    X86_64_ELF_DATA
#define ELF_MACHINE_CODE		    EM_X86_64
#define ELF_MAXPAGESIZE			    0x200000
#define ELF_MINPAGESIZE			    0x1000
#define ELF_COMMONPAGESIZE		    0x1000

#define elf_backend_can_gc_sections	    1
#define elf_backend_can_refcount	    1
#define elf_backend_want_got_plt	    1
#define elf_backend_plt_readonly	    1
#define elf_backend_want_plt_sym	    0
#define elf_backend_got_header_size	    (GOT_ENTRY_SIZE*3)
#define elf_backend_rela_normal		    1
#define elf_backend_plt_alignment           4

#define elf_info_to_howto		    elf_x86_64_info_to_howto

#define bfd_elf64_bfd_link_hash_table_create \
  elf_x86_64_link_hash_table_create
#define bfd_elf64_bfd_link_hash_table_free \
  elf_x86_64_link_hash_table_free
#define bfd_elf64_bfd_reloc_type_lookup	    elf_x86_64_reloc_type_lookup
#define bfd_elf64_bfd_reloc_name_lookup \
  elf_x86_64_reloc_name_lookup

#define elf_backend_adjust_dynamic_symbol   elf_x86_64_adjust_dynamic_symbol
#define elf_backend_relocs_compatible	    elf_x86_64_relocs_compatible
#define elf_backend_check_relocs	    elf_x86_64_check_relocs
#define elf_backend_copy_indirect_symbol    elf_x86_64_copy_indirect_symbol
#define elf_backend_create_dynamic_sections elf_x86_64_create_dynamic_sections
#define elf_backend_finish_dynamic_sections elf_x86_64_finish_dynamic_sections
#define elf_backend_finish_dynamic_symbol   elf_x86_64_finish_dynamic_symbol
#define elf_backend_gc_mark_hook	    elf_x86_64_gc_mark_hook
#define elf_backend_gc_sweep_hook	    elf_x86_64_gc_sweep_hook
#define elf_backend_grok_prstatus	    elf_x86_64_grok_prstatus
#define elf_backend_grok_psinfo		    elf_x86_64_grok_psinfo
#ifdef CORE_HEADER
#define elf_backend_write_core_note	    elf_x86_64_write_core_note
#endif
#define elf_backend_reloc_type_class	    elf_x86_64_reloc_type_class
#define elf_backend_relocate_section	    elf_x86_64_relocate_section
#define elf_backend_size_dynamic_sections   elf_x86_64_size_dynamic_sections
#define elf_backend_always_size_sections    elf_x86_64_always_size_sections
#define elf_backend_init_index_section	    _bfd_elf_init_1_index_section
#define elf_backend_plt_sym_val		    elf_x86_64_plt_sym_val
#define elf_backend_object_p		    elf64_x86_64_elf_object_p
#define bfd_elf64_mkobject		    elf_x86_64_mkobject

#define elf_backend_section_from_shdr \
	elf_x86_64_section_from_shdr

#define elf_backend_section_from_bfd_section \
  elf_x86_64_elf_section_from_bfd_section
#define elf_backend_add_symbol_hook \
  elf_x86_64_add_symbol_hook
#define elf_backend_symbol_processing \
  elf_x86_64_symbol_processing
#define elf_backend_common_section_index \
  elf_x86_64_common_section_index
#define elf_backend_common_section \
  elf_x86_64_common_section
#define elf_backend_common_definition \
  elf_x86_64_common_definition
#define elf_backend_merge_symbol \
  elf_x86_64_merge_symbol
#define elf_backend_special_sections \
  elf_x86_64_special_sections
#define elf_backend_additional_program_headers \
  elf_x86_64_additional_program_headers
#define elf_backend_hash_symbol \
  elf_x86_64_hash_symbol

#define elf_backend_post_process_headers  _bfd_elf_set_osabi

#include "elf64-target.h"

/* FreeBSD support.  */

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		    bfd_elf64_x86_64_freebsd_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		    "elf64-x86-64-freebsd"

#undef	ELF_OSABI
#define	ELF_OSABI			    ELFOSABI_FREEBSD

#undef  elf64_bed
#define elf64_bed elf64_x86_64_fbsd_bed

#include "elf64-target.h"

/* Solaris 2 support.  */

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		    bfd_elf64_x86_64_sol2_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		    "elf64-x86-64-sol2"

/* Restore default: we cannot use ELFOSABI_SOLARIS, otherwise ELFOSABI_NONE
   objects won't be recognized.  */
#undef ELF_OSABI

#undef  elf64_bed
#define elf64_bed			    elf64_x86_64_sol2_bed

/* The 64-bit static TLS arena size is rounded to the nearest 16-byte
   boundary.  */
#undef elf_backend_static_tls_alignment
#define elf_backend_static_tls_alignment    16

/* The Solaris 2 ABI requires a plt symbol on all platforms.

   Cf. Linker and Libraries Guide, Ch. 2, Link-Editor, Generating the Output
   File, p.63.  */
#undef elf_backend_want_plt_sym
#define elf_backend_want_plt_sym	    1

#include "elf64-target.h"

/* Native Client support.  */

#undef	TARGET_LITTLE_SYM
#define	TARGET_LITTLE_SYM		bfd_elf64_x86_64_nacl_vec
#undef	TARGET_LITTLE_NAME
#define	TARGET_LITTLE_NAME		"elf64-x86-64-nacl"
#undef	elf64_bed
#define	elf64_bed			elf64_x86_64_nacl_bed

#undef	ELF_MAXPAGESIZE
#undef	ELF_MINPAGESIZE
#undef	ELF_COMMONPAGESIZE
#define ELF_MAXPAGESIZE			0x10000
#define ELF_MINPAGESIZE			0x10000
#define ELF_COMMONPAGESIZE		0x10000

/* Restore defaults.  */
#undef	ELF_OSABI
#undef	elf_backend_static_tls_alignment
#undef	elf_backend_want_plt_sym
#define elf_backend_want_plt_sym	0

/* NaCl uses substantially different PLT entries for the same effects.  */

#undef	elf_backend_plt_alignment
#define elf_backend_plt_alignment	5
#define NACL_PLT_ENTRY_SIZE		64
#define	NACLMASK			0xe0 /* 32-byte alignment mask.  */

static const bfd_byte elf_x86_64_nacl_plt0_entry[NACL_PLT_ENTRY_SIZE] =
  {
    0xff, 0x35, 8, 0, 0, 0,             /* pushq GOT+8(%rip) 		*/
    0x4c, 0x8b, 0x1d, 16, 0, 0, 0,	/* mov GOT+16(%rip), %r11	*/
    0x41, 0x83, 0xe3, NACLMASK,         /* and $-32, %r11d		*/
    0x4d, 0x01, 0xfb,             	/* add %r15, %r11		*/
    0x41, 0xff, 0xe3,             	/* jmpq *%r11			*/

    /* 9-byte nop sequence to pad out to the next 32-byte boundary.  */
    0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, /* nopl %cs:0x0(%rax,%rax,1)	*/

    /* 32 bytes of nop to pad out to the standard size.  */
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    /* excess data32 prefixes	*/
    0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, /* nopw %cs:0x0(%rax,%rax,1)	*/
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    /* excess data32 prefixes	*/
    0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, /* nopw %cs:0x0(%rax,%rax,1)	*/
    0x66,                                  /* excess data32 prefix	*/
    0x90                                   /* nop */
  };

static const bfd_byte elf_x86_64_nacl_plt_entry[NACL_PLT_ENTRY_SIZE] =
  {
    0x4c, 0x8b, 0x1d, 0, 0, 0, 0,	/* mov name@@GOTPCREL(%rip),%r11	*/
    0x41, 0x83, 0xe3, NACLMASK,         /* and $-32, %r11d		*/
    0x4d, 0x01, 0xfb,             	/* add %r15, %r11		*/
    0x41, 0xff, 0xe3,             	/* jmpq *%r11			*/

    /* 15-byte nop sequence to pad out to the next 32-byte boundary.  */
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    /* excess data32 prefixes	*/
    0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, /* nopw %cs:0x0(%rax,%rax,1)	*/

    /* Lazy GOT entries point here (32-byte aligned).  */
    0x68,                 /* pushq immediate */
    0, 0, 0, 0,           /* replaced with index into relocation table.  */
    0xe9,                 /* jmp relative */
    0, 0, 0, 0,           /* replaced with offset to start of .plt0.  */

    /* 22 bytes of nop to pad out to the standard size.  */
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66,    /* excess data32 prefixes	*/
    0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, /* nopw %cs:0x0(%rax,%rax,1)	*/
    0x0f, 0x1f, 0x80, 0, 0, 0, 0,          /* nopl 0x0(%rax)		*/
  };

/* .eh_frame covering the .plt section.  */

static const bfd_byte elf_x86_64_nacl_eh_frame_plt[] =
  {
#if (PLT_CIE_LENGTH != 20                               \
     || PLT_FDE_LENGTH != 36                            \
     || PLT_FDE_START_OFFSET != 4 + PLT_CIE_LENGTH + 8  \
     || PLT_FDE_LEN_OFFSET != 4 + PLT_CIE_LENGTH + 12)
# error "Need elf_x86_64_backend_data parameters for eh_frame_plt offsets!"
#endif
    PLT_CIE_LENGTH, 0, 0, 0,	/* CIE length */
    0, 0, 0, 0,			/* CIE ID */
    1,				/* CIE version */
    'z', 'R', 0,                /* Augmentation string */
    1,				/* Code alignment factor */
    0x78,                       /* Data alignment factor */
    16,				/* Return address column */
    1,				/* Augmentation size */
    DW_EH_PE_pcrel | DW_EH_PE_sdata4, /* FDE encoding */
    DW_CFA_def_cfa, 7, 8,	/* DW_CFA_def_cfa: r7 (rsp) ofs 8 */
    DW_CFA_offset + 16, 1,	/* DW_CFA_offset: r16 (rip) at cfa-8 */
    DW_CFA_nop, DW_CFA_nop,

    PLT_FDE_LENGTH, 0, 0, 0,	/* FDE length */
    PLT_CIE_LENGTH + 8, 0, 0, 0,/* CIE pointer */
    0, 0, 0, 0,			/* R_X86_64_PC32 .plt goes here */
    0, 0, 0, 0,			/* .plt size goes here */
    0,				/* Augmentation size */
    DW_CFA_def_cfa_offset, 16,	/* DW_CFA_def_cfa_offset: 16 */
    DW_CFA_advance_loc + 6,	/* DW_CFA_advance_loc: 6 to __PLT__+6 */
    DW_CFA_def_cfa_offset, 24,	/* DW_CFA_def_cfa_offset: 24 */
    DW_CFA_advance_loc + 58,	/* DW_CFA_advance_loc: 58 to __PLT__+64 */
    DW_CFA_def_cfa_expression,	/* DW_CFA_def_cfa_expression */
    13,				/* Block length */
    DW_OP_breg7, 8,		/* DW_OP_breg7 (rsp): 8 */
    DW_OP_breg16, 0,		/* DW_OP_breg16 (rip): 0 */
    DW_OP_const1u, 63, DW_OP_and, DW_OP_const1u, 37, DW_OP_ge,
    DW_OP_lit3, DW_OP_shl, DW_OP_plus,
    DW_CFA_nop, DW_CFA_nop
  };

static const struct elf_x86_64_backend_data elf_x86_64_nacl_arch_bed =
  {
    elf_x86_64_nacl_plt0_entry,              /* plt0_entry */
    elf_x86_64_nacl_plt_entry,               /* plt_entry */
    NACL_PLT_ENTRY_SIZE,                     /* plt_entry_size */
    2,                                       /* plt0_got1_offset */
    9,                                       /* plt0_got2_offset */
    13,                                      /* plt0_got2_insn_end */
    3,                                       /* plt_got_offset */
    33,                                      /* plt_reloc_offset */
    38,                                      /* plt_plt_offset */
    7,                                       /* plt_got_insn_size */
    42,                                      /* plt_plt_insn_end */
    32,                                      /* plt_lazy_offset */
    elf_x86_64_nacl_eh_frame_plt,            /* eh_frame_plt */
    sizeof (elf_x86_64_nacl_eh_frame_plt),   /* eh_frame_plt_size */
  };

#undef	elf_backend_arch_data
#define	elf_backend_arch_data	&elf_x86_64_nacl_arch_bed

#undef	elf_backend_modify_segment_map
#define	elf_backend_modify_segment_map		nacl_modify_segment_map
#undef	elf_backend_modify_program_headers
#define	elf_backend_modify_program_headers	nacl_modify_program_headers
#undef	elf_backend_final_write_processing
#define elf_backend_final_write_processing	nacl_final_write_processing

#include "elf64-target.h"

/* Native Client x32 support.  */

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		bfd_elf32_x86_64_nacl_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		"elf32-x86-64-nacl"
#undef	elf32_bed
#define	elf32_bed			elf32_x86_64_nacl_bed

#define bfd_elf32_bfd_link_hash_table_create \
  elf_x86_64_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
  elf_x86_64_link_hash_table_free
#define bfd_elf32_bfd_reloc_type_lookup	\
  elf_x86_64_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup \
  elf_x86_64_reloc_name_lookup
#define bfd_elf32_mkobject \
  elf_x86_64_mkobject

#undef elf_backend_object_p
#define elf_backend_object_p \
  elf32_x86_64_elf_object_p

#undef elf_backend_bfd_from_remote_memory
#define elf_backend_bfd_from_remote_memory \
  _bfd_elf32_bfd_from_remote_memory

#undef elf_backend_size_info
#define elf_backend_size_info \
  _bfd_elf32_size_info

#include "elf32-target.h"

/* Restore defaults.  */
#undef	elf_backend_object_p
#define elf_backend_object_p		    elf64_x86_64_elf_object_p
#undef	elf_backend_bfd_from_remote_memory
#undef	elf_backend_size_info
#undef	elf_backend_modify_segment_map
#undef	elf_backend_modify_program_headers
#undef	elf_backend_final_write_processing

/* Intel L1OM support.  */

static bfd_boolean
elf64_l1om_elf_object_p (bfd *abfd)
{
  /* Set the right machine number for an L1OM elf64 file.  */
  bfd_default_set_arch_mach (abfd, bfd_arch_l1om, bfd_mach_l1om);
  return TRUE;
}

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		    bfd_elf64_l1om_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		    "elf64-l1om"
#undef ELF_ARCH
#define ELF_ARCH			    bfd_arch_l1om

#undef	ELF_MACHINE_CODE
#define ELF_MACHINE_CODE		    EM_L1OM

#undef	ELF_OSABI

#undef  elf64_bed
#define elf64_bed elf64_l1om_bed

#undef elf_backend_object_p
#define elf_backend_object_p		    elf64_l1om_elf_object_p

/* Restore defaults.  */
#undef	ELF_MAXPAGESIZE
#undef	ELF_MINPAGESIZE
#undef	ELF_COMMONPAGESIZE
#define ELF_MAXPAGESIZE			0x200000
#define ELF_MINPAGESIZE			0x1000
#define ELF_COMMONPAGESIZE		0x1000
#undef	elf_backend_plt_alignment
#define elf_backend_plt_alignment	4
#undef	elf_backend_arch_data
#define	elf_backend_arch_data	&elf_x86_64_arch_bed

#include "elf64-target.h"

/* FreeBSD L1OM support.  */

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		    bfd_elf64_l1om_freebsd_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		    "elf64-l1om-freebsd"

#undef	ELF_OSABI
#define	ELF_OSABI			    ELFOSABI_FREEBSD

#undef  elf64_bed
#define elf64_bed elf64_l1om_fbsd_bed

#include "elf64-target.h"

/* Intel K1OM support.  */

static bfd_boolean
elf64_k1om_elf_object_p (bfd *abfd)
{
  /* Set the right machine number for an K1OM elf64 file.  */
  bfd_default_set_arch_mach (abfd, bfd_arch_k1om, bfd_mach_k1om);
  return TRUE;
}

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		    bfd_elf64_k1om_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		    "elf64-k1om"
#undef ELF_ARCH
#define ELF_ARCH			    bfd_arch_k1om

#undef	ELF_MACHINE_CODE
#define ELF_MACHINE_CODE		    EM_K1OM

#undef	ELF_OSABI

#undef  elf64_bed
#define elf64_bed elf64_k1om_bed

#undef elf_backend_object_p
#define elf_backend_object_p		    elf64_k1om_elf_object_p

#undef  elf_backend_static_tls_alignment

#undef elf_backend_want_plt_sym
#define elf_backend_want_plt_sym	    0

#include "elf64-target.h"

/* FreeBSD K1OM support.  */

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		    bfd_elf64_k1om_freebsd_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		    "elf64-k1om-freebsd"

#undef	ELF_OSABI
#define	ELF_OSABI			    ELFOSABI_FREEBSD

#undef  elf64_bed
#define elf64_bed elf64_k1om_fbsd_bed

#include "elf64-target.h"

/* 32bit x86-64 support.  */

#undef  TARGET_LITTLE_SYM
#define TARGET_LITTLE_SYM		    bfd_elf32_x86_64_vec
#undef  TARGET_LITTLE_NAME
#define TARGET_LITTLE_NAME		    "elf32-x86-64"
#undef	elf32_bed

#undef ELF_ARCH
#define ELF_ARCH			    bfd_arch_i386

#undef	ELF_MACHINE_CODE
#define ELF_MACHINE_CODE		    EM_X86_64

#undef	ELF_OSABI

#undef elf_backend_object_p
#define elf_backend_object_p \
  elf32_x86_64_elf_object_p

#undef elf_backend_bfd_from_remote_memory
#define elf_backend_bfd_from_remote_memory \
  _bfd_elf32_bfd_from_remote_memory

#undef elf_backend_size_info
#define elf_backend_size_info \
  _bfd_elf32_size_info

#include "elf32-target.h"
@


1.300
log
@bfd/
	* elf-nacl.c (nacl_modify_segment_map): Fix logic reordering the
	elf_segment_map list.  If an executable segment is page-aligned
	but does not end with a full page, then append a fake section into
	the segment map entry that pads out the page.
	(nacl_final_write_processing): New function.  Write the code fill
	laid out in nacl_modify_segment_map.
	* elf-nacl.h: Declare it.
	* elf32-arm.c (elf32_arm_nacl_final_write_processing): New function.
	(elf_backend_final_write_processing): Define it for NaCl backend.
	* elf32-i386.c (elf_backend_final_write_processing): Likewise.
	* elf64-x86-64.c (elf_backend_final_write_processing): Likewise.

	* elf-nacl.c (segment_eligible_for_headers): Rename MAXPAGESIZE
	parameter to MINPAGESIZE.
	(nacl_modify_segment_map): Use minpagesize instead of maxpagesize.

	* elf32-arm.c (ELF_MINPAGESIZE, ELF_COMMONPAGESIZE): Set to
	0x10000	for NaCl targets.

ld/testsuite/
	* ld-x86-64/ilp32-4-nacl.d: Loosen .shstrtab line regexp to match
	any file offset.
	* ld-x86-64/tlsbin-nacl.rd: Update expected code segment PT_LOAD.
	* ld-x86-64/tlsbindesc-nacl.rd: Likewise.
	* ld-scripts/rgn-at3.d: XFAIL for *-*-nacl* targets.
	* ld-scripts/rgn-over8-ok.d: Likewise.
@
text
@d1092 1
d1130 6
a1135 1
	     can transit to different access model.  */
d1140 1
a1140 2
	  if ((offset + 12) > sec->size
	      || memcmp (contents + offset + 4, call, 4) != 0)
d1143 13
a1155 1
	  if (ABI_64_P (abfd))
d1173 6
a1178 1
	     can transit to different access model.  */
d1185 1
a1185 2
	  if (memcmp (contents + offset - 3, lea, 3) != 0
	      || 0xe8 != *(contents + offset + 4))
d1187 11
d1209 4
a1212 2
	      && (ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PC32
		  || ELF32_R_TYPE (rel[1].r_info) == R_X86_64_PLT32)
d3986 20
a4005 2
		     leaq foo@@tpoff(%rax), %rax */
		  if (ABI_64_P (output_bfd))
d4015 2
a4016 2
			      contents + roff + 8);
		  /* Skip R_X86_64_PC32/R_X86_64_PLT32.  */
d4251 20
a4270 2
		     addq foo@@gottpoff(%rip), %rax */
		  if (ABI_64_P (output_bfd))
d4282 1
d4287 2
a4288 2
			      contents + roff + 8);
		  /* Skip R_X86_64_PLT32.  */
d4350 9
a4358 1
		 nopl 0x0(%rax); movl %fs:0, %eax.  */
d4361 6
a4366 1
	      if (ABI_64_P (output_bfd))
d4372 1
a4372 1
	      /* Skip R_X86_64_PC32/R_X86_64_PLT32.  */
@


1.299
log
@Add get_elf_x86_64_arch_data

	* elf64-x86-64.c (get_elf_x86_64_arch_data): New.
	(get_elf_x86_64_backend_data): Use it.
	(elf_x86_64_size_dynamic_sections): Likewise.
@
text
@d5402 2
d5448 1
@


1.298
log
@Handle R_X86_64_DTPOFF64

bfd/

	PR ld/15685
	* elf64-x86-64.c (elf_x86_64_relocate_section): Handle
	R_X86_64_DTPOFF64.

ld/testsuite/

	PR ld/15685
	* ld-x86-64/tlsg.s: Add a test for R_X86_64_DTPOFF64.
	* ld-x86-64/tlsg.sd: Updated.
@
text
@d631 3
d635 1
a635 2
  ((const struct elf_x86_64_backend_data *) \
   get_elf_backend_data (abfd)->arch_data)
d2911 1
a2911 1
	= (const struct elf_x86_64_backend_data *) bed->arch_data;
d2983 1
a2983 1
	= (const struct elf_x86_64_backend_data *) bed->arch_data;
@


1.297
log
@bfd/elf-ifunc.c: Add header size arg to _bfd_elf_allocate_ifunc_dyn_relocs.

bfd/ChangeLog:

2013-05-07  Will Newton  <will.newton@@linaro.org>

	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Add a
	plt_header_size argument for ports where it differs from
	plt_entry_size.
	* elf-bfd.h: Likewise.
	* elf32-i386.c: Pass plt_header_size to
	_bfd_elf_allocate_ifunc_dyn_relocs.
	* elf64-x86-64.c: Likewise.
@
text
@d4335 5
@


1.296
log
@Set non_ir_ref if a symbol is referenced by a non-shared object

bfd/

	PR ld/15323
	* elf32-i386.c (elf_i386_check_relocs): Set non_ir_ref if a
	symbol is referenced by a non-shared object.
	* elf64-x86-64.c (elf_x86_64_check_relocs): Likewise.

ld/testsuite/

	PR ld/15323
	* ld-plugin/lto.exp (lto_link_tests): Add pr15323a-r.o.
	(lto_run_tests): Add a test for PR ld/15323.

	* ld-plugin/pr15323.out: New file.
	* ld-plugin/pr15323a.c: Likewise.
	* ld-plugin/pr15323b.c: Likewise.
@
text
@d2263 1
@


1.295
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d3 1
a3 1
   2010, 2011, 2012
d1522 1
@


1.294
log
@	* elf-bfd.h (struct elf_backend_data <merge_symbol>): Update proto.
	(_bfd_elf_init_reloc_shdr): Delete.
	* elf.c (_bfd_elf_init_reloc_shdr): Make static.
	* elf64-x86-64.c (elf_x86_64_merge_symbol): Trim parameters to
	just what is needed.
	* elflink.c (_bfd_elf_merge_symbol): Update bed->merge_symbol call.
@
text
@d4669 3
a4671 1
elf_x86_64_reloc_type_class (const Elf_Internal_Rela *rela)
@


1.293
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d5041 2
a5042 4
elf_x86_64_merge_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
			 struct elf_link_hash_entry **sym_hash ATTRIBUTE_UNUSED,
			 struct elf_link_hash_entry *h,
			 Elf_Internal_Sym *sym,
d5044 2
a5045 16
			 bfd_vma *pvalue ATTRIBUTE_UNUSED,
			 unsigned int *pold_alignment ATTRIBUTE_UNUSED,
			 bfd_boolean *skip ATTRIBUTE_UNUSED,
			 bfd_boolean *override ATTRIBUTE_UNUSED,
			 bfd_boolean *type_change_ok ATTRIBUTE_UNUSED,
			 bfd_boolean *size_change_ok ATTRIBUTE_UNUSED,
			 bfd_boolean *newdyn ATTRIBUTE_UNUSED,
			 bfd_boolean *newdef,
			 bfd_boolean *newdyncommon ATTRIBUTE_UNUSED,
			 bfd_boolean *newweak ATTRIBUTE_UNUSED,
			 bfd *abfd ATTRIBUTE_UNUSED,
			 asection **sec,
			 bfd_boolean *olddyn ATTRIBUTE_UNUSED,
			 bfd_boolean *olddef,
			 bfd_boolean *olddyncommon ATTRIBUTE_UNUSED,
			 bfd_boolean *oldweak ATTRIBUTE_UNUSED,
d5047 1
a5047 1
			 asection **oldsec)
d5052 1
a5052 1
  if (!*olddef
d5054 3
a5056 3
      && !*newdef
      && bfd_is_com_section (*sec)
      && *oldsec != *sec)
d5059 1
a5059 1
	  && (elf_section_flags (*oldsec) & SHF_X86_64_LARGE) != 0)
d5066 2
a5067 2
	       && (elf_section_flags (*oldsec) & SHF_X86_64_LARGE) == 0)
	*psec = *sec = bfd_com_section_ptr;
@


1.292
log
@	* elfcode.h (elf_checksum_contents): Free contents.
	* elf-bfd.h (_bfd_elf_link_hash_table_free): Declare.
	* elflink.c (_bfd_elf_link_hash_table_free): New function.
	(elf_final_link_free): New function, extracted from..
	(bfd_elf_final_link): ..here.  Always call
	_bfd_elf_write_section_eh_frame_hdr.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Default to
	_bfd_elf_link_hash_table_free.
	* libbfd-in.h (_bfd_merge_sections_free): Declare.
	* libbfd.h: Regenerate.
	* merge.c (_bfd_merge_sections_free): New function.
	* elf-eh-frame.c (_bfd_elf_write_section_eh_frame_hdr): Free
	hdr_info->array.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): Call
	_bfd_elf_link_hash_table_free.
	* elf32-arm.c (elf32_arm_link_hash_table_free): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_free): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_free): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_free): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_free): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_free): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_free): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_free): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_hash_table_free): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_free): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_free): Likewise.
	* elfnn-ia64.c (elfNN_ia64_hash_table_free): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Don't define.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_free): Delete.
	(bfd_elf32_bfd_link_hash_table_free): Dont' define.
@
text
@d351 1
a351 1
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d354 1
a354 1
	elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 24);
d364 1
a364 1
	elf_tdata (abfd)->core_signal
d368 1
a368 1
	elf_tdata (abfd)->core_lwpid
d392 1
a392 1
	elf_tdata (abfd)->core_pid
d394 1
a394 1
	elf_tdata (abfd)->core_program
d396 1
a396 1
	elf_tdata (abfd)->core_command
d401 1
a401 1
	elf_tdata (abfd)->core_pid
d403 1
a403 1
	elf_tdata (abfd)->core_program
d405 1
a405 1
	elf_tdata (abfd)->core_command
d414 1
a414 1
    char *command = elf_tdata (abfd)->core_command;
@


1.291
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d947 1
a947 1
  _bfd_generic_link_hash_table_free (hash);
@


1.290
log
@Don't resolve size relocation against non-zero TLS symbol

bfd/

	* elf32-i386.c (elf_i386_allocate_dynrelocs): Don't clear pc_count
	for non-zero TLS symbol.
	(elf_i386_relocate_section): Don't resolve size relocation against
	non-zero TLS symbol.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs): Don't clear
	pc_count for non-zero TLS symbol.
	(elf_x86_64_relocate_section): Don't resolve size relocation
	against non-zero TLS symbol.

ld/testsuite/

	* ld-size/size-10.rd: Updated.
	* ld-size/size-8.rd: Likewise.
	* ld-size/size32-2-i386.d: Likewise.
	* ld-size/size32-2-x32.d: Likewise.
	* ld-size/size32-2-x86-64.d: Likewise.
	* ld-size/size64-2-x32.d: Likewise.
	* ld-size/size64-2-x86-64.d: Likewise.

	* ld-size/size.exp (run_time_tests): Pass --hash-styl=gnu to
	linker for size-8 test.
@
text
@d891 1
a891 1
  ret = (struct elf_x86_64_link_hash_table *) bfd_malloc (amt);
a903 12
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->plt_eh_frame = NULL;
  ret->sym_cache.abfd = NULL;
  ret->tlsdesc_plt = 0;
  ret->tlsdesc_got = 0;
  ret->tls_ld_got.refcount = 0;
  ret->sgotplt_jump_table_size = 0;
  ret->tls_module_base = NULL;
  ret->next_jump_slot_index = 0;
  ret->next_irelative_index = 0;

@


1.289
log
@Resolve size relocation against non-zero TLS symbol

bfd/

	* elf32-i386.c (elf_i386_allocate_dynrelocs): Clear pc_count for
	non-zero TLS symbol.
	(elf_i386_relocate_section): Resolve size relocation against
	non-zero TLS symbol.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs): Clear pc_count
	for non-zero TLS symbol.
	(elf_x86_64_relocate_section): Resolve size relocation against
	non-zero TLS symbol.

ld/testsuite/

	* ld-size/size-10.rd: Updated.
	* ld-size/size-8.rd: Likewise.
	* ld-size/size32-2-i386.d: Likewise.
	* ld-size/size32-2-x32.d: Likewise.
	* ld-size/size32-2-x86-64.d: Likewise.
	* ld-size/size64-2-x32.d: Likewise.
	* ld-size/size64-2-x86-64.d: Likewise.
@
text
@a2402 18
  /* Since pc_count for TLS symbol can only have size relocations and
     we always resolve size relocation against non-zero TLS symbol, we
     clear pc_count for non-zero TLS symbol.  */
  if (h->type == STT_TLS && h->size != 0)
    {
      struct elf_dyn_relocs **pp;

      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	{
	  p->count -= p->pc_count;
	  p->pc_count = 0;
	  if (p->count == 0)
	    *pp = p->next;
	  else
	    pp = &p->next;
	}
    }

a3689 6
	  if (h && h->type == STT_TLS && st_size != 0)
	    {
	      /* Resolve size relocation against non-zero TLS symbol.  */
	      unresolved_reloc = FALSE;
	      break;
	    }
@


1.288
log
@Count size relocation as PC-relative relocation

bfd/

	* elf32-i386.c (elf_i386_check_relocs): Count size relocation as
	PC-relative relocation.
	* elf64-x86-64.c (elf_x86_64_check_relocs): Count size relocation
	as PC-relative relocation.

ld/testsuite/

	* ld-size/size32-3-i386.d: New file.
	* ld-size/size32-3-x32.d: Likewise.
	* ld-size/size32-3-x86-64.d: Likewise.
	* ld-size/size32-3.s: Likewise.
@
text
@d2403 18
d3708 6
@


1.287
log
@Update x86 size relocation check

	* elf32-i386.c (elf_i386_check_relocs): Update R_386_SIZE32
	check.
	(elf_i386_relocate_section): Don't check TLS for R_386_SIZE32.

	* elf64-x86-64.c (elf_x86_64_check_relocs): Update R_X86_64_SIZE32
	and R_X86_64_SIZE64 check.
	(elf_x86_64_relocate_section): Don't check TLS for R_X86_64_SIZE32
	nor R_X86_64_SIZE64.
@
text
@d1427 1
d1712 1
d1764 1
d1866 2
a1867 1
	      if (IS_X86_64_PCREL_TYPE (r_type))
@


1.286
log
@Add x86 size relocation support to bfd

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

	* elf32-i386.c (elf_howto_table): Fill R_386_SIZE32 entry.
	(elf_i386_reloc_type_lookup): Support BFD_RELOC_SIZE32.
	(elf_i386_check_relocs): Handle R_386_SIZE32.
	(elf_i386_gc_sweep_hook): Likewise.
	(elf_i386_relocate_section): Likewise.

	* elf64-x86-64.c (x86_64_elf_howto_table): Fill R_X86_64_SIZE32
	and R_X86_64_SIZE64 entries.
	(x86_64_reloc_map): Add BFD_RELOC_SIZE32 and BFD_RELOC_SIZE64,
	(elf_x86_64_rtype_to_howto): Handle R_X86_64_SIZE32 for x32.
	(elf_x86_64_reloc_name_lookup): Likewise.
	(elf_x86_64_check_relocs): Handle R_X86_64_SIZE32 and
	R_X86_64_SIZE64.
	(elf_x86_64_gc_sweep_hook): Likewise.
	(elf_x86_64_relocate_section): Likewise.

	* reloc.c (bfd_reloc_code_type): Add BFD_RELOC_SIZE32 and
	BFD_RELOC_SIZE64.
@
text
@d1709 4
a1743 2
	case R_X86_64_SIZE32:
	case R_X86_64_SIZE64:
d1762 1
a3683 14
	  if (h
	      && h->type == STT_TLS
	      && (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
	      && h->root.u.def.section->output_section != NULL
	      && htab->elf.tls_sec == NULL)
	    {
	      (*_bfd_error_handler)
		(_("%B: `%s' accessed both as normal and thread local symbol"),
		 input_bfd, h->root.root.string);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }

@


1.285
log
@Define R_X86_64_standard with R_X86_64_RELATIVE64

	* elf64-x86-64.c (R_X86_64_standard): Replace R_X86_64_IRELATIVE
	with R_X86_64_RELATIVE64.
@
text
@d151 6
a156 2
  EMPTY_HOWTO (32),
  EMPTY_HOWTO (33),
d245 2
d1740 2
d2038 2
d3215 1
d3249 1
d3273 1
d3283 16
a3298 8
      if (rel->r_addend == 0
	  && r_type == R_X86_64_64
	  && !ABI_64_P (output_bfd))
	{
	  /* For x32, treat R_X86_64_64 like R_X86_64_32 and zero-extend
	     it to 64bit if addend is zero.  */
	  r_type = R_X86_64_32;
	  memset (contents + rel->r_offset + 4, 0, 4);
d3679 20
d3771 1
d3779 3
a3781 1
	       && (! IS_X86_64_PCREL_TYPE (r_type)
@


1.284
log
@Set bfd errror for normal and TLS symbol access

	* elf32-i386.c (elf_i386_check_relocs): Set bfd errror for
	normal and TLS symbol access.
	* elf64-x86-64.c (elf_x86_64_check_relocs): Likewise.
@
text
@d176 1
a176 1
#define R_X86_64_standard (R_X86_64_IRELATIVE + 1)
@


1.283
log
@Check R_X86_64_standard for unrecognized relocation

	* elf64-x86-64.c (elf_x86_64_relocate_section): Check
	R_X86_64_standard instead of R_X86_64_max for unrecognized
	relocation.
@
text
@d1647 1
@


1.282
log
@Properly adjust h->plt.refcount

bfd/

	PR ld/14980
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Properly
	adjust h->plt.refcount.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.

ld/testsuite/

	PR ld/14980
	* ld-ifunc/ifunc-14c.s: New file.
	* ld-ifunc/ifunc-14e-i386.d: Likewise.
	* ld-ifunc/ifunc-14e-x86-64.d: Likewise.
	* ld-ifunc/ifunc-14f-i386.d: Likewise.
	* ld-ifunc/ifunc-14f-x86-64.d: Likewise.
@
text
@d3210 1
a3210 1
      if (r_type >= R_X86_64_max)
d3212 3
@


1.281
log
@Don't check IFUNC relocations in elf_*_check_relocs

	* elf32-i386.c (elf_i386_check_relocs): Don't check IFUNC
	relocations here.
	* elf64-x86-64.c (elf_x86_64_check_relocs): Likewise.
@
text
@a2092 1
	      h->plt.refcount += 1;
d2094 4
@


1.280
log
@Also check local IFUNC references

bfd/

	PR ld/14968
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Also check
	local IFUNC references.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.

ld/testsuite/

	PR ld/14968
	* ld-ifunc/ifunc-18a-i386.d: New file.
	* ld-ifunc/ifunc-18a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-18a.s: Likewise.
	* ld-ifunc/ifunc-18b-i386.d: Likewise.
	* ld-ifunc/ifunc-18b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-18b.s: Likewise.
	* ld-ifunc/ifunc-19a-i386.d: Likewise.
	* ld-ifunc/ifunc-19a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-19a.s: Likewise.
	* ld-ifunc/ifunc-19b-i386.d: Likewise.
	* ld-ifunc/ifunc-19b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-19b.s: Likewise.
@
text
@d1525 2
a1526 76
	  /* Since STT_GNU_IFUNC symbol must go through PLT, we handle
	     it here if it is defined in a non-shared object.  */
	  if (h->type == STT_GNU_IFUNC
	      && h->def_regular)
	    {
	      /* It is referenced by a non-shared object. */
	      h->ref_regular = 1;
	      h->needs_plt = 1;

	      /* STT_GNU_IFUNC symbol must go through PLT.  */
	      h->plt.refcount += 1;

	      /* STT_GNU_IFUNC needs dynamic sections.  */
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;

	      switch (r_type)
		{
		default:
		  if (h->root.root.string)
		    name = h->root.root.string;
		  else
		    name = bfd_elf_sym_name (abfd, symtab_hdr, isym,
					     NULL);
		  (*_bfd_error_handler)
		    (_("%B: relocation %s against STT_GNU_IFUNC "
		       "symbol `%s' isn't handled by %s"), abfd,
		     x86_64_elf_howto_table[r_type].name,
		     name, __FUNCTION__);
		  bfd_set_error (bfd_error_bad_value);
		  return FALSE;

		case R_X86_64_32:
		  if (ABI_64_P (abfd))
		    goto not_pointer;
		case R_X86_64_64:
		  h->non_got_ref = 1;
		  h->pointer_equality_needed = 1;
		  if (info->shared)
		    {
		      /* We must copy these reloc types into the output
			 file.  Create a reloc section in dynobj and
			 make room for this reloc.  */
		      sreloc = _bfd_elf_create_ifunc_dyn_reloc
			(abfd, info, sec, sreloc,
			 &((struct elf_x86_64_link_hash_entry *) h)->dyn_relocs);
		      if (sreloc == NULL)
			return FALSE;
		    }
		  break;

		case R_X86_64_32S:
		case R_X86_64_PC32:
		case R_X86_64_PC64:
not_pointer:
		  h->non_got_ref = 1;
		  if (r_type != R_X86_64_PC32
		      && r_type != R_X86_64_PC64)
		    h->pointer_equality_needed = 1;
		  break;

		case R_X86_64_PLT32:
		  break;

		case R_X86_64_GOTPCREL:
		case R_X86_64_GOTPCREL64:
		  h->got.refcount += 1;
		  if (htab->elf.sgot == NULL
		      && !_bfd_elf_create_got_section (htab->elf.dynobj,
						       info))
		    return FALSE;
		  break;
		}

	      continue;
	    }
@


1.279
log
@Check local IFUNC calls

bfd/

2012-12-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14956
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Check local
	IFUNC calls.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.

ld/testsuite/

2012-12-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14956
	* ld-ifunc/ifunc-14-i386.d: Renamed to ...
	* ld-ifunc/ifunc-14a-i386.d: This.

	* ld-ifunc/ifunc-14-x86-64.d: Renamed to ...
	* ld-ifunc/ifunc-14a-x86-64.d: This.

	* ld-ifunc/ifunc-14b-i386.d: New file.
	* ld-ifunc/ifunc-14b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-14c-i386.d: Likewise.
	* ld-ifunc/ifunc-14c-x86-64.d: Likewise.
	* ld-ifunc/ifunc-14d-i386.d: Likewise.
	* ld-ifunc/ifunc-14d-x86-64.d: Likewise.
@
text
@d2143 2
a2144 1
      /* Check local STT_GNU_IFUNC calls.  */
d2148 1
a2148 1
	  bfd_size_type pc_count = 0;
d2157 1
d2164 1
a2164 1
	  if (pc_count)
@


1.278
log
@Add Linux/x86_64 core support to i[3-7]86-*-linux

	* configure.in: Set CORE_HEADER to hosts/x86-64linux.h for
	'i[3-7]86-*-linux-*' if x86_64-*linux is enabled.
	* configure: Regenerated.

	* elf64-x86-64.c (elf_x86_64_write_core_note): Replace type
	'prpsinfo_t' and 'prstatus_t' with 'prpsinfo64_t' and
	'prstatus64_t' respectively.

	* hosts/x86-64linux.h (a8_uint64_t): New.
	(user_regsx32_struct): Renamed to ...
	(user_regs64_struct): This.  Replace uint64_t with a8_uint64_t.
	(elf_gregx32_t): Renamed to ...
	(elf_greg64_t): This.  Replace uint64_t with a8_uint64_t.
	(ELF_NGREGX32): Removed.
	(ELF_NGREG64): New.
	(elf_gregx32_t): Removed.
	(elf_greg64_t): New.
	(struct prstatus64_timeval): New.
	(elf_prstatusx32): Replace elf_gregsetx32_t with elf_gregset64_t.
	(elf_prstatus64): New.
	(elf_prpsinfo64): New.
	(prstatus64_t, prpsinfo64_t): New typedef.
@
text
@d2137 2
d2143 27
a2245 3
      struct elf_x86_64_link_hash_entry * eh;
      struct elf_dyn_relocs *p;

@


1.277
log
@Replace _GLOBAL_OFFSET_TABLE_ lookup with htab->elf.hgot

	* elf32-i386.c (elf_i386_size_dynamic_sections): Replace
	_GLOBAL_OFFSET_TABLE_ lookup with htab->elf.hgot.
	* elf64-x86-64.c (elf_x86_64_size_dynamic_sections): Likewise.
@
text
@d452 1
a452 1
	  prpsinfo_t data;
d493 1
a493 1
	  prstatus_t prstat;
@


1.276
log
@Ignore discarded section when converting mov to lea

	* elf32-i386.c (elf_i386_convert_mov_to_lea): Ignore discarded
	section.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
@
text
@a2919 5
      struct elf_link_hash_entry *got;
      got = elf_link_hash_lookup (elf_hash_table (info),
				  "_GLOBAL_OFFSET_TABLE_",
				  FALSE, FALSE, FALSE);

d2922 2
a2923 2
      if ((got == NULL
	   || !got->ref_regular_nonweak)
@


1.275
log
@Replace return FALSE with abort in x86 finish_dynamic_symbol

	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Replace return
	FALSE with abort.
	* elf64-x86-64.c (elf_x86_64_finish_dynamic_symbol): Likewise.
@
text
@d2598 1
a2598 1
  /* Nothing to do if there are no codes or no relocations.  */
d2600 2
a2601 1
      || sec->reloc_count == 0)
@


1.274
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d4469 1
a4469 1
	return FALSE;
@


1.273
log
@Don't optimize relocation against _DYNAMIC

bfd/

	* elf32-i386.c (elf_i386_convert_mov_to_lea): Don't optimize
	_DYNAMIC.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.

ld/testsuite/

	* ld-i386/i386.exp: Run mov1a, mov1b.
	* ld-x86-64/x86-64.exp: Run mov1a, mov1b, mov1c, mov1d.

	* ld-i386/mov1.s: New file.
	* ld-i386/mov1a.d: Likewise.
	* ld-i386/mov1b.d: Likewise.
	* ld-x86-64/mov1.s: Likewise.
	* ld-x86-64/mov1a.d: Likewise.
	* ld-x86-64/mov1b.d: Likewise.
	* ld-x86-64/mov1c.d: Likewise.
	* ld-x86-64/mov1d.d: Likewise.
@
text
@d2675 1
a2675 1
	  && strcmp (h->root.root.string, "_DYNAMIC") != 0
@


1.272
log
@Convert mov to lea in size_dynamic_sections

bfd/

	* elf32-i386.c (elf_i386_convert_mov_to_lea): New.
	(elf_i386_size_dynamic_sections): Use it on input sections.
	(elf_i386_relocate_section): Don't convert
	"mov foo@@GOT(%reg), %reg" to "lea foo@@GOTOFF(%reg), %reg"
	for local symbols here.

	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): New.
	(elf_x86_64_size_dynamic_sections): Use it on input sections.
	(elf_x86_64_relocate_section): Don't convert
	"mov foo@@GOTPCREL(%rip), %reg" to "lea foo@@GOTOFF(%reg), %reg"
	for local symbols.

ld/testsuite/

	* ld-i386/i386.exp: Run lea1d, lea1f, lea1f.
	* ld-x86-64/x86-64.exp: Run lea1g, lea1h, lea1i, lea1j, lea1k,
	lea1l.

	* ld-ifunc/ifunc-13-i386.d: Remove R_386_RELATIVE entry.

	* ld-i386/lea1d.d: New file.
	* ld-i386/lea1e.d: Likewise.
	* ld-i386/lea1f.d: Likewise.
	* ld-x86-64/lea1g.d: Likewise.
	* ld-x86-64/lea1h.d: Likewise.
	* ld-x86-64/lea1i.d: Likewise.
	* ld-x86-64/lea1j.d: Likewise.
	* ld-x86-64/lea1k.d: Likewise.
	* ld-x86-64/lea1l.d: Likewise.
@
text
@d2670 3
a2672 1
      /* STT_GNU_IFUNC must keep R_X86_64_GOTPCREL relocation.  */
d2675 1
@


1.271
log
@Convert mov to lea for loading local function address

bfd/

	* elf32-i386.c (elf_i386_relocate_section): Convert
	"mov foo@@GOT(%reg), %reg" to "lea foo@@GOTOFF(%reg), %reg"
	for local symbols.

	* elf64-x86-64.c (elf_x86_64_relocate_section): Convert
	"mov foo@@GOTPCREL(%rip), %reg" to "lea foo(%rip), %reg"
	for local symbols.

ld/testsuite/

	* ld-i386/i386.exp: Run lea1a, lea1b, lea1c.
	* ld-x86-64/x86-64.exp: Run lea1a, lea1b, lea1c, lea1d, lea1e,
	lea1f.

	* ld-i386/lea1.s: New file.
	* ld-i386/lea1a.d: Likewise.
	* ld-i386/lea1b.d: Likewise.
	* ld-i386/lea1c.d: Likewise.
	* ld-x86-64/lea1.s: Likewise.
	* ld-x86-64/lea1a.d: Likewise.
	* ld-x86-64/lea1b.d: Likewise.
	* ld-x86-64/lea1c.d: Likewise.
	* ld-x86-64/lea1d.d: Likewise.
	* ld-x86-64/lea1e.d: Likewise.
	* ld-x86-64/lea1f.d: Likewise.
@
text
@d2575 144
d2773 3
a3609 16
	  if (r_type == R_X86_64_GOTPCREL
	      && h->def_regular
	      && SYMBOL_REFERENCES_LOCAL (info, h)
	      && bfd_get_8 (input_bfd,
			    contents + rel->r_offset - 2) == 0x8b)
	    {
	      /* Convert
		 mov foo@@GOTPCREL(%rip), %reg
		 to
		 lea foo(%rip), %reg
	       */
	      bfd_put_8 (output_bfd, 0x8d,
			 contents + rel->r_offset - 2);
	      break;
	    }

@


1.270
log
@Return FALSE on unresolvable relocation

	* elf64-x86-64.c (elf_x86_64_relocate_section): Return FALSE
	on unresolvable relocation.
@
text
@d3463 16
@


1.270.4.1
log
@Check local IFUNC calls

bfd/

	PR ld/14956
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Check local
	IFUNC calls.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.

ld/testsuite/

	PR ld/14956
	* ld-ifunc/ifunc-14-i386.d: Renamed to ...
	* ld-ifunc/ifunc-14a-i386.d: This.

	* ld-ifunc/ifunc-14-x86-64.d: Renamed to ...
	* ld-ifunc/ifunc-14a-x86-64.d: This.

	* ld-ifunc/ifunc-14b-i386.d: New file.
	* ld-ifunc/ifunc-14b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-14c-i386.d: Likewise.
	* ld-ifunc/ifunc-14c-x86-64.d: Likewise.
	* ld-ifunc/ifunc-14d-i386.d: Likewise.
	* ld-ifunc/ifunc-14d-x86-64.d: Likewise.
@
text
@a2136 2
  struct elf_x86_64_link_hash_entry *eh;
  struct elf_dyn_relocs *p;
a2140 27
      /* Check local STT_GNU_IFUNC calls.  */
      if (h->ref_regular
	  && SYMBOL_CALLS_LOCAL (info, h))
	{
	  bfd_size_type pc_count = 0;
	  struct elf_dyn_relocs **pp;

	  eh = (struct elf_x86_64_link_hash_entry *) h;
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      pc_count += p->pc_count;
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }

	  if (pc_count)
	    {
	      h->needs_plt = 1;
	      h->plt.refcount += 1;
	      h->non_got_ref = 1;
	    }
	}

d2217 3
@


1.270.4.2
log
@Also check local IFUNC references

bfd/

	PR ld/14968
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Also check
	local IFUNC references.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.

ld/testsuite/

	PR ld/14968
	* ld-ifunc/ifunc-18a-i386.d: New file.
	* ld-ifunc/ifunc-18a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-18a.s: Likewise.
	* ld-ifunc/ifunc-18b-i386.d: Likewise.
	* ld-ifunc/ifunc-18b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-18b.s: Likewise.
	* ld-ifunc/ifunc-19a-i386.d: Likewise.
	* ld-ifunc/ifunc-19a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-19a.s: Likewise.
	* ld-ifunc/ifunc-19b-i386.d: Likewise.
	* ld-ifunc/ifunc-19b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-19b.s: Likewise.
@
text
@d2143 1
a2143 2
      /* All local STT_GNU_IFUNC references must be treate as local
	 calls via local PLT.  */
d2147 1
a2147 1
	  bfd_size_type pc_count = 0, count = 0;
a2155 1
	      count += p->count;
d2162 1
a2162 1
	  if (pc_count || count)
@


1.270.4.3
log
@Properly adjust h->plt.refcount

bfd/

	PR ld/14980
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Properly
	adjust h->plt.refcount.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.

ld/testsuite/

	PR ld/14980
	* ld-ifunc/ifunc-14c.s: New file.
	* ld-ifunc/ifunc-14e-i386.d: Likewise.
	* ld-ifunc/ifunc-14e-x86-64.d: Likewise.
	* ld-ifunc/ifunc-14f-i386.d: Likewise.
	* ld-ifunc/ifunc-14f-x86-64.d: Likewise.
@
text
@d2167 1
a2168 4
	      if (h->plt.refcount <= 0)
		h->plt.refcount = 1;
	      else
		h->plt.refcount += 1;
@


1.270.4.4
log
@Check R_X86_64_standard for unrecognized relocation

	* elf64-x86-64.c (elf_x86_64_relocate_section): Check
	R_X86_64_standard instead of R_X86_64_max for unrecognized
	relocation.
@
text
@d3138 1
a3138 1
      if (r_type >= (int) R_X86_64_standard)
a3139 3
	  (*_bfd_error_handler)
	    (_("%B: unrecognized relocation (0x%x) in section `%A'"),
	     input_bfd, input_section, r_type);
@


1.270.4.5
log
@bfd/
	* elf-nacl.c (nacl_modify_segment_map): Fix logic reordering the
	elf_segment_map list.  If an executable segment is page-aligned
	but does not end with a full page, then append a fake section into
	the segment map entry that pads out the page.
	(nacl_final_write_processing): New function.  Write the code fill
	laid out in nacl_modify_segment_map.
	* elf-nacl.h: Declare it.
	* elf32-arm.c (elf32_arm_nacl_final_write_processing): New function.
	(elf_backend_final_write_processing): Define it for NaCl backend.
	* elf32-i386.c (elf_backend_final_write_processing): Likewise.
	* elf64-x86-64.c (elf_backend_final_write_processing): Likewise.

	* elf-nacl.c (segment_eligible_for_headers): Rename MAXPAGESIZE
	parameter to MINPAGESIZE.
	(nacl_modify_segment_map): Use minpagesize instead of maxpagesize.

	* elf32-arm.c (ELF_MINPAGESIZE, ELF_COMMONPAGESIZE): Set to
	0x10000	for NaCl targets.

ld/testsuite/
	* ld-x86-64/ilp32-4-nacl.d: Loosen .shstrtab line regexp to match
	any file offset.
	* ld-x86-64/tlsbin-nacl.rd: Update expected code segment PT_LOAD.
	* ld-x86-64/tlsbindesc-nacl.rd: Likewise.
	* ld-scripts/rgn-at3.d: XFAIL for *-*-nacl* targets.
	* ld-scripts/rgn-over8-ok.d: Likewise.
@
text
@a5308 2
#undef	elf_backend_final_write_processing
#define elf_backend_final_write_processing	nacl_final_write_processing
a5352 1
#undef	elf_backend_final_write_processing
@


1.269
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d4213 10
a4222 7
	(*_bfd_error_handler)
	  (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	   input_bfd,
	   input_section,
	   (long) rel->r_offset,
	   howto->name,
	   h->root.root.string);
@


1.268
log
@Don't use dynamic_sec_flags on PLT .eh_frame section

	* elf32-i386.c (elf_i386_create_dynamic_sections): Don't use
	dynamic_sec_flags to create PLT .eh_frame section.
	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Likewise.
@
text
@d973 1
a973 1
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
d975 1
a975 1
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rela.bss");
d2602 1
a2602 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d4567 1
a4567 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
@


1.267
log
@	PR ld/13909
	* elf-eh-frame.c (_bfd_elf_eh_frame_present): New function.
	(_bfd_elf_maybe_strip_eh_frame_hdr): Use it here.
	* elf-bfd.h (_bfd_elf_eh_frame_present): Declare.
	* elflink.c (bfd_elf_size_dynamic_sections): Let the backend
	size dynamic sections before stripping eh_frame_hdr.
	(bfd_elf_gc_sections): Handle multiple .eh_frame sections.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Drop glink_eh_frame
	if no other .eh_frame sections exist.
	* elf64-ppc.c (ppc64_elf_size_stubs): Likewise.
	* elf32-i386.c (elf_i386_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_i386_size_dynamic_sections): ..do it here instead.  Don't
	specially keep sgotplt, iplt, tgotplt, sdynbss for symbols.
	(elf_i386_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Don't size
	or alloc plt_eh_frame here..
	(elf_x86_64_size_dynamic_sections): ..do it here instead.
	(elf_x86_64_finish_dynamic_sections): Check plt_eh_frame->contents
	before writing plt offset.
@
text
@d985 3
a987 1
      flagword flags = get_elf_backend_data (dynobj)->dynamic_sec_flags;
d989 1
a989 4
	= bfd_make_section_anyway_with_flags (dynobj, ".eh_frame",
					      (flags
					       | SEC_LINKER_CREATED
					       | SEC_READONLY));
@


1.266
log
@Revert the change for PR ld/r13909

bfd/

	PR ld/13909
	* elf32-i386.c (elf_i386_create_dynamic_sections): Revert the
	last change.
	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Likewise.

ld/testsuite/

2012-05-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13909
	* ld-i386/i386.exp: Revert the last change.
	* ld-x86-64/x86-64.exp: Likewise.

	* ld-i386/dummy.s: Removed.
	* ld-i386/pr13909.d: Likewise.
	* ld-x86-64/pr13909.d: Likewise.
@
text
@a984 2
      const struct elf_x86_64_backend_data *const abed
	= get_elf_x86_64_backend_data (dynobj);
a993 6

      htab->plt_eh_frame->size = abed->eh_frame_plt_size;
      htab->plt_eh_frame->contents
	= bfd_alloc (dynobj, htab->plt_eh_frame->size);
      memcpy (htab->plt_eh_frame->contents,
	      abed->eh_frame_plt, abed->eh_frame_plt_size);
d2792 11
d2816 1
d2868 10
a2877 5
      && htab->elf.splt != NULL
      && htab->elf.splt->size != 0
      && (htab->elf.splt->flags & SEC_EXCLUDE) == 0)
    bfd_put_32 (dynobj, htab->elf.splt->size,
		htab->plt_eh_frame->contents + PLT_FDE_LEN_OFFSET);
d4737 2
a4738 1
  if (htab->plt_eh_frame != NULL)
@


1.265
log
@Create PLT eh_frame section if there is .eh_frame section

bfd/

	PR ld/13909
	* elf32-i386.c (elf_i386_create_dynamic_sections): Create PLT
	eh_frame section if there is an input .eh_frame section.
	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Likewise.

ld/testsuite/

	PR ld/13909
	* ld-i386/i386.exp: Run pr13909.
	* ld-x86-64/x86-64.exp: Likewise.

	* ld-i386/dummy.s: New file.
	* ld-i386/pr13909.d: Likewise.
	* ld-x86-64/pr13909.d: Likewise.
@
text
@d983 1
a983 2
      && htab->elf.splt != NULL
      && bfd_get_section_by_name (dynobj, ".eh_frame") != NULL)
@


1.264
log
@Always create PLT eh_frame section for i386/x86-64

bfd/

2012-05-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14105
	* elf32-i386.c (elf_i386_create_dynamic_sections): Always
	create PLT eh_frame section with SEC_LINKER_CREATED.
	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Likewise.

ld/testsuite/

2012-05-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/14105
	* ld-elf/eh4.d: Add PLT eh_frame.

	* ld-i386/i386.exp: Run pr12570a and pr12570b.
	* ld-x86-64/x86-64.exp: Likewise.

	* ld-i386/pr12570a.d: New file.
	* ld-i386/pr12570a.s: Likewise.
	* ld-i386/pr12570b.s: Likewise.
	* ld-i386/pr12570b.s: Likewise.
	* ld-x86-64/pr12570a.d: Likewise.
	* ld-x86-64/pr12570a.s: Likewise.
	* ld-x86-64/pr12570b.d: Likewise.
	* ld-x86-64/pr12570b.s: Likewise.
@
text
@d983 2
a984 1
      && htab->elf.splt != NULL)
@


1.263
log
@Don't make _DYNAMIC/_GLOBAL_OFFSET_TABLE_ absolute

bfd/

	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Don't make
	_DYNAMIC nor _GLOBAL_OFFSET_TABLE_ absolute.
	* elf64-x86-64.c (elf_x86_64_finish_dynamic_symbol): Likewise.

ld/testsuite/

	* ld-i386/tlsdesc-nacl.rd: Update for dynamic sym changes.
	* ld-i386/tlsdesc.rd: Likewise.
	* ld-i386/tlsgdesc-nacl.rd: Likewise.
	* ld-i386/tlsgdesc.rd: Likewise.
	* ld-i386/tlsnopic-nacl.rd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlspic-nacl.rd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-x86-64/tlsdesc-nacl.rd: Likewise.
	* ld-x86-64/tlsdesc.rd: Likewise.
	* ld-x86-64/tlsgdesc-nacl.rd: Likewise.
	* ld-x86-64/tlsgdesc.rd: Likewise.
	* ld-x86-64/tlspic-nacl.rd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
@
text
@d982 1
a982 1
      && bfd_get_section_by_name (dynobj, ".eh_frame") == NULL
d989 4
a992 2
	= bfd_make_section_with_flags (dynobj, ".eh_frame",
				       flags | SEC_READONLY);
@


1.262
log
@Use int and bfd_signed_vma in x32 addend overflow check

bfd/

	* elf64-x86-64.c (elf_x86_64_relocate_section): Use int in x32
	addend overflow check.

gas/

	* config/tc-i386.c (tc_gen_reloc): Use bfd_signed_vma in x32
	addend overflow check.
@
text
@d4263 1
a4263 1
				  Elf_Internal_Sym *sym)
a4501 7
  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  SYM may
     be NULL for local symbols.  */
  if (sym != NULL
      && (strcmp (h->root.root.string, "_DYNAMIC") == 0
	  || h == htab->elf.hgot))
    sym->st_shndx = SHN_ABS;

@


1.261
log
@Display signed hex number in x32 addend overflow check

bfd/

	* elf64-x86-64.c (elf_x86_64_relocate_section): Display signed
	hex number in x32 addend overflow check.

gas/

	* config/tc-i386.c (tc_gen_reloc): Display signed hex number in
	x32 addend overflow check.

ld/testsuite/

	* ld-x86-64/ilp32-11.d: Updated.
@
text
@d3689 1
a3689 1
			  long addend = rel->r_addend;
d3697 1
a3697 1
			      (_("%B: addend -0x%lx in relocation %s against "
d3705 1
a3705 1
			      (_("%B: addend 0x%lx in relocation %s against "
@


1.260
log
@Count R_X86_64_RELATIVE64 as reloc_class_relative

bfd/

	* elf64-x86-64.c (elf_x86_64_reloc_type_class): Handle
	R_X86_64_RELATIVE64.

ld/testsuite/

	* ld-x86-64/pr13082-1a.d: Check RELACOUNT.
	* ld-x86-64/pr13082-1b.d: Likewise.
@
text
@d3689 1
d3695 16
a3710 8
			  (*_bfd_error_handler)
			    (_("%B: addend %ld in relocation %s against "
			       "symbol `%s' at 0x%lx in section `%A' is "
			       "out of range"),
			     input_bfd, input_section,
			     (long) rel->r_addend,
			     x86_64_elf_howto_table[r_type].name,
			     name, (unsigned long) rel->r_offset);
@


1.259
log
@Check 64-bit relocation addend overflow for x32

bfd/

	* elf64-x86-64.c (elf_x86_64_relocate_section): Check addend
	overflow for R_X86_64_RELATIVE64.

gas/

	* config/tc-i386.c (tc_gen_reloc): Check x32 addend overflow
	for BFD_RELOC_64.

gas/testsuite/

	* gas/i386/ilp32/ilp32.exp: Run reloc64-inval.

	* gas/i386/ilp32/reloc64.s: Add tests for ".quad".
	* gas/i386/ilp32/reloc64.d: Updated.

	* gas/i386/ilp32/reloc64-inval.l: New file.
	* gas/i386/ilp32/reloc64-inval.s: Likewise.

ld/testsuite/

	* ld-x86-64/ilp32-11.d: New file.
	* ld-x86-64/ilp32-11.s: Likewise.

	* ld-x86-64/x86-64.exp: Run ilp32-11.
@
text
@d4527 1
@


1.258
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d3684 21
@


1.257
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3148 1
a3148 1
					 rel, relend, howto, contents);
@


1.256
log
@* elf64-x86-64.c (elf_x86_64_nacl_plt0_entry): Fix nop padding
so that 32-byte boundary is a proper instruction boundary.
@
text
@d3146 1
a3146 1
      if (sec != NULL && elf_discarded_section (sec))
d4718 1
a4718 2
      if (htab->plt_eh_frame->sec_info_type
	  == ELF_INFO_TYPE_EH_FRAME)
@


1.255
log
@bfd/
2012-04-03  Roland McGrath  <mcgrathr@@google.com>

	* elf-nacl.c: New file.
	* elf-nacl.h: New file.
	* elf32-i386.c (elf_backend_modify_segment_map): Define for
	bfd_elf32_i386_nacl_vec.
	(elf_backend_modify_program_headers): Likewise.
	* elf64-x86-64.c (elf_backend_modify_segment_map): Define for
	bfd_elf64_x86_64_nacl_vec and bfd_elf32_x86_64_nacl_vec.
	(elf_backend_modify_program_headers): Likewise.
	* Makefile.am (BFD32_BACKENDS, BFD64_BACKENDS): Add elf-nacl.lo here.
	(BFD32_BACKENDS_CFILES, BFD64_BACKENDS_CFILES): Add elf-nacl.c here.
	* Makefile.in: Regenerated.
	* configure.in (bfd_elf64_x86_64_nacl_vec): Add elf-nacl.o to tb here.
	(bfd_elf32_x86_64_nacl_vec): Likewise.
	(bfd_elf64_x86_64_vec, bfd_elf32_x86_64_vec): Likewise.
	(bfd_elf64_x86_64_freebsd_vec, bfd_elf64_x86_64_sol2_vec): Likewise.
	(bfd_elf64_l1om_vec, bfd_elf64_l1om_freebsd_vec): Likewise.
	(bfd_elf64_k1om_vec, bfd_elf64_k1om_freebsd_vec): Likewise.
	(bfd_elf32_i386_nacl_vec): Likewise.
	(bfd_elf32_i386_sol2_vec, bfd_elf32_i386_freebsd_vec): Likewise.
	(bfd_elf32_i386_vxworks_vec, bfd_elf32_i386_vec): Likewise.
	* configure: Regenerated.

binutils/testsuite/
2012-04-03  Roland McGrath  <mcgrathr@@google.com>

	* lib/binutils-common.exp (is_elf_format): Consider *-*-nacl* to
	be ELF too.

	* binutils-all/elfedit-4.d: Add "#as: --64" option.

	* binutils-all/i386/i386.exp: Accept nacl targets too.
	* binutils-all/x86-64/x86-64.exp: Likewise.

gas/testsuite/
2012-04-03  Roland McGrath  <mcgrathr@@google.com>

	* gas/i386/k1om.d: Add not-target match for *-*-nacl*.
	* gas/i386/l1om.d: Likewise.

ld/
2012-04-03  Roland McGrath  <mcgrathr@@google.com>

	* configure.tgt (i[3-7]86-*-nacl*, x86_64-*-nacl*): Handle them.
	* emulparams/elf_nacl.sh: New file.
	* emulparams/elf_i386_nacl.sh: New file.
	* emulparams/elf32_x86_64_nacl.sh: New file.
	* emulparams/elf_x86_64_nacl.sh: New file.
	* Makefile.am (ALL_EMULATION_SOURCES): Add eelf_i386_nacl.c here.
	(ALL_64_EMULATION_SOURCES): Add eelf32_x86_64_nacl.c and
	eelf_x86_64_nacl.c here.
	(eelf_i386_nacl.c, eelf32_x86_64_nacl.c, eelf_x86_64_nacl.c):
	New targets.
	* Makefile.in: Regenerated.

	* scripttempl/elf.sc: Handle SEPARATE_CODE cases.

ld/testsuite/
2012-04-03  Roland McGrath  <mcgrathr@@google.com>

	* ld-x86-64/ilp32-4-nacl.d: New file.
	* ld-x86-64/x86-64.exp: Run it.

	* ld-discard/discard.exp: Accept nacl targets too.
	* ld-elf/binutils.exp: Likewise.
	* ld-elf/comm-data.exp: Likewise.
	* ld-elf/elf.exp: Likewise.
	* ld-elf/tls_common.exp: Likewise.
	* ld-elfvers/vers.exp: Likewise.
	* ld-elfvsb/elfvsb.exp: Likewise.
	* ld-elfweak/elfweak.exp: Likewise.
	* ld-gc/gc.exp: Likewise.
	* ld-ifunc/binutils.exp: Likewise.
	* ld-ifunc/ifunc.exp: Likewise.
	* ld-linkonce/linkonce.exp:Likewise.
	* ld-pie/pie.exp: Likewise.
	* ld-shared/shared.exp: Likewise.
	* ld-undefined/weak-undef.exp: Likewise.
	* ld-unique/unique.exp: Likewise.
	* ld-x86-64/dwarfreloc.exp: Likewise.
	* ld-x86-64/line.exp: Likewise.

	* lib/ld-lib.exp (slurp_options): Support global array
	options_regsub to apply substitutions to the contents
	of options lines read from the file.
	* ld-i386/emit-relocs.d: Renamed to ...
	* ld-i386/emit-relocs.rd: ... this.
	* ld-i386/i386.exp: Accept nacl targets too.
	For them, use options_regsub to replace elf_i386 with
	elf_i386_nacl in run_dump_test cases; apply the same
	substitution in $i386tests; replace foo.rd expectations
	files with foo-nacl.rd in $i386tests.
	(i386tests): Change emit-relocs.d to emit-relocs.rd here.
	* ld-i386/emit-relocs-nacl.rd: New file.
	* ld-i386/plt-nacl.pd: New file.
	* ld-i386/plt-pic-nacl.pd: New file.
	* ld-i386/tlsbin-nacl.rd: New file.
	* ld-i386/tlsbindesc-nacl.rd: New file.
	* ld-i386/tlsdesc-nacl.rd: New file.
	* ld-i386/tlsgdesc-nacl.rd: New file.
	* ld-i386/tlsnopic-nacl.rd: New file.
	* ld-i386/tlspic-nacl.rd: New file.
	* ld-x86-64/x86-64.exp: Accept nacl targets too.
	For them, use options_regsub to replace elf_x86_64 with
	elf_x86_64_nacl in run_dump_test cases; apply the same
	substitution in $x86_64tests; replace foo.rd expectations
	files with foo-nacl.rd in $x86_64tests.
	Add explicit -melf_x86_64 to ld options in tests that need it,
	in case the default emulation is x32 (as it is for x86_64-nacl).
	* ld/testsuite/ld-x86-64/plt-nacl.pd: New file.
	* ld/testsuite/ld-x86-64/split-by-file-nacl.rd: New file.
	* ld/testsuite/ld-x86-64/tlsbin-nacl.rd: New file.
	* ld/testsuite/ld-x86-64/tlsbindesc-nacl.rd: New file.
	* ld/testsuite/ld-x86-64/tlsdesc-nacl.pd: New file.
	* ld/testsuite/ld-x86-64/tlsdesc-nacl.rd: New file.
	* ld/testsuite/ld-x86-64/tlsgdesc-nacl.rd: New file.
	* ld/testsuite/ld-x86-64/tlspic-nacl.rd: New file.

	* ld-i386/hidden2.d: Loosen regexps to match any file format variant,
	and not to depend on exact addresses, displacements, etc. where
	they are irrelevant.
	* ld-i386/pcrel16.d: Likewise.
	* ld-i386/pcrel16abs.d: Likewise.
	* ld-i386/pr12718.d: Likewise.
	* ld-i386/pr12921.d: Likewise.
	* ld-i386/reloc.d: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
	* ld-i386/tlsbin.td: Likewise.
	* ld-i386/tlsbindesc.dd: Likewise.
	* ld-i386/tlsbindesc.sd: Likewise.
	* ld-i386/tlsbindesc.td: Likewise.
	* ld-i386/tlsdesc.dd: Likewise.
	* ld-i386/tlsdesc.sd: Likewise.
	* ld-i386/tlsdesc.td: Likewise.
	* ld-i386/tlsg.sd: Likewise.
	* ld-i386/tlsgdesc.dd: Likewise.
	* ld-i386/tlsindntpoff.dd: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlspic.td: Likewise.
	* ld-i386/tlspie2.d: Likewise.
	* ld-x86-64/hidden2.d: Likewise.
	* ld-x86-64/pcrel16.d: Likewise.
	* ld-x86-64/pr12718.d: Likewise.
	* ld-x86-64/pr12921.d: Likewise.
	* ld-x86-64/protected3.d: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlsbindesc.sd: Likewise.
	* ld-x86-64/tlsbindesc.td: Likewise.
	* ld-x86-64/tlsdesc.dd: Likewise.
	* ld-x86-64/tlsdesc.sd: Likewise.
	* ld-x86-64/tlsdesc.td: Likewise.
	* ld-x86-64/tlsg.sd: Likewise.
	* ld-x86-64/tlsgd5.dd: Likewise.
	* ld-x86-64/tlsgd6.dd: Likewise.
	* ld-x86-64/tlsgdesc.dd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlspic.td: Likewise.

	* ld-x86-64/ilp32-8.d: Match any file format variant.
	Use a -Ttext and adjust expected results, to handle variant layouts.
	* ld-x86-64/ilp32-9.d: Likewise.

	* ld-i386/alloc.t: Remove superfluous OUTPUT_FORMAT statement.
	* ld-i386/pr12627.t: Likewise.

	* ld-x86-64/abs-l1om.d: Add target: constraint.
	* ld-x86-64/protected2-l1om.d: Likewise.
	* ld-x86-64/protected3-l1om.d: Likewise.
	* ld-x86-64/ilp32-4.d: Likewise.

	* ld-x86-64/plt.s: New file.
	* ld-x86-64/pltlib.s: New file.
	* ld-x86-64/plt.pd: New file.
	* ld-x86-64/x86-64.exp (x86_64tests): Add them.

	* ld-i386/plt.s: New file.
	* ld-i386/pltlib.s: New file.
	* ld-i386/plt.pd: New file.
	* ld-i386/plt-pic.s: New file.
	* ld-i386/plt-pic.pd: New file.
	* ld-i386/i386.exp (i386tests): Add them.
@
text
@d5137 4
a5140 1
    /* 41 bytes of nop to pad out to the standard size.  */
d5145 2
a5146 2
    0x66, 0x66,                            /* excess data32 prefixes	*/
    0x2e, 0x0f, 0x1f, 0x84, 0, 0, 0, 0, 0, /* nopw %cs:0x0(%rax,%rax,1)	*/
@


1.254
log
@Handle relocation against protected function for -Bsymbolic

bfd/

2012-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13880
	* elf32-i386.c (elf_i386_relocate_section): Don't issue an error
	for R_386_GOTOFF relocation against protected function if
	SYMBOLIC_BIND is true.

	* elf64-x86-64.c (elf_x86_64_relocate_section): Don't issue an
	error for R_X86_64_GOTOFF64 relocation against protected function
	when building executable or SYMBOLIC_BIND is true.

ld/testsuite/

2012-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13880
	* ld-i386/i386.exp: Run protected4 and protected5.
	* ld-x86-64/x86-64.exp: Likewise.

	* ld-i386/protected4.d: New.
	* ld-i386/protected4.s: Likewise.
	* ld-i386/protected5.d: Likewise.
	* ld-i386/protected5.s: Likewise.
	* ld-x86-64/protected4.d: Likewise.
	* ld-x86-64/protected4.s: Likewise.
	* ld-x86-64/protected5.d: Likewise.
	* ld-x86-64/protected5.s: Likewise.
@
text
@d29 1
d5231 5
d5273 1
a5273 1
#undef elf_backend_object_p
d5275 4
a5278 2
#undef elf_backend_bfd_from_remote_memory
#undef elf_backend_size_info
@


1.253
log
@bfd/
2012-03-16  Roland McGrath  <mcgrathr@@google.com>

	* config.bfd: Handle x86_64-*-nacl*.
	* elf64-x86-64.c (bfd_elf64_x86_64_nacl_vec): New backend vector stanza.
	(bfd_elf32_x86_64_nacl_vec): Likewise.
	* targets.c: Support them.
	* configure.in: Likewise.
	* configure: Regenerated.

gas/
2012-03-16  Roland McGrath  <mcgrathr@@google.com>

	* config/tc-i386.h [TE_NACL] (ELF_TARGET_FORMAT32, ELF_TARGET_FORMAT64):
	Define for this case.
	* configure.tgt (i386-*-nacl*): If ${cpu} is x86_64*, default to x32.
@
text
@d3467 1
a3467 1
	  if (info->shared
d3469 1
@


1.252
log
@	* elf64-x86-64.c (elf_x86_64_create_dynamic_sections): Use
	elf_x86_64_backend_data parameters for plt_eh_frame.

Change-Id: I4e1a7c2787ed1276765e269f50fc8ba89bab41d5
@
text
@d985 1
a985 1
        = get_elf_x86_64_backend_data (dynobj);
d996 1
a996 1
        = bfd_alloc (dynobj, htab->plt_eh_frame->size);
d998 1
a998 1
              abed->eh_frame_plt, abed->eh_frame_plt_size);
d1078 8
d5098 173
d5299 11
a5309 4
#undef  elf_backend_static_tls_alignment

#undef elf_backend_want_plt_sym
#define elf_backend_want_plt_sym	    0
a5379 8
static bfd_boolean
elf32_x86_64_elf_object_p (bfd *abfd)
{
  /* Set the right machine number for an x86-64 elf32 file.  */
  bfd_default_set_arch_mach (abfd, bfd_arch_i386, bfd_mach_x64_32);
  return TRUE;
}

d5384 1
a5391 11
#define bfd_elf32_bfd_link_hash_table_create \
  elf_x86_64_link_hash_table_create
#define bfd_elf32_bfd_link_hash_table_free \
  elf_x86_64_link_hash_table_free
#define bfd_elf32_bfd_reloc_type_lookup	\
  elf_x86_64_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup \
  elf_x86_64_reloc_name_lookup
#define bfd_elf32_mkobject \
  elf_x86_64_mkobject

@


1.251
log
@	* elf64-x86-64.c (struct elf_x86_64_backend_data): New type.
	(get_elf_x86_64_backend_data, GET_PLT_ENTRY_SIZE): New macros.
	(elf_x86_64_arch_bed): New variable.
	(elf_backend_arch_data): New macro.
	(elf_x86_64_adjust_dynamic_symbol): Use GET_PLT_ENTRY_SIZE.
	(elf_x86_64_allocate_dynrelocs): Likewise.
	(elf_x86_64_relocate_section): Likewise.
	(elf_x86_64_plt_sym_val): Likewise.
	(elf_x86_64_finish_dynamic_symbol): Use elf_x86_64_backend_data
	parameters for PLT details.
	(elf_x86_64_finish_dynamic_sections): Likewise.
@
text
@d984 2
d994 1
a994 1
      htab->plt_eh_frame->size = sizeof (elf_x86_64_eh_frame_plt);
d996 3
a998 3
	= bfd_alloc (dynobj, htab->plt_eh_frame->size);
      memcpy (htab->plt_eh_frame->contents, elf_x86_64_eh_frame_plt,
	      sizeof (elf_x86_64_eh_frame_plt));
@


1.250
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@d588 64
d788 2
a789 2
          bfd_hash_allocate (table,
                             sizeof (struct elf_x86_64_link_hash_entry));
d906 1
a906 1
  ret->next_jump_slot_index = 0; 
d1174 1
a1174 1
	 may be versioned.  */ 
d2074 1
a2074 1
	        h->plt.refcount -= 1;
d2274 1
d2286 1
d2294 1
a2294 1
					       PLT_ENTRY_SIZE,
d2316 1
a2316 1
	    s->size += PLT_ENTRY_SIZE;
d2333 1
a2333 1
	  s->size += PLT_ENTRY_SIZE;
d2757 1
a2757 1
	    htab->elf.splt->size += PLT_ENTRY_SIZE;
d2759 1
a2759 1
	  htab->elf.splt->size += PLT_ENTRY_SIZE;
d2771 1
a2771 1
         entries and there is no refeence to _GLOBAL_OFFSET_TABLE_.  */
d2897 1
a2897 1
	    elf_link_hash_traverse (&htab->elf, 
d3050 1
d3093 1
a3093 1
	  || ABI_64_P (output_bfd)) 
d3120 1
a3120 1
	      /* Set STT_GNU_IFUNC symbol value.  */ 
d3196 1
a3196 1
	    case R_X86_64_64: 
d3281 1
a3281 1
		      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
d3287 1
a3287 1
		      plt_index = h->plt.offset / PLT_ENTRY_SIZE;
d3296 1
a3296 1
		      /* This references the local defitionion.  We must 
d3298 1
a3298 1
			 Since the offset must always be a multiple of 8, 
d3354 1
a3354 1
	          && h->plt.offset != (bfd_vma)-1
d3361 1
a3361 1
		  bfd_vma plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
d3392 1
a3392 1
		         as -1 | 1 still is -1.  */
d3490 1
a3490 1
          if (h != NULL
d4224 2
d4279 1
a4279 1
	  got_offset = h->plt.offset / PLT_ENTRY_SIZE - 1;
d4284 1
a4284 1
	  got_offset = h->plt.offset / PLT_ENTRY_SIZE;
d4289 4
a4292 2
      memcpy (plt->contents + h->plt.offset, elf_x86_64_plt_entry,
	      PLT_ENTRY_SIZE);
d4294 2
a4295 5
      /* Insert the relocation positions of the plt section.  The magic
	 numbers at the end of the statements are the positions of the
	 relocations in the plt section.  */
      /* Put offset for jmp *name@@GOTPCREL(%rip), since the
	 instruction uses 6 bytes, subtract this value.  */
d4297 8
a4304 8
		      (gotplt->output_section->vma
		       + gotplt->output_offset
		       + got_offset
		       - plt->output_section->vma
		       - plt->output_offset
		       - h->plt.offset
		       - 6),
		  plt->contents + h->plt.offset + 2);
d4307 1
a4307 1
	 points to the pushq instruction in the PLT which is at offset 6.  */
d4310 1
a4310 1
			       + h->plt.offset + 6),
d4344 1
a4344 1
		      plt->contents + h->plt.offset + 7);
d4346 2
a4347 2
	  bfd_put_32 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE),
		      plt->contents + h->plt.offset + 12);
d4479 1
a4479 1
    = (struct bfd_link_info *) inf; 
d4513 2
d4597 2
a4598 2
	  memcpy (htab->elf.splt->contents, elf_x86_64_plt0_entry,
		  PLT_ENTRY_SIZE);
d4608 3
a4610 3
		      htab->elf.splt->contents + 2);
	  /* Add offset for jmp *GOT+16(%rip). The 12 is the offset to
	     the end of the instruction.  */
d4617 2
a4618 2
		       - 12),
		      htab->elf.splt->contents + 8);
d4620 2
a4621 2
	  elf_section_data (htab->elf.splt->output_section)->this_hdr.sh_entsize =
	    PLT_ENTRY_SIZE;
d4629 1
a4629 2
		      elf_x86_64_plt0_entry,
		      PLT_ENTRY_SIZE);
d4641 5
a4645 4
			  htab->elf.splt->contents + htab->tlsdesc_plt + 2);
	      /* Add offset for jmp *GOT+TDG(%rip), where TGD stands for
		 htab->tlsdesc_got. The 12 is the offset to the end of
		 the instruction.  */
d4653 3
a4655 2
			   - 12),
			  htab->elf.splt->contents + htab->tlsdesc_plt + 8);
d4735 1
a4735 1
  return plt->vma + (i + 1) * PLT_ENTRY_SIZE;
@


1.249
log
@Restore R_386_IRELATIVE and R_X86_64_IRELATIVE

bfd/

2012-03-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13817
	* bfd/elf32-i386.c (elf_i386_relocate_section): Restore
	R_386_IRELATIVE.

	* * elf64-x86-64.c (elf_x86_64_relocate_section): Restore
	R_X86_64_IRELATIVE.

ld/testsuite/

2012-03-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13817
	* ld-i386/pr13302.d: Updated.
	* ld-x86-64/pr13082-5b.d: Likewise.
	* ld-x86-64/pr13082-6a.d: Likewise.
	* ld-x86-64/pr13082-6b.d: Likewise.
@
text
@a2168 7
  if (h->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
      return TRUE;
    }

d2186 1
a2186 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.248
log
@	* elf64-x86-64.c (elf_x86_64_relocate_section): For R_X86_64_RELATIVE
	set relocate to TRUE.
@
text
@a3158 1
		  bfd_boolean relocate;
d3178 4
a3181 3
		      outrel.r_info = htab->r_info (0, R_X86_64_RELATIVE);
		      outrel.r_addend = relocation;
		      relocate = TRUE;
a3186 1
		      relocate = FALSE;
d3197 1
a3197 2
		  if (! relocate)
		    continue;
@


1.247
log
@Remove ABI_64_P check on R_X86_64_PCXX

bfd/

2012-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13581
	* elf64-x86-64.c (elf_x86_64_relocate_section): Remove ABI_64_P
	check on R_X86_64_PCXX.

ld/testsuite/

2012-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13581
	* ld-x86-64/ilp32-4.s: New.
	* ld-x86-64/ilp32-10.d: Likewise.
	* ld-x86-64/ilp32-10.s: Likewise.

	* ld-x86-64/ilp32-4.d: Adjusted.
	* ld-x86-64/ilp32-5.d: Likewise.
	* ld-x86-64/ilp32-5.s: Likewise.

	* ld-x86-64/x86-64.exp: Run ilp32-10.
@
text
@d3 1
a3 1
   2010, 2011
d3181 1
a3181 1
		      relocate = FALSE;
@


1.246
log
@bfd/
	Fix zero registers core files when built by gcc-4.7.
	* elf64-x86-64.c (elf_x86_64_write_core_note): Remove variables p and
	size.  Call elfcore_write_note for the local variables.  Remove the
	final elfcore_write_note call.  Add NOTREACHED comments.
@
text
@a3474 1
	      && ABI_64_P (output_bfd)
@


1.245
log
@Set the default x32 interpreter to "/lib/ldx32.so.1"

2011-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (ELF32_DYNAMIC_INTERPRETER): Set to
	 "/lib/ldx32.so.1".
@
text
@a422 2
  const void *p;
  int size;
d446 2
a447 2
	  p = (const void *) &data;
	  size = sizeof (data);
d455 2
a456 2
	  p = (const void *) &data;
	  size = sizeof (data);
d458 1
a458 1
      break;
d476 2
a477 2
	      p = (const void *) &prstat;
	      size = sizeof (prstat);
d486 2
a487 2
	      p = (const void *) &prstat;
	      size = sizeof (prstat);
d497 2
a498 2
	  p = (const void *) &prstat;
	  size = sizeof (prstat);
a499 1
      break;
d501 1
a501 3

  return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type, p,
			     size);
@


1.244
log
@Replace IRELATIVE relocations with RELATIVE in .rel.dyn.

bfd/

2011-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13302
	* elf32-i386.c (elf_i386_relocate_section): Replace
	R_386_IRELATIVE with R_386_RELATIVE.

	* elf64-x86-64.c (elf_x86_64_relocate_section): Replace
	R_X86_64_IRELATIVE with R_X86_64_RELATIVE.

ld/testsuite/

2011-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13302
	* ld-i386/i386.exp: Run pr13302.

	* ld-i386/pr13302.d: New.
	* ld-i386/pr13302.s: Likewise.

	* ld-x86-64/pr13082-5b.d: Updated.
	* ld-x86-64/pr13082-6a.d: Likewise.
	* ld-x86-64/pr13082-6b.d: Likewise.
@
text
@d516 1
a516 1
#define ELF32_DYNAMIC_INTERPRETER "/lib/ld32.so.1"
@


1.244.2.1
log
@bfd/
	Fix zero registers core files when built by gcc-4.7.
	* elf64-x86-64.c: Update copyright year.
	(elf_x86_64_write_core_note): Remove variables p and size.  Call
	elfcore_write_note for the local variables.  Remove the final
	elfcore_write_note call.  Add NOTREACHED comments.
@
text
@d3 1
a3 1
   2010, 2011, 2012
d423 2
d448 2
a449 2
	  return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
				     &data, sizeof (data));
d457 2
a458 2
	  return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
				     &data, sizeof (data));
d460 1
a460 1
      /* NOTREACHED */
d478 2
a479 2
	      return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
					 &prstat, sizeof (prstat));
d488 2
a489 2
	      return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
					 &prstat, sizeof (prstat));
d499 2
a500 2
	  return elfcore_write_note (abfd, buf, bufsiz, "CORE", note_type,
				     &prstat, sizeof (prstat));
d502 1
d504 3
a506 1
  /* NOTREACHED */
@


1.243
log
@Fix a typo in comments.

2011-10-21  H.J. Lu  <hongjiu.lu@@intel.com>.

	* elf32-i386.c (elf_i386_relocate_section): Fix a typo in
	comments.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
@
text
@d3164 1
d3184 3
a3186 4
		      outrel.r_info = htab->r_info (0, R_X86_64_IRELATIVE);
		      outrel.r_addend = (h->root.u.def.value
					 + h->root.u.def.section->output_section->vma
					 + h->root.u.def.section->output_offset);
d3192 1
d3203 2
a3204 1
		  continue;
@


1.242
log
@Put IRELATIVE relocations after JUMP_SLOT.

bfd/

2011-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13302
	* elf32-i386.c (elf_i386_link_hash_table): Add next_jump_slot_index
	and next_irelative_index.
	(elf_i386_link_hash_table_create): Initialize next_jump_slot_index
	and next_irelative_index.
	(elf_i386_allocate_dynrelocs): Increment reloc_count instead of
	next_tls_desc_index.
	(elf_i386_size_dynamic_sections): Set next_tls_desc_index and
	next_irelative_index from reloc_count.
	(elf_i386_finish_dynamic_symbol): Put R_386_IRELATIVE after
	R_386_JUMP_SLOT.

	* elf64-x86-64.c (elf_x86_64_link_hash_table): Add
	next_jump_slot_index and next_irelative_index.
	(elf_x86_64_link_hash_table_create): Initialize
	next_jump_slot_index and next_irelative_index.
	(elf_x86_64_size_dynamic_sections): Set next_irelative_index
	from reloc_count.
	(elf_x86_64_finish_dynamic_symbol): Put R_X86_64_IRELATIVE after
	R_X86_64_JUMP_SLOT.

ld/testsuite/

2011-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13302
	* ld-ifunc/ifunc-16-i386.d: New.
	* ld-ifunc/ifunc-16-x86-64.d: Likewise.
	* ld-ifunc/ifunc-16-x86.s: Likewise.
@
text
@d3159 1
a3159 1
		 non-GOF reference in a shared object.  */
@


1.241
log
@	* elf32-i386.c (i386_opcode16): Delete.
	(elf_i386_check_tls_transition): Use memcmp to compare contents.
	* elf64-x86-64.c (x86_64_opcode16, x86_64_opcode32): Delete.
	(elf_x86_64_check_tls_transition): Use memcmp to compare contents.
@
text
@d701 5
d847 2
d2677 4
a2680 1
     slot size.  */
d2682 7
a2688 2
    htab->sgotplt_jump_table_size
      = elf_x86_64_compute_jump_table_size (htab);
d4223 2
a4224 2
	  plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
	  got_offset = (plt_index + 3) * GOT_ENTRY_SIZE;
d4228 2
a4229 2
	  plt_index = h->plt.offset / PLT_ENTRY_SIZE;
	  got_offset = plt_index * GOT_ENTRY_SIZE;
a4250 11
      /* Don't fill PLT entry for static executables.  */
      if (plt == htab->elf.splt)
	{
	  /* Put relocation index.  */
	  bfd_put_32 (output_bfd, plt_index,
		      plt->contents + h->plt.offset + 7);
	  /* Put offset for jmp .PLT0.  */
	  bfd_put_32 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE),
		      plt->contents + h->plt.offset + 12);
	}

d4274 2
d4281 12
@


1.240
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@a1009 14
typedef union
  {
    unsigned char c[2];
    uint16_t i;
  }
x86_64_opcode16;

typedef union
  {
    unsigned char c[4];
    uint32_t i;
  }
x86_64_opcode32;

d1065 3
a1067 1
	  static x86_64_opcode32 call = { { 0x66, 0x66, 0x48, 0xe8 } };
d1069 1
a1069 1
	      || bfd_get_32 (abfd, contents + offset + 4) != call.i)
a1073 1
	      static x86_64_opcode32 leaq = { { 0x66, 0x48, 0x8d, 0x3d } };
d1075 1
a1075 1
		  || bfd_get_32 (abfd, contents + offset - 4) != leaq.i)
a1079 1
	      static x86_64_opcode16 lea = { { 0x8d, 0x3d } };
d1081 1
a1081 2
		  || bfd_get_8 (abfd, contents + offset - 3) != 0x48
		  || bfd_get_16 (abfd, contents + offset - 2) != lea.i)
d1092 1
a1092 2
	  static x86_64_opcode32 ld = { { 0x48, 0x8d, 0x3d, 0xe8 } };
	  x86_64_opcode32 op;
d1097 2
a1098 3
	  op.i = bfd_get_32 (abfd, contents + offset - 3);
	  op.c[3] = bfd_get_8 (abfd, contents + offset + 4);
	  if (op.i != ld.i)
d1177 2
a1178 2
	  static x86_64_opcode16 call = { { 0xff, 0x10 } };
	  return bfd_get_16 (abfd, contents + offset) == call.i;
@


1.239
log
@Add R_X86_64_RELATIVE64 and handle R_X86_64_64 for x32.

bfd/

2011-08-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13082
	* elf64-x86-64.c (x86_64_elf_howto_table): Add R_X86_64_RELATIVE64.
	(elf_x86_64_relocate_section): Treat R_X86_64_64 like R_X86_64_32
	and zero-extend it to 64bit if addend is zero for x32.  Generate
	R_X86_64_RELATIVE64 for x32.

include/elf/

2011-08-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13082
	* x86-64.h (R_X86_64_RELATIVE64): New.

ld/testsuite/

2011-08-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13082
	* ld-x86-64/pr13082-1.s: New.
	* ld-x86-64/pr13082-1a.d: Likewise.
	* ld-x86-64/pr13082-1b.d: Likewise.
	* ld-x86-64/pr13082-2.s: Likewise.
	* ld-x86-64/pr13082-2a.d: Likewise.
	* ld-x86-64/pr13082-2b.d: Likewise.
	* ld-x86-64/pr13082-3.s: Likewise.
	* ld-x86-64/pr13082-3a.d: Likewise.
	* ld-x86-64/pr13082-3b.d: Likewise.
	* ld-x86-64/pr13082-4.s: Likewise.
	* ld-x86-64/pr13082-4a.d: Likewise.
	* ld-x86-64/pr13082-4b.d: Likewise.
	* ld-x86-64/pr13082-5.s: Likewise.
	* ld-x86-64/pr13082-5a.d: Likewise.
	* ld-x86-64/pr13082-5b.d: Likewise.
	* ld-x86-64/pr13082-6.s: Likewise.
	* ld-x86-64/pr13082-6a.d: Likewise.
	* ld-x86-64/pr13082-6b.d: Likewise.

	* ld-x86-64/x86-64.exp: Run pr13082-[1-6][ab].
@
text
@d4106 3
a4108 1
	       && h->def_dynamic))
@


1.239.2.1
log
@	2011-10-20  Alan Modra  <amodra@@gmail.com>
	* elf32-i386.c (i386_opcode16): Delete.
	(elf_i386_check_tls_transition): Use memcmp to compare contents.
	* elf64-x86-64.c (x86_64_opcode16, x86_64_opcode32): Delete.
	(elf_x86_64_check_tls_transition): Use memcmp to compare contents.
@
text
@d1010 14
d1079 1
a1079 3
	  static const unsigned char call[] = { 0x66, 0x66, 0x48, 0xe8 };
	  static const unsigned char leaq[] = { 0x66, 0x48, 0x8d, 0x3d };

d1081 1
a1081 1
	      || memcmp (contents + offset + 4, call, 4) != 0)
d1086 1
d1088 1
a1088 1
		  || memcmp (contents + offset - 4, leaq, 4) != 0)
d1093 1
d1095 2
a1096 1
		  || memcmp (contents + offset - 3, leaq + 1, 3) != 0)
d1107 2
a1108 1
	  static const unsigned char lea[] = { 0x48, 0x8d, 0x3d };
d1113 3
a1115 2
	  if (memcmp (contents + offset - 3, lea, 3) != 0
	      || 0xe8 != *(contents + offset + 4))
d1194 2
a1195 2
	  static const unsigned char call[] = { 0xff, 0x10 };
	  return memcmp (contents + offset, call, 2) == 0;
@


1.239.2.2
log
@Remove ABI_64_P check on R_X86_64_PCXX

bfd/

2012-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13581
	* elf64-x86-64.c (elf_x86_64_relocate_section): Remove ABI_64_P
	check on R_X86_64_PCXX.

ld/testsuite/

2012-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13581
	* ld-x86-64/ilp32-4.s: New.
	* ld-x86-64/ilp32-10.d: Likewise.
	* ld-x86-64/ilp32-10.s: Likewise.

	* ld-x86-64/ilp32-4.d: Adjusted.
	* ld-x86-64/ilp32-5.d: Likewise.
	* ld-x86-64/ilp32-5.s: Likewise.

	* ld-x86-64/x86-64.exp: Run ilp32-10.
@
text
@d3463 1
@


1.239.2.3
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d3065 1
a3065 1
      if (sec != NULL && discarded_section (sec))
d4628 1
a4628 1
	  == SEC_INFO_TYPE_EH_FRAME)
@


1.238
log
@Check R_X86_64_32 overflow and allow R_X86_64_64 for x32.

bfd/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* archures.c (bfd_mach_i386_intel_syntax): New.
	(bfd_mach_i386_i8086): Updated.
	(bfd_mach_i386_i386): Likewise.
	(bfd_mach_x86_64): Likewise.
	(bfd_mach_x64_32): Likewise.
	(bfd_mach_i386_i386_intel_syntax): Likewise.
	(bfd_mach_x86_64_intel_syntax): Likewise.
	(bfd_mach_x64_32_intel_syntax): Likewise.
	(bfd_mach_l1om): Likewise.
	(bfd_mach_l1om_intel_syntax): Likewise.
	(bfd_mach_k1om): Likewise.
	(bfd_mach_k1om_intel_syntax): Likewise.

	* bfd-in2.h: Regenerated.

	* cpu-i386.c (bfd_i386_compatible): Check mach instead of
	bits_per_address.
	(bfd_x64_32_arch_intel_syntax): Set bits_per_address to 64.
	(bfd_x64_32_arch): Likewise.

	* elf64-x86-64.c: Include "libiberty.h".
	(x86_64_elf_howto_table): Append x32 R_X86_64_32.
	(elf_x86_64_rtype_to_howto): Support x32 R_X86_64_32.
	(elf_x86_64_reloc_type_lookup): Likewise.
	(elf_x86_64_reloc_name_lookup): Likewise.
	(elf_x86_64_relocate_section): Likewise.
	(elf_x86_64_check_relocs): Allow R_X86_64_64 relocations for x32.

gas/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* config/tc-i386.c (handle_quad): Removed.
	(md_pseudo_table): Remove "quad".
	(tc_gen_reloc): Don't check BFD_RELOC_64 for disallow_64bit_reloc.
	(x86_dwarf2_addr_size): New.

	* config/tc-i386.h (x86_dwarf2_addr_size): New.
	(DWARF2_ADDR_SIZE): Likewise.

gas/testsuite/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* gas/i386/ilp32/ilp32.exp: Don't run inval.

	* gas/i386/ilp32/inval.l: Removed.
	* gas/i386/ilp32/inval.s: Likewise.

	* gas/i386/ilp32/quad.d: Expect R_X86_64_64 instead of
	R_X86_64_32.

	* gas/i386/ilp32/x86-64-pcrel.s: Add tests for movabs.
	* gas/i386/ilp32/x86-64-pcrel.d: Updated.

ld/testsuite/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* ld-x86-64/ilp32-6.d: New.
	* ld-x86-64/ilp32-6.s: Likewise.
	* ld-x86-64/ilp32-7.d: Likewise.
	* ld-x86-64/ilp32-7.s: Likewise.
	* ld-x86-64/ilp32-8.d: Likewise.
	* ld-x86-64/ilp32-8.s: Likewise.
	* ld-x86-64/ilp32-9.d: Likewise.
	* ld-x86-64/ilp32-9.s: Likewise.

	* ld-x86-64/x86-64.exp: Run ilp32-6, ilp32-7, ilp32-8 and ilp32-9.

opcodes/

2011-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13048
	* i386-dis.c (print_insn): Optimize info->mach check.
@
text
@d167 3
d3089 10
d3613 8
@


1.237
log
@Add initial Intel K1OM support.

bfd/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_MACHINES): Add cpu-k1om.lo.
	(ALL_MACHINES_CFILES): Add cpu-k1om.c.
	* Makefile.in: Regenerated.

	* archures.c (bfd_architecture): Add bfd_arch_k1om.
	(bfd_k1om_arch): New.
	(bfd_archures_list): Add &bfd_k1om_arch.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf64_k1om_vec if
	bfd_elf64_x86_64_vec is supported.  Add bfd_elf64_k1om_freebsd_vec
	if bfd_elf64_x86_64_freebsd_vec is supported.
	(targ_selvecs): Likewise.

	* configure.in: Support bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.
	* configure: Regenerated.

	* cpu-k1om.c: New.

	* elf64-x86-64.c (elf64_k1om_elf_object_p): New.
	(bfd_elf64_k1om_vec): Likewise.
	(bfd_elf64_k1om_freebsd_vec): Likewise.

	* targets.c (bfd_elf64_k1om_vec): New.
	(bfd_elf64_k1om_freebsd_vec): Likewise.
	(_bfd_target_vector): Add bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.

binutils/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (init_dwarf_regnames): Handle EM_K1OM.

	* elfedit.c (elf_machine): Support EM_K1OM.
	(elf_class): Likewise.

	* readelf.c (guess_is_rela): Handle EM_K1OM.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(get_section_type_name): Likewise.
	(get_elf_section_flags): Likewise.
	(process_section_headers): Likewise.
	(get_symbol_index_type): Likewise.
	(is_32bit_abs_reloc): Likewise.
	(is_32bit_pcrel_reloc): Likewise.
	(is_64bit_abs_reloc): Likewise.
	(is_64bit_pcrel_reloc): Likewise.
	(is_none_reloc): Likewise.

	* doc/binutils.texi: Mention K1OM for elfedit.

binutils/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/elfedit.exp: Run elfedit-4.

	* binutils-all/elfedit-4.d: New.

gas/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add k1om.
	(i386_align_code): Handle PROCESSOR_K1OM.
	(check_cpu_arch_compatible): Check EM_K1OM.
	(i386_arch): Handle Intel K1OM.
	(i386_mach): Return bfd_mach_k1om for Intel K1OM.
	(i386_target_format): Return ELF_TARGET_K1OM_FORMAT for Intel
	K1OM.

	* config/tc-i386.h (ELF_TARGET_K1OM_FORMAT): New.
	(processor_type): Add PROCESSOR_K1OM.

	* doc/c-i386.texi: Document k1om.

gas/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/k1om.d: New.
	* gas/i386/k1om-inval.l: Likewise.
	* gas/i386/k1om-inval.s: Likewise.

	* gas/i386/i386.exp: Run k1om-inval and k1om.

include/elf/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (EM_K1OM): New.

ld/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_64_EMULATIONS): Add eelf_k1om.o and
	eelf_k1om_fbsd.o
	(eelf_k1om.c): New.
	(eelf_k1om_fbsd.c): Likewise.
	* Makefile.in: Regenerated.

	* configure.tgt (targ64_extra_emuls): Add elf_k1om if elf_x86_64
	is supported.  Add elf_k1om_fbsd if elf_x86_64_fbsd is supported.
	(targ_extra_emuls): Likewise.

	* emulparams/elf_k1om.sh: New.
	* emulparams/elf_k1om_fbsd.sh: Likewise.

ld/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/abs-k1om.d: New.
	* ld-x86-64/protected2-k1om.d: Likewise.
	* ld-x86-64/protected3-k1om.d: Likewise.

	* ld-x86-64/x86-64.exp: Run abs-k1om, protected2-k1om and
	protected3-k1om.

opcodes/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in: Handle bfd_k1om_arch.
	* configure: Regenerated.

	* disassemble.c (disassembler): Handle bfd_k1om_arch.

	* i386-dis.c (print_insn): Handle bfd_mach_k1om and
	bfd_mach_k1om_intel_syntax.

	* i386-gen.c (cpu_flag_init): Set CPU_UNKNOWN_FLAGS to
	~(CpuL1OM|CpuK1OM).  Add CPU_K1OM_FLAGS.
	(cpu_flags): Add CpuK1OM.

	* i386-opc.h (CpuK1OM): New.
	(i386_cpu_flags): Add cpuk1om.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d33 1
d182 6
a187 1
	 FALSE)
d250 9
a258 2
  if (r_type < (unsigned int) R_X86_64_GNU_VTINHERIT
      || r_type >= (unsigned int) R_X86_64_max)
d292 1
a292 1
elf_x86_64_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
d297 10
a306 4
  for (i = 0;
       i < (sizeof (x86_64_elf_howto_table)
	    / sizeof (x86_64_elf_howto_table[0]));
       i++)
a1417 8
	  case R_X86_64_64:
	    /* Allow R_X86_64_64 relocations in SEC_DEBUGGING sections
	       when building shared libraries.  */
	    if (info->shared
		&& !info->executable
		&& (sec->flags & SEC_DEBUGGING) != 0)
	      break;

d3036 6
a3041 1
      howto = x86_64_elf_howto_table + r_type;
@


1.236
log
@Always elf_backend_post_process_headers to _bfd_elf_set_osabi.

2011-07-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_backend_post_process_headers): Always
	define to _bfd_elf_set_osabi.
@
text
@d5040 50
@


1.235
log
@Properly define elf_backend_post_process_headers.

2011-06-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_backend_post_process_headers): Don't
	define for FreeBSD/x86-64 nor FreeBSD/L1OM.  Define for L1OM.
@
text
@a4942 1
#undef  elf_backend_post_process_headers
a4959 2
#undef  elf_backend_post_process_headers

a5017 3
#undef  elf_backend_post_process_headers
#define elf_backend_post_process_headers    _bfd_elf_set_osabi

a5037 2
#undef  elf_backend_post_process_headers

a5073 3
#undef elf_backend_post_process_headers
#define elf_backend_post_process_headers    _bfd_elf_set_osabi

@


1.234
log
@bfd/
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Initialize
	PLT_EH_FRAME.
	* elf32-i386.c (elf_i386_link_hash_table): Likewise.
@
text
@d4961 2
d5022 2
a5044 1
#define elf_backend_post_process_headers  _bfd_elf_set_osabi
d5083 1
a5096 3
#undef  elf_backend_post_process_headers
#define elf_backend_post_process_headers  _bfd_elf_set_osabi

@


1.233
log
@	PR ld/12570
include/
	* bfdlink.h (struct bfd_link_info): Add no_ld_generated_unwind_info
	option.
ld/
	* emultempl/elf32.em (OPTION_LD_GENERATED_UNWIND_INFO,
	OPTION_NO_LD_GENERATED_UNWIND_INFO): Define.
	(gld${EMULATION_NAME}_handle_option): Handle
	--ld-generated-unwind-info and --no-ld-generated-unwind-info.
	* ld.texinfo (--ld-generated-unwind-info,
	--no-ld-generated-unwind-info): Document.
bfd/
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): Allow no relocations
	at all for linker created .eh_frame sections.
	(_bfd_elf_discard_section_eh_frame): Handle linker created
	.eh_frame sections with no relocations.
	* elf64-x86-64.c: Include dwarf2.h.
	(elf_x86_64_eh_frame_plt): New variable.
	(PLT_CIE_LENGTH, PLT_FDE_LENGTH, PLT_FDE_START_OFFSET,
	PLT_FDE_LEN_OFFSET): Define.
	(struct elf_x86_64_link_hash_table): Add plt_eh_frame field.
	(elf_x86_64_create_dynamic_sections): Create and fill in
	.eh_frame section for .plt section.
	(elf_x86_64_size_dynamic_sections): Write .plt section size
	into .eh_frame FDE covering .plt section.
	(elf_x86_64_finish_dynamic_sections): Write .plt section
	start into .eh_frame FDE covering .plt section.  Call
	_bfd_elf_write_section_eh_frame on htab->plt_eh_frame section.
	(elf_backend_plt_alignment): Define to 4.
	* elf32-i386.c: Include dwarf2.h.
	(elf_i386_eh_frame_plt): New variable.
	(PLT_CIE_LENGTH, PLT_FDE_LENGTH, PLT_FDE_START_OFFSET,
	PLT_FDE_LEN_OFFSET): Define.
	(struct elf_i386_link_hash_table): Add plt_eh_frame field.
	(elf_i386_create_dynamic_sections): Create and fill in
	.eh_frame section for .plt section.
	(elf_i386_size_dynamic_sections): Write .plt section size
	into .eh_frame FDE covering .plt section.
	(elf_i386_finish_dynamic_sections): Write .plt section
	start into .eh_frame FDE covering .plt section.  Call
	_bfd_elf_write_section_eh_frame on htab->plt_eh_frame section.
	(elf_backend_plt_alignment): Define to 4.
ld/testsuite/
	* ld-x86-64/x86-64.exp: Link some testcases with
	--no-ld-generated-unwind-info.
	* ld-x86-64/tlsbin.rd: Add --no-ld-generated-unwind-info to ld
	comment.
	* ld-x86-64/tlsdesc.dd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsdesc.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlsbindesc.rd: Likewise.
	* ld-x86-64/tlsbindesc.sd: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsdesc.pd: Likewise.
	* ld-x86-64/tlsdesc.td: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlsgdesc.rd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbindesc.td: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/ilp32-4.d: Likewise.
	* ld-x86-64/tlsgdesc.dd: Add --no-ld-generated-unwind-info to ld
	comment.  Adjust.
	* ld-x86-64/tlsdesc.rd: Likewise.
	* ld-x86-64/tlsgd6.dd: Adjust.
	* ld-x86-64/tlsgd5.dd: Likewise.
	* ld-i386/i386.exp: Link some testcases with
	--no-ld-generated-unwind-info.
	* ld-i386/tlsbin.rd: Add --no-ld-generated-unwind-info to ld
	comment..
	* ld-i386/tlsdesc.dd: Likewise.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlsdesc.sd: Likewise.
	* ld-i386/tlsgdesc.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-i386/tlsdesc.rd: Likewise.
	* ld-i386/tlsbindesc.rd: Likewise.
	* ld-i386/tlsbindesc.sd: Likewise.
	* ld-i386/tlsbin.td: Likewise.
	* ld-i386/tlsdesc.td: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsbindesc.dd: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsgdesc.rd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsbindesc.td: Likewise.
	* ld-i386/tlspic.td: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
@
text
@d813 1
@


1.232
log
@Fix misc x32 bugs.

bfd/

2011-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_backend_post_process_headers): Defined
	for x32.

binutils/testsuite/

2011-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/elfedit-1.d: Updated for x32.

gas/

2011-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.tgt: Support x32.

ld/

2011-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.tgt: Support x32.

ld/testsuite/

2011-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/eh1.d: Skip x32.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
	* ld-elf/eh4.d: Likewise.

	* ld-elfvsb/elfvsb.exp: Only xfail 64bit x86_64-*-linux*.
	* ld-shared/shared.exp: Likewise.

	* ld-ifunc/ifunc-1-local-x86.d: Support x32.
	* ld-ifunc/ifunc-1-x86.d: Likewise.
	* ld-ifunc/ifunc-3a-x86.d: Likewise.
	* ld-x86-64/pcrel16.d: Likewise.

	* ld-x86-64/x86-64.exp (x86_64tests): Add missing -melf_x86_64.
@
text
@d32 1
d532 39
d644 1
d891 18
d2783 7
d4590 27
d4883 1
@


1.231
log
@Suport x32 gcore.

2011-06-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c: Include <stdarg.h> and CORE_HEADER if
	CORE_HEADER is defined.
	(elf_x86_64_write_core_note): New.
	(elf_backend_write_core_note): Likewise.

	* hosts/x86-64linux.h (uint64_t): New.
	(user_regsx32_struct): Likewise.
	(elf_gregx32_t): Likewise.
	(ELF_NGREGX32): Likewise.
	(elf_gregsetx32_t): Likewise.
	(elf_prstatusx32): Likewise.
	(prstatusx32_t): Likewise.
	(user_fpregs32_struct): Removed.
	(user_fpxregs32_struct): Likewise.
	(user32): Likewise.
	(elf_fpregset32_t): Likewise.
	(elf_fpxregset32_t): Likewise.
	(prgregset32_t): Likewise.
	(prfpregset32_t): Likewise.
@
text
@d4998 3
@


1.230
log
@Support x32 core dump.

2011-06-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_grok_prstatus): Support x32.
	(elf_x86_64_grok_psinfo): Likewise.
@
text
@d35 5
d393 93
d4812 3
@


1.229
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d314 13
d356 9
@


1.228
log
@Allow building x32 DSO from x86-64 object file.

bfd/

2011-06-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_check_relocs): Allow R_X86_64_64
	relocations in SEC_DEBUGGING sections when building shared
	libraries.

ld/testsuite/

2011-06-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/simple.c: New.
	* ld-x86-64/x86-64-x32.rd: Likewise.

	* ld-x86-64/x86-64.exp: Check building x32 DSO from x86-64
	object file.
@
text
@a2041 2
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;
a2305 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.227
log
@Properly warn relocation in readonly section in a shared object.

2011-06-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_size_dynamic_sections): Properly warn
	relocation in readonly section in a shared object.
	* elf64-x86-64.c (elf_x86_64_size_dynamic_sections): Likewise.
@
text
@d1220 7
@


1.226
log
@Handle R_X86_64_TPOFF64 in executable.

bfd/

2011-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12809
	* elf64-x86-64.c (elf_x86_64_relocate_section): Handle
	R_X86_64_TPOFF64 in executable.

ld/testsuite/

2011-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12809
	* ld-x86-64/tlsbin.s: Add a test for LE with large model.

	* ld-x86-64/tlsbin.dd: Updated.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlsbindesc.rd: Likewise.
	* ld-x86-64/tlsbindesc.sd: Likewise.
	* ld-x86-64/tlsbindesc.td: Likewise.
@
text
@d2402 2
a2403 1
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
a2408 1
		      break;
@


1.225
log
@	PR ld/12718
	* elf32-i386.c (elf_i386_check_relocs): Ensure dynobj set before
	creating ifunc sections.
	* elf64-x86-64.c (elf_x86_64_check_relocs): Likewise.
@
text
@d3866 1
@


1.224
log
@Correct parameter names for elf_x86_64_merge_symbol.

2011-04-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_merge_symbol): Correct parameter
	names.
@
text
@d1264 3
a1266 1
	      if (!_bfd_elf_create_ifunc_sections (abfd, info))
@


1.223
log
@Warn relocation in readonly section in a shared object.

2011-04-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_readonly_dynrelocs): Warn relocation
	in readonly section in a shared object.
	(elf_i386_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf_x86_64_readonly_dynrelocs): Likewise.
	(elf_x86_64_size_dynamic_sections): Likewise.
@
text
@d4554 2
a4555 2
			 bfd_boolean *newdef ATTRIBUTE_UNUSED,
			 bfd_boolean *newdyn,
d4560 2
a4561 2
			 bfd_boolean *olddef ATTRIBUTE_UNUSED,
			 bfd_boolean *olddyn,
d4570 1
a4570 1
  if (!*olddyn
d4572 1
a4572 1
      && !*newdyn
@


1.222
log
@Skip local IFUNC symbols when checking dynamic relocs in read-only sections.

bfd/

2011-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12694
	* elf32-i386.c (elf_i386_readonly_dynrelocs): Skip local IFUNC
	symbols.
	* elf64-x86-64.c (elf_x86_64_readonly_dynrelocs): Likewise.

ld/testsuite/

2011-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12694
	* ld-ifunc/ifunc-14-i386.d: New.
	* ld-ifunc/ifunc-14-x86-64.d: Likewise.
	* ld-ifunc/ifunc-14a.s: Likewise.
	* ld-ifunc/ifunc-14b.s: Likewise.
@
text
@d2317 5
d2401 7
a2407 1
		    info->flags |= DF_TEXTREL;
@


1.221
log
@Return false on dynamic symbol error.

2011-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Return false
	on dynamic symbol error.
	* elf64-x86-64.c (elf_x86_64_finish_dynamic_symbol): Likewise.
@
text
@d2302 4
@


1.220
log
@	PR 10549
	* elf-bfd.h (has_ifunc_symbols): Renamed to has_gnu_symbols.
	(has_gnu_symbols): Renamed from has_ifunc_symbols.
	* elf.c (_bfd_elf_set_osabi): Use new has_gnu_symbols name.
	* elf32-arm.c (elf32_arm_add_symbol_hook): Set has_gnu_symbols
	also if STB_GNU_UNIQUE symbol binding was seen.
	* elf32-i386.c (elf_i386_add_symbol_hook): Likewise.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf_x86_64_add_symbol_hook): Likewise.

	* ld-unique: New directory.
	* ld-unique/unique.exp: New file: Run the UNIQUE tests.
	* ld-unique/unique.s: New test file.
	* ld-unique/unique_empty.s: Likewise.
	* ld-unique/unique_shared.s: Likewise.
@
text
@d3964 1
a3964 1
	abort ();
@


1.219
log
@Update copyright year.

2011-04-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c: Update copyright year.
	* elf64-x86-64.c: Likewise.
@
text
@d4460 3
a4462 2
      && ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
    elf_tdata (info->output_bfd)->has_ifunc_symbols = TRUE;
@


1.218
log
@Revert the accidental checkin.
@
text
@d3 2
a4 1
   2010  Free Software Foundation, Inc.
@


1.217
log
@Return relocation error on unsupported relocation.

2011-04-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_relocate_section): Return relocation
	error on unsupported relocation.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
@
text
@d3904 1
a3904 1
		(_("%B(%A+0x%lx): reloc against `%s': error %r"),
@


1.216
log
@Support TLS x32 GD->IE, GD->LE and LD->LE transitions.

bfd/

2011-03-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_check_tls_transition): Supprt TLS
	x32 GD->IE and GD->LE transitions.
	(elf_x86_64_relocate_section): Supprt TLS x32 GD->IE, GD->LE
	and LD->LE transitions.

ld/testsuite/

2011-03-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/tlsgd4.dd: New.
	* ld-x86-64/tlsgd4.s: Likewise.
	* ld-x86-64/tlsgd5.dd: Likewise.
	* ld-x86-64/tlsgd5a.s: Likewise.
	* ld-x86-64/tlsgd5b.s: Likewise.
	* ld-x86-64/tlsgd6.dd: Likewise.
	* ld-x86-64/tlsgd6a.s: Likewise.
	* ld-x86-64/tlsgd6b.s: Likewise.
	* ld-x86-64/tlsld2.dd: Likewise.
	* ld-x86-64/tlsld2.s: Likewise.

	* ld-x86-64/x86-64.exp (x86_64tests): Add tlsgd4, libtlsgd5.so,
	tlsgd5, libtlsgd6.so, tlsgd6 and tlsld2.
@
text
@d3414 5
a3418 1
	      BFD_ASSERT (sreloc != NULL && sreloc->contents != NULL);
d3875 1
d3904 1
a3904 1
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
@


1.215
log
@2011-03-06  Michael Snyder  <msnyder@@vmware.com>

	* elf64-x86-64.c (elf_x86_64_relocate_section): Document
	that case statement falls through intentionally.
@
text
@d868 1
a868 1
	  /* Check transition from GD access model.  Only
d871 3
d876 2
a877 5
	  static x86_64_opcode32 leaq = { { 0x66, 0x48, 0x8d, 0x3d } },
				 call = { { 0x66, 0x66, 0x48, 0xe8 } };
	  if (offset < 4
	      || (offset + 12) > sec->size
	      || bfd_get_32 (abfd, contents + offset - 4) != leaq.i
d880 16
d3453 1
a3453 1
		  /* GD->LE transition.
d3456 1
a3456 1
		     Change it into:
d3458 6
d3465 8
a3472 3
		  memcpy (contents + roff - 4,
			  "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0",
			  16);
d3700 1
a3700 1
		  /* GD->IE transition.
d3703 1
a3703 1
		     Change it into:
d3705 6
d3712 8
a3719 3
		  memcpy (contents + roff - 4,
			  "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0",
			  16);
d3788 4
a3791 2
		 We change it into:
		 .word 0x6666; .byte 0x66; movl %fs:0, %rax.  */
d3794 6
a3799 2
	      memcpy (contents + rel->r_offset - 3,
		      "\x66\x66\x66\x64\x48\x8b\x04\x25\0\0\0", 12);
@


1.214
log
@2011-03-03  Michael Snyder  <msnyder@@vmware.com>

	* elf64-x86-64.c (elf_x86_64_relocate_section): Remove dead code.
@
text
@d2890 1
d2954 1
a2954 1

@


1.213
log
@Supprt TLS x32 IE->LE transition.

bfd/

2011-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_check_tls_transition): Supprt TLS
	x32 IE->LE transition.
	(elf_x86_64_relocate_section): Likewise.

ld/testsuite/

2011-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/tlsie4.dd: New.
	* ld-x86-64/tlsie4.s: Likewise.

	* ld-x86-64/x86-64.exp (x86_64tests): Add tlsie4.
@
text
@a3014 12
	      if (r_type != R_X86_64_GOTPCREL
		  && r_type != R_X86_64_GOTPCREL64)
		{
		  asection *gotplt;
		  if (htab->elf.splt != NULL)
		    gotplt = htab->elf.sgotplt;
		  else
		    gotplt = htab->elf.igotplt;
		  relocation -= (gotplt->output_section->vma
				 - gotplt->output_offset);
		}

@


1.212
log
@Revert the last change to elf64-x86-64.c.
@
text
@d916 2
a917 2
		movq foo@@gottpoff(%rip), %reg
		addq foo@@gottpoff(%rip), %reg
d920 19
a938 6
      if (offset < 3 || (offset + 4) > sec->size)
	return FALSE;

      val = bfd_get_8 (abfd, contents + offset - 3);
      if (val != 0x48 && val != 0x4c)
	return FALSE;
d3521 3
d3536 3
d3550 3
@


1.211
log
@Don't check relocation overflow for x32.

2011-02-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_check_relocs): Check relocation
	overflow only for ABI_64_P.
	(elf_x86_64_relocate_section): Likewise.
@
text
@a1500 1
	      && ABI_64_P (abfd)
a3150 1
	      && ABI_64_P (output_bfd)
@


1.210
log
@Don't undefine elf_backend_static_tls_alignment twice.
@
text
@d1501 1
d3152 1
@


1.209
log
@Undo Solaris damages in elf64-x86-64.c.

bfd/

2011-01-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_backend_static_tls_alignment): Undefine
	after Solaris target.
	(elf_backend_want_plt_sym): Redefine to 0 after Solaris target.

ld/testsuite/

2011-01-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/ilp32-4.d: Updated.
@
text
@a4721 3
/* Undo Solaris damages.  */
#undef elf_backend_static_tls_alignment

@


1.208
log
@Check invalid x32 relocations.

2011-01-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_check_relocs): Check invalid x32
	relocations.
@
text
@d4722 6
@


1.207
log
@Handle R_X86_64_32 like R_X86_64_64 for ILP32.

bfd/

2011-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_link_hash_table): Add pointer_r_type.
	(elf_x86_64_link_hash_table_create): Set pointer_r_type.
	(elf_x86_64_check_relocs): Handle R_X86_64_32 like R_X86_64_64
	for ILP32.  Remove ABI_64_P PIC check for R_X86_64_8,
	R_X86_64_16, R_X86_64_32 and R_X86_64_32S.
	(elf_x86_64_relocate_section):  Handle R_X86_64_32 like R_X86_64_64
	for ILP32.

ld/testsuite/

2011-01-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/ilp32-5.d: New.
	* ld-x86-64/ilp32-5.s: Likewise.

	* ld-x86-64/x86-64.exp: Run ilp32-5.
@
text
@d1182 33
@


1.206
log
@Fix x86-64 ILP32 shared library.

bfd/

2011-01-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_link_hash_table): Remove
	swap_reloca_out.
	(elf_x86_64_link_hash_table_create): Don't set swap_reloca_out.
	(elf_x86_64_check_relocs): Align relocation section to 4 byte
	for 32bit.
	(elf_x86_64_gc_sweep_hook): Replace ELF64_ST_TYPE with
	ELF_ST_TYPE.
	(elf_x86_64_finish_dynamic_symbol): Updated.
	(elf_x86_64_finish_dynamic_sections): Don't use
	Elf64_External_Dyn, bfd_elf64_swap_dyn_in, nor
	bfd_elf64_swap_dyn_out.

ld/testsuite/

2011-01-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/ilp32-4.d: New.

	* ld-x86-64/x86-64.exp: Run ilp32-4.
@
text
@d498 1
d662 1
d670 1
d1238 3
a1257 1
		case R_X86_64_32:
d1260 1
d1457 3
a1461 1
	case R_X86_64_32:
a1467 1
	      && ABI_64_P (abfd)
d1488 1
d2841 3
a2907 1
	    case R_X86_64_32:
d3320 1
a3320 1
		  if (r_type == R_X86_64_64)
@


1.205
log
@Handle STT_GNU_IFUNC symols when building shared library.

bfd/

2012-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12366
	PR ld/12371
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Properly
	handle symbols marked with regular reference, but not non-GOT
	reference when building shared library.

	* elf32-i386.c (elf_i386_gc_sweep_hook): Properly handle
	local and global STT_GNU_IFUNC symols when building shared
	library.
	* elf64-x86-64.c (elf_x86_64_gc_sweep_hook): Likewise.

ld/testsuite/

2012-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12366
	PR ld/12371
	* ld-ifunc/ifunc-10-i386.s: Add more tests.
	* ld-ifunc/ifunc-10-x86-64.s: Likewise.
	* ld-ifunc/ifunc-11-i386.s: Likewise.
	* ld-ifunc/ifunc-11-x86-64.s: Likewise.

	* ld-ifunc/ifunc-12-i386.d: New.
	* ld-ifunc/ifunc-12-i386.s: Likewise.
	* ld-ifunc/ifunc-12-x86-64.d: Likewise.
	* ld-ifunc/ifunc-12-x86-64.s: Likewise.
	* ld-ifunc/ifunc-13-i386.d: Likewise.
	* ld-ifunc/ifunc-13-x86-64.d: Likewise.
	* ld-ifunc/ifunc-13a-i386.s: Likewise.
	* ld-ifunc/ifunc-13a-x86-64.s: Likewise.
	* ld-ifunc/ifunc-13b-i386.s: Likewise.
	* ld-ifunc/ifunc-13b-x86-64.s: Likewise.
@
text
@a497 1
  void (*swap_reloca_out) (bfd *, const Elf_Internal_Rela *, bfd_byte *);
a660 1
      ret->swap_reloca_out = bfd_elf64_swap_reloca_out;
a667 1
      ret->swap_reloca_out = bfd_elf32_swap_reloca_out;
d1545 2
a1546 1
		    (sec, htab->elf.dynobj, 3, abfd, /*rela?*/ TRUE);
d1700 1
a1700 1
	      && ELF64_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
d3946 1
a3946 1
      htab->swap_reloca_out (output_bfd, &rela, loc);
d4117 3
a4119 1
      Elf64_External_Dyn *dyncon, *dynconend;
d4124 5
a4128 3
      dyncon = (Elf64_External_Dyn *) sdyn->contents;
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
d4133 1
a4133 1
	  bfd_elf64_swap_dyn_in (dynobj, dyncon, &dyn);
d4182 1
a4182 1
	  bfd_elf64_swap_dyn_out (output_bfd, &dyn, dyncon);
@


1.204
log
@Add elf_x86_64_relocs_compatible.

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf_x86_64_relocs_compatible): New.
	(elf_backend_relocs_compatible): Defined to
	elf_x86_64_relocs_compatible.
@
text
@a1686 4
	  struct elf_x86_64_link_hash_entry *eh;
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

a1690 9
	  eh = (struct elf_x86_64_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
d1710 17
d1778 2
a1779 1
	  if (info->shared)
@


1.203
log
@Add x86-64 ILP32 support.

bfd/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* archures.c (bfd_mach_x64_32): New.
	(bfd_mach_x64_32_intel_syntax): Likewise.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf32_x86_64_vec for
	i[3-7]86-*-linux-*.
	(targ_selvecs): Add bfd_elf32_x86_64_vec for x86_64-*-linux-*.

	* configure.in: Support bfd_elf32_x86_64_vec.
	* configure: Regenerated.

	* cpu-i386.c (bfd_x64_32_arch_intel_syntax): New.
	(bfd_x64_32_arch): Likewise.

	* elf-bfd.h (elf_append_rela): New prototype.
	(elf_append_rel): Likewise.
	(elf64_r_info): Likewise.
	(elf32_r_info): Likewise.
	(elf64_r_sym): Likewise.
	(elf32_r_sym): Likewise.

	* elf64-x86-64.c (ABI_64_P): New.
	(elf_x86_64_info_to_howto): Replace ELF64_R_TYPE with
	ELF32_R_TYPE.  Replace ELF64_ST_TYPE with ELF_ST_TYPE.
	(elf_x86_64_check_tls_transition):Likewise.
	(elf_x86_64_check_relocs): Likewise.
	(elf_x86_64_gc_mark_hook):Likewise.
	(elf_x86_64_gc_sweep_hook): Likewise.
	(elf_x86_64_relocate_section): Likewise.
	(elf_x86_64_reloc_type_class): Likewise.
	(ELF_DYNAMIC_INTERPRETER): Renamed to ...
	(ELF64_DYNAMIC_INTERPRETER): This.
	(ELF32_DYNAMIC_INTERPRETER): New.
	(elf_x86_64_link_hash_table): Add r_info, r_sym, swap_reloca_out,
	dynamic_interpreter and dynamic_interpreter_size.
	(elf_x86_64_get_local_sym_hash): Replace ELF64_R_SYM with
	htab->r_sym.  Replace ELF64_R_INFO with htab->r_info.
	(elf_x86_64_get_local_sym_hash): Likewise.
	(elf_x86_64_check_tls_transition):Likewise.
	(elf_x86_64_check_relocs): Likewise.
	(elf_x86_64_gc_mark_hook):Likewise.
	(elf_x86_64_gc_sweep_hook): Likewise.
	(elf_x86_64_relocate_section): Likewise.
	(elf_x86_64_finish_dynamic_symbol): Likewise.
	(elf_x86_64_finish_local_dynamic_symbol): Likewise.
	(elf_x86_64_link_hash_table_create): Initialize r_info, r_sym,
	swap_reloca_out, dynamic_interpreter and dynamic_interpreter_size.
	(elf_x86_64_check_relocs): Check ABI_64_P when requesting for
	PIC.
	(elf_x86_64_relocate_section): Likewise.
	(elf64_x86_64_adjust_dynamic_symbol): Replace sizeof
	(Elf64_External_Rela) with bed->s->sizeof_rela.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(elf64_x86_64_finish_dynamic_symbol): Likewise.
	(elf64_x86_64_append_rela): Removed.
	(elf32_x86_64_elf_object_p): New.
	Add bfd_elf32_x86_64_vec.

	* elf64-x86-64.c (elf64_x86_64_xxx): Renamed to ...
	(elf_x86_64_xxx): This.

	* elflink.c (bfd_elf_final_link): Check ELF file class on error.
	(elf_append_rela): New.
	(elf_append_rel): Likewise.
	(elf64_r_info): Likewise.
	(elf32_r_info): Likewise.
	(elf64_r_sym): Likewise.
	(elf32_r_sym): Likewise.

	* targets.c (bfd_elf32_x86_64_vec): New.
	(_bfd_target_vector): Add bfd_elf32_x86_64_vec.

gas/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (x86_elf_abi): New.
	(i386_mach): Return bfd_mach_x64_32 for ILP32.
	(OPTION_N32): Likewise.
	(md_longopts): Add "n32" for ELF.
	(md_parse_option): Handle OPTION_N32.
	(md_show_usage): Add --n32.
	(i386_target_format): Update and check x86_elf_abi.

	* config/tc-i386.h (ELF_TARGET_FORMAT32): New.

	* doc/as.texinfo: Document --n32.
	* doc/c-i386.texi: Likewise.

gas/testsuite/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/ilp32/lns/ilp32.exp: New.
	* gas/i386/ilp32/lns/lns-common-1.d: Likewise.
	* gas/i386/ilp32/lns/lns-duplicate.d: Likewise.

	* gas/i386/ilp32/cfi/cfi-common-1.d: New.
	* gas/i386/ilp32/cfi/cfi-common-2.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-3.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-4.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-5.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-6.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-common-7.d: Likewise.
	* gas/i386/ilp32/cfi/cfi-x86_64.d: Likewise.
	* gas/i386/ilp32/cfi/ilp32.exp: Likewise.
	* gas/i386/ilp32/elf/ehopt0.d: Likewise.
	* gas/i386/ilp32/elf/equ-reloc.d: Likewise.
	* gas/i386/ilp32/elf/file.d: Likewise.
	* gas/i386/ilp32/elf/group0a.d: Likewise.
	* gas/i386/ilp32/elf/group0b.d: Likewise.
	* gas/i386/ilp32/elf/group1a.d: Likewise.
	* gas/i386/ilp32/elf/group1b.d: Likewise.
	* gas/i386/ilp32/elf/ifunc-1.d: Likewise.
	* gas/i386/ilp32/elf/ilp32.exp: Likewise.
	* gas/i386/ilp32/elf/redef.d: Likewise.
	* gas/i386/ilp32/elf/section0.d: Likewise.
	* gas/i386/ilp32/elf/section1.d: Likewise.
	* gas/i386/ilp32/elf/section3.d: Likewise.
	* gas/i386/ilp32/elf/section4.d: Likewise.
	* gas/i386/ilp32/elf/section6.d: Likewise.
	* gas/i386/ilp32/elf/section7.d: Likewise.
	* gas/i386/ilp32/elf/struct.d: Likewise.
	* gas/i386/ilp32/elf/symtab.d: Likewise.
	* gas/i386/ilp32/elf/symver.d: Likewise.

	* gas/i386/ilp32/ilp32.exp: New.
	* gas/i386/ilp32/immed64.d: Likewise.
	* gas/i386/ilp32/mixed-mode-reloc64.d: Likewise.
	* gas/i386/ilp32/reloc64.d: Likewise.
	* gas/i386/ilp32/rex.d: Likewise.
	* gas/i386/ilp32/rexw.d: Likewise.
	* gas/i386/ilp32/svme64.d: Likewise.
	* gas/i386/ilp32/x86-64-addr32.d: Likewise.
	* gas/i386/ilp32/x86-64-addr32-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-aes.d: Likewise.
	* gas/i386/ilp32/x86-64-aes-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-amdfam10.d: Likewise.
	* gas/i386/ilp32/x86-64-arch-1.d: Likewise.
	* gas/i386/ilp32/x86-64-arch-2.d: Likewise.
	* gas/i386/ilp32/x86-64-avx.d: Likewise.
	* gas/i386/ilp32/x86-64-avx-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-avx-swap.d: Likewise.
	* gas/i386/ilp32/x86-64-avx-swap-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-branch.d: Likewise.
	* gas/i386/ilp32/x86-64-cbw.d: Likewise.
	* gas/i386/ilp32/x86-64-cbw-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-clmul.d: Likewise.
	* gas/i386/ilp32/x86-64-clmul-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-crc32.d: Likewise.
	* gas/i386/ilp32/x86-64-crc32-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-crx.d: Likewise.
	* gas/i386/ilp32/x86-64-crx-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64.d: Likewise.
	* gas/i386/ilp32/x86-64-disp.d: Likewise.
	* gas/i386/ilp32/x86-64-disp-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-drx.d: Likewise.
	* gas/i386/ilp32/x86-64-drx-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-ept.d: Likewise.
	* gas/i386/ilp32/x86-64-ept-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-fma4.d: Likewise.
	* gas/i386/ilp32/x86-64-fma.d: Likewise.
	* gas/i386/ilp32/x86-64-fma-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-gidt.d: Likewise.
	* gas/i386/ilp32/x86-64-ifunc.d: Likewise.
	* gas/i386/ilp32/x86-64-intel64.d: Likewise.
	* gas/i386/ilp32/x86-64-io.d: Likewise.
	* gas/i386/ilp32/x86-64-io-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-io-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-localpic.d: Likewise.
	* gas/i386/ilp32/x86-64-mem.d: Likewise.
	* gas/i386/ilp32/x86-64-mem-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-movbe.d: Likewise.
	* gas/i386/ilp32/x86-64-movbe-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-core2.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-k8.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-nocona.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-1-pentium.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-2.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-3.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-4-core2.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-4.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-4-k8.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-5.d: Likewise.
	* gas/i386/ilp32/x86-64-nops-5-k8.d: Likewise.
	* gas/i386/ilp32/x86-64-nops.d: Likewise.
	* gas/i386/ilp32/x86-64-opcode.d: Likewise.
	* gas/i386/ilp32/x86-64-opcode-inval.d: Likewise.
	* gas/i386/ilp32/x86-64-opcode-inval-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-opts.d: Likewise.
	* gas/i386/ilp32/x86-64-opts-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-pcrel.d: Likewise.
	* gas/i386/ilp32/x86-64-reg.d: Likewise.
	* gas/i386/ilp32/x86-64-reg-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-rep.d: Likewise.
	* gas/i386/ilp32/x86-64-rep-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-rip.d: Likewise.
	* gas/i386/ilp32/x86-64-rip-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sib.d: Likewise.
	* gas/i386/ilp32/x86-64-sib-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-simd.d: Likewise.
	* gas/i386/ilp32/x86-64-simd-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-simd-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-sse2avx.d: Likewise.
	* gas/i386/ilp32/x86-64-sse2avx-opts.d: Likewise.
	* gas/i386/ilp32/x86-64-sse2avx-opts-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sse3.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_1.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_1-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_2.d: Likewise.
	* gas/i386/ilp32/x86-64-sse4_2-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-check.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-check-none.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-check-warn.d: Likewise.
	* gas/i386/ilp32/x86-64-sse-noavx.d: Likewise.
	* gas/i386/ilp32/x86-64-ssse3.d: Likewise.
	* gas/i386/ilp32/x86-64-stack.d: Likewise.
	* gas/i386/ilp32/x86-64-stack-intel.d: Likewise.
	* gas/i386/ilp32/x86-64-stack-suffix.d: Likewise.
	* gas/i386/ilp32/x86-64-unwind.d: Likewise.
	* gas/i386/ilp32/x86-64-vmx.d: Likewise.
	* gas/i386/ilp32/x86-64-xsave.d: Likewise.
	* gas/i386/ilp32/x86-64-xsave-intel.d: Likewise.

ld/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/elf32_x86_64.sh: New.

	* configure.tgt (targ64_extra_emuls): Add elf32_x86_64 for
	i[3-7]86-*-linux-*.
	(targ_extra_libpath): Likewise.
	(targ_extra_emuls): Add elf32_x86_64 for x86_64-*-linux-*.
	(targ_extra_libpath): Likewise.

	* Makefile.am (ALL_64_EMULATION_SOURCES): Add eelf32_x86_64.c.
	(eelf32_x86_64.c): New.
	* Makefile.in: Regenerated.

opcodes/

2010-12-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (print_insn): Support bfd_mach_x64_32 and
	bfd_mach_x64_32_intel_syntax.
@
text
@d4499 11
d4550 1
a4550 1
#define elf_backend_relocs_compatible	    _bfd_elf_relocs_compatible
@


1.202
log
@	* elf-bfd.h (struct elf_backend_data): New member
	static_tls_alignment.
	* elfxx-target.h (elf_backend_static_tls_alignment): Provide
	default.
	(elfNN_bed): Initialize static_tls_alignment.
	* elflink.c (bfd_elf_final_link): Don't round end of TLS section
	if static TLS has special alignment requirements.
	* elf32-i386.c (elf_i386_tpoff): Define bed, static_tls_size.
	Consider static_tls_alignment.
	(elf_backend_static_tls_alignment): Redefine for Solaris 2.
	Undef again for VxWorks.
	* elf64-x86-64.c (elf64_x86_64_tpoff):  Define bed,
	static_tls_size.
	Consider static_tls_alignment.
	(elf_backend_static_tls_alignment): Redefine for Solaris 2.
	Undef again for Intel L1OM.
@
text
@d1 1
a1 1
/* X86-64 specific support for 64-bit ELF
d37 8
d233 1
a233 1
elf64_x86_64_rtype_to_howto (bfd *abfd, unsigned r_type)
d256 2
a257 2
elf64_x86_64_reloc_type_lookup (bfd *abfd,
				bfd_reloc_code_real_type code)
d265 2
a266 2
	return elf64_x86_64_rtype_to_howto (abfd,
					    x86_64_reloc_map[i].elf_reloc_val);
d272 2
a273 2
elf64_x86_64_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				const char *r_name)
d291 2
a292 2
elf64_x86_64_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			    Elf_Internal_Rela *dst)
d296 2
a297 2
  r_type = ELF64_R_TYPE (dst->r_info);
  cache_ptr->howto = elf64_x86_64_rtype_to_howto (abfd, r_type);
d303 1
a303 1
elf64_x86_64_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d335 1
a335 1
elf64_x86_64_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d371 2
a372 1
#define ELF_DYNAMIC_INTERPRETER "/lib/ld64.so.1"
d391 1
a391 1
static const bfd_byte elf64_x86_64_plt0_entry[PLT_ENTRY_SIZE] =
d400 1
a400 1
static const bfd_byte elf64_x86_64_plt_entry[PLT_ENTRY_SIZE] =
d412 1
a412 1
struct elf64_x86_64_link_hash_entry
d439 2
a440 2
#define elf64_x86_64_hash_entry(ent) \
  ((struct elf64_x86_64_link_hash_entry *)(ent))
d442 1
a442 1
struct elf64_x86_64_obj_tdata
d453 2
a454 2
#define elf64_x86_64_tdata(abfd) \
  ((struct elf64_x86_64_obj_tdata *) (abfd)->tdata.any)
d456 2
a457 2
#define elf64_x86_64_local_got_tls_type(abfd) \
  (elf64_x86_64_tdata (abfd)->local_got_tls_type)
d459 2
a460 2
#define elf64_x86_64_local_tlsdesc_gotent(abfd) \
  (elf64_x86_64_tdata (abfd)->local_tlsdesc_gotent)
d468 1
a468 1
elf64_x86_64_mkobject (bfd *abfd)
d470 1
a470 1
  return bfd_elf_allocate_object (abfd, sizeof (struct elf64_x86_64_obj_tdata),
d476 1
a476 1
struct elf64_x86_64_link_hash_table
d496 6
d521 1
a521 1
#define elf64_x86_64_hash_table(p) \
d523 1
a523 1
  == X86_64_ELF_DATA ? ((struct elf64_x86_64_link_hash_table *) ((p)->hash)) : NULL)
d525 1
a525 1
#define elf64_x86_64_compute_jump_table_size(htab) \
d531 3
a533 3
elf64_x86_64_link_hash_newfunc (struct bfd_hash_entry *entry,
				struct bfd_hash_table *table,
				const char *string)
d541 1
a541 1
                             sizeof (struct elf64_x86_64_link_hash_entry));
d550 1
a550 1
      struct elf64_x86_64_link_hash_entry *eh;
d552 1
a552 1
      eh = (struct elf64_x86_64_link_hash_entry *) entry;
d567 1
a567 1
elf64_x86_64_local_htab_hash (const void *ptr)
d577 1
a577 1
elf64_x86_64_local_htab_eq (const void *ptr1, const void *ptr2)
d590 3
a592 3
elf64_x86_64_get_local_sym_hash (struct elf64_x86_64_link_hash_table *htab,
				 bfd *abfd, const Elf_Internal_Rela *rel,
				 bfd_boolean create)
d594 1
a594 1
  struct elf64_x86_64_link_hash_entry e, *ret;
d597 1
a597 1
				       ELF64_R_SYM (rel->r_info));
d601 1
a601 1
  e.elf.dynstr_index = ELF64_R_SYM (rel->r_info);
d610 1
a610 1
      ret = (struct elf64_x86_64_link_hash_entry *) *slot;
d614 1
a614 1
  ret = (struct elf64_x86_64_link_hash_entry *)
d616 1
a616 1
			sizeof (struct elf64_x86_64_link_hash_entry));
d621 1
a621 1
      ret->elf.dynstr_index = ELF64_R_SYM (rel->r_info);
d631 1
a631 1
elf64_x86_64_link_hash_table_create (bfd *abfd)
d633 2
a634 2
  struct elf64_x86_64_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf64_x86_64_link_hash_table);
d636 1
a636 1
  ret = (struct elf64_x86_64_link_hash_table *) bfd_malloc (amt);
d641 2
a642 2
				      elf64_x86_64_link_hash_newfunc,
				      sizeof (struct elf64_x86_64_link_hash_entry),
d658 17
d676 2
a677 2
					 elf64_x86_64_local_htab_hash,
					 elf64_x86_64_local_htab_eq,
d692 1
a692 1
elf64_x86_64_link_hash_table_free (struct bfd_link_hash_table *hash)
d694 2
a695 2
  struct elf64_x86_64_link_hash_table *htab
    = (struct elf64_x86_64_link_hash_table *) hash;
d709 2
a710 1
elf64_x86_64_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
d712 1
a712 1
  struct elf64_x86_64_link_hash_table *htab;
d717 1
a717 1
  htab = elf64_x86_64_hash_table (info);
d735 3
a737 3
elf64_x86_64_copy_indirect_symbol (struct bfd_link_info *info,
				   struct elf_link_hash_entry *dir,
				   struct elf_link_hash_entry *ind)
d739 1
a739 1
  struct elf64_x86_64_link_hash_entry *edir, *eind;
d741 2
a742 2
  edir = (struct elf64_x86_64_link_hash_entry *) dir;
  eind = (struct elf64_x86_64_link_hash_entry *) ind;
d825 9
a833 7
elf64_x86_64_check_tls_transition (bfd *abfd, asection *sec,
				   bfd_byte *contents,
				   Elf_Internal_Shdr *symtab_hdr,
				   struct elf_link_hash_entry **sym_hashes,
				   unsigned int r_type,
				   const Elf_Internal_Rela *rel,
				   const Elf_Internal_Rela *relend)
d839 1
d857 1
d900 1
a900 1
      r_symndx = ELF64_R_SYM (rel[1].r_info);
d909 2
a910 2
	      && (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PC32
		  || ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32)
d977 9
a985 9
elf64_x86_64_tls_transition (struct bfd_link_info *info, bfd *abfd,
			     asection *sec, bfd_byte *contents,
			     Elf_Internal_Shdr *symtab_hdr,
			     struct elf_link_hash_entry **sym_hashes,
			     unsigned int *r_type, int tls_type,
			     const Elf_Internal_Rela *rel,
			     const Elf_Internal_Rela *relend,
			     struct elf_link_hash_entry *h,
			     unsigned long r_symndx)
d1011 1
a1011 1
      /* When we are called from elf64_x86_64_relocate_section,
d1033 1
a1033 1
	     elf64_x86_64_check_relocs.  We only want to check the new
d1056 3
a1058 3
      && ! elf64_x86_64_check_tls_transition (abfd, sec, contents,
					      symtab_hdr, sym_hashes,
					      from_type, rel, relend))
d1063 2
a1064 2
      from = elf64_x86_64_rtype_to_howto (abfd, from_type);
      to = elf64_x86_64_rtype_to_howto (abfd, to_type);
d1070 1
a1070 1
	  struct elf64_x86_64_link_hash_table *htab;
d1072 1
a1072 1
	  htab = elf64_x86_64_hash_table (info);
d1103 3
a1105 3
elf64_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info,
			   asection *sec,
			   const Elf_Internal_Rela *relocs)
d1107 1
a1107 1
  struct elf64_x86_64_link_hash_table *htab;
d1119 1
a1119 1
  htab = elf64_x86_64_hash_table (info);
d1137 2
a1138 2
      r_symndx = ELF64_R_SYM (rel->r_info);
      r_type = ELF64_R_TYPE (rel->r_info);
d1156 1
a1156 1
	  if (ELF64_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
d1158 2
a1159 2
	      h = elf64_x86_64_get_local_sym_hash (htab, abfd, rel,
						   TRUE);
d1248 1
a1248 1
			 &((struct elf64_x86_64_link_hash_entry *) h)->dyn_relocs);
d1281 4
a1284 4
      if (! elf64_x86_64_tls_transition (info, abfd, sec, NULL,
					 symtab_hdr, sym_hashes,
					 &r_type, GOT_UNKNOWN,
					 rel, rel_end, h, r_symndx))
d1294 1
a1294 1
	  if (!info->executable)
d1348 1
a1348 1
		old_tls_type = elf64_x86_64_hash_entry (h)->tls_type;
d1368 1
a1368 1
		    elf64_x86_64_local_tlsdesc_gotent (abfd)
d1370 1
a1370 1
		    elf64_x86_64_local_got_tls_type (abfd)
d1375 1
a1375 1
		  = elf64_x86_64_local_got_tls_type (abfd) [r_symndx];
d1406 1
a1406 1
		  elf64_x86_64_hash_entry (h)->tls_type = tls_type;
d1408 1
a1408 1
		  elf64_x86_64_local_got_tls_type (abfd) [r_symndx] = tls_type;
d1463 1
d1558 1
a1558 1
		  head = &((struct elf64_x86_64_link_hash_entry *) h)->dyn_relocs;
d1633 5
a1637 5
elf64_x86_64_gc_mark_hook (asection *sec,
			   struct bfd_link_info *info,
			   Elf_Internal_Rela *rel,
			   struct elf_link_hash_entry *h,
			   Elf_Internal_Sym *sym)
d1640 1
a1640 1
    switch (ELF64_R_TYPE (rel->r_info))
d1653 3
a1655 3
elf64_x86_64_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
			    asection *sec,
			    const Elf_Internal_Rela *relocs)
d1657 1
a1657 1
  struct elf64_x86_64_link_hash_table *htab;
d1666 1
a1666 1
  htab = elf64_x86_64_hash_table (info);
d1676 1
d1684 1
a1684 1
      r_symndx = ELF64_R_SYM (rel->r_info);
d1687 1
a1687 1
	  struct elf64_x86_64_link_hash_entry *eh;
d1695 1
a1695 1
	  eh = (struct elf64_x86_64_link_hash_entry *) h;
d1717 1
a1717 2
	      h = elf64_x86_64_get_local_sym_hash (htab, abfd, rel,
						   FALSE);
d1723 5
a1727 5
      r_type = ELF64_R_TYPE (rel->r_info);
      if (! elf64_x86_64_tls_transition (info, abfd, sec, NULL,
					 symtab_hdr, sym_hashes,
					 &r_type, GOT_UNKNOWN,
					 rel, relend, h, r_symndx))
d1802 2
a1803 2
elf64_x86_64_adjust_dynamic_symbol (struct bfd_link_info *info,
				    struct elf_link_hash_entry *h)
d1805 1
a1805 1
  struct elf64_x86_64_link_hash_table *htab;
d1887 1
a1887 1
      struct elf64_x86_64_link_hash_entry * eh;
d1890 1
a1890 1
      eh = (struct elf64_x86_64_link_hash_entry *) h;
d1924 1
a1924 1
  htab = elf64_x86_64_hash_table (info);
d1933 3
a1935 1
      htab->srelbss->size += sizeof (Elf64_External_Rela);
d1948 1
a1948 1
elf64_x86_64_allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d1951 2
a1952 2
  struct elf64_x86_64_link_hash_table *htab;
  struct elf64_x86_64_link_hash_entry *eh;
d1954 1
d1961 1
a1961 1
  eh = (struct elf64_x86_64_link_hash_entry *) h;
d1964 1
a1964 1
  htab = elf64_x86_64_hash_table (info);
d1967 1
d2021 1
a2021 1
	  htab->elf.srelplt->size += sizeof (Elf64_External_Rela);
d2043 1
a2043 1
      && elf64_x86_64_hash_entry (h)->tls_type == GOT_TLS_IE)
d2051 1
a2051 1
      int tls_type = elf64_x86_64_hash_entry (h)->tls_type;
d2065 1
a2065 1
	    - elf64_x86_64_compute_jump_table_size (htab);
d2084 1
a2084 1
	htab->elf.srelgot->size += sizeof (Elf64_External_Rela);
d2086 1
a2086 1
	htab->elf.srelgot->size += 2 * sizeof (Elf64_External_Rela);
d2092 1
a2092 1
	htab->elf.srelgot->size += sizeof (Elf64_External_Rela);
d2095 1
a2095 1
	  htab->elf.srelplt->size += sizeof (Elf64_External_Rela);
d2191 1
a2191 1
      sreloc->size += p->count * sizeof (Elf64_External_Rela);
d2201 1
a2201 1
elf64_x86_64_allocate_local_dynrelocs (void **slot, void *inf)
d2213 1
a2213 1
  return elf64_x86_64_allocate_dynrelocs (h, inf);
d2219 2
a2220 1
elf64_x86_64_readonly_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d2222 1
a2222 1
  struct elf64_x86_64_link_hash_entry *eh;
d2228 1
a2228 1
  eh = (struct elf64_x86_64_link_hash_entry *) h;
d2249 2
a2250 2
elf64_x86_64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info)
d2252 1
a2252 1
  struct elf64_x86_64_link_hash_table *htab;
d2257 1
d2259 1
a2259 1
  htab = elf64_x86_64_hash_table (info);
d2262 1
d2276 2
a2277 2
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
d2316 1
a2316 1
		  srel->size += p->count * sizeof (Elf64_External_Rela);
d2330 2
a2331 2
      local_tls_type = elf64_x86_64_local_got_tls_type (ibfd);
      local_tlsdesc_gotent = elf64_x86_64_local_tlsdesc_gotent (ibfd);
d2343 1
a2343 1
		    - elf64_x86_64_compute_jump_table_size (htab);
d2362 1
a2362 1
			+= sizeof (Elf64_External_Rela);
d2367 1
a2367 1
		    srel->size += sizeof (Elf64_External_Rela);
d2381 1
a2381 1
      htab->elf.srelgot->size += sizeof (Elf64_External_Rela);
d2388 1
a2388 1
  elf_link_hash_traverse (&htab->elf, elf64_x86_64_allocate_dynrelocs,
d2393 1
a2393 1
		 elf64_x86_64_allocate_local_dynrelocs,
d2403 1
a2403 1
      = elf64_x86_64_compute_jump_table_size (htab);
d2514 1
a2514 1
	 values later, in elf64_x86_64_finish_dynamic_sections, but we
d2545 1
a2545 1
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf64_External_Rela)))
d2552 1
a2552 1
				    elf64_x86_64_readonly_dynrelocs,
d2568 2
a2569 2
elf64_x86_64_always_size_sections (bfd *output_bfd,
				   struct bfd_link_info *info)
d2583 1
a2583 1
	  struct elf64_x86_64_link_hash_table *htab;
d2588 1
a2588 1
	  htab = elf64_x86_64_hash_table (info);
d2616 1
a2616 1
elf64_x86_64_set_tls_module_base (struct bfd_link_info *info)
d2618 1
a2618 1
  struct elf64_x86_64_link_hash_table *htab;
d2624 1
a2624 1
  htab = elf64_x86_64_hash_table (info);
d2640 1
a2640 1
elf64_x86_64_dtpoff_base (struct bfd_link_info *info)
d2652 1
a2652 1
elf64_x86_64_tpoff (struct bfd_link_info *info, bfd_vma address)
a2684 10
static void
elf64_x86_64_append_rela (bfd *abfd, asection *s, Elf_Internal_Rela *rel)
{
  bfd_byte *loc = s->contents;
  loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
  BFD_ASSERT (loc + sizeof (Elf64_External_Rela)
	      <= s->contents + s->size);
  bfd_elf64_swap_reloca_out (abfd, rel, loc);
}

d2688 8
a2695 5
elf64_x86_64_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			       bfd *input_bfd, asection *input_section,
			       bfd_byte *contents, Elf_Internal_Rela *relocs,
			       Elf_Internal_Sym *local_syms,
			       asection **local_sections)
d2697 1
a2697 1
  struct elf64_x86_64_link_hash_table *htab;
d2707 1
a2707 1
  htab = elf64_x86_64_hash_table (info);
d2713 1
a2713 1
  local_tlsdesc_gotents = elf64_x86_64_local_tlsdesc_gotent (input_bfd);
d2715 1
a2715 1
  elf64_x86_64_set_tls_module_base (info);
d2734 1
a2734 1
      r_type = ELF64_R_TYPE (rel->r_info);
d2746 1
a2746 1
      r_symndx = ELF64_R_SYM (rel->r_info);
d2761 1
a2761 1
	      && ELF64_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
d2763 2
a2764 2
	      h = elf64_x86_64_get_local_sym_hash (htab, input_bfd,
						   rel, FALSE);
d2872 1
a2872 1
		      outrel.r_info = ELF64_R_INFO (0, R_X86_64_IRELATIVE);
d2879 1
a2879 1
		      outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
d2884 1
a2884 1
		  elf64_x86_64_append_rela (output_bfd, sreloc, &outrel);
d3077 1
a3077 1
		      outrel.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
d3079 1
a3079 1
		      elf64_x86_64_append_rela (output_bfd, s, &outrel);
d3180 1
d3301 1
a3301 1
		  outrel.r_info = ELF64_R_INFO (h->dynindx, r_type);
d3310 1
a3310 1
		      outrel.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
d3343 1
a3343 1
		      outrel.r_info = ELF64_R_INFO (sindx, r_type);
d3352 1
a3352 1
	      elf64_x86_64_append_rela (output_bfd, sreloc, &outrel);
d3370 1
a3370 1
	    tls_type = elf64_x86_64_local_got_tls_type (input_bfd) [r_symndx];
d3372 1
a3372 1
	    tls_type = elf64_x86_64_hash_entry (h)->tls_type;
d3374 5
a3378 5
	  if (! elf64_x86_64_tls_transition (info, input_bfd,
					     input_section, contents,
					     symtab_hdr, sym_hashes,
					     &r_type, tls_type, rel,
					     relend, h, r_symndx))
d3387 1
a3387 1
	      if (ELF64_R_TYPE (rel->r_info) == R_X86_64_TLSGD)
d3399 1
a3399 1
			      elf64_x86_64_tpoff (info, relocation),
d3405 1
a3405 1
	      else if (ELF64_R_TYPE (rel->r_info) == R_X86_64_GOTPC32_TLSDESC)
d3424 1
a3424 1
			      elf64_x86_64_tpoff (info, relocation),
d3428 1
a3428 1
	      else if (ELF64_R_TYPE (rel->r_info) == R_X86_64_TLSDESC_CALL)
d3439 1
a3439 1
	      else if (ELF64_R_TYPE (rel->r_info) == R_X86_64_GOTTPOFF)
d3491 1
a3491 1
			      elf64_x86_64_tpoff (info, relocation),
d3505 1
a3505 1
	      offplt = elf64_x86_64_hash_entry (h)->tlsdesc_got;
d3531 1
a3531 1
		  outrel.r_info = ELF64_R_INFO (indx, R_X86_64_TLSDESC);
d3540 1
a3540 1
		    outrel.r_addend = relocation - elf64_x86_64_dtpoff_base (info);
d3543 1
a3543 1
		  elf64_x86_64_append_rela (output_bfd, sreloc, &outrel);
d3562 2
a3563 2
		outrel.r_addend = relocation - elf64_x86_64_dtpoff_base (info);
	      outrel.r_info = ELF64_R_INFO (indx, dr_type);
d3565 1
a3565 1
	      elf64_x86_64_append_rela (output_bfd, sreloc, &outrel);
d3573 1
a3573 1
				  relocation - elf64_x86_64_dtpoff_base (info),
d3580 1
a3580 1
		      outrel.r_info = ELF64_R_INFO (indx,
d3583 1
a3583 1
		      elf64_x86_64_append_rela (output_bfd, sreloc,
d3598 1
a3598 1
	  if (r_type == ELF64_R_TYPE (rel->r_info))
d3614 1
a3614 1
	      if (ELF64_R_TYPE (rel->r_info) == R_X86_64_TLSGD)
d3638 1
a3638 1
	      else if (ELF64_R_TYPE (rel->r_info) == R_X86_64_GOTPC32_TLSDESC)
d3663 1
a3663 1
	      else if (ELF64_R_TYPE (rel->r_info) == R_X86_64_TLSDESC_CALL)
d3682 5
a3686 5
	  if (! elf64_x86_64_tls_transition (info, input_bfd,
					     input_section, contents,
					     symtab_hdr, sym_hashes,
					     &r_type, GOT_UNKNOWN,
					     rel, relend, h, r_symndx))
d3724 1
a3724 1
	      outrel.r_info = ELF64_R_INFO (0, R_X86_64_DTPMOD64);
d3726 1
a3726 1
	      elf64_x86_64_append_rela (output_bfd, htab->elf.srelgot,
d3737 1
a3737 1
	    relocation -= elf64_x86_64_dtpoff_base (info);
d3739 1
a3739 1
	    relocation = elf64_x86_64_tpoff (info, relocation);
d3744 1
a3744 1
	  relocation = elf64_x86_64_tpoff (info, relocation);
d3813 4
a3816 4
elf64_x86_64_finish_dynamic_symbol (bfd *output_bfd,
				    struct bfd_link_info *info,
				    struct elf_link_hash_entry *h,
				    Elf_Internal_Sym *sym)
d3818 1
a3818 1
  struct elf64_x86_64_link_hash_table *htab;
d3820 1
a3820 1
  htab = elf64_x86_64_hash_table (info);
d3831 1
d3882 1
a3882 1
      memcpy (plt->contents + h->plt.offset, elf64_x86_64_plt_entry,
d3930 1
a3930 1
	  rela.r_info = ELF64_R_INFO (0, R_X86_64_IRELATIVE);
d3937 1
a3937 1
	  rela.r_info = ELF64_R_INFO (h->dynindx, R_X86_64_JUMP_SLOT);
d3940 4
a3943 2
      loc = relplt->contents + plt_index * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
d3962 2
a3963 2
      && ! GOT_TLS_GD_ANY_P (elf64_x86_64_hash_entry (h)->tls_type)
      && elf64_x86_64_hash_entry (h)->tls_type != GOT_TLS_IE)
d4013 1
a4013 1
	  rela.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
d4024 1
a4024 1
	  rela.r_info = ELF64_R_INFO (h->dynindx, R_X86_64_GLOB_DAT);
d4028 1
a4028 1
      elf64_x86_64_append_rela (output_bfd, htab->elf.srelgot, &rela);
d4046 1
a4046 1
      rela.r_info = ELF64_R_INFO (h->dynindx, R_X86_64_COPY);
d4048 1
a4048 1
      elf64_x86_64_append_rela (output_bfd, htab->srelbss, &rela);
d4065 1
a4065 1
elf64_x86_64_finish_local_dynamic_symbol (void **slot, void *inf)
d4072 1
a4072 1
  return elf64_x86_64_finish_dynamic_symbol (info->output_bfd,
d4080 1
a4080 1
elf64_x86_64_reloc_type_class (const Elf_Internal_Rela *rela)
d4082 1
a4082 1
  switch ((int) ELF64_R_TYPE (rela->r_info))
d4098 2
a4099 1
elf64_x86_64_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
d4101 1
a4101 1
  struct elf64_x86_64_link_hash_table *htab;
d4105 1
a4105 1
  htab = elf64_x86_64_hash_table (info);
d4182 1
a4182 1
	  memcpy (htab->elf.splt->contents, elf64_x86_64_plt0_entry,
d4214 1
a4214 1
		      elf64_x86_64_plt0_entry,
d4279 1
a4279 1
		 elf64_x86_64_finish_local_dynamic_symbol,
d4289 2
a4290 2
elf64_x86_64_plt_sym_val (bfd_vma i, const asection *plt,
			  const arelent *rel ATTRIBUTE_UNUSED)
d4299 1
a4299 1
elf64_x86_64_section_from_shdr (bfd *abfd,
d4318 7
a4324 7
elf64_x86_64_add_symbol_hook (bfd *abfd,
			      struct bfd_link_info *info,
			      Elf_Internal_Sym *sym,
			      const char **namep ATTRIBUTE_UNUSED,
			      flagword *flagsp ATTRIBUTE_UNUSED,
			      asection **secp,
			      bfd_vma *valp)
d4360 2
a4361 2
elf64_x86_64_elf_section_from_bfd_section (bfd *abfd ATTRIBUTE_UNUSED,
					   asection *sec, int *index_return)
d4374 2
a4375 2
elf64_x86_64_symbol_processing (bfd *abfd ATTRIBUTE_UNUSED,
				asymbol *asym)
d4391 1
a4391 1
elf64_x86_64_common_definition (Elf_Internal_Sym *sym)
d4398 1
a4398 1
elf64_x86_64_common_section_index (asection *sec)
d4407 1
a4407 1
elf64_x86_64_common_section (asection *sec)
d4416 23
a4438 23
elf64_x86_64_merge_symbol (struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   struct elf_link_hash_entry **sym_hash ATTRIBUTE_UNUSED,
			   struct elf_link_hash_entry *h,
			   Elf_Internal_Sym *sym,
			   asection **psec,
			   bfd_vma *pvalue ATTRIBUTE_UNUSED,
			   unsigned int *pold_alignment ATTRIBUTE_UNUSED,
			   bfd_boolean *skip ATTRIBUTE_UNUSED,
			   bfd_boolean *override ATTRIBUTE_UNUSED,
			   bfd_boolean *type_change_ok ATTRIBUTE_UNUSED,
			   bfd_boolean *size_change_ok ATTRIBUTE_UNUSED,
			   bfd_boolean *newdef ATTRIBUTE_UNUSED,
			   bfd_boolean *newdyn,
			   bfd_boolean *newdyncommon ATTRIBUTE_UNUSED,
			   bfd_boolean *newweak ATTRIBUTE_UNUSED,
			   bfd *abfd ATTRIBUTE_UNUSED,
			   asection **sec,
			   bfd_boolean *olddef ATTRIBUTE_UNUSED,
			   bfd_boolean *olddyn,
			   bfd_boolean *olddyncommon ATTRIBUTE_UNUSED,
			   bfd_boolean *oldweak ATTRIBUTE_UNUSED,
			   bfd *oldbfd,
			   asection **oldsec)
d4465 2
a4466 2
elf64_x86_64_additional_program_headers (bfd *abfd,
					 struct bfd_link_info *info ATTRIBUTE_UNUSED)
d4489 1
a4489 1
elf64_x86_64_hash_symbol (struct elf_link_hash_entry *h)
d4500 1
a4500 1
  elf64_x86_64_special_sections[]=
d4528 1
a4528 1
#define elf_info_to_howto		    elf64_x86_64_info_to_howto
d4531 1
a4531 1
  elf64_x86_64_link_hash_table_create
d4533 2
a4534 2
  elf64_x86_64_link_hash_table_free
#define bfd_elf64_bfd_reloc_type_lookup	    elf64_x86_64_reloc_type_lookup
d4536 1
a4536 1
  elf64_x86_64_reloc_name_lookup
d4538 1
a4538 1
#define elf_backend_adjust_dynamic_symbol   elf64_x86_64_adjust_dynamic_symbol
d4540 13
a4552 13
#define elf_backend_check_relocs	    elf64_x86_64_check_relocs
#define elf_backend_copy_indirect_symbol    elf64_x86_64_copy_indirect_symbol
#define elf_backend_create_dynamic_sections elf64_x86_64_create_dynamic_sections
#define elf_backend_finish_dynamic_sections elf64_x86_64_finish_dynamic_sections
#define elf_backend_finish_dynamic_symbol   elf64_x86_64_finish_dynamic_symbol
#define elf_backend_gc_mark_hook	    elf64_x86_64_gc_mark_hook
#define elf_backend_gc_sweep_hook	    elf64_x86_64_gc_sweep_hook
#define elf_backend_grok_prstatus	    elf64_x86_64_grok_prstatus
#define elf_backend_grok_psinfo		    elf64_x86_64_grok_psinfo
#define elf_backend_reloc_type_class	    elf64_x86_64_reloc_type_class
#define elf_backend_relocate_section	    elf64_x86_64_relocate_section
#define elf_backend_size_dynamic_sections   elf64_x86_64_size_dynamic_sections
#define elf_backend_always_size_sections    elf64_x86_64_always_size_sections
d4554 1
a4554 1
#define elf_backend_plt_sym_val		    elf64_x86_64_plt_sym_val
d4556 1
a4556 1
#define bfd_elf64_mkobject		    elf64_x86_64_mkobject
d4559 1
a4559 1
	elf64_x86_64_section_from_shdr
d4562 1
a4562 1
  elf64_x86_64_elf_section_from_bfd_section
d4564 1
a4564 1
  elf64_x86_64_add_symbol_hook
d4566 1
a4566 1
  elf64_x86_64_symbol_processing
d4568 1
a4568 1
  elf64_x86_64_common_section_index
d4570 1
a4570 1
  elf64_x86_64_common_section
d4572 1
a4572 1
  elf64_x86_64_common_definition
d4574 1
a4574 1
  elf64_x86_64_merge_symbol
d4576 1
a4576 1
  elf64_x86_64_special_sections
d4578 1
a4578 1
  elf64_x86_64_additional_program_headers
d4580 1
a4580 1
  elf64_x86_64_hash_symbol
d4680 50
@


1.202.2.1
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@d4306 2
a4307 3
      && (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC
	  || ELF_ST_BIND (sym->st_info) == STB_GNU_UNIQUE))
    elf_tdata (info->output_bfd)->has_gnu_symbols = TRUE;
@


1.202.2.2
log
@Handle STT_GNU_IFUNC symols when building shared library.

bfd/

2012-05-25  H.J. Lu  <hongjiu.lu@@intel.com>

	Backport from mainline
	2012-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12366
	PR ld/12371
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Properly
	handle symbols marked with regular reference, but not non-GOT
	reference when building shared library.

	* elf32-i386.c (elf_i386_gc_sweep_hook): Properly handle
	local and global STT_GNU_IFUNC symols when building shared
	library.
	* elf64-x86-64.c (elf_x86_64_gc_sweep_hook): Likewise.

ld/testsuite/

2012-05-25  H.J. Lu  <hongjiu.lu@@intel.com>

	Backport from mainline
	2012-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12366
	PR ld/12371
	* ld-ifunc/ifunc-10-i386.s: Add more tests.
	* ld-ifunc/ifunc-10-x86-64.s: Likewise.
	* ld-ifunc/ifunc-11-i386.s: Likewise.
	* ld-ifunc/ifunc-11-x86-64.s: Likewise.

	* ld-ifunc/ifunc-12-i386.d: New.
	* ld-ifunc/ifunc-12-i386.s: Likewise.
	* ld-ifunc/ifunc-12-x86-64.d: Likewise.
	* ld-ifunc/ifunc-12-x86-64.s: Likewise.
	* ld-ifunc/ifunc-13-i386.d: Likewise.
	* ld-ifunc/ifunc-13-x86-64.d: Likewise.
	* ld-ifunc/ifunc-13a-i386.s: Likewise.
	* ld-ifunc/ifunc-13a-x86-64.s: Likewise.
	* ld-ifunc/ifunc-13b-i386.s: Likewise.
	* ld-ifunc/ifunc-13b-x86-64.s: Likewise.
@
text
@d1648 4
d1656 9
d1685 1
a1685 18
      if (h)
	{
	  struct elf64_x86_64_link_hash_entry *eh;
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  eh = (struct elf64_x86_64_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF32_R_TYPE (rel->r_info);
d1736 1
a1736 2
	  if (info->shared
	      && (h == NULL || h->type != STT_GNU_IFUNC))
@


1.201
log
@Clear non_elf on ELF linker defined symbols.

2010-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11812
	* elf32-i386.c (elf_i386_size_dynamic_sections): Don't
	 allocate .got.plt section if there are no GOT nor PLT
	 entries and there is no refeence to _GLOBAL_OFFSET_TABLE_.
	 * elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Li.kewise.

	* elflink.c (_bfd_elf_define_linkage_sym): Clear non_elf.
@
text
@d2610 2
d2616 4
a2619 1
  return address - htab->tls_size - htab->tls_sec->vma;
d4573 5
d4616 1
@


1.200
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2381 5
d2387 5
a2391 3
         entries.  */
      if ((htab->elf.sgotplt->size
	   == get_elf_backend_data (output_bfd)->got_header_size)
@


1.199
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d4459 1
@


1.198
log
@Check if .got.plt section is discarded before using it.

bfd/

2010-08-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11913
	* elf32-i386.c (elf_i386_finish_dynamic_sections): Check if
	 .got.plt section is discarded.
	 * elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Likewise.

ld/testsuite/

2010-08-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11913
	* ld-i386/discarded1.d: New.
	* ld-i386/discarded1.s: Likewise.
	* ld-i386/discarded1.t: Likewise.
	* ld-x86-64/discarded1.d: Likewise.
	* ld-x86-64/discarded1.s: Likewise.
	* ld-x86-64/discarded1.t: Likewise.

	* ld-i386/i386.exp: Run discarded1.
	* ld-x86-64/x86-64.exp: Likewise.
@
text
@d311 1
a311 1
	elf_tdata (abfd)->core_pid
d335 2
@


1.197
log
@Don't allocate .got.plt section if there are no GOT nor PLT entries.

bfd/

2010-07-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11812
	* elf32-i386.c (elf_i386_size_dynamic_sections): Don't
	 allocate .got.plt section if there are no GOT nor PLT
	 entries.
	 * elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Likewise.

ld/testsuite/

2010-07-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11812
	* ld-elf/exclude3b.d: Don't run on ia64-*-*.  Replace .got with
	.dynamic.

	* ld-elf/exclude3d.d: New.
	* ld-i386/nogot1.d: Likewise.
	* ld-i386/nogot1.s: Likewise.
	* ld-x86-64/nogot1.d: Likewise.
	* ld-x86-64/nogot1.s: Likewise.

	* ld-i386/i386.exp: Run nogot1.
	* ld-x86-64/x86-64.exp: Likewise.
@
text
@d4189 7
@


1.196
log
@Support garbage collection against STT_GNU_IFUNC symbols.

bfd/

2010-07-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11791
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Support
	garbage collection against STT_GNU_IFUNC symbols.

	* elf32-i386.c (elf_i386_get_local_sym_hash): Don't set
	elf.plt.offset/elf.got.offset to -1.
	(elf_i386_tls_transition): Skip TLS transition for functions.
	(elf_i386_gc_sweep_hook): Support STT_GNU_IFUNC symbols.

	* elf64-x86-64.c (elf64_x86_64_get_local_sym_hash): Don't set
	elf.plt.offset/elf.got.offset to -1.
	(elf64_x86_64_tls_transition): Skip TLS transition for functions.
	(elf64_x86_64_gc_sweep_hook): Support STT_GNU_IFUNC symbols.

ld/testsuite/

2010-07-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11791
	* ld-ifunc/ifunc-10-i386.d: New.
	* ld-ifunc/ifunc-10-i386.s: Likewise.
	* ld-ifunc/ifunc-10-x86-64.d: Likewise.
	* ld-ifunc/ifunc-10-x86-64.s: Likewise.
	* ld-ifunc/ifunc-11-i386.d: Likewise.
	* ld-ifunc/ifunc-11-i386.s: Likewise.
	* ld-ifunc/ifunc-11-x86-64.d: Likewise.
	* ld-ifunc/ifunc-11-x86-64.s: Likewise.
@
text
@d2377 17
@


1.195
log
@Remove relocation against discarded sections for relocatable link.

bfd/

2010-04-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11542
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): New.

	* elf32-i386.c (elf_i386_relocate_section): Use it.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

ld/testsuite/

2010-04-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11542
	* ld-elf/discard.ld: New.
	* ld-elf/discard1.d: Likewise.
	* ld-elf/discard1.s: Likewise.
	* ld-elf/discard2.d: Likewise.
	* ld-elf/discard2.s: Likewise.
	* ld-elf/discard3.d: Likewise.
@
text
@a605 2
      ret->elf.plt.offset = (bfd_vma) -1;
      ret->elf.got.offset = (bfd_vma) -1;
d952 6
d1664 18
d1712 5
@


1.194
log
@        * archive64.c (bfd_elf64_archive_slurp_armap): Remove unused
        arhdrpos variable.
        * elf64-x86-64.c (elf64_x86_64_relocate_section): Add unused
        attribute to warned variable.  Remove unused val, type and type2
        variables.
@
text
@d2688 2
a2689 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.193
log
@	ld:
	* Makefile.am (ALL_EMULATIONS): Add eelf32_sparc_sol2.o,
	eelf_i386_sol2.o.
	(ALL_64_EMULATIONS): Add eelf_x86_64_sol2.o, eelf64_sparc_sol2.o.
	(eelf32_sparc_sol2.c): New rule.
	(eelf64_sparc_sol2.c): Likewise.
	(eelf_x86_64_sol2.c): Likewise.
	(eelf_i386_sol2.c): Likewise.
	* Makefile.in: Regenerate.
	* configure.tgt (i[3-7]86-*-solaris2*): Change targ_emul to
	elf_i386_sol2.
	Add elf_i386_ldso, elf_x86_64_sol2 to targ_extra_emuls.
	(x86_64-*-solaris2*): Change targ_emul to elf_x86_64_sol2.
	Add elf_x86_64, elf_i386_sol2, elf_i386 to targ_extra_emuls.
	(sparc-*-solaris2.[0-6]*): Change targ_emul to elf32_sparc_sol2.
	Add target_extra_emuls.
	(sparc-*-solaris2*): Change targ_emul to elf32_sparc_sol2.
	Add elf32_sparc, elf64_sparc_sol2 to targ_extra_emuls.
	(sparcv9-*-solaris2*): Change targ_emul to elf64_sparc_sol2.
	Add elf64_sparc, elf32_sparc_sol2 to target_extra_emuls.
	* emulparams/elf32_sparc_sol2.sh: New file.
	* emulparams/elf64_sparc_sol2.sh: New file.
	* emulparams/elf_i386_sol2.sh: New file.
	* emulparams/elf_x86_64_sol2.sh: New file.
	* emultempl/solaris2.em: New file.

	bfd:
	* elflink.c (bfd_elf_size_dynamic_sections): Don't emit base
	version twice.
	Skip it when constructing def.vd_next.

	* elf32-i386.c (TARGET_LITTLE_SYM): Redefine to
	bfd_elf32_i386_sol2_vec.
	(TARGET_LITTLE_NAME): Redefine to elf32-i386-sol2.
	(elf32_bed): Redefine to elf32_i386_sol2_bed.
	(elf_backend_want_plt_sym): Redefine to 1.

	* elf64-x86-64.c (TARGET_LITTLE_SYM): Redefine to
	bfd_elf64_x86_64_sol2_vec.
	(TARGET_LITTLE_NAME): Redefine to elf64-x86-64-sol2.
	(elf64_bed): Redefine to elf64_x86_64_sol2_bed.
	(elf_backend_want_plt_sym): Redefine to 1.

	* config.bfd (i[3-7]86-*-solaris2*): Set targ_defvec to
	bfd_elf32_i386_sol2_vec.
	Replace bfd_elf64_x86_64_vec by bfd_elf64_x86_64_sol2_vec in
	targ64_selvecs.
	(x86_64-*-solaris2*): Set targ_defvec to bfd_elf32_i386_sol2_vec.
	Replace bfd_elf64_x86_64_vec by bfd_elf64_x86_64_sol2_vec in
	targ_selvecs.

	* configure.in: Handle bfd_elf32_i386_sol2_vec,
	bfd_elf64_x86_64_sol2_vec.
	* configure: Regenerate.

	* targets.c (bfd_elf32_i386_sol2_vec): Declare.
	(bfd_elf64_x86_64_sol2_vec): Declare.
	(_bfd_target_vector): Add bfd_elf32_i386_sol2_vec,
	bfd_elf64_x86_64_sol2_vec.
@
text
@d2679 1
a2679 1
	  bfd_boolean warned;
d3322 1
a3322 2
		     movl $x@@tpoff, %rax
		   */
d3324 1
a3324 1
		  unsigned int val, type, type2;
a3326 1
		  type2 = bfd_get_8 (input_bfd, contents + roff - 2);
d3555 1
a3555 8
		     movq x@@gottpoff(%rip), %rax # before xchg %ax,%ax
		   */

		  unsigned int val, type, type2;

		  type = bfd_get_8 (input_bfd, contents + roff - 3);
		  type2 = bfd_get_8 (input_bfd, contents + roff - 2);
		  val = bfd_get_8 (input_bfd, contents + roff - 1);
d3580 1
a3580 3
		     xchg %ax,%ax.  */

		  unsigned int val, type;
a3581 2
		  type = bfd_get_8 (input_bfd, contents + roff);
		  val = bfd_get_8 (input_bfd, contents + roff + 1);
@


1.192
log
@Don't check STT_GNU_IFUNC on large common symbol.

2010-02-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): Don't check
	STT_GNU_IFUNC on large common symbol.
@
text
@d4513 23
@


1.191
log
@Don't set ELFOSABI_LINUX in dynamic ifunc-using executable.

bfd/

2010-02-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_add_symbol_hook): Don't set
	has_ifunc_symbols if the symbol comes from a shared library.
	* elf32-ppc.c (ppc_elf_add_symbol_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_add_symbol_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_add_symbol_hook): Likewise.
	* elf64-sparc.c (elf64_sparc_add_symbol_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): Likewise.

ld/testsuite/

2010-02-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-ifunc/ifunc.exp: Expect System V OSABI in dynamic
	ifunc-using executable.
@
text
@d4257 1
a4257 1
      break;
@


1.190
log
@Remove trailing white spaces.

2010-02-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c: Remove trailing white spaces.
	* elf64-x86-64.c: Likewise.
@
text
@d4260 2
a4261 1
  if (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
@


1.189
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d642 1
a642 1
  
d1119 1
a1119 1
	      
d1171 1
a1171 1
 
d3785 1
a3785 1
	 
@


1.188
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 2
a3 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
d454 1
a454 1
   && elf_object_id (bfd) == X86_64_ELF_TDATA)
d460 1
a460 1
				  X86_64_ELF_TDATA);
d473 2
a474 10
  /* The offset into splt of the PLT entry for the TLS descriptor
     resolver.  Special values are 0, if not necessary (or not found
     to be necessary yet), and -1 if needed but not determined
     yet.  */
  bfd_vma tlsdesc_plt;
  /* The offset into sgot of the GOT entry used by the PLT entry
     above.  */
  bfd_vma tlsdesc_got;

  union {
d490 10
a499 1
  void *loc_hash_memory;
d505 2
a506 1
  ((struct elf64_x86_64_link_hash_table *) ((p)->hash))
d627 2
a628 1
				      sizeof (struct elf64_x86_64_link_hash_entry)))
d642 1
a642 1

d685 3
a1026 1
	  Elf_Internal_Sym *isym;
d1028 1
d1030 10
a1039 3
	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					abfd, r_symndx);
	  name = bfd_elf_sym_name (abfd, symtab_hdr, isym, NULL);
d1077 3
d1613 1
d1622 4
d1671 2
a1672 2
	  if (elf64_x86_64_hash_table (info)->tls_ld_got.refcount > 0)
	    elf64_x86_64_hash_table (info)->tls_ld_got.refcount -= 1;
d1858 2
d1895 2
d2187 3
d2485 1
d2490 4
d2500 1
a2500 1
	  elf64_x86_64_hash_table (info)->tls_module_base = bh;
d2520 1
d2526 3
a2528 1
  base = elf64_x86_64_hash_table (info)->tls_module_base;
d2530 2
a2531 1
  if (!base)
d2534 1
a2534 1
  base->u.def.value = elf_hash_table (info)->tls_size;
d2612 2
d3744 2
d4025 3
@


1.187
log
@2009-09-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf64_x86_64_append_rela): New.
	(elf64_x86_64_relocate_section): Use it.
	(elf64_x86_64_finish_dynamic_symbol): Likewise.
@
text
@a1506 1
		  Elf_Internal_Sym *isym;
d4228 1
a4228 1
					   asection *sec, int *index)
d4232 1
a4232 1
      *index = SHN_X86_64_LCOMMON;
@


1.186
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d2546 10
a2724 1
		  bfd_byte *loc;
d2757 1
a2757 4
		  loc = sreloc->contents;
		  loc += (sreloc->reloc_count++
			  * sizeof (Elf64_External_Rela));
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
a2939 1
		      bfd_byte *loc;
d2952 1
a2952 3
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
a3140 1
	      bfd_byte *loc;
d3224 1
a3224 3
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
a3394 1
	      bfd_byte *loc;
a3412 5
		  loc = sreloc->contents;
		  loc += sreloc->reloc_count++
		    * sizeof (Elf64_External_Rela);
		  BFD_ASSERT (loc + sizeof (Elf64_External_Rela)
			      <= sreloc->contents + sreloc->size);
d3417 1
a3417 1
		  bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d3439 1
a3439 5
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
	      BFD_ASSERT (loc + sizeof (Elf64_External_Rela)
			  <= sreloc->contents + sreloc->size);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d3457 2
a3458 5
		      sreloc->reloc_count++;
		      loc += sizeof (Elf64_External_Rela);
		      BFD_ASSERT (loc + sizeof (Elf64_External_Rela)
				  <= sreloc->contents + sreloc->size);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
a3597 1
	      bfd_byte *loc;
d3611 2
a3612 3
	      loc = htab->elf.srelgot->contents;
	      loc += htab->elf.srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
a3845 1
      bfd_byte *loc;
d3908 1
a3908 3
      loc = htab->elf.srelgot->contents;
      loc += htab->elf.srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
a3913 1
      bfd_byte *loc;
d3928 1
a3928 3
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf64_External_Rela);
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
@


1.185
log
@update copyright dates
@
text
@d520 3
a522 2
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf64_x86_64_link_hash_entry));
@


1.185.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d520 2
a521 3
      entry = (struct bfd_hash_entry *)
          bfd_hash_allocate (table,
                             sizeof (struct elf64_x86_64_link_hash_entry));
@


1.184
log
@2009-09-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Declare
	plt earlier.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.183
log
@2009-08-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Revert the
	accidental checkin.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likwise.
@
text
@d3886 2
d3894 1
a3894 1
	      asection *plt = htab->elf.splt ? htab->elf.splt : htab->elf.iplt;
@


1.182
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@a3718 17
  /* PR 10433: STT_GNU_IFUNC symbols must go through the PLT
     only when they are referenced, not when they are defined.  */
  if (h->type == STT_GNU_IFUNC
      && h->def_regular
      && ! h->ref_regular
      && ! info->relocatable)
    {
      if (! ((h->dynindx != -1
	      || h->forced_local)
	     && ((info->shared
		  && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		      || h->root.type != bfd_link_hash_undefweak))
		 || ! h->forced_local)
	     && elf_hash_table (info)->dynamic_sections_created))
	return TRUE;
    }

@


1.181
log
@2009-08-02  H.J. Lu  <hongjiu.lu@@intel.com>
	    Jakub Jelinek  <jakub@@redhat.com>

	PR ld/6443
	* elf32-i386.c (elf_i386_tls_transition): Check executable
	instead of shared for TLS when building PIE.
	(elf_i386_check_relocs): Likewise.
	(elf_i386_allocate_dynrelocs): Likewise.
	(elf_i386_relocate_section): Likewise.

	* elf64-x86-64.c (elf64_x86_64_tls_transition): Check executable
	instead of shared for TLS when building PIE.
	(elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_relocate_section): Likewise.

ld/testsuite/

2009-08-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/6443
	* ld-i386/i386.exp: Run tlspie1.
	* ld-x86-64/x86-64.exp: tlspie1.

	* ld-i386/tlspie1.d: New.
	* ld-i386/tlspie1.s: Likewise.
	* ld-x86-64/tlspie1.d: Likewise.
	* ld-x86-64/tlspie1.s: Likewise.
@
text
@d3719 17
@


1.180
log
@bfd/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* archures.c (bfd_architecture): Add bfd_arch_l1om.
	(bfd_l1om_arch): New.
	(bfd_archures_list): Add &bfd_l1om_arch.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf64_l1om_vec if
	bfd_elf64_x86_64_vec is supported.  Add bfd_elf64_l1om_freebsd_vec
	if bfd_elf64_x86_64_freebsd_vec is supported.
	(targ_selvecs): Likewise.

	* configure.in: Support bfd_elf64_l1om_vec and
	bfd_elf64_l1om_freebsd_vec.
	* configure: Regenerated.

	* cpu-l1om.c: New.

	* elf64-x86-64.c (elf64_l1om_elf_object_p): New.
	(bfd_elf64_l1om_vec): Likewise.
	(bfd_elf64_l1om_freebsd_vec): Likewise.

	* Makefile.am (ALL_MACHINES): Add cpu-l1om.lo.
	(ALL_MACHINES_CFILES): Add cpu-l1om.c.
	* Makefile.in: Regenerated.

	* targets.c (bfd_elf64_l1om_vec): New.
	(bfd_elf64_l1om_freebsd_vec): Likewise.
	(_bfd_target_vector): Add bfd_elf64_l1om_vec and
	bfd_elf64_l1om_freebsd_vec.

binutils/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (guess_is_rela): Handle EM_L1OM.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(get_section_type_name): Likewise.
	(get_elf_section_flags): Likewise.
	(get_symbol_index_type): Likewise.
	(is_32bit_abs_reloc): Likewise.
	(is_32bit_pcrel_reloc): Likewise.
	(is_64bit_abs_reloc): Likewise.
	(is_64bit_pcrel_reloc): Likewise.
	(is_none_reloc): Likewise.

gas/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add l1om.
	(check_cpu_arch_compatible): New.
	(set_cpu_arch): Use it.
	(i386_arch): New.
	(i386_mach): Return bfd_mach_l1om for Intel L1OM.
	(md_show_usage): Display l1om.
	(i386_target_format): Return ELF_TARGET_L1OM_FORMAT if
	cpu_arch_isa_flags.bitfield.cpul1om is set.

	* config/tc-i386.h (TARGET_ARCH): Use (i386_arch ()).
	(i386_arch): New.
	(ELF_TARGET_L1OM_FORMAT): Likewise.

	* doc/c-i386.texi: Document l1om.

gas/testsuite/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/l1om.d: New.
	* gas/i386/l1om-inval.l: Likewise.
	* gas/i386/l1om-inval.s: Likewise.

	* gas/i386/i386.exp: Run l1om-inval and l1om.

include/elf/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (EM_L1OM): New.

ld/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.tgt (targ64_extra_emuls): Add elf_l1om if elf_x86_64
	is supported.  Add elf_l1om_fbsd if elf_x86_64_fbsd is supported.
	(targ_extra_emuls): Likewise.

	* Makefile.am (ALL_64_EMULATIONS): Add eelf_l1om.o and
	eelf_l1om_fbsd.o
	(eelf_l1om.c): New.
	(eelf_l1om_fbsd.c): Likewise.
	* Makefile.in: Regenerated.

	* emulparams/elf_l1om.sh: New.
	* emulparams/elf_l1om_fbsd.sh: Likewise.

ld/testsuite/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/abs-l1om.d: New.
	* ld-x86-64/protected2-l1om.d: Likewise.
	* ld-x86-64/protected3-l1om.d: Likewise.

	* ld-x86-64/x86-64.exp: Run abs-l1om, protected2-l1om and
	protected3-l1om.

opcodes/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in: Handle bfd_l1om_arch.
	* disassemble.c (disassembler): Likewise.

	* configure: Regenerated.

	* i386-dis.c (print_insn): Handle bfd_mach_l1om and
	bfd_mach_l1om_intel_syntax.  Use 8 bytes per line for Intel L1OM.

	* i386-gen.c (cpu_flag_init): Set CPU_UNKNOWN_FLAGS to ~CpuL1OM.
	Add CPU_L1OM_FLAGS.
	(cpu_flags): Add CpuL1OM.
	(set_bitfield): Take an argument to set the value field.
	(process_i386_cpu_flag): Support ~CpuXXX and ~(CpuXXX|CpuYYY).
	(process_i386_opcode_modifier): Updated.
	(process_i386_operand_type): Likewise.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.

	* i386-opc.h (CpuL1OM): New.
	(CpuXsave): Updated.
	(i386_cpu_flags): Add cpul1om.
@
text
@d953 1
a953 1
      if (!info->shared)
d968 1
a968 1
	  if (!info->shared
d992 1
a992 1
      if (!info->shared)
d1251 1
a1251 1
	  if (info->shared)
d1945 1
a1945 1
      && !info->shared
d3635 1
a3635 1
	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
@


1.179
log
@bfd/

2009-07-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10434
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Check executable
	instead of shared for R_X86_64_TPOFF32.
	(elf64_x86_64_relocate_section): Likewise.

ld/testsuite/

2009-07-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10434
	* ld-x86-64/tlsle1.d: New.
	* ld-x86-64/tlsle1.s: Likewise.

	* ld-x86-64/x86-64.exp: Run tlsle1.
@
text
@d4486 50
@


1.178
log
@bfd/

2009-07-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_relocate_section): Don't get local
	STT_GNU_IFUNC symbol for relocatable link.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

ld/testsuite/

2009-07-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-ifunc/ifunc-5r-local-i386.d: New.
	* ld-ifunc/ifunc-5r-local-x86-64.d: Likewise.
@
text
@d1234 1
a1234 1
	  if (info->shared)
d3642 1
a3642 1
	  BFD_ASSERT (! info->shared);
@


1.177
log
@	* elf-bfd.h (struct elf_link_hash_entry): Clarify ref_regular
	and ref_regular_nonweak comment.
	* elflink.c (elf_link_output_extsym): Special case ifunc syms
	when def_regular, not ref_regular.
	(elf_link_add_object_symbols): Don't set needs_plt on ifunc syms,..
	* elf32-i386.c (elf_i386_check_relocs): ..set it here instead..
	* elf64-x86-64.c (elf64_x86_64_check_relocs): ..and here.
@
text
@d2615 2
a2616 1
	  if (ELF64_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
@


1.176
log
@2009-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_check_relocs): Properly check local
	symbol on error.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
@
text
@d1153 1
@


1.175
log
@bfd/

2009-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_tls_transition): Add a parameter,
	r_symndx.  Report local symbol name on error.
	(elf_i386_check_relocs): Updated.  Report local symbol name on
	error.
	(elf_i386_gc_sweep_hook): Updated.
	(elf_i386_relocate_section): Likewise.

	* elf64-x86-64.c (elf64_x86_64_tls_transition): Add a parameter,
	r_symndx.  Report local symbol name on error.
	(elf64_x86_64_check_relocs): Updated.  Report local symbol name
	on error.
	(elf64_x86_64_gc_sweep_hook): Updated.
	(elf64_x86_64_relocate_section): Likewise.

ld/testsuite/

2009-06-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-i386/i386.exp: Run tlsgd2.

	* ld-i386/tlsgd2.d: New.
	* ld-i386/tlsgd2.s: Likewise.

	* ld-x86-64/tlsgd3.d: Updated.
@
text
@d1235 1
a1235 1
	      if (h->root.root.string)
d1330 1
a1330 1
		    if (h->root.root.string)
d1405 1
a1405 1
	      if (h->root.root.string)
@


1.174
log
@2009-06-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_check_relocs): Remove isymbuf and use
	bfd_sym_from_r_symndx.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
@
text
@d940 2
a941 1
			     struct elf_link_hash_entry *h)
d1011 1
d1016 12
d1031 1
a1031 2
	 abfd, sec, from->name, to->name,
	 h ? h->root.root.string : "a local symbol",
d1074 2
a1089 2
	  Elf_Internal_Sym *isym;

d1115 1
d1164 5
d1173 1
a1173 3
		     (h->root.root.string
		      ? h->root.root.string : "a local symbol"),
		     __FUNCTION__);
d1223 1
a1223 1
					 rel, rel_end, h))
d1235 5
d1243 1
a1243 2
		 x86_64_elf_howto_table[r_type].name,
		 (h) ? h->root.root.string : "a local symbol");
d1330 5
d1337 1
a1337 1
		       abfd, h ? h->root.root.string : "<local>");
d1405 4
d1411 1
a1411 3
		 abfd,
		 x86_64_elf_howto_table[r_type].name,
		 (h) ? h->root.root.string : "a local symbol");
d1643 1
a1643 1
					 rel, relend, h))
d2658 1
d2672 5
d2681 1
a2681 3
		 (h->root.root.string
		  ? h->root.root.string : "a local symbol"),
		 __FUNCTION__);
d2693 5
d2702 1
a2702 3
		     (h->root.root.string
		      ? h->root.root.string : "a local symbol"),
		     rel->r_addend);
d3247 1
a3247 1
					     relend, h))
d3581 1
a3581 1
					     rel, relend, h))
@


1.173
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@a1042 1
  Elf_Internal_Sym *isymbuf;
a1050 1
  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
d1077 4
a1080 10
	  /* Read this BFD's local symbols.  */
	  if (isymbuf == NULL)
	    {
	      if (isymbuf == NULL)
		isymbuf = bfd_elf_get_elf_syms (abfd, symtab_hdr,
						symtab_hdr->sh_info, 0,
						NULL, NULL, NULL);
	      if (isymbuf == NULL)
		  return FALSE;
	    }
a1082 1
	  isym = isymbuf + r_symndx;
d1088 1
a1088 1
		goto error_return;
d1128 1
a1128 1
		goto error_return;
d1158 1
a1158 1
		  goto error_return;
d1172 1
a1172 1
			goto error_return;
d1195 1
a1195 1
		    goto error_return;
d1207 1
a1207 1
	goto error_return;
d1224 1
a1224 1
	      goto error_return;
d1284 1
a1284 1
		      goto error_return;
d1312 1
a1312 1
		    goto error_return;
d1336 1
a1336 1
		goto error_return;
d1385 1
a1385 1
	      goto error_return;
d1461 1
a1461 1
		    goto error_return;
d1502 1
a1502 1
		    goto error_return;
d1520 1
a1520 1
	    goto error_return;
d1529 1
a1529 1
	    goto error_return;
a1536 12
   if (isymbuf != NULL
       && (unsigned char *) isymbuf != symtab_hdr->contents)
    {
      if (!info->keep_memory)
	free (isymbuf);
      else
	{
	  /* Cache the symbols for elf_link_input_bfd.  */
	  symtab_hdr->contents = (unsigned char *) isymbuf;
	}
    }

a1537 6

error_return:
   if (isymbuf != NULL
       && (unsigned char *) isymbuf != symtab_hdr->contents)
     free (isymbuf);
   return FALSE;
@


1.172
log
@2009-06-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_check_relocs): Cache or free isymbuf.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
@
text
@d490 2
a491 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d632 1
a632 1
  ret->sym_sec.abfd = NULL;
a1480 1
		  void **vpp;
d1484 3
d1488 6
a1493 3
		  asection *s;
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
d1495 1
a1495 1
		    goto error_return;
@


1.171
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_allocate_ifunc_dyn_relocs): New.
	* elf-ifunc.c (_bfd_elf_allocate_ifunc_dyn_relocs): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs): Use it.
	* elf64-x86-64.c (elf64_x86_64_allocate_dynrelocs): Likewise.

2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_create_ifunc_dyn_reloc): New.
	* elf-ifunc.c (_bfd_elf_create_ifunc_dyn_reloc): Likewise.
	* elf32-i386.c (elf_i386_check_relocs): Use it.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.

2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_dyn_relocs): New.

	* elf32-i386.c (elf_i386_dyn_relocs): Removed.
	(elf_i386_link_hash_entry): Replace elf_i386_dyn_relocs with
	elf_dyn_relocs.
	(elf_i386_copy_indirect_symbol): Likewise.
	(elf_i386_check_relocs): Likewise.
	(elf_i386_gc_sweep_hook): Likewise.
	(elf_i386_allocate_dynrelocs): Likewise.
	(elf_i386_readonly_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.

	* elf64-x86-64.c (elf64_x86_64_dyn_relocs): Removed.
	(elf64_x86_64_link_hash_entry): Replace elf64_x86_64_dyn_relocs
	with elf_dyn_relocs.
	(elf64_x86_64_copy_indirect_symbol): Updated.
	(elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_gc_sweep_hook): Likewise.
	(elf64_x86_64_adjust_dynamic_symbol): Likewise.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_readonly_dynrelocs): Likewise.
	(elf64_x86_64_size_dynamic_sections): Likewise.
@
text
@d1097 1
a1097 1
		return FALSE;
d1137 1
a1137 1
		return FALSE;
d1167 1
a1167 1
		  return FALSE;
d1181 1
a1181 1
			return FALSE;
d1204 1
a1204 1
		    return FALSE;
d1216 1
a1216 1
	return FALSE;
d1233 1
a1233 1
	      return FALSE;
d1293 1
a1293 1
		      return FALSE;
d1321 1
a1321 1
		    return FALSE;
d1345 1
a1345 1
		return FALSE;
d1394 1
a1394 1
	      return FALSE;
d1470 1
a1470 1
		    return FALSE;
d1490 1
a1490 1
		    return FALSE;
d1506 1
a1506 1
		    return FALSE;
d1524 1
a1524 1
	    return FALSE;
d1533 1
a1533 1
	    return FALSE;
d1541 12
d1554 6
@


1.170
log
@2009-06-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (ELF_LOCAL_SYMBOL_HASH): New.

	* elf32-i386.c (elf_i386_local_hash): Removed.
	(elf_i386_local_htab_hash): Use ELF_LOCAL_SYMBOL_HASH.
	(elf_i386_get_local_sym_hash): Likewise.

	* elf64-x86-64.c (elf64_x86_64_local_hash): Removed.
	(elf64_x86_64_local_htab_hash): Use ELF_LOCAL_SYMBOL_HASH.
	(elf64_x86_64_get_local_sym_hash): Likewise.
	* elfxx-ia64.c (elfNN_ia64_local_htab_hash): Likewise.
	(get_local_sym_hash): Likewise.
@
text
@a398 21
/* The x86-64 linker needs to keep track of the number of relocs that
   it decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct elf64_x86_64_dyn_relocs
{
  /* Next section.  */
  struct elf64_x86_64_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};

d406 1
a406 1
  struct elf64_x86_64_dyn_relocs *dyn_relocs;
d708 2
a709 2
	  struct elf64_x86_64_dyn_relocs **pp;
	  struct elf64_x86_64_dyn_relocs *p;
d715 1
a715 1
	      struct elf64_x86_64_dyn_relocs *q;
a1173 3
		      struct elf64_x86_64_dyn_relocs *p;
		      struct elf64_x86_64_dyn_relocs **head;

d1177 3
d1181 1
a1181 28
			{
			  if (htab->elf.dynobj == NULL)
			    htab->elf.dynobj = abfd;

			  sreloc = _bfd_elf_make_dynamic_reloc_section
			    (sec, htab->elf.dynobj, 3, abfd, TRUE);

			  if (sreloc == NULL)
			    return FALSE;
			}
		      
		      head = &((struct elf64_x86_64_link_hash_entry *) h)->dyn_relocs;
		      p = *head;
		      if (p == NULL || p->sec != sec)
			{
			  bfd_size_type amt = sizeof *p;

			  p = ((struct elf64_x86_64_dyn_relocs *)
			       bfd_alloc (htab->elf.dynobj, amt));
			  if (p == NULL)
			    return FALSE;
			  p->next = *head;
			  *head = p;
			  p->sec = sec;
			  p->count = 0;
			  p->pc_count = 0;
			}
		      p->count += 1;
d1455 2
a1456 2
	      struct elf64_x86_64_dyn_relocs *p;
	      struct elf64_x86_64_dyn_relocs **head;
d1495 1
a1495 1
		  head = (struct elf64_x86_64_dyn_relocs **)vpp;
d1503 1
a1503 1
		  p = ((struct elf64_x86_64_dyn_relocs *)
d1597 2
a1598 2
	  struct elf64_x86_64_dyn_relocs **pp;
	  struct elf64_x86_64_dyn_relocs *p;
d1775 1
a1775 1
      struct elf64_x86_64_dyn_relocs *p;
d1836 1
a1836 1
  struct elf64_x86_64_dyn_relocs *p;
d1852 4
a1855 118
    {
      asection *plt, *gotplt, *relplt;

      /* When a shared library references a STT_GNU_IFUNC symbol
	 defined in executable, the address of the resolved function
	 may be used.  But in non-shared executable, the address of
	 its .plt slot may be used.  Pointer equality may not work
	 correctly.  PIE should be used if pointer equality is
	 required here.  */
      if (!info->shared
	  && (h->dynindx != -1
	      || info->export_dynamic)
	  && h->pointer_equality_needed)
	{
	  info->callbacks->einfo 
	    (_("%F%P: dynamic STT_GNU_IFUNC symbol `%s' with pointer "
	       "equality in `%B' can not be used when making an "
	       "executable; recompile with -fPIE and relink with -pie\n"),
	     h->root.root.string,
	     h->root.u.def.section->owner);
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      /* Return and discard space for dynamic relocations against it if
	 it is never referenced in a non-shared object.  */
      if (!h->ref_regular)
	{
	  if (h->plt.refcount > 0
	      || h->got.refcount > 0)
	    abort ();
	  h->got.offset = (bfd_vma) -1;
	  eh->dyn_relocs = NULL;
	  return TRUE;
	}

      /* When building a static executable, use .iplt, .igot.plt and
	 .rela.iplt sections for STT_GNU_IFUNC symbols.  */
      if (htab->elf.splt != NULL)
	{
	  plt = htab->elf.splt;
	  gotplt = htab->elf.sgotplt;
	  relplt = htab->elf.srelplt;
	  
	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (plt->size == 0)
	    plt->size += PLT_ENTRY_SIZE;
	}
      else
	{
	  plt = htab->elf.iplt;
	  gotplt = htab->elf.igotplt;
	  relplt = htab->elf.irelplt;
	}

      /* Don't update value of STT_GNU_IFUNC symbol to PLT.  We need
	 the original value for R_X86_64_IRELATIVE.  */  
      h->plt.offset = plt->size;

      /* Make room for this entry in the .plt/.iplt section.  */
      plt->size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .got.plt/.got.iplt
	 section, which will be placed in the .got section by the
	 linker script.  */
      gotplt->size += GOT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt/.rela.iplt
	 section.  */
      relplt->size += sizeof (Elf64_External_Rela);
      relplt->reloc_count++;

      /* We need dynamic relocation for STT_GNU_IFUNC symbol only
	 when there is a non-GOT reference in a shared object.  */
      if (!info->shared
	  || !h->non_got_ref)
	eh->dyn_relocs = NULL;

      /* Finally, allocate space.  */
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	htab->elf.irelifunc->size
	  += p->count * sizeof (Elf64_External_Rela);

      /* For STT_GNU_IFUNC symbol, .got.plt has the real function
	 addres and .got has the PLT entry adddress.  We will load
	 the GOT entry with the PLT entry in finish_dynamic_symbol if
	 it is used.  For branch, it uses .got.plt.  For symbol value,
	 1. Use .got.plt in a shared object if it is forced local or
	 not dynamic.
	 2. Use .got.plt in a non-shared object if pointer equality 
	 isn't needed.
	 3. Use .got.plt in PIE.
	 4. Use .got.plt if .got isn't used.
	 5. Otherwise use .got so that it can be shared among different
	 objects at run-time.
	 We only need to relocate .got entry in shared object.  */
      if ((info->shared
	   && (h->dynindx == -1
	       || h->forced_local))
	  || (!info->shared
	      && !h->pointer_equality_needed)
	  || (info->executable && info->shared)
	  || htab->elf.sgot == NULL)
	{
	  /* Use .got.plt.  */
	  h->got.offset = (bfd_vma) -1;
	}
      else
	{
	  h->got.offset = htab->elf.sgot->size;
	  htab->elf.sgot->size += GOT_ENTRY_SIZE;
	  if (info->shared)
	    htab->elf.srelgot->size += sizeof (Elf64_External_Rela);
	}

      return TRUE;
    }
d2000 1
a2000 1
	  struct elf64_x86_64_dyn_relocs **pp;
d2101 1
a2101 1
  struct elf64_x86_64_dyn_relocs *p;
d2171 1
a2171 1
	  struct elf64_x86_64_dyn_relocs *p;
d2173 1
a2173 1
	  for (p = (struct elf64_x86_64_dyn_relocs *)
@


1.169
log
@2009-06-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in (elf): Add elf-ifunc.lo.

	* configure: Regenerated.
	* Makefile.in: Likewise.

	* elf-bfd.h (elf_link_hash_table): Add sgot, sgotplt,
	srelgot, splt, srelplt, igotplt, iplt, irelplt and irelifunc.

	* elf32-i386.c (elf_i386_link_hash_table): Remove sgot,
	sgotplt, srelgot, splt, srelplt, igotplt, iplt, irelplt and
	irelifunc.
	(elf_i386_link_hash_table_create): Likewise.
	(elf_i386_create_dynamic_sections): Likewise.
	(elf_i386_check_relocs): Likewise.
	(elf_i386_allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(elf_i386_finish_dynamic_sections): Likewise.
	(elf_i386_create_got_section): Removed.

	* elf64-x86-64.c (elf64_x86_64_link_hash_table): Remove sgot,
	sgotplt, srelgot, splt, srelplt, igotplt, iplt, irelplt and
	irelifunc.
	(elf64_x86_64_compute_jump_table_size): Updated.
	(elf64_x86_64_link_hash_table_create): Likewise.
	(elf64_x86_64_create_dynamic_sections): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	(elf64_x86_64_finish_dynamic_symbol): Likewise.
	(elf64_x86_64_finish_dynamic_sections): Likewise.
	(elf64_x86_64_create_got_section): Removed.

	* elflink.c (_bfd_elf_create_got_section): Use log_file_align
	for pointer alignment.  Set up section pointers.
	(_bfd_elf_create_dynamic_sections): Likewise.
	(_bfd_elf_create_ifunc_sections): Moved to ...
	* elf-ifunc.c: Here.  New.

	* Makefile.am (BFD32_BACKENDS): Add elf-ifunc.lo.
	(BFD32_BACKENDS_CFILES): Add elf-ifunc.c.
	Run "make dep-am".
@
text
@a561 7
static hashval_t
elf64_x86_64_local_hash (int id, int r_sym)
{
  return ((((id & 0xff) << 24) | ((id & 0xff00) << 8))
	  ^ r_sym ^ (id >> 16));
}

d572 1
a572 1
  return elf64_x86_64_local_hash (h->indx, h->dynstr_index);
d597 2
a598 2
  hashval_t h = elf64_x86_64_local_hash (sec->id,
					 ELF64_R_SYM (rel->r_info));
@


1.168
log
@2009-06-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_allocate_dynrelocs): Update comments.
	* elf64-x86-64.c (elf64_x86_64_allocate_dynrelocs): Likewise.
@
text
@a490 5
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
a492 4
  asection *igotplt;
  asection *iplt;
  asection *irelplt;
  asection *irelifunc;
d528 1
a528 1
  ((htab)->srelplt->reloc_count * GOT_ENTRY_SIZE)
a657 5
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
a659 4
  ret->igotplt= NULL;
  ret->iplt = NULL;
  ret->irelplt= NULL;
  ret->irelifunc = NULL;
a695 29
/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
elf64_x86_64_create_got_section (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf64_x86_64_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = elf64_x86_64_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (!htab->sgot || !htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rela.got",
					       (SEC_ALLOC | SEC_LOAD
						| SEC_HAS_CONTENTS
						| SEC_IN_MEMORY
						| SEC_LINKER_CREATED
						| SEC_READONLY));
  if (htab->srelgot == NULL
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 3))
    return FALSE;
  return TRUE;
}

a704 4
  htab = elf64_x86_64_hash_table (info);
  if (!htab->sgot && !elf64_x86_64_create_got_section (dynobj, info))
    return FALSE;

d708 1
a708 2
  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
d713 1
a713 1
  if (!htab->splt || !htab->srelplt || !htab->sdynbss
d1164 2
a1165 25
	      if (htab->irelifunc == NULL && htab->iplt == NULL)
		{
		  if (!_bfd_elf_create_ifunc_sections (abfd, info))
		    return FALSE;

		  if (info->shared)
		    {
		      htab->irelifunc = bfd_get_section_by_name (abfd,
								 ".rela.ifunc");
		      if (!htab->irelifunc)
			abort ();
		    }
		  else
		    {
		      htab->iplt = bfd_get_section_by_name (abfd, ".iplt");
		      htab->irelplt = bfd_get_section_by_name (abfd,
							       ".rela.iplt");
		      htab->igotplt = bfd_get_section_by_name (abfd,
							       ".igot.plt");
		      if (!htab->iplt
			  || !htab->irelplt
			  || !htab->igotplt)
			abort ();
		    }
		}
d1256 3
a1258 3
		  if (htab->sgot == NULL
		      && !elf64_x86_64_create_got_section (htab->elf.dynobj,
							   info))
d1394 1
a1394 1
	  if (htab->sgot == NULL)
d1398 2
a1399 2
	      if (!elf64_x86_64_create_got_section (htab->elf.dynobj,
						    info))
d1945 1
a1945 1
      if (htab->splt != NULL)
d1947 3
a1949 3
	  plt = htab->splt;
	  gotplt = htab->sgotplt;
	  relplt = htab->srelplt;
d1958 3
a1960 3
	  plt = htab->iplt;
	  gotplt = htab->igotplt;
	  relplt = htab->irelplt;
d1988 2
a1989 1
	htab->irelifunc->size += p->count * sizeof (Elf64_External_Rela);
d2010 1
a2010 1
	  || htab->sgot == NULL)
d2017 2
a2018 2
	  h->got.offset = htab->sgot->size;
	  htab->sgot->size += GOT_ENTRY_SIZE;
d2020 1
a2020 1
	    htab->srelgot->size += sizeof (Elf64_External_Rela);
d2040 1
a2040 1
	  asection *s = htab->splt;
d2066 1
a2066 1
	  htab->sgotplt->size += GOT_ENTRY_SIZE;
d2069 2
a2070 2
	  htab->srelplt->size += sizeof (Elf64_External_Rela);
	  htab->srelplt->reloc_count++;
d2112 1
a2112 1
	  eh->tlsdesc_got = htab->sgotplt->size
d2114 1
a2114 1
	  htab->sgotplt->size += 2 * GOT_ENTRY_SIZE;
d2120 1
a2120 1
	  s = htab->sgot;
d2132 1
a2132 1
	htab->srelgot->size += sizeof (Elf64_External_Rela);
d2134 1
a2134 1
	htab->srelgot->size += 2 * sizeof (Elf64_External_Rela);
d2140 1
a2140 1
	htab->srelgot->size += sizeof (Elf64_External_Rela);
d2143 1
a2143 1
	  htab->srelplt->size += sizeof (Elf64_External_Rela);
d2374 2
a2375 2
      s = htab->sgot;
      srel = htab->srelgot;
d2384 1
a2384 1
		  *local_tlsdesc_gotent = htab->sgotplt->size
d2386 1
a2386 1
		  htab->sgotplt->size += 2 * GOT_ENTRY_SIZE;
d2403 2
a2404 1
		      htab->srelplt->size += sizeof (Elf64_External_Rela);
d2421 3
a2423 3
      htab->tls_ld_got.offset = htab->sgot->size;
      htab->sgot->size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->size += sizeof (Elf64_External_Rela);
d2443 1
a2443 1
  if (htab->srelplt)
d2455 2
a2456 2
	  htab->tlsdesc_got = htab->sgot->size;
	  htab->sgot->size += GOT_ENTRY_SIZE;
d2459 4
a2462 4
	  if (htab->splt->size == 0)
	    htab->splt->size += PLT_ENTRY_SIZE;
	  htab->tlsdesc_plt = htab->splt->size;
	  htab->splt->size += PLT_ENTRY_SIZE;
d2474 5
a2478 5
      if (s == htab->splt
	  || s == htab->sgot
	  || s == htab->sgotplt
	  || s == htab->iplt
	  || s == htab->igotplt
d2486 1
a2486 1
	  if (s->size != 0 && s != htab->srelplt)
d2491 1
a2491 1
	  if (s != htab->srelplt)
d2545 1
a2545 1
      if (htab->splt->size != 0)
d2809 1
a2809 1
	  plt = htab->splt ? htab->splt : htab->iplt;
d2882 1
a2882 1
		  sreloc = htab->irelifunc;
d2904 1
a2904 1
	      base_got = htab->sgot;
d2916 1
a2916 1
		  if (htab->splt != NULL)
d2920 1
a2920 1
		      base_got = htab->sgotplt;
d2926 1
a2926 1
		      base_got = htab->igotplt;
d2962 2
a2963 2
		  if (htab->splt != NULL)
		    gotplt = htab->sgotplt;
d2965 1
a2965 1
		    gotplt = htab->igotplt;
d2992 1
a2992 1
	  base_got = htab->sgot;
d2994 1
a2994 1
	  if (htab->sgot == NULL)
d3012 1
a3012 1
		  base_got = htab->sgotplt;
d3073 1
a3073 1
		      s = htab->srelgot;
d3097 2
a3098 2
	    relocation -= htab->sgotplt->output_section->vma
			  - htab->sgotplt->output_offset;
d3127 2
a3128 2
	  relocation -= htab->sgotplt->output_section->vma
			+ htab->sgotplt->output_offset;
d3134 2
a3135 2
	  relocation = htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset;
d3145 1
a3145 1
	      && htab->splt != NULL)
d3147 2
a3148 2
	      relocation = (htab->splt->output_section->vma
			    + htab->splt->output_offset
d3153 2
a3154 2
	  relocation -= htab->sgotplt->output_section->vma
			+ htab->sgotplt->output_offset;
d3167 1
a3167 1
	      || htab->splt == NULL)
d3175 2
a3176 2
	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
d3508 1
a3508 1
	  if (htab->sgot == NULL)
d3534 1
a3534 1
	      if (htab->srelgot == NULL)
d3543 3
a3545 3
			      + 2 * GOT_ENTRY_SIZE <= htab->sgotplt->size);
		  outrel.r_offset = (htab->sgotplt->output_section->vma
				     + htab->sgotplt->output_offset
d3548 1
a3548 1
		  sreloc = htab->srelplt;
d3561 1
a3561 1
	      sreloc = htab->srelgot;
d3563 2
a3564 2
	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);
d3573 1
a3573 1
	      bfd_put_64 (output_bfd, 0, htab->sgot->contents + off);
d3593 1
a3593 1
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
d3598 1
a3598 1
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
d3624 2
a3625 2
		relocation = htab->sgotplt->output_section->vma
		  + htab->sgotplt->output_offset
d3628 2
a3629 2
		relocation = htab->sgot->output_section->vma
		  + htab->sgot->output_offset + off;
d3648 2
a3649 2
		  relocation = (htab->sgot->output_section->vma
				+ htab->sgot->output_offset + off
d3683 2
a3684 2
			      htab->sgot->output_section->vma
			      + htab->sgot->output_offset + off
d3737 1
a3737 1
	  if (htab->sgot == NULL)
d3748 1
a3748 1
	      if (htab->srelgot == NULL)
d3751 2
a3752 2
	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);
d3755 1
a3755 1
			  htab->sgot->contents + off);
d3757 1
a3757 1
			  htab->sgot->contents + off + GOT_ENTRY_SIZE);
d3760 2
a3761 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d3765 2
a3766 2
	  relocation = htab->sgot->output_section->vma
		       + htab->sgot->output_offset + off;
d3867 1
a3867 1
      if (htab->splt != NULL)
d3869 3
a3871 3
	  plt = htab->splt;
	  gotplt = htab->sgotplt;
	  relplt = htab->srelplt;
d3875 3
a3877 3
	  plt = htab->iplt;
	  gotplt = htab->igotplt;
	  relplt = htab->irelplt;
d3902 1
a3902 1
      if (plt == htab->splt)
d3933 1
a3933 1
      if (plt == htab->splt)
d4000 1
a4000 1
      if (htab->sgot == NULL || htab->srelgot == NULL)
d4003 2
a4004 2
      rela.r_offset = (htab->sgot->output_section->vma
		       + htab->sgot->output_offset
d4028 1
a4028 1
	      asection *plt = htab->splt ? htab->splt : htab->iplt;
d4032 1
a4032 1
			  htab->sgot->contents + h->got.offset);
d4052 1
a4052 1
		      htab->sgot->contents + h->got.offset);
d4057 2
a4058 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d4146 1
a4146 1
      if (sdyn == NULL || htab->sgot == NULL)
d4164 1
a4164 1
	      s = htab->sgotplt;
d4169 1
a4169 1
	      dyn.d_un.d_ptr = htab->srelplt->output_section->vma;
d4173 1
a4173 1
	      s = htab->srelplt->output_section;
d4185 1
a4185 1
	      if (htab->srelplt != NULL)
d4187 1
a4187 1
		  s = htab->srelplt->output_section;
d4193 1
a4193 1
	      s = htab->splt;
d4199 1
a4199 1
	      s = htab->sgot;
d4209 1
a4209 1
      if (htab->splt && htab->splt->size > 0)
d4212 1
a4212 1
	  memcpy (htab->splt->contents, elf64_x86_64_plt0_entry,
d4217 2
a4218 2
		      (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d4220 2
a4221 2
		       - htab->splt->output_section->vma
		       - htab->splt->output_offset
d4223 1
a4223 1
		      htab->splt->contents + 2);
d4227 2
a4228 2
		      (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d4230 2
a4231 2
		       - htab->splt->output_section->vma
		       - htab->splt->output_offset
d4233 1
a4233 1
		      htab->splt->contents + 8);
d4235 1
a4235 1
	  elf_section_data (htab->splt->output_section)->this_hdr.sh_entsize =
d4241 1
a4241 1
			  htab->sgot->contents + htab->tlsdesc_got);
d4243 1
a4243 1
	      memcpy (htab->splt->contents + htab->tlsdesc_plt,
d4250 2
a4251 2
			  (htab->sgotplt->output_section->vma
			   + htab->sgotplt->output_offset
d4253 2
a4254 2
			   - htab->splt->output_section->vma
			   - htab->splt->output_offset
d4257 1
a4257 1
			  htab->splt->contents + htab->tlsdesc_plt + 2);
d4262 2
a4263 2
			  (htab->sgot->output_section->vma
			   + htab->sgot->output_offset
d4265 2
a4266 2
			   - htab->splt->output_section->vma
			   - htab->splt->output_offset
d4269 1
a4269 1
			  htab->splt->contents + htab->tlsdesc_plt + 8);
d4274 1
a4274 1
  if (htab->sgotplt)
d4277 1
a4277 1
      if (htab->sgotplt->size > 0)
d4282 1
a4282 1
	    bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents);
d4286 1
a4286 1
			htab->sgotplt->contents);
d4288 2
a4289 2
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents + GOT_ENTRY_SIZE);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents + GOT_ENTRY_SIZE*2);
d4292 1
a4292 1
      elf_section_data (htab->sgotplt->output_section)->this_hdr.sh_entsize =
d4296 2
a4297 2
  if (htab->sgot && htab->sgot->size > 0)
    elf_section_data (htab->sgot->output_section)->this_hdr.sh_entsize
@


1.167
log
@2009-06-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_check_relocs): Reformat.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
@
text
@d1986 5
a1990 5
	 defined in executable. the .got.plt slot in the shared library
	 will contain address of the .plt slot in the binary and only
	 its .got.plt will contain the resolved function that should be
	 called.  Pointer equality won't work correctly.  PIE should
	 be used if pointer equality is required here.  */
@


1.166
log
@2009-06-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_allocate_dynrelocs): Fix a typo.
	* elf64-x86-64.c (elf64_x86_64_allocate_dynrelocs): Likewise.
@
text
@d1261 5
a1265 5
		 default:
		   (*_bfd_error_handler)
		     (_("%B: relocation %s against STT_GNU_IFUNC "
			"symbol `%s' isn't handled by %s"), abfd,
		      x86_64_elf_howto_table[r_type].name,
d1268 3
a1270 3
		      __FUNCTION__);
		   bfd_set_error (bfd_error_bad_value);
		   return FALSE;
@


1.165
log
@bfd/

2009-06-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10270
	* elf32-i386.c (elf_i386_allocate_dynrelocs): Disallow
	dynamic IFUNC pointer in non-shared object.  Use .got.plt
	for IFUNC definition in PIE.
	(elf_i386_allocate_dynrelocs): Resolve IFUNC definition in
	PIE locally.

	* elf64-x86-64.c (elf64_x86_64_allocate_dynrelocs): Disallow
	dynamic IFUNC pointer in non-shared object.  Use .got.plt
	for IFUNC definition in PIE.
	(elf64_x86_64_relocate_section): Resolve IFUNC definition in
	PIE locally.

ld/testsuite/

2009-06-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10270
	* ld-ifunc/ifunc-9-x86.d: New.
	* ld-ifunc/ifunc-9-x86.s: Likewise.
@
text
@d1997 1
a1997 1
	    (_("%F%P: dynamic STT_GNU_IFUNC symbool `%s' with pointer "
@


1.164
log
@2009-06-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_relocate_section): Properly report
	local symbol for unhandled relocation against STT_GNU_IFUNC
	symbol.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@d1985 21
d2073 3
a2075 2
	 3. Use .got.plt if .got isn't used.
	 4. Otherwise use .got so that it can be shared among different
d2083 1
d2940 2
a2941 1
		      || h->forced_local)
@


1.163
log
@2009-06-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_check_relocs): Properly report
	local symbol for unhandled relocation against STT_GNU_IFUNC
	symbol.
	* elf64-x86-64.c (elf64_x86_64_check_relocs):  Likewise.
@
text
@d2870 3
a2872 1
		 h->root.root.string, __FUNCTION__);
d2888 3
a2890 1
		     h->root.root.string, rel->r_addend);
@


1.162
log
@bfd/

2009-06-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10269
	* elf32-i386.c: Include "objalloc.h" and "hashtab.h".
	(elf_i386_link_hash_table): Add loc_hash_table and
	loc_hash_memory.
	(elf_i386_local_hash): New.
	(elf_i386_local_htab_hash): Likewise.
	(elf_i386_local_htab_eq): Likewise.
	(elf_i386_get_local_sym_hash): Likewise.
	(elf_i386_link_hash_table_free): Likewise.
	(elf_i386_allocate_local_dynrelocs): Likewise.
	(elf_i386_finish_local_dynamic_symbol): Likewise.
	(bfd_elf64_bfd_link_hash_table_free): Likewise.
	(elf_i386_link_hash_table_create): Create loc_hash_table and
	loc_hash_memory.
	(elf_i386_check_relocs): Handle local STT_GNU_IFUNC symbols.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_sections): Likewise.
	(elf_i386_finish_dynamic_symbol): Check _DYNAMIC only if sym
	isn't NULL.

	* elf64-x86-64.c: Include "objalloc.h" and "hashtab.h".
	(elf64_x86_64_link_hash_table): Add loc_hash_table and
	loc_hash_memory.
	(elf64_x86_64_local_hash): New.
	(elf64_x86_64_local_htab_hash): Likewise.
	(elf64_x86_64_local_htab_eq): Likewise.
	(elf64_x86_64_get_local_sym_hash): Likewise.
	(elf64_x86_64_link_hash_table_free): Likewise.
	(elf64_x86_64_allocate_local_dynrelocs): Likewise.
	(elf64_x86_64_finish_local_dynamic_symbol): Likewise.
	(bfd_elf64_bfd_link_hash_table_free): Likewise.
	(elf64_x86_64_link_hash_table_create): Create loc_hash_table
	and loc_hash_memory.
	(elf64_x86_64_check_relocs): Handle local STT_GNU_IFUNC
	symbols.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	(elf64_x86_64_finish_dynamic_sections): Likewise.
	(elf64_x86_64_finish_dynamic_symbol): Check _DYNAMIC only if
	sym isn't NULL.

gas/

2009-06-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10269
	* config/tc-i386.c (md_apply_fix): Use TC_FORCE_RELOCATION
	instead of generic_force_reloc.

	* config/tc-i386.h (TC_FORCE_RELOCATION): New.

ld/testsuite/

2009-06-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10269
	*: ld-ifunc/ifunc-1-local-x86.d: New.
	*: ld-ifunc/ifunc-1-local-x86.s: Likewise.
	*: ld-ifunc/ifunc-2-local-i386.d: Likewise.
	*: ld-ifunc/ifunc-2-local-i386.s: Likewise.
	*: ld-ifunc/ifunc-2-local-x86-64.d: Likewise.
	*: ld-ifunc/ifunc-2-local-x86-64.s: Likewise.
	*: ld-ifunc/ifunc-4-local-x86.d: Likewise.
	*: ld-ifunc/ifunc-4-local-x86.s: Likewise.
	*: ld-ifunc/ifunc-5-local-i386.s: Likewise.
	*: ld-ifunc/ifunc-5-local-x86-64.s: Likewise.
	*: ld-ifunc/ifunc-5a-local-i386.d: Likewise.
	*: ld-ifunc/ifunc-5a-local-x86-64.d: Likewise.
	*: ld-ifunc/ifunc-5b-local-i386.d: Likewise.
	*: ld-ifunc/ifunc-5b-local-x86-64.d: Likewise.
@
text
@d1266 2
a1267 1
		      h != NULL ? h->root.root.string : "a local symbol",
@


1.161
log
@bfd/

2009-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_link_hash_table): Add irelifunc.
	(elf_i386_link_hash_table_create): Initialize irelifunc.
	(elf_i386_check_relocs): Updated.  Set up irelifunc for
	shared objects.
	(elf_i386_allocate_dynrelocs): Use irelifunc for dynamic
	relocation for non-GOT reference of STT_GNU_IFUNC symbol in
	shared objects.
	(elf_i386_relocate_section): Likewise.

	* elf64-x86-64.c (elf64_x86_64_link_hash_table): Add irelifunc.
	(elf64_x86_64_link_hash_table_create): Initialize irelifunc.
	(elf64_x86_64_check_relocs): Updated.  Set up irelifunc for
	shared objects.
	(elf64_x86_64_allocate_dynrelocs): Use irelifunc for dynamic
	relocation for non-GOT reference of STT_GNU_IFUNC symbol in
	shared objects.
	(elf64_x86_64_relocate_section): Likewise.

	* elf-bfd.h (_bfd_elf_create_static_ifunc_sections): Renamed to
	...
	(_bfd_elf_create_ifunc_sections): This.

	* elflink.c (_bfd_elf_create_static_ifunc_sections): Renamd to
	...
	(_bfd_elf_create_ifunc_sections): This.  Create .rel[a].ifunc
	for shared objects.

ld/

2009-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* scripttempl/elf.sc: Add .rel.ifunc and .rela.ifunc.
@
text
@d29 2
d525 4
d571 76
d685 11
d699 15
d1123 1
d1132 1
d1155 34
a1188 1
	h = NULL;
d1195 1
d1197 2
d1266 2
a1267 1
		      h->root.root.string, __FUNCTION__);
d2295 19
d2482 5
d2804 15
a2818 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d2898 2
a2899 2
		  /* Need a dynamic relocation get the the real
		     function address. */
d4129 5
a4133 3
  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute.  */
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
      || h == htab->elf.hgot)
d4139 15
d4344 5
d4597 2
@


1.160
log
@2009-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_check_relocs): Make room for dynamic
	relocation for R_386_32 against STT_GNU_IFUNC symbol when
	building shared object.  Check info->executable instead of
	!info->shared when setting non_got_ref.
	(elf_i386_allocate_dynrelocs): Allocate dynamic relocation
	for non-GOT reference of STT_GNU_IFUNC symbol in shared
	object. Allocate GOT relocation agsinst STT_GNU_IFUNC
	symbol if needed.
	(elf_i386_relocate_section): Output dynamic relocation for
	R_386_32 against STT_GNU_IFUNC symbol to get the real
	function address when building shared object.
	(elf_i386_finish_dynamic_symbol): Output R_386_GLOB_DAT
	relocation for STT_GNU_IFUNC symbol in shared object.

	* elf64-x86-64.c (elf64_x86_64_check_relocs): Make room for
	dynamic relocation for R_X86_64_64 against STT_GNU_IFUNC
	symbol when building shared object.  Check info->executable
	instead of !info->shared when setting non_got_ref.
	(elf64_x86_64_allocate_dynrelocs): Allocate dynamic relocation
	for non-GOT reference of STT_GNU_IFUNC symbol in shared
	library. Allocate GOT relocation agsinst STT_GNU_IFUNC symbol
	if needed.
	(elf64_x86_64_relocate_section): Output dynamic relocation
	for R_X86_64_64 against STT_GNU_IFUNC symbol to get the real
	function address when building shared object.
	(elf64_x86_64_finish_dynamic_symbol): Output R_X86_64_GLOB_DAT
	relocation for STT_GNU_IFUNC symbol in shared object.
@
text
@d499 1
d595 1
d1070 1
a1070 1
	      if (!info->shared && htab->iplt == NULL)
d1072 1
a1072 2
		  if (!_bfd_elf_create_static_ifunc_sections (abfd,
							      info))
d1075 19
a1093 9
		  htab->iplt = bfd_get_section_by_name (abfd, ".iplt");
		  htab->irelplt = bfd_get_section_by_name (abfd,
							   ".rela.iplt");
		  htab->igotplt = bfd_get_section_by_name (abfd,
							   ".igot.plt");
		  if (!htab->iplt
		      || !htab->irelplt
		      || !htab->igotplt)
		    abort ();
d1894 1
a1894 4
	{
	  asection * sreloc = elf_section_data (p->sec)->sreloc;
	  sreloc->size += p->count * sizeof (Elf64_External_Rela);
	}
d2741 1
a2741 1
		  sreloc = elf_section_data (input_section)->sreloc;
@


1.159
log
@2009-06-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_allocate_dynrelocs): Remove check of
	h->plt.refcount > 0 on STT_GNU_IFUNC symbol.
	* elf64-x86-64.c (elf64_x86_64_allocate_dynrelocs): Likewise.
@
text
@d1113 43
a1157 1
		case R_X86_64_64:
d1374 1
a1374 1
	  if (h != NULL && !info->shared)
d1840 1
a1840 1
      if (htab->splt != 0)
d1875 4
a1878 3
      /* No need for dynamic relocation for local STT_GNU_IFUNC symbol.
	 Discard space for relocations against it.  */
      if (h->dynindx == -1 || h->forced_local)
d1881 35
a1915 22
      /* STT_GNU_IFUNC symbol uses .got.plt, not .got.  But for
	 shared library, we must go through GOT and we can't
	 use R_X86_64_IRELATIVE unless it is forced local.   */
      if (info->executable
	  || info->symbolic
	  || h->forced_local)
	{
	  if (h->pointer_equality_needed
	      && htab->sgot != NULL)
	    {
	      /* We can't use .got.plt, which contains the real
		 function addres, since we need pointer equality.
		 We will load the GOT entry with the PLT entry
		 in elf64_x86_64_finish_dynamic_symbol and don't
		 need GOT relocation.  */
	      h->got.offset = htab->sgot->size;
	      htab->sgot->size += GOT_ENTRY_SIZE;
	      eh->tlsdesc_got = (bfd_vma) -1;
	      goto skip_relgot;
	    }
	  else
	    h->got.refcount = 0;
d1917 2
a2044 1
skip_relgot:
d2681 1
a2681 1
	      if (!info->executable)
d2683 63
a2747 1
	    case R_X86_64_64:
d3718 1
a3718 1
      if (htab->splt != 0)
d3863 1
a3863 5
      if ((info->executable
	   || info->symbolic
	   || h->forced_local)
	  && h->def_regular
	  && h->pointer_equality_needed
d3866 20
a3885 12
	  /* The STT_GNU_IFUNC symbol is locally defined.  But we can't
	     use .got.plt, which contains the real function addres,
	     since we need pointer equality.  We load the GOT entry
	     with the PLT entry without relocation.  */
	  asection *plt = htab->splt ? htab->splt : htab->iplt;
	  if (htab->sgot == NULL
	      || h->plt.offset == (bfd_vma) -1)
	    abort ();
	  bfd_put_64 (output_bfd, (plt->output_section->vma
				   + plt->output_offset + h->plt.offset),
		      htab->sgot->contents + h->got.offset);
	  return TRUE;
d3901 1
@


1.158
log
@2009-06-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_allocate_dynrelocs): Allocate
	GOT entry for STT_GNU_IFUNC symbol with pointer equality.
	(elf_i386_relocate_section): Adjust R_386_GOT32 relocation
	against STT_GNU_IFUNC symbols for static executables.
	(elf_i386_finish_dynamic_symbol): Load GOT entry with
	PLT entry for STT_GNU_IFUNC symbol with pointer equality.

	* elf64-x86-64.c (elf64_x86_64_allocate_dynrelocs): Allocate
	GOT entry for STT_GNU_IFUNC symbol with pointer equality.
	(elf64_x86_64_finish_dynamic_symbol): Load GOT entry with
	PLT entry for STT_GNU_IFUNC symbol with pointer equality.
@
text
@a1795 3
      if (h->plt.refcount <= 0)
	abort ();

@


1.157
log
@bfd/

2009-06-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_check_relocs): Increment
	got.refcount for R_386_GOT32/R_386_GOTOFF relocations
	against STT_GNU_IFUNC symbol.
	(elf_i386_allocate_dynrelocs): Set got.refcount to 0 if
	local STT_GNU_IFUNC definition is used.
	(elf_i386_relocate_section): Handle got.offset != -1 for
	R_386_GOT32/R_386_GOTOFF relocations against STT_GNU_IFUNC
	symbol.

	* elf64-x86-64.c (elf64_x86_64_check_relocs): Increment
	got.refcount for R_X86_64_GOTPCREL/R_X86_64_GOTPCREL64
	relocations against STT_GNU_IFUNC symbol.
	(elf64_x86_64_allocate_dynrelocs): Set got.refcount to 0 if
	local STT_GNU_IFUNC definition is used.
	(elf64_x86_64_relocate_section): Handle got.offset != -1
	for R_X86_64_GOTPCREL/R_X86_64_GOTPCREL64 relocations against
	STT_GNU_IFUNC symbol.

ld/testsuite/

2009-06-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-ifunc/ifunc-5-i386.d: Renamed to ...
	* ld-ifunc/ifunc-5a-i386.d: This.

	* ld-ifunc/ifunc-5-x86-64.d: Renamed to ...
	* ld-ifunc/ifunc-5a-x86-64.d: This.

	* ld-ifunc/ifunc-5b-i386.d: New.
	* ld-ifunc/ifunc-5b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-6a-i386.d: Likewise.
	* ld-ifunc/ifunc-6a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-6b-i386.d: Likewise.
	* ld-ifunc/ifunc-6b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-6-i386.s: Likewise.
	* ld-ifunc/ifunc-6-x86-64.s: Likewise.
	* ld-ifunc/ifunc-7a-i386.d: Likewise.
	* ld-ifunc/ifunc-7a-x86-64.d: Likewise.
	* ld-ifunc/ifunc-7b-i386.d: Likewise.
	* ld-ifunc/ifunc-7b-x86-64.d: Likewise.
	* ld-ifunc/ifunc-7-i386.s: Likewise.
	* ld-ifunc/ifunc-7-x86-64.s: Likewise.
@
text
@d1844 1
a1844 1
      if (!info->shared 
d1847 17
a1863 1
	h->got.refcount = 0;
d1990 1
d3747 22
a3768 2
      if (info->shared
	  && SYMBOL_REFERENCES_LOCAL (info, h))
@


1.156
log
@bfd/

2009-06-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10205
	* elf32-i386.c (elf_howto_table): Add R_386_IRELATIVE.
	(elf_i386_reloc_type_lookup): Likewise.
	(R_386_tls): Removed.
	(R_386_irelative): New.
	(R_386_vt_offset): Updated.
	(elf_i386_rtype_to_howto): Likewise.
	(elf_i386_link_hash_table): Add igotplt, iplt and irelplt.
	(elf_i386_link_hash_table_create): Initialize igotplt,
	iplt and irelplt.
	(elf_i386_check_relocs): Handle STT_GNU_IFUNC symbol first.
	(elf_i386_adjust_dynamic_symbol): Likewise.
	(elf_i386_allocate_dynrelocs): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_size_dynamic_sections): Set up .iplt and .igot.plt
	sections.
	(elf_i386_finish_dynamic_symbol): When building a static
	executable, use .iplt, .igot.plt and .rel.iplt sections for
	STT_GNU_IFUNC symbols.  Generate R_386_IRELATIVE relocation for
	locally defined STT_GNU_IFUNC symbol.

	* elf64-x86-64.c (x86_64_elf_howto): Add R_X86_64_IRELATIVE.
	(x86_64_reloc_map): Likewise.
	(R_X86_64_standard): Updated.
	(elf64_x86_64_link_hash_table): Add igotplt, iplt and irelplt.
	(elf64_x86_64_link_hash_table_create): Initialize igotplt,
	iplt and irelplt.
	(elf64_x86_64_check_relocs): Handle STT_GNU_IFUNC symbol first.
	(elf64_x86_64_adjust_dynamic_symbol): Likewise.
	(elf64_x86_64_allocate_dynrelocs): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	(elf64_x86_64_size_dynamic_sections): Set up .iplt and .igot.plt
	sections.
	(elf64_x86_64_finish_dynamic_symbol): When building a static
	executable, use .iplt, .igot.plt and .rela.iplt sections for
	STT_GNU_IFUNC symbols.  Generate R_X86_64_IRELATIVE relocation
	for locally defined STT_GNU_IFUNC symbol.

	* reloc.c (BFD_RELOC_386_IRELATIVE): New.
	(BFD_RELOC_X86_64_IRELATIVE): Likewise.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

include/elf/

2009-06-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10205
	* i386.h (R_386_IRELATIVE): New.
	* x86-64.h (R_X86_64_IRELATIVE): Likewise.

ld/testsuite/

2009-06-01  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10205
	* ld-ifunc/ifunc.exp (contains_irelative_reloc): New.
	Use it on executable and shared library.
	Run *.d.

	* ld-ifunc/lib.c: Add a hidden alias, __GI_library_func2, for
	library_func2.
	(library_func): New.

	* ld-ifunc/ifunc-1-x86.d: New.
	* ld-ifunc/ifunc-1-x86.s: Likewise.
	* ld-ifunc/ifunc-2-i386.d: Likewise.
	* ld-ifunc/ifunc-2-i386.s: Likewise.
	* ld-ifunc/ifunc-2-x86-64.d: Likewise.
	* ld-ifunc/ifunc-2-x86-64.s: Likewise.
	* ld-ifunc/ifunc-3a-x86.d: Likewise.
	* ld-ifunc/ifunc-3b-x86.d: Likewise.
	* ld-ifunc/ifunc-3-x86.s: Likewise.
	* ld-ifunc/ifunc-4-x86.d: Likewise.
	* ld-ifunc/ifunc-4-x86.s: Likewise.
	* ld-ifunc/ifunc-5-i386.d: Likewise.
	* ld-ifunc/ifunc-5-i386.s: Likewise.
	* ld-ifunc/ifunc-5-x86-64.d: Likewise.
	* ld-ifunc/ifunc-5-x86-64.s: Likewise.
@
text
@d1129 1
d1841 7
a1847 2
      /* STT_GNU_IFUNC symbol uses .got.plt, not .got.  */
      h->got.refcount = 0;
d2625 1
a2625 2
	      if (base_got == NULL
		  || off != (bfd_vma) -1)
d2628 1
a2628 11
	      /* We can't use h->got.offset here to save state, or
		 even just remember the offset, as finish_dynamic_symbol
		 would use that as offset into .got.  */

	      if (htab->splt != NULL)
		{
		  plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
		  off = (plt_index + 3) * GOT_ENTRY_SIZE;
		  base_got = htab->sgotplt;
		}
	      else
d2630 3
a2632 4
		  plt_index = h->plt.offset / PLT_ENTRY_SIZE;
		  off = plt_index * GOT_ENTRY_SIZE;
		  base_got = htab->igotplt;
		}
d2634 12
a2645 9
	      if (h->dynindx == -1
		  || h->forced_local
		  || info->symbolic)
		{
		  /* This references the local defitionion.  We must 
		     initialize this entry in the global offset table.
		     Since the offset must always be a multiple of 8, we
		     use the least significant bit to record whether we
		     have initialized it already.
d2647 3
a2649 6
		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.	This is
		     done in the finish_dynamic_symbol routine.	 */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
d2651 19
a2669 5
		      bfd_put_64 (output_bfd, relocation,
				  base_got->contents + off);
		      /* Note that this is harmless for the GOTPLT64 case,
		         as -1 | 1 still is -1.  */
		      h->got.offset |= 1;
@


1.155
log
@2009-05-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (link_hash_newfunc): Add elf_i386_ prefix.
	(create_got_section): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	(set_tls_module_base): Likewise.
	(dtpoff_base): Likewise.
	(tpoff): Likewise.
	(elf_i386_link_hash_table_create): Updated.
	(elf_i386_create_dynamic_sections): Likewise.
	(elf_i386_check_relocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.

	* elf64-x86-64.c (link_hash_newfunc): Add elf64_x86_64_ prefix.
	(create_got_section): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	(set_tls_module_base): Likewise.
	(dtpoff_base): Likewise.
	(tpoff): Likewise.
	(elf64_x86_64_link_hash_table_create): Updated.
	(elf64_x86_64_create_dynamic_sections): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
@
text
@d146 3
d154 1
a154 1
#define R_X86_64_standard (R_X86_64_TLSDESC + 1)
d217 1
d496 3
d591 3
d1024 1
a1024 1
  
d1050 88
a1398 6

		  /* Create the ifunc section, even if we will not encounter an
		     indirect function symbol.  We may not even see one in the input
		     object file, but we can still encounter them in libraries.  */
		  (void) _bfd_elf_make_ifunc_reloc_section
		    (abfd, sec, htab->elf.dynobj, 2);
d1623 11
a1764 1
  bfd_boolean use_indirect_section = FALSE;
d1771 1
d1776 69
a1844 2
  if (htab->elf.dynamic_sections_created
      && h->plt.refcount > 0)
a1901 1
  eh = (struct elf64_x86_64_link_hash_entry *) h;
d2015 1
a2015 10
    }
  else if (_bfd_elf_is_ifunc_symbol (info->output_bfd, h)
	   && h->dynindx == -1
	   && ! h->forced_local)
    {
      if (bfd_elf_link_record_dynamic_symbol (info, h)
	  && h->dynindx != -1)
	use_indirect_section = TRUE;
      else
	return FALSE;
d2053 1
a2053 4
      if (use_indirect_section)
	sreloc = elf_section_data (p->sec)->indirect_relocs;
      else
	sreloc = elf_section_data (p->sec)->sreloc;
d2270 2
d2524 1
d2574 110
a2687 1
	asection *base_got;
a2971 6
	      || (! info->shared
		  && h != NULL
		  && h->dynindx != -1
		  && ! h->forced_local
		  && ((struct elf64_x86_64_link_hash_entry *) h)->dyn_relocs != NULL
		  && _bfd_elf_is_ifunc_symbol (output_bfd, h))
d3063 1
a3063 10
	      if (! info->shared
		  && h != NULL
		  && h->dynindx != -1
		  && ! h->forced_local
		  && _bfd_elf_is_ifunc_symbol (output_bfd, h)
		  && elf_section_data (input_section)->indirect_relocs != NULL
		  && elf_section_data (input_section)->indirect_relocs->contents != NULL)
		sreloc = elf_section_data (input_section)->indirect_relocs;
	      else
		sreloc = elf_section_data (input_section)->sreloc;
d3510 1
d3573 16
d3592 7
a3598 4
      if (h->dynindx == -1
	  || htab->splt == NULL
	  || htab->sgotplt == NULL
	  || htab->srelplt == NULL)
d3604 5
a3608 2
	 first entry in the procedure linkage table is reserved.  */
      plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
d3610 12
a3621 4
      /* Get the offset into the .got table of the entry that
	 corresponds to this function.	Each .got entry is GOT_ENTRY_SIZE
	 bytes. The first three are reserved for the dynamic linker.  */
      got_offset = (plt_index + 3) * GOT_ENTRY_SIZE;
d3624 1
a3624 1
      memcpy (htab->splt->contents + h->plt.offset, elf64_x86_64_plt_entry,
d3633 2
a3634 2
		      (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d3636 2
a3637 2
		       - htab->splt->output_section->vma
		       - htab->splt->output_offset
d3640 12
a3651 7
		  htab->splt->contents + h->plt.offset + 2);
      /* Put relocation index.  */
      bfd_put_32 (output_bfd, plt_index,
		  htab->splt->contents + h->plt.offset + 7);
      /* Put offset for jmp .PLT0.  */
      bfd_put_32 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE),
		  htab->splt->contents + h->plt.offset + 12);
d3655 2
a3656 2
      bfd_put_64 (output_bfd, (htab->splt->output_section->vma
			       + htab->splt->output_offset
d3658 1
a3658 1
		  htab->sgotplt->contents + got_offset);
d3661 2
a3662 2
      rela.r_offset = (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d3664 19
a3682 3
      rela.r_info = ELF64_R_INFO (h->dynindx, R_X86_64_JUMP_SLOT);
      rela.r_addend = 0;
      loc = htab->srelplt->contents + plt_index * sizeof (Elf64_External_Rela);
@


1.154
log
@2009-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_is_ifunc_symbol): New.

	* elf32-i386.c (is_indirect_symbol): Renamed to ...
	* elflink.c (_bfd_elf_is_ifunc_symbol): This.

	* elf32-i386.c (allocate_dynrelocs): Updated.
	(elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(elf64_x86_64_relocate_section): Likewise.

	* elf64-x86-64.c (is_indirect_symbol): Removed.
@
text
@d528 3
a530 2
link_hash_newfunc (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
		   const char *string)
d569 2
a570 1
  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc,
d598 1
a598 1
create_got_section (bfd *dynobj, struct bfd_link_info *info)
d633 1
a633 1
  if (!htab->sgot && !create_got_section (dynobj, info))
d1173 2
a1174 1
	      if (!create_got_section (htab->elf.dynobj, info))
d1656 1
a1656 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d1909 1
a1909 1
readonly_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d2071 2
a2072 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);
d2203 3
a2205 1
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);
d2263 1
a2263 1
set_tls_module_base (struct bfd_link_info *info)
d2283 1
a2283 1
dtpoff_base (struct bfd_link_info *info)
d2295 1
a2295 1
tpoff (struct bfd_link_info *info, bfd_vma address)
d2348 1
a2348 1
  set_tls_module_base (info);
d2861 2
a2862 1
		  bfd_put_32 (output_bfd, tpoff (info, relocation),
d2888 2
a2889 1
		  bfd_put_32 (output_bfd, tpoff (info, relocation),
d2955 2
a2956 1
		  bfd_put_32 (output_bfd, tpoff (info, relocation),
d3011 1
a3011 1
		    outrel.r_addend = relocation - dtpoff_base (info);
d3033 1
a3033 1
		outrel.r_addend = relocation - dtpoff_base (info);
d3048 1
a3048 1
				  relocation - dtpoff_base (info),
d3228 1
a3228 1
	    relocation -= dtpoff_base (info);
d3230 1
a3230 1
	    relocation = tpoff (info, relocation);
d3235 1
a3235 1
	  relocation = tpoff (info, relocation);
@


1.153
log
@include/elf
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * common.h (STT_GNU_IFUNC): Define.

elfcpp
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * (enum STT): Add STT_GNU_IFUNC.

gas
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * config/obj-elf.c (obj_elf_type): Add support for a
        gnu_indirect_function type.
        * config/tc-i386.c (tc_i386_fix_adjustable): Do not adjust fixups
        against indirect function symbols.
        * doc/as.texinfo (.type): Document the support for the
        gnu_indirect_function symbol type.
        * NEWS: Mention the new feature.

gas/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * gas/elf/elf.exp: Extend type test to include an ifunc symbol.
        Provide an alternative test for targets which do not support ifunc
        symbols.
        (type.s): Add entry for an ifunc symbol.
        (type.e): Add ifunc entry to expected symbol dump.
        (section2.e-armelf): Add  entry for ifunc symbol.
        (type-noifunc.s): New file.
        (type-noifunc.e): New file.

bfd/
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs
        section pointer.
        (struct elf_obj_data): Add has_ifunc_symbols boolean.
        * elf.c (swap_out_syms): Convert BSF_GNU_INDIRECT_FUNCTION flags
        into a STT_GNU_IFUNC symbol type.
        (_bfd_elf_is_function_type): Accept STT_GNU_IFUNC as a function
        type.
        (_bfd_elf_set_osabi): Set the osasbi field to ELFOSABI_LINUX if
        the binary contains ifunc symbols.
        * elfcode.h (elf_slurp_symbol_table): Translate the STT_GNU_IFUNC
        symbol type into a BSF_GNU_INDIRECT_FUNCTION flag.
        * elf32-i386.c (is_indirect_function): New function.
        (elf_i386_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf_i386_relocate_section): Emit a reloc against an ifunc symbol
        if necessary.
        (elf_i386_add_symbol_hook): New function. Set the
        has_ifunc_symbols field of the elf_obj_data structure if an ifunc
        symbol is encountered.
        (elf_backend_post_process_headers): Define.
        (elf_backend_add_symbol_hook): Define.
        (elf_i386_post_process_headers): Rename to
        elf_i388_fbsd_post_process_headers.
        * elf64-x86_64.c (IS_X86_64_PCREL_TYPE): New macro.
        (is_indirect_function): New function.
        (elf64_x86_64_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf64_x86_64_relocate_section): Emit a reloc against an ifunc
        symbol if necessary.
        (elf_i386_add_symbol_hook): Set the has_ifunc_symbols field of the
        elf_obj_data structure if an ifunc symbol is encountered.
        (elf_backend_post_process_headers): Define.
        * elflink.c (_bfd_elf_adjust_dynamic_symbol): Always create a PLT
        if we have ifunc symbols to handle.
        (get_ifunc_reloc_section_name): New function.  Computes the name
        for an ifunc section.
        (_bfd_elf_make_ifunc_reloc_section): New function.  Creates a
        section to hold ifunc relocs.
        * syms.c (BSF_GNU_INDIRECT_FUNCTION): Define.
        (bfd_print_symbol_vandf): Handle ifunc symbols.
        (bfd_decode_symclass): Likewise.
        * bfd-in2.h: Regenerate.

binutils
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * readelf.c (dump_relocations): Display a relocation against an
        ifunc symbol as if it were a function invocation.
        (get_symbol_type): Handle STT_GNU_IFUNC.

ld
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * NEWS: Mention support for IFUNC symbols.

ld/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * ld-ifunc: New directory.
        * ld-ifunc/ifunc.exp: New file: Run the IFUNC tests.
        * ld-ifunc/prog.c: New file.
        * ld-ifunc/lib.c: New file.
@
text
@a985 19
/* Returns true if the hash entry refers to a symbol
   marked for indirect handling during reloc processing.  */

static bfd_boolean
is_indirect_symbol (bfd * abfd, struct elf_link_hash_entry * h)
{
  const struct elf_backend_data * bed;

  if (abfd == NULL || h == NULL)
    return FALSE;

  bed = get_elf_backend_data (abfd);

  return h->type == STT_GNU_IFUNC
    && (bed->elf_osabi == ELFOSABI_LINUX
	/* GNU/Linux is still using the default value 0.  */
	|| bed->elf_osabi == ELFOSABI_NONE);
}

d1844 1
a1844 1
  else if (is_indirect_symbol (info->output_bfd, h)
d2702 1
a2702 1
		  && is_indirect_symbol (output_bfd, h))
d2798 1
a2798 1
		  && is_indirect_symbol (output_bfd, h)
@


1.152
log
@2009-03-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/9938
	* elf32-i386.c (elf_i386_check_tls_transition): Use strncmp
	to check ___tls_get_addr.

	* elf64-x86-64.c (elf64_x86_64_check_tls_transition): Use
	strncmp to check __tls_get_addr.
@
text
@d164 6
d986 19
d1031 1
a1031 1

a1286 1

d1289 1
a1289 4
	       && (((r_type != R_X86_64_PC8)
		    && (r_type != R_X86_64_PC16)
		    && (r_type != R_X86_64_PC32)
		    && (r_type != R_X86_64_PC64))
d1317 6
d1354 1
d1367 1
a1367 4
	      if (r_type == R_X86_64_PC8
		  || r_type == R_X86_64_PC16
		  || r_type == R_X86_64_PC32
		  || r_type == R_X86_64_PC64)
d1678 1
d1757 3
a1759 1
    h->got.offset = (bfd_vma) -1;
d1858 3
a1860 5
		   && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
d1863 10
d1889 3
a1891 5
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
d1909 4
a1912 1
      sreloc = elf_section_data (p->sec)->sreloc;
d2714 8
a2721 5
	       && ((r_type != R_X86_64_PC8
		    && r_type != R_X86_64_PC16
		    && r_type != R_X86_64_PC32
		    && r_type != R_X86_64_PC64)
		   || !SYMBOL_CALLS_LOCAL (info, h)))
d2761 4
a2764 7
		       && (r_type == R_X86_64_PC8
			   || r_type == R_X86_64_PC16
			   || r_type == R_X86_64_PC32
			   || r_type == R_X86_64_PC64
			   || !info->shared
			   || !SYMBOLIC_BIND (info, h)
			   || !h->def_regular))
d2813 11
a2823 2
	      sreloc = elf_section_data (input_section)->sreloc;
		
d3709 1
a3709 1
			      struct bfd_link_info *info ATTRIBUTE_UNUSED,
d3713 2
a3714 1
			      asection **secp, bfd_vma *valp)
d3737 4
d3968 3
a3982 3
#undef  elf_backend_post_process_headers
#define elf_backend_post_process_headers  _bfd_elf_set_osabi

@


1.151
log
@Remove STT_IFUNC support.
@
text
@d813 2
d819 2
a820 1
	      && (strcmp (h->root.root.string, "__tls_get_addr") == 0));
@


1.150
log
@include/elf/
            * common.h (STT_IFUNC): Define.
elfcpp/
            * elfcpp.h (enum STT): Add STT_IFUNC.
bfd/
            * syms.c (struct bfd_symbol): Add new flag BSF_INDIRECT_FUNCTION.
            Remove redundant flag BFD_FORT_COMM_DEFAULT_VALUE.  Renumber flags
            to remove gaps.
            (bfd_print_symbol_vandf): Return 'i' for BSF_INDIRECT_FUNCTION.
            (bfd_decode_symclass): Likewise.
            * elf.c (swap_out_syms): Translate BSF_INDIRECT_FUNCTION into
            STT_IFUNC.
            (elf_find_function): Treat STT_IFUNC in the same way as STT_FUNC.
            (_bfd_elf_is_function_type): Likewise.
            * elf32-arm.c (arm_elf_find_function): Likewise.
            (elf32_arm_adjust_dynamic_symbol): Likewise.
            (elf32_arm_swap_symbol_in): Likewise.
            (elf32_arm_additional_program_headers): Likewise.
            * elf32-i386.c (is_indirect_symbol): New function.
            (elf_i386_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf_i386_relocate_section): Likewise.
            * elf64-x86-64.c (is_indirect_symbol): New function.
            (elf64_x86_64_check_relocs): Also generate dynamic relocs for
            relocations against STT_IFUNC symbols.
            (allocate_dynrelocs): Likewise.
            (elf64_x86_64_relocate_section): Likewise.
            * elfcode.h (elf_slurp_symbol_table): Translate STT_IFUNC into
            BSF_INDIRECT_FUNCTION.
            * elflink.c (_bfd_elf_adjust_dynamic_reloc_section): Add support
            for STT_IFUNC symbols.
            (get_ifunc_reloc_section_name): New function.
            (_bfd_elf_make_ifunc_reloc_section): New function.
            * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs field.
            * bfd-in2.h: Regenerate.
gas/
            * config/obj-elf.c (obj_elf_type): Add support for STT_IFUNC type.
            * doc/as.texinfo: Document new feature.
            * NEWS: Mention new feature.
gas/testsuite/
            * gas/elf/type.s: Add test of STT_IFUNC symbol type.
            * gas/elf/type.e: Update expected disassembly.
            * gas/elf/elf.exp: Update grep of symbol types.
ld/
            * NEWS: Mention new feature.
            * pe-dll.c (process_def_file): Replace use of redundant
            BFD_FORT_COMM_DEFAULT_VALUE with 0.
            * scripttempl/elf.sc: Add .rel.ifunc.dyn and .rela.ifunc.dyn
            sections.
ld/testsuite/
            * ld-mips-elf/reloc-1-n32.d: Updated expected output for reloc
            descriptions.
            * ld-mips-elf/reloc-1-n64.d: Likewise.
            * ld-i386/ifunc.d: New test.
            * ld-i386/ifunc.s: Source file for the new test.
            * ld-i386/i386.exp: Run the new test.
@
text
@a976 20
/* Returns true if the hash entry refers to a symbol
   marked for indirect handling during reloc processing.  */

static bfd_boolean
is_indirect_symbol (bfd * abfd, struct elf_link_hash_entry * h)
{
  const struct elf_backend_data * bed;

  if (abfd == NULL || h == NULL)
    return FALSE;

  bed = get_elf_backend_data (abfd);

  return h->type == STT_IFUNC
    && bed != NULL
    && (bed->elf_osabi == ELFOSABI_LINUX
	/* GNU/Linux is still using the default value 0.  */
	|| bed->elf_osabi == ELFOSABI_NONE);
}

d1258 1
a1258 1
	     symbol.
a1259 2
	     Also we must keep any relocations against IFUNC symbols as
	     they will be evaluated at load time.  */
d1275 1
a1275 2
		      || !h->def_regular))
	      || is_indirect_symbol (abfd, h))
a1294 3
	      if (is_indirect_symbol (abfd, h))
		(void) _bfd_elf_make_ifunc_reloc_section (abfd, sec, htab->elf.dynobj, 2);

a1833 7
  else if (is_indirect_symbol (info->output_bfd, h))
    {
      if (h->dynindx == -1
	  && ! h->forced_local
	  && ! bfd_elf_link_record_dynamic_symbol (info, h))
	return FALSE;    
    }
d1872 1
a1872 5
      if (! info->shared
	  && is_indirect_symbol (info->output_bfd, h))
	sreloc = elf_section_data (p->sec)->indirect_relocs;
      else
	sreloc = elf_section_data (p->sec)->sreloc;
d2687 1
a2687 2
		      || h->root.type == bfd_link_hash_undefined))
	      || is_indirect_symbol (output_bfd, h))
d2773 1
a2773 4
	      if ((! info->shared) && is_indirect_symbol (output_bfd, h))
		sreloc = elf_section_data (input_section)->indirect_relocs;
	      else
		sreloc = elf_section_data (input_section)->sreloc;
d2785 1
a2785 1
	      if (! relocate || is_indirect_symbol (output_bfd, h))
@


1.149
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d977 20
d1278 4
a1281 1
	     symbol.  */
d1297 2
a1298 1
		      || !h->def_regular)))
d1318 3
d1860 7
d1903 10
a1912 1
      asection *sreloc = elf_section_data (p->sec)->sreloc;
a2015 1

d2084 1
a2084 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);
d2215 1
a2215 2
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
				    (PTR) info);
d2724 2
a2725 1
		      || h->root.type == bfd_link_hash_undefined)))
d2811 6
a2816 3
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
d2826 1
a2826 1
	      if (! relocate)
@


1.148
log
@bfd/ChangeLog:
* elf32-i386.c (struct elf_i386_link_hash_table): Added field
tls_module_base.
(elf_i386_link_hash_table_create): Initialize it.
(elf_i386_always_size_sections): Set it.
(set_tls_module_base): New.
(elf_i386_relocate_sections): Call it.
* elf64-x86-64.c (struct elf64_x86_64_link_hash_table): Added
field tls_module_base.
(elf64_x86_64_link_hash_table_create): Initialize it.
(elf64_x86_64_always_size_sections): Set it.
(set_tls_module_base): New.
(elf64_x86_64_relocate_sections): Call it.
Reported by Cary Coutant <ccoutant@@google.com>
ld/testsuite/ChangeLog:
* ld-i386/tlsbindesc.dd: Adjust incorrect expectations for LD to
LE relaxation.
* ld-x86-64/tlsbindesc.dd: Likewise.
* ld-i386/tlsbindesc.rd: Adjust address of _TLS_MODULE_BASE_.
* ld-x86-64/tlsbindesc.rd: Likewise.
Reported by Cary Coutant <ccoutant@@google.com>
@
text
@a1283 19
		  const char *name;
		  bfd *dynobj;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  if (! CONST_STRNEQ (name, ".rela")
		      || strcmp (bfd_get_section_name (abfd, sec),
				 name + 5) != 0)
		    {
		      (*_bfd_error_handler)
			(_("%B: bad relocation section name `%s\'"),
			 abfd, name);
		    }

d1287 2
a1288 1
		  dynobj = htab->elf.dynobj;
a1289 1
		  sreloc = bfd_get_section_by_name (dynobj, name);
d1291 1
a1291 15
		    {
		      flagword flags;

		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      sreloc = bfd_make_section_with_flags (dynobj,
							    name,
							    flags);
		      if (sreloc == NULL
			  || ! bfd_set_section_alignment (dynobj, sreloc, 3))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
@


1.147
log
@bfd/

2008-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/5789
	PR ld/5943
	* elf32-i386.c  (elf_i386_relocate_section): Issue an error
	for R_386_GOTOFF relocaton against undefined hidden/internal
	symbols when building a shared object.

	* elf64-x86-64.c (elf64_x86_64_relocate_section): Issue an
	error for R_X86_64_PC8/R_X86_64_PC16/R_X86_64_PC32
	relocaton against undefined hidden/internal symbols when
	building a shared object.
	(elf64_x86_64_finish_dynamic_symbol): Return FALSE when symbol
	is referenced locally, but isn't defined in a regular file.

ld/testsuite/

2008-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/5789
	PR ld/5943
	* ld-i386/hidden1.d: New.
	* ld-i386/hidden1.s: Likewise.
	* ld-i386/hidden2.d: Likewise.
	* ld-i386/hidden2.s: Likewise.
	* ld-i386/hidden3.d: Likewise.
	* ld-i386/hidden4.s: Likewise.
	* ld-i386/protected1.d: Likewise.
	* ld-i386/protected1.s: Likewise.
	* ld-i386/protected2.d: Likewise.
	* ld-i386/protected2.s: Likewise.
	* ld-i386/protected3.d: Likewise.
	* ld-i386/protected3.s: Likewise.
	* ld-x86-64/hidden1.d: Likewise.
	* ld-x86-64/hidden1.s: Likewise.
	* ld-x86-64/hidden2.d: Likewise.
	* ld-x86-64/hidden2.s: Likewise.
	* ld-x86-64/hidden3.d: Likewise.
	* ld-x86-64/hidden3.s: Likewise.
	* ld-x86-64/protected1.d: Likewise.
	* ld-x86-64/protected1.s: Likewise.
	* ld-x86-64/protected2.d: Likewise.
	* ld-x86-64/protected2.s: Likewise.
	* ld-x86-64/protected3.d: Likewise.
	* ld-x86-64/protected3.s: Likewise.

	* ld-i386/i386.exp: Run hidden1, hidden2, hidden3, protected1,
	protected2 and protected3.
	* ld-x86-64/x86-64.exp: Likewise.
@
text
@d506 3
d581 1
d2246 3
d2259 21
d2350 2
@


1.146
log
@PR ld/5692
   * elf-bfd.h (enum elf_object_id): New enum, used to identify
   target specific extensions to the elf_obj_tdata structure.
   (struct elf_obj_tdata): New field 'object_id'.
   (elf_object_id, elf_program_header_size, elf_symtab_hdr): New
   macros for accessing fields in the elf_obj_tdata structure.
   (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object.
   (bfd_elf_allocate_object): New function.
   * elf.c (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object
   and implement by calling bfd_elf_allocate_object.
   (bfd_elf_allocate_object): New function: Allocates an
   elf_obj_tdata structure, possibly with a target specific
   extension.
   * elfxx-target.h (bfd_elfNN_mkobject): Use
   bfd_elf_make_generic_object as the default value.
   * elf32-arm.c (elf32_arm_obj_tdata): Rename to elf_arm_obj_tdata
   for consistency with other, similar structures.
   (is_arm_elf): New macro.  Checks a BFD to make sure that is an ARM
   ELF bfd.
   (elf32_arm_mkobject): Call bfd_elf_allocate_object.
   (bfd_elf32_arm_vfp11_erratum_scan): Use is_arm_elf macro to check
   the bfd being processed.
   (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
   (bfd_elf32_arm_set_target_relocs): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_copy_private_bfd_data): Likewise.
   (bfd_elf32_arm_merge_eabi_attributes): Likewise.
   (bfd_elf32_arm_merge_private_bfd_data): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_gc_mark_extra_sections): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   (bfd_elf32_arm_process_before_allocation): Use elf_symtab_hdr.
   (bfd_elf32_arm_init_maps): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_relocate_section): Likewise.
   (bfd_elf32_arm_gc_sweep_hook): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   * elf32-i386.c (elf_i386_mkobject): Call bfd_elf_allocate_object.
   (is_i386_elf): New macro.  Checks a BFD to make sure that is an x86
   ELF bfd.
   (elf_i386_check_relocs): Use is_i386_elf macro to check    the bfd
   being processed.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   (elf_i386_check_relocs): Use elf_symtab_hdr.
   (elf_i386_gc_sweep_hook): Likewise.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   * elf32-ppc.c (ppc_elf_mkobject): Call bfd_elf_allocate_object.
   (elf_create_pointer_linker_section): Use is_ppc_elf_target to
   verify that the bfd before accessing target specific fields.
   (ppc_elf_check_relocs): Likewise.
   (elf_finish_pointer_linker_section): Likewise.
   (elf_create_pointer_linker_section): Use elf_symtab_hdr.
   (ppc_elf_check_relocs): Likewise.
   (ppc_elf_gc_sweep_hook): Likewise.
   (ppc_elf_tls_optimize): Likewise.
   (ppc_elf_size_dynamic_sections): Likewise.
   (ppc_elf_relax_section): Likewise.
   (ppc_elf_relocate_section): Likewise.
   * elf32-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf64-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf32-sh.c (sh_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sh_elf): New macro.  Checks a BFD to make sure that is an SH
   ELF bfd.
   (sh_elf_size_dynamic_sections): Use is_sh_elf macro to check the
   bfd being processed.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_check_relocs): Likewise.
   (sh_elf_copy_private_data): Likewise.
   (sh_elf_relax_section): Use elf_symtab_hdr.
   (sh_elf_size_dynamic_sections): Likewise.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_get_relocated_section_contents): Likewise.
   (sh_elf_gc_sweep_hook): Likewise.
   (sh_elf_check_relocs): Likewise.
   * elf64-alpha.c (elf64_alpha_mkobject): Call bfd_elf_allocate_object.
   (is_alpha_elf): New macro.  Checks a BFD to make sure that is an
   Alpha ELF bfd.
   (elf64_alpha_create_got_section): Use is_alpha_elf macro to check
   the bfd being processed.
   (elf64_alpha_create_dynamic_section): Likewise.
   (elf64_alpha_check_relocs): Likewise.
   (elf64_alpha_size_got_sections): Likewise.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   (elf64_alpha_final_link): Likewise.
   (elf64_alpha_check_relocs): Use elf_symtab_hdr.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section_r): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   * elf64-ppc.c (ppc64_elf_mkobject): Call bfd_elf_allocate_object.
   (ppc64_elf_check_relocs): Use is_ppc64_elf_target to check the bfd
   being processed.
   (opd_entry_value): Likewise.
   (allocate_dynrelocs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   (ppc64_elf_check_relocs): Use elf_symtab_hdr.
   (opd_entry_value): Likewise.
   (ppc64_elf_gc_sweep_hook): Likewise.
   (get_sym_h): Likewise.
   (ppc64_elf_edit_opd): Likewise.
   (ppc64_elf_tls_optimize): Likewise.
   (ppc64_elf_edit_toc): Likewise.
   (ppc64_elf_size_dynamic_sections): Likewise.
   (toc_adjusting_stub_needed): Likewise.
   (ppc64_elf_size_stubs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   * elf64-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf32-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf64-x86_64.c (elf64_x86_64_mkobject): Call bfd_elf_allocate_object.
   (is_x86_64_elf): New macro.  Checks a BFD to make sure that is an
   x86_64 ELF bfd.
   (elf64_x86_64_check_relocs): Use is_x86_64_elf macro to check the bfd
   being processed.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   (elf64_x86_64_check_relocs): Use elf_symtab_hdr.
   (elf64_x86_64_gc_sweep_hook): Likewise.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   * elfxx-sparc.c (_bfd_sparc_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sparc_elf): New macro.  Checks a BFD to make sure that is a Sparc
   ELF bfd.
   (_bfd_sparc_elf_check_relocs): Use is_sparc_elf macro to check the
   bfd being processed.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_check_relocs): Use elf_symtab_hdr.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@a2597 1
	      && !SYMBOL_REFERENCES_LOCAL (info, h)
d2600 1
a2600 6
	      && (!h->def_regular
		  || r_type != R_X86_64_PC32
		  || h->type != STT_FUNC
		  || ELF_ST_VISIBILITY (h->other) != STV_PROTECTED
		  || !is_32bit_relative_branch (contents,
						rel->r_offset)))
d2602 11
a2612 7
	      if (h->def_regular
		  && r_type == R_X86_64_PC32
		  && h->type == STT_FUNC
		  && ELF_ST_VISIBILITY (h->other) == STV_PROTECTED)
		(*_bfd_error_handler)
		   (_("%B: relocation R_X86_64_PC32 against protected function `%s' can not be used when making a shared object"),
		    input_bfd, h->root.root.string);
d2614 41
a2654 6
		(*_bfd_error_handler)
		  (_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		   input_bfd, x86_64_elf_howto_table[r_type].name,
		   h->root.root.string);
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
d3379 2
@


1.145
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d460 12
a707 13
elf64_x86_64_mkobject (bfd *abfd)
{
  if (abfd->tdata.any == NULL)
    {
      bfd_size_type amt = sizeof (struct elf64_x86_64_obj_tdata);
      abfd->tdata.any = bfd_zalloc (abfd, amt);
      if (abfd->tdata.any == NULL)
	return FALSE;
    }
  return bfd_elf_mkobject (abfd);
}

static bfd_boolean
d992 2
d995 1
a995 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d1434 1
a1434 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d1976 1
a1976 1
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
d2011 1
a2011 1
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d2314 2
d2317 1
a2317 1
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
@


1.144
log
@	PR ld/4424
	* config.bfd (targ_selvecs): Add bfd_elf64_alpha_vec for
	alpha/FreeBSD.  Add bfd_elf64_sparc_vec for sparc64/FreeBSD.
	Add bfd_elf32_i386_vec and bfd_efi_app_ia32_vec for i386/FreeBSD.
	(targ64_selvecs): Set for i386/FreeBSD.
	* elf-bfd.h (elf_backend_data): Add relocs_compatible.
	(_bfd_elf_default_relocs_compatible): Declare.
	(_bfd_elf_relocs_compatible): Declare.
	* elfxx-target.h (elf_backend_relocs_compatible): Define.
	(elfNN_bed): Init new relocs_compatible field.
	* elflink.c (_bfd_elf_default_relocs_compatible): New function.
	(_bfd_elf_relocs_compatible): New function.
	(elf_link_add_object_symbols): Call bed->relocs_compatible.
	* elf32-i386.c (elf_backend_relocs_compatible): Define.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d1428 3
@


1.143
log
@PR linker/5099
* elf64-x86-64.c (elf64_x86_64_check_relocs): Add missing apostrophe to error message.
@
text
@d3829 1
@


1.142
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d1133 1
a1133 1
		      (_("%B: %s' accessed both as normal and thread local symbol"),
@


1.141
log
@2007-09-11  Jan Beulich  <jbeulich@@novell.com>

	* elf64-i386.c (elf64_i386_tls_transition): Remove redundant 'const'.
	* elf64-x86_64.c (elf64_x86_64_tls_transition): Likewise.
@
text
@d1381 3
a1383 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.140
log
@2007-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf64_x86_64_relocate_section): Adjust
	indentation.
@
text
@d955 1
a955 1
      const reloc_howto_type *from, *to;
@


1.139
log
@bfd/

2007-08-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c: Include "bfd_stdint.h".
	(elf_i386_rtype_to_howto): New function.
	(elf_i386_info_to_howto_rel): Use it.
	(x86_64_opcode16): New union type.
	(elf_i386_check_tls_transition): New function.
	(elf_i386_tls_transition): Updated to check transition and
	issue an error if a transition isn't supported.
	(elf_i386_check_relocs): Return FALSE if
	elf_i386_tls_transition returns FALSE.
	(elf_i386_gc_sweep_hook): Likewise.
	(elf_i386_relocate_section): Likewise. Remove BFD_ASSERT
	on TLS transitions.

	* elf64-x86-64.c: Include "bfd_stdint.h".
	(x86_64_opcode16): New union type.
	(x86_64_opcode32): Likewise.
	(elf64_x86_64_check_tls_transition): New function.
	(elf64_x86_64_tls_transition): Updated to check transition and
	issue an error if a transition isn't supported.
	(elf64_x86_64_check_relocs): Return FALSE if
	elf64_x86_64_tls_transition returns FALSE.
	(elf64_x86_64_gc_sweep_hook): Likewise.
	(elf64_x86_64_relocate_section): Likewise. Remove BFD_ASSERT
	on TLS transitions.

ld/testsuite/

2007-08-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-i386/tlsbinpic.s: Add a new GD -> IE test.

	* ld-i386/tlsgd1.s: Add a new GD -> LE test.

	* ld-i386/tlsbin.dd: Updated.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsgd1.dd: Likewise.
@
text
@d2764 1
a2764 1
	      return FALSE;
@


1.138
log
@2007-08-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c: Remove trailing whitespace.
	* elfxx-ia64.c: Likewise.
@
text
@d28 1
d716 170
a885 2
static int
elf64_x86_64_tls_transition (struct bfd_link_info *info, int r_type,
d888 3
a890 2
  if (info->shared)
    return r_type;
d892 1
a892 1
  switch (r_type)
d898 38
a935 3
      if (h == NULL)
	return R_X86_64_TPOFF32;
      return R_X86_64_GOTTPOFF;
d937 31
a967 1
      return R_X86_64_TPOFF32;
d970 2
a971 1
   return r_type;
d979 2
a980 1
elf64_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
d1026 6
a1031 1
      r_type = elf64_x86_64_tls_transition (info, r_type, h);
d1418 2
a1419 1
			    asection *sec, const Elf_Internal_Rela *relocs)
d1462 6
a1467 1
      r_type = elf64_x86_64_tls_transition (info, r_type, h);
a2752 1
	  r_type = elf64_x86_64_tls_transition (info, r_type, h);
d2757 8
a2764 12
	    {
	      tls_type = elf64_x86_64_hash_entry (h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type == GOT_TLS_IE)
		r_type = R_X86_64_TPOFF32;
	    }
	  if (r_type == R_X86_64_TLSGD
	      || r_type == R_X86_64_GOTPC32_TLSDESC
	      || r_type == R_X86_64_TLSDESC_CALL)
	    {
	      if (tls_type == GOT_TLS_IE)
		r_type = R_X86_64_GOTTPOFF;
	    }
d2768 2
d2771 1
a2773 6
		  unsigned int i;
		  static unsigned char tlsgd[8]
		    = { 0x66, 0x48, 0x8d, 0x3d, 0x66, 0x66, 0x48, 0xe8 };
		  unsigned long tls_r_symndx;
		  struct elf_link_hash_entry *tls_h;

d2780 1
a2780 22
		  BFD_ASSERT (rel->r_offset >= 4);
		  for (i = 0; i < 4; i++)
		    BFD_ASSERT (bfd_get_8 (input_bfd,
					   contents + rel->r_offset - 4 + i)
				== tlsgd[i]);
		  BFD_ASSERT (rel->r_offset + 12 <= input_section->size);
		  for (i = 0; i < 4; i++)
		    BFD_ASSERT (bfd_get_8 (input_bfd,
					   contents + rel->r_offset + 4 + i)
				== tlsgd[i+4]);
		  BFD_ASSERT (rel + 1 < relend);
		  tls_r_symndx = ELF64_R_SYM (rel[1].r_info);
		  BFD_ASSERT (tls_r_symndx >= symtab_hdr->sh_info);
		  tls_h = sym_hashes[tls_r_symndx - symtab_hdr->sh_info];
		  BFD_ASSERT (tls_h != NULL
			      && tls_h->root.root.string != NULL
			      && strcmp (tls_h->root.root.string,
					 "__tls_get_addr") == 0);
		  BFD_ASSERT ((! info->shared
			       && ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PC32)
			      || ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
		  memcpy (contents + rel->r_offset - 4,
d2784 1
a2784 1
			      contents + rel->r_offset + 8);
d2797 1
a2797 2

		     Registers other than %rax may be set up here.  */
a2799 1
		  bfd_vma roff;
a2800 5
		  /* First, make sure it's a leaq adding rip to a
		     32-bit offset into any register, although it's
		     probably almost always going to be rax.  */
		  roff = rel->r_offset;
		  BFD_ASSERT (roff >= 3);
a2801 1
		  BFD_ASSERT ((type & 0xfb) == 0x48);
a2802 1
		  BFD_ASSERT (type2 == 0x8d);
a2803 4
		  BFD_ASSERT ((val & 0xc7) == 0x05);
		  BFD_ASSERT (roff + 4 <= input_section->size);

		  /* Now modify the instruction as appropriate.  */
d2819 1
a2819 15
		     nop; nop.  */

		  unsigned int val, type;
		  bfd_vma roff;

		  /* First, make sure it's a call *(%rax).  */
		  roff = rel->r_offset;
		  BFD_ASSERT (roff + 2 <= input_section->size);
		  type = bfd_get_8 (input_bfd, contents + roff);
		  BFD_ASSERT (type == 0xff);
		  val = bfd_get_8 (input_bfd, contents + roff + 1);
		  BFD_ASSERT (val == 0x10);

		  /* Now modify the instruction as appropriate.  Use
		     xchg %ax,%ax instead of 2 nops.  */
d2824 1
a2824 1
	      else
a2825 2
		  unsigned int val, type, reg;

d2834 6
a2839 7
		  BFD_ASSERT (rel->r_offset >= 3);
		  val = bfd_get_8 (input_bfd, contents + rel->r_offset - 3);
		  BFD_ASSERT (val == 0x48 || val == 0x4c);
		  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);
		  BFD_ASSERT (type == 0x8b || type == 0x03);
		  reg = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
		  BFD_ASSERT ((reg & 0xc7) == 5);
a2840 1
		  BFD_ASSERT (rel->r_offset + 4 <= input_section->size);
d2846 1
a2846 1
				   contents + rel->r_offset - 3);
d2848 1
a2848 1
				 contents + rel->r_offset - 2);
d2850 1
a2850 1
				 contents + rel->r_offset - 1);
d2858 1
a2858 1
				   contents + rel->r_offset - 3);
d2860 1
a2860 1
				 contents + rel->r_offset - 2);
d2862 1
a2862 1
				 contents + rel->r_offset - 1);
d2869 1
a2869 1
				   contents + rel->r_offset - 3);
d2871 1
a2871 1
				 contents + rel->r_offset - 2);
d2873 1
a2873 1
				 contents + rel->r_offset - 1);
d2876 1
a2876 1
			      contents + rel->r_offset);
d2879 2
d3007 1
a3007 1
	  else if (ELF64_R_TYPE (rel->r_info) == R_X86_64_TLSGD)
d3009 66
a3074 70
	      unsigned int i;
	      static unsigned char tlsgd[8]
		= { 0x66, 0x48, 0x8d, 0x3d, 0x66, 0x66, 0x48, 0xe8 };

	      /* GD->IE transition.
		 .byte 0x66; leaq foo@@tlsgd(%rip), %rdi
		 .word 0x6666; rex64; call __tls_get_addr@@plt
		 Change it into:
		 movq %fs:0, %rax
		 addq foo@@gottpoff(%rip), %rax */
	      BFD_ASSERT (rel->r_offset >= 4);
	      for (i = 0; i < 4; i++)
		BFD_ASSERT (bfd_get_8 (input_bfd,
				       contents + rel->r_offset - 4 + i)
			    == tlsgd[i]);
	      BFD_ASSERT (rel->r_offset + 12 <= input_section->size);
	      for (i = 0; i < 4; i++)
		BFD_ASSERT (bfd_get_8 (input_bfd,
				       contents + rel->r_offset + 4 + i)
			    == tlsgd[i+4]);
	      BFD_ASSERT (rel + 1 < relend);
	      BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
	      memcpy (contents + rel->r_offset - 4,
		      "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0",
		      16);

	      relocation = (htab->sgot->output_section->vma
			    + htab->sgot->output_offset + off
			    - rel->r_offset
			    - input_section->output_section->vma
			    - input_section->output_offset
			    - 12);
	      bfd_put_32 (output_bfd, relocation,
			  contents + rel->r_offset + 8);
	      /* Skip R_X86_64_PLT32.  */
	      rel++;
	      continue;
	    }
	  else if (ELF64_R_TYPE (rel->r_info) == R_X86_64_GOTPC32_TLSDESC)
	    {
	      /* GDesc -> IE transition.
		 It's originally something like:
		 leaq x@@tlsdesc(%rip), %rax

		 Change it to:
		 movq x@@gottpoff(%rip), %rax # before nop; nop

		 Registers other than %rax may be set up here.  */

	      unsigned int val, type, type2;
	      bfd_vma roff;

	      /* First, make sure it's a leaq adding rip to a 32-bit
		 offset into any register, although it's probably
		 almost always going to be rax.  */
	      roff = rel->r_offset;
	      BFD_ASSERT (roff >= 3);
	      type = bfd_get_8 (input_bfd, contents + roff - 3);
	      BFD_ASSERT ((type & 0xfb) == 0x48);
	      type2 = bfd_get_8 (input_bfd, contents + roff - 2);
	      BFD_ASSERT (type2 == 0x8d);
	      val = bfd_get_8 (input_bfd, contents + roff - 1);
	      BFD_ASSERT ((val & 0xc7) == 0x05);
	      BFD_ASSERT (roff + 4 <= input_section->size);

	      /* Now modify the instruction as appropriate.  */
	      /* To turn a leaq into a movq in the form we use it, it
		 suffices to change the second byte from 0x8d to
		 0x8b.  */
	      bfd_put_8 (output_bfd, 0x8b, contents + roff - 2);
d3076 1
a3076 34
	      bfd_put_32 (output_bfd,
			  htab->sgot->output_section->vma
			  + htab->sgot->output_offset + off
			  - rel->r_offset
			  - input_section->output_section->vma
			  - input_section->output_offset
			  - 4,
			  contents + roff);
	      continue;
	    }
	  else if (ELF64_R_TYPE (rel->r_info) == R_X86_64_TLSDESC_CALL)
	    {
	      /* GDesc -> IE transition.
		 It's originally:
		 call *(%rax)

		 Change it to:
		 nop; nop.  */

	      unsigned int val, type;
	      bfd_vma roff;

	      /* First, make sure it's a call *(%eax).  */
	      roff = rel->r_offset;
	      BFD_ASSERT (roff + 2 <= input_section->size);
	      type = bfd_get_8 (input_bfd, contents + roff);
	      BFD_ASSERT (type == 0xff);
	      val = bfd_get_8 (input_bfd, contents + roff + 1);
	      BFD_ASSERT (val == 0x10);

	      /* Now modify the instruction as appropriate.  Use
		 xchg %ax,%ax instead of 2 nops.  */
	      bfd_put_8 (output_bfd, 0x66, contents + roff);
	      bfd_put_8 (output_bfd, 0x90, contents + roff + 1);
d3078 8
a3085 1
	      continue;
a3086 2
	  else
	    BFD_ASSERT (FALSE);
d3090 8
a3097 1
	  if (! info->shared)
a3098 3
	      unsigned long tls_r_symndx;
	      struct elf_link_hash_entry *tls_h;

a3099 1
		 Ensure it is:
d3103 2
a3104 20
	      BFD_ASSERT (rel->r_offset >= 3);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 3)
			  == 0x48);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 2)
			  == 0x8d);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 1)
			  == 0x3d);
	      BFD_ASSERT (rel->r_offset + 9 <= input_section->size);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset + 4)
			  == 0xe8);
	      BFD_ASSERT (rel + 1 < relend);
	      tls_r_symndx = ELF64_R_SYM (rel[1].r_info);
	      BFD_ASSERT (tls_r_symndx >= symtab_hdr->sh_info);
	      tls_h = sym_hashes[tls_r_symndx - symtab_hdr->sh_info];
	      BFD_ASSERT (tls_h != NULL
			  && tls_h->root.root.string != NULL
			  && strcmp (tls_h->root.root.string,
				     "__tls_get_addr") == 0);
	      BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PC32
			  || ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
@


1.137
log
@2007-08-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_tls_transition): Accept a pointer
	to ELF hash entry instead of an integer for local test.
	(elf_i386_check_relocs): Updated.
	(elf_i386_gc_sweep_hook): Likewise.
	(elf_i386_relocate_section): Likewise.

	* elf64-x86-64.c  (elf64_x86_64_tls_transition): Accept a
	pointer to ELF hash entry instead of an integer for local
	test.
	(elf64_x86_64_check_relocs): Updated.
	(elf64_x86_64_gc_sweep_hook): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
@
text
@d3606 1
a3606 1
	*psec = *sec = bfd_com_section_ptr; 
d3617 1
a3617 1
  int count = 0; 
d3647 1
a3647 1
static const struct bfd_elf_special_section 
@


1.136
log
@2007-08-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_tls_transition): Break long line.
	* elf64-x86-64.c (elf64_x86_64_tls_transition): Likewise.
@
text
@d717 1
a717 1
			     int is_local)
d728 1
a728 1
      if (is_local)
d789 1
a789 1
      r_type = elf64_x86_64_tls_transition (info, r_type, h == NULL);
d1219 1
a1219 1
      r_type = elf64_x86_64_tls_transition (info, r_type, h != NULL);
d2505 1
a2505 1
	  r_type = elf64_x86_64_tls_transition (info, r_type, h == NULL);
@


1.135
log
@bfd/

2007-08-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4918
	* elf32-i386.c (elf_i386_relocate_section): Allow R_386_PC32
	on ___tls_get_addr for GD->LE/LD->LE transitions when not
	building shared library.

	* elf64-x86-64.c (elf64_x86_64_relocate_section): Allow
	R_X86_64_PC32 on __tls_get_addr for GD->LE/LD->LE transitions
	when not building shared library.

ld/testsuite/

2007-08-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4918
	* ld-i386/i386.exp (i386tests): Add tlsgd1 and tlsld1 tests.
	* ld-x86-64/x86-64.exp (x86_64tests): Likewise.

	* ld-i386/tlsgd1.dd: New file.
	* ld-i386/tlsgd1.s: Likewise.
	* ld-i386/tlsld1.dd: Likewise.
	* ld-i386/tlsld1.s: Likewise.
	* ld-x86-64/tlsgd1.dd: Likewise.
	* ld-x86-64/tlsgd1.s: Likewise.
	* ld-x86-64/tlsld1.dd: Likewise.
	* ld-x86-64/tlsld1.s: Likewise.
@
text
@d716 2
a717 1
elf64_x86_64_tls_transition (struct bfd_link_info *info, int r_type, int is_local)
@


1.134
log
@Switch sources over to use the GPL version 3
@
text
@d2530 2
d2535 1
a2535 1
		     .word 0x6666; rex64; call __tls_get_addr@@plt
d2550 10
a2559 1
		  BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
d2565 1
a2565 1
		  /* Skip R_X86_64_PLT32.  */
d2933 3
d2938 1
a2938 1
		 leaq foo@@tlsld(%rip), %rdi; call __tls_get_addr@@plt.
d2952 9
a2960 1
	      BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
d2963 1
a2963 1
	      /* Skip R_X86_64_PLT32.  */
@


1.133
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.132
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a1289 1
  unsigned int power_of_two;
a1406 10
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.	16-bytes is the size
     of the largest type that requires hard alignment -- long double.  */
  /* FIXME: This is VERY ugly. Should be fixed for all architectures using
     this construct.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 4)
    power_of_two = 4;

  /* Apply the required alignment.  */
a1407 6
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
    {
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
	return FALSE;
    }
d1409 1
a1409 8
  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.131
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d22 1
a23 1
#include "sysdep.h"
@


1.130
log
@2007-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3826
	* elf-bfd.h (elf_backend_data): Add elf_osabi.
	(_bfd_elf_set_osabi): New.

	* elf.c (_bfd_elf_set_osabi): New.

	* elf32-hppa.c (elf32_hppa_post_process_headers): Removed.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.
	(ELF_OSABI): Properly defined for each target.

	* elf32-i370.c (i370_elf_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf32-i386.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf_i386_post_process_headers): Set EI_OSABI with elf_osabi.

	* elf32-msp430.c (elf32_msp430_post_process_headers): Removed.
	(ELF_OSABI): Defined.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-alpha.c (ELF_OSABI): Defined to ELFOSABI_FREEBSD for
	freebsd.
	(elf64_alpha_fbsd_post_process_headers): Set EI_OSABI with
	elf_osabi.

	* elf64-hppa.c (elf64_hppa_post_process_headers): Set EI_OSABI
	with elf_osabi.
	(ELF_OSABI): Properly defined for each target.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi for Linux.

	* elf64-sparc.c (elf64_sparc_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elf64-x86-64.c (elf64_x86_64_fbsd_post_process_headers): Removed.
	(ELF_OSABI): Defined to ELFOSABI_FREEBSD for freebsd.
	(elf_backend_post_process_headers): Defined with
	_bfd_elf_set_osabi.

	* elfcode.h (elf_object_p): Match the ELFOSABI_NONE ELF target
	with any ELF target of the compatible machine for which we do not
	have a specific backend.

	* elfxx-ia64.c (elfNN_hpux_post_process_headers): Set EI_OSABI
	with elf_osabi.

	* elfxx-target.h (ELF_OSABI): Default to ELFOSABI_NONE.
	(elfNN_bed): Initialize elf_osabi with ELF_OSABI.
@
text
@d249 17
d3680 2
@


1.129
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d3716 2
a3717 15
/* The kernel recognizes executables as valid only if they carry a
   "FreeBSD" label in the ELF header.  So we put this label on all
   executables and (for simplicity) also all other object files.  */

static void
elf64_x86_64_fbsd_post_process_headers (bfd * abfd,
					struct bfd_link_info * link_info ATTRIBUTE_UNUSED)
{
  Elf_Internal_Ehdr * i_ehdrp;	/* ELF file header, internal form.  */

  i_ehdrp = elf_elfheader (abfd);

  /* Put an ABI label supported by FreeBSD >= 4.1.  */
  i_ehdrp->e_ident[EI_OSABI] = ELFOSABI_FREEBSD;
}
d3720 1
a3720 1
#define elf_backend_post_process_headers  elf64_x86_64_fbsd_post_process_headers
@


1.128
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006
a2064 3
  if (info->relocatable)
    return TRUE;

d2120 15
a2381 9
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0)
	    {
	      _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	      break;
	    }

@


1.127
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d2373 7
a2379 2
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
@


1.126
log
@2006-09-29  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3283
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Don't ignore
	relocation overflow on branches to undefweaks.
@
text
@d2460 5
d2467 6
a2472 1
			  BFD_ASSERT (sindx > 0);
d3670 1
@


1.125
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@a3019 6
	      if (h != NULL
		  && h->root.type == bfd_link_hash_undefweak
		  && howto->pc_relative)
		/* Ignore reloc overflow on branches to undefweak syms.  */
		continue;

@


1.124
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d1137 1
a1137 1
			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
d1143 6
a1148 24
    {
      switch (ELF64_R_TYPE (rel->r_info))
	{
	case R_X86_64_GNU_VTINHERIT:
	case R_X86_64_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;

	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d1150 1
a1150 1
  return NULL;
@


1.123
log
@bfd/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_link_hash_entry): Add a dynamic field.
	(bfd_elf_link_mark_dynamic_symbol): New.
	(SYMBOLIC_BIND): New.

	* elf32-i386.c (elf_i386_check_relocs): Replace info->symbolic
	with SYMBOLIC_BIND (info, h).
	(elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_check_relocs): Likewise.

	* elflink.c (bfd_elf_link_mark_dynamic_symbol): New.
	(bfd_elf_record_link_assignment): Call
	bfd_elf_link_mark_dynamic_symbol on new entry.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_export_symbol): Return if the symbol isn't exported.
	(_bfd_elf_fix_symbol_flags): Replace info->symbolic with
	SYMBOLIC_BIND (info, h).
	(_bfd_elf_dynamic_symbol_p): Likewise.
	(_bfd_elf_symbol_refs_local_p): Likewise.
	(bfd_elf_size_dynamic_sections): Updated.

include/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_elf_dynamic_list): New.
	(bfd_link_info): Add a dynamic field.

ld/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (CXX): Set to g++.
	(CXX_FOR_TARGET): Likewise.
	* Makefile.in: Regenerated.

	* NEWS: Mention --dynamic-list.

	* ld.texinfo: Document --dynamic-list.

	* ldgram.y: Support dynamic list.

	* ldlang.c (lang_process): Call lang_finalize_version_expr_head
	on link_info.dynamic if needed.
	(lang_append_dynamic_list): New.
	(lang_append_dynamic_list_cpp_typeinfo): New.
	* ldlang.h (lang_append_dynamic_list): Likewise.
	* ldlang.h (lang_append_dynamic_list_cpp_typeinfo): Likewise.

	* ldlex.h (input_enum): Add input_dynamic_list.
	* ldlex.l: Handle it.

	* ldmain.c (main): Initialize link_info.dynamic.

	* lexsup.c (option_values): Add OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.
	(ld_options): Add entries for OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.
	(parse_args): Handle OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.

ld/testsuite/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/dl1.c: New file.
	* ld-elf/dl1.list: Likewise.
	* ld-elf/dl1.out: Likewise.
	* ld-elf/dl1main.c: Likewise.
	* ld-elf/dl2.c: Likewise.
	* ld-elf/dl2.list: Likewise.
	* ld-elf/dl2a.out: Likewise.
	* ld-elf/dl2b.out: Likewise.
	* ld-elf/dl2main.c: Likewise.
	* ld-elf/dl2xxx.c: Likewise.
	* ld-elf/dl2xxx.list: Likewise.
	* ld-elf/dl3.cc: Likewise.
	* ld-elf/dl3.list: Likewise.
	* ld-elf/dl3a.out: Likewise.
	* ld-elf/dl3b.out: Likewise.
	* ld-elf/dl3header.h: Likewise.
	* ld-elf/dl3main.cc: Likewise.

	* ld-elf/shared.exp: Updated.

	* lib/ld-lib.exp (run_ld_link_exec_tests): Take an optional
	argument for source language. Use CC/CXX for link, depending
	on source language.
	(run_cc_link_tests): Likewise.
@
text
@d1028 1
a1028 1
		  if (strncmp (name, ".rela", 5) != 0
d1886 1
a1886 1
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
d3639 7
a3645 7
  { ".gnu.linkonce.lb",	16, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_X86_64_LARGE},
  { ".gnu.linkonce.lr",	16, -2, SHT_PROGBITS, SHF_ALLOC + SHF_X86_64_LARGE},
  { ".gnu.linkonce.lt",	16, -2, SHT_PROGBITS, SHF_ALLOC + SHF_EXECINSTR + SHF_X86_64_LARGE},
  { ".lbss",	5, -2, SHT_NOBITS,   SHF_ALLOC + SHF_WRITE + SHF_X86_64_LARGE},
  { ".ldata",	6, -2, SHT_PROGBITS, SHF_ALLOC + SHF_WRITE + SHF_X86_64_LARGE},
  { ".lrodata",	8, -2, SHT_PROGBITS, SHF_ALLOC + SHF_X86_64_LARGE},
  { NULL,	0,  0, 0,            0 }
@


1.122
log
@PR binutils/2983
* bfd/elf64-x86-64.c: Add FreeBSD support.
  (elf64_x86_64_fbsd_post_process_headers): New function.
* bfd/targets.c (_bfd_target_vector): Add bfd_elf64_x86_64_freebsd_vec.
* bfd/config.bfd (x64_64-*-freebsd*): Add bfd_elf64_x86_64_freebsd_vec to the targ_selvecs.
* bfd/configure.in: Add entry for bfd_elf64_x86_64_freebsd_vec.
* bfd/configure: Regenerate.
* gas/config/tc-i386.c (md_parse_option): Treat any target starting with elf64_x86_64 as a viable target for the -64 switch.
  (i386_target_format): For 64-bit ELF flavoured output use ELF_TARGET_FORMAT64.
* gas/config/tc-i386.h (ELF_TARGET_FORMAT64): Define.
* ld/emulparams/elf_x86_64_fbsd.sh (OUTPUT_FORMAT): Define as elf64-x86-64-freebsd.
@
text
@d1000 1
a1000 1
		       && (! info->symbolic
d2448 1
a2448 1
			   || !info->symbolic
@


1.121
log
@include/
	* bfdlink.h (struct bfd_link_info): Add emit_hash and
	emit_gnu_hash bitfields.
include/elf/
	* common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.
ld/
	* scripttempl/elf.sc: Add .gnu.hash section.
	* emultempl/elf32.em (OPTION_HASH_STYLE): Define.
	(gld${EMULATION_NAME}_add_options): Register --hash-style option.
	(gld${EMULATION_NAME}_handle_option): Handle it.
	(gld${EMULATION_NAME}_list_options): Document it.
	* ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
	* ld.texinfo: Document --hash-style option.
bfd/
	* elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
	(bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
	Handle SHT_GNU_HASH.
	(special_sections_g): Include .gnu.hash section.
	(bfd_elf_gnu_hash): New function.
	* elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
	(struct elf_backend_data): Add elf_hash_symbol method.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
	only if info->emit_hash, create .gnu.hash section if
	info->emit_gnu_hash.
	(struct collect_gnu_hash_codes): New type.
	(elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
	_bfd_elf_hash_symbol): New functions.
	(compute_bucket_count): Don't compute HASHCODES array, instead add
	that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
	instead of bed->s->arch_size / 8.  Fix .hash size estimation.
	When not optimizing, use the number of hashed symbols rather than
	dynsymcount.
	(bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
	and ADD DT_GNU_HASH if info->emit_gnu_hash.
	(bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
	adjust compute_bucket_count caller.  Create and populate .gnu.hash
	section if info->emit_gnu_hash.
	(elf_link_output_extsym): Only populate .hash section if
	finfo->hash_sec != NULL.
	(bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
	* elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
	(elfNN_bed): Add elf_backend_hash_symbol.
	* elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
	* elf32-i386.c (elf_i386_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
binutils/
	* readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
	(get_section_type_name): Handle SHT_GNU_HASH.
	(dynamic_info_DT_GNU_HASH): New variable.
	(process_dynamic_section): Handle DT_GNU_HASH.
	(process_symbol_table): Print also DT_GNU_HASH histogram.
ld/testsuite/
	* ld-powerpc/tlsso32.r: Adjust.
	* ld-powerpc/tlsso32.d: Adjust.
	* ld-powerpc/tlsso32.g: Adjust.
	* ld-powerpc/tlsso.r: Adjust.
	* ld-powerpc/tlsso.g: Adjust.
	* ld-powerpc/tlstocso.g: Adjust.
@
text
@d3713 31
@


1.120
log
@bfd/

2006-06-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_relocate_section): Use xchg %ax,%ax
	instead of 2 nops.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	(elf64_x86_64_plt0_entry): Use nopl 0(%rax) instead of 4 nops.

ld/testsuite/

2006-06-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-i386/tlsbindesc.dd: Updated to expect xchg %ax,%ax instead
	of 2 nops.
	* ld-i386/tlsdesc.dd: Likewise.
	* ld-i386/tlsgdesc.dd: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlsdesc.dd: Likewise.
	* ld-x86-64/tlsdesc.pd: Likewise.
	* ld-x86-64/tlsgdesc.dd: Likewise.
@
text
@d3623 13
d3709 2
@


1.119
log
@	PR ld/2754
	* elf.c (bfd_elf_mkobject): Don't alloc if already done.  Set
	program_header_size to -1.
	(_bfd_elf_map_sections_to_segments): Adjust program_header_size check.
	(assign_file_positions_for_load_sections ): Likewise.
	(_bfd_elf_sizeof_headers): Use saved program_header_size if
	available.
	* elf32-arm.c (elf32_arm_mkobject): Call bfd_elf_mkobject, don't
	alloc if already done.
	* elf32-i386.c (elf_i386_mkobject): Likewise.
	* elf32-ppc.c (ppc_elf_mkobject): Likewise.
	* elf32-s390.c (elf_s390_mkobject): Likewise.
	* elf32-sh.c (sh_elf_mkobject): Likewise.
	* elf64-alpha.c (elf64_alpha_mkobject): Likewise.
	* elf64-ppc.c (ppc64_elf_mkobject): Likewise.
	* elf64-s390.c (elf_s390_mkobject): Likewise.
	* elf64-x86-64.c (elf64_x86_64_mkobject): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_mkobject): Likewise.
@
text
@d353 1
a353 1
  0x90, 0x90, 0x90, 0x90	/* pad out to 16 bytes with nops.  */
d2620 3
a2622 2
		  /* Now modify the instruction as appropriate.  */
		  bfd_put_8 (output_bfd, 0x90, contents + roff);
d2914 3
a2916 2
	      /* Now modify the instruction as appropriate.  */
	      bfd_put_8 (output_bfd, 0x90, contents + roff);
@


1.118
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@a678 2
  bfd_size_type amt = sizeof (struct elf64_x86_64_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
d680 7
a686 2
    return FALSE;
  return TRUE;
@


1.117
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@d3597 2
a3598 1
elf64_x86_64_additional_program_headers (bfd *abfd)
@


1.116
log
@2006-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (ELF_MINPAGESIZE): Changed to 0x1000.
@
text
@d3635 1
@


1.115
log
@2006-05-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (ELF_MINPAGESIZE): Set to 0x100000.
@
text
@d3634 1
a3634 1
#define ELF_MINPAGESIZE			    0x100000
@


1.114
log
@bfd/

2006-05-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (ELF_MAXPAGESIZE): Updated to 0x200000.

ld/

2006-05-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/elf_x86_64.sh (MAXPAGESIZE): Updated to 0x200000.

ld/testsuite/

2006-05-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/tlsbin.dd: Updated for 2MB maximum page size.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlsbindesc.rd: Likewise.
	* ld-x86-64/tlsbindesc.sd: Likewise.
	* ld-x86-64/tlsbindesc.td: Likewise.
	* ld-x86-64/tlsdesc.dd: Likewise.
	* ld-x86-64/tlsdesc.pd: Likewise.
	* ld-x86-64/tlsdesc.rd: Likewise.
	* ld-x86-64/tlsdesc.sd: Likewise.
	* ld-x86-64/tlsdesc.td: Likewise.
	* ld-x86-64/tlsgdesc.dd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
@
text
@d3634 1
@


1.113
log
@Patch by matz@@suse.de:
bfd/ChangeLog:
	* reloc.c: Add BFD_RELOC_X86_64_GOT64, BFD_RELOC_X86_64_GOTPCREL64,
	BFD_RELOC_X86_64_GOTPC64, BFD_RELOC_X86_64_GOTPLT64,
	BFD_RELOC_X86_64_PLTOFF64.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
	* elf64-x86-64.c (x86_64_elf_howto_table): Correct comment.
	Add howtos for above relocs.
	(x86_64_reloc_map): Add mappings for new relocs.
	(elf64_x86_64_check_relocs): R_X86_64_GOT64, R_X86_64_GOTPCREL64,
	R_X86_64_GOTPLT64 need a got entry.  R_X86_64_GOTPLT64 also a PLT
	entry.  R_X86_64_GOTPC64 needs a .got section.  R_X86_64_PLTOFF64
	needs a PLT entry.
	(elf64_x86_64_gc_sweep_hook): Reflect changes from
	elf64_x86_64_check_relocs for the new relocs.
	(elf64_x86_64_relocate_section): Handle new relocs.

gas/ChangeLog:
	* config/tc-i386.c (type_names): Correct placement of 'static'.
	(reloc): Map some more relocs to their 64 bit counterpart when
	size is 8.
	(output_insn): Work around breakage if DEBUG386 is defined.
	(output_disp): A BFD_RELOC_64 with GOT_symbol as operand also
	needs to be mapped to BFD_RELOC_X86_64_GOTPC64 or
	BFD_RELOC_X86_64_GOTPC32.  Also x86-64 handles pcrel addressing
	different from i386.
	(output_imm): Ditto.
	(lex_got): Recognize @@PLTOFF and @@GOTPLT.  Make @@GOT accept also
	Imm64.
	(md_convert_frag): Jumps can now be larger than 2GB away, error
	out in that case.
	(tc_gen_reloc): New relocs are passed through.  BFD_RELOC_64
	and BFD_RELOC_64_PCREL are mapped to BFD_RELOC_X86_64_GOTPC64.

gas/testsuite/ChangeLog:
	* gas/i386/reloc64.s: Accept 64-bit forms.
	* gas/i386/reloc64.d: Adjust.
	* gas/i386/reloc64.l: Adjust.

include/ChangeLog:
	* elf/x86-64.h: Add the new relocations with their official
	numbers.
@
text
@d3633 1
a3633 1
#define ELF_MAXPAGESIZE			    0x100000
@


1.112
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d34 2
a35 2
   type, size, bitsize, pc_relative, complain_on_overflow,
   special_function, name, partial_inplace, src_mask, dst_pack, pcrel_offset.  */
d115 15
a129 5
  EMPTY_HOWTO (27),
  EMPTY_HOWTO (28),
  EMPTY_HOWTO (29),
  EMPTY_HOWTO (30),
  EMPTY_HOWTO (31),
d198 5
d795 3
d816 8
d887 1
d915 10
d1229 3
d1234 2
d1260 1
d2142 1
d2144 1
d2148 11
a2158 1
	  /* Use global offset table as symbol value.  */
d2167 13
d2204 3
a2206 1
				  htab->sgot->contents + off);
d2228 1
a2228 1
			      htab->sgot->contents + off);
d2242 2
a2243 2
		      outrel.r_offset = (htab->sgot->output_section->vma
					 + htab->sgot->output_offset
d2259 3
a2261 3
	  relocation = htab->sgot->output_section->vma
		       + htab->sgot->output_offset + off;
	  if (r_type != R_X86_64_GOTPCREL)
d2297 1
d2304 18
@


1.112.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d34 2
a35 2
   type, rightshift, size, bitsize, pc_relative, bitpos, complain_on_overflow,
   special_function, name, partial_inplace, src_mask, dst_mask, pcrel_offset.  */
d115 5
a119 15
  HOWTO(R_X86_64_GOT64, 0, 4, 64, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOT64", FALSE, MINUS_ONE, MINUS_ONE,
	FALSE),
  HOWTO(R_X86_64_GOTPCREL64, 0, 4, 64, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL64", FALSE, MINUS_ONE,
	MINUS_ONE, TRUE),
  HOWTO(R_X86_64_GOTPC64, 0, 4, 64, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPC64",
	FALSE, MINUS_ONE, MINUS_ONE, TRUE),
  HOWTO(R_X86_64_GOTPLT64, 0, 4, 64, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPLT64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_PLTOFF64, 0, 4, 64, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PLTOFF64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
a187 5
  { BFD_RELOC_X86_64_GOT64,	R_X86_64_GOT64, },
  { BFD_RELOC_X86_64_GOTPCREL64,R_X86_64_GOTPCREL64, },
  { BFD_RELOC_X86_64_GOTPC64,	R_X86_64_GOTPC64, },
  { BFD_RELOC_X86_64_GOTPLT64,	R_X86_64_GOTPLT64, },
  { BFD_RELOC_X86_64_PLTOFF64,	R_X86_64_PLTOFF64, },
a779 3
	case R_X86_64_GOT64:
	case R_X86_64_GOTPCREL64:
	case R_X86_64_GOTPLT64:
a797 8
		if (r_type == R_X86_64_GOTPLT64)
		  {
		    /* This relocation indicates that we also need
		       a PLT entry, as this is a function.  We don't need
		       a PLT entry for local symbols.  */
		    h->needs_plt = 1;
		    h->plt.refcount += 1;
		  }
a860 1
	case R_X86_64_GOTPC64:
a887 10
	case R_X86_64_PLTOFF64:
	  /* This tries to form the 'address' of a function relative
	     to GOT.  For global symbols we need a PLT entry.  */
	  if (h != NULL)
	    {
	      h->needs_plt = 1;
	      h->plt.refcount += 1;
	    }
	  goto create_got;

a1191 3
	case R_X86_64_GOT64:
	case R_X86_64_GOTPCREL64:
	case R_X86_64_GOTPLT64:
a1193 2
	      if (r_type == R_X86_64_GOTPLT64 && h->plt.refcount > 0)
	        h->plt.refcount -= 1;
a1217 1
	case R_X86_64_PLTOFF64:
a2098 1
	asection *base_got;
a2099 1
	case R_X86_64_GOT64:
d2103 1
a2103 11
	case R_X86_64_GOTPCREL64:
	  /* Use global offset table entry as symbol value.  */
	case R_X86_64_GOTPLT64:
	  /* This is the same as GOT64 for relocation purposes, but
	     indicates the existence of a PLT entry.  The difficulty is,
	     that we must calculate the GOT slot offset from the PLT
	     offset, if this symbol got a PLT entry (it was global).
	     Additionally if it's computed from the PLT entry, then that
	     GOT offset is relative to .got.plt, not to .got.  */
	  base_got = htab->sgot;

a2111 13
	      if (h->needs_plt
	          && h->plt.offset != (bfd_vma)-1
		  && off == (bfd_vma)-1)
		{
		  /* We can't use h->got.offset here to save
		     state, or even just remember the offset, as
		     finish_dynamic_symbol would use that as offset into
		     .got.  */
		  bfd_vma plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
		  off = (plt_index + 3) * GOT_ENTRY_SIZE;
		  base_got = htab->sgotplt;
		}

d2136 1
a2136 3
				  base_got->contents + off);
		      /* Note that this is harmless for the GOTPLT64 case,
		         as -1 | 1 still is -1.  */
d2158 1
a2158 1
			      base_got->contents + off);
d2172 2
a2173 2
		      outrel.r_offset = (base_got->output_section->vma
					 + base_got->output_offset
d2189 3
a2191 3
	  relocation = base_got->output_section->vma
		       + base_got->output_offset + off;
	  if (r_type != R_X86_64_GOTPCREL && r_type != R_X86_64_GOTPCREL64)
a2226 1
	case R_X86_64_GOTPC64:
a2232 18
	case R_X86_64_PLTOFF64:
	  /* Relocation is PLT entry relative to GOT.  For local
	     symbols it's the symbol itself relative to GOT.  */
          if (h != NULL
	      /* See PLT32 handling.  */
	      && h->plt.offset != (bfd_vma) -1
	      && htab->splt != NULL)
	    {
	      relocation = (htab->splt->output_section->vma
			    + htab->splt->output_offset
			    + h->plt.offset);
	      unresolved_reloc = FALSE;
	    }

	  relocation -= htab->sgotplt->output_section->vma
			+ htab->sgotplt->output_offset;
	  break;

@


1.112.2.2
log
@        Backport from mainline:

        2006-07-29  Richard Sandiford  <richard@@codesourcery.com>

        ld/
        * Makefile.am (eelf32b4300.c): Update dependencies.
        (eelf32bmip.c): Likewise.
        (eelf32bsmip.c): Likewise.
        (eelf32btsmip.c): Likewise.
        (eelf32btsmipn32.c): Likewise.
        (eelf32ltsmip.c): Likewise.
        (eelf32ltsmipn32.c): Likewise.
        (eelf32ebmip.c): Likewise.
        (eelf32ebmipvxworks.c): Likewise.
        (eelf32elmip.c): Likewise.
        (eelf32elmipvxworks.c): Likewise.
        (eelf32bmipn32.c): Likewise.
        (eelf32lmip.c): Likewise.
        (eelf32mipswindiss.c): Likewise.
        (eelf32lsmip.c): Likewise.
        (eelf64bmip.c): Likewise.
        (eelf64btsmip.c): Likewise.
        (eelf64ltsmip.c): Likewise.
        (emipsbig.c): Likewise.  Canonicalize ${GENSCRIPTS} line.
        (emipsbsd.c): Likewise.
        (emipsidt.c): Update dependencies.
        (emipsidtl.c): Likewise.
        (emipslit.c): Likewise.
        (emipslnews.c): Likewise.
        (emipspe.c): Likewise.  Fix ${GENSCRIPTS} invocation.
        * Makefile.in: Regenerate.
        * emulparams/elf32bmip.sh (EXTRA_EM_FILE): Define.
        * emulparams/elf32bmipn32-defs.sh (EXTRA_EM_FILE): Likewise.
        * emultempl/irix.em: Include emultempl/mipself.em.
        * emultempl/mipself.em: New file.

        ld/testsuite/
        * ld-mips-elf/hash1.s, ld-mips-elf/hash1a.d,
        * ld-mips-elf/hash1b.d, ld-mips-elf/hash1c.d: New tests.
        * ld-mips-elf/mips-elf.exp: Run them.

        2006-07-14  Jakub Jelinek  <jakub@@redhat.com>

        * elflink.c (bfd_elf_size_dynsym_hash_dynstr): Fix cinfo.shift2 value.

        2006-07-10  Jakub Jelinek  <jakub@@redhat.com>

        include/
        * bfdlink.h (struct bfd_link_info): Add emit_hash and
        emit_gnu_hash bitfields.

        include/elf/
        * common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.

        ld/
        * scripttempl/elf.sc: Add .gnu.hash section.
        * emultempl/elf32.em (OPTION_HASH_STYLE): Define.
        (gld${EMULATION_NAME}_add_options): Register --hash-style option.
        (gld${EMULATION_NAME}_handle_option): Handle it.
        (gld${EMULATION_NAME}_list_options): Document it.
        * ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
        * ld.texinfo: Document --hash-style option.

        ld/testsuite/
        * ld-powerpc/tlsso32.r: Adjust.
        * ld-powerpc/tlsso32.d: Adjust.
        * ld-powerpc/tlsso32.g: Adjust.
        * ld-powerpc/tlsso.r: Adjust.
        * ld-powerpc/tlsso.g: Adjust.
        * ld-powerpc/tlstocso.g: Adjust.

        bfd/
        * elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
        (bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
        Handle SHT_GNU_HASH.
        (special_sections_g): Include .gnu.hash section.
        (bfd_elf_gnu_hash): New function.
        * elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
        (struct elf_backend_data): Add elf_hash_symbol method.
        * elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
        only if info->emit_hash, create .gnu.hash section if
        info->emit_gnu_hash.
        (struct collect_gnu_hash_codes): New type.
        (elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
        _bfd_elf_hash_symbol): New functions.
        (compute_bucket_count): Don't compute HASHCODES array, instead add
        that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
        instead of bed->s->arch_size / 8.  Fix .hash size estimation.
        When not optimizing, use the number of hashed symbols rather than
        dynsymcount.
        (bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
        and ADD DT_GNU_HASH if info->emit_gnu_hash.
        (bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
        adjust compute_bucket_count caller.  Create and populate .gnu.hash
        section if info->emit_gnu_hash.
        (elf_link_output_extsym): Only populate .hash section if
        finfo->hash_sec != NULL.
        (bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
        * elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
        (elfNN_bed): Add elf_backend_hash_symbol.
        * elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.
        * elf32-i386.c (elf_i386_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.

        binutils/
        * readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
        (get_section_type_name): Handle SHT_GNU_HASH.
        (dynamic_info_DT_GNU_HASH): New variable.
        (process_dynamic_section): Handle DT_GNU_HASH.
        (process_symbol_table): Print also DT_GNU_HASH histogram.
@
text
@a3616 13
/* Return TRUE if symbol should be hashed in the `.gnu.hash' section.  */

static bfd_boolean
elf64_x86_64_hash_symbol (struct elf_link_hash_entry *h)
{
  if (h->plt.offset != (bfd_vma) -1
      && !h->def_regular
      && !h->pointer_equality_needed)
    return FALSE;

  return _bfd_elf_hash_symbol (h);
}

a3687 2
#define elf_backend_hash_symbol \
  elf64_x86_64_hash_symbol
@


1.111
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d513 2
a514 1
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc))
@


1.110
log
@	PR ld/2218
	* elf32-arm.c (allocate_dynrelocs): Ensure undef weak sym in pie
	is dynamic.
	* elf32-hppa.c (allocate_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	* elf32-sh.c (allocate_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	* elf32-m32r.c (allocate_dynrelocs): Likewise.  Discard relocs
	on undef weak with non-default visibility too.
	* elfxx-sparc.c (allocate_dynrelocs): Ditto.
@
text
@d3134 1
a3134 1
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
@


1.109
log
@include/elf/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* common.h (DT_TLSDESC_GOT, DT_TLSDESC_PLT): New.
* i386.h (R_386_TLS_GOTDESC, R_386_TLS_DESC_CALL, R_386_TLS_DESC):
New.
* x86-64.h (R_X86_64_GOTPC32_TLSDESC, R_X86_64_TLSDESC_CALL,
R_X86_64_TLSDESC): New.
bfd/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* reloc.c (BFD_RELOC_386_TLS_GOTDESC, BFD_RELOC_386_TLS_DESC,
BFD_RELOC_386_TLS_DESC_CALL, BFD_RELOC_X86_64_GOTPC32_TLSDESC,
BFD_RELOC_X86_64_TLSDESC, BFD_RELOC_X86_64_TLSDESC_CALL): New.
* libbfd.h, bfd-in2.h: Rebuilt.
* elf32-i386.c (elf_howto_table): New relocations.
(R_386_tls): Adjust.
(elf_i386_reloc_type_lookup): Map new relocations.
(GOT_TLS_GDESC, GOT_TLS_GD_BOTH_P): New macros.
(GOT_TLS_GD_P, GOT_TLS_GDESC_P, GOT_TLS_GD_ANY_P): New macros.
(struct elf_i386_link_hash_entry): Add tlsdesc_got field.
(struct elf_i386_obj_tdata): Add local_tlsdesc_gotent field.
(elf_i386_local_tlsdesc_gotent): New macro.
(struct elf_i386_link_hash_table): Add sgotplt_jump_table_size.
(elf_i386_compute_jump_table_size): New macro.
(link_hash_newfunc): Initialize tlsdesc_got.
(elf_i386_link_hash_table_create): Set sgotplt_jump_table_size.
(elf_i386_tls_transition): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(elf_i386_check_relocs): Likewise.  Allocate space for
local_tlsdesc_gotent.
(elf_i386_gc_sweep_hook): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(allocate_dynrelocs): Count function PLT relocations.  Reserve
space for TLS descriptors and relocations.
(elf_i386_size_dynamic_sections): Reserve space for TLS
descriptors and relocations.  Set up sgotplt_jump_table_size.
Don't zero reloc_count in srelplt.
(elf_i386_always_size_sections): New.  Set up _TLS_MODULE_BASE_.
(elf_i386_relocate_section): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(elf_i386_finish_dynamic_symbol): Use GOT_TLS_GD_ANY_P.
(elf_backend_always_size_sections): Define.
* elf64-x86-64.c (x86_64_elf_howto): Add R_X86_64_GOTPC32_TLSDESC,
R_X86_64_TLSDESC, R_X86_64_TLSDESC_CALL.
(R_X86_64_standard): Adjust.
(x86_64_reloc_map): Map new relocs.
(elf64_x86_64_rtype_to_howto): New, split out of...
(elf64_x86_64_info_to_howto): ... this function, and...
(elf64_x86_64_reloc_type_lookup): ... use it to map elf_reloc_val.
(GOT_TLS_GDESC, GOT_TLS_GD_BOTH_P): New macros.
(GOT_TLS_GD_P, GOT_TLS_GDESC_P, GOT_TLS_GD_ANY_P): New macros.
(struct elf64_x86_64_link_hash_entry): Add tlsdesc_got field.
(struct elf64_x86_64_obj_tdata): Add local_tlsdesc_gotent field.
(elf64_x86_64_local_tlsdesc_gotent): New macro.
(struct elf64_x86_64_link_hash_table): Add tlsdesc_plt,
tlsdesc_got and sgotplt_jump_table_size fields.
(elf64_x86_64_compute_jump_table_size): New macro.
(link_hash_newfunc): Initialize tlsdesc_got.
(elf64_x86_64_link_hash_table_create): Initialize new fields.
(elf64_x86_64_tls_transition): Handle R_X86_64_GOTPC32_TLSDESC and
R_X86_64_TLSDESC_CALL.
(elf64_x86_64_check_relocs): Likewise.  Allocate space for
local_tlsdesc_gotent.
(elf64_x86_64_gc_sweep_hook): Handle R_X86_64_GOTPC32_TLSDESC and
R_X86_64_TLSDESC_CALL.
(allocate_dynrelocs): Count function PLT relocations.  Reserve
space for TLS descriptors and relocations.
(elf64_x86_64_size_dynamic_sections): Reserve space for TLS
descriptors and relocations.  Set up sgotplt_jump_table_size,
tlsdesc_plt and tlsdesc_got.  Make room for them.  Don't zero
reloc_count in srelplt.  Add dynamic entries for DT_TLSDESC_PLT
and DT_TLSDESC_GOT.
(elf64_x86_64_always_size_sections): New.  Set up
_TLS_MODULE_BASE_.
(elf64_x86_64_relocate_section): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(elf64_x86_64_finish_dynamic_symbol): Use GOT_TLS_GD_ANY_P.
(elf64_x86_64_finish_dynamic_sections): Set DT_TLSDESC_PLT and
DT_TLSDESC_GOT.  Set up TLS descriptor lazy resolver PLT entry.
(elf_backend_always_size_sections): Define.
binutils/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* readelf.c (get_dynamic_type): Handle DT_TLSDESC_GOT and
DT_TLSDESC_PLT.
gas/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* config/tc-i386.c (tc_i386_fix_adjustable): Handle
BFD_RELOC_386_TLS_GOTDESC, BFD_RELOC_386_TLS_DESC_CALL,
BFD_RELOC_X86_64_GOTPC32_TLSDESC, BFD_RELOC_X86_64_TLSDESC_CALL.
(optimize_disp): Emit fix up for BFD_RELOC_386_TLS_DESC_CALL and
BFD_RELOC_X86_64_TLSDESC_CALL immediately, and clear the
displacement bits.
(build_modrm_byte): Set up zero modrm for TLS desc calls.
(lex_got): Handle @@tlsdesc and @@tlscall.
(md_apply_fix, tc_gen_reloc): Handle the new relocations.
ld/testsuite/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* ld-i386/i386.exp: Run on x86_64-*-linux* and amd64-*-linux*.
Add new tests.
* ld-i386/pcrel16.d: Add -melf_i386.
* ld-i386/pcrel8.d: Likewise.
* ld-i386/tlsbindesc.dd: New.
* ld-i386/tlsbindesc.rd: New.
* ld-i386/tlsbindesc.s: New.
* ld-i386/tlsbindesc.sd: New.
* ld-i386/tlsbindesc.td: New.
* ld-i386/tlsdesc.dd: New.
* ld-i386/tlsdesc.rd: New.
* ld-i386/tlsdesc.s: New.
* ld-i386/tlsdesc.sd: New.
* ld-i386/tlsdesc.td: New.
* ld-i386/tlsgdesc.dd: New.
* ld-i386/tlsgdesc.rd: New.
* ld-i386/tlsgdesc.s: New.
* ld-x86-64/x86-64.exp: Run new tests.
* ld-x86-64/tlsbindesc.dd: New.
* ld-x86-64/tlsbindesc.rd: New.
* ld-x86-64/tlsbindesc.s: New.
* ld-x86-64/tlsbindesc.sd: New.
* ld-x86-64/tlsbindesc.td: New.
* ld-x86-64/tlsdesc.dd: New.
* ld-x86-64/tlsdesc.pd: New.
* ld-x86-64/tlsdesc.rd: New.
* ld-x86-64/tlsdesc.s: New.
* ld-x86-64/tlsdesc.sd: New.
* ld-x86-64/tlsdesc.td: New.
* ld-x86-64/tlsgdesc.dd: New.
* ld-x86-64/tlsgdesc.rd: New.
* ld-x86-64/tlsgdesc.s: New.
@
text
@d1568 1
a1568 1
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
d1570 13
a1582 1
	eh->dyn_relocs = NULL;
@


1.108
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005
d115 19
d139 1
a139 1
#define R_X86_64_standard (R_X86_64_GOTPC32 + 1)
d188 3
d195 21
d219 1
a219 1
elf64_x86_64_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
d228 2
a229 1
	return &x86_64_elf_howto_table[i];
d240 1
a240 1
  unsigned r_type, i;
d243 1
a243 14
  if (r_type < (unsigned int) R_X86_64_GNU_VTINHERIT
      || r_type >= (unsigned int) R_X86_64_max)
    {
      if (r_type >= (unsigned int) R_X86_64_standard)
	{
	  (*_bfd_error_handler) (_("%B: invalid relocation type %d"),
				 abfd, (int) r_type);
	  r_type = R_X86_64_NONE;
	}
      i = r_type;
    }
  else
    i = r_type - (unsigned int) R_X86_64_vt_offset;
  cache_ptr->howto = &x86_64_elf_howto_table[i];
d387 9
d397 4
d412 3
d423 2
d441 9
d455 3
d467 3
d495 1
d527 2
d530 1
d687 2
d779 2
d790 3
d811 2
a812 1
		    size *= sizeof (bfd_signed_vma) + sizeof (char);
d818 2
d821 1
a821 1
		      = (char *) (local_got_refcounts + symtab_hdr->sh_info);
d831 2
a832 1
		&& (old_tls_type != GOT_TLS_GD || tls_type != GOT_TLS_IE))
d834 1
a834 1
		if (old_tls_type == GOT_TLS_IE && tls_type == GOT_TLS_GD)
d836 3
d1186 2
d1455 1
d1469 3
d1494 16
a1509 6
      s = htab->sgot;
      h->got.offset = s->size;
      s->size += GOT_ENTRY_SIZE;
      /* R_X86_64_TLSGD needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->size += GOT_ENTRY_SIZE;
d1514 1
a1514 1
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
d1517 1
a1517 1
      else if (tls_type == GOT_TLS_GD)
d1519 3
a1521 2
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
d1525 5
a1533 1
  eh = (struct elf64_x86_64_link_hash_entry *) h;
d1681 1
d1725 1
d1728 2
a1729 1
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
d1731 1
d1734 15
a1748 4
	      *local_got = s->size;
	      s->size += GOT_ENTRY_SIZE;
	      if (*local_tls_type == GOT_TLS_GD)
		s->size += GOT_ENTRY_SIZE;
d1750 1
a1750 1
		  || *local_tls_type == GOT_TLS_GD
d1752 10
a1761 1
		srel->size += sizeof (Elf64_External_Rela);
d1783 28
d1834 2
a1835 1
	  s->reloc_count = 0;
d1895 5
d1927 35
d2020 1
d2031 1
d2043 1
a2043 1
      bfd_vma off;
d2402 2
d2415 3
a2417 1
	  if (r_type == R_X86_64_TLSGD)
d2459 61
d2585 4
a2588 1
	    off = h->got.offset;
d2595 1
d2605 1
d2610 26
d2639 1
a2639 2
	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_X86_64_TLSGD)
d2641 2
d2648 2
a2649 1
	      if (dr_type == R_X86_64_TPOFF64 && indx == 0)
d2653 4
a2656 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d2659 1
a2659 1
	      if (r_type == R_X86_64_TLSGD)
d2675 1
a2675 1
		      htab->srelgot->reloc_count++;
d2677 2
d2683 1
d2690 2
a2691 1
	  if (off >= (bfd_vma) -2)
d2695 8
a2702 2
	      relocation = htab->sgot->output_section->vma
			   + htab->sgot->output_offset + off;
d2705 1
a2705 1
	  else
d2745 71
d3054 1
a3054 1
      && elf64_x86_64_hash_entry (h)->tls_type != GOT_TLS_GD
d3209 12
d3255 34
d3560 1
@


1.107
log
@* elf32-i386.c (elf_i386_check_relocs): Don't cast a unary &
address operator, as that breaks GCC's strict aliasing rules.
(elf_i386_size_dynamic_sections): Avoid the need for type
punning.
* elf64-x86-64.c (elf_x86_64_check_relocs): Don't cast a unary
& address operator, as that breaks GCC's strict aliasing
rules.
(elf_x86_64_size_dynamic_sections): Avoid the need for type
punning.
@
text
@d528 1
a528 1
elf64_x86_64_copy_indirect_symbol (const struct elf_backend_data *bed,
d544 1
a544 4
	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
d589 1
a589 1
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.106
log
@2005-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1208
	* elf-hppa.h (elf_hppa_relocate_section): Print out the name
	of unresolvable relocation.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d949 1
d960 4
a963 2
		  head = ((struct elf64_x86_64_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
d1592 2
a1593 2
	  for (p = *((struct elf64_x86_64_dyn_relocs **)
		     &elf_section_data (s)->local_dynrel);
@


1.105
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d2522 1
a2522 1
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
d2526 1
@


1.104
log
@2005-08-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf64_x86_64_merge_symbol): When mixing a
	large common symbol and a normal common symbol, always turn
	the large common symbol into a normal one.
@
text
@d1250 7
@


1.103
log
@bfd/

2005-08-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_howto_table): Undo the overflow change for
	R_386_PC16 made on 2005-07-18.

	* elf64-x86-64.c (x86_64_elf_howto_table): Undo the overflow
	change for R_X86_64_PC16 made on 2005-07-18.

ld/testsuite/

2005-08-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-i386/pcrel16.d: Updated.
	* ld-i386/pcrel16.s: Likewise.
	* ld-x86-64/pcrel16.d: Likewise.
@
text
@d3017 1
a3017 1
			   asection **psec ATTRIBUTE_UNUSED,
d3034 1
a3034 1
			   bfd *oldbfd ATTRIBUTE_UNUSED,
d3038 2
a3039 4
     normal common symbol.  If we see the normal symbol first, we
     do nothing since the first one will be used.  If we see the
     large common symbol first, we need to change the large common
     symbol to the normal common symbol.  */
d3044 1
a3044 3
      && *oldsec != *sec
      && sym->st_shndx == SHN_COMMON
      && (elf_section_flags (*oldsec) & SHF_X86_64_LARGE) != 0)
d3046 10
a3055 3
      h->root.u.c.p->section = bfd_make_section_old_way (abfd,
							 "COMMON");
      h->root.u.c.p->section->flags = SEC_ALLOC;
@


1.102
log
@bfd/
2005-07-27  Jan Beulich  <jbeulich@@novell.com>

	* elf64-x86-64.c (R_X86_64_standard, R_X86_64_vt_offset): New.
	(elf64_x86_64_info_to_howto): Use them.
@
text
@d76 1
a76 1
  HOWTO(R_X86_64_PC16,0, 1, 16, TRUE, 0, complain_overflow_signed,
@


1.101
log
@bfd/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_large_com_section): New.
	* elf.c (_bfd_elf_large_com_section): New. Defined.

	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): New.
	(elf64_x86_64_elf_section_from_bfd_section): New.
	(elf64_x86_64_symbol_processing): New.
	(elf64_x86_64_common_definition): New.
	(elf64_x86_64_common_section_index): New.
	(elf64_x86_64_common_section): New.
	(elf64_x86_64_merge_symbol): New.
	(elf64_x86_64_additional_program_headers): New.
	(elf64_x86_64_special_sections): New.
	(elf_backend_section_from_bfd_section): New. Defined.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_common_section_index): Likewise.
	(elf_backend_common_section): Likewise.
	(elf_backend_common_definition): Likewise.
	(elf_backend_merge_symbol): Likewise.
	(elf_backend_special_sections): Likewise.
	(elf_backend_additional_program_headers): Likewise.

binutils/

2005-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (dump_relocations): Handle SHN_X86_64_LCOMMON.
	(get_symbol_index_type): Likewise.
	(get_elf_section_flags): Handle SHF_X86_64_LARGE.

gas/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c: Include "elf/x86-64.h" if TC_I386 is
	defined.
	(elf_com_section_ptr): New.
	(elf_begin): Set elf_com_section_ptr to bfd_com_section_ptr.
	(elf_common_parse): Make it global. Use elf_com_section_ptr
	instead of bfd_com_section_ptr.
	(obj_elf_change_section): Handle x86-64 large bss sections.

	* config/obj-elf.h (elf_com_section_ptr): New.
	(elf_common_parse): New.

	* config/tc-i386.c (handle_large_common): New.
	(md_pseudo_table): Add "largecomm".
	(x86_64_section_letter): New.
	(x86_64_section_word): New.

	* config/tc-i386.h (x86_64_section_word): New.
	(x86_64_section_letter): New.
	(md_elf_section_letter): New. Defined.
	(md_elf_section_word): Likewise.

include/elf/

2005-07-25  Jan Hubicka  <jh@@suse.cz>

	* x86-64.h (SHN_X86_64_LCOMMON): New.
	(SHF_X86_64_LARGE): New.

ld/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/elf_x86_64.sh (LARGE_SECTIONS): New.

	* scripttempl/elf.sc: Updated for large section support.
@
text
@d116 7
d202 1
a202 1
      if (r_type > (unsigned int) R_X86_64_GOTPC32)
d211 1
a211 1
    i = r_type - ((unsigned int) R_X86_64_GNU_VTINHERIT - R_X86_64_GOTPC32 - 1);
@


1.100
log
@bfd/
2005-07-18  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_howto_table): Adjust overflow complaint handler
	for R_386_PC16.
	* elf64-x86-64.c (x86_64_elf_howto_table): Adjust overflow complaint
	handler for R_X86_64_PC16, R_X86_64_8, and R_X86_64_DTPOFF.

ld/testsuite/
2005-07-18  Jan Beulich  <jbeulich@@novell.com>

	* ld-i386/abs.s, ld-i386/zero.s, ld-i386/abs.d, ld-x86-64/abs.d,
	ld-i386/pcrel16.s, ld-i386/pcrel16.d, ld-x86-64/pcrel16.d,
	ld-i386/pcrel8.s, ld-i386/pcrel8.d, ld-x86-64/pcrel8.d: New.
	* ld-i386/i386.exp, ld-x86-64/x86-64.exp: Run new tests.
@
text
@d2909 175
d3124 19
@


1.99
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d76 1
a76 1
  HOWTO(R_X86_64_PC16,0, 1, 16, TRUE, 0, complain_overflow_bitfield,
d78 1
a78 1
  HOWTO(R_X86_64_8, 0, 0, 8, FALSE, 0, complain_overflow_signed,
d97 1
a97 1
  HOWTO(R_X86_64_DTPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
@


1.98
log
@	* libbfd-in.h (bfd_malloc2, bfd_realloc2, bfd_zmalloc2, bfd_alloc2,
	bfd_zalloc2): New prototypes.
	* bfd-in.h (HALF_BFD_SIZE_TYPE): Define.
	* libbfd.c (bfd_malloc2, bfd_realloc2, bfd_zmalloc2): New functions.
	* opncls.c (bfd_alloc2, bfd_zalloc2): New functions.
	* elf.c (bfd_elf_get_elf_syms, setup_group, assign_section_numbers,
	elf_map_symbols, map_sections_to_segments,
	assign_file_positions_for_segments, copy_private_bfd_data,
	swap_out_syms, _bfd_elf_slurp_version_tables): Use bfd_*alloc2
	where appropriate.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.

	* elf.c (_bfd_elf_print_private_bfd_data): Don't crash on bogus
	verdef or verneed section.
	(_bfd_elf_slurp_version_tables): Handle corrupt verdef and/or
	verneed sections gracefully.
	* elfxx-sparc.c (_bfd_sparc_elf_info_to_howto_ptr): Don't crash on
	bogus relocation values.
	* elf64-ppc.c (ppc64_elf_info_to_howto): Likewise.
	* elf64-s390.c (elf_s390_info_to_howto): Likewise.
	* elf32-s390.c (elf_s390_info_to_howto): Likewise.
	* elf64-x86-64.c (elf64_x86_64_info_to_howto): Likewise.
	* elfxx-ia64.c (lookup_howto): Likewise.
@
text
@d1689 3
@


1.97
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025:
	* elf32-i386.c (elf_i386_check_relocs): Handle indirect symbol.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
@
text
@d192 2
a193 1
  if (r_type < (unsigned int) R_X86_64_GNU_VTINHERIT)
d195 6
a200 1
      BFD_ASSERT (r_type <= (unsigned int) R_X86_64_GOTPC32);
d204 1
a204 4
    {
      BFD_ASSERT (r_type < (unsigned int) R_X86_64_max);
      i = r_type - ((unsigned int) R_X86_64_GNU_VTINHERIT - R_X86_64_GOTPC32 - 1);
    }
@


1.96
log
@bfd/
2005-06-17  Jan Beulich  <jbeulich@@novell.com>

	* bfd-in2.h (elf_x86_64_reloc_type): Add BFD_RELOC_X86_64_GOTOFF64
	and BFD_RELOC_X86_64_GOTPC32.
	* libbfd.h (bfd_reloc_code_real_names): Likewise.
	* elf64-x86-64.c (x86_64_elf_howto_table): Add entries for
	R_X86_64_PC64, R_X86_64_GOTOFF64, and R_X86_64_GOTPC32.
	(x86_64_reloc_map): Add entries for R_X86_64_PC64, R_X86_64_GOTOFF64,
	and R_X86_64_GOTPC32.
	(elf64_x86_64_info_to_howto): Adjust bounding relocation type.
	(elf64_x86_64_check_relocs): Also handle R_X86_64_PC64,
	R_X86_64_GOTOFF64, and R_X86_64_GOTPC32.
	(elf64_x86_64_relocate_section): Likewise.
	(elf64_x86_64_gc_sweep_hook): Also handle R_X86_64_PC64.

gas/
2005-06-17  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (reloc): Also handle BFD_RELOC_64_PCREL.
	(tc_i386_fix_adjustable): Include BFD_RELOC_X86_64_GOTOFF64,
	BFD_RELOC_X86_64_DTPOFF64, and BFD_RELOC_X86_64_TPOFF64.
	(output_disp): Do GOTPC conversion also for BFD_RELOC_X86_64_32S
	and BFD_RELOC_32_PCREL. Use BFD_RELOC_X86_64_GOTPC32 instead of
	aborting.
	(output_imm): Do GOTPC conversion also for BFD_RELOC_X86_64_32S.
	Use BFD_RELOC_X86_64_GOTPC32 instead of aborting.
	(tc_gen_reloc): Do GOTPC conversion also for BFD_RELOC_32_PCREL.
	Use BFD_RELOC_X86_64_GOTPC32 instead of aborting. Also handle
	BFD_RELOC_X86_64_GOTOFF64, BFD_RELOC_X86_64_GOTPC32,
	BFD_RELOC_X86_64_DTPOFF64, and BFD_RELOC_X86_64_TPOFF64. Also
	convert 8-byte pc-relative relocations.
	(lex_got): Use BFD_RELOC_X86_64_GOTOFF64 for 64-bit @@gotoff.
	(i386_validate_fix): Likewise.
	(x86_cons): Also handle quad values in 64-bit mode.
	(i386_displacement): Also handle BFD_RELOC_X86_64_GOTOFF64.
	(md_apply_fix): Include BFD_RELOC_X86_64_DTPOFF64 and
	BFD_RELOC_X86_64_TPOFF64 in the TLS check. Also convert BFD_RELOC_64
	to pc-relative variant. Also check for BFD_RELOC_64_PCREL.

gas/testsuite/
2005-06-17  Jan Beulich  <jbeulich@@novell.com>

	* gas/i386/x86-64-pcrel.s: Add insn requiring 64-bit pc-relative
	relocation. Add insns for all widths of non-pc-relative relocations.
	* gas/i386/x86-64-pcrel.d: Adjust.

include/elf/
2005-06-17  Jan Beulich  <jbeulich@@novell.com>

	* x86-64.h (elf_x86_64_reloc_type): Adjust comment for
	R_X86_64_GOTPCREL. Add R_X86_64_PC64, R_X86_64_GOTOFF64, and
	R_X86_64_GOTPC32.
@
text
@d667 6
a672 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.95
log
@bfd/

2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 797
	* elf32-i386.c (elf_i386_size_dynamic_sections): Also remove
	empty sdynbss section.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Likewise.

ld/

2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 797
	* ldexp.c (exp_fold_tree_1): Renamed from exp_fold_tree and
	take take a bfd_boolean, mark_used. Ignore assert failure if
	mark_used is TRUE.
	(exp_fold_tree) Call exp_fold_tree_1 with mark_used == FALSE.
	(exp_fold_tree_no_dot): Updated to take a bfd_boolean,
	mark_used and pass down.
	(fold_unary): Likewise.
	(fold_binary): Likewise.
	(fold_trinary): Likewise.
	(exp_binop): Add FALSE to call to exp_fold_tree_no_dot.
	(exp_trinop): Likewise.
	(exp_unop): Likewise.
	(exp_nameop): Likewise.
	(exp_get_vma): Likewise.
	(exp_get_fill): Likewise.
	(exp_get_abs_int): Likewise.
	(fold_name): Likewise. Set SEC_KEEP in output section flags.
	(exp_mark_used_section): New.

	* ldexp.h (exp_mark_used_section): New.

	* ldlang.c (lang_output_section_statement_lookup_1): Set the
	ignored field to FALSE.
	(lang_mark_used_section_1): New.
	(lang_mark_used_section): Call lang_mark_used_section_1.
	(strip_excluded_output_sections): Call lang_mark_used_section
	and check for unused sections.
	(lang_size_sections_1): Skip an output section if it should
	be ignored.
	(lang_do_assignments_1): Likewise.
	(lang_process): Don't call lang_mark_used_section here.

	* ldlang.h (lang_output_section_statement_type): Change
	all_input_readonly to bitfield. Add ignored.

ld/testsuite/

2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 797
	* empty-aligned.d: New file.
	* empty-aligned.exp: Likewise.
	* empty-aligned.s: Likewise.
	* empty-aligned.t: Likewise.
@
text
@d106 9
d159 3
d194 1
a194 1
      BFD_ASSERT (r_type <= (unsigned int) R_X86_64_TPOFF32);
d200 1
a200 1
      i = r_type - ((unsigned int) R_X86_64_GNU_VTINHERIT - R_X86_64_TPOFF32 - 1);
d764 2
a765 1
	  //case R_X86_64_GOTPCREL:
d818 1
d833 1
a833 1
	      if (r_type != R_X86_64_PC32)
d862 2
a863 1
		    && (r_type != R_X86_64_PC32))
d966 2
a967 1
		  || r_type == R_X86_64_PC32)
d1112 1
d1961 36
d2055 1
d2073 2
a2074 1
		    && r_type != R_X86_64_PC32)
d2118 1
@


1.94
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d1627 2
a1628 1
	  || s == htab->sgotplt)
@


1.93
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d462 6
a467 1
  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
a468 4
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
a896 1
		      sreloc = bfd_make_section (dynobj, name);
d901 3
a904 1
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
@


1.92
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.91
log
@Update the FSF address in the copyright/GPL notice
@
text
@d1657 1
a1657 1
	  _bfd_strip_section_from_output (info, s);
@


1.90
log
@2005-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_backend_data): Add int to
	elf_backend_section_from_shdr.
	(bfd_elf_section_data): Update comment for this_idx.
	(_bfd_elf_make_section_from_shdr): Add int.
	* elfxx-mips.h (_bfd_mips_elf_section_from_shdr): Likewise.

	* elf.c (_bfd_elf_make_section_from_shdr): Take section index
	and use it to set this_idx in bfd_elf_section_data.
	(bfd_section_from_shdr): Pass shindex to
	_bfd_elf_make_section_from_shdr.
	(_bfd_elf_section_from_bfd_section): Use this_idx in
	bfd_elf_section_data to find section index.

	* elf32-arm.c (elf32_arm_section_from_shdr): Take section
	index and pass it to _bfd_elf_make_section_from_shdr.
	* elf32-i370.c(i370_elf_section_from_shdr): Likewise.
	* elf32-ppc.c (ppc_elf_section_from_shdr): Likewise.
	* elf32-sh64.c (sh64_backend_section_from_shdr): Likewise.
	* elf32-v850.c (v850_elf_section_from_shdr): Likewise.
	* elf64-alpha.c (elf64_alpha_section_from_shdr): Likewise.
	* elf64-hppa.c (elf64_hppa_section_from_shdr): Likewise.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): Likewise.
	* elfxx-ia64.c (elfNN_ia64_section_from_shdr): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Likewise.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.89
log
@2005-02-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-i386.c (elf_i386_relocate_section): Disallow R_386_GOTOFF
	against protected function when building shared library.

	PR 584
	* elf64-x86-64.c (is_32bit_relative_branch): New.
	(elf64_x86_64_relocate_section): Alllow R_X86_64_PC32 on a
	protected function symbol when building shared library for
	32bit relative branch instruction.
@
text
@d2825 4
a2828 1
elf64_x86_64_section_from_shdr (bfd *abfd, Elf_Internal_Shdr *hdr, const char *name)
d2833 1
a2833 1
  if (! _bfd_elf_make_section_from_shdr (abfd, hdr, name))
@


1.88
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@d1748 18
d1971 7
a1977 1
	      && (input_section->flags & SEC_READONLY) != 0)
d1979 12
a1990 5
	      (*_bfd_error_handler)
		(_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 input_bfd,
		 x86_64_elf_howto_table[r_type].name,
		 (h) ? h->root.root.string : "a local symbol");
@


1.87
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 2
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1047 3
@


1.86
log
@bfd/
	* config.bfd: Include 64-bit support for i[3-7]86-*-solaris2*.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): New function.
	(elf_backend_section_from_shdr): Define.
binutils/
	* readelf.c (get_x86_64_section_type_name): New function.
	(get_section_type_name): Use it.
gas/
	* config/tc-i386.c: Include "elf/x86-64.h".
	(i386_elf_section_type): New function.
	* config/tc-i386.h (md_elf_section_type): Define.
	(i386_elf_section_type): New prototype.
gas/testsuite/
	* gas/i386/i386.exp: Don't run divide test for targets where '/'
	is a comment.  Run x86-64-unwind for 64-bit ELF targets.
	* gas/i386/x86-64-unwind.d, gas/i386/x86-64-unwind.s: New.
include/
	* elf/common.h (PT_SUNW_EH_FRAME): Define.
	* elf/x86-64.h (SHT_X86_64_UNWIND): Define.
ld/
	* configure.tgt: Include elf_x86_64 for i[3-7]86-*-solaris2*.
@
text
@d2439 3
a2441 2
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
@


1.85
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d2785 15
d2837 3
@


1.84
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d1157 1
a1157 1
  if (h->weakdef != NULL)
d1159 4
a1162 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
d1164 1
a1164 1
	h->non_got_ref = h->weakdef->non_got_ref;
@


1.83
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d556 11
a566 10
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT
				   | ELF_LINK_POINTER_EQUALITY_NEEDED));
d774 1
a774 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d812 1
a812 1
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d818 1
a818 1
		h->elf_link_hash_flags |= ELF_LINK_POINTER_EQUALITY_NEEDED;
d850 1
a850 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d856 1
a856 2
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d1128 1
a1128 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d1141 1
a1141 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1164 1
a1164 3
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1180 1
a1180 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
d1186 1
a1186 1
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d1207 1
a1207 1
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d1230 1
a1230 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d1287 1
a1287 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d1311 1
a1311 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1330 1
a1330 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1336 1
a1336 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1355 1
a1355 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d1430 3
a1432 3
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1440 1
a1440 1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d1987 3
a1989 5
		  && (h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && (((h->elf_link_hash_flags
			& ELF_LINK_HASH_DEF_DYNAMIC) != 0
		       && (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2027 1
a2027 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
d2401 1
a2401 1
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d2537 1
a2537 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2548 1
a2548 1
	  if ((h->elf_link_hash_flags & ELF_LINK_POINTER_EQUALITY_NEEDED) == 0)
d2597 1
a2597 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.82
log
@	* elf64-x86-64.c (elf64_x86_64_relocate_section): For -fno-pic
	error, test input_section flags rather than sec.
@
text
@d644 2
a645 3
	  (*_bfd_error_handler) (_("%s: bad symbol index: %d"),
				 bfd_archive_filename (abfd),
				 r_symndx);
d665 2
a666 2
		(_("%s: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (abfd),
d733 2
a734 3
		      (_("%s: %s' accessed both as normal and thread local symbol"),
		       bfd_archive_filename (abfd),
		       h ? h->root.root.string : "<local>");
d790 2
a791 2
		(_("%s: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (abfd),
d882 2
a883 2
			(_("%s: bad relocation section name `%s\'"),
			 bfd_archive_filename (abfd), name);
d1955 2
a1956 2
		(_("%s: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (input_bfd),
d2409 3
a2411 3
	  (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	   bfd_archive_filename (input_bfd),
	   bfd_get_section_name (input_bfd, input_section),
d2452 2
a2453 3
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
@


1.81
log
@2004-06-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf64-x86-64.c (elf64_x86_64_check_relocs): Warn overflow
	relocation symbol.
	(elf64_x86_64_relocate_section): Issue an error for
	R_X86_64_PC8, R_X86_64_PC16 and R_X86_64_PC32 relocations
	against global symbols when building shared library.
@
text
@d1953 2
a1954 2
	      && (sec->flags & SEC_ALLOC) != 0
	      && (sec->flags & SEC_READONLY) != 0)
@


1.80
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d666 1
a666 1
		(_("%s: relocation %s can not be used when making a shared object; recompile with -fPIC"),
d668 2
a669 1
		 x86_64_elf_howto_table[r_type].name);
d792 1
a792 1
		(_("%s: relocation %s can not be used when making a shared object; recompile with -fPIC"),
d794 2
a795 1
		 x86_64_elf_howto_table[r_type].name);
d1951 15
@


1.79
log
@	* elf64-x86-64.c (elf64_x86_64_relocate_section): Ignore reloc
	overflow on branches to undefweaks.
@
text
@d198 1
a198 1
  size_t raw_size;
d216 1
a216 1
	raw_size = 216;
d223 1
a223 1
					  raw_size, note->descpos + offset);
d1232 1
a1232 1
      htab->srelbss->_raw_size += sizeof (Elf64_External_Rela);
d1247 1
a1247 1
  s->_raw_size = BFD_ALIGN (s->_raw_size, (bfd_size_type) (1 << power_of_two));
d1256 1
a1256 1
  h->root.u.def.value = s->_raw_size;
d1259 1
a1259 1
  s->_raw_size += h->size;
d1303 2
a1304 2
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_ENTRY_SIZE;
d1306 1
a1306 1
	  h->plt.offset = s->_raw_size;
d1321 1
a1321 1
	  s->_raw_size += PLT_ENTRY_SIZE;
d1325 1
a1325 1
	  htab->sgotplt->_raw_size += GOT_ENTRY_SIZE;
d1328 1
a1328 1
	  htab->srelplt->_raw_size += sizeof (Elf64_External_Rela);
d1365 2
a1366 2
      h->got.offset = s->_raw_size;
      s->_raw_size += GOT_ENTRY_SIZE;
d1369 1
a1369 1
	s->_raw_size += GOT_ENTRY_SIZE;
d1376 1
a1376 1
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
d1378 1
a1378 1
	htab->srelgot->_raw_size += 2 * sizeof (Elf64_External_Rela);
d1383 1
a1383 1
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
d1464 1
a1464 1
      sreloc->_raw_size += p->count * sizeof (Elf64_External_Rela);
d1524 1
a1524 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d1563 1
a1563 1
		  srel->_raw_size += p->count * sizeof (Elf64_External_Rela);
d1585 2
a1586 2
	      *local_got = s->_raw_size;
	      s->_raw_size += GOT_ENTRY_SIZE;
d1588 1
a1588 1
		s->_raw_size += GOT_ENTRY_SIZE;
d1592 1
a1592 1
		srel->_raw_size += sizeof (Elf64_External_Rela);
d1603 3
a1605 3
      htab->tls_ld_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
d1631 1
a1631 1
	  if (s->_raw_size != 0 && s != htab->srelplt)
d1644 1
a1644 1
      if (s->_raw_size == 0)
d1665 1
a1665 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d1686 1
a1686 1
      if (htab->splt->_raw_size != 0)
d2113 1
a2113 1
		  BFD_ASSERT (rel->r_offset + 12 <= input_section->_raw_size);
d2149 1
a2149 1
		  BFD_ASSERT (rel->r_offset + 4 <= input_section->_raw_size);
d2286 1
a2286 1
	      BFD_ASSERT (rel->r_offset + 12 <= input_section->_raw_size);
d2326 1
a2326 1
	      BFD_ASSERT (rel->r_offset + 9 <= input_section->_raw_size);
d2660 1
a2660 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d2684 1
a2684 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d2698 1
a2698 4
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
d2707 1
a2707 1
      if (htab->splt && htab->splt->_raw_size > 0)
d2741 1
a2741 1
      if (htab->sgotplt->_raw_size > 0)
d2760 1
a2760 1
  if (htab->sgot && htab->sgot->_raw_size > 0)
@


1.78
log
@bfd/
	* elflink.c (elf_bfd_final_link): Don't output STT_SECTION symbol
	into .dynsym if elf_section_data (sec)->dynindx <= 0.
	Adjust counting of last_local.
	(_bfd_elf_link_renumber_dynsyms): Don't assign dynindx to sections
	other than SHT_PROGBITS/SHT_NOBITS and neither for .got/.got.plt/.plt
	created by the linker nor !SHF_ALLOC.

	* elf32-i386.c (elf_i386_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.  Set sh_entsize for .got section in addition
	to .got.plt.
	(elf_i386_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.
	(elf64_x86_64_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.  Set sh_entsize for .got section
	in addition to .got.plt.
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_RELRO.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Likewise.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Likewise.
	* elflink.c (bfd_elf_size_dynamic_sections): Set
	elf_tdata (output_bfd)->relro from info->relro.
	* elf-bfd.h (struct elf_obj_tdata): Add relro field.
include/
	* bfdlink.h (struct bfd_link_info): Add relro, relro_start and
	relro_end fields.
	* elf/common.h (PT_GNU_EH_FRAME, PT_GNU_STACK): Add comments.
	(PT_GNU_RELRO): Define.
binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_RELRO.
ld/
	* genscripts.sh: Generate -z combreloc -z now -z relro scripts
	for binaries, -shared and -pie.
	* emulparams/elf_i386.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf_x86_64.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf32ppc.sh (OTHER_READWRITE_SECTIONS): Rename to...
	(OTHER_RELRO_SECTIONS): ... this.
	* ldlex.l (DATA_SEGMENT_RELRO_END): Add.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Handle
	-z relro and -z norelro.
	(gld${EMULATION_NAME}_list_options): Add it to usage.
	(gld${EMULATION_NAME}_get_script): Return -z combreloc -z now
	-z relro scripts when appropriate.
	* scripttempl/elf.sc: Unset SEPARATE_GOTPLT if RELRO_NOW is set.
	Create separate .got.plt section if SEPARATE_GOTPLT.
	Move sections which are only written during relocation handling
	to the beginning of RW segment.  If NO_SMALL_DATA, move .got
	before .data.  Add DATA_SEGMENT_RELRO_END directive.
	Include OTHER_RELRO_SECTIONS.
	* ldgram.y (DATA_SEGMENT_RELRO_END): Add.
	* ldexp.c (exp_print_token): Handle DATA_SEGMENT_RELRO_END.
	(fold_unary): Likewise.
	(fold_binary): Handle -z relro.
	* ldexp.h (struct exp_data_seg): Add exp_dataseg_relro_seen and
	exp_dataseg_relro_adjust phases.  Add relro_end field.
	* ldmain.c (main): Initialize link_info.relro to FALSE.
	* ldlang.c (lang_size_sections): Handle -z relro.
ld/testsuite/
	* ld-i386/tlspic.rd: Adjust for section reordering changes
	and removal of unneeded STT_SECTION symbols from .dynsym.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsbinpic.s: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsnopic1.s: Likewise.
	* ld-i386/combreloc.d: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-s390/tlspic1.s: Likewise.
	* ld-s390/tlsbinpic.s: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlspic.dd: Likewise.
	* ld-s390/tlsbin.dd: Likewise.
	* ld-s390/tlsbin.sd: Likewise.
	* ld-s390/tlsbin.td: Likewise.
	* ld-s390/tlspic.sd: Likewise.
	* ld-s390/tlspic.td: Likewise.
	* ld-s390/tlspic1_64.s: Likewise.
	* ld-s390/tlsbinpic_64.s: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic_64.dd: Likewise.
	* ld-s390/tlsbin_64.dd: Likewise.
	* ld-s390/tlspic_64.sd: Likewise.
	* ld-s390/tlspic_64.td: Likewise.
	* ld-s390/tlsbin_64.td: Likewise.
	* ld-s390/tlsbin_64.sd: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.t: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlsso.g: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-powerpc/tlstocso.g: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-ia64/tlspic.dd: Likewise.
	* ld-ia64/tlspic.sd: Likewise.
	* ld-ia64/tlspic.td: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlsbin.sd: Likewise.
	* ld-ia64/tlsbin.td: Likewise.
	* ld-elfvsb/elfvsb.exp: XFAIL non-PIC load offset tests on s390x.
	* ld-shared/shared.exp: Likewise.
@
text
@d2423 5
@


1.77
log
@	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Copy also
	ELF_LINK_POINTER_EQUALITY_NEEDED.
	(elf64_x86_64_check_relocs): Set ELF_LINK_POINTER_EQUALITY_NEEDED
	if r_type is not R_X86_64_PC32.
	(elf64_x86_64_finish_dynamic_symbol): If
	ELF_LINK_POINTER_EQUALITY_NEEDED is not set, clear st_value of
	SHN_UNDEF symbols.
@
text
@d1914 5
a1918 3
	  relocation = htab->sgot->output_offset + off;
	  if (r_type == R_X86_64_GOTPCREL)
	    relocation += htab->sgot->output_section->vma;
d2669 2
a2670 1
	      dyn.d_un.d_ptr = htab->sgot->output_section->vma;
d2760 4
@


1.76
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d564 2
a565 1
				   | ELF_LINK_HASH_NEEDS_PLT));
d816 2
d2525 2
a2526 1
	     the .plt section.  Leave the value alone.  This is a clue
d2529 3
a2531 1
	     library.  */
d2533 2
@


1.75
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d2753 9
d2796 1
@


1.74
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d954 1
a954 1
	  if (!_bfd_elf64_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d961 1
a961 1
	  if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_addend))
a1260 11
/* This is the condition under which elf64_x86_64_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf64_x86_64_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d1289 1
a1289 1
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
d1357 1
a1357 1
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
d1442 1
a1442 1
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
@


1.73
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d1686 1
a1686 1
  bfd_elf64_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.72
log
@	* elf32-i386.c (elf_i386_object_p): Delete.
	(elf_backend_object_p): Don't define.
	* elf32-s390.c (elf_s390_object_p): No need to alloc tdata here.
	* elf32-sh.c (sh_elf_object_p): Likewise.
	* elf32-sparc.c (elf32_sparc_object_p): Likewise.
	* elf64-alpha.c (elf64_alpha_object_p): Likewise.
	* elf64-s390.c (elf_s390_object_p): Likewise.
	* elf64-x86-64.c (elf64_x86_64_elf_object_p): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d1823 4
a1826 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.72.6.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d954 1
a954 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d961 1
a961 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1261 11
d1300 1
a1300 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1368 1
a1368 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1453 1
a1453 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1686 1
a1686 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d1823 4
a1826 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.72.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1686 1
a1686 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d1823 4
a1826 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.72.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d954 1
a954 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d961 1
a961 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1261 11
d1300 1
a1300 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1368 1
a1368 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1453 1
a1453 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
@


1.72.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d198 1
a198 1
  size_t size;
d216 1
a216 1
	size = 216;
d223 1
a223 1
					  size, note->descpos + offset);
d564 1
a564 2
				   | ELF_LINK_HASH_NEEDS_PLT
				   | ELF_LINK_POINTER_EQUALITY_NEEDED));
d643 3
a645 2
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
				 abfd, r_symndx);
d665 3
a667 4
		(_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 abfd,
		 x86_64_elf_howto_table[r_type].name,
		 (h) ? h->root.root.string : "a local symbol");
d732 3
a734 2
		      (_("%B: %s' accessed both as normal and thread local symbol"),
		       abfd, h ? h->root.root.string : "<local>");
d790 3
a792 4
		(_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 abfd,
		 x86_64_elf_howto_table[r_type].name,
		 (h) ? h->root.root.string : "a local symbol");
a814 2
	      if (r_type != R_X86_64_PC32)
		h->elf_link_hash_flags |= ELF_LINK_POINTER_EQUALITY_NEEDED;
d879 2
a880 2
			(_("%B: bad relocation section name `%s\'"),
			 abfd, name);
d1229 1
a1229 1
      htab->srelbss->size += sizeof (Elf64_External_Rela);
d1244 1
a1244 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d1253 1
a1253 1
  h->root.u.def.value = s->size;
d1256 1
a1256 1
  s->size += h->size;
d1300 2
a1301 2
	  if (s->size == 0)
	    s->size += PLT_ENTRY_SIZE;
d1303 1
a1303 1
	  h->plt.offset = s->size;
d1318 1
a1318 1
	  s->size += PLT_ENTRY_SIZE;
d1322 1
a1322 1
	  htab->sgotplt->size += GOT_ENTRY_SIZE;
d1325 1
a1325 1
	  htab->srelplt->size += sizeof (Elf64_External_Rela);
d1362 2
a1363 2
      h->got.offset = s->size;
      s->size += GOT_ENTRY_SIZE;
d1366 1
a1366 1
	s->size += GOT_ENTRY_SIZE;
d1373 1
a1373 1
	htab->srelgot->size += sizeof (Elf64_External_Rela);
d1375 1
a1375 1
	htab->srelgot->size += 2 * sizeof (Elf64_External_Rela);
d1380 1
a1380 1
	htab->srelgot->size += sizeof (Elf64_External_Rela);
d1461 1
a1461 1
      sreloc->size += p->count * sizeof (Elf64_External_Rela);
d1521 1
a1521 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d1560 1
a1560 1
		  srel->size += p->count * sizeof (Elf64_External_Rela);
d1582 2
a1583 2
	      *local_got = s->size;
	      s->size += GOT_ENTRY_SIZE;
d1585 1
a1585 1
		s->size += GOT_ENTRY_SIZE;
d1589 1
a1589 1
		srel->size += sizeof (Elf64_External_Rela);
d1600 3
a1602 3
      htab->tls_ld_got.offset = htab->sgot->size;
      htab->sgot->size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->size += sizeof (Elf64_External_Rela);
d1628 1
a1628 1
	  if (s->size != 0 && s != htab->srelplt)
d1641 1
a1641 1
      if (s->size == 0)
d1662 1
a1662 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
d1683 1
a1683 1
      if (htab->splt->size != 0)
d1911 3
a1913 5
	  relocation = htab->sgot->output_section->vma
		       + htab->sgot->output_offset + off;
	  if (r_type != R_X86_64_GOTPCREL)
	    relocation -= htab->sgotplt->output_section->vma
			  - htab->sgotplt->output_offset;
a1943 15
	  if (info->shared
	      && !SYMBOL_REFERENCES_LOCAL (info, h)
	      && (input_section->flags & SEC_ALLOC) != 0
	      && (input_section->flags & SEC_READONLY) != 0)
	    {
	      (*_bfd_error_handler)
		(_("%B: relocation %s against `%s' can not be used when making a shared object; recompile with -fPIC"),
		 input_bfd,
		 x86_64_elf_howto_table[r_type].name,
		 (h) ? h->root.root.string : "a local symbol");
	      bfd_set_error (bfd_error_bad_value);
	      return FALSE;
	    }
	  /* Fall through.  */

d2108 1
a2108 1
		  BFD_ASSERT (rel->r_offset + 12 <= input_section->size);
d2144 1
a2144 1
		  BFD_ASSERT (rel->r_offset + 4 <= input_section->size);
d2281 1
a2281 1
	      BFD_ASSERT (rel->r_offset + 12 <= input_section->size);
d2321 1
a2321 1
	      BFD_ASSERT (rel->r_offset + 9 <= input_section->size);
d2389 3
a2391 3
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	   input_bfd,
	   input_section,
a2417 5
	      if (h != NULL
		  && h->root.type == bfd_link_hash_undefweak
		  && howto->pc_relative)
		/* Ignore reloc overflow on branches to undefweak syms.  */
		continue;
d2427 3
a2429 2
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
d2522 1
a2522 2
	     the .plt section.  Leave the value if there were any
	     relocations where pointer equality matters (this is a clue
d2525 1
a2525 3
	     library), otherwise set it to zero.  If a function is only
	     called from a binary, there is no need to slow down
	     shared libraries because of that.  */
a2526 2
	  if ((h->elf_link_hash_flags & ELF_LINK_POINTER_EQUALITY_NEEDED) == 0)
	    sym->st_value = 0;
d2645 1
a2645 1
      dynconend = (Elf64_External_Dyn *) (sdyn->contents + sdyn->size);
d2659 1
a2659 2
	      s = htab->sgotplt;
	      dyn.d_un.d_ptr = s->output_section->vma + s->output_offset;
d2668 4
a2671 1
	      dyn.d_un.d_val = s->size;
d2685 4
a2688 1
		  dyn.d_un.d_val -= s->size;
d2697 1
a2697 1
      if (htab->splt && htab->splt->size > 0)
d2731 1
a2731 1
      if (htab->sgotplt->size > 0)
a2749 4
  if (htab->sgot && htab->sgot->size > 0)
    elf_section_data (htab->sgot->output_section)->this_hdr.sh_entsize
      = GOT_ENTRY_SIZE;

a2752 9
/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
elf64_x86_64_plt_sym_val (bfd_vma i, const asection *plt,
			  const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + (i + 1) * PLT_ENTRY_SIZE;
}
a2786 1
#define elf_backend_plt_sym_val		    elf64_x86_64_plt_sym_val
@


1.72.8.4
log
@Merge from mainline.
@
text
@d556 10
a565 11
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
      dir->pointer_equality_needed |= ind->pointer_equality_needed;
    }
d773 1
a773 1
	  h->needs_plt = 1;
d811 1
a811 1
	      h->non_got_ref = 1;
d817 1
a817 1
		h->pointer_equality_needed = 1;
d849 2
a850 1
			   || !h->def_regular))))
d856 2
a857 1
		      || !h->def_regular)))
d1129 1
a1129 1
      || h->needs_plt)
d1142 1
a1142 1
	  h->needs_plt = 0;
d1158 1
a1158 1
  if (h->u.weakdef != NULL)
d1160 4
a1163 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d1165 3
a1167 1
	h->non_got_ref = h->u.weakdef->non_got_ref;
d1183 1
a1183 1
  if (!h->non_got_ref)
d1189 1
a1189 1
      h->non_got_ref = 0;
d1210 1
a1210 1
	  h->non_got_ref = 0;
d1233 1
a1233 1
      h->needs_copy = 1;
d1290 1
a1290 1
	  && !h->forced_local)
d1314 1
a1314 1
	      && !h->def_regular)
d1333 1
a1333 1
	  h->needs_plt = 0;
d1339 1
a1339 1
      h->needs_plt = 0;
d1358 1
a1358 1
	  && !h->forced_local)
d1433 3
a1435 3
      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
d1443 1
a1443 1
	      && !h->forced_local)
d1990 5
a1994 3
		  && !h->non_got_ref
		  && ((h->def_dynamic
		       && !h->def_regular)
d2032 2
a2033 1
			   || !h->def_regular))
d2407 1
a2407 1
	       && h->def_dynamic))
d2543 1
a2543 1
      if (!h->def_regular)
d2554 1
a2554 1
	  if (!h->pointer_equality_needed)
d2603 1
a2603 1
  if (h->needs_copy)
@


1.71
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@a581 8
  /* Allocate our special target data.  */
  struct elf64_x86_64_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct elf64_x86_64_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return FALSE;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
@


1.70
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d563 2
a564 1
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
@


1.69
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d1824 1
a1824 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
d2049 1
a2049 10
		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
@


1.68
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d1742 2
a1743 2
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
d1745 1
a1745 1
  return elf_hash_table (info)->tls_segment->start;
d1754 1
a1754 2
  struct elf_link_tls_segment *tls_segment
    = elf_hash_table (info)->tls_segment;
d1757 1
a1757 1
  if (tls_segment == NULL)
d1759 1
a1759 2
  return address - align_power (tls_segment->size, tls_segment->align)
	 - tls_segment->start;
@


1.67
log
@Better handking for unresolved symbols
@
text
@a2794 1
#define elf_backend_plt_header_size	    PLT_ENTRY_SIZE
@


1.66
log
@	* elf32-i386.c (elf_i386_relocate_section): Make undefined symbols
	fatal if -pie.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(ppc_elf_relocate_section) <case R_PPC_RELAX32>: Issue fatal error
	on undefined symbols if -pie.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
@
text
@d1830 1
a1830 4
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d1832 4
a1835 34
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      if (sec->output_section == NULL)
		{
		  /* Set a flag that will be cleared later if we find a
		     relocation value for this symbol.  output_section
		     is typically NULL for symbols satisfied by a shared
		     library.  */
		  unresolved_reloc = TRUE;
		  relocation = 0;
		}
	      else
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else if (!info->executable
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->executable || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      relocation = 0;
	    }
@


1.65
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d1864 1
a1864 1
		      (!info->shared || info->no_undefined
@


1.64
log
@	* elf-bfd.h (SYMBOL_REFERENCES_LOCAL, SYMBOL_CALLS_LOCAL): Use..
	(_bfd_elf_symbol_refs_local_p): ..this.  Declare.
	* elflink.c (_bfd_elf_symbol_refs_local_p): New function.
	* elf32-i386.c (elf_i386_relocate_section): Remove h NULL test
	now done in _bfd_elf_symbol_refs_local_p.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@d504 1
a504 1
elf64_x86_64_copy_indirect_symbol (struct elf_backend_data *bed,
@


1.63
log
@bfd/
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add rel_fptr_sec.
	(elfNN_ia64_dynamic_symbol_p): Change info->shared into
	!info->executable.
	(get_fptr): For -pie create .opd as writable section and create
	.rela.opd as well.
	(elfNN_ia64_check_relocs): Change info->shared into
	!info->executable.
	(allocate_fptr): Likewise.
	(allocate_dynrel_entries): Account for a relative reloc for -pie
	@@fptr().  Don't account for a relative reloc if -pie want_ltoff_fptr
	for undefweak symbol.  Account for an IPLT reloc in .rela.opd
	section if -pie.
	(set_got_entry): Don't create a relative reloc if -pie
	want_ltoff_fptr for undefweak symbol.
	(set_fptr_entry): Emit an IPLT reloc in .rela.opd for -pie.
	(elfNN_ia64_relocate_section): Emit a relative reloc for -pie
	@@fptr().

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Issue undefined_symbol
	even if -pie.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
ld/
	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Don't include
	.opd if -pie.
	(OTHER_READWRITE_SECTIONS): Include .opd if -pie.
	* scripttempl/elf.sc: Use SHLIB_DATA_ADDR instead of DATA_ADDR
	if -pie.
@
text
@d2018 1
a2018 2
		   || (h != NULL
		       && !SYMBOL_CALLS_LOCAL (info, h))))
@


1.62
log
@	* elf64-x86-64.c: Convert to ISO C90 prototypes, remove
	unnecessary prototypes.  Replace PTR with void *.
@
text
@d1855 1
a1855 1
	  else if (info->shared
@


1.61
log
@Correct spelling of "relocatable".
@
text
@a152 58
static reloc_howto_type *elf64_x86_64_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void elf64_x86_64_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean elf64_x86_64_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
static bfd_boolean elf64_x86_64_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
static struct bfd_link_hash_table *elf64_x86_64_link_hash_table_create
  PARAMS ((bfd *));
static int elf64_x86_64_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));
static bfd_boolean elf64_x86_64_mkobject
  PARAMS((bfd *));
static bfd_boolean elf64_x86_64_elf_object_p PARAMS ((bfd *abfd));
static bfd_boolean create_got_section
  PARAMS((bfd *, struct bfd_link_info *));
static bfd_boolean elf64_x86_64_create_dynamic_sections
  PARAMS((bfd *, struct bfd_link_info *));
static void elf64_x86_64_copy_indirect_symbol
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
static bfd_boolean elf64_x86_64_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *sec,
	   const Elf_Internal_Rela *));
static asection *elf64_x86_64_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));

static bfd_boolean elf64_x86_64_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));

static struct bfd_hash_entry *link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static bfd_boolean elf64_x86_64_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));

static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf64_x86_64_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
static bfd_boolean elf64_x86_64_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	 Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf64_x86_64_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *sym));
static bfd_boolean elf64_x86_64_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static enum elf_reloc_type_class elf64_x86_64_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
d156 2
a157 3
elf64_x86_64_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d160 1
d173 2
a174 4
elf64_x86_64_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d195 1
a195 3
elf64_x86_64_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d227 1
a227 3
elf64_x86_64_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
d386 2
a387 4
link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d416 1
a416 2
elf64_x86_64_link_hash_table_create (abfd)
     bfd *abfd;
d448 1
a448 3
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d477 1
a477 3
elf64_x86_64_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d504 3
a506 3
elf64_x86_64_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
     struct elf_link_hash_entry *dir, *ind;
d569 1
a569 2
elf64_x86_64_mkobject (abfd)
     bfd *abfd;
d579 1
a579 2
elf64_x86_64_elf_object_p (abfd)
  bfd *abfd;
d595 1
a595 4
elf64_x86_64_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
d619 2
a620 5
elf64_x86_64_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d984 5
a988 6
elf64_x86_64_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1022 2
a1023 5
elf64_x86_64_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1122 2
a1123 3
elf64_x86_64_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d1136 3
a1138 5
	  || (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
	      && h->root.type != bfd_link_hash_undefweak
	      && h->root.type != bfd_link_hash_undefined))
d1272 1
a1272 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
d1274 1
a1274 1
   && ((INFO)->shared							\
d1283 1
a1283 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1300 1
a1300 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1311 2
a1312 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d1396 2
a1397 1
	       && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d1415 7
a1421 3
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
d1488 1
a1488 3
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1517 2
a1518 3
elf64_x86_64_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d1740 1
a1740 2
dtpoff_base (info)
     struct bfd_link_info *info;
d1752 1
a1752 3
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
d1767 5
a1771 10
elf64_x86_64_relocate_section (output_bfd, info, input_bfd, input_section,
			       contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d1889 1
a1889 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d1891 1
a1891 4
		      && (info->symbolic
			  || h->dynindx == -1
			  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d2019 1
a2019 4
		       && h->dynindx != -1
		       && (! info->symbolic
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d2506 4
a2509 5
elf64_x86_64_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d2615 1
a2615 4
	  && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d2672 1
a2672 2
elf64_x86_64_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d2690 1
a2690 3
elf64_x86_64_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
@


1.60
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d708 1
a708 1
  if (info->relocateable)
d1875 1
a1875 1
  if (info->relocateable)
@


1.59
log
@	* elf32-i386.c (allocate_dynrelocs): For undef weak syms with
	non-default visibility, a) don't make them dynamic, b) discard
	space for dynamic relocs.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.

	* elf32-ppc.c (allocate_dynrelocs): For undef weak syms with
	non-default visibility, a) don't allocate plt entries, b) don't
	allocate .got relocs, c) discard dyn rel space,
	(ppc_elf_relocate_section): d) don't generate .got relocs, e)
	don't generate dynamic relocs.
	* elf64-ppc.c (allocate_dynrelocs): As above.
	(ppc64_elf_relocate_section): As above.
@
text
@d1621 1
a1621 1
      if (! info->shared)
d1782 1
a1782 1
      if (! info->shared)
@


1.58
log
@	* elf64-x86-64.c (allocate_dynrelocs): Don't allocate dynamic
	relocation entries for weak undefined symbols with non-default
	visibility.
	(elf64_x86_64_relocate_section): Initialize the GOT entries and
	skip R_386_32/R_386_PC32 for weak undefined symbols with
	non-default visibility.
@
text
@d1388 3
a1390 1
      && h->plt.refcount > 0)
d1401 1
a1401 3
      if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	   || h->root.type != bfd_link_hash_undefweak)
	  && WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d1519 6
@


1.57
log
@
	* elf64-x86-64.c (elf_x86_64_copy_indirect_symbol): Don't copy
	ELF_LINK_NON_GOT_REF for weakdefs when symbol already adjusted.
	(ELIMINATE_COPY_RELOCS): Define as one.  Use throughout.
	(elf_x86_64_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
@
text
@d1399 3
a1401 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d1483 3
a1485 1
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d1983 3
a1985 1
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2104 3
@


1.56
log
@	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Simplify dynamic reloc
	removal.  Localize vars.  Remove unnecessary dynobj test.
	* elf32-i386 (WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead
	of INFO.
	(allocate_dynrelocs): Adjust WILL_CALL_FINISH_DYNAMIC_SYMBOL uses,
	and optimize.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_gc_sweep_hook): Simplify dyn reloc removal.  Localize vars.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.  Remove
	local_dynrel for section too.  Don't touch HIPLT22, LOPLT10, PCPLT32
	or PCPLT10 relocs.  Don't subtract twice on PLT32 relocs.
	Formatting.
@
text
@d327 6
d625 12
a636 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d934 2
a935 1
	      || (!info->shared
a1209 2
  struct elf64_x86_64_link_hash_entry * eh;
  struct elf64_x86_64_dyn_relocs *p;
d1254 4
d1283 1
a1283 2
  eh = (struct elf64_x86_64_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d1285 10
a1294 4
      s = p->sec->output_section;
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	break;
    }
d1296 7
a1302 6
  /* If we didn't find any dynamic relocs in read-only sections, then
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
d1516 1
a1516 1
  else
d2106 2
a2107 1
	      || (!info->shared
d2381 1
a2381 1
	    	      BFD_ASSERT (! unresolved_reloc);
@


1.56.16.1
log
@Merge from mainline.
@
text
@a326 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d619 1
a619 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d917 1
a917 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1192 2
a1237 4
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1263 2
a1264 1
  if (ELIMINATE_COPY_RELOCS)
d1266 4
a1269 2
      struct elf64_x86_64_link_hash_entry * eh;
      struct elf64_x86_64_dyn_relocs *p;
d1271 6
a1276 15
      eh = (struct elf64_x86_64_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1490 1
a1490 1
  else if (ELIMINATE_COPY_RELOCS)
d2080 1
a2080 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d2354 1
a2354 1
		      BFD_ASSERT (! unresolved_reloc);
@


1.56.16.2
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@d1388 1
a1388 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1481 1
a1481 3
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
a1514 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1979 1
a1979 3
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
a2097 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
@


1.56.18.1
log
@	* elf64-x86-64.c (elf_x86_64_copy_indirect_symbol): Don't copy
	ELF_LINK_NON_GOT_REF for weakdefs when symbol already adjusted.
	(ELIMINATE_COPY_RELOCS): Define as one.  Use throughout.
	(elf_x86_64_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
@
text
@a326 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d619 1
a619 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d917 1
a917 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1192 2
a1237 4
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1263 2
a1264 1
  if (ELIMINATE_COPY_RELOCS)
d1266 4
a1269 2
      struct elf64_x86_64_link_hash_entry * eh;
      struct elf64_x86_64_dyn_relocs *p;
d1271 6
a1276 15
      eh = (struct elf64_x86_64_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1490 1
a1490 1
  else if (ELIMINATE_COPY_RELOCS)
d2080 1
a2080 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d2354 1
a2354 1
		      BFD_ASSERT (! unresolved_reloc);
@


1.55
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@a1093 3
  unsigned long r_symndx;
  int r_type;
  struct elf_link_hash_entry *h;
d1103 4
a1106 9
    switch ((r_type = elf64_x86_64_tls_transition (info,
						   ELF64_R_TYPE (rel->r_info),
						   ELF64_R_SYM (rel->r_info)
						   >= symtab_hdr->sh_info)))
      {
      case R_X86_64_TLSLD:
	if (elf64_x86_64_hash_table (info)->tls_ld_got.refcount > 0)
	  elf64_x86_64_hash_table (info)->tls_ld_got.refcount -= 1;
	break;
d1108 6
a1113 17
      case R_X86_64_TLSGD:
      case R_X86_64_GOTTPOFF:
      case R_X86_64_GOT32:
      case R_X86_64_GOTPCREL:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;
d1115 2
a1116 16
      case R_X86_64_8:
      case R_X86_64_16:
      case R_X86_64_32:
      case R_X86_64_64:
      case R_X86_64_32S:
      case R_X86_64_PC8:
      case R_X86_64_PC16:
      case R_X86_64_PC32:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf64_x86_64_link_hash_entry *eh;
	    struct elf64_x86_64_dyn_relocs **pp;
	    struct elf64_x86_64_dyn_relocs *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d1118 8
a1125 2
	    if (!info->shared && h->plt.refcount > 0)
	      h->plt.refcount -= 1;
d1127 8
a1134 1
	    eh = (struct elf64_x86_64_link_hash_entry *) h;
d1136 15
a1150 14
	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
		{
		  if (ELF64_R_TYPE (rel->r_info) == R_X86_64_PC8
		      || ELF64_R_TYPE (rel->r_info) == R_X86_64_PC16
		      || ELF64_R_TYPE (rel->r_info) == R_X86_64_PC32)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
	  }
	break;
d1152 11
d1164 7
a1170 9
      case R_X86_64_PLT32:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;
d1172 4
a1175 3
      default:
	break;
      }
d2322 1
a2322 1
          else
d2400 1
a2400 1
	        BFD_ASSERT (bfd_get_8 (input_bfd,
d2405 1
a2405 1
	        BFD_ASSERT (bfd_get_8 (input_bfd,
@


1.54
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a1923 1
		   && (!info->symbolic || info->allow_shlib_undefined)
a2107 1

a2592 1

a2670 1

@


1.53
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d37 68
a104 68
  HOWTO(R_X86_64_NONE, 0, 0, 0, false, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_X86_64_NONE",	false, 0x00000000, 0x00000000,
	false),
  HOWTO(R_X86_64_64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_64", false, MINUS_ONE, MINUS_ONE,
	false),
  HOWTO(R_X86_64_PC32, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC32", false, 0xffffffff, 0xffffffff,
	true),
  HOWTO(R_X86_64_GOT32, 0, 2, 32, false, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOT32", false, 0xffffffff, 0xffffffff,
	false),
  HOWTO(R_X86_64_PLT32, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PLT32", false, 0xffffffff, 0xffffffff,
	true),
  HOWTO(R_X86_64_COPY, 0, 2, 32, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_COPY", false, 0xffffffff, 0xffffffff,
	false),
  HOWTO(R_X86_64_GLOB_DAT, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_GLOB_DAT", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_JUMP_SLOT, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_RELATIVE, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_GOTPCREL, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_32, 0, 2, 32, false, 0, complain_overflow_unsigned,
	bfd_elf_generic_reloc, "R_X86_64_32", false, 0xffffffff, 0xffffffff,
	false),
  HOWTO(R_X86_64_32S, 0, 2, 32, false, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_32S", false, 0xffffffff, 0xffffffff,
	false),
  HOWTO(R_X86_64_16, 0, 1, 16, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_16", false, 0xffff, 0xffff, false),
  HOWTO(R_X86_64_PC16,0, 1, 16, true, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_PC16", false, 0xffff, 0xffff, true),
  HOWTO(R_X86_64_8, 0, 0, 8, false, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_8", false, 0xff, 0xff, false),
  HOWTO(R_X86_64_PC8, 0, 0, 8, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC8", false, 0xff, 0xff, true),
  HOWTO(R_X86_64_DTPMOD64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPMOD64", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_DTPOFF64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF64", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_TPOFF64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF64", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_TLSGD, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSGD", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_TLSLD, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSLD", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_DTPOFF32, 0, 2, 32, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF32", false, 0xffffffff,
	0xffffffff, false),
  HOWTO(R_X86_64_GOTTPOFF, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTTPOFF", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_TPOFF32, 0, 2, 32, false, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF32", false, 0xffffffff,
	0xffffffff, false),
d107 2
a108 2
  HOWTO (R_X86_64_GNU_VTINHERIT, 0, 4, 0, false, 0, complain_overflow_dont,
	 NULL, "R_X86_64_GNU_VTINHERIT", false, 0, 0, false),
d111 3
a113 3
  HOWTO (R_X86_64_GNU_VTENTRY, 0, 4, 0, false, 0, complain_overflow_dont,
	 _bfd_elf_rel_vtable_reloc_fn, "R_X86_64_GNU_VTENTRY", false, 0, 0,
	 false)
d157 1
a157 1
static boolean elf64_x86_64_grok_prstatus
d159 1
a159 1
static boolean elf64_x86_64_grok_psinfo
d165 1
a165 1
static boolean elf64_x86_64_mkobject
d167 2
a168 2
static boolean elf64_x86_64_elf_object_p PARAMS ((bfd *abfd));
static boolean create_got_section
d170 1
a170 1
static boolean elf64_x86_64_create_dynamic_sections
d175 1
a175 1
static boolean elf64_x86_64_check_relocs
d182 1
a182 1
static boolean elf64_x86_64_gc_sweep_hook
d188 1
a188 1
static boolean elf64_x86_64_adjust_dynamic_symbol
d191 1
a191 1
static boolean allocate_dynrelocs
d193 1
a193 1
static boolean readonly_dynrelocs
d195 1
a195 1
static boolean elf64_x86_64_size_dynamic_sections
d201 1
a201 1
static boolean elf64_x86_64_relocate_section
d204 1
a204 1
static boolean elf64_x86_64_finish_dynamic_symbol
d207 1
a207 1
static boolean elf64_x86_64_finish_dynamic_sections
d254 1
a254 1
static boolean
d265 1
a265 1
	return false;
d288 1
a288 1
static boolean
d296 1
a296 1
	return false;
d317 1
a317 1
  return true;
d508 1
a508 1
static boolean
d516 1
a516 1
    return false;
d531 2
a532 2
    return false;
  return true;
d539 1
a539 1
static boolean
d548 1
a548 1
    return false;
d551 1
a551 1
    return false;
d563 1
a563 1
  return true;
d622 1
a622 1
static boolean
d629 2
a630 2
    return false;
  return true;
d633 1
a633 1
static boolean
d642 1
a642 1
    return false;
d647 1
a647 1
  return true;
d677 1
a677 1
static boolean
d692 1
a692 1
    return true;
d715 1
a715 1
	  return false;
d738 1
a738 1
	      return false;
d781 1
a781 1
		      return false;
d804 1
a804 1
		    return false;
d825 1
a825 1
		return false;
d863 1
a863 1
	      return false;
d940 1
a940 1
		    return false;
d969 1
a969 1
			return false;
d990 1
a990 1
		    return false;
d1003 1
a1003 1
		    return false;
d1023 1
a1023 1
	    return false;
d1030 1
a1030 1
	    return false;
d1038 1
a1038 1
  return true;
d1083 1
a1083 1
static boolean
d1186 1
a1186 1
  return true;
d1195 1
a1195 1
static boolean
d1228 1
a1228 1
      return true;
d1247 1
a1247 1
      return true;
d1258 1
a1258 1
    return true;
d1263 1
a1263 1
    return true;
d1269 1
a1269 1
      return true;
d1285 1
a1285 1
      return true;
d1324 1
a1324 1
	return false;
d1334 1
a1334 1
  return true;
d1351 1
a1351 1
static boolean
d1362 1
a1362 1
    return true;
d1379 1
a1379 1
	    return false;
d1437 1
a1437 1
      boolean dyn;
d1446 1
a1446 1
	    return false;
d1472 1
a1472 1
    return true;
d1518 1
a1518 1
		return false;
d1539 1
a1539 1
  return true;
d1544 1
a1544 1
static boolean
d1567 1
a1567 1
	  return false;
d1570 1
a1570 1
  return true;
d1575 1
a1575 1
static boolean
d1583 1
a1583 1
  boolean relocs;
d1691 1
a1691 1
  relocs = false;
d1707 1
a1707 1
	    relocs = true;
d1742 1
a1742 1
	return false;
d1758 1
a1758 1
	    return false;
d1767 1
a1767 1
	    return false;
d1775 1
a1775 1
	    return false;
d1786 1
a1786 1
		return false;
d1792 1
a1792 1
  return true;
d1829 1
a1829 1
static boolean
d1849 1
a1849 1
    return true;
d1868 1
a1868 1
      boolean unresolved_reloc;
d1880 1
a1880 1
	  return false;
d1888 1
a1888 1
      unresolved_reloc = false;
d1913 1
a1913 1
		  unresolved_reloc = true;
d1935 1
a1935 1
		return false;
d1953 1
a1953 1
	      boolean dyn;
d1986 1
a1986 1
		unresolved_reloc = false;
d2061 1
a2061 1
	  unresolved_reloc = false;
d2103 1
a2103 1
	      boolean skip, relocate;
d2110 2
a2111 2
	      skip = false;
	      relocate = false;
d2117 1
a2117 1
		skip = true;
d2119 1
a2119 1
		skip = true, relocate = true;
d2147 1
a2147 1
		      relocate = true;
d2169 1
a2169 1
			  return false;
d2395 1
a2395 1
	      unresolved_reloc = false;
d2496 1
a2496 1
	  unresolved_reloc = false;
d2544 1
a2544 1
		return false;
d2555 1
a2555 1
		return false;
d2564 1
a2564 1
	      return false;
d2569 1
a2569 1
  return true;
d2575 1
a2575 1
static boolean
d2741 1
a2741 1
  return true;
d2766 1
a2766 1
static boolean
d2892 1
a2892 1
  return true;
@


1.52
log
@bfd/
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Change TLSGD
	sequence and its transitions.
ld/testsuite/
	* ld-x86-64/tlspic1.s: Change TLSGD sequences.
	* ld-x86-64/tlsbinpic.s: Likewise.
	* ld-x86-64/tlspic.dd: Adjust.
@
text
@d156 1
a156 1
  PARAMS ((bfd *, arelent *, Elf64_Internal_Rela *));
d234 1
a234 1
     Elf64_Internal_Rela *dst;
d2007 1
a2007 1
		      asection *srelgot;
d2009 1
a2009 1
		      Elf64_External_Rela *loc;
d2013 2
a2014 2
		      srelgot = htab->srelgot;
		      if (srelgot == NULL)
d2022 2
a2023 2
		      loc = (Elf64_External_Rela *) srelgot->contents;
		      loc += srelgot->reloc_count++;
d2102 1
a2104 1
	      Elf64_External_Rela *loc;
d2189 2
a2190 2
	      loc = (Elf64_External_Rela *) sreloc->contents;
	      loc += sreloc->reloc_count++;
d2336 1
a2336 1
	      Elf64_External_Rela *loc;
d2357 2
a2358 2
	      loc = (Elf64_External_Rela *) htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++;
d2378 2
a2379 3
		      loc++;
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						 loc);
d2475 1
a2475 1
	      Elf64_External_Rela *loc;
d2489 2
a2490 2
	      loc = (Elf64_External_Rela *) htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++;
d2591 1
a2591 1
      Elf64_External_Rela *loc;
d2651 1
a2651 1
      loc = (Elf64_External_Rela *) htab->srelplt->contents + plt_index;
d2670 1
a2670 1
      Elf64_External_Rela *loc;
d2708 2
a2709 2
      loc = (Elf64_External_Rela *) htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++;
d2716 1
a2716 1
      Elf64_External_Rela *loc;
d2731 2
a2732 2
      loc = (Elf64_External_Rela *) htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++;
@


1.52.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d37 68
a104 68
  HOWTO(R_X86_64_NONE, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_X86_64_NONE",	FALSE, 0x00000000, 0x00000000,
	FALSE),
  HOWTO(R_X86_64_64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_64", FALSE, MINUS_ONE, MINUS_ONE,
	FALSE),
  HOWTO(R_X86_64_PC32, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC32", FALSE, 0xffffffff, 0xffffffff,
	TRUE),
  HOWTO(R_X86_64_GOT32, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOT32", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_PLT32, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PLT32", FALSE, 0xffffffff, 0xffffffff,
	TRUE),
  HOWTO(R_X86_64_COPY, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_COPY", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_GLOB_DAT, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_GLOB_DAT", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_JUMP_SLOT, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_RELATIVE, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_GOTPCREL, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_32, 0, 2, 32, FALSE, 0, complain_overflow_unsigned,
	bfd_elf_generic_reloc, "R_X86_64_32", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_32S, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_32S", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_16, 0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_16", FALSE, 0xffff, 0xffff, FALSE),
  HOWTO(R_X86_64_PC16,0, 1, 16, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_PC16", FALSE, 0xffff, 0xffff, TRUE),
  HOWTO(R_X86_64_8, 0, 0, 8, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_8", FALSE, 0xff, 0xff, FALSE),
  HOWTO(R_X86_64_PC8, 0, 0, 8, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC8", FALSE, 0xff, 0xff, TRUE),
  HOWTO(R_X86_64_DTPMOD64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPMOD64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_DTPOFF64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_TPOFF64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_TLSGD, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSGD", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_TLSLD, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSLD", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_DTPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF32", FALSE, 0xffffffff,
	0xffffffff, FALSE),
  HOWTO(R_X86_64_GOTTPOFF, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTTPOFF", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_TPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF32", FALSE, 0xffffffff,
	0xffffffff, FALSE),
d107 2
a108 2
  HOWTO (R_X86_64_GNU_VTINHERIT, 0, 4, 0, FALSE, 0, complain_overflow_dont,
	 NULL, "R_X86_64_GNU_VTINHERIT", FALSE, 0, 0, FALSE),
d111 3
a113 3
  HOWTO (R_X86_64_GNU_VTENTRY, 0, 4, 0, FALSE, 0, complain_overflow_dont,
	 _bfd_elf_rel_vtable_reloc_fn, "R_X86_64_GNU_VTENTRY", FALSE, 0, 0,
	 FALSE)
d153 58
d214 3
a216 2
elf64_x86_64_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				bfd_reloc_code_real_type code)
a218 1

d231 4
a234 2
elf64_x86_64_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			    Elf_Internal_Rela *dst)
d254 4
a257 2
static bfd_boolean
elf64_x86_64_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d265 1
a265 1
	return FALSE;
d288 4
a291 2
static bfd_boolean
elf64_x86_64_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d296 1
a296 1
	return FALSE;
d317 1
a317 1
  return TRUE;
a326 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d444 4
a447 2
link_hash_newfunc (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
		   const char *string)
d476 2
a477 1
elf64_x86_64_link_hash_table_create (bfd *abfd)
d508 4
a511 2
static bfd_boolean
create_got_section (bfd *dynobj, struct bfd_link_info *info)
d516 1
a516 1
    return FALSE;
d531 2
a532 2
    return FALSE;
  return TRUE;
d539 4
a542 2
static bfd_boolean
elf64_x86_64_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
d548 1
a548 1
    return FALSE;
d551 1
a551 1
    return FALSE;
d563 1
a563 1
  return TRUE;
d569 3
a571 3
elf64_x86_64_copy_indirect_symbol (const struct elf_backend_data *bed,
				   struct elf_link_hash_entry *dir,
				   struct elf_link_hash_entry *ind)
d619 1
a619 13
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d622 3
a624 2
static bfd_boolean
elf64_x86_64_mkobject (bfd *abfd)
d629 2
a630 2
    return FALSE;
  return TRUE;
d633 3
a635 2
static bfd_boolean
elf64_x86_64_elf_object_p (bfd *abfd)
d637 8
d647 1
a647 1
  return TRUE;
d651 4
a654 1
elf64_x86_64_tls_transition (struct bfd_link_info *info, int r_type, int is_local)
d677 6
a682 3
static bfd_boolean
elf64_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
			   const Elf_Internal_Rela *relocs)
d691 2
a692 2
  if (info->relocatable)
    return TRUE;
d715 1
a715 1
	  return FALSE;
d738 1
a738 1
	      return FALSE;
d781 1
a781 1
		      return FALSE;
d804 1
a804 1
		    return FALSE;
d825 1
a825 1
		return FALSE;
d863 1
a863 1
	      return FALSE;
d917 1
a917 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d940 1
a940 1
		    return FALSE;
d969 1
a969 1
			return FALSE;
d990 1
a990 1
		    return FALSE;
d1003 1
a1003 1
		    return FALSE;
d1023 1
a1023 1
	    return FALSE;
d1030 1
a1030 1
	    return FALSE;
d1038 1
a1038 1
  return TRUE;
d1045 6
a1050 5
elf64_x86_64_gc_mark_hook (asection *sec,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   Elf_Internal_Rela *rel,
			   struct elf_link_hash_entry *h,
			   Elf_Internal_Sym *sym)
d1083 6
a1088 3
static bfd_boolean
elf64_x86_64_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
			    asection *sec, const Elf_Internal_Rela *relocs)
d1094 3
d1106 27
a1132 4
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;
d1134 14
a1147 6
      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf64_x86_64_link_hash_entry *eh;
	  struct elf64_x86_64_dyn_relocs **pp;
	  struct elf64_x86_64_dyn_relocs *p;
d1149 1
a1149 2
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf64_x86_64_link_hash_entry *) h;
d1151 2
a1152 8
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
d1154 1
a1154 8
      r_type = ELF64_R_TYPE (rel->r_info);
      r_type = elf64_x86_64_tls_transition (info, r_type, h != NULL);
      switch (r_type)
	{
	case R_X86_64_TLSLD:
	  if (elf64_x86_64_hash_table (info)->tls_ld_got.refcount > 0)
	    elf64_x86_64_hash_table (info)->tls_ld_got.refcount -= 1;
	  break;
d1156 14
a1169 15
	case R_X86_64_TLSGD:
	case R_X86_64_GOTTPOFF:
	case R_X86_64_GOT32:
	case R_X86_64_GOTPCREL:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
a1170 11
	case R_X86_64_8:
	case R_X86_64_16:
	case R_X86_64_32:
	case R_X86_64_64:
	case R_X86_64_32S:
	case R_X86_64_PC8:
	case R_X86_64_PC16:
	case R_X86_64_PC32:
	  if (info->shared)
	    break;
	  /* Fall thru */
d1172 9
a1180 7
	case R_X86_64_PLT32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d1182 3
a1184 4
	default:
	  break;
	}
    }
d1186 1
a1186 1
  return TRUE;
d1195 4
a1198 3
static bfd_boolean
elf64_x86_64_adjust_dynamic_symbol (struct bfd_link_info *info,
				    struct elf_link_hash_entry *h)
d1201 2
d1213 5
a1217 3
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d1228 1
a1228 1
      return TRUE;
d1247 1
a1247 5
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
      return TRUE;
d1258 1
a1258 1
    return TRUE;
d1263 1
a1263 1
    return TRUE;
d1269 1
a1269 1
      return TRUE;
d1272 2
a1273 1
  if (ELIMINATE_COPY_RELOCS)
d1275 4
a1278 2
      struct elf64_x86_64_link_hash_entry * eh;
      struct elf64_x86_64_dyn_relocs *p;
d1280 6
a1285 15
      eh = (struct elf64_x86_64_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1324 1
a1324 1
	return FALSE;
d1334 1
a1334 1
  return TRUE;
d1341 1
a1341 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d1343 1
a1343 1
   && ((SHARED)								\
d1351 4
a1354 2
static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d1362 1
a1362 1
    return TRUE;
d1379 1
a1379 1
	    return FALSE;
d1382 1
a1382 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d1437 1
a1437 1
      bfd_boolean dyn;
d1446 1
a1446 1
	    return FALSE;
d1464 1
a1464 4
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
d1472 1
a1472 1
    return TRUE;
d1482 3
a1484 7
      /* Relocs that use pc_count are those that appear on a call
	 insn, or certain REL relocs that can generated via assembly.
	 We want calls to protected symbols to resolve directly to the
	 function rather than going via the plt.  If people want
	 function pointer comparisons to work as expected then they
	 should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
a1497 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1499 1
a1499 1
  else if (ELIMINATE_COPY_RELOCS)
d1518 1
a1518 1
		return FALSE;
d1539 1
a1539 1
  return TRUE;
d1544 4
a1547 2
static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d1567 1
a1567 1
	  return FALSE;
d1570 1
a1570 1
  return TRUE;
d1575 4
a1578 3
static bfd_boolean
elf64_x86_64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info)
d1583 1
a1583 1
  bfd_boolean relocs;
d1594 1
a1594 1
      if (info->executable)
d1691 1
a1691 1
  relocs = FALSE;
d1707 1
a1707 1
	    relocs = TRUE;
d1742 1
a1742 1
	return FALSE;
d1755 1
a1755 1
      if (info->executable)
d1758 1
a1758 1
	    return FALSE;
d1767 1
a1767 1
	    return FALSE;
d1775 1
a1775 1
	    return FALSE;
d1786 1
a1786 1
		return FALSE;
d1792 1
a1792 1
  return TRUE;
d1800 2
a1801 1
dtpoff_base (struct bfd_link_info *info)
d1803 2
a1804 2
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
d1806 1
a1806 1
  return elf_hash_table (info)->tls_sec->vma;
d1813 3
a1815 1
tpoff (struct bfd_link_info *info, bfd_vma address)
d1817 2
a1818 1
  struct elf_link_hash_table *htab = elf_hash_table (info);
d1821 1
a1821 1
  if (htab->tls_sec == NULL)
d1823 2
a1824 1
  return address - htab->tls_size - htab->tls_sec->vma;
d1829 11
a1839 6
static bfd_boolean
elf64_x86_64_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			       bfd *input_bfd, asection *input_section,
			       bfd_byte *contents, Elf_Internal_Rela *relocs,
			       Elf_Internal_Sym *local_syms,
			       asection **local_sections)
d1848 2
a1849 2
  if (info->relocatable)
    return TRUE;
d1868 1
a1868 1
      bfd_boolean unresolved_reloc;
d1880 1
a1880 1
	  return FALSE;
d1888 1
a1888 1
      unresolved_reloc = FALSE;
d1894 1
a1894 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1898 4
a1901 1
	  bfd_boolean warned;
d1903 35
a1937 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
d1953 1
a1953 1
	      bfd_boolean dyn;
d1958 1
a1958 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d1960 4
a1963 3
		      && SYMBOL_REFERENCES_LOCAL (info, h))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
d1986 1
a1986 1
		unresolved_reloc = FALSE;
d2007 1
a2007 1
		      asection *s;
d2009 1
a2009 1
		      bfd_byte *loc;
d2013 2
a2014 2
		      s = htab->srelgot;
		      if (s == NULL)
d2022 2
a2023 2
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
d2061 1
a2061 1
	  unresolved_reloc = FALSE;
a2081 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d2085 6
a2090 3
		   || !SYMBOL_CALLS_LOCAL (info, h)))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d2102 1
a2102 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d2104 1
d2109 3
a2111 2
	      skip = FALSE;
	      relocate = FALSE;
d2117 1
a2117 1
		skip = TRUE;
d2119 1
a2119 1
		skip = TRUE, relocate = TRUE;
d2147 1
a2147 1
		      relocate = TRUE;
d2155 10
a2164 1
		      if (bfd_is_abs_section (sec))
d2169 1
a2169 1
			  return FALSE;
d2189 2
a2190 2
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
d2333 1
a2333 1
	  else
d2336 1
a2336 1
	      bfd_byte *loc;
d2357 2
a2358 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d2365 1
a2365 1
		      BFD_ASSERT (! unresolved_reloc);
d2378 3
a2380 2
		      loc += sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d2396 1
a2396 1
	      unresolved_reloc = FALSE;
d2412 1
a2412 1
		BFD_ASSERT (bfd_get_8 (input_bfd,
d2417 1
a2417 1
		BFD_ASSERT (bfd_get_8 (input_bfd,
d2476 1
a2476 1
	      bfd_byte *loc;
d2490 2
a2491 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d2497 1
a2497 1
	  unresolved_reloc = FALSE;
d2545 1
a2545 1
		return FALSE;
d2556 1
a2556 1
		return FALSE;
d2565 1
a2565 1
	      return FALSE;
d2570 1
a2570 1
  return TRUE;
d2576 6
a2581 5
static bfd_boolean
elf64_x86_64_finish_dynamic_symbol (bfd *output_bfd,
				    struct bfd_link_info *info,
				    struct elf_link_hash_entry *h,
				    Elf_Internal_Sym *sym)
d2592 1
a2592 1
      bfd_byte *loc;
d2596 1
d2652 1
a2652 1
      loc = htab->srelplt->contents + plt_index * sizeof (Elf64_External_Rela);
d2671 1
a2671 1
      bfd_byte *loc;
d2675 1
d2689 4
a2692 1
	  && SYMBOL_REFERENCES_LOCAL (info, h))
d2709 2
a2710 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d2717 1
a2717 1
      bfd_byte *loc;
d2732 2
a2733 2
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf64_External_Rela);
d2742 1
a2742 1
  return TRUE;
d2749 2
a2750 1
elf64_x86_64_reloc_type_class (const Elf_Internal_Rela *rela)
d2767 4
a2770 2
static bfd_boolean
elf64_x86_64_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
d2893 1
a2893 1
  return TRUE;
d2909 1
@


1.51
log
@bfd/
	* elf32-i386.c (elf_i386_relocate_section): Resolve R_386_TLS_LDO_32
	to st_value + addend in non-code sections.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Resolve
	R_X86_64_DTPOFF32 to st_value + addend in non-code sections.

ld/testsuite/
	* ld-i386/i386.exp: Add tlsg test.
	* ld-i386/tlsg.s: New test.
	* ld-i386/tlsg.sd: New test.
	* ld-i386/tlsbin.dd: Change LD into LD -> LE in comments.
	* ld-i386/tlsbinpic.s: Likewise.
	* ld-x86-64/x86-64.exp: Add tlsg test.
	* ld-x86-64/tlsg.s: New test.
	* ld-x86-64/tlsg.sd: New test.
	* ld-x86-64/tlsbin.dd: Change LD into LD -> LE in comments.
	* ld-x86-64/tlsbinpic.s: Likewise.
@
text
@d2227 2
a2228 2
		  static unsigned char tlsgd[7]
		    = { 0x66, 0x66, 0x66, 0x66, 0x48, 0x8d, 0x3d };
d2231 2
a2232 2
		     .long 0x66666666; leaq foo@@tlsgd(%rip), %rdi
		     callq __tls_get_addr@@plt
d2236 2
a2237 2
		  BFD_ASSERT (rel->r_offset >= 7);
		  for (i = 0; i < 7; i++)
d2239 1
a2239 1
					   contents + rel->r_offset - 7 + i)
d2241 5
a2245 4
		  BFD_ASSERT (rel->r_offset + 9 <= input_section->_raw_size);
		  BFD_ASSERT (bfd_get_8 (input_bfd,
					 contents + rel->r_offset + 4)
			      == 0xe8);
d2248 1
a2248 1
		  memcpy (contents + rel->r_offset - 7,
d2252 1
a2252 1
			      contents + rel->r_offset + 5);
d2401 2
a2402 2
	      static unsigned char tlsgd[7]
		= { 0x66, 0x66, 0x66, 0x66, 0x48, 0x8d, 0x3d };
d2405 2
a2406 2
		 .long 0x66666666; leaq foo@@tlsgd(%rip), %rdi
		 callq __tls_get_addr@@plt
d2410 2
a2411 2
	      BFD_ASSERT (rel->r_offset >= 7);
	      for (i = 0; i < 7; i++)
d2413 1
a2413 1
				       contents + rel->r_offset - 7 + i)
d2415 5
a2419 4
	      BFD_ASSERT (rel->r_offset + 9 <= input_section->_raw_size);
	      BFD_ASSERT (bfd_get_8 (input_bfd,
				     contents + rel->r_offset + 4)
			  == 0xe8);
d2422 1
a2422 1
	      memcpy (contents + rel->r_offset - 7,
d2431 1
a2431 1
			    - 9);
d2433 1
a2433 1
			  contents + rel->r_offset + 5);
@


1.50
log
@bfd/
	* reloc.c: Add x86-64 TLS relocs.
	* bfd-in2.h, libbfd.h: Rebuilt.
	* elf64-x86-64.c (x86_64_elf_howto): Fix size fields for 32-bit
	relocs.  Add TLS relocs.
	(x86_64_reloc_map): Add TLS relocs.
	(elf64_x86_64_info_to_howto): Adjust for added TLS relocs.
	(struct elf64_x86_64_link_hash_entry): Add tls_type field.
	(GOT_UNKNOWN, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE): Define.
	(elf64_x86_64_hash_entry): Define.
	(struct elf64_x86_64_obj_tdata): New.
	(elf64_x86_64_tdata, elf64_x86_64_local_got_tls_type): Define.
	(struct elf64_x86_64_link_hash_table): Add tls_ld_got.
	(link_hash_newfunc): Initialize tls_type.
	(elf64_x86_64_link_hash_table_create): Initialize tls_ld_got.
	(elf64_x86_64_copy_indirect_symbol): Swap tls_type if necessary.
	(elf64_x86_64_mkobject): New.
	(elf64_x86_64_elf_object_p): Allocate struct elf64_x86_64_obj_tdata.
	(elf64_x86_64_tls_transition): New.
	(elf64_x86_64_check_relocs): Add r_type variable and use it.
	Handle TLS relocs.
	(elf64_x86_64_gc_sweep_hook): Handle TLS relocs.
	(allocate_dynrelocs): Allocate GOT space for TLS relocs.
	(elf64_x86_64_size_dynamic_sections): Likewise.
	(dtpoff_base, tpoff): New.
	(elf64_x86_64_relocate_section): Handle TLS relocs.
	(elf64_x86_64_finish_dynamic_symbol): Only handle non-TLS GOT
	entries.
	(bfd_elf64_mkobject): Define.

	* elf32-i386.c (elf_i386_check_relocs) [R_386_TLS_LE]: Set
	DF_STATIC_TLS if shared.
gas/
	* config/tc-i386.c (tc_i386_fix_adjustable): Add x86-64 TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Handle @@tlsgd, @@dtpoff and @@tpoff in 64-bit mode, add
	@@tlsld.
	(md_apply_fix3): No addend for BFD_RELOC_X86_64_TLSGD,
	BFD_RELOC_X86_64_TLSLD and BFD_RELOC_X86_64_GOTTPOFF.
	(tc_gen_reloc): Handle x86-64 TLS relocs.
include/
	* elf/x86-64.h: Add TLS relocs.
ld/testsuite/
	* lib/ld-lib.exp (run_ld_link_tests): Add.
	* ld-sh/sh64/sh64.exp (run_ld_link_tests, regexp_diff,
	file_contents): Remove.
	(sh64tests): Add 6th field to the tests array.
	* ld-i386/i386.exp (run_ld_link_tests): Remove.
	* ld-x86-64/x86-64.exp: New.
	* ld-x86-64/tlsbin.dd: New test.
	* ld-x86-64/tlsbinpic.s: New test.
	* ld-x86-64/tlsbin.rd: New test.
	* ld-x86-64/tlsbin.s: New test.
	* ld-x86-64/tlsbin.sd: New test.
	* ld-x86-64/tlsbin.td: New test.
	* ld-x86-64/tlslib.s: New test.
	* ld-x86-64/tlspic1.s: New test.
	* ld-x86-64/tlspic2.s: New test.
	* ld-x86-64/tlspic.dd: New test.
	* ld-x86-64/tlspic.rd: New test.
	* ld-x86-64/tlspic.sd: New test.
	* ld-x86-64/tlspic.td: New test.
@
text
@d2499 1
a2499 1
	  if (info->shared)
@


1.49
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d43 1
a43 1
  HOWTO(R_X86_64_PC32, 0, 4, 32, true, 0, complain_overflow_signed,
d46 1
a46 1
  HOWTO(R_X86_64_GOT32, 0, 4, 32, false, 0, complain_overflow_signed,
d49 1
a49 1
  HOWTO(R_X86_64_PLT32, 0, 4, 32, true, 0, complain_overflow_signed,
d52 1
a52 1
  HOWTO(R_X86_64_COPY, 0, 4, 32, false, 0, complain_overflow_bitfield,
d64 1
a64 1
  HOWTO(R_X86_64_GOTPCREL, 0, 4, 32, true,0 , complain_overflow_signed,
d67 1
a67 1
  HOWTO(R_X86_64_32, 0, 4, 32, false, 0, complain_overflow_unsigned,
d70 1
a70 1
  HOWTO(R_X86_64_32S, 0, 4, 32, false, 0, complain_overflow_signed,
d81 24
d141 8
d163 4
d197 4
d241 1
a241 1
      BFD_ASSERT (r_type <= (unsigned int) R_X86_64_PC8);
d247 1
a247 1
      i = r_type - ((unsigned int) R_X86_64_GNU_VTINHERIT - R_X86_64_PC8 - 1);
d386 17
d405 7
d427 5
d467 1
d500 1
d612 7
d623 11
d635 1
a635 1
     bfd *abfd;
d637 8
d650 23
d703 1
d708 1
d723 2
a724 1
      switch (ELF64_R_TYPE (rel->r_info))
d726 21
d749 1
d751 2
a752 7
	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	    }
	  else
	    {
	      bfd_signed_vma *local_got_refcounts;
d754 21
a774 5
	      /* This is a global offset table entry for a local symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	      if (local_got_refcounts == NULL)
		{
		  bfd_size_type size;
d776 28
a803 5
		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
d805 11
a815 4
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      local_got_refcounts[r_symndx] += 1;
	    }
d819 1
d861 1
a861 1
		 x86_64_elf_howto_table[ELF64_R_TYPE (rel->r_info)].name);
d909 3
a911 3
	       && (((ELF64_R_TYPE (rel->r_info) != R_X86_64_PC8)
		    && (ELF64_R_TYPE (rel->r_info) != R_X86_64_PC16)
		    && (ELF64_R_TYPE (rel->r_info) != R_X86_64_PC32))
d1012 3
a1014 3
	      if (ELF64_R_TYPE (rel->r_info) == R_X86_64_PC8
		  || ELF64_R_TYPE (rel->r_info) == R_X86_64_PC16
		  || ELF64_R_TYPE (rel->r_info) == R_X86_64_PC32)
d1095 1
d1106 4
a1109 1
    switch (ELF64_R_TYPE (rel->r_info))
d1111 7
d1427 8
a1434 1
  if (h->got.refcount > 0)
d1438 1
d1452 3
d1456 9
a1464 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d1610 1
d1653 1
d1656 1
a1656 1
      for (; local_got < end_local_got; ++local_got)
d1662 5
a1666 1
	      if (info->shared)
d1674 11
d1795 32
d1860 1
a1860 1
      int r_type;
d1870 1
d1877 1
a1877 1
      if (r_type < 0 || r_type >= R_X86_64_max)
d2203 307
d2664 3
a2666 1
  if (h->got.offset != (bfd_vma) -1)
d2672 1
a2672 1
         up.  */
d2930 1
@


1.49.10.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d43 1
a43 1
  HOWTO(R_X86_64_PC32, 0, 2, 32, true, 0, complain_overflow_signed,
d46 1
a46 1
  HOWTO(R_X86_64_GOT32, 0, 2, 32, false, 0, complain_overflow_signed,
d49 1
a49 1
  HOWTO(R_X86_64_PLT32, 0, 2, 32, true, 0, complain_overflow_signed,
d52 1
a52 1
  HOWTO(R_X86_64_COPY, 0, 2, 32, false, 0, complain_overflow_bitfield,
d64 1
a64 1
  HOWTO(R_X86_64_GOTPCREL, 0, 2, 32, true, 0, complain_overflow_signed,
d67 1
a67 1
  HOWTO(R_X86_64_32, 0, 2, 32, false, 0, complain_overflow_unsigned,
d70 1
a70 1
  HOWTO(R_X86_64_32S, 0, 2, 32, false, 0, complain_overflow_signed,
a80 24
  HOWTO(R_X86_64_DTPMOD64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPMOD64", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_DTPOFF64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF64", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_TPOFF64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF64", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_TLSGD, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSGD", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_TLSLD, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSLD", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_DTPOFF32, 0, 2, 32, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF32", false, 0xffffffff,
	0xffffffff, false),
  HOWTO(R_X86_64_GOTTPOFF, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTTPOFF", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_TPOFF32, 0, 2, 32, false, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF32", false, 0xffffffff,
	0xffffffff, false),
a116 8
  { BFD_RELOC_X86_64_DTPMOD64,	R_X86_64_DTPMOD64, },
  { BFD_RELOC_X86_64_DTPOFF64,	R_X86_64_DTPOFF64, },
  { BFD_RELOC_X86_64_TPOFF64,	R_X86_64_TPOFF64, },
  { BFD_RELOC_X86_64_TLSGD,	R_X86_64_TLSGD, },
  { BFD_RELOC_X86_64_TLSLD,	R_X86_64_TLSLD, },
  { BFD_RELOC_X86_64_DTPOFF32,	R_X86_64_DTPOFF32, },
  { BFD_RELOC_X86_64_GOTTPOFF,	R_X86_64_GOTTPOFF, },
  { BFD_RELOC_X86_64_TPOFF32,	R_X86_64_TPOFF32, },
a130 4
static int elf64_x86_64_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));
static boolean elf64_x86_64_mkobject
  PARAMS((bfd *));
a160 4
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
d201 1
a201 1
      BFD_ASSERT (r_type <= (unsigned int) R_X86_64_TPOFF32);
d207 1
a207 1
      i = r_type - ((unsigned int) R_X86_64_GNU_VTINHERIT - R_X86_64_TPOFF32 - 1);
a345 17

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	3
  unsigned char tls_type;
};

#define elf64_x86_64_hash_entry(ent) \
  ((struct elf64_x86_64_link_hash_entry *)(ent))

struct elf64_x86_64_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
a347 7
#define elf64_x86_64_tdata(abfd) \
  ((struct elf64_x86_64_obj_tdata *) (abfd)->tdata.any)

#define elf64_x86_64_local_got_tls_type(abfd) \
  (elf64_x86_64_tdata (abfd)->local_got_tls_type)


a362 5
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ld_got;

a397 1
      eh->tls_type = GOT_UNKNOWN;
a429 1
  ret->tls_ld_got.refcount = 0;
a540 7
  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

d545 1
a545 1
elf64_x86_64_mkobject (abfd)
a547 19
  bfd_size_type amt = sizeof (struct elf64_x86_64_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return false;
  return true;
}

static boolean
elf64_x86_64_elf_object_p (abfd)
  bfd *abfd;
{
  /* Allocate our special target data.  */
  struct elf64_x86_64_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct elf64_x86_64_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return false;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
a552 23
static int
elf64_x86_64_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_X86_64_TLSGD:
    case R_X86_64_GOTTPOFF:
      if (is_local)
	return R_X86_64_TPOFF32;
      return R_X86_64_GOTTPOFF;
    case R_X86_64_TLSLD:
      return R_X86_64_TPOFF32;
    }

   return r_type;
}

a582 1
      unsigned int r_type;
a586 1
      r_type = ELF64_R_TYPE (rel->r_info);
d601 1
a601 2
      r_type = elf64_x86_64_tls_transition (info, r_type, h == NULL);
      switch (r_type)
a602 21
	case R_X86_64_TLSLD:
	  htab->tls_ld_got.refcount += 1;
	  goto create_got;

	case R_X86_64_TPOFF32:
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: relocation %s can not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (abfd),
		 x86_64_elf_howto_table[r_type].name);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  break;

	case R_X86_64_GOTTPOFF:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through */

a604 1
	case R_X86_64_TLSGD:
d606 7
a612 2
	  {
	    int tls_type, old_tls_type;
d614 5
a618 21
	    switch (r_type)
	      {
	      default: tls_type = GOT_NORMAL; break;
	      case R_X86_64_TLSGD: tls_type = GOT_TLS_GD; break;
	      case R_X86_64_GOTTPOFF: tls_type = GOT_TLS_IE; break;
	      }

	    if (h != NULL)
	      {
		h->got.refcount += 1;
		old_tls_type = elf64_x86_64_hash_entry (h)->tls_type;
	      }
	    else
	      {
		bfd_signed_vma *local_got_refcounts;

		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
		  {
		    bfd_size_type size;
d620 5
a624 28
		    size = symtab_hdr->sh_info;
		    size *= sizeof (bfd_signed_vma) + sizeof (char);
		    local_got_refcounts = ((bfd_signed_vma *)
					   bfd_zalloc (abfd, size));
		    if (local_got_refcounts == NULL)
		      return false;
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
		    elf64_x86_64_local_got_tls_type (abfd)
		      = (char *) (local_got_refcounts + symtab_hdr->sh_info);
		  }
		local_got_refcounts[r_symndx] += 1;
		old_tls_type
		  = elf64_x86_64_local_got_tls_type (abfd) [r_symndx];
	      }

	    /* If a TLS symbol is accessed using IE at least once,
	       there is no point to use dynamic model for it.  */
	    if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
		&& (old_tls_type != GOT_TLS_GD || tls_type != GOT_TLS_IE))
	      {
		if (old_tls_type == GOT_TLS_IE && tls_type == GOT_TLS_GD)
		  tls_type = old_tls_type;
		else
		  {
		    (*_bfd_error_handler)
		      (_("%s: %s' accessed both as normal and thread local symbol"),
		       bfd_archive_filename (abfd),
		       h ? h->root.root.string : "<local>");
d626 4
a629 11
		  }
	      }

	    if (old_tls_type != tls_type)
	      {
		if (h != NULL)
		  elf64_x86_64_hash_entry (h)->tls_type = tls_type;
		else
		  elf64_x86_64_local_got_tls_type (abfd) [r_symndx] = tls_type;
	      }
	  }
a632 1
	create_got:
d674 1
a674 1
		 x86_64_elf_howto_table[r_type].name);
d722 3
a724 3
	       && (((r_type != R_X86_64_PC8)
		    && (r_type != R_X86_64_PC16)
		    && (r_type != R_X86_64_PC32))
d825 3
a827 3
	      if (r_type == R_X86_64_PC8
		  || r_type == R_X86_64_PC16
		  || r_type == R_X86_64_PC32)
a907 1
  int r_type;
d918 1
a918 4
    switch ((r_type = elf64_x86_64_tls_transition (info,
						   ELF64_R_TYPE (rel->r_info),
						   ELF64_R_SYM (rel->r_info)
						   >= symtab_hdr->sh_info)))
a919 7
      case R_X86_64_TLSLD:
	if (elf64_x86_64_hash_table (info)->tls_ld_got.refcount > 0)
	  elf64_x86_64_hash_table (info)->tls_ld_got.refcount -= 1;
	break;

      case R_X86_64_TLSGD:
      case R_X86_64_GOTTPOFF:
d1229 1
a1229 8
  /* If R_X86_64_GOTTPOFF symbol is now local to the binary,
     make it a R_X86_64_TPOFF32 requiring no GOT entry.  */
  if (h->got.refcount > 0
      && !info->shared
      && h->dynindx == -1
      && elf64_x86_64_hash_entry (h)->tls_type == GOT_TLS_IE)
    h->got.offset = (bfd_vma) -1;
  else if (h->got.refcount > 0)
a1232 1
      int tls_type = elf64_x86_64_hash_entry (h)->tls_type;
a1245 3
      /* R_X86_64_TLSGD needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->_raw_size += GOT_ENTRY_SIZE;
d1247 1
a1247 9
      /* R_X86_64_TLSGD needs one dynamic relocation if local symbol
	 and two if global.
	 R_X86_64_GOTTPOFF needs one dynamic relocation.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type == GOT_TLS_IE)
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->_raw_size += 2 * sizeof (Elf64_External_Rela);
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
a1392 1
      char *local_tls_type;
a1434 1
      local_tls_type = elf64_x86_64_local_got_tls_type (ibfd);
d1437 1
a1437 1
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
d1443 1
a1443 5
	      if (*local_tls_type == GOT_TLS_GD)
		s->_raw_size += GOT_ENTRY_SIZE;
	      if (info->shared
		  || *local_tls_type == GOT_TLS_GD
		  || *local_tls_type == GOT_TLS_IE)
a1450 11
  if (htab->tls_ld_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_X86_64_TLSLD
	 relocs.  */
      htab->tls_ld_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
    }
  else
    htab->tls_ld_got.offset = -1;

a1560 32
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
    return 0;
  return elf_hash_table (info)->tls_segment->start;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
{
  struct elf_link_tls_segment *tls_segment
    = elf_hash_table (info)->tls_segment;

  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (tls_segment == NULL)
    return 0;
  return address - align_power (tls_segment->size, tls_segment->align)
	 - tls_segment->start;
}

d1594 1
a1594 1
      unsigned int r_type;
a1603 1
      int tls_type;
d1610 1
a1610 1
      if (r_type >= R_X86_64_max)
a1935 307
	case R_X86_64_TLSGD:
	case R_X86_64_GOTTPOFF:
	  r_type = elf64_x86_64_tls_transition (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf64_x86_64_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = elf64_x86_64_hash_entry (h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type == GOT_TLS_IE)
		r_type = R_X86_64_TPOFF32;
	    }
	  if (r_type == R_X86_64_TLSGD)
	    {
	      if (tls_type == GOT_TLS_IE)
		r_type = R_X86_64_GOTTPOFF;
	    }

	  if (r_type == R_X86_64_TPOFF32)
	    {
	      BFD_ASSERT (! unresolved_reloc);
	      if (ELF64_R_TYPE (rel->r_info) == R_X86_64_TLSGD)
		{
		  unsigned int i;
		  static unsigned char tlsgd[7]
		    = { 0x66, 0x66, 0x66, 0x66, 0x48, 0x8d, 0x3d };

		  /* GD->LE transition.
		     .long 0x66666666; leaq foo@@tlsgd(%rip), %rdi
		     callq __tls_get_addr@@plt
		     Change it into:
		     movq %fs:0, %rax
		     leaq foo@@tpoff(%rax), %rax */
		  BFD_ASSERT (rel->r_offset >= 7);
		  for (i = 0; i < 7; i++)
		    BFD_ASSERT (bfd_get_8 (input_bfd,
					   contents + rel->r_offset - 7 + i)
				== tlsgd[i]);
		  BFD_ASSERT (rel->r_offset + 9 <= input_section->_raw_size);
		  BFD_ASSERT (bfd_get_8 (input_bfd,
					 contents + rel->r_offset + 4)
			      == 0xe8);
		  BFD_ASSERT (rel + 1 < relend);
		  BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
		  memcpy (contents + rel->r_offset - 7,
			  "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0",
			  16);
		  bfd_put_32 (output_bfd, tpoff (info, relocation),
			      contents + rel->r_offset + 5);
		  /* Skip R_X86_64_PLT32.  */
		  rel++;
		  continue;
		}
	      else
		{
		  unsigned int val, type, reg;

		  /* IE->LE transition:
		     Originally it can be one of:
		     movq foo@@gottpoff(%rip), %reg
		     addq foo@@gottpoff(%rip), %reg
		     We change it into:
		     movq $foo, %reg
		     leaq foo(%reg), %reg
		     addq $foo, %reg.  */
		  BFD_ASSERT (rel->r_offset >= 3);
		  val = bfd_get_8 (input_bfd, contents + rel->r_offset - 3);
		  BFD_ASSERT (val == 0x48 || val == 0x4c);
		  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);
		  BFD_ASSERT (type == 0x8b || type == 0x03);
		  reg = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
		  BFD_ASSERT ((reg & 0xc7) == 5);
		  reg >>= 3;
		  BFD_ASSERT (rel->r_offset + 4 <= input_section->_raw_size);
		  if (type == 0x8b)
		    {
		      /* movq */
		      if (val == 0x4c)
			bfd_put_8 (output_bfd, 0x49,
				   contents + rel->r_offset - 3);
		      bfd_put_8 (output_bfd, 0xc7,
				 contents + rel->r_offset - 2);
		      bfd_put_8 (output_bfd, 0xc0 | reg,
				 contents + rel->r_offset - 1);
		    }
		  else if (reg == 4)
		    {
		      /* addq -> addq - addressing with %rsp/%r12 is
			 special  */
		      if (val == 0x4c)
			bfd_put_8 (output_bfd, 0x49,
				   contents + rel->r_offset - 3);
		      bfd_put_8 (output_bfd, 0x81,
				 contents + rel->r_offset - 2);
		      bfd_put_8 (output_bfd, 0xc0 | reg,
				 contents + rel->r_offset - 1);
		    }
		  else
		    {
		      /* addq -> leaq */
		      if (val == 0x4c)
			bfd_put_8 (output_bfd, 0x4d,
				   contents + rel->r_offset - 3);
		      bfd_put_8 (output_bfd, 0x8d,
				 contents + rel->r_offset - 2);
		      bfd_put_8 (output_bfd, 0x80 | reg | (reg << 3),
				 contents + rel->r_offset - 1);
		    }
		  bfd_put_32 (output_bfd, tpoff (info, relocation),
			      contents + rel->r_offset);
		  continue;
		}
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	  if ((off & 1) != 0)
	    off &= ~1;
          else
	    {
	      Elf_Internal_Rela outrel;
	      Elf64_External_Rela *loc;
	      int dr_type, indx;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_X86_64_TLSGD)
		dr_type = R_X86_64_DTPMOD64;
	      else
		dr_type = R_X86_64_TPOFF64;

	      bfd_put_64 (output_bfd, 0, htab->sgot->contents + off);
	      outrel.r_addend = 0;
	      if (dr_type == R_X86_64_TPOFF64 && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      outrel.r_info = ELF64_R_INFO (indx, dr_type);

	      loc = (Elf64_External_Rela *) htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++;
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_X86_64_TLSGD)
		{
		  if (indx == 0)
		    {
	    	      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_64 (output_bfd,
				  relocation - dtpoff_base (info),
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
		    }
		  else
		    {
		      bfd_put_64 (output_bfd, 0,
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
		      outrel.r_info = ELF64_R_INFO (indx,
						    R_X86_64_DTPOFF64);
		      outrel.r_offset += GOT_ENTRY_SIZE;
		      htab->srelgot->reloc_count++;
		      loc++;
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						 loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();
	  if (r_type == ELF64_R_TYPE (rel->r_info))
	    {
	      relocation = htab->sgot->output_section->vma
			   + htab->sgot->output_offset + off;
	      unresolved_reloc = false;
	    }
	  else
	    {
	      unsigned int i;
	      static unsigned char tlsgd[7]
		= { 0x66, 0x66, 0x66, 0x66, 0x48, 0x8d, 0x3d };

	      /* GD->IE transition.
		 .long 0x66666666; leaq foo@@tlsgd(%rip), %rdi
		 callq __tls_get_addr@@plt
		 Change it into:
		 movq %fs:0, %rax
		 addq foo@@gottpoff(%rip), %rax */
	      BFD_ASSERT (rel->r_offset >= 7);
	      for (i = 0; i < 7; i++)
	        BFD_ASSERT (bfd_get_8 (input_bfd,
				       contents + rel->r_offset - 7 + i)
			    == tlsgd[i]);
	      BFD_ASSERT (rel->r_offset + 9 <= input_section->_raw_size);
	      BFD_ASSERT (bfd_get_8 (input_bfd,
				     contents + rel->r_offset + 4)
			  == 0xe8);
	      BFD_ASSERT (rel + 1 < relend);
	      BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
	      memcpy (contents + rel->r_offset - 7,
		      "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0",
		      16);

	      relocation = (htab->sgot->output_section->vma
			    + htab->sgot->output_offset + off
			    - rel->r_offset
			    - input_section->output_section->vma
			    - input_section->output_offset
			    - 9);
	      bfd_put_32 (output_bfd, relocation,
			  contents + rel->r_offset + 5);
	      /* Skip R_X86_64_PLT32.  */
	      rel++;
	      continue;
	    }
	  break;

	case R_X86_64_TLSLD:
	  if (! info->shared)
	    {
	      /* LD->LE transition:
		 Ensure it is:
		 leaq foo@@tlsld(%rip), %rdi; call __tls_get_addr@@plt.
		 We change it into:
		 .word 0x6666; .byte 0x66; movl %fs:0, %rax.  */
	      BFD_ASSERT (rel->r_offset >= 3);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 3)
			  == 0x48);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 2)
			  == 0x8d);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 1)
			  == 0x3d);
	      BFD_ASSERT (rel->r_offset + 9 <= input_section->_raw_size);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset + 4)
			  == 0xe8);
	      BFD_ASSERT (rel + 1 < relend);
	      BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
	      memcpy (contents + rel->r_offset - 3,
		      "\x66\x66\x66\x64\x48\x8b\x04\x25\0\0\0", 12);
	      /* Skip R_X86_64_PLT32.  */
	      rel++;
	      continue;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  off = htab->tls_ld_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      Elf64_External_Rela *loc;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      bfd_put_64 (output_bfd, 0,
			  htab->sgot->contents + off);
	      bfd_put_64 (output_bfd, 0,
			  htab->sgot->contents + off + GOT_ENTRY_SIZE);
	      outrel.r_info = ELF64_R_INFO (0, R_X86_64_DTPMOD64);
	      outrel.r_addend = 0;
	      loc = (Elf64_External_Rela *) htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++;
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ld_got.offset |= 1;
	    }
	  relocation = htab->sgot->output_section->vma
		       + htab->sgot->output_offset + off;
	  unresolved_reloc = false;
	  break;

	case R_X86_64_DTPOFF32:
	  if (info->shared)
	    relocation -= dtpoff_base (info);
	  else
	    relocation = tpoff (info, relocation);
	  break;

	case R_X86_64_TPOFF32:
	  BFD_ASSERT (! info->shared);
	  relocation = tpoff (info, relocation);
	  break;

d2090 1
a2090 3
  if (h->got.offset != (bfd_vma) -1
      && elf64_x86_64_hash_entry (h)->tls_type != GOT_TLS_GD
      && elf64_x86_64_hash_entry (h)->tls_type != GOT_TLS_IE)
d2096 1
a2096 1
	 up.  */
a2353 1
#define bfd_elf64_mkobject		    elf64_x86_64_mkobject
@


1.49.10.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d2227 2
a2228 2
		  static unsigned char tlsgd[8]
		    = { 0x66, 0x48, 0x8d, 0x3d, 0x66, 0x66, 0x48, 0xe8 };
d2231 2
a2232 2
		     .byte 0x66; leaq foo@@tlsgd(%rip), %rdi
		     .word 0x6666; rex64; call __tls_get_addr@@plt
d2236 2
a2237 2
		  BFD_ASSERT (rel->r_offset >= 4);
		  for (i = 0; i < 4; i++)
d2239 1
a2239 1
					   contents + rel->r_offset - 4 + i)
d2241 4
a2244 5
		  BFD_ASSERT (rel->r_offset + 12 <= input_section->_raw_size);
		  for (i = 0; i < 4; i++)
		    BFD_ASSERT (bfd_get_8 (input_bfd,
					   contents + rel->r_offset + 4 + i)
				== tlsgd[i+4]);
d2247 1
a2247 1
		  memcpy (contents + rel->r_offset - 4,
d2251 1
a2251 1
			      contents + rel->r_offset + 8);
d2400 2
a2401 2
	      static unsigned char tlsgd[8]
		= { 0x66, 0x48, 0x8d, 0x3d, 0x66, 0x66, 0x48, 0xe8 };
d2404 2
a2405 2
		 .byte 0x66; leaq foo@@tlsgd(%rip), %rdi
		 .word 0x6666; rex64; call __tls_get_addr@@plt
d2409 2
a2410 2
	      BFD_ASSERT (rel->r_offset >= 4);
	      for (i = 0; i < 4; i++)
d2412 1
a2412 1
				       contents + rel->r_offset - 4 + i)
d2414 4
a2417 5
	      BFD_ASSERT (rel->r_offset + 12 <= input_section->_raw_size);
	      for (i = 0; i < 4; i++)
	        BFD_ASSERT (bfd_get_8 (input_bfd,
				       contents + rel->r_offset + 4 + i)
			    == tlsgd[i+4]);
d2420 1
a2420 1
	      memcpy (contents + rel->r_offset - 4,
d2429 1
a2429 1
			    - 12);
d2431 1
a2431 1
			  contents + rel->r_offset + 8);
d2499 1
a2499 1
	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
@


1.49.10.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d37 68
a104 68
  HOWTO(R_X86_64_NONE, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_X86_64_NONE",	FALSE, 0x00000000, 0x00000000,
	FALSE),
  HOWTO(R_X86_64_64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_64", FALSE, MINUS_ONE, MINUS_ONE,
	FALSE),
  HOWTO(R_X86_64_PC32, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC32", FALSE, 0xffffffff, 0xffffffff,
	TRUE),
  HOWTO(R_X86_64_GOT32, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOT32", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_PLT32, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PLT32", FALSE, 0xffffffff, 0xffffffff,
	TRUE),
  HOWTO(R_X86_64_COPY, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_COPY", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_GLOB_DAT, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_GLOB_DAT", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_JUMP_SLOT, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_RELATIVE, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_GOTPCREL, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_32, 0, 2, 32, FALSE, 0, complain_overflow_unsigned,
	bfd_elf_generic_reloc, "R_X86_64_32", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_32S, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_32S", FALSE, 0xffffffff, 0xffffffff,
	FALSE),
  HOWTO(R_X86_64_16, 0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_16", FALSE, 0xffff, 0xffff, FALSE),
  HOWTO(R_X86_64_PC16,0, 1, 16, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_PC16", FALSE, 0xffff, 0xffff, TRUE),
  HOWTO(R_X86_64_8, 0, 0, 8, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_8", FALSE, 0xff, 0xff, FALSE),
  HOWTO(R_X86_64_PC8, 0, 0, 8, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC8", FALSE, 0xff, 0xff, TRUE),
  HOWTO(R_X86_64_DTPMOD64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPMOD64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_DTPOFF64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_TPOFF64, 0, 4, 64, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF64", FALSE, MINUS_ONE,
	MINUS_ONE, FALSE),
  HOWTO(R_X86_64_TLSGD, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSGD", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_TLSLD, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSLD", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_DTPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF32", FALSE, 0xffffffff,
	0xffffffff, FALSE),
  HOWTO(R_X86_64_GOTTPOFF, 0, 2, 32, TRUE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTTPOFF", FALSE, 0xffffffff,
	0xffffffff, TRUE),
  HOWTO(R_X86_64_TPOFF32, 0, 2, 32, FALSE, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF32", FALSE, 0xffffffff,
	0xffffffff, FALSE),
d107 2
a108 2
  HOWTO (R_X86_64_GNU_VTINHERIT, 0, 4, 0, FALSE, 0, complain_overflow_dont,
	 NULL, "R_X86_64_GNU_VTINHERIT", FALSE, 0, 0, FALSE),
d111 3
a113 3
  HOWTO (R_X86_64_GNU_VTENTRY, 0, 4, 0, FALSE, 0, complain_overflow_dont,
	 _bfd_elf_rel_vtable_reloc_fn, "R_X86_64_GNU_VTENTRY", FALSE, 0, 0,
	 FALSE)
d156 2
a157 2
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean elf64_x86_64_grok_prstatus
d159 1
a159 1
static bfd_boolean elf64_x86_64_grok_psinfo
d165 1
a165 1
static bfd_boolean elf64_x86_64_mkobject
d167 2
a168 2
static bfd_boolean elf64_x86_64_elf_object_p PARAMS ((bfd *abfd));
static bfd_boolean create_got_section
d170 1
a170 1
static bfd_boolean elf64_x86_64_create_dynamic_sections
d175 1
a175 1
static bfd_boolean elf64_x86_64_check_relocs
d182 1
a182 1
static bfd_boolean elf64_x86_64_gc_sweep_hook
d188 1
a188 1
static bfd_boolean elf64_x86_64_adjust_dynamic_symbol
d191 1
a191 1
static bfd_boolean allocate_dynrelocs
d193 1
a193 1
static bfd_boolean readonly_dynrelocs
d195 1
a195 1
static bfd_boolean elf64_x86_64_size_dynamic_sections
d201 1
a201 1
static bfd_boolean elf64_x86_64_relocate_section
d204 1
a204 1
static bfd_boolean elf64_x86_64_finish_dynamic_symbol
d207 1
a207 1
static bfd_boolean elf64_x86_64_finish_dynamic_sections
d234 1
a234 1
     Elf_Internal_Rela *dst;
d254 1
a254 1
static bfd_boolean
d265 1
a265 1
	return FALSE;
d288 1
a288 1
static bfd_boolean
d296 1
a296 1
	return FALSE;
d317 1
a317 1
  return TRUE;
d508 1
a508 1
static bfd_boolean
d516 1
a516 1
    return FALSE;
d531 2
a532 2
    return FALSE;
  return TRUE;
d539 1
a539 1
static bfd_boolean
d548 1
a548 1
    return FALSE;
d551 1
a551 1
    return FALSE;
d563 1
a563 1
  return TRUE;
d622 1
a622 1
static bfd_boolean
d629 2
a630 2
    return FALSE;
  return TRUE;
d633 1
a633 1
static bfd_boolean
d642 1
a642 1
    return FALSE;
d647 1
a647 1
  return TRUE;
d677 1
a677 1
static bfd_boolean
d692 1
a692 1
    return TRUE;
d715 1
a715 1
	  return FALSE;
d738 1
a738 1
	      return FALSE;
d781 1
a781 1
		      return FALSE;
d804 1
a804 1
		    return FALSE;
d825 1
a825 1
		return FALSE;
d863 1
a863 1
	      return FALSE;
d940 1
a940 1
		    return FALSE;
d969 1
a969 1
			return FALSE;
d990 1
a990 1
		    return FALSE;
d1003 1
a1003 1
		    return FALSE;
d1023 1
a1023 1
	    return FALSE;
d1030 1
a1030 1
	    return FALSE;
d1038 1
a1038 1
  return TRUE;
d1083 1
a1083 1
static bfd_boolean
d1186 1
a1186 1
  return TRUE;
d1195 1
a1195 1
static bfd_boolean
d1228 1
a1228 1
      return TRUE;
d1247 1
a1247 1
      return TRUE;
d1258 1
a1258 1
    return TRUE;
d1263 1
a1263 1
    return TRUE;
d1269 1
a1269 1
      return TRUE;
d1285 1
a1285 1
      return TRUE;
d1324 1
a1324 1
	return FALSE;
d1334 1
a1334 1
  return TRUE;
d1351 1
a1351 1
static bfd_boolean
d1362 1
a1362 1
    return TRUE;
d1379 1
a1379 1
	    return FALSE;
d1437 1
a1437 1
      bfd_boolean dyn;
d1446 1
a1446 1
	    return FALSE;
d1472 1
a1472 1
    return TRUE;
d1518 1
a1518 1
		return FALSE;
d1539 1
a1539 1
  return TRUE;
d1544 1
a1544 1
static bfd_boolean
d1567 1
a1567 1
	  return FALSE;
d1570 1
a1570 1
  return TRUE;
d1575 1
a1575 1
static bfd_boolean
d1583 1
a1583 1
  bfd_boolean relocs;
d1691 1
a1691 1
  relocs = FALSE;
d1707 1
a1707 1
	    relocs = TRUE;
d1742 1
a1742 1
	return FALSE;
d1758 1
a1758 1
	    return FALSE;
d1767 1
a1767 1
	    return FALSE;
d1775 1
a1775 1
	    return FALSE;
d1786 1
a1786 1
		return FALSE;
d1792 1
a1792 1
  return TRUE;
d1829 1
a1829 1
static bfd_boolean
d1849 1
a1849 1
    return TRUE;
d1868 1
a1868 1
      bfd_boolean unresolved_reloc;
d1880 1
a1880 1
	  return FALSE;
d1888 1
a1888 1
      unresolved_reloc = FALSE;
d1913 1
a1913 1
		  unresolved_reloc = TRUE;
d1935 1
a1935 1
		return FALSE;
d1953 1
a1953 1
	      bfd_boolean dyn;
d1986 1
a1986 1
		unresolved_reloc = FALSE;
d2007 1
a2007 1
		      asection *s;
d2009 1
a2009 1
		      bfd_byte *loc;
d2013 2
a2014 2
		      s = htab->srelgot;
		      if (s == NULL)
d2022 2
a2023 2
		      loc = s->contents;
		      loc += s->reloc_count++ * sizeof (Elf64_External_Rela);
d2061 1
a2061 1
	  unresolved_reloc = FALSE;
d2102 1
a2102 2
	      bfd_byte *loc;
	      bfd_boolean skip, relocate;
d2104 1
d2110 2
a2111 2
	      skip = FALSE;
	      relocate = FALSE;
d2117 1
a2117 1
		skip = TRUE;
d2119 1
a2119 1
		skip = TRUE, relocate = TRUE;
d2147 1
a2147 1
		      relocate = TRUE;
d2169 1
a2169 1
			  return FALSE;
d2189 2
a2190 2
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf64_External_Rela);
d2336 1
a2336 1
	      bfd_byte *loc;
d2357 2
a2358 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d2378 3
a2380 2
		      loc += sizeof (Elf64_External_Rela);
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d2396 1
a2396 1
	      unresolved_reloc = FALSE;
d2476 1
a2476 1
	      bfd_byte *loc;
d2490 2
a2491 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d2497 1
a2497 1
	  unresolved_reloc = FALSE;
d2545 1
a2545 1
		return FALSE;
d2556 1
a2556 1
		return FALSE;
d2565 1
a2565 1
	      return FALSE;
d2570 1
a2570 1
  return TRUE;
d2576 1
a2576 1
static bfd_boolean
d2592 1
a2592 1
      bfd_byte *loc;
d2652 1
a2652 1
      loc = htab->srelplt->contents + plt_index * sizeof (Elf64_External_Rela);
d2671 1
a2671 1
      bfd_byte *loc;
d2709 2
a2710 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf64_External_Rela);
d2717 1
a2717 1
      bfd_byte *loc;
d2732 2
a2733 2
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf64_External_Rela);
d2742 1
a2742 1
  return TRUE;
d2767 1
a2767 1
static bfd_boolean
d2893 1
a2893 1
  return TRUE;
@


1.49.10.4
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d5 1
a5 1
   This file is part of BFD, the Binary File Descriptor library.
d7 13
a19 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d1094 3
d1106 27
a1132 4
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;
d1134 14
a1147 6
      r_symndx = ELF64_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf64_x86_64_link_hash_entry *eh;
	  struct elf64_x86_64_dyn_relocs **pp;
	  struct elf64_x86_64_dyn_relocs *p;
d1149 1
a1149 2
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf64_x86_64_link_hash_entry *) h;
d1151 2
a1152 8
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
d1154 1
a1154 8
      r_type = ELF64_R_TYPE (rel->r_info);
      r_type = elf64_x86_64_tls_transition (info, r_type, h != NULL);
      switch (r_type)
	{
	case R_X86_64_TLSLD:
	  if (elf64_x86_64_hash_table (info)->tls_ld_got.refcount > 0)
	    elf64_x86_64_hash_table (info)->tls_ld_got.refcount -= 1;
	  break;
d1156 14
a1169 15
	case R_X86_64_TLSGD:
	case R_X86_64_GOTTPOFF:
	case R_X86_64_GOT32:
	case R_X86_64_GOTPCREL:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
a1170 11
	case R_X86_64_8:
	case R_X86_64_16:
	case R_X86_64_32:
	case R_X86_64_64:
	case R_X86_64_32S:
	case R_X86_64_PC8:
	case R_X86_64_PC16:
	case R_X86_64_PC32:
	  if (info->shared)
	    break;
	  /* Fall thru */
d1172 9
a1180 7
	case R_X86_64_PLT32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d1182 3
a1184 4
	default:
	  break;
	}
    }
d1924 1
d2109 1
d2333 1
a2333 1
	  else
d2411 1
a2411 1
		BFD_ASSERT (bfd_get_8 (input_bfd,
d2416 1
a2416 1
		BFD_ASSERT (bfd_get_8 (input_bfd,
d2595 1
d2674 1
@


1.49.10.5
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a326 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d619 1
a619 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d917 1
a917 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1192 2
a1237 4
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1263 2
a1264 1
  if (ELIMINATE_COPY_RELOCS)
d1266 4
a1269 2
      struct elf64_x86_64_link_hash_entry * eh;
      struct elf64_x86_64_dyn_relocs *p;
d1271 6
a1276 15
      eh = (struct elf64_x86_64_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1362 1
a1362 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1455 1
a1455 3
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
a1488 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1490 1
a1490 1
  else if (ELIMINATE_COPY_RELOCS)
d1953 1
a1953 3
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
a2071 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d2080 1
a2080 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d2354 1
a2354 1
		      BFD_ASSERT (! unresolved_reloc);
@


1.49.10.6
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d708 1
a708 1
  if (info->relocatable)
d1621 1
a1621 1
      if (info->executable)
d1782 1
a1782 1
      if (info->executable)
d1875 1
a1875 1
  if (info->relocatable)
@


1.49.10.7
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d153 58
d214 3
a216 2
elf64_x86_64_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
				bfd_reloc_code_real_type code)
a218 1

d231 4
a234 2
elf64_x86_64_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED, arelent *cache_ptr,
			    Elf_Internal_Rela *dst)
d255 3
a257 1
elf64_x86_64_grok_prstatus (bfd *abfd, Elf_Internal_Note *note)
d289 3
a291 1
elf64_x86_64_grok_psinfo (bfd *abfd, Elf_Internal_Note *note)
d450 4
a453 2
link_hash_newfunc (struct bfd_hash_entry *entry, struct bfd_hash_table *table,
		   const char *string)
d482 2
a483 1
elf64_x86_64_link_hash_table_create (bfd *abfd)
d515 3
a517 1
create_got_section (bfd *dynobj, struct bfd_link_info *info)
d546 3
a548 1
elf64_x86_64_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
d575 3
a577 3
elf64_x86_64_copy_indirect_symbol (struct elf_backend_data *bed,
				   struct elf_link_hash_entry *dir,
				   struct elf_link_hash_entry *ind)
d640 2
a641 1
elf64_x86_64_mkobject (bfd *abfd)
d651 2
a652 1
elf64_x86_64_elf_object_p (bfd *abfd)
d668 4
a671 1
elf64_x86_64_tls_transition (struct bfd_link_info *info, int r_type, int is_local)
d695 5
a699 2
elf64_x86_64_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
			   const Elf_Internal_Rela *relocs)
d1063 6
a1068 5
elf64_x86_64_gc_mark_hook (asection *sec,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   Elf_Internal_Rela *rel,
			   struct elf_link_hash_entry *h,
			   Elf_Internal_Sym *sym)
d1102 5
a1106 2
elf64_x86_64_gc_sweep_hook (bfd *abfd, struct bfd_link_info *info,
			    asection *sec, const Elf_Internal_Rela *relocs)
d1205 3
a1207 2
elf64_x86_64_adjust_dynamic_symbol (struct bfd_link_info *info,
				    struct elf_link_hash_entry *h)
d1220 5
a1224 3
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type == bfd_link_hash_undefweak))
d1358 1
a1358 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d1360 1
a1360 1
   && ((SHARED)								\
d1369 3
a1371 1
allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d1388 3
a1390 1
      && h->plt.refcount > 0)
d1401 1
a1401 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d1485 1
a1485 2
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
d1503 3
a1505 7
      /* Relocs that use pc_count are those that appear on a call
	 insn, or certain REL relocs that can generated via assembly.
	 We want calls to protected symbols to resolve directly to the
	 function rather than going via the plt.  If people want
	 function pointer comparisons to work as expected then they
	 should avoid writing weird assembly.  */
      if (SYMBOL_CALLS_LOCAL (info, h))
d1572 3
a1574 1
readonly_dynrelocs (struct elf_link_hash_entry *h, void * inf)
d1603 3
a1605 2
elf64_x86_64_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				    struct bfd_link_info *info)
d1827 2
a1828 1
dtpoff_base (struct bfd_link_info *info)
d1840 3
a1842 1
tpoff (struct bfd_link_info *info, bfd_vma address)
d1857 10
a1866 5
elf64_x86_64_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
			       bfd *input_bfd, asection *input_section,
			       bfd_byte *contents, Elf_Internal_Rela *relocs,
			       Elf_Internal_Sym *local_syms,
			       asection **local_sections)
d1950 1
a1950 1
	  else if (!info->executable
d1984 1
a1984 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d1986 4
a1989 1
		      && SYMBOL_REFERENCES_LOCAL (info, h))
d2116 5
a2120 1
		   || !SYMBOL_CALLS_LOCAL (info, h)))
d2607 5
a2611 4
elf64_x86_64_finish_dynamic_symbol (bfd *output_bfd,
				    struct bfd_link_info *info,
				    struct elf_link_hash_entry *h,
				    Elf_Internal_Sym *sym)
d2717 4
a2720 1
	  && SYMBOL_REFERENCES_LOCAL (info, h))
d2777 2
a2778 1
elf64_x86_64_reloc_type_class (const Elf_Internal_Rela *rela)
d2796 3
a2798 1
elf64_x86_64_finish_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
@


1.49.10.8
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d504 1
a504 1
elf64_x86_64_copy_indirect_symbol (const struct elf_backend_data *bed,
d1830 4
a1833 1
	  bfd_boolean warned;
d1835 34
a1868 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.49.10.9
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d1742 2
a1743 2
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
d1745 1
a1745 1
  return elf_hash_table (info)->tls_sec->vma;
d1754 2
a1755 1
  struct elf_link_hash_table *htab = elf_hash_table (info);
d1758 1
a1758 1
  if (htab->tls_sec == NULL)
d1760 2
a1761 1
  return address - htab->tls_size - htab->tls_sec->vma;
d1826 1
a1826 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d2051 10
a2060 1
		      if (bfd_is_abs_section (sec))
d2795 1
@


1.49.10.10
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d563 1
a563 2
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d581 8
@


1.48
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d137 2
a138 1
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
d498 2
a499 1
elf64_x86_64_copy_indirect_symbol (dir, ind)
d541 1
a541 1
  _bfd_elf_link_hash_copy_indirect (dir, ind);
@


1.47
log
@	* elf32-i386.c (elf_i386_relocate_section): Don't complain about
	unresolved debugging relocs in dynamic applications.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@a28 3
/* We use only the RELA entries.  */
#define USE_RELA 1

@


1.47.2.1
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d140 1
a140 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d500 1
a500 2
elf64_x86_64_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d542 1
a542 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.46
log
@	* elf64-x86-64.c (elf64_x86_64_relocate_section): Only convert
	R_X86_64_64 to R_X86_64_RELATIVE.
@
text
@d1941 3
a1943 5
      /* FIXME: Why do we allow debugging sections to escape this error?
	 More importantly, why do we not emit dynamic relocs for
	 R_386_32 above in debugging sections (which are ! SEC_ALLOC)?
	 If we had emitted the dynamic reloc, we could remove the
	 fudge here.  */
d1945 1
a1945 2
	  && !(info->shared
	       && (input_section->flags & SEC_DEBUGGING) != 0
@


1.45
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d1879 38
a1916 3
		  relocate = true;
		  outrel.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
		  outrel.r_addend = relocation + rel->r_addend;
@


1.44
log
@	* elf64-x86-64.c (elf64_x86_64_check_relocs): Certain relocations
	are not allowed in shared libs code, enforce -fPIC.
@
text
@d145 1
a145 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d859 2
a860 2
elf64_x86_64_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d890 1
a890 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.43
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@a662 1
	case R_X86_64_64:
d664 17
d684 1
@


1.42
log
@2002-05-24  Michal Ludvig  <mludvig@@suse.cz>

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Added.
	(elf64_x86_64_grok_psinfo): Added.
@
text
@d128 1
a128 1
static boolean elf64_x86_64_grok_prstatus 
d130 1
a130 1
static boolean elf64_x86_64_grok_psinfo 
d231 1
a231 1
	elf_tdata (abfd)->core_signal 
d235 1
a235 1
	elf_tdata (abfd)->core_pid 
d1090 1
a1090 1
     runtime process image. */
@


1.42.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d128 1
a128 1
static boolean elf64_x86_64_grok_prstatus
d130 1
a130 1
static boolean elf64_x86_64_grok_psinfo
d231 1
a231 1
	elf_tdata (abfd)->core_signal
d235 1
a235 1
	elf_tdata (abfd)->core_pid
d1090 1
a1090 1
     runtime process image.  */
@


1.42.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d145 1
a145 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d663 1
a664 17
	  /* Let's help debug shared library creation.  These relocs
	     cannot be used in shared libs.  Don't error out for
	     sections we don't care about, such as debug sections or
	     non-constant sections.  */
	  if (info->shared
	      && (sec->flags & SEC_ALLOC) != 0
	      && (sec->flags & SEC_READONLY) != 0)
	    {
	      (*_bfd_error_handler)
		(_("%s: relocation %s can not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (abfd),
		 x86_64_elf_howto_table[ELF64_R_TYPE (rel->r_info)].name);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  /* Fall through.  */

a667 1
	case R_X86_64_64:
d842 2
a843 2
elf64_x86_64_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d873 3
a875 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
d1864 3
a1866 38
		  if (r_type == R_X86_64_64)
		    {
		      relocate = true;
		      outrel.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
		  else
		    {
		      long sindx;

		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
			sindx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return false;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  sindx = elf_section_data (osec)->dynindx;
			  BFD_ASSERT (sindx > 0);
			}

		      outrel.r_info = ELF64_R_INFO (sindx, r_type);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
d1891 5
a1895 3
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
d1897 2
a1898 1
	  && !((input_section->flags & SEC_DEBUGGING) != 0
@


1.42.2.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d29 3
@


1.42.2.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d137 1
a137 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d497 1
a497 2
elf64_x86_64_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d539 1
a539 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.42.2.5
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d43 1
a43 1
  HOWTO(R_X86_64_PC32, 0, 2, 32, true, 0, complain_overflow_signed,
d46 1
a46 1
  HOWTO(R_X86_64_GOT32, 0, 2, 32, false, 0, complain_overflow_signed,
d49 1
a49 1
  HOWTO(R_X86_64_PLT32, 0, 2, 32, true, 0, complain_overflow_signed,
d52 1
a52 1
  HOWTO(R_X86_64_COPY, 0, 2, 32, false, 0, complain_overflow_bitfield,
d64 1
a64 1
  HOWTO(R_X86_64_GOTPCREL, 0, 2, 32, true, 0, complain_overflow_signed,
d67 1
a67 1
  HOWTO(R_X86_64_32, 0, 2, 32, false, 0, complain_overflow_unsigned,
d70 1
a70 1
  HOWTO(R_X86_64_32S, 0, 2, 32, false, 0, complain_overflow_signed,
a80 24
  HOWTO(R_X86_64_DTPMOD64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPMOD64", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_DTPOFF64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF64", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_TPOFF64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF64", false, MINUS_ONE,
	MINUS_ONE, false),
  HOWTO(R_X86_64_TLSGD, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSGD", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_TLSLD, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TLSLD", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_DTPOFF32, 0, 2, 32, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_DTPOFF32", false, 0xffffffff,
	0xffffffff, false),
  HOWTO(R_X86_64_GOTTPOFF, 0, 2, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTTPOFF", false, 0xffffffff,
	0xffffffff, true),
  HOWTO(R_X86_64_TPOFF32, 0, 2, 32, false, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_TPOFF32", false, 0xffffffff,
	0xffffffff, false),
a116 8
  { BFD_RELOC_X86_64_DTPMOD64,	R_X86_64_DTPMOD64, },
  { BFD_RELOC_X86_64_DTPOFF64,	R_X86_64_DTPOFF64, },
  { BFD_RELOC_X86_64_TPOFF64,	R_X86_64_TPOFF64, },
  { BFD_RELOC_X86_64_TLSGD,	R_X86_64_TLSGD, },
  { BFD_RELOC_X86_64_TLSLD,	R_X86_64_TLSLD, },
  { BFD_RELOC_X86_64_DTPOFF32,	R_X86_64_DTPOFF32, },
  { BFD_RELOC_X86_64_GOTTPOFF,	R_X86_64_GOTTPOFF, },
  { BFD_RELOC_X86_64_TPOFF32,	R_X86_64_TPOFF32, },
a130 4
static int elf64_x86_64_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));
static boolean elf64_x86_64_mkobject
  PARAMS((bfd *));
a160 4
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
d201 1
a201 1
      BFD_ASSERT (r_type <= (unsigned int) R_X86_64_TPOFF32);
d207 1
a207 1
      i = r_type - ((unsigned int) R_X86_64_GNU_VTINHERIT - R_X86_64_TPOFF32 - 1);
a345 17

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	3
  unsigned char tls_type;
};

#define elf64_x86_64_hash_entry(ent) \
  ((struct elf64_x86_64_link_hash_entry *)(ent))

struct elf64_x86_64_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
a347 7
#define elf64_x86_64_tdata(abfd) \
  ((struct elf64_x86_64_obj_tdata *) (abfd)->tdata.any)

#define elf64_x86_64_local_got_tls_type(abfd) \
  (elf64_x86_64_tdata (abfd)->local_got_tls_type)


a362 5
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ld_got;

a397 1
      eh->tls_type = GOT_UNKNOWN;
a429 1
  ret->tls_ld_got.refcount = 0;
a540 7
  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

d545 1
a545 1
elf64_x86_64_mkobject (abfd)
a547 19
  bfd_size_type amt = sizeof (struct elf64_x86_64_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return false;
  return true;
}

static boolean
elf64_x86_64_elf_object_p (abfd)
  bfd *abfd;
{
  /* Allocate our special target data.  */
  struct elf64_x86_64_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct elf64_x86_64_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return false;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
a552 23
static int
elf64_x86_64_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_X86_64_TLSGD:
    case R_X86_64_GOTTPOFF:
      if (is_local)
	return R_X86_64_TPOFF32;
      return R_X86_64_GOTTPOFF;
    case R_X86_64_TLSLD:
      return R_X86_64_TPOFF32;
    }

   return r_type;
}

a582 1
      unsigned int r_type;
a586 1
      r_type = ELF64_R_TYPE (rel->r_info);
d601 1
a601 2
      r_type = elf64_x86_64_tls_transition (info, r_type, h == NULL);
      switch (r_type)
a602 21
	case R_X86_64_TLSLD:
	  htab->tls_ld_got.refcount += 1;
	  goto create_got;

	case R_X86_64_TPOFF32:
	  if (info->shared)
	    {
	      (*_bfd_error_handler)
		(_("%s: relocation %s can not be used when making a shared object; recompile with -fPIC"),
		 bfd_archive_filename (abfd),
		 x86_64_elf_howto_table[r_type].name);
	      bfd_set_error (bfd_error_bad_value);
	      return false;
	    }
	  break;

	case R_X86_64_GOTTPOFF:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through */

a604 1
	case R_X86_64_TLSGD:
d606 7
a612 2
	  {
	    int tls_type, old_tls_type;
d614 5
a618 21
	    switch (r_type)
	      {
	      default: tls_type = GOT_NORMAL; break;
	      case R_X86_64_TLSGD: tls_type = GOT_TLS_GD; break;
	      case R_X86_64_GOTTPOFF: tls_type = GOT_TLS_IE; break;
	      }

	    if (h != NULL)
	      {
		h->got.refcount += 1;
		old_tls_type = elf64_x86_64_hash_entry (h)->tls_type;
	      }
	    else
	      {
		bfd_signed_vma *local_got_refcounts;

		/* This is a global offset table entry for a local symbol.  */
		local_got_refcounts = elf_local_got_refcounts (abfd);
		if (local_got_refcounts == NULL)
		  {
		    bfd_size_type size;
d620 5
a624 28
		    size = symtab_hdr->sh_info;
		    size *= sizeof (bfd_signed_vma) + sizeof (char);
		    local_got_refcounts = ((bfd_signed_vma *)
					   bfd_zalloc (abfd, size));
		    if (local_got_refcounts == NULL)
		      return false;
		    elf_local_got_refcounts (abfd) = local_got_refcounts;
		    elf64_x86_64_local_got_tls_type (abfd)
		      = (char *) (local_got_refcounts + symtab_hdr->sh_info);
		  }
		local_got_refcounts[r_symndx] += 1;
		old_tls_type
		  = elf64_x86_64_local_got_tls_type (abfd) [r_symndx];
	      }

	    /* If a TLS symbol is accessed using IE at least once,
	       there is no point to use dynamic model for it.  */
	    if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN
		&& (old_tls_type != GOT_TLS_GD || tls_type != GOT_TLS_IE))
	      {
		if (old_tls_type == GOT_TLS_IE && tls_type == GOT_TLS_GD)
		  tls_type = old_tls_type;
		else
		  {
		    (*_bfd_error_handler)
		      (_("%s: %s' accessed both as normal and thread local symbol"),
		       bfd_archive_filename (abfd),
		       h ? h->root.root.string : "<local>");
d626 4
a629 11
		  }
	      }

	    if (old_tls_type != tls_type)
	      {
		if (h != NULL)
		  elf64_x86_64_hash_entry (h)->tls_type = tls_type;
		else
		  elf64_x86_64_local_got_tls_type (abfd) [r_symndx] = tls_type;
	      }
	  }
a632 1
	create_got:
d674 1
a674 1
		 x86_64_elf_howto_table[r_type].name);
d722 3
a724 3
	       && (((r_type != R_X86_64_PC8)
		    && (r_type != R_X86_64_PC16)
		    && (r_type != R_X86_64_PC32))
d825 3
a827 3
	      if (r_type == R_X86_64_PC8
		  || r_type == R_X86_64_PC16
		  || r_type == R_X86_64_PC32)
a907 1
  int r_type;
d918 1
a918 4
    switch ((r_type = elf64_x86_64_tls_transition (info,
						   ELF64_R_TYPE (rel->r_info),
						   ELF64_R_SYM (rel->r_info)
						   >= symtab_hdr->sh_info)))
a919 7
      case R_X86_64_TLSLD:
	if (elf64_x86_64_hash_table (info)->tls_ld_got.refcount > 0)
	  elf64_x86_64_hash_table (info)->tls_ld_got.refcount -= 1;
	break;

      case R_X86_64_TLSGD:
      case R_X86_64_GOTTPOFF:
d1229 1
a1229 8
  /* If R_X86_64_GOTTPOFF symbol is now local to the binary,
     make it a R_X86_64_TPOFF32 requiring no GOT entry.  */
  if (h->got.refcount > 0
      && !info->shared
      && h->dynindx == -1
      && elf64_x86_64_hash_entry (h)->tls_type == GOT_TLS_IE)
    h->got.offset = (bfd_vma) -1;
  else if (h->got.refcount > 0)
a1232 1
      int tls_type = elf64_x86_64_hash_entry (h)->tls_type;
a1245 3
      /* R_X86_64_TLSGD needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->_raw_size += GOT_ENTRY_SIZE;
d1247 1
a1247 9
      /* R_X86_64_TLSGD needs one dynamic relocation if local symbol
	 and two if global.
	 R_X86_64_GOTTPOFF needs one dynamic relocation.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type == GOT_TLS_IE)
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->_raw_size += 2 * sizeof (Elf64_External_Rela);
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
a1392 1
      char *local_tls_type;
a1434 1
      local_tls_type = elf64_x86_64_local_got_tls_type (ibfd);
d1437 1
a1437 1
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
d1443 1
a1443 5
	      if (*local_tls_type == GOT_TLS_GD)
		s->_raw_size += GOT_ENTRY_SIZE;
	      if (info->shared
		  || *local_tls_type == GOT_TLS_GD
		  || *local_tls_type == GOT_TLS_IE)
a1450 11
  if (htab->tls_ld_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_X86_64_TLSLD
	 relocs.  */
      htab->tls_ld_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
    }
  else
    htab->tls_ld_got.offset = -1;

a1560 32
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
    return 0;
  return elf_hash_table (info)->tls_segment->start;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
{
  struct elf_link_tls_segment *tls_segment
    = elf_hash_table (info)->tls_segment;

  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (tls_segment == NULL)
    return 0;
  return address - align_power (tls_segment->size, tls_segment->align)
	 - tls_segment->start;
}

d1594 1
a1594 1
      unsigned int r_type;
a1603 1
      int tls_type;
d1610 1
a1610 1
      if (r_type >= R_X86_64_max)
a1935 307
	case R_X86_64_TLSGD:
	case R_X86_64_GOTTPOFF:
	  r_type = elf64_x86_64_tls_transition (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf64_x86_64_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = elf64_x86_64_hash_entry (h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type == GOT_TLS_IE)
		r_type = R_X86_64_TPOFF32;
	    }
	  if (r_type == R_X86_64_TLSGD)
	    {
	      if (tls_type == GOT_TLS_IE)
		r_type = R_X86_64_GOTTPOFF;
	    }

	  if (r_type == R_X86_64_TPOFF32)
	    {
	      BFD_ASSERT (! unresolved_reloc);
	      if (ELF64_R_TYPE (rel->r_info) == R_X86_64_TLSGD)
		{
		  unsigned int i;
		  static unsigned char tlsgd[7]
		    = { 0x66, 0x66, 0x66, 0x66, 0x48, 0x8d, 0x3d };

		  /* GD->LE transition.
		     .long 0x66666666; leaq foo@@tlsgd(%rip), %rdi
		     callq __tls_get_addr@@plt
		     Change it into:
		     movq %fs:0, %rax
		     leaq foo@@tpoff(%rax), %rax */
		  BFD_ASSERT (rel->r_offset >= 7);
		  for (i = 0; i < 7; i++)
		    BFD_ASSERT (bfd_get_8 (input_bfd,
					   contents + rel->r_offset - 7 + i)
				== tlsgd[i]);
		  BFD_ASSERT (rel->r_offset + 9 <= input_section->_raw_size);
		  BFD_ASSERT (bfd_get_8 (input_bfd,
					 contents + rel->r_offset + 4)
			      == 0xe8);
		  BFD_ASSERT (rel + 1 < relend);
		  BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
		  memcpy (contents + rel->r_offset - 7,
			  "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x8d\x80\0\0\0",
			  16);
		  bfd_put_32 (output_bfd, tpoff (info, relocation),
			      contents + rel->r_offset + 5);
		  /* Skip R_X86_64_PLT32.  */
		  rel++;
		  continue;
		}
	      else
		{
		  unsigned int val, type, reg;

		  /* IE->LE transition:
		     Originally it can be one of:
		     movq foo@@gottpoff(%rip), %reg
		     addq foo@@gottpoff(%rip), %reg
		     We change it into:
		     movq $foo, %reg
		     leaq foo(%reg), %reg
		     addq $foo, %reg.  */
		  BFD_ASSERT (rel->r_offset >= 3);
		  val = bfd_get_8 (input_bfd, contents + rel->r_offset - 3);
		  BFD_ASSERT (val == 0x48 || val == 0x4c);
		  type = bfd_get_8 (input_bfd, contents + rel->r_offset - 2);
		  BFD_ASSERT (type == 0x8b || type == 0x03);
		  reg = bfd_get_8 (input_bfd, contents + rel->r_offset - 1);
		  BFD_ASSERT ((reg & 0xc7) == 5);
		  reg >>= 3;
		  BFD_ASSERT (rel->r_offset + 4 <= input_section->_raw_size);
		  if (type == 0x8b)
		    {
		      /* movq */
		      if (val == 0x4c)
			bfd_put_8 (output_bfd, 0x49,
				   contents + rel->r_offset - 3);
		      bfd_put_8 (output_bfd, 0xc7,
				 contents + rel->r_offset - 2);
		      bfd_put_8 (output_bfd, 0xc0 | reg,
				 contents + rel->r_offset - 1);
		    }
		  else if (reg == 4)
		    {
		      /* addq -> addq - addressing with %rsp/%r12 is
			 special  */
		      if (val == 0x4c)
			bfd_put_8 (output_bfd, 0x49,
				   contents + rel->r_offset - 3);
		      bfd_put_8 (output_bfd, 0x81,
				 contents + rel->r_offset - 2);
		      bfd_put_8 (output_bfd, 0xc0 | reg,
				 contents + rel->r_offset - 1);
		    }
		  else
		    {
		      /* addq -> leaq */
		      if (val == 0x4c)
			bfd_put_8 (output_bfd, 0x4d,
				   contents + rel->r_offset - 3);
		      bfd_put_8 (output_bfd, 0x8d,
				 contents + rel->r_offset - 2);
		      bfd_put_8 (output_bfd, 0x80 | reg | (reg << 3),
				 contents + rel->r_offset - 1);
		    }
		  bfd_put_32 (output_bfd, tpoff (info, relocation),
			      contents + rel->r_offset);
		  continue;
		}
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	  if ((off & 1) != 0)
	    off &= ~1;
          else
	    {
	      Elf_Internal_Rela outrel;
	      Elf64_External_Rela *loc;
	      int dr_type, indx;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_X86_64_TLSGD)
		dr_type = R_X86_64_DTPMOD64;
	      else
		dr_type = R_X86_64_TPOFF64;

	      bfd_put_64 (output_bfd, 0, htab->sgot->contents + off);
	      outrel.r_addend = 0;
	      if (dr_type == R_X86_64_TPOFF64 && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      outrel.r_info = ELF64_R_INFO (indx, dr_type);

	      loc = (Elf64_External_Rela *) htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++;
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_X86_64_TLSGD)
		{
		  if (indx == 0)
		    {
	    	      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_64 (output_bfd,
				  relocation - dtpoff_base (info),
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
		    }
		  else
		    {
		      bfd_put_64 (output_bfd, 0,
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
		      outrel.r_info = ELF64_R_INFO (indx,
						    R_X86_64_DTPOFF64);
		      outrel.r_offset += GOT_ENTRY_SIZE;
		      htab->srelgot->reloc_count++;
		      loc++;
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						 loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();
	  if (r_type == ELF64_R_TYPE (rel->r_info))
	    {
	      relocation = htab->sgot->output_section->vma
			   + htab->sgot->output_offset + off;
	      unresolved_reloc = false;
	    }
	  else
	    {
	      unsigned int i;
	      static unsigned char tlsgd[7]
		= { 0x66, 0x66, 0x66, 0x66, 0x48, 0x8d, 0x3d };

	      /* GD->IE transition.
		 .long 0x66666666; leaq foo@@tlsgd(%rip), %rdi
		 callq __tls_get_addr@@plt
		 Change it into:
		 movq %fs:0, %rax
		 addq foo@@gottpoff(%rip), %rax */
	      BFD_ASSERT (rel->r_offset >= 7);
	      for (i = 0; i < 7; i++)
	        BFD_ASSERT (bfd_get_8 (input_bfd,
				       contents + rel->r_offset - 7 + i)
			    == tlsgd[i]);
	      BFD_ASSERT (rel->r_offset + 9 <= input_section->_raw_size);
	      BFD_ASSERT (bfd_get_8 (input_bfd,
				     contents + rel->r_offset + 4)
			  == 0xe8);
	      BFD_ASSERT (rel + 1 < relend);
	      BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
	      memcpy (contents + rel->r_offset - 7,
		      "\x64\x48\x8b\x04\x25\0\0\0\0\x48\x03\x05\0\0\0",
		      16);

	      relocation = (htab->sgot->output_section->vma
			    + htab->sgot->output_offset + off
			    - rel->r_offset
			    - input_section->output_section->vma
			    - input_section->output_offset
			    - 9);
	      bfd_put_32 (output_bfd, relocation,
			  contents + rel->r_offset + 5);
	      /* Skip R_X86_64_PLT32.  */
	      rel++;
	      continue;
	    }
	  break;

	case R_X86_64_TLSLD:
	  if (! info->shared)
	    {
	      /* LD->LE transition:
		 Ensure it is:
		 leaq foo@@tlsld(%rip), %rdi; call __tls_get_addr@@plt.
		 We change it into:
		 .word 0x6666; .byte 0x66; movl %fs:0, %rax.  */
	      BFD_ASSERT (rel->r_offset >= 3);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 3)
			  == 0x48);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 2)
			  == 0x8d);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset - 1)
			  == 0x3d);
	      BFD_ASSERT (rel->r_offset + 9 <= input_section->_raw_size);
	      BFD_ASSERT (bfd_get_8 (input_bfd, contents + rel->r_offset + 4)
			  == 0xe8);
	      BFD_ASSERT (rel + 1 < relend);
	      BFD_ASSERT (ELF64_R_TYPE (rel[1].r_info) == R_X86_64_PLT32);
	      memcpy (contents + rel->r_offset - 3,
		      "\x66\x66\x66\x64\x48\x8b\x04\x25\0\0\0", 12);
	      /* Skip R_X86_64_PLT32.  */
	      rel++;
	      continue;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  off = htab->tls_ld_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      Elf64_External_Rela *loc;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      bfd_put_64 (output_bfd, 0,
			  htab->sgot->contents + off);
	      bfd_put_64 (output_bfd, 0,
			  htab->sgot->contents + off + GOT_ENTRY_SIZE);
	      outrel.r_info = ELF64_R_INFO (0, R_X86_64_DTPMOD64);
	      outrel.r_addend = 0;
	      loc = (Elf64_External_Rela *) htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++;
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ld_got.offset |= 1;
	    }
	  relocation = htab->sgot->output_section->vma
		       + htab->sgot->output_offset + off;
	  unresolved_reloc = false;
	  break;

	case R_X86_64_DTPOFF32:
	  if (info->shared)
	    relocation -= dtpoff_base (info);
	  else
	    relocation = tpoff (info, relocation);
	  break;

	case R_X86_64_TPOFF32:
	  BFD_ASSERT (! info->shared);
	  relocation = tpoff (info, relocation);
	  break;

d2090 1
a2090 3
  if (h->got.offset != (bfd_vma) -1
      && elf64_x86_64_hash_entry (h)->tls_type != GOT_TLS_GD
      && elf64_x86_64_hash_entry (h)->tls_type != GOT_TLS_IE)
d2096 1
a2096 1
	 up.  */
a2353 1
#define bfd_elf64_mkobject		    elf64_x86_64_mkobject
@


1.42.2.6
log
@merge from mainline
@
text
@d2227 2
a2228 2
		  static unsigned char tlsgd[8]
		    = { 0x66, 0x48, 0x8d, 0x3d, 0x66, 0x66, 0x48, 0xe8 };
d2231 2
a2232 2
		     .byte 0x66; leaq foo@@tlsgd(%rip), %rdi
		     .word 0x6666; rex64; call __tls_get_addr@@plt
d2236 2
a2237 2
		  BFD_ASSERT (rel->r_offset >= 4);
		  for (i = 0; i < 4; i++)
d2239 1
a2239 1
					   contents + rel->r_offset - 4 + i)
d2241 4
a2244 5
		  BFD_ASSERT (rel->r_offset + 12 <= input_section->_raw_size);
		  for (i = 0; i < 4; i++)
		    BFD_ASSERT (bfd_get_8 (input_bfd,
					   contents + rel->r_offset + 4 + i)
				== tlsgd[i+4]);
d2247 1
a2247 1
		  memcpy (contents + rel->r_offset - 4,
d2251 1
a2251 1
			      contents + rel->r_offset + 8);
d2400 2
a2401 2
	      static unsigned char tlsgd[8]
		= { 0x66, 0x48, 0x8d, 0x3d, 0x66, 0x66, 0x48, 0xe8 };
d2404 2
a2405 2
		 .byte 0x66; leaq foo@@tlsgd(%rip), %rdi
		 .word 0x6666; rex64; call __tls_get_addr@@plt
d2409 2
a2410 2
	      BFD_ASSERT (rel->r_offset >= 4);
	      for (i = 0; i < 4; i++)
d2412 1
a2412 1
				       contents + rel->r_offset - 4 + i)
d2414 4
a2417 5
	      BFD_ASSERT (rel->r_offset + 12 <= input_section->_raw_size);
	      for (i = 0; i < 4; i++)
	        BFD_ASSERT (bfd_get_8 (input_bfd,
				       contents + rel->r_offset + 4 + i)
			    == tlsgd[i+4]);
d2420 1
a2420 1
	      memcpy (contents + rel->r_offset - 4,
d2429 1
a2429 1
			    - 12);
d2431 1
a2431 1
			  contents + rel->r_offset + 8);
d2499 1
a2499 1
	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
@


1.41
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@d128 4
d215 67
d2302 2
@


1.41.2.1
log
@merge from trunk
@
text
@a127 4
static boolean elf64_x86_64_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
static boolean elf64_x86_64_grok_psinfo
  PARAMS ((bfd *, Elf_Internal_Note *));
a210 67
/* Support for core dump NOTE sections.  */
static boolean
elf64_x86_64_grok_prstatus (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  int offset;
  size_t raw_size;

  switch (note->descsz)
    {
      default:
	return false;

      case 336:		/* sizeof(istruct elf_prstatus) on Linux/x86_64 */
	/* pr_cursig */
	elf_tdata (abfd)->core_signal
	  = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core_pid
	  = bfd_get_32 (abfd, note->descdata + 32);

	/* pr_reg */
	offset = 112;
	raw_size = 216;

	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  raw_size, note->descpos + offset);
}

static boolean
elf64_x86_64_grok_psinfo (abfd, note)
     bfd *abfd;
     Elf_Internal_Note *note;
{
  switch (note->descsz)
    {
      default:
	return false;

      case 136:		/* sizeof(struct elf_prpsinfo) on Linux/x86_64 */
	elf_tdata (abfd)->core_program
	 = _bfd_elfcore_strndup (abfd, note->descdata + 40, 16);
	elf_tdata (abfd)->core_command
	 = _bfd_elfcore_strndup (abfd, note->descdata + 56, 80);
    }

  /* Note that for some reason, a spurious space is tacked
     onto the end of the args in some (at least one anyway)
     implementations, so strip it off if it exists.  */

  {
    char *command = elf_tdata (abfd)->core_command;
    int n = strlen (command);

    if (0 < n && command[n - 1] == ' ')
      command[n - 1] = '\0';
  }

  return true;
}

d1019 1
a1019 1
     runtime process image.  */
a2230 2
#define elf_backend_grok_prstatus	    elf64_x86_64_grok_prstatus
#define elf_backend_grok_psinfo		    elf64_x86_64_grok_psinfo
@


1.40
log
@	* elf64-x86-64.c (struct elf64_x86_64_dyn_relocs): Comment typo.
	* elf32-hppa.c (elf32_hppa_final_link): Formatting.
@
text
@d1497 3
d1530 1
a1531 1

a1532 21

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.	*/
d2215 1
@


1.39
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d249 1
a249 1
   decides to copy as dynamic relocs in check_relocs for each symbol.
@


1.38
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d343 1
a343 1
  ret = (struct elf64_x86_64_link_hash_table *) bfd_alloc (abfd, amt);
d349 1
a349 1
      bfd_release (abfd, ret);
@


1.37
log
@	* elf64-sh64.c (sh_elf64_relocate_section): Fix a typo from my
	last patch.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@d1078 1
a1078 2
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
d1081 3
d1249 3
@


1.36
log
@	* elf64-x86-64.c: Major rework that introduces all recent changes
	to the x86-64 backend.  Get a closer match to elf32-i386.
	(struct elf64_x86_64_dyn_relocs): Rename from
	elf64_x86_64_pcrel_relocs_copied, add additional fields.  Change
	all users.
	(struct elf64_x86_64_link_hash_table): Add short cuts to some
	sections.
	(link_hash_newfunc): Rename from elf64_x86_64_link_hash_newfunc,
	remove casts, initialize new hash members.
	(create_got_section): New.
	(elf64_x86_64_create_dynamic_sections): New.
	(elf64_x86_64_copy_indirect_symbol): New.
	(elf64_x86_64_check_relocs): Don't allocate space for dynamic
	relocs, .got or .relgot here but do it in allocate_dynrelocs.
	Reference count possible .plt and .got entries.  Don't test input
	section SEC_READONLY here to try to avoid copy relocs, and keep
	dyn_relocs regardless of ELF_LINK_NON_GOT_REF.  Don't set
	DF_TEXTREL here.  Delay setting of variables until needed.  Cache
	pointer to "sreloc" section in elf_section_data. Tweak condition
	under which .got created.  Report files with bad relocation
	section names.
	(elf64_x86_64_gc_sweep_hook): Sweep dyn_relocs and local_dynrel.
	Reference count possible .plt entries.  Don't deallocate .got and
	.relgot space here.
	(elf64_x86_64_adjust_dynamic_symbol): Handle nocopyreloc.  Don't
	do copy reloc processing for weakdefs.  Remove redundant casts and
	aborts.  Delay setting of vars until needed.  Move creation of
	dynamic symbols and allocation of .plt and .rela.plt to
	allocate_dynrelocs.  Replace BFD_ASSERT with abort.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(allocate_dynrelocs): New.
	(readonly_dynrelocs): New.
	(elf64_x86_64_size_dynamic_sections): Call readonly_dynrelocs.
	Allocate space for dyn relocs.  Replace BFD_ASSERT with abort.
	Zero out the dynamic allocated content space.
	(elf64_x86_64_discard_copies): Removed.
	(elf64_x86_64_relocate_section): Make use of dynamic section
	short-cuts.  Localise vars, and delay setting.  Better error
	reporting, replace BFD_ASSERT with abort.  Check
	ELF_LINK_HASH_DEF_DYNAMIC to see if a symbol is not defined in the
	regular object file and tread the weak definition as the normal
	one.  Don't discard relocs for undefweak or undefined symbols and
	check !DEF_REGULAR as well as DEF_DYNAMIC in test for avoided copy
	relocs.
	(elf64_x86_64_finish_dynamic_symbol): Don't copy relocs for
	symbols that have been forced local.  Use same test to decide if
	we can use a relative reloc for got as relocate_section.  Expand
	SHN_UNDEF comment.  Move expressions out of function calls.
	Replace BFD_ASSERT with abort.
	(bfd_elf64_bfd_final_link): Removed.
	(elf_backend_copy_indirect_symbol): Define.
@
text
@d1779 1
a1779 1
	      else if (outrel.r_offset == (bfd_vma) -1)
@


1.35
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d23 1
d30 1
a30 1
#define USE_RELA
d131 6
d148 1
a148 1
static struct bfd_hash_entry *elf64_x86_64_link_hash_newfunc
d153 4
d249 4
a252 4
   it decides to copy in check_relocs for each symbol.	This is so
   that it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.	 */
d254 1
a254 4
/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */

struct elf64_x86_64_pcrel_relocs_copied
d257 6
a262 4
  struct elf64_x86_64_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
d264 3
d273 1
a273 1
  struct elf_link_hash_entry root;
d275 2
a276 2
  /* Number of PC relative relocs copied for this symbol.  */
  struct elf64_x86_64_pcrel_relocs_copied *pcrel_relocs_copied;
d279 1
a279 1
/* x86-64  ELF linker hash table.  */
d283 1
a283 2
  struct elf_link_hash_table root;
};
d285 8
a292 1
/* Declare this now that the above structures are defined.  */
d294 3
a296 10
static boolean elf64_x86_64_discard_copies
  PARAMS ((struct elf64_x86_64_link_hash_entry *, PTR));

/* Traverse an x86-64 ELF linker hash table.  */

#define elf64_x86_64_link_hash_traverse(table, func, info)		\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))
d306 1
a306 1
elf64_x86_64_link_hash_newfunc (entry, table, string)
a310 3
  struct elf64_x86_64_link_hash_entry *ret =
    (struct elf64_x86_64_link_hash_entry *) entry;

d312 8
a319 7
     subclass.	*/
  if (ret == (struct elf64_x86_64_link_hash_entry *) NULL)
    ret = ((struct elf64_x86_64_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf64_x86_64_link_hash_entry)));
  if (ret == (struct elf64_x86_64_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;
d322 2
a323 4
  ret = ((struct elf64_x86_64_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct elf64_x86_64_link_hash_entry *) NULL)
d325 4
a328 1
      ret->pcrel_relocs_copied = NULL;
d331 1
a331 1
  return (struct bfd_hash_entry *) ret;
d343 2
a344 2
  ret = ((struct elf64_x86_64_link_hash_table *) bfd_alloc (abfd, amt));
  if (ret == (struct elf64_x86_64_link_hash_table *) NULL)
d347 1
a347 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       elf64_x86_64_link_hash_newfunc))
d353 119
a471 1
  return &ret->root.root;
d484 2
a485 2
   allocate space in the global offset table or procedure linkage
   table.  */
d494 1
a494 1
  bfd *dynobj;
a496 1
  bfd_signed_vma *local_got_refcounts;
a498 2
  asection *sgot;
  asection *srelgot;
d504 1
a504 1
  dynobj = elf_hash_table (info)->dynobj;
a506 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
d508 2
a509 1
  sgot = srelgot = sreloc = NULL;
d517 9
a530 14
      /* Some relocs require a global offset table.  */
      if (dynobj == NULL)
	{
	  switch (ELF64_R_TYPE (rel->r_info))
	    {
	    case R_X86_64_GOT32:
	    case R_X86_64_GOTPCREL:
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
		return false;
	      break;
	    }
	}

d533 1
a534 1
	case R_X86_64_GOT32:
a535 26

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }

	  if (srelgot == NULL && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 3))
		    return false;
		}
	    }

a537 12
	      if (h->got.refcount == 0)
		{
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1)
		    {
		      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
			return false;
		    }

		  sgot->_raw_size += GOT_ENTRY_SIZE;
		  srelgot->_raw_size += sizeof (Elf64_External_Rela);
		}
d542 2
d545 1
a557 11
	      if (local_got_refcounts[r_symndx] == 0)
		{
		  sgot->_raw_size += GOT_ENTRY_SIZE;
		  if (info->shared)
		    {
		      /* If we are generating a shared object, we need to
			 output a R_X86_64_RELATIVE reloc so that the dynamic
			 linker can adjust this GOT entry.  */
		      srelgot->_raw_size += sizeof (Elf64_External_Rela);
		    }
		}
d560 10
d594 2
d597 14
a610 2
	  if (h != NULL)
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d621 35
a655 18
	     later (it is never cleared).  We account for that
	     possibility below by storing information in the
	     pcrel_relocs_copied field of the hash table entry.
	     A similar situation occurs when creating shared libraries
	     and symbol visibility changes render the symbol local.  */
	  if (info->shared
	      && (sec->flags & SEC_ALLOC) != 0
	      && (((ELF64_R_TYPE (rel->r_info) != R_X86_64_PC8)
		  && (ELF64_R_TYPE (rel->r_info) != R_X86_64_PC16)
		  && (ELF64_R_TYPE (rel->r_info) != R_X86_64_PC32))
		  || (h != NULL
		      && (! info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	    {
	      /* When creating a shared object, we must copy these
		 reloc types into the output file.  We create a reloc
		 section in dynobj and make room for this reloc.  */
d659 1
d668 13
a680 3
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);
d697 1
a697 2
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
d700 7
a706 12
	      sreloc->_raw_size += sizeof (Elf64_External_Rela);

	      /* If this is a global symbol, we count the number of PC
		 relative relocations we have entered for this symbol,
		 so that we can discard them later as necessary.  Note
		 that this function is only called if we are using an
		 elf64_x86_64 linker hash table, which means that h is
		 really a pointer to an elf64_x86_64_link_hash_entry.  */
	      if (h != NULL
		  && ((ELF64_R_TYPE (rel->r_info) == R_X86_64_PC8)
		      || (ELF64_R_TYPE (rel->r_info) == R_X86_64_PC16)
		      || (ELF64_R_TYPE (rel->r_info) == R_X86_64_PC32)))
d708 9
a716 2
		  struct elf64_x86_64_link_hash_entry *eh;
		  struct elf64_x86_64_pcrel_relocs_copied *p;
d718 3
a720 5
		  eh = (struct elf64_x86_64_link_hash_entry *) h;

		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		    if (p->section == sreloc)
		      break;
d722 6
d729 7
a735 10
		    {
		      p = ((struct elf64_x86_64_pcrel_relocs_copied *)
			   bfd_alloc (dynobj, (bfd_size_type) sizeof *p));
		      if (p == NULL)
			return false;
		      p->next = eh->pcrel_relocs_copied;
		      eh->pcrel_relocs_copied = p;
		      p->section = sreloc;
		      p->count = 0;
		    }
d737 5
a741 2
		  ++p->count;
		}
d758 3
d774 1
a774 1
     Elf_Internal_Rela *rel ATTRIBUTE_UNUSED;
d814 1
a814 1
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
d824 2
a825 3
  bfd *dynobj;
  asection *sgot;
  asection *srelgot;
a830 7
  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return true;

  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");

d842 1
a842 8
	      {
		h->got.refcount -= 1;
		if (h->got.refcount == 0)
		  {
		    sgot->_raw_size -= GOT_ENTRY_SIZE;
		    srelgot->_raw_size -= sizeof (Elf64_External_Rela);
		  }
	      }
d847 38
a884 9
	      {
		local_got_refcounts[r_symndx] -= 1;
		if (local_got_refcounts[r_symndx] == 0)
		  {
		    sgot->_raw_size -= GOT_ENTRY_SIZE;
		    if (info->shared)
		      srelgot->_raw_size -= sizeof (Elf64_External_Rela);
		  }
	      }
d888 1
d917 3
a919 1
  bfd *dynobj;
a922 13
  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
		  || h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

d929 6
a934 4
      if ((! info->shared
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	  || (info->shared && h->plt.refcount <= 0))
a942 1
	  return true;
a944 43
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
	    return false;
	}

      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* If this is the first .plt entry, make room for the special
	 first entry.  */
      if (s->_raw_size == 0)
	s->_raw_size = PLT_ENTRY_SIZE;

      /* If this symbol is not defined in a regular file, and we are
	 not generating a shared library, then set the symbol to this
	 location in the .plt.	This is required to make function
	 pointers compare as equal between the normal executable and
	 the shared library.  */
      if (! info->shared
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	{
	  h->root.u.def.section = s;
	  h->root.u.def.value = s->_raw_size;
	}

      h->plt.offset = s->_raw_size;

      /* Make room for this entry.  */
      s->_raw_size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */
      s = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += GOT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf64_External_Rela);

d948 5
d982 23
d1015 1
a1015 2
  s = bfd_get_section_by_name (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);
d1019 1
a1019 2
     runtime process image.  We need to remember the offset into the
     .rela.bss section we are going to use.  */
d1022 1
a1022 5
      asection *srel;

      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf64_External_Rela);
d1036 1
d1038 1
a1038 1
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
d1040 1
a1040 1
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
d1054 212
d1273 1
a1275 1
  boolean plt;
d1277 1
d1279 4
a1282 2
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
d1284 1
a1284 1
  if (elf_hash_table (info)->dynamic_sections_created)
d1290 2
a1291 1
	  BFD_ASSERT (s != NULL);
a1295 11
  else
    {
      /* We may have created entries in the .rela.got section.
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.got,
	 which will cause it to get stripped from the output file
	 below.	 */
      s = bfd_get_section_by_name (dynobj, ".rela.got");
      if (s != NULL)
	s->_raw_size = 0;
    }
d1297 9
a1305 17
  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared)
    elf64_x86_64_link_hash_traverse (elf64_x86_64_hash_table (info),
				     elf64_x86_64_discard_copies,
				     (PTR) info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = relocs = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      boolean strip;
d1307 1
a1307 1
      if ((s->flags & SEC_LINKER_CREATED) == 0)
d1310 3
a1312 3
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);
d1314 4
a1317 4
      strip = false;
      if (strcmp (name, ".plt") == 0)
	{
	  if (s->_raw_size == 0)
d1319 16
a1334 8
	      /* Strip this section if we don't need it; see the
		 comment below.	 */
	      strip = true;
	    }
	  else
	    {
	      /* Remember whether there is a PLT.  */
	      plt = true;
d1337 11
a1347 1
      else if (strncmp (name, ".rela", 5) == 0)
d1349 1
a1349 1
	  if (s->_raw_size == 0)
d1351 4
a1354 10
	      /* If we don't need this section, strip it from the
		 output file.  This is mostly to handle .rela.bss and
		 .rela.plt.  We must create both sections in
		 create_dynamic_sections, because they must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = true;
d1357 15
a1371 3
	    {
	      if (strcmp (name, ".rela.plt") != 0)
		relocs = true;
d1373 6
a1378 4
	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
d1380 10
a1389 1
      else if (strncmp (name, ".got", 4) != 0)
d1395 1
a1395 1
      if (strip)
d1397 10
d1417 1
a1417 1
      if (s->contents == NULL && s->_raw_size != 0)
d1421 1
a1421 1
  if (elf_hash_table (info)->dynamic_sections_created)
d1437 1
a1437 1
      if (plt)
a1451 1
	}
d1453 11
a1463 4
      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return false;
a1470 31
/* This function is called via elf64_x86_64_link_hash_traverse if we are
   creating a shared object.  In the -Bsymbolic case, it discards the
   space allocated to copy PC relative relocs against symbols which
   are defined in regular objects.  For the normal non-symbolic case,
   we also discard space for relocs that have become local due to
   symbol visibility changes.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */

static boolean
elf64_x86_64_discard_copies (h, inf)
     struct elf64_x86_64_link_hash_entry *h;
     PTR inf;
{
  struct elf64_x86_64_pcrel_relocs_copied *s;
  struct bfd_link_info *info = (struct bfd_link_info *) inf;

  /* If a symbol has been forced local or we have found a regular
     definition for the symbolic link case, then we won't be needing
     any relocs.  */
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
      && ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	  || info->symbolic))
    {
      for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
	s->section->_raw_size -= s->count * sizeof (Elf64_External_Rela);
    }

  return true;
}

d1485 1
a1485 1
  bfd *dynobj;
d1489 1
a1489 4
  asection *sgot;
  asection *splt;
  asection *sreloc;
  Elf_Internal_Rela *rela;
d1492 1
a1492 1
  dynobj = elf_hash_table (info)->dynobj;
d1497 1
a1497 8
  sreloc = splt = sgot = NULL;
  if (dynobj != NULL)
    {
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got");
    }

  rela = relocs;
d1499 1
a1499 1
  for (; rela < relend; rela++)
d1507 1
d1509 1
a1510 1
      unsigned int indx;
d1512 1
a1512 1
      r_type = ELF64_R_TYPE (rela->r_info);
d1517 1
a1517 1
      if ((indx = (unsigned) r_type) >= R_X86_64_max)
d1522 1
a1522 1
      howto = x86_64_elf_howto_table + indx;
d1524 1
a1524 1
      r_symndx = ELF64_R_SYM (rela->r_info);
d1538 1
a1538 1
		  rela->r_addend += sec->output_offset + sym->st_value;
d1549 1
d1554 2
a1555 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rela);
d1563 1
d1568 1
a1568 35
	      if ((r_type == R_X86_64_PLT32
		   && splt != NULL
		   && h->plt.offset != (bfd_vma) -1)
		  || ((r_type == R_X86_64_GOT32 || r_type == R_X86_64_GOTPCREL)
		      && elf_hash_table (info)->dynamic_sections_created
		      && (!info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      && (r_type == R_X86_64_8
			  || r_type == R_X86_64_16
			  || r_type == R_X86_64_32
			  || r_type == R_X86_64_64
			  || r_type == R_X86_64_PC8
			  || r_type == R_X86_64_PC16
			  || r_type == R_X86_64_PC32)
                      && ((input_section->flags & SEC_ALLOC) != 0
                          /* DWARF will emit R_X86_64_32 relocations in its
                             sections against symbols defined externally
                             in shared libraries.  We can't do anything
                             with them here.  */
                          || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
		{
		  /* In these cases, we don't need the relocation
                     value.  We check specially because in some
                     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
	      else if (sec->output_section == NULL)
d1570 5
a1574 4
		  (*_bfd_error_handler)
		    (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
		     bfd_archive_filename (input_bfd), h->root.root.string,
		     bfd_get_section_name (input_bfd, input_section));
d1593 1
a1593 1
		      input_section, rela->r_offset,
a1599 1

d1609 2
a1610 1
	  BFD_ASSERT (sgot != NULL);
d1614 4
a1617 2
	      bfd_vma off = h->got.offset;
	      BFD_ASSERT (off != (bfd_vma) -1);
d1619 1
a1619 1
	      if (! elf_hash_table (info)->dynamic_sections_created
d1621 3
a1623 1
		      && (info->symbolic || h->dynindx == -1)
d1642 1
a1642 1
				  sgot->contents + off);
a1645 2
	      if (r_type == R_X86_64_GOTPCREL)
		relocation = sgot->output_section->vma + sgot->output_offset + off;
d1647 1
a1647 1
		relocation = sgot->output_offset + off;
d1651 2
a1652 4
	      bfd_vma off;

	      BFD_ASSERT (local_got_offsets != NULL
			  && local_got_offsets[r_symndx] != (bfd_vma) -1);
d1663 2
a1664 1
		  bfd_put_64 (output_bfd, relocation, sgot->contents + off);
d1670 1
d1674 3
a1676 2
		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (srelgot != NULL);
d1678 2
a1679 2
		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset
d1683 3
a1685 5
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						 (((Elf64_External_Rela *)
						   srelgot->contents)
						  + srelgot->reloc_count));
		      ++srelgot->reloc_count;
d1690 1
d1692 6
a1697 5
	      if (r_type == R_X86_64_GOTPCREL)
		relocation = sgot->output_section->vma + sgot->output_offset + off;
	      else
		relocation = sgot->output_offset + off;
	    }
d1710 2
a1711 1
	  if (h->plt.offset == (bfd_vma) -1 || splt == NULL)
d1719 2
a1720 2
	  relocation = (splt->output_section->vma
			+ splt->output_offset
d1722 1
a1727 5
	  if (h == NULL || h->dynindx == -1
	      || (info->symbolic
		  && h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
	    break;
	  /* Fall through.  */
d1734 27
a1760 3
	  if (info->shared
	      && r_symndx != 0
	      && (input_section->flags & SEC_ALLOC) != 0)
d1764 2
a1770 20
	      if (sreloc == NULL)
		{
		  const char *name;

		  name = (bfd_elf_string_from_elf_section
			  (input_bfd,
			   elf_elfheader (input_bfd)->e_shstrndx,
			   elf_section_data (input_section)->rel_hdr.sh_name));
		  if (name == NULL)
		    return false;

		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (input_bfd,
							       input_section),
					 name + 5) == 0);

		  sreloc = bfd_get_section_by_name (dynobj, name);
		  BFD_ASSERT (sreloc != NULL);
		}

d1776 1
a1776 1
					 rela->r_offset);
d1787 1
d1791 6
a1796 1
		       && ((! info->symbolic && h->dynindx != -1)
a1799 1
		  BFD_ASSERT (h->dynindx != -1);
d1801 1
a1801 1
		  outrel.r_addend = relocation + rela->r_addend;
d1805 5
a1809 9
		  if (r_type == R_X86_64_64)
		    {
		      relocate = true;
		      outrel.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
		      outrel.r_addend = relocation + rela->r_addend;
		    }
		  else
		    {
		      long sindx;
d1811 3
a1813 24
		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
			sindx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return false;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  sindx = elf_section_data (osec)->dynindx;
			  BFD_ASSERT (sindx > 0);
			}
d1815 3
a1817 11
		      outrel.r_info = ELF64_R_INFO (sindx, r_type);
		      outrel.r_addend = relocation + rela->r_addend;
		    }

		}

	      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
					(((Elf64_External_Rela *)
					  sreloc->contents)
					 + sreloc->reloc_count));
	      ++sreloc->reloc_count;
d1833 16
d1850 2
a1851 2
				    contents, rela->r_offset,
				    relocation, rela->r_addend);
d1855 24
a1878 1
	  switch (r)
d1880 6
a1885 25
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return false;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rela->r_offset)))
		  return false;
	      }
	      break;
d1903 1
a1903 1
  bfd *dynobj;
d1905 1
a1905 1
  dynobj = elf_hash_table (info)->dynobj;
a1908 3
      asection *splt;
      asection *sgot;
      asection *srela;
d1912 1
d1917 5
a1921 6
      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srela = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);
d1935 1
a1935 1
      memcpy (splt->contents + h->plt.offset, elf64_x86_64_plt_entry,
d1944 2
a1945 2
		      (sgot->output_section->vma
		       + sgot->output_offset
d1947 2
a1948 2
		       - splt->output_section->vma
		       - splt->output_offset
d1951 1
a1951 1
		  splt->contents + h->plt.offset + 2);
d1954 1
a1954 1
		  splt->contents + h->plt.offset + 7);
d1957 1
a1957 1
		  splt->contents + h->plt.offset + 12);
d1961 2
a1962 1
      bfd_put_64 (output_bfd, (splt->output_section->vma + splt->output_offset
d1964 1
a1964 1
		  sgot->contents + got_offset);
d1967 2
a1968 2
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
d1972 2
a1973 3
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) srela->contents
				  + plt_index));
d1978 4
a1981 1
	     the .plt section.	Leave the value alone.	*/
a1982 7
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	      == 0)
	    sym->st_value = 0;
a1987 2
      asection *sgot;
      asection *srela;
d1989 1
d1994 2
a1995 3
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srela != NULL);
d1997 2
a1998 2
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
d2006 5
a2010 4
      if (! elf_hash_table (info)->dynamic_sections_created
	  || (info->shared
	      && (info->symbolic || h->dynindx == -1)
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2021 2
a2022 1
	  bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
d2027 3
a2029 4
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) srela->contents
				  + srela->reloc_count));
      ++srela->reloc_count;
a2033 1
      asection *s;
d2035 1
d2039 5
a2043 7
      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));

      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
      BFD_ASSERT (s != NULL);
d2050 3
a2052 4
      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
d2063 20
d2090 1
a2092 1
  asection *sgot;
d2094 2
a2095 4
  dynobj = elf_hash_table (info)->dynobj;

  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
d2098 1
a2098 1
  if (elf_hash_table (info)->dynamic_sections_created)
a2099 1
      asection *splt;
d2102 2
a2103 1
      BFD_ASSERT (sdyn != NULL);
a2109 1
	  const char *name;
d2120 2
a2121 2
	      name = ".got";
	      goto get_vma;
d2124 2
a2125 1
	      name = ".rela.plt";
d2127 6
a2132 4
	    get_vma:
	      s = bfd_get_section_by_name (output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
d2136 8
a2143 8
	      /* FIXME: This comment and code is from elf64-alpha.c:  */
	      /* My interpretation of the TIS v1.1 ELF document indicates
		 that RELASZ should not include JMPREL.	 This is not what
		 the rest of the BFD does.  It is, however, what the
		 glibc ld.so wants.  Do this fixup here until we found
		 out who is right.  */
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      if (s)
d2145 5
a2149 3
		  /* Subtract JMPREL size from RELASZ.	*/
		  dyn.d_un.d_val -=
		    (s->_cooked_size ? s->_cooked_size : s->_raw_size);
d2152 1
a2153 7
	    case DT_PLTRELSZ:
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_val =
		(s->_cooked_size != 0 ? s->_cooked_size : s->_raw_size);
	      break;
	    }
d2157 2
a2158 4
      /* Initialize the contents of the .plt section.  */
      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL);
      if (splt->_raw_size > 0)
d2161 2
a2162 1
	  memcpy (splt->contents, elf64_x86_64_plt0_entry, PLT_ENTRY_SIZE);
d2166 2
a2167 2
		      (sgot->output_section->vma
		       + sgot->output_offset
d2169 2
a2170 2
		       - splt->output_section->vma
		       - splt->output_offset
d2172 1
a2172 1
		      splt->contents + 2);
d2176 2
a2177 2
		      (sgot->output_section->vma
		       + sgot->output_offset
d2179 2
a2180 2
		       - splt->output_section->vma
		       - splt->output_offset
d2182 1
a2182 1
		      splt->contents + 8);
d2184 2
a2186 3

      elf_section_data (splt->output_section)->this_hdr.sh_entsize =
	PLT_ENTRY_SIZE;
d2189 1
a2189 3
  /* Set the first entry in the global offset table to the address of
     the dynamic section.  */
  if (sgot->_raw_size > 0)
d2191 18
a2208 9
      if (sdyn == NULL)
	bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_64 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
      /* Write GOT[1] and GOT[2], needed for the dynamic linker.  */
      bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + GOT_ENTRY_SIZE);
      bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + GOT_ENTRY_SIZE*2);
a2210 3
  elf_section_data (sgot->output_section)->this_hdr.sh_entsize =
    GOT_ENTRY_SIZE;

a2213 16
static enum elf_reloc_type_class
elf64_x86_64_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_X86_64_RELATIVE:
      return reloc_class_relative;
    case R_X86_64_JUMP_SLOT:
      return reloc_class_plt;
    case R_X86_64_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}
a2230 1
#define bfd_elf64_bfd_final_link	    _bfd_elf64_gc_common_final_link
d2237 3
a2239 3
#define elf_backend_create_dynamic_sections _bfd_elf_create_dynamic_sections
#define elf_backend_finish_dynamic_sections \
  elf64_x86_64_finish_dynamic_sections
d2243 1
a2246 1
#define elf_backend_reloc_type_class	    elf64_x86_64_reloc_type_class
@


1.34
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d1469 1
d1476 2
d1483 1
a1483 4
		{
		  memset (&outrel, 0, sizeof outrel);
		  relocate = false;
		}
a1491 1
		  relocate = false;
a1531 1
		      relocate = false;
@


1.34.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a1468 1
	      relocate = false;
a1474 2
	      else if (outrel.r_offset == (bfd_vma) -1)
		skip = true, relocate = true;
d1480 4
a1483 1
		memset (&outrel, 0, sizeof outrel);
d1492 1
d1533 1
@


1.34.2.2
log
@	* elf64-sh64.c (sh_elf64_relocate_section): Fix a typo from my
	last patch.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@d1476 1
a1476 1
	      else if (outrel.r_offset == (bfd_vma) -2)
@


1.34.2.3
log
@Merge from mainline.
@
text
@a1120 3
  if (h->root.root.type == bfd_link_hash_warning)
    h = (struct elf64_x86_64_link_hash_entry *) h->root.root.u.i.link;

@


1.34.2.4
log
@	Merge from mainline
	2002-04-12  Alan Modra  <amodra@@bigpond.net.au>
	* elf.c (prep_headers): Don't zero EI_OSABI, EI_ABIVERSION or
	header pad.

	2002-02-21  Andreas Jaeger  <aj@@suse.de>
	* elf64-x86-64.c: Major rework that introduces all recent changes
	to the x86-64 backend.  Get a closer match to elf32-i386.
	(struct elf64_x86_64_dyn_relocs): Rename from
	elf64_x86_64_pcrel_relocs_copied, add additional fields.  Change
	all users.
	(struct elf64_x86_64_link_hash_table): Add short cuts to some
	sections.
	(link_hash_newfunc): Rename from elf64_x86_64_link_hash_newfunc,
	remove casts, initialize new hash members.
	(create_got_section): New.
	(elf64_x86_64_create_dynamic_sections): New.
	(elf64_x86_64_copy_indirect_symbol): New.
	(elf64_x86_64_check_relocs): Don't allocate space for dynamic
	relocs, .got or .relgot here but do it in allocate_dynrelocs.
	Reference count possible .plt and .got entries.  Don't test input
	section SEC_READONLY here to try to avoid copy relocs, and keep
	dyn_relocs regardless of ELF_LINK_NON_GOT_REF.  Don't set
	DF_TEXTREL here.  Delay setting of variables until needed.  Cache
	pointer to "sreloc" section in elf_section_data. Tweak condition
	under which .got created.  Report files with bad relocation
	section names.
	(elf64_x86_64_gc_sweep_hook): Sweep dyn_relocs and local_dynrel.
	Reference count possible .plt entries.  Don't deallocate .got and
	.relgot space here.
	(elf64_x86_64_adjust_dynamic_symbol): Handle nocopyreloc.  Don't
	do copy reloc processing for weakdefs.  Remove redundant casts and
	aborts.  Delay setting of vars until needed.  Move creation of
	dynamic symbols and allocation of .plt and .rela.plt to
	allocate_dynrelocs.  Replace BFD_ASSERT with abort.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): New.
	(allocate_dynrelocs): New.
	(readonly_dynrelocs): New.
	(elf64_x86_64_size_dynamic_sections): Call readonly_dynrelocs.
	Allocate space for dyn relocs.  Replace BFD_ASSERT with abort.
	Zero out the dynamic allocated content space.
	(elf64_x86_64_discard_copies): Removed.
	(elf64_x86_64_relocate_section): Make use of dynamic section
	short-cuts.  Localise vars, and delay setting.  Better error
	reporting, replace BFD_ASSERT with abort.  Check
	ELF_LINK_HASH_DEF_DYNAMIC to see if a symbol is not defined in the
	regular object file and tread the weak definition as the normal
	one.  Don't discard relocs for undefweak or undefined symbols and
	check !DEF_REGULAR as well as DEF_DYNAMIC in test for avoided copy
	relocs.
	(elf64_x86_64_finish_dynamic_symbol): Don't copy relocs for
	symbols that have been forced local.  Use same test to decide if
	we can use a relative reloc for got as relocate_section.  Expand
	SHN_UNDEF comment.  Move expressions out of function calls.
	Replace BFD_ASSERT with abort.
	(bfd_elf64_bfd_final_link): Removed.
	(elf_backend_copy_indirect_symbol): Define.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
a22 1
#include "bfdlink.h"
d29 1
a29 1
#define USE_RELA 1
a129 6
static boolean create_got_section
  PARAMS((bfd *, struct bfd_link_info *));
static boolean elf64_x86_64_create_dynamic_sections
  PARAMS((bfd *, struct bfd_link_info *));
static void elf64_x86_64_copy_indirect_symbol
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
d141 1
a141 1
static struct bfd_hash_entry *link_hash_newfunc
a145 4
static boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
d238 4
a241 4
   it decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */
d243 4
a246 1
struct elf64_x86_64_dyn_relocs
d249 4
a252 6
  struct elf64_x86_64_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
a253 3

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
d260 1
a260 1
  struct elf_link_hash_entry elf;
d262 2
a263 2
  /* Track dynamic relocs copied for this symbol.  */
  struct elf64_x86_64_dyn_relocs *dyn_relocs;
d266 1
a266 1
/* x86-64 ELF linker hash table.  */
d270 4
a273 1
  struct elf_link_hash_table elf;
d275 4
a278 8
  /* Short-cuts to get to dynamic linker sections.  */
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
  asection *sdynbss;
  asection *srelbss;
d280 5
a284 3
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
};
d294 1
a294 1
link_hash_newfunc (entry, table, string)
d299 3
d303 7
a309 8
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf64_x86_64_link_hash_entry));
      if (entry == NULL)
	return entry;
    }
d312 4
a315 2
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
d317 1
a317 4
      struct elf64_x86_64_link_hash_entry *eh;

      eh = (struct elf64_x86_64_link_hash_entry *) entry;
      eh->dyn_relocs = NULL;
d320 1
a320 1
  return entry;
d332 2
a333 2
  ret = (struct elf64_x86_64_link_hash_table *) bfd_alloc (abfd, amt);
  if (ret == NULL)
d336 2
a337 1
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc))
d343 1
a343 119
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->sym_sec.abfd = NULL;

  return &ret->elf.root;
}

/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static boolean
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf64_x86_64_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return false;

  htab = elf64_x86_64_hash_table (info);
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  if (!htab->sgot || !htab->sgotplt)
    abort ();

  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
  if (htab->srelgot == NULL
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 3))
    return false;
  return true;
}

/* Create .plt, .rela.plt, .got, .got.plt, .rela.got, .dynbss, and
   .rela.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static boolean
elf64_x86_64_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
{
  struct elf64_x86_64_link_hash_table *htab;

  htab = elf64_x86_64_hash_table (info);
  if (!htab->sgot && !create_got_section (dynobj, info))
    return false;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return false;

  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rela.bss");

  if (!htab->splt || !htab->srelplt || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  return true;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf64_x86_64_copy_indirect_symbol (dir, ind)
     struct elf_link_hash_entry *dir, *ind;
{
  struct elf64_x86_64_link_hash_entry *edir, *eind;

  edir = (struct elf64_x86_64_link_hash_entry *) dir;
  eind = (struct elf64_x86_64_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf64_x86_64_dyn_relocs **pp;
	  struct elf64_x86_64_dyn_relocs *p;

	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf64_x86_64_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  _bfd_elf_link_hash_copy_indirect (dir, ind);
d356 2
a357 2
   calculate needed space in the global offset table, procedure
   linkage table, and dynamic reloc sections.  */
d366 1
a366 1
  struct elf64_x86_64_link_hash_table *htab;
d369 1
d372 2
d379 1
a379 1
  htab = elf64_x86_64_hash_table (info);
d382 1
d384 1
a384 2
  sreloc = NULL;

a391 9

      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler) (_("%s: bad symbol index: %d"),
				 bfd_archive_filename (abfd),
				 r_symndx);
	  return false;
	}

d397 14
d413 1
a414 1
	case R_X86_64_GOTPCREL:
d416 26
d444 12
a459 2
	      bfd_signed_vma *local_got_refcounts;

a460 1
	      local_got_refcounts = elf_local_got_refcounts (abfd);
d473 11
a485 10
	  /* Fall through */

	  //case R_X86_64_GOTPCREL:
	  if (htab->sgot == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!create_got_section (htab->elf.dynobj, info))
		return false;
	    }
a509 2
	case R_X86_64_PC8:
	case R_X86_64_PC16:
d511 2
a512 14
	  if (h != NULL && !info->shared)
	    {
	      /* If this reloc is in a read-only section, we might
		 need a copy reloc.  We can't check reliably at this
		 stage whether the section is read-only, as input
		 sections have not yet been mapped to output sections.
		 Tentatively set the flag for now, and correct in
		 adjust_dynamic_symbol.  */
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;

	      /* We may need a .plt entry if the function this reloc
		 refers to is in a shared lib.  */
	      h->plt.refcount += 1;
	    }
d523 18
a540 35
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library.  We account for that possibility below by
	     storing information in the relocs_copied field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && (((ELF64_R_TYPE (rel->r_info) != R_X86_64_PC8)
		    && (ELF64_R_TYPE (rel->r_info) != R_X86_64_PC16)
		    && (ELF64_R_TYPE (rel->r_info) != R_X86_64_PC32))
		   || (h != NULL
		       && (! info->symbolic
			   || h->root.type == bfd_link_hash_defweak
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (!info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
	    {
	      struct elf64_x86_64_dyn_relocs *p;
	      struct elf64_x86_64_dyn_relocs **head;

	      /* We must copy these reloc types into the output file.
		 Create a reloc section in dynobj and make room for
		 this reloc.  */
a543 1
		  bfd *dynobj;
d552 3
a554 13
		  if (strncmp (name, ".rela", 5) != 0
		      || strcmp (bfd_get_section_name (abfd, sec),
				 name + 5) != 0)
		    {
		      (*_bfd_error_handler)
			(_("%s: bad relocation section name `%s\'"),
			 bfd_archive_filename (abfd), name);
		    }

		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;

		  dynobj = htab->elf.dynobj;
d571 2
a572 1
		  elf_section_data (sec)->sreloc = sreloc;
d575 12
a586 3
	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
d588 4
a591 13
		  head = &((struct elf64_x86_64_link_hash_entry *) h)->dyn_relocs;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */

		  asection *s;
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
		  if (s == NULL)
		    return false;
d593 3
a595 3
		  head = ((struct elf64_x86_64_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
		}
a596 6
	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof *p;
		  p = ((struct elf64_x86_64_dyn_relocs *)
		       bfd_alloc (htab->elf.dynobj, amt));
d598 12
a609 6
		    return false;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
a610 6

	      p->count += 1;
	      if (ELF64_R_TYPE (rel->r_info) == R_X86_64_PC8
		  || ELF64_R_TYPE (rel->r_info) == R_X86_64_PC16
		  || ELF64_R_TYPE (rel->r_info) == R_X86_64_PC32)
		p->pc_count += 1;
a626 3

	default:
	  break;
d640 1
a640 1
     Elf_Internal_Rela *rel;
d680 1
a680 1
     struct bfd_link_info *info;
d690 3
a692 2

  elf_section_data (sec)->local_dynrel = NULL;
d698 7
d716 8
a723 1
	      h->got.refcount -= 1;
d728 9
a736 38
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;

      case R_X86_64_8:
      case R_X86_64_16:
      case R_X86_64_32:
      case R_X86_64_64:
      case R_X86_64_32S:
      case R_X86_64_PC8:
      case R_X86_64_PC16:
      case R_X86_64_PC32:
	r_symndx = ELF64_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf64_x86_64_link_hash_entry *eh;
	    struct elf64_x86_64_dyn_relocs **pp;
	    struct elf64_x86_64_dyn_relocs *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];

	    if (!info->shared && h->plt.refcount > 0)
	      h->plt.refcount -= 1;

	    eh = (struct elf64_x86_64_link_hash_entry *) h;

	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
		{
		  if (ELF64_R_TYPE (rel->r_info) == R_X86_64_PC8
		      || ELF64_R_TYPE (rel->r_info) == R_X86_64_PC16
		      || ELF64_R_TYPE (rel->r_info) == R_X86_64_PC32)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
		}
a739 1

d768 1
a768 3
  struct elf64_x86_64_link_hash_table *htab;
  struct elf64_x86_64_link_hash_entry * eh;
  struct elf64_x86_64_dyn_relocs *p;
d772 13
d791 4
a794 6
      if (h->plt.refcount <= 0
	  || (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
	      && h->root.type != bfd_link_hash_undefweak
	      && h->root.type != bfd_link_hash_undefined))
d803 8
d813 36
a851 5
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_X86_64_PC32 reloc to a non-function sym in
       check_relocs.  We can't decide accurately between function and
       non-function syms in check-relocs;  Objects loaded later in
       the link may change h->type.  So fix it now.  */
a880 23
  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return true;
    }

  eh = (struct elf64_x86_64_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      s = p->sec->output_section;
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	break;
    }

  /* If we didn't find any dynamic relocs in read-only sections, then
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return true;
    }

d891 2
a892 1
  htab = elf64_x86_64_hash_table (info);
d896 2
a897 1
     runtime process image. */
d900 5
a904 1
      htab->srelbss->_raw_size += sizeof (Elf64_External_Rela);
a917 1
  s = htab->sdynbss;
d919 1
a919 1
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
d921 1
a921 1
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
a934 217
/* This is the condition under which elf64_x86_64_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf64_x86_64_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
  ((DYN)								\
   && ((INFO)->shared							\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static boolean
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct bfd_link_info *info;
  struct elf64_x86_64_link_hash_table *htab;
  struct elf64_x86_64_link_hash_entry *eh;
  struct elf64_x86_64_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return true;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  info = (struct bfd_link_info *) inf;
  htab = elf64_x86_64_hash_table (info);

  if (htab->elf.dynamic_sections_created
      && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
	    return false;
	}

      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
	{
	  asection *s = htab->splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_ENTRY_SIZE;

	  h->plt.offset = s->_raw_size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->_raw_size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->sgotplt->_raw_size += GOT_ENTRY_SIZE;

	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->srelplt->_raw_size += sizeof (Elf64_External_Rela);
	}
      else
	{
	  h->plt.offset = (bfd_vma) -1;
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
    }

  if (h->got.refcount > 0)
    {
      asection *s;
      boolean dyn;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	{
	  if (! bfd_elf64_link_record_dynamic_symbol (info, h))
	    return false;
	}

      s = htab->sgot;
      h->got.offset = s->_raw_size;
      s->_raw_size += GOT_ENTRY_SIZE;
      dyn = htab->elf.dynamic_sections_created;
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
	htab->srelgot->_raw_size += sizeof (Elf64_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

  eh = (struct elf64_x86_64_link_hash_entry *) h;
  if (eh->dyn_relocs == NULL)
    return true;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
	{
	  struct elf64_x86_64_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}
    }
  else
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
	      || (htab->elf.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
	    {
	      if (! bfd_elf64_link_record_dynamic_symbol (info, h))
		return false;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;
      sreloc->_raw_size += p->count * sizeof (Elf64_External_Rela);
    }

  return true;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static boolean
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
{
  struct elf64_x86_64_link_hash_entry *eh;
  struct elf64_x86_64_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

  eh = (struct elf64_x86_64_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return false;
	}
    }
  return true;
}

a941 1
  struct elf64_x86_64_link_hash_table *htab;
d944 1
a945 1
  bfd *ibfd;
d947 2
a948 4
  htab = elf64_x86_64_hash_table (info);
  dynobj = htab->elf.dynobj;
  if (dynobj == NULL)
    abort ();
d950 1
a950 1
  if (htab->elf.dynamic_sections_created)
d956 1
a956 2
	  if (s == NULL)
	    abort ();
d961 11
d973 17
a989 9
  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srel;
d991 1
a991 1
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
d994 6
a999 1
      for (s = ibfd->sections; s != NULL; s = s->next)
d1001 7
a1007 6
	  struct elf64_x86_64_dyn_relocs *p;

	  for (p = *((struct elf64_x86_64_dyn_relocs **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
d1009 2
a1010 16
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srel = elf_section_data (p->sec)->sreloc;
		  srel->_raw_size += p->count * sizeof (Elf64_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;

		}
d1013 1
a1013 11

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      s = htab->sgot;
      srel = htab->srelgot;
      for (; local_got < end_local_got; ++local_got)
d1015 1
a1015 1
	  if (*local_got > 0)
d1017 10
a1026 4
	      *local_got = s->_raw_size;
	      s->_raw_size += GOT_ENTRY_SIZE;
	      if (info->shared)
		srel->_raw_size += sizeof (Elf64_External_Rela);
d1029 3
a1031 3
	    *local_got = (bfd_vma) -1;
	}
    }
d1033 4
a1036 18
  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->splt
	  || s == htab->sgot
	  || s == htab->sgotplt)
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
d1038 1
a1038 10
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
	{
	  if (s->_raw_size != 0 && s != htab->srelplt)
	    relocs = true;

	  /* We use the reloc_count field as a counter if we need
	     to copy relocs into the output file.  */
	  s->reloc_count = 0;
	}
      else
d1044 1
a1044 1
      if (s->_raw_size == 0)
a1045 10
	  /* If we don't need this section, strip it from the
	     output file.  This is mostly to handle .rela.bss and
	     .rela.plt.  We must create both sections in
	     create_dynamic_sections, because they must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */

d1056 1
a1056 1
      if (s->contents == NULL)
d1060 1
a1060 1
  if (htab->elf.dynamic_sections_created)
d1076 1
a1076 1
      if (htab->splt->_raw_size != 0)
d1091 1
d1093 4
a1096 11
	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
				    (PTR) info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (!add_dynamic_entry (DT_TEXTREL, 0))
		return false;
	    }
d1104 34
d1152 1
a1152 1
  struct elf64_x86_64_link_hash_table *htab;
d1156 4
a1159 1
  Elf_Internal_Rela *rel;
d1162 1
a1162 1
  htab = elf64_x86_64_hash_table (info);
d1167 8
a1174 1
  rel = relocs;
d1176 1
a1176 1
  for (; rel < relend; rel++)
a1183 1
      bfd_vma off;
a1184 1
      boolean unresolved_reloc;
d1186 1
d1188 1
a1188 1
      r_type = ELF64_R_TYPE (rel->r_info);
d1193 1
a1193 1
      if (r_type < 0 || r_type >= R_X86_64_max)
d1198 1
a1198 1
      howto = x86_64_elf_howto_table + r_type;
d1200 1
a1200 1
      r_symndx = ELF64_R_SYM (rel->r_info);
d1214 1
a1214 1
		  rel->r_addend += sec->output_offset + sym->st_value;
a1224 1
      unresolved_reloc = false;
d1229 1
a1229 2

	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
a1236 1

d1241 28
a1268 1
	      if (sec->output_section == NULL)
d1270 11
a1280 5
		  /* Set a flag that will be cleared later if we find a
		     relocation value for this symbol.  output_section
		     is typically NULL for symbols satisfied by a shared
		     library.  */
		  unresolved_reloc = true;
d1299 1
a1299 1
		      input_section, rel->r_offset,
d1306 1
d1316 1
a1316 2
	  if (htab->sgot == NULL)
	    abort ();
d1320 2
a1321 1
	      boolean dyn;
d1323 1
a1323 4
	      off = h->got.offset;
	      dyn = htab->elf.dynamic_sections_created;

	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
d1325 1
a1325 3
		      && (info->symbolic
			  || h->dynindx == -1
			  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
d1344 1
a1344 1
				  htab->sgot->contents + off);
d1348 2
d1351 1
a1351 1
		unresolved_reloc = false;
d1355 4
a1358 2
	      if (local_got_offsets == NULL)
		abort ();
d1369 1
a1369 2
		  bfd_put_64 (output_bfd, relocation,
			      htab->sgot->contents + off);
a1374 1
		      Elf64_External_Rela *loc;
d1378 2
a1379 3
		      srelgot = htab->srelgot;
		      if (srelgot == NULL)
			abort ();
d1381 2
a1382 2
		      outrel.r_offset = (htab->sgot->output_section->vma
					 + htab->sgot->output_offset
d1386 5
a1390 3
		      loc = (Elf64_External_Rela *) srelgot->contents;
		      loc += srelgot->reloc_count++;
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
d1395 5
a1401 7
	  if (off >= (bfd_vma) -2)
	    abort ();

	  relocation = htab->sgot->output_offset + off;
	  if (r_type == R_X86_64_GOTPCREL)
	    relocation += htab->sgot->output_section->vma;

d1413 1
a1413 2
	  if (h->plt.offset == (bfd_vma) -1
	      || htab->splt == NULL)
d1421 2
a1422 2
	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
a1423 1
	  unresolved_reloc = false;
d1429 5
d1440 3
a1442 27

	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
	    break;

	  if ((info->shared
	       && ((r_type != R_X86_64_PC8
		    && r_type != R_X86_64_PC16
		    && r_type != R_X86_64_PC32)
		   || (h != NULL
		       && h->dynindx != -1
		       && (! info->symbolic
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
	      || (!info->shared
		  && h != NULL
		  && h->dynindx != -1
		  && (h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && (((h->elf_link_hash_flags
			& ELF_LINK_HASH_DEF_DYNAMIC) != 0
		       && (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      || h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined)))
a1445 2
	      asection *sreloc;
	      Elf64_External_Rela *loc;
d1451 20
d1476 1
a1476 1
					 rel->r_offset);
a1486 1

d1490 1
a1490 6
		       && h->dynindx != -1
		       && (r_type == R_X86_64_PC8
			   || r_type == R_X86_64_PC16
			   || r_type == R_X86_64_PC32
			   || !info->shared
			   || !info->symbolic
d1494 1
d1496 1
a1496 1
		  outrel.r_addend = rel->r_addend;
d1500 39
a1538 4
		  /* This symbol is local, or marked to become local.  */
		  relocate = true;
		  outrel.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
		  outrel.r_addend = relocation + rel->r_addend;
d1541 5
a1545 7
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();

	      loc = (Elf64_External_Rela *) sreloc->contents;
	      loc += sreloc->reloc_count++;
	      bfd_elf64_swap_reloca_out (output_bfd, &outrel, loc);
a1560 16
      /* FIXME: Why do we allow debugging sections to escape this error?
	 More importantly, why do we not emit dynamic relocs for
	 R_386_32 above in debugging sections (which are ! SEC_ALLOC)?
	 If we had emitted the dynamic reloc, we could remove the
	 fudge here.  */
      if (unresolved_reloc
	  && !(info->shared
	       && (input_section->flags & SEC_DEBUGGING) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
	(*_bfd_error_handler)
	  (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	   bfd_archive_filename (input_bfd),
	   bfd_get_section_name (input_bfd, input_section),
	   (long) rel->r_offset,
	   h->root.root.string);

d1562 2
a1563 2
				    contents, rel->r_offset,
				    relocation, rel->r_addend);
d1567 1
a1567 5
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
d1569 25
a1593 25
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return false;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  if (r == bfd_reloc_overflow)
	    {

	      if (! ((*info->callbacks->reloc_overflow)
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
		return false;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
		 (long) rel->r_offset, name, (int) r);
	      return false;
d1611 1
a1611 1
  struct elf64_x86_64_link_hash_table *htab;
d1613 1
a1613 1
  htab = elf64_x86_64_hash_table (info);
d1617 3
a1622 1
      Elf64_External_Rela *loc;
d1627 6
a1632 5
      if (h->dynindx == -1
	  || htab->splt == NULL
	  || htab->sgotplt == NULL
	  || htab->srelplt == NULL)
	abort ();
d1646 1
a1646 1
      memcpy (htab->splt->contents + h->plt.offset, elf64_x86_64_plt_entry,
d1655 2
a1656 2
		      (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d1658 2
a1659 2
		       - htab->splt->output_section->vma
		       - htab->splt->output_offset
d1662 1
a1662 1
		  htab->splt->contents + h->plt.offset + 2);
d1665 1
a1665 1
		  htab->splt->contents + h->plt.offset + 7);
d1668 1
a1668 1
		  htab->splt->contents + h->plt.offset + 12);
d1672 1
a1672 2
      bfd_put_64 (output_bfd, (htab->splt->output_section->vma
			       + htab->splt->output_offset
d1674 1
a1674 1
		  htab->sgotplt->contents + got_offset);
d1677 2
a1678 2
      rela.r_offset = (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d1682 3
a1684 2
      loc = (Elf64_External_Rela *) htab->srelplt->contents + plt_index;
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
d1689 1
a1689 4
	     the .plt section.  Leave the value alone.  This is a clue
	     for the dynamic linker, to make function pointer
	     comparisons work between an application and shared
	     library.  */
d1691 7
d1703 2
a1705 1
      Elf64_External_Rela *loc;
d1710 3
a1712 2
      if (htab->sgot == NULL || htab->srelgot == NULL)
	abort ();
d1714 2
a1715 2
      rela.r_offset = (htab->sgot->output_section->vma
		       + htab->sgot->output_offset
d1723 4
a1726 5
      if (info->shared
	  && (info->symbolic
	      || h->dynindx == -1
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d1737 1
a1737 2
	  bfd_put_64 (output_bfd, (bfd_vma) 0,
		      htab->sgot->contents + h->got.offset);
d1742 4
a1745 3
      loc = (Elf64_External_Rela *) htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++;
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
d1750 1
a1751 1
      Elf64_External_Rela *loc;
d1755 7
a1761 5
      if (h->dynindx == -1
	  || (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	  || htab->srelbss == NULL)
	abort ();
d1768 4
a1771 3
      loc = (Elf64_External_Rela *) htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++;
      bfd_elf64_swap_reloca_out (output_bfd, &rela, loc);
a1781 20
/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
elf64_x86_64_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF64_R_TYPE (rela->r_info))
    {
    case R_X86_64_RELATIVE:
      return reloc_class_relative;
    case R_X86_64_JUMP_SLOT:
      return reloc_class_plt;
    case R_X86_64_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

a1788 1
  struct elf64_x86_64_link_hash_table *htab;
d1791 1
d1793 4
a1796 2
  htab = elf64_x86_64_hash_table (info);
  dynobj = htab->elf.dynobj;
d1799 1
a1799 1
  if (htab->elf.dynamic_sections_created)
d1801 1
d1804 1
a1804 2
      if (sdyn == NULL || htab->sgot == NULL)
	abort ();
d1811 1
d1822 2
a1823 2
	      dyn.d_un.d_ptr = htab->sgot->output_section->vma;
	      break;
d1826 1
a1826 2
	      dyn.d_un.d_ptr = htab->srelplt->output_section->vma;
	      break;
d1828 4
a1831 6
	    case DT_PLTRELSZ:
	      s = htab->srelplt->output_section;
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d1835 8
a1842 8
	      /* The procedure linkage table relocs (DT_JMPREL) should
		 not be included in the overall relocs (DT_RELA).
		 Therefore, we override the DT_RELASZ entry here to
		 make it not include the JMPREL relocs.  Since the
		 linker script arranges for .rela.plt to follow all
		 other relocation sections, we don't have to worry
		 about changing the DT_RELA entry.  */
	      if (htab->srelplt != NULL)
d1844 3
a1846 5
		  s = htab->srelplt->output_section;
		  if (s->_cooked_size != 0)
		    dyn.d_un.d_val -= s->_cooked_size;
		  else
		    dyn.d_un.d_val -= s->_raw_size;
d1849 7
a1856 1

d1860 4
a1863 2
      /* Fill in the special first entry in the procedure linkage table.  */
      if (htab->splt && htab->splt->_raw_size > 0)
d1866 1
a1866 2
	  memcpy (htab->splt->contents, elf64_x86_64_plt0_entry,
		  PLT_ENTRY_SIZE);
d1870 2
a1871 2
		      (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d1873 2
a1874 2
		       - htab->splt->output_section->vma
		       - htab->splt->output_offset
d1876 1
a1876 1
		      htab->splt->contents + 2);
d1880 2
a1881 2
		      (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d1883 2
a1884 2
		       - htab->splt->output_section->vma
		       - htab->splt->output_offset
d1886 1
a1886 1
		      htab->splt->contents + 8);
a1887 2
	  elf_section_data (htab->splt->output_section)->this_hdr.sh_entsize =
	    PLT_ENTRY_SIZE;
d1889 3
d1894 3
a1896 1
  if (htab->sgotplt)
d1898 10
a1907 15
      /* Fill in the first three entries in the global offset table.  */
      if (htab->sgotplt->_raw_size > 0)
	{
	  /* Set the first entry in the global offset table to the address of
	     the dynamic section.  */
	  if (sdyn == NULL)
	    bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents);
	  else
	    bfd_put_64 (output_bfd,
			sdyn->output_section->vma + sdyn->output_offset,
			htab->sgotplt->contents);
	  /* Write GOT[1] and GOT[2], needed for the dynamic linker.  */
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents + GOT_ENTRY_SIZE);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents + GOT_ENTRY_SIZE*2);
	}
d1909 2
a1910 3
      elf_section_data (htab->sgotplt->output_section)->this_hdr.sh_entsize =
	GOT_ENTRY_SIZE;
    }
d1915 16
d1948 1
d1955 3
a1957 3
#define elf_backend_copy_indirect_symbol    elf64_x86_64_copy_indirect_symbol
#define elf_backend_create_dynamic_sections elf64_x86_64_create_dynamic_sections
#define elf_backend_finish_dynamic_sections elf64_x86_64_finish_dynamic_sections
a1960 1
#define elf_backend_reloc_type_class	    elf64_x86_64_reloc_type_class
d1964 1
@


1.34.2.5
log
@Merge from mainline
@
text
@a1496 3
  if (info->relocateable)
    return true;

d1527 1
a1528 1
      howto = x86_64_elf_howto_table + r_type;
d1530 21
a2232 1
#define elf_backend_rela_normal		    1
@


1.33
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d669 1
a669 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
@


1.32
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d1476 5
a1480 15
	      if (elf_section_data (input_section)->stab_info == NULL)
		outrel.r_offset = rela->r_offset;
	      else
		{
		  bfd_vma off;

		  off = (_bfd_stab_section_offset
			 (output_bfd, &elf_hash_table (info)->stab_info,
			  input_section,
			  &elf_section_data (input_section)->stab_info,
			  rela->r_offset));
		  if (off == (bfd_vma) -1)
		    skip = true;
		  outrel.r_offset = off;
		}
@


1.31
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d1232 1
a1232 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.30
log
@	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Merge dyn_reloc
	counts for aliases instead of aborting.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.

	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Set plt.offset
	to -1 for non-function symbols.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Refer to
	plt.offset instead of plt.refcount when setting to -1.
@
text
@d1445 3
a1447 1
	  if (info->shared && (input_section->flags & SEC_ALLOC) != 0)
@


1.29
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): Add init_refcount.
	(struct elf_backend_data): Add can_refcount.
	* elf.c (_bfd_elf_link_hash_newfunc): Get rid of a few casts.  Set
	got.refcount and plt.refcount from init_refcount.
	(_bfd_elf_link_hash_table_init): Set up init_refcount.
	(_bfd_elf_link_hash_copy_indirect): Reference got/plt.refcount
	rather than got/plt.offset, and test for <= 0 rather than -1.
	* elflink.h (size_dynamic_sections): Set init_refcount to -1.
	* elfxx-target.h (elf_backend_can_refcount): Define.
	(elfNN_bed): Init can_refcount.
	* linker.c (_bfd_link_hash_newfunc): Get rid of a few casts.
	(_bfd_generic_link_hash_newfunc): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-hppa.c (elf32_hppa_check_relocs): Modify for refcounts
	starting from zero.
	(elf32_hppa_copy_indirect_symbol): Make static to agree with
	prototype.
	(elf_backend_can_refcount): Define.
	* elf32-i386.c (elf_i386_check_relocs): Modify for refcounts
	starting from zero.
	(allocate_dynrelocs): Set plt/got.offset rather than *.refcount.
	(elf_i386_finish_dynamic_symbol): Expand SHN_UNDEF comment.
	(elf_i386_finish_dynamic_sections): Use local var so line < 80 chars.
	(elf_backend_can_refcount): Define.
	(elf_i386_copy_indirect_symbol): Make static to agree with
	prototype.  Formatting fix.
	* elf32-m68k.c (elf_m68k_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-ppc.c (ppc_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
@
text
@d857 2
@


1.28
log
@	* elf64-x86-64.c (elf64_x86_64_reloc_type_lookup): Don't map bfd
	reloc code using x86_64_reloc_map.
@
text
@d444 1
a444 1
	      if (h->got.refcount == -1)
a445 2
		  h->got.refcount = 1;

d456 1
a456 2
	      else
		h->got.refcount += 1;
d468 1
a468 1
					 bfd_alloc (abfd, size));
a471 1
		  memset (local_got_refcounts, -1, (size_t) size);
d473 1
a473 1
	      if (local_got_refcounts[r_symndx] == -1)
a474 2
		  local_got_refcounts[r_symndx] = 1;

d484 1
a484 2
	      else
		local_got_refcounts[r_symndx] += 1;
d502 1
a502 4
	  if (h->plt.refcount == -1)
	    h->plt.refcount = 1;
	  else
	    h->plt.refcount += 1;
d1952 1
@


1.27
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d170 1
a170 2
	return &x86_64_elf_howto_table[(int)
				       x86_64_reloc_map[i].elf_reloc_val];
@


1.26
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d156 2
a157 1
static enum elf_reloc_type_class elf64_x86_64_reloc_type_class PARAMS ((int));
d1940 2
a1941 2
elf64_x86_64_reloc_type_class (type)
     int type;
d1943 1
a1943 1
  switch (type)
@


1.25
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d1292 1
a1292 1
		     bfd_get_filename (input_bfd), h->root.root.string,
@


1.24
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1303 3
a1305 1
	  else if (info->shared && !info->symbolic && !info->no_undefined
@


1.23
log
@	* elf64-x86-64.c (elf64_x86_64_check_relocs): Set DF_TEXTREL if
	the reloc is against read-only section.
	(elf64_x86_64_size_dynamic_sections): Use DF_TEXTREL flag instead
	of looking up section names for DT_TEXTREL.
	(elf64_x86_64_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
@
text
@d101 1
a101 1
static CONST struct elf_reloc_map x86_64_reloc_map[] =
d330 1
d332 1
a332 2
  ret = ((struct elf64_x86_64_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf64_x86_64_link_hash_table)));
d466 1
a466 1
		  size_t size;
d468 2
a469 1
		  size = symtab_hdr->sh_info * sizeof (bfd_signed_vma);
d475 1
a475 1
		  memset (local_got_refcounts, -1, size);
d610 1
a610 1
			   bfd_alloc (dynobj, sizeof *p));
d1081 3
d1086 1
a1086 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_DEBUG, 0))
d1092 4
a1095 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_JMPREL, 0))
d1101 3
a1103 4
	  if (! bfd_elf64_add_dynamic_entry (info, DT_RELA, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_RELASZ, 0)
	      || ! bfd_elf64_add_dynamic_entry (info, DT_RELAENT,
						sizeof (Elf64_External_Rela)))
d1109 1
a1109 1
	  if (! bfd_elf64_add_dynamic_entry (info, DT_TEXTREL, 0))
d1113 1
d1528 1
a1528 1
		      long indx;
d1540 1
a1540 1
			indx = 0;
d1551 2
a1552 2
			  indx = elf_section_data (osec)->dynindx;
			  BFD_ASSERT (indx > 0);
d1556 1
a1556 1
		      outrel.r_info = ELF64_R_INFO (indx, r_type);
d1737 1
a1737 1
		       + (h->got.offset &~ 1));
@


1.22
log
@	* elf64-x86-64.c (elf64_x86_64_elf_object_p): Make static.
	Add prototypes where needed.
@
text
@d156 1
d580 2
d952 1
a952 1
     bfd *output_bfd;
a958 1
  boolean reltext;
d998 1
a998 1
  plt = relocs = reltext = false;
a1042 4
	      asection *target;

	      /* Remember whether there are any reloc sections other
		 than .rela.plt.  */
d1044 1
a1044 18
		{
		  const char *outname;

		  relocs = true;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rela.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 5);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = true;
		}
d1104 1
a1104 1
      if (reltext)
a1107 1
	  info->flags |= DF_TEXTREL;
d1932 17
d1980 1
@


1.21
log
@	* elf64-x86-64.c (elf64_x86_64_relocate_section): Fix linking of
	shared libraries.
@
text
@d129 11
d345 1
a345 1
boolean
@


1.20
log
@(elf64_x86_64_relocate_section): Fix creation of dynamic symbols.
@
text
@d1445 3
a1447 1
	  if (h == NULL)
d1456 1
a1456 9
	  if (info->shared
	      && (input_section->flags & SEC_ALLOC) != 0
	      && ((r_type != R_X86_64_PC8
		   && r_type != R_X86_64_PC16
		   && r_type != R_X86_64_PC32)
		  || (! info->symbolic
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))

d1560 1
a1560 1
 		      relocate = false;
d1562 2
a1563 2
 		      outrel.r_addend = relocation + rela->r_addend;
 		    }
@


1.19
log
@2001-06-07  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Add an
	assertion.
	(elf64_x86_64_check_relocs): Fix VTENTRY relocation; set an
	alignment of 8 for .rela sections; handle further relocations.
@
text
@d1442 6
a1451 3
	case R_X86_64_PC8:
	case R_X86_64_PC16:
	case R_X86_64_PC32:
d1459 4
a1462 5
		  || (h != NULL
		      && h->dynindx != -1
		      && (! info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1517 6
a1522 3
	      else if ((r_type == R_X86_64_PC8)
		       || (r_type == R_X86_64_PC16)
		       || (r_type == R_X86_64_PC32))
d1524 1
a1524 1
		  BFD_ASSERT (h != NULL && h->dynindx != -1);
d1531 1
a1531 6
		  /* h->dynindx may be -1 if this symbol was marked to
		     become local.  */
		  if (h == NULL
		      || ((info->symbolic || h->dynindx == -1)
			  && (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) != 0))
d1539 32
a1570 5
		      BFD_ASSERT (h->dynindx != -1);
		      relocate = false;
		      outrel.r_info = ELF64_R_INFO (h->dynindx, R_X86_64_32);
		      outrel.r_addend = relocation + rela->r_addend;
		    }
@


1.18
log
@	* elf64-x86-64.c (elf64_x86_64_relocate_section): Add PC8
	relocation, small reformatting.
@
text
@d495 1
d497 1
a497 4
	    {
	      h->plt.refcount = 1;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	    }
d502 3
a505 1
	case R_X86_64_32:
d527 3
a529 1
	      && (ELF64_R_TYPE (rel->r_info) != R_X86_64_PC32
d565 1
a565 1
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
d578 4
a581 1
	      if (h != NULL && ELF64_R_TYPE (rel->r_info) == R_X86_64_PC32)
d619 1
a619 1
	  if (!_bfd_elf64_gc_record_vtentry (abfd, sec, h, rel->r_offset))
d1733 1
@


1.17
log
@	* elf64-x86-64.c (elf64_x86_64_check_relocs): Handle R_X86_64_64.
	(elf64_x86_64_relocate_section): Likewise.
@
text
@d1267 7
a1273 6
		      && ( r_type == R_X86_64_8 ||
			   r_type == R_X86_64_16 ||
                           r_type == R_X86_64_32 ||
			   r_type == R_X86_64_64 ||
                           r_type == R_X86_64_PC16 ||
			   r_type == R_X86_64_PC32)
d1444 1
a1444 1
	  /* FIXME: The abi says the linker should make sure the value is
d1448 2
a1449 1
	      && ((r_type != R_X86_64_PC8 && r_type != R_X86_64_PC16
d1510 2
a1511 1
	      else if ((r_type == R_X86_64_PC8) || (r_type == R_X86_64_PC16)
@


1.16
log
@	* elf64-x86-64.c (elf64_86_64_size_info): Remove, we can use the
	generic version since we want a hashsize of 4.
	(elf_backend_size_info): Likewise.
@
text
@d504 1
d1439 1
@


1.15
log
@	* elf64-x86-64.c (elf64_x86_64_relocate_section): Correct test for
	R_X86_64_GOTPCREL, don't use assignments instead of comparisons.
@
text
@a1908 35
/*
 * Why was the hash table entry size definition changed from
 * ARCH_SIZE/8 to 4? This breaks the 64 bit dynamic linker and
 * this is the only reason for the elf64_x86_64_size_info structure.
 */

const struct elf_size_info elf64_86_64_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_External_Rel),
  sizeof (Elf64_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  8,		/* hash-table entry size */
  1,		/* internal relocations per external relocations */
  64,		/* arch_size */
  8,		/* file_align */
  ELFCLASS64, EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  bfd_elf64_write_relocs,
  bfd_elf64_swap_symbol_out,
  bfd_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  NULL,
  NULL,
  NULL,
  NULL
};

a1913 2

#define elf_backend_size_info		    elf64_86_64_size_info
@


1.14
log
@
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Only swap
	out handled entries.
	(elf64_x86_64_finish_dynamic_symbol): Set up GOT entries.
	(elf64_x86_64_relocate_section): Fix GOTPCREL calculation.
	(elf64_x86_64_relocate_section): Merge entries for GOTPCREL and
	GOT32.
@
text
@d1253 4
a1256 5
	      if (r_type == R_X86_64_GOTPCREL
		  || (r_type = R_X86_64_PLT32
		      && splt != NULL
		      && h->plt.offset != (bfd_vma) -1)
		  || (r_type = R_X86_64_GOT32
d1410 1
@


1.13
log
@2001-04-23  Bo Thorsen  <bo@@suse.de>

	* x86-64.h: Add vtable support.

2001-04-23  Bo Thorsen  <bo@@suse.de>

	* elf64-x86-64.c: Add c++ vtable hack.
	Small whitespace and comment changes.
@
text
@d1324 2
d1358 4
a1361 1
	      relocation = sgot->output_offset + off;
d1406 2
a1407 55
	      relocation = sgot->output_offset + off;
	    }

	  break;

	case R_X86_64_GOTPCREL:
	  /* Use global offset table as symbol value.  */

	  BFD_ASSERT (sgot != NULL);
	  if (h != NULL)
	    {
	      bfd_vma off = h->got.offset;
	      BFD_ASSERT (off != (bfd_vma) -1);

	      if (! elf_hash_table (info)->dynamic_sections_created
		  || (info->shared
		      && (info->symbolic || h->dynindx == -1)
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
		{
		  /* This is actually a static link, or it is a -Bsymbolic
		     link and the symbol is defined locally, or the symbol
		     was forced to be local because of a version file.	We
		     must initialize this entry in the global offset table.
		     Since the offset must always be a multiple of 8, we
		     use the least significant bit to record whether we
		     have initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.	This is
		     done in the finish_dynamic_symbol routine.	 */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_64 (output_bfd, relocation,
				  sgot->contents + off);
		      h->got.offset |= 1;
		    }
		}
	      relocation = sgot->output_offset + off;
	    }
	  else
	    {
	      bfd_vma off;

	      BFD_ASSERT (local_got_offsets != NULL
			  && local_got_offsets[r_symndx] != (bfd_vma) -1);

	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 8.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.	 */
	      if ((off & 1) != 0)
		off &= ~1;
d1409 1
a1409 29
		{
		  bfd_put_64 (output_bfd, relocation, sgot->contents + off);

		  if (info->shared)
		    {
		      asection *srelgot;
		      Elf_Internal_Rela outrel;

		      /* We need to generate a R_X86_64_RELATIVE reloc
			 for the dynamic linker.  */
		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (srelgot != NULL);

		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset
					 + off);
		      outrel.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
		      outrel.r_addend = relocation;
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						 (((Elf64_External_Rela *)
						   srelgot->contents)
						  + srelgot->reloc_count));
		      ++srelgot->reloc_count;
		    }

		  local_got_offsets[r_symndx] |= 1;
		}

	      relocation = sgot->output_section->vma + off;
d1696 46
d1813 1
a1813 1
	      break;
a1850 1

@


1.12
log
@2001-04-19  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_plt0_entry): Fix instructions.
	(elf64_x86_64_plt_entry): Likewise.
	(elf64_x86_64_finish_dynamic_sections): Fix PLT0 generation.
	(elf64_x86_64_finish_dynamic_symbol): Fix PLT generation.
@
text
@d40 2
a41 1
	bfd_elf_generic_reloc, "R_X86_64_NONE",	false, 0x00000000, 0x00000000, false),
d43 2
a44 1
	bfd_elf_generic_reloc, "R_X86_64_64", false, MINUS_ONE, MINUS_ONE, false),
d46 2
a47 1
	bfd_elf_generic_reloc, "R_X86_64_PC32", false, 0xffffffff, 0xffffffff, true),
d49 2
a50 1
	bfd_elf_generic_reloc, "R_X86_64_GOT32", false, 0xffffffff, 0xffffffff, false),
d52 2
a53 1
	bfd_elf_generic_reloc, "R_X86_64_PLT32", false, 0xffffffff, 0xffffffff, true),
d55 2
a56 1
	bfd_elf_generic_reloc, "R_X86_64_COPY", false, 0xffffffff, 0xffffffff, false),
d58 2
a59 1
	bfd_elf_generic_reloc, "R_X86_64_GLOB_DAT", false, MINUS_ONE, MINUS_ONE, false),
d61 2
a62 1
	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", false, MINUS_ONE, MINUS_ONE, false),
d64 2
a65 1
	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", false, MINUS_ONE, MINUS_ONE, false),
d67 2
a68 1
	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL", false, 0xffffffff, 0xffffffff, true),
d70 2
a71 1
	bfd_elf_generic_reloc, "R_X86_64_32", false, 0xffffffff, 0xffffffff, false),
d73 2
a74 1
	bfd_elf_generic_reloc, "R_X86_64_32S", false, 0xffffffff, 0xffffffff, false),
d82 10
a91 1
	bfd_elf_generic_reloc, "R_X86_64_PC8", false, 0xff, 0xff, true)
d119 2
d171 1
a171 1
  unsigned r_type;
d174 11
a184 2
  BFD_ASSERT (r_type < (unsigned int) R_X86_64_max);
  cache_ptr->howto = &x86_64_elf_howto_table[r_type];
d575 1
a575 2
	      if (h != NULL
		  && ELF64_R_TYPE (rel->r_info) == R_X86_64_PC32)
d602 14
d635 1
a635 1
      switch (h->root.type)
d637 10
a646 3
	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
	  return h->root.u.def.section;
d648 2
a649 2
	case bfd_link_hash_common:
	  return h->root.u.c.p->section;
d651 3
a653 2
	default:
	  break;
d1152 1
a1152 1
			     contents, relocs, local_syms, local_sections)
d1199 3
d1713 1
a1713 1
	 bytes. The first three are reserved.  */
@


1.11
log
@2001-03-07  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_relocate_section): Fix handling of
	some relocation values.
@
text
@d176 3
a178 3
  0xff, 0xb3, 8, 0, 0, 0,	/* pushq GOT+8(%rip) */
  0xff, 0xa3, 16, 0, 0, 0,	/* jmp GOT+16(%rip) */
  0, 0, 0, 0			/* pad out to 16 bytes.	 */
d185 1
a185 1
  0xff, 0xa3,	/* jmp *name@@GOTPC(%rip) */
d187 1
a187 1
  0x68,	/* pushq immediate */
d1667 13
a1679 2
      bfd_put_64 (output_bfd, got_offset, splt->contents + h->plt.offset + 2);
      bfd_put_64 (output_bfd, plt_index * sizeof (Elf64_External_Rela),
d1681 2
a1682 1
      bfd_put_64 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE),
d1685 2
a1686 1
      /* Fill in the entry in the global offset table.	*/
d1763 2
d1834 1
d1836 21
a1864 2
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
d1873 1
a1873 1
      /* Write GOT[1] and GOT[2], needed for the linker.  */
@


1.10
log
@2001-02-28  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_relocate_section): Add relocation
	to addend.
@
text
@d1197 35
a1231 1
	      if (sec->output_section == NULL)
@


1.9
log
@2001-02-26  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (x86_64_elf_howto_table): Fix order of entries.
@
text
@d1498 1
a1498 1
		  outrel.r_addend = rela->r_addend;
d1511 1
a1511 1
		      outrel.r_addend = rela->r_addend;
d1518 1
a1518 1
		      outrel.r_addend = rela->r_addend;
@


1.8
log
@2001-02-20  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Don't make
	PLT entries that could serve as a definition for a weak symbol.
@
text
@d53 2
a56 2
  HOWTO(R_X86_64_JUMP_SLOT, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", false, MINUS_ONE, MINUS_ONE, false),
@


1.7
log
@2001-02-14  Bo Thorsen  <bo@@suse.de>

	* elf64-x86-64.c: Small formatting fixes and rearrangements of code.
	(elf64_86_64_size_info): Struct added to fix a problem
	with the hashtable string entries.
	(elf64_x86_64_adjust_dynamic_symbol): Add generation of .got.plt.
	(elf64_x86_64_size_dynamic_sections): A FIXME removed.
	(elf64_x86_64_size_dynamic_sections): Fix a dynamic entry and
	remove the FIXME for this.
	(elf64_x86_64_adjust_dynamic_symbol): Fix check for unneeded .plt
	section. Also removed the FIXME for it.
	(x86_64_elf_howto_table): Use bfd_elf_generic_reloc.
	(ELF_DYNAMIC_INTERPRETER): Fix the name of the dynamic linker.
	(elf64_x86_64_finish_dynamic_sections): Enable .got.plt writing.
@
text
@d1659 7
@


1.6
log
@
2001-02-09  Bo Thorsen  <bo@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_check_relocs): Set .rela.got section
	alignment to 3.
	(elf64_x86_64_check_relocs): Write R_X86_64_GOTPCREL GOT entry
	and relocation.
	(elf64_x86_64_relocate_section): Fix formatting.
	(elf64_x86_64_relocate_section): Fix addend for relocation of
	R_X86_64_(8|16|32|PC8|PC16|PC32).
@
text
@d35 2
a36 2
   type, size, bitsize, pc_relative, complain_on_overflow, special_function,
   name, partial_inplace, src_mask, dst_pack, pcrel_offset  */
d39 32
a70 16
  HOWTO(R_X86_64_NONE,          0,0, 0,false,0,complain_overflow_dont,    0, "R_X86_64_NONE",   false,0x00000000,0x00000000,false),
  HOWTO(R_X86_64_64,    0,4,64,false,0,complain_overflow_bitfield,0, "R_X86_64_64",     false,MINUS_ONE ,MINUS_ONE ,false),
  HOWTO(R_X86_64_PC32,          0,4,32,true ,0,complain_overflow_signed  ,0, "R_X86_64_PC32",   false,0xffffffff,0xffffffff,true),
  HOWTO(R_X86_64_GOT32,         0,4,32,false,0,complain_overflow_signed  ,0, "R_X86_64_GOT32",  false,0xffffffff,0xffffffff,false),
  HOWTO(R_X86_64_PLT32,         0,4,32,true ,0,complain_overflow_signed  ,0, "R_X86_64_PLT32",  false,0xffffffff,0xffffffff,true),
  HOWTO(R_X86_64_COPY,     0,4,32,false,0,complain_overflow_bitfield,0, "R_X86_64_COPY",   false,0xffffffff,0xffffffff,false),
  HOWTO(R_X86_64_GLOB_DAT, 0,4,64,false,0,complain_overflow_bitfield,0,"R_X86_64_GLOB_DAT",false,MINUS_ONE ,MINUS_ONE ,false),
  HOWTO(R_X86_64_RELATIVE ,0,4,64,false,0,complain_overflow_bitfield,0,"R_X86_64_RELATIVE",false,MINUS_ONE ,MINUS_ONE ,false),
  HOWTO(R_X86_64_JUMP_SLOT,0,4,64,false,0,complain_overflow_bitfield,0,"R_X86_64_JUMP_SLOT",false,MINUS_ONE,MINUS_ONE ,false),
  HOWTO(R_X86_64_GOTPCREL, 0,4,32,true, 0,complain_overflow_signed  ,0, "R_X86_64_GOTPCREL",false,0xffffffff,0xffffffff,true),
  HOWTO(R_X86_64_32,    0,4,32,false,0,complain_overflow_unsigned,0, "R_X86_64_32",     false,0xffffffff,0xffffffff,false),
  HOWTO(R_X86_64_32S,   0,4,32,false,0,complain_overflow_signed,  0, "R_X86_64_32S",    false,0xffffffff,0xffffffff,false),
  HOWTO(R_X86_64_16,    0,1,16,false,0,complain_overflow_bitfield,0, "R_X86_64_16",     false,0xffff    ,0xffff,    false),
  HOWTO(R_X86_64_PC16,          0,1,16,true ,0,complain_overflow_bitfield,0, "R_X86_64_PC16",   false,0xffff    ,0xffff,    true),
  HOWTO(R_X86_64_8,     0,0, 8,false,0,complain_overflow_signed  ,0, "R_X86_64_8",      false,0xff      ,0xff,      false),
  HOWTO(R_X86_64_PC8,   0,0, 8,true ,0,complain_overflow_signed  ,0, "R_X86_64_PC8",    false,0xff      ,0xff,      true),
d116 1
a116 1
         Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d156 1
a156 1
/* Functions for the x86-64 ELF linker.  */
d158 1
a158 1
/* The name of the dynamic interpreter.  This is put in the .interp
d161 1
a161 1
#define ELF_DYNAMIC_INTERPRETER "/lib/libd64.so.1"
d178 1
a178 1
  0, 0, 0, 0			/* pad out to 16 bytes.  */
d186 1
a186 1
  0, 0, 0, 0,	/* replaced with offset to this symbol in .got.  */
d194 1
a194 1
   it decides to copy in check_relocs for each symbol.  This is so
d197 1
a197 1
   extending the regular ELF linker hash table.  */
d224 2
a225 1
struct elf64_x86_64_link_hash_table {
d247 1
a247 1
/* Create an entry in an x86-64 ELF linker hash table.  */
d259 1
a259 1
     subclass.  */
d371 1
a371 1
	  /* This symbol requires a global offset table entry.  */
d452 5
a456 5
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code which is
             never referenced by a dynamic object, in which case we
             don't need to generate a procedure linkage table entry
             after all.  */
d459 1
a459 1
             creating a procedure linkage table entry.  */
d484 1
a484 1
	     including in the link (i.e., DEF_REGULAR is set).  At
d578 1
a578 1
   relocation.  */
d617 1
a617 1
/* Update the got entry reference counts for the section being removed.  */
d703 1
a703 1
   understand.  */
d733 4
a736 1
      if (! elf_hash_table (info)->dynamic_sections_created)
a737 7
	  /* FIXME: These are the sparc64 comment and then the i386 comment.
	     How we need to deal with this and why remains to be seen.  */
	  /* This case can occur if we saw a WPLT30 reloc in an input
             file, but none of the input files were dynamic objects.
             In such a case, we don't actually need to build a
             procedure linkage table, and we can just do a WDISP30
             reloc instead.  */
a742 1
	  /* i386 code: */
d765 1
a765 1
	 location in the .plt.  This is required to make function
d780 6
d796 1
a796 1
     real definition first, and we can just use the same value.  */
d807 1
a807 1
     is not a function.  */
d812 1
a812 1
     be handled correctly by relocate_section.  */
d822 1
a822 1
     become part of the .bss section of the executable.  There will be
d849 1
a849 1
     have no idea how ELF linkers handle this.  16-bytes is the size
d905 4
a908 4
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rela.got,
         which will cause it to get stripped from the output file
         below.  */
d945 1
a945 1
                 comment below.  */
d974 1
a974 1
                 than .rela.plt.  */
d1027 1
a1027 1
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
a1036 1
	  /* FIXME: Are all these needed?  */
d1039 1
a1039 1
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_REL)
d1099 1
a1099 1
                             contents, relocs, local_syms, local_sections)
d1175 1
a1175 1
      /* This is a final link.  */
d1248 1
a1248 1
		     was forced to be local because of a version file.  We
d1255 2
a1256 2
		     relocation entry to initialize the value.  This is
		     done in the finish_dynamic_symbol routine.  */
d1278 2
a1279 2
                 the least significant bit to record whether we have
                 already generated the necessary reloc.  */
d1332 1
a1332 1
		     was forced to be local because of a version file.  We
d1339 2
a1340 2
		     relocation entry to initialize the value.  This is
		     done in the finish_dynamic_symbol routine.  */
d1362 2
a1363 2
                 the least significant bit to record whether we have
                 already generated the necessary reloc.  */
d1404 1
a1404 1
             without using the procedure linkage table.  */
d1411 2
a1412 2
                 happens when statically linking PIC code, or when
                 using -Bsymbolic.  */
d1428 1
a1428 1
	     the same when it's zeroextended to 64 bit.  */
d1444 1
a1444 1
		 time.  */
d1503 1
a1503 1
                     become local.  */
d1606 1
a1606 1
	 it up.  */
d1622 1
a1622 1
	 corresponds to this function.  Each .got entry is GOT_ENTRY_SIZE
d1639 1
a1639 1
      /* Fill in the entry in the global offset table.  */
d1657 1
a1657 1
	     the .plt section.  Leave the value alone.  */
d1716 1
a1716 2
      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL && sdyn != NULL);
d1749 1
a1749 1
		 that RELASZ should not include JMPREL.  This is not what
d1756 1
a1756 1
		  /* Subtract JMPREL size from RELASZ.  */
d1774 2
d1778 1
a1778 1
	    memcpy (splt->contents, elf64_x86_64_plt0_entry, PLT_ENTRY_SIZE);
d1787 1
a1787 1
  sgot = bfd_get_section_by_name (dynobj, ".got");
d1808 35
d1849 2
a1858 2
#define elf_backend_object_p		    elf64_x86_64_elf_object_p
#define elf_backend_relocate_section	    elf64_x86_64_relocate_section
d1863 1
a1863 1
#define bfd_elf64_bfd_reloc_type_lookup     elf64_x86_64_reloc_type_lookup
d1875 1
@


1.5
log
@
	* elf64-x86-64.c (x86_64_elf_howto): Fix name of R_X86_64_GOTPCREL.
	* tc-i386.c (i386_displacement): Fix handling of
	BFD_RELOC_X86_64_GOTPCREL.
	(i386_validate_fix): Likewise.
@
text
@d352 1
d376 1
a376 1
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
d1269 1
a1269 1
      if (info->shared)
d1302 2
a1303 1
	  if (sgot == NULL)
d1305 29
a1333 2
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
d1335 3
d1339 18
a1356 1
	  relocation = sgot->output_section->vma + (h->got.offset & ~1);
d1358 22
d1481 1
a1481 1
		  outrel.r_addend = relocation + rela->r_addend;
d1494 1
a1494 1
		      outrel.r_addend = relocation + rela->r_addend;
d1501 1
a1501 1
		      outrel.r_addend = relocation + rela->r_addend;
@


1.4
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* aoutx.h: Fix formatting.
	* bfd.c: Likewise.
	* bfd-in2.h: Likewise.
	* bfd-in.h: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-m68hc11.c: Likewise.
	* dwarf2.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* format.c: Likewise.
	* freebsd.h: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
@
text
@d48 1
a48 1
  HOWTO(R_X86_64_GOTPCREL, 0,4,32,true, 0,complain_overflow_signed  ,0, "R_X86_64_PCREL",  false,0xffffffff,0xffffffff,true),
@


1.4.2.1
log
@
	* elf64-x86-64.c (x86_64_elf_howto): Fix name of R_X86_64_GOTPCREL.
	* tc-i386.c (i386_displacement): Fix handling of
	BFD_RELOC_X86_64_GOTPCREL.
	(i386_validate_fix): Likewise.
@
text
@d48 1
a48 1
  HOWTO(R_X86_64_GOTPCREL, 0,4,32,true, 0,complain_overflow_signed  ,0, "R_X86_64_GOTPCREL",false,0xffffffff,0xffffffff,true),
@


1.4.2.2
log
@
2001-02-09  Bo Thorsen  <bo@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_check_relocs): Set .rela.got section
	alignment to 3.
	(elf64_x86_64_check_relocs): Write R_X86_64_GOTPCREL GOT entry
	and relocation.
	(elf64_x86_64_relocate_section): Fix formatting.
	(elf64_x86_64_relocate_section): Fix addend for relocation of
	R_X86_64_(8|16|32|PC8|PC16|PC32).
@
text
@a351 1
	case R_X86_64_GOTPCREL:
d375 1
a375 1
		      || ! bfd_set_section_alignment (dynobj, srelgot, 3))
d1268 1
a1268 1
		  if (info->shared)
d1301 1
a1301 2
	  BFD_ASSERT (sgot != NULL);
	  if (h != NULL)
d1303 2
a1304 29
	      bfd_vma off = h->got.offset;
	      BFD_ASSERT (off != (bfd_vma) -1);

	      if (! elf_hash_table (info)->dynamic_sections_created
		  || (info->shared
		      && (info->symbolic || h->dynindx == -1)
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
		{
		  /* This is actually a static link, or it is a -Bsymbolic
		     link and the symbol is defined locally, or the symbol
		     was forced to be local because of a version file.  We
		     must initialize this entry in the global offset table.
		     Since the offset must always be a multiple of 8, we
		     use the least significant bit to record whether we
		     have initialized it already.

		     When doing a dynamic link, we create a .rela.got
		     relocation entry to initialize the value.  This is
		     done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_64 (output_bfd, relocation,
				  sgot->contents + off);
		      h->got.offset |= 1;
		    }
		}
	      relocation = sgot->output_offset + off;
a1305 3
	  else
	    {
	      bfd_vma off;
d1307 1
a1307 18
	      BFD_ASSERT (local_got_offsets != NULL
			  && local_got_offsets[r_symndx] != (bfd_vma) -1);

	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 8.  We use
                 the least significant bit to record whether we have
                 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_64 (output_bfd, relocation, sgot->contents + off);

		  if (info->shared)
		    {
		      asection *srelgot;
		      Elf_Internal_Rela outrel;
a1308 22
		      /* We need to generate a R_X86_64_RELATIVE reloc
			 for the dynamic linker.  */
		      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
		      BFD_ASSERT (srelgot != NULL);

		      outrel.r_offset = (sgot->output_section->vma
					 + sgot->output_offset
					 + off);
		      outrel.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
		      outrel.r_addend = relocation;
		      bfd_elf64_swap_reloca_out (output_bfd, &outrel,
						 (((Elf64_External_Rela *)
						   srelgot->contents)
						  + srelgot->reloc_count));
		      ++srelgot->reloc_count;
		    }

		  local_got_offsets[r_symndx] |= 1;
		}

	      relocation = sgot->output_section->vma + off;
	    }
d1410 1
a1410 1
		  outrel.r_addend = rela->r_addend;
d1423 1
a1423 1
		      outrel.r_addend = rela->r_addend;
d1430 1
a1430 1
		      outrel.r_addend = rela->r_addend;
@


1.4.2.3
log
@2001-02-14  Bo Thorsen  <bo@@suse.de>

        * elf64-x86-64.c: Small formatting fixes and rearrangements of code.
        (elf64_86_64_size_info): Struct added to fix a problem
        with the hashtable string entries.
        (elf64_x86_64_adjust_dynamic_symbol): Add generation of .got.plt.
        (elf64_x86_64_size_dynamic_sections): A FIXME removed.
        (elf64_x86_64_size_dynamic_sections): Fix a dynamic entry and
        remove the FIXME for this.
        (elf64_x86_64_adjust_dynamic_symbol): Fix check for unneeded .plt
        section. Also removed the FIXME for it.
        (x86_64_elf_howto_table): Use bfd_elf_generic_reloc.
        (ELF_DYNAMIC_INTERPRETER): Fix the name of the dynamic linker.
        (elf64_x86_64_finish_dynamic_sections): Enable .got.plt writing.
@
text
@d35 2
a36 2
   type, size, bitsize, pc_relative, complain_on_overflow,
   special_function, name, partial_inplace, src_mask, dst_pack, pcrel_offset.  */
d39 16
a54 32
  HOWTO(R_X86_64_NONE, 0, 0, 0, false, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_X86_64_NONE",	false, 0x00000000, 0x00000000, false),
  HOWTO(R_X86_64_64, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_64", false, MINUS_ONE, MINUS_ONE, false),
  HOWTO(R_X86_64_PC32, 0, 4, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC32", false, 0xffffffff, 0xffffffff, true),
  HOWTO(R_X86_64_GOT32, 0, 4, 32, false, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOT32", false, 0xffffffff, 0xffffffff, false),
  HOWTO(R_X86_64_PLT32, 0, 4, 32, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PLT32", false, 0xffffffff, 0xffffffff, true),
  HOWTO(R_X86_64_COPY, 0, 4, 32, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_COPY", false, 0xffffffff, 0xffffffff, false),
  HOWTO(R_X86_64_GLOB_DAT, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_GLOB_DAT", false, MINUS_ONE, MINUS_ONE, false),
  HOWTO(R_X86_64_RELATIVE, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", false, MINUS_ONE, MINUS_ONE, false),
  HOWTO(R_X86_64_JUMP_SLOT, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", false, MINUS_ONE, MINUS_ONE, false),
  HOWTO(R_X86_64_GOTPCREL, 0, 4, 32, true,0 , complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL", false, 0xffffffff, 0xffffffff, true),
  HOWTO(R_X86_64_32, 0, 4, 32, false, 0, complain_overflow_unsigned,
	bfd_elf_generic_reloc, "R_X86_64_32", false, 0xffffffff, 0xffffffff, false),
  HOWTO(R_X86_64_32S, 0, 4, 32, false, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_32S", false, 0xffffffff, 0xffffffff, false),
  HOWTO(R_X86_64_16, 0, 1, 16, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_16", false, 0xffff, 0xffff, false),
  HOWTO(R_X86_64_PC16,0, 1, 16, true, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_PC16", false, 0xffff, 0xffff, true),
  HOWTO(R_X86_64_8, 0, 0, 8, false, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_8", false, 0xff, 0xff, false),
  HOWTO(R_X86_64_PC8, 0, 0, 8, true, 0, complain_overflow_signed,
	bfd_elf_generic_reloc, "R_X86_64_PC8", false, 0xff, 0xff, true)
d100 1
a100 1
	 Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
d140 1
a140 1
/* Functions for the x86-64 ELF linker.	 */
d142 1
a142 1
/* The name of the dynamic interpreter.	 This is put in the .interp
d145 1
a145 1
#define ELF_DYNAMIC_INTERPRETER "/lib/ld64.so.1"
d162 1
a162 1
  0, 0, 0, 0			/* pad out to 16 bytes.	 */
d170 1
a170 1
  0, 0, 0, 0,	/* replaced with offset to this symbol in .got.	 */
d178 1
a178 1
   it decides to copy in check_relocs for each symbol.	This is so
d181 1
a181 1
   extending the regular ELF linker hash table.	 */
d208 1
a208 2
struct elf64_x86_64_link_hash_table
{
d230 1
a230 1
/* Create an entry in an x86-64 ELF linker hash table.	*/
d242 1
a242 1
     subclass.	*/
d354 1
a354 1
	  /* This symbol requires a global offset table entry.	*/
d435 5
a439 5
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.	 */
d442 1
a442 1
	     creating a procedure linkage table entry.	*/
d467 1
a467 1
	     including in the link (i.e., DEF_REGULAR is set).	At
d561 1
a561 1
   relocation.	*/
d600 1
a600 1
/* Update the got entry reference counts for the section being removed.	 */
d686 1
a686 1
   understand.	*/
d716 1
a716 4
      if ((! info->shared
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	  || (info->shared && h->plt.refcount <= 0))
d718 7
d730 1
d753 1
a753 1
	 location in the .plt.	This is required to make function
a767 6
      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */
      s = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += GOT_ENTRY_SIZE;

d778 1
a778 1
     real definition first, and we can just use the same value.	 */
d789 1
a789 1
     is not a function.	 */
d794 1
a794 1
     be handled correctly by relocate_section.	*/
d804 1
a804 1
     become part of the .bss section of the executable.	 There will be
d831 1
a831 1
     have no idea how ELF linkers handle this.	16-bytes is the size
d887 4
a890 4
	 However, if we are not creating the dynamic sections, we will
	 not actually use these entries.  Reset the size of .rela.got,
	 which will cause it to get stripped from the output file
	 below.	 */
d927 1
a927 1
		 comment below.	 */
d956 1
a956 1
		 than .rela.plt.  */
d1009 1
a1009 1
	 the .dynamic section.	The DT_DEBUG entry is filled in by the
d1019 1
d1022 1
a1022 1
	      || ! bfd_elf64_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
d1082 1
a1082 1
			     contents, relocs, local_syms, local_sections)
d1158 1
a1158 1
      /* This is a final link.	*/
d1231 1
a1231 1
		     was forced to be local because of a version file.	We
d1238 2
a1239 2
		     relocation entry to initialize the value.	This is
		     done in the finish_dynamic_symbol routine.	 */
d1261 2
a1262 2
		 the least significant bit to record whether we have
		 already generated the necessary reloc.	 */
d1315 1
a1315 1
		     was forced to be local because of a version file.	We
d1322 2
a1323 2
		     relocation entry to initialize the value.	This is
		     done in the finish_dynamic_symbol routine.	 */
d1345 2
a1346 2
		 the least significant bit to record whether we have
		 already generated the necessary reloc.	 */
d1387 1
a1387 1
	     without using the procedure linkage table.	 */
d1394 2
a1395 2
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
d1411 1
a1411 1
	     the same when it's zeroextended to 64 bit.	 */
d1427 1
a1427 1
		 time.	*/
d1486 1
a1486 1
		     become local.  */
d1589 1
a1589 1
	 it up.	 */
d1605 1
a1605 1
	 corresponds to this function.	Each .got entry is GOT_ENTRY_SIZE
d1622 1
a1622 1
      /* Fill in the entry in the global offset table.	*/
d1640 1
a1640 1
	     the .plt section.	Leave the value alone.	*/
d1699 2
a1700 1
      BFD_ASSERT (sdyn != NULL);
d1733 1
a1733 1
		 that RELASZ should not include JMPREL.	 This is not what
d1740 1
a1740 1
		  /* Subtract JMPREL size from RELASZ.	*/
a1757 2
      splt = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (splt != NULL);
d1760 1
a1760 1
	  memcpy (splt->contents, elf64_x86_64_plt0_entry, PLT_ENTRY_SIZE);
d1769 1
a1769 1
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
a1789 35
/*
 * Why was the hash table entry size definition changed from
 * ARCH_SIZE/8 to 4? This breaks the 64 bit dynamic linker and
 * this is the only reason for the elf64_x86_64_size_info structure.
 */

const struct elf_size_info elf64_86_64_size_info =
{
  sizeof (Elf64_External_Ehdr),
  sizeof (Elf64_External_Phdr),
  sizeof (Elf64_External_Shdr),
  sizeof (Elf64_External_Rel),
  sizeof (Elf64_External_Rela),
  sizeof (Elf64_External_Sym),
  sizeof (Elf64_External_Dyn),
  sizeof (Elf_External_Note),
  8,		/* hash-table entry size */
  1,		/* internal relocations per external relocations */
  64,		/* arch_size */
  8,		/* file_align */
  ELFCLASS64, EV_CURRENT,
  bfd_elf64_write_out_phdrs,
  bfd_elf64_write_shdrs_and_ehdr,
  bfd_elf64_write_relocs,
  bfd_elf64_swap_symbol_out,
  bfd_elf64_slurp_reloc_table,
  bfd_elf64_slurp_symbol_table,
  bfd_elf64_swap_dyn_in,
  bfd_elf64_swap_dyn_out,
  NULL,
  NULL,
  NULL,
  NULL
};

a1795 2
#define elf_backend_size_info		    elf64_86_64_size_info

d1804 2
d1810 1
a1810 1
#define bfd_elf64_bfd_reloc_type_lookup	    elf64_x86_64_reloc_type_lookup
a1821 1
#define elf_backend_object_p		    elf64_x86_64_elf_object_p
@


1.4.2.4
log
@2001-02-20  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Don't make
	PLT entries that could serve as a definition for a weak symbol.
@
text
@a1658 7
	  /* If the symbol is weak, we do need to clear the value.
	     Otherwise, the PLT entry would provide a definition for
	     the symbol even if the symbol wasn't defined anywhere,
	     and so the symbol would never be NULL.  */
	  if ((h->elf_link_hash_flags & ELF_LINK_HASH_REF_REGULAR_NONWEAK)
	      == 0)
	    sym->st_value = 0;
@


1.4.2.5
log
@2001-02-26  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (x86_64_elf_howto_table): Fix order of entries.
@
text
@d53 2
a56 2
  HOWTO(R_X86_64_RELATIVE, 0, 4, 64, false, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", false, MINUS_ONE, MINUS_ONE, false),
@


1.4.2.6
log
@2001-02-28  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_relocate_section): Add relocation
	to addend.
@
text
@d1498 1
a1498 1
		  outrel.r_addend = relocation + rela->r_addend;
d1511 1
a1511 1
		      outrel.r_addend = relocation + rela->r_addend;
d1518 1
a1518 1
		      outrel.r_addend = relocation + rela->r_addend;
@


1.4.2.7
log
@2001-03-07  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_relocate_section): Fix handling of
	some relocation values.
@
text
@d1197 1
a1197 35
	      if (r_type == R_X86_64_GOTPCREL
		  || (r_type = R_X86_64_PLT32
		      && splt != NULL
		      && h->plt.offset != (bfd_vma) -1)
		  || (r_type = R_X86_64_GOT32
		      && elf_hash_table (info)->dynamic_sections_created
		      && (!info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      && ( r_type == R_X86_64_8 ||
			   r_type == R_X86_64_16 ||
                           r_type == R_X86_64_32 ||
			   r_type == R_X86_64_64 ||
                           r_type == R_X86_64_PC16 ||
			   r_type == R_X86_64_PC32)
                      && ((input_section->flags & SEC_ALLOC) != 0
                          /* DWARF will emit R_X86_64_32 relocations in its
                             sections against symbols defined externally
                             in shared libraries.  We can't do anything
                             with them here.  */
                          || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
		{
		  /* In these cases, we don't need the relocation
                     value.  We check specially because in some
                     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
	      else if (sec->output_section == NULL)
@


1.4.2.8
log
@2001-04-19  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_plt0_entry): Fix instructions.
	(elf64_x86_64_plt_entry): Likewise.
	(elf64_x86_64_finish_dynamic_sections): Fix PLT0 generation.
	(elf64_x86_64_finish_dynamic_symbol): Fix PLT generation.
@
text
@d176 3
a178 3
  0xff, 0x35, 8, 0, 0, 0,	/* pushq GOT+8(%rip)  */
  0xff, 0x25, 16, 0, 0, 0,	/* jmpq *GOT+16(%rip) */
  0x90, 0x90, 0x90, 0x90	/* pad out to 16 bytes with nops.  */
d185 1
a185 1
  0xff, 0x25,	/* jmpq *name@@GOTPC(%rip) */
d187 1
a187 1
  0x68,		/* pushq immediate */
d1667 2
a1668 13
      /* Put offset for jmp *name@@GOTPCREL(%rip), since the
	 instruction uses 6 bytes, subtract this value.  */
      bfd_put_32 (output_bfd,
		      (sgot->output_section->vma
		       + sgot->output_offset
		       + got_offset
		       - splt->output_section->vma
		       - splt->output_offset
		       - h->plt.offset
		       - 6),
		  splt->contents + h->plt.offset + 2);
      /* Put relocation index.  */
      bfd_put_32 (output_bfd, plt_index,
d1670 1
a1670 2
      /* Put offset for jmp .PLT0.  */
      bfd_put_32 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE),
d1673 1
a1673 2
      /* Fill in the entry in the global offset table, initially this
	 points to the pushq instruction in the PLT which is at offset 6.  */
a1749 2
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
a1818 1
	  /* Fill in the first entry in the procedure linkage table.  */
a1819 21
	  /* Add offset for pushq GOT+8(%rip), since the instruction
	     uses 6 bytes subtract this value.  */
	  bfd_put_32 (output_bfd,
		      (sgot->output_section->vma
		       + sgot->output_offset
		       + 8
		       - splt->output_section->vma
		       - splt->output_offset
		       - 6),
		      splt->contents + 2);
	  /* Add offset for jmp *GOT+16(%rip). The 12 is the offset to
	     the end of the instruction.  */
	  bfd_put_32 (output_bfd,
		      (sgot->output_section->vma
		       + sgot->output_offset
		       + 16
		       - splt->output_section->vma
		       - splt->output_offset
		       - 12),
		      splt->contents + 8);

d1828 2
d1838 1
a1838 1
      /* Write GOT[1] and GOT[2], needed for the dynamic linker.  */
@


1.4.2.9
log
@2001-04-30  Andreas Jaeger  <aj@@suse.de>, Andreas Schwab <schwab@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_relocate_section): Correct test for
	R_X86_64_GOTPCREL, don't use assignments instead of comparisons.

2001-04-27  Andreas Jaeger  <aj@@suse.de>

	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Only swap
	out handled entries.
	(elf64_x86_64_finish_dynamic_symbol): Set up GOT entries.
	(elf64_x86_64_relocate_section): Fix GOTPCREL calculation.
	(elf64_x86_64_relocate_section): Merge entries for GOTPCREL and
	GOT32.
@
text
@d1197 5
a1201 4
	      if ((r_type == R_X86_64_PLT32
		   && splt != NULL
		   && h->plt.offset != (bfd_vma) -1)
		  || ((r_type == R_X86_64_GOT32 || r_type == R_X86_64_GOTPCREL)
d1268 82
d1352 1
a1353 1

d1384 1
a1384 4
	      if (r_type == R_X86_64_GOTPCREL)
		relocation = sgot->output_section->vma + sgot->output_offset + off;
	      else
		relocation = sgot->output_offset + off;
d1429 1
a1429 4
	      if (r_type == R_X86_64_GOTPCREL)
		relocation = sgot->output_section->vma + sgot->output_offset + off;
	      else
		relocation = sgot->output_offset + off;
a1430 1

a1715 46
  if (h->got.offset != (bfd_vma) -1)
    {
      asection *sgot;
      asection *srela;
      Elf_Internal_Rela rela;

      /* This symbol has an entry in the global offset table.  Set it
         up.  */

      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srela != NULL);

      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + (h->got.offset &~ 1));

      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (! elf_hash_table (info)->dynamic_sections_created
	  || (info->shared
	      && (info->symbolic || h->dynindx == -1)
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
	{
	  rela.r_info = ELF64_R_INFO (0, R_X86_64_RELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
      else
	{
	  BFD_ASSERT((h->got.offset & 1) == 0);
	  bfd_put_64 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
	  rela.r_info = ELF64_R_INFO (h->dynindx, R_X86_64_GLOB_DAT);
	  rela.r_addend = 0;
	}

      bfd_elf64_swap_reloca_out (output_bfd, &rela,
				 ((Elf64_External_Rela *) srela->contents
				  + srela->reloc_count));
      ++srela->reloc_count;
    }

d1787 1
a1787 1
	      continue;
d1825 1
@


1.4.2.10
log
@	* elf64-x86-64.c (elf64_x86_64_check_relocs): Handle R_X86_64_64.
	(elf64_x86_64_relocate_section): Likewise.

	* elf64-x86-64.c (elf64_86_64_size_info): Remove, we can use the
	generic version since we want a hashsize of 4.
	(elf_backend_size_info): Likewise.
@
text
@a471 1
	case R_X86_64_64:
a1381 1
	case R_X86_64_64:
d1853 34
d1893 2
@


1.4.2.11
log
@	Merge from mainline sources:
	2001-06-19  Andreas Jaeger  <aj@@suse.de>
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Fix creation of
	dynamic symbols.
	2001-06-07  Andreas Jaeger  <aj@@suse.de>
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Add an
	assertion.
	(elf64_x86_64_check_relocs): Set an alignment of 8 for .rela
	sections; handle further relocations.
	2001-06-01  Andreas Jaeger  <aj@@suse.de>
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Add PC8
	relocation, small reformatting.
@
text
@d40 1
a40 2
	bfd_elf_generic_reloc, "R_X86_64_NONE",	false, 0x00000000, 0x00000000,
	false),
d42 1
a42 2
	bfd_elf_generic_reloc, "R_X86_64_64", false, MINUS_ONE, MINUS_ONE,
	false),
d44 1
a44 2
	bfd_elf_generic_reloc, "R_X86_64_PC32", false, 0xffffffff, 0xffffffff,
	true),
d46 1
a46 2
	bfd_elf_generic_reloc, "R_X86_64_GOT32", false, 0xffffffff, 0xffffffff,
	false),
d48 1
a48 2
	bfd_elf_generic_reloc, "R_X86_64_PLT32", false, 0xffffffff, 0xffffffff,
	true),
d50 1
a50 2
	bfd_elf_generic_reloc, "R_X86_64_COPY", false, 0xffffffff, 0xffffffff,
	false),
d52 1
a52 2
	bfd_elf_generic_reloc, "R_X86_64_GLOB_DAT", false, MINUS_ONE,
	MINUS_ONE, false),
d54 1
a54 2
	bfd_elf_generic_reloc, "R_X86_64_JUMP_SLOT", false, MINUS_ONE,
	MINUS_ONE, false),
d56 1
a56 2
	bfd_elf_generic_reloc, "R_X86_64_RELATIVE", false, MINUS_ONE,
	MINUS_ONE, false),
d58 1
a58 2
	bfd_elf_generic_reloc, "R_X86_64_GOTPCREL", false, 0xffffffff,
	0xffffffff, true),
d60 1
a60 2
	bfd_elf_generic_reloc, "R_X86_64_32", false, 0xffffffff, 0xffffffff,
	false),
d62 1
a62 2
	bfd_elf_generic_reloc, "R_X86_64_32S", false, 0xffffffff, 0xffffffff,
	false),
a462 1
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d464 4
a467 1
	    h->plt.refcount = 1;
d472 1
a472 2
	case R_X86_64_8:
	case R_X86_64_16:
a473 1
	case R_X86_64_64:
d495 1
a495 3
	      && (((ELF64_R_TYPE (rel->r_info) != R_X86_64_PC8)
		  && (ELF64_R_TYPE (rel->r_info) != R_X86_64_PC16)
		  && (ELF64_R_TYPE (rel->r_info) != R_X86_64_PC32))
d531 1
a531 1
			  || ! bfd_set_section_alignment (dynobj, sreloc, 3))
d545 1
a545 3
		  && ((ELF64_R_TYPE (rel->r_info) == R_X86_64_PC8)
		      || (ELF64_R_TYPE (rel->r_info) == R_X86_64_PC16)
		      || (ELF64_R_TYPE (rel->r_info) == R_X86_64_PC32)))
d1100 1
a1100 1
			       contents, relocs, local_syms, local_sections)
d1211 6
a1216 7
		      && (r_type == R_X86_64_8
			  || r_type == R_X86_64_16
			  || r_type == R_X86_64_32
			  || r_type == R_X86_64_64
			  || r_type == R_X86_64_PC8
			  || r_type == R_X86_64_PC16
			  || r_type == R_X86_64_PC32)
a1379 6
	case R_X86_64_PC8:
	case R_X86_64_PC16:
	case R_X86_64_PC32:
	  if (h == NULL)
	    break;
	  /* Fall through.  */
d1384 4
a1387 1
	  /* FIXME: The ABI says the linker should make sure the value is
d1391 1
a1391 2
	      && ((r_type != R_X86_64_PC8
		   && r_type != R_X86_64_PC16
d1393 5
a1397 4
		  || (! info->symbolic
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))

d1452 2
a1453 6
	      /* h->dynindx may be -1 if this symbol was marked to
		 become local.  */
	      else if (h != NULL
		       && ((! info->symbolic && h->dynindx != -1)
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
d1455 1
a1455 1
		  BFD_ASSERT (h->dynindx != -1);
d1462 6
a1467 1
		  if (r_type == R_X86_64_64)
d1475 5
a1479 32
		      long indx;

		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
			indx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error (bfd_error_bad_value);
			  return false;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  indx = elf_section_data (osec)->dynindx;
			  BFD_ASSERT (indx > 0);
			}

 		      relocate = false;
		      outrel.r_info = ELF64_R_INFO (indx, r_type);
 		      outrel.r_addend = relocation + rela->r_addend;
 		    }

d1583 1
a1583 1
	 bytes. The first three are reserved for the dynamic linker.  */
a1668 1
	  BFD_ASSERT((h->got.offset & 1) != 0);
@


1.4.2.12
log
@        * elf64-x86-64.c (elf64_x86_64_relocate_section): Fix linking of
        shared libraries.
@
text
@d1400 1
a1400 3
	  if (h == NULL || h->dynindx == -1
	      || (info->symbolic
		  && h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d1409 9
a1417 1
	  if (info->shared && (input_section->flags & SEC_ALLOC) != 0)
d1521 1
a1521 1
		      relocate = false;
d1523 2
a1524 2
		      outrel.r_addend = relocation + rela->r_addend;
		    }
@


1.3
log
@2001-01-22  Bo Thorsen  <bo@@suse.de>

        * elf64-x86-64.c: Added PIC support for X86-64.
        (elf64_x86_64_link_hash_newfunc): Function added.
        (elf64_x86_64_link_hash_table_create): Likewise.
        (elf64_x86_64_check_relocs): Likewise.
        (elf64_x86_64_gc_mark_hook): Likewise.
        (elf64_x86_64_gc_sweep_hook): Likewise.
        (elf64_x86_64_adjust_dynamic_symbol): Likewise.
        (elf64_x86_64_size_dynamic_sections): Likewise.
        (elf64_x86_64_discard_copies): Likewise.
        (elf64_x86_64_finish_dynamic_symbol): Likewise.
        (elf64_x86_64_finish_dynamic_sections): Likewise.
        (elf64_x86_64_relocate_section): Add relocation of PIC sections.
@
text
@a1718 1

@


1.2
log
@2000-12-07  Kazu Hirata  <kazu@@hxi.com>

	* elf32-ppc.c: Fix formatting.
	* elf64-x86-64.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 2000 Free Software Foundation, Inc.
d37 2
a38 1
static reloc_howto_type x86_64_elf_howto_table[] = {
d58 2
a59 1
struct elf_reloc_map {
d66 16
a81 16
  { BFD_RELOC_NONE,           R_X86_64_NONE, },
  { BFD_RELOC_64,             R_X86_64_64,   },
  { BFD_RELOC_32_PCREL,               R_X86_64_PC32, },
  { BFD_RELOC_X86_64_GOT32,   R_X86_64_GOT32,},
  { BFD_RELOC_X86_64_PLT32,   R_X86_64_PLT32,},
  { BFD_RELOC_X86_64_COPY,    R_X86_64_COPY, },
  { BFD_RELOC_X86_64_GLOB_DAT,        R_X86_64_GLOB_DAT, },
  { BFD_RELOC_X86_64_JUMP_SLOT,       R_X86_64_JUMP_SLOT, },
  { BFD_RELOC_X86_64_RELATIVE,        R_X86_64_RELATIVE, },
  { BFD_RELOC_X86_64_GOTPCREL,        R_X86_64_GOTPCREL, },
  { BFD_RELOC_32,             R_X86_64_32, },
  { BFD_RELOC_X86_64_32S,     R_X86_64_32S, },
  { BFD_RELOC_16,             R_X86_64_16, },
  { BFD_RELOC_16_PCREL,               R_X86_64_PC16, },
  { BFD_RELOC_8,              R_X86_64_8, },
  { BFD_RELOC_8_PCREL,                R_X86_64_PC8, },
d90 8
d101 5
d139 62
d202 3
a204 2
/* Hash table functions - these will be used by dynamic linking code and
   right now they are needed to keep ld happy.  */
d206 1
a206 1
/* x86_64  ELF linker hash table.  */
d212 14
a225 1
/* Get the X86-64 ELF linker hash table from a link_info structure.  */
d230 32
d276 1
a276 1
                                     _bfd_elf_link_hash_newfunc))
d294 783
d1095 2
d1098 1
a1098 1
  Elf_Internal_Rela *rel;
d1106 1
a1106 1
  sreloc = NULL;
d1108 4
a1111 1
    abort ();
d1113 1
a1113 1
  rel = relocs;
d1115 1
a1115 1
  for (; rel < relend; rel++)
d1127 1
a1127 1
      r_type = ELF64_R_TYPE (rel->r_info);
d1136 1
a1136 1
      r_symndx = ELF64_R_SYM (rel->r_info);
d1150 1
a1150 1
		  rel->r_addend += sec->output_offset + sym->st_value;
d1194 3
d1201 1
a1201 1
		      input_section, rel->r_offset,
d1208 60
a1267 1
      /* This function should support shared objects, but don't.  */
d1269 184
a1452 1
	abort ();
d1455 2
a1456 2
				    contents, rel->r_offset,
				    relocation, rel->r_addend);
d1483 1
a1483 1
			input_bfd, input_section, rel->r_offset)))
d1490 226
d1719 33
a1751 10
#define TARGET_LITTLE_SYM             bfd_elf64_x86_64_vec
#define TARGET_LITTLE_NAME            "elf64-x86-64"
#define ELF_ARCH                      bfd_arch_i386
#define ELF_MACHINE_CODE              EM_X86_64
#define ELF_MAXPAGESIZE                       0x100000
#define elf_info_to_howto             elf64_x86_64_info_to_howto
#define bfd_elf64_bfd_reloc_type_lookup       elf64_x86_64_reloc_type_lookup
#define elf_backend_object_p            elf64_x86_64_elf_object_p
#define elf_backend_relocate_section  elf64_x86_64_relocate_section
#define bfd_elf64_bfd_link_hash_table_create elf64_x86_64_link_hash_table_create
@


1.1
log
@Add support for x86_64-*-linux-gnu* target
@
text
@d37 1
a37 2
static reloc_howto_type x86_64_elf_howto_table[] =
{
a81 1

d103 2
a104 2
      return &x86_64_elf_howto_table[(int)
                                     x86_64_reloc_map[i].elf_reloc_val];
d109 1
a110 1
/* Given an x86_64 ELF reloc type, fill in an arelent structure.  */
d130 1
a130 2
struct elf64_x86_64_link_hash_table
{
a133 1

d148 1
a148 1
       bfd_alloc (abfd, sizeof (struct elf64_x86_64_link_hash_table)));
d219 4
a222 4
      {
        bfd_set_error (bfd_error_bad_value);
        return false;
      }
d228 14
a241 14
      {
        /* This is a relocateable link.  We don't have to change
           anything, unless the reloc is against a section symbol,
           in which case we have to adjust according to where the
           section symbol winds up in the output section.  */
        if (r_symndx < symtab_hdr->sh_info)
          {
            sym = local_syms + r_symndx;
            if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
              {
                sec = local_sections[r_symndx];
                rel->r_addend += sec->output_offset + sym->st_value;
              }
          }
d243 2
a244 2
        continue;
      }
d251 7
a257 7
      {
        sym = local_syms + r_symndx;
        sec = local_sections[r_symndx];
        relocation = (sec->output_section->vma
                      + sec->output_offset
                      + sym->st_value);
      }
d259 35
a293 35
      {
        h = sym_hashes[r_symndx - symtab_hdr->sh_info];
        while (h->root.type == bfd_link_hash_indirect
               || h->root.type == bfd_link_hash_warning)
          h = (struct elf_link_hash_entry *) h->root.u.i.link;
        if (h->root.type == bfd_link_hash_defined
            || h->root.type == bfd_link_hash_defweak)
          {
            sec = h->root.u.def.section;
            if (sec->output_section == NULL)
              {
                (*_bfd_error_handler)
                  (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
                   bfd_get_filename (input_bfd), h->root.root.string,
                   bfd_get_section_name (input_bfd, input_section));
                relocation = 0;
              }
            else
              relocation = (h->root.u.def.value
                            + sec->output_section->vma
                            + sec->output_offset);
          }
        else if (h->root.type == bfd_link_hash_undefweak)
          relocation = 0;
        else
          {
            if (! ((*info->callbacks->undefined_symbol)
                   (info, h->root.root.string, input_bfd,
                    input_section, rel->r_offset,
                    (!info->shared || info->no_undefined
                     || ELF_ST_VISIBILITY (h->other)))))
              return false;
            relocation = 0;
          }
      }
d296 1
a296 1
      abort();
d299 2
a300 2
                                  contents, rel->r_offset,
                                  relocation, rel->r_addend);
d303 30
a332 30
      {
        switch (r)
          {
          default:
          case bfd_reloc_outofrange:
            abort ();
          case bfd_reloc_overflow:
            {
              const char *name;

              if (h != NULL)
                name = h->root.root.string;
              else
                {
                  name = bfd_elf_string_from_elf_section (input_bfd,
                                                          symtab_hdr->sh_link,
                                                          sym->st_name);
                  if (name == NULL)
                    return false;
                  if (*name == '\0')
                    name = bfd_section_name (input_bfd, sec);
                }
              if (! ((*info->callbacks->reloc_overflow)
                     (info, name, howto->name, (bfd_vma) 0,
                      input_bfd, input_section, rel->r_offset)))
                return false;
            }
            break;
          }
      }
a335 1

@

