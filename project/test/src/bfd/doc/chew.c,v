head	1.26;
access;
symbols
	sid-snapshot-20180601:1.26
	sid-snapshot-20180501:1.26
	sid-snapshot-20180401:1.26
	sid-snapshot-20180301:1.26
	sid-snapshot-20180201:1.26
	sid-snapshot-20180101:1.26
	sid-snapshot-20171201:1.26
	sid-snapshot-20171101:1.26
	sid-snapshot-20171001:1.26
	sid-snapshot-20170901:1.26
	sid-snapshot-20170801:1.26
	sid-snapshot-20170701:1.26
	sid-snapshot-20170601:1.26
	sid-snapshot-20170501:1.26
	sid-snapshot-20170401:1.26
	sid-snapshot-20170301:1.26
	sid-snapshot-20170201:1.26
	sid-snapshot-20170101:1.26
	sid-snapshot-20161201:1.26
	sid-snapshot-20161101:1.26
	sid-snapshot-20160901:1.26
	sid-snapshot-20160801:1.26
	sid-snapshot-20160701:1.26
	sid-snapshot-20160601:1.26
	sid-snapshot-20160501:1.26
	sid-snapshot-20160401:1.26
	sid-snapshot-20160301:1.26
	sid-snapshot-20160201:1.26
	sid-snapshot-20160101:1.26
	sid-snapshot-20151201:1.26
	sid-snapshot-20151101:1.26
	sid-snapshot-20151001:1.26
	sid-snapshot-20150901:1.26
	sid-snapshot-20150801:1.26
	sid-snapshot-20150701:1.26
	sid-snapshot-20150601:1.26
	sid-snapshot-20150501:1.26
	sid-snapshot-20150401:1.26
	sid-snapshot-20150301:1.26
	sid-snapshot-20150201:1.26
	sid-snapshot-20150101:1.26
	sid-snapshot-20141201:1.26
	sid-snapshot-20141101:1.26
	sid-snapshot-20141001:1.26
	sid-snapshot-20140901:1.26
	sid-snapshot-20140801:1.26
	sid-snapshot-20140701:1.26
	sid-snapshot-20140601:1.26
	sid-snapshot-20140501:1.26
	sid-snapshot-20140401:1.26
	sid-snapshot-20140301:1.26
	sid-snapshot-20140201:1.26
	sid-snapshot-20140101:1.26
	sid-snapshot-20131201:1.26
	sid-snapshot-20131101:1.26
	sid-snapshot-20131001:1.25
	binutils-2_24-branch:1.25.0.8
	binutils-2_24-branchpoint:1.25
	binutils-2_21_1:1.24
	sid-snapshot-20130901:1.25
	gdb_7_6_1-2013-08-30-release:1.25
	sid-snapshot-20130801:1.25
	sid-snapshot-20130701:1.25
	sid-snapshot-20130601:1.25
	sid-snapshot-20130501:1.25
	gdb_7_6-2013-04-26-release:1.25
	sid-snapshot-20130401:1.25
	binutils-2_23_2:1.25
	gdb_7_6-branch:1.25.0.6
	gdb_7_6-2013-03-12-branchpoint:1.25
	sid-snapshot-20130301:1.25
	sid-snapshot-20130201:1.25
	sid-snapshot-20130101:1.25
	sid-snapshot-20121201:1.25
	gdb_7_5_1-2012-11-29-release:1.25
	binutils-2_23_1:1.25
	sid-snapshot-20121101:1.25
	binutils-2_23:1.25
	sid-snapshot-20121001:1.25
	sid-snapshot-20120901:1.25
	gdb_7_5-2012-08-17-release:1.25
	sid-snapshot-20120801:1.25
	binutils-2_23-branch:1.25.0.4
	binutils-2_23-branchpoint:1.25
	gdb_7_5-branch:1.25.0.2
	gdb_7_5-2012-07-18-branchpoint:1.25
	sid-snapshot-20120701:1.25
	sid-snapshot-20120601:1.25
	sid-snapshot-20120501:1.25
	binutils-2_22_branch:1.24.0.14
	gdb_7_4_1-2012-04-26-release:1.24
	sid-snapshot-20120401:1.25
	sid-snapshot-20120301:1.25
	sid-snapshot-20120201:1.24
	gdb_7_4-2012-01-24-release:1.24
	sid-snapshot-20120101:1.24
	gdb_7_4-branch:1.24.0.12
	gdb_7_4-2011-12-13-branchpoint:1.24
	sid-snapshot-20111201:1.24
	binutils-2_22:1.24
	sid-snapshot-20111101:1.24
	sid-snapshot-20111001:1.24
	binutils-2_22-branch:1.24.0.10
	binutils-2_22-branchpoint:1.24
	gdb_7_3_1-2011-09-04-release:1.24
	sid-snapshot-20110901:1.24
	sid-snapshot-20110801:1.24
	gdb_7_3-2011-07-26-release:1.24
	sid-snapshot-20110701:1.24
	sid-snapshot-20110601:1.24
	sid-snapshot-20110501:1.24
	gdb_7_3-branch:1.24.0.8
	gdb_7_3-2011-04-01-branchpoint:1.24
	sid-snapshot-20110401:1.24
	sid-snapshot-20110301:1.24
	sid-snapshot-20110201:1.24
	sid-snapshot-20110101:1.24
	binutils-2_21:1.24
	sid-snapshot-20101201:1.24
	binutils-2_21-branch:1.24.0.6
	binutils-2_21-branchpoint:1.24
	sid-snapshot-20101101:1.24
	sid-snapshot-20101001:1.24
	binutils-2_20_1:1.23
	gdb_7_2-2010-09-02-release:1.24
	sid-snapshot-20100901:1.24
	sid-snapshot-20100801:1.24
	gdb_7_2-branch:1.24.0.4
	gdb_7_2-2010-07-07-branchpoint:1.24
	sid-snapshot-20100701:1.24
	sid-snapshot-20100601:1.24
	sid-snapshot-20100501:1.24
	sid-snapshot-20100401:1.24
	gdb_7_1-2010-03-18-release:1.24
	sid-snapshot-20100301:1.24
	gdb_7_1-branch:1.24.0.2
	gdb_7_1-2010-02-18-branchpoint:1.24
	sid-snapshot-20100201:1.24
	sid-snapshot-20100101:1.24
	gdb_7_0_1-2009-12-22-release:1.23
	sid-snapshot-20091201:1.24
	sid-snapshot-20091101:1.24
	binutils-2_20:1.23
	gdb_7_0-2009-10-06-release:1.23
	sid-snapshot-20091001:1.24
	gdb_7_0-branch:1.23.0.4
	gdb_7_0-2009-09-16-branchpoint:1.23
	arc-sim-20090309:1.21
	binutils-arc-20081103-branch:1.21.0.26
	binutils-arc-20081103-branchpoint:1.21
	binutils-2_20-branch:1.23.0.2
	binutils-2_20-branchpoint:1.23
	sid-snapshot-20090901:1.22
	sid-snapshot-20090801:1.21
	msnyder-checkpoint-072509-branch:1.21.0.24
	msnyder-checkpoint-072509-branchpoint:1.21
	sid-snapshot-20090701:1.21
	dje-cgen-play1-branch:1.21.0.22
	dje-cgen-play1-branchpoint:1.21
	sid-snapshot-20090601:1.21
	sid-snapshot-20090501:1.21
	sid-snapshot-20090401:1.21
	arc-20081103-branch:1.21.0.20
	arc-20081103-branchpoint:1.21
	arc-insight_6_8-branch:1.21.0.18
	arc-insight_6_8-branchpoint:1.21
	insight_6_8-branch:1.21.0.16
	insight_6_8-branchpoint:1.21
	sid-snapshot-20090301:1.21
	binutils-2_19_1:1.21
	sid-snapshot-20090201:1.21
	sid-snapshot-20090101:1.21
	reverse-20081226-branch:1.21.0.14
	reverse-20081226-branchpoint:1.21
	sid-snapshot-20081201:1.21
	multiprocess-20081120-branch:1.21.0.12
	multiprocess-20081120-branchpoint:1.21
	sid-snapshot-20081101:1.21
	binutils-2_19:1.21
	sid-snapshot-20081001:1.21
	reverse-20080930-branch:1.21.0.10
	reverse-20080930-branchpoint:1.21
	binutils-2_19-branch:1.21.0.8
	binutils-2_19-branchpoint:1.21
	sid-snapshot-20080901:1.21
	sid-snapshot-20080801:1.21
	reverse-20080717-branch:1.21.0.6
	reverse-20080717-branchpoint:1.21
	sid-snapshot-20080701:1.21
	msnyder-reverse-20080609-branch:1.21.0.4
	msnyder-reverse-20080609-branchpoint:1.21
	drow-reverse-20070409-branch:1.19.0.32
	drow-reverse-20070409-branchpoint:1.19
	sid-snapshot-20080601:1.21
	sid-snapshot-20080501:1.21
	sid-snapshot-20080403:1.21
	sid-snapshot-20080401:1.21
	gdb_6_8-2008-03-27-release:1.21
	sid-snapshot-20080301:1.21
	gdb_6_8-branch:1.21.0.2
	gdb_6_8-2008-02-26-branchpoint:1.21
	sid-snapshot-20080201:1.21
	sid-snapshot-20080101:1.21
	sid-snapshot-20071201:1.21
	sid-snapshot-20071101:1.21
	gdb_6_7_1-2007-10-29-release:1.20
	gdb_6_7-2007-10-10-release:1.20
	sid-snapshot-20071001:1.20
	gdb_6_7-branch:1.20.0.4
	gdb_6_7-2007-09-07-branchpoint:1.20
	binutils-2_18:1.20
	binutils-2_18-branch:1.20.0.2
	binutils-2_18-branchpoint:1.20
	insight_6_6-20070208-release:1.19
	binutils-csl-coldfire-4_1-32:1.19
	binutils-csl-sourcerygxx-4_1-32:1.19
	gdb_6_6-2006-12-18-release:1.19
	binutils-csl-innovasic-fido-3_4_4-33:1.19
	binutils-csl-sourcerygxx-3_4_4-32:1.14
	binutils-csl-coldfire-4_1-30:1.19
	binutils-csl-sourcerygxx-4_1-30:1.19
	binutils-csl-coldfire-4_1-28:1.19
	binutils-csl-sourcerygxx-4_1-29:1.19
	binutils-csl-sourcerygxx-4_1-28:1.19
	gdb_6_6-branch:1.19.0.30
	gdb_6_6-2006-11-15-branchpoint:1.19
	binutils-csl-arm-2006q3-27:1.19
	binutils-csl-sourcerygxx-4_1-27:1.19
	binutils-csl-arm-2006q3-26:1.19
	binutils-csl-sourcerygxx-4_1-26:1.19
	binutils-csl-sourcerygxx-4_1-25:1.19
	binutils-csl-sourcerygxx-4_1-24:1.19
	binutils-csl-sourcerygxx-4_1-23:1.19
	insight_6_5-20061003-release:1.19
	gdb-csl-symbian-6_4_50_20060226-12:1.19
	binutils-csl-sourcerygxx-4_1-21:1.19
	binutils-csl-arm-2006q3-21:1.19
	binutils-csl-sourcerygxx-4_1-22:1.19
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.19
	binutils-csl-sourcerygxx-4_1-20:1.19
	binutils-csl-arm-2006q3-19:1.19
	binutils-csl-sourcerygxx-4_1-19:1.19
	binutils-csl-sourcerygxx-4_1-18:1.19
	binutils-csl-renesas-4_1-9:1.19
	gdb-csl-sourcerygxx-3_4_4-25:1.19
	binutils-csl-sourcerygxx-3_4_4-25:1.14
	nickrob-async-20060828-mergepoint:1.19
	gdb-csl-symbian-6_4_50_20060226-11:1.19
	binutils-csl-renesas-4_1-8:1.19
	binutils-csl-renesas-4_1-7:1.19
	binutils-csl-renesas-4_1-6:1.19
	gdb-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-17:1.19
	gdb-csl-20060226-branch-local-2:1.19
	gdb-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-15:1.19
	gdb-csl-sourcerygxx-4_1-13:1.19
	binutils-csl-sourcerygxx-4_1-13:1.19
	binutils-2_17:1.19
	gdb-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-4_1-12:1.19
	gdb-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.19
	gdb_6_5-20060621-release:1.19
	binutils-csl-wrs-linux-3_4_4-24:1.14
	binutils-csl-wrs-linux-3_4_4-23:1.14
	gdb-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-9:1.19
	gdb-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-8:1.19
	gdb-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-sourcerygxx-4_1-7:1.19
	gdb-csl-arm-2006q1-6:1.19
	binutils-csl-arm-2006q1-6:1.19
	gdb-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-wrs-linux-3_4_4-22:1.14
	gdb-csl-symbian-6_4_50_20060226-10:1.19
	gdb-csl-symbian-6_4_50_20060226-9:1.19
	gdb-csl-symbian-6_4_50_20060226-8:1.19
	gdb-csl-coldfire-4_1-11:1.19
	binutils-csl-coldfire-4_1-11:1.19
	gdb-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.19
	gdb-csl-coldfire-4_1-10:1.19
	gdb_6_5-branch:1.19.0.28
	gdb_6_5-2006-05-14-branchpoint:1.19
	binutils-csl-coldfire-4_1-10:1.19
	gdb-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-5:1.19
	nickrob-async-20060513-branch:1.19.0.26
	nickrob-async-20060513-branchpoint:1.19
	gdb-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-sourcerygxx-4_1-4:1.19
	msnyder-reverse-20060502-branch:1.19.0.24
	msnyder-reverse-20060502-branchpoint:1.19
	binutils-csl-wrs-linux-3_4_4-21:1.14
	gdb-csl-morpho-4_1-4:1.19
	binutils-csl-morpho-4_1-4:1.19
	gdb-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-wrs-linux-3_4_4-20:1.14
	readline_5_1-import-branch:1.19.0.22
	readline_5_1-import-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.19
	binutils-2_17-branch:1.19.0.20
	binutils-2_17-branchpoint:1.19
	gdb-csl-symbian-20060226-branch:1.19.0.18
	gdb-csl-symbian-20060226-branchpoint:1.19
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.19
	msnyder-reverse-20060331-branch:1.19.0.16
	msnyder-reverse-20060331-branchpoint:1.19
	binutils-csl-2_17-branch:1.19.0.14
	binutils-csl-2_17-branchpoint:1.19
	gdb-csl-available-20060303-branch:1.19.0.12
	gdb-csl-available-20060303-branchpoint:1.19
	gdb-csl-20060226-branch:1.19.0.10
	gdb-csl-20060226-branchpoint:1.19
	gdb_6_4-20051202-release:1.19
	msnyder-fork-checkpoint-branch:1.19.0.8
	msnyder-fork-checkpoint-branchpoint:1.19
	gdb-csl-gxxpro-6_3-branch:1.19.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.19
	gdb_6_4-branch:1.19.0.4
	gdb_6_4-2005-11-01-branchpoint:1.19
	gdb-csl-arm-20051020-branch:1.19.0.2
	gdb-csl-arm-20051020-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.14.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.14
	binutils-2_16_1:1.14
	msnyder-tracepoint-checkpoint-branch:1.16.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.16
	gdb-csl-arm-20050325-2005-q1b:1.14
	binutils-csl-arm-2005q1b:1.14
	binutils-2_16:1.14
	gdb-csl-arm-20050325-2005-q1a:1.14
	binutils-csl-arm-2005q1a:1.14
	csl-arm-20050325-branch:1.14.0.6
	csl-arm-20050325-branchpoint:1.14
	binutils-csl-arm-2005q1-branch:1.14.0.4
	binutils-csl-arm-2005q1-branchpoint:1.14
	binutils-2_16-branch:1.14.0.2
	binutils-2_16-branchpoint:1.14
	csl-arm-2004-q3d:1.12
	gdb_6_3-20041109-release:1.12
	gdb_6_3-branch:1.12.0.24
	gdb_6_3-20041019-branchpoint:1.12
	csl-arm-2004-q3:1.12
	drow_intercu-merge-20040921:1.12
	drow_intercu-merge-20040915:1.12
	jimb-gdb_6_2-e500-branch:1.12.0.26
	jimb-gdb_6_2-e500-branchpoint:1.12
	gdb_6_2-20040730-release:1.12
	gdb_6_2-branch:1.12.0.22
	gdb_6_2-2004-07-10-gmt-branchpoint:1.12
	gdb_6_1_1-20040616-release:1.12
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	gdb_6_1-2004-04-05-release:1.12
	drow_intercu-merge-20040402:1.12
	drow_intercu-merge-20040327:1.12
	ezannoni_pie-20040323-branch:1.12.0.20
	ezannoni_pie-20040323-branchpoint:1.12
	cagney_tramp-20040321-mergepoint:1.12
	cagney_tramp-20040309-branch:1.12.0.18
	cagney_tramp-20040309-branchpoint:1.12
	gdb_6_1-branch:1.12.0.16
	gdb_6_1-2004-03-01-gmt-branchpoint:1.12
	drow_intercu-20040221-branch:1.12.0.14
	drow_intercu-20040221-branchpoint:1.12
	binutils-2_15-branch:1.12.0.12
	cagney_bfdfile-20040213-branch:1.12.0.10
	cagney_bfdfile-20040213-branchpoint:1.12
	drow-cplus-merge-20040208:1.12
	carlton_dictionary-20040126-merge:1.12
	cagney_bigcore-20040122-branch:1.12.0.8
	cagney_bigcore-20040122-branchpoint:1.12
	drow-cplus-merge-20040113:1.12
	csl-arm-2003-q4:1.12
	drow-cplus-merge-20031224:1.12
	drow-cplus-merge-20031220:1.12
	carlton_dictionary-20031215-merge:1.12
	drow-cplus-merge-20031214:1.12
	carlton-dictionary-20031111-merge:1.12
	gdb_6_0-2003-10-04-release:1.11
	kettenis_sparc-20030918-branch:1.12.0.6
	kettenis_sparc-20030918-branchpoint:1.12
	carlton_dictionary-20030917-merge:1.12
	ezannoni_pie-20030916-branchpoint:1.12
	ezannoni_pie-20030916-branch:1.12.0.4
	cagney_x86i386-20030821-branch:1.12.0.2
	cagney_x86i386-20030821-branchpoint:1.12
	carlton_dictionary-20030805-merge:1.12
	carlton_dictionary-20030627-merge:1.11
	gdb_6_0-branch:1.11.0.44
	gdb_6_0-2003-06-23-branchpoint:1.11
	jimb-ppc64-linux-20030613-branch:1.11.0.42
	jimb-ppc64-linux-20030613-branchpoint:1.11
	binutils-2_14:1.11
	cagney_convert-20030606-branch:1.11.0.40
	cagney_convert-20030606-branchpoint:1.11
	cagney_writestrings-20030508-branch:1.11.0.38
	cagney_writestrings-20030508-branchpoint:1.11
	jimb-ppc64-linux-20030528-branch:1.11.0.36
	jimb-ppc64-linux-20030528-branchpoint:1.11
	carlton_dictionary-20030523-merge:1.11
	cagney_fileio-20030521-branch:1.11.0.34
	cagney_fileio-20030521-branchpoint:1.11
	kettenis_i386newframe-20030517-mergepoint:1.11
	jimb-ppc64-linux-20030509-branch:1.11.0.32
	jimb-ppc64-linux-20030509-branchpoint:1.11
	kettenis_i386newframe-20030504-mergepoint:1.11
	carlton_dictionary-20030430-merge:1.11
	binutils-2_14-branch:1.11.0.30
	binutils-2_14-branchpoint:1.11
	kettenis_i386newframe-20030419-branch:1.11.0.28
	kettenis_i386newframe-20030419-branchpoint:1.11
	carlton_dictionary-20030416-merge:1.11
	cagney_frameaddr-20030409-mergepoint:1.11
	kettenis_i386newframe-20030406-branch:1.11.0.26
	kettenis_i386newframe-20030406-branchpoint:1.11
	cagney_frameaddr-20030403-branchpoint:1.11
	cagney_frameaddr-20030403-branch:1.11.0.24
	cagney_framebase-20030330-mergepoint:1.11
	cagney_framebase-20030326-branch:1.11.0.22
	cagney_framebase-20030326-branchpoint:1.11
	cagney_lazyid-20030317-branch:1.11.0.20
	cagney_lazyid-20030317-branchpoint:1.11
	kettenis-i386newframe-20030316-mergepoint:1.11
	offbyone-20030313-branch:1.11.0.18
	offbyone-20030313-branchpoint:1.11
	kettenis-i386newframe-20030308-branch:1.11.0.16
	kettenis-i386newframe-20030308-branchpoint:1.11
	carlton_dictionary-20030305-merge:1.11
	cagney_offbyone-20030303-branch:1.11.0.14
	cagney_offbyone-20030303-branchpoint:1.11
	carlton_dictionary-20030207-merge:1.11
	interps-20030202-branch:1.11.0.12
	interps-20030202-branchpoint:1.11
	cagney-unwind-20030108-branch:1.11.0.10
	cagney-unwind-20030108-branchpoint:1.11
	binutils-2_13_2_1:1.10.4.1
	binutils-2_13_2:1.10.4.1
	carlton_dictionary-20021223-merge:1.11
	gdb_5_3-2002-12-12-release:1.11
	carlton_dictionary-20021115-merge:1.11
	binutils-2_13_1:1.10.4.1
	kseitz_interps-20021105-merge:1.11
	kseitz_interps-20021103-merge:1.11
	drow-cplus-merge-20021020:1.11
	drow-cplus-merge-20021025:1.11
	carlton_dictionary-20021025-merge:1.11
	carlton_dictionary-20021011-merge:1.11
	drow-cplus-branch:1.11.0.8
	drow-cplus-branchpoint:1.11
	kseitz_interps-20020930-merge:1.11
	carlton_dictionary-20020927-merge:1.11
	carlton_dictionary-branch:1.11.0.6
	carlton_dictionary-20020920-branchpoint:1.11
	sid-20020905-branchpoint:1.11
	sid-20020905-branch:1.11.0.4
	gdb_5_3-branch:1.11.0.2
	gdb_5_3-2002-09-04-branchpoint:1.11
	kseitz_interps-20020829-merge:1.11
	cagney_sysregs-20020825-branch:1.10.0.8
	cagney_sysregs-20020825-branchpoint:1.10
	readline_4_3-import-branch:1.10.0.6
	readline_4_3-import-branchpoint:1.10
	binutils-2_13:1.10
	gdb_5_2_1-2002-07-23-release:1.9
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.4
	kseitz_interps-20020528-branch:1.10.0.2
	kseitz_interps-20020528-branchpoint:1.10
	cagney_regbuf-20020515-branch:1.9.0.8
	cagney_regbuf-20020515-branchpoint:1.9
	binutils-2_12_1:1.9
	jimb-macro-020506-branch:1.9.0.6
	jimb-macro-020506-branchpoint:1.9
	gdb_5_2-2002-04-29-release:1.9
	binutils-2_12:1.9
	gdb_5_2-branch:1.9.0.4
	gdb_5_2-2002-03-03-branchpoint:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	gdb_5_1_1-2002-01-24-release:1.7
	gdb_5_1_0_1-2002-01-03-release:1.7
	cygnus_cvs_20020108_pre:1.7
	gdb_5_1_0_1-2002-01-03-branch:1.7.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.7
	gdb_5_1-2001-11-21-release:1.7
	gdb_s390-2001-09-26-branch:1.7.0.4
	gdb_s390-2001-09-26-branchpoint:1.7
	gdb_5_1-2001-07-29-branch:1.7.0.2
	gdb_5_1-2001-07-29-branchpoint:1.7
	binutils-2_11_2:1.6.2.1
	binutils-2_11_1:1.6.2.1
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	insight-precleanup-2001-01-01:1.4
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.26
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2013.10.14.09.15.09;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2012.02.27.07.03.00;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.28.12.15.51;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.02.07.18.38;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2007.10.15.02.00.28;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.03.14.26.43;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.07.24.16.57.42;	author drow;	state Exp;
branches;
next	1.18;

1.18
date	2005.07.22.23.54.56;	author dj;	state Exp;
branches;
next	1.17;

1.17
date	2005.07.22.18.16.17;	author kazu;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.04.15.53.42;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.04.07.19.45;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.03.11.41.02;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.31.23.13.33;	author bje;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.29.10.06.40;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.29.14.37.19;	author danglin;	state Exp;
branches
	1.11.6.1
	1.11.8.1;
next	1.10;

1.10
date	2002.05.25.12.50.18;	author amodra;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;

1.9
date	2002.02.01.09.22.53;	author amodra;	state Exp;
branches
	1.9.8.1;
next	1.8;

1.8
date	2002.01.31.06.23.17;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.25.20.12.49;	author kazu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.01.24.22.38.31;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.08.23.46.41;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.07.20.22.50;	author kazu;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.08.12.00.26;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.11.6.1
date	2003.08.05.17.12.56;	author carlton;	state Exp;
branches;
next	;

1.11.8.1
date	2003.12.14.20.26.54;	author drow;	state Exp;
branches;
next	;

1.10.2.1
date	2002.08.30.22.52.38;	author kseitz;	state Exp;
branches;
next	;

1.10.4.1
date	2002.09.23.22.08.56;	author drow;	state Exp;
branches;
next	;

1.9.8.1
date	2002.06.15.16.42.44;	author cagney;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.08.27;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.26
log
@	* gen-aout.c (main): Fix formatting.  Close file.

	* emultempl/aix.em (_read_file): Close file at end of function.

	* gas/all/itbl-test.c (main): Close fas.

	* read.c (add_include_dir): Use xrealloc.
	* config/tc-score.c (do_macro_bcmp): Initialise inst_main.
	* config/tc-tic6x.c (tic6x_parse_operand): Initialise second_reg.

	* readelf.c (decode_arm_unwind): Initialise addr structure.
	(process_symbol_table): Free lengths.
	* srcconv.c (wr_sc): Free info.

	* chew.c (perform): Free next.
@
text
@/* chew
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001,
   2002, 2003, 2005, 2007, 2009, 2012
   Free Software Foundation, Inc.
   Contributed by steve chamberlain @@cygnus

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/* Yet another way of extracting documentation from source.
   No, I haven't finished it yet, but I hope you people like it better
   than the old way

   sac

   Basically, this is a sort of string forth, maybe we should call it
   struth?

   You define new words thus:
   : <newword> <oldwords> ;

*/

/* Primitives provided by the program:

   Two stacks are provided, a string stack and an integer stack.

   Internal state variables:
	internal_wanted - indicates whether `-i' was passed
	internal_mode - user-settable

   Commands:
	push_text
	! - pop top of integer stack for address, pop next for value; store
	@@ - treat value on integer stack as the address of an integer; push
		that integer on the integer stack after popping the "address"
	hello - print "hello\n" to stdout
	stdout - put stdout marker on TOS
	stderr - put stderr marker on TOS
	print - print TOS-1 on TOS (eg: "hello\n" stdout print)
	skip_past_newline
	catstr - fn icatstr
	copy_past_newline - append input, up to and including newline into TOS
	dup - fn other_dup
	drop - discard TOS
	idrop - ditto
	remchar - delete last character from TOS
	get_stuff_in_command
	do_fancy_stuff - translate <<foo>> to @@code{foo} in TOS
	bulletize - if "o" lines found, prepend @@itemize @@bullet to TOS
		and @@item to each "o" line; append @@end itemize
	courierize - put @@example around . and | lines, translate {* *} { }
	exit - fn chew_exit
	swap
	outputdots - strip out lines without leading dots
	paramstuff - convert full declaration into "PARAMS" form if not already
	maybecatstr - do catstr if internal_mode == internal_wanted, discard
		value in any case
	translatecomments - turn {* and *} into comment delimiters
	kill_bogus_lines - get rid of extra newlines
	indent
	internalmode - pop from integer stack, set `internalmode' to that value
	print_stack_level - print current stack depth to stderr
	strip_trailing_newlines - go ahead, guess...
	[quoted string] - push string onto string stack
	[word starting with digit] - push atol(str) onto integer stack

   A command must be all upper-case, and alone on a line.

   Foo.  */

#include "ansidecl.h"
#include <assert.h>
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

#define DEF_SIZE 5000
#define STACK 50

int internal_wanted;
int internal_mode;

int warning;

/* Here is a string type ...  */

typedef struct buffer
{
  char *ptr;
  unsigned long write_idx;
  unsigned long size;
} string_type;

#ifdef __STDC__
static void init_string_with_size (string_type *, unsigned int);
static void init_string (string_type *);
static int find (string_type *, char *);
static void write_buffer (string_type *, FILE *);
static void delete_string (string_type *);
static char *addr (string_type *, unsigned int);
static char at (string_type *, unsigned int);
static void catchar (string_type *, int);
static void overwrite_string (string_type *, string_type *);
static void catbuf (string_type *, char *, unsigned int);
static void cattext (string_type *, char *);
static void catstr (string_type *, string_type *);
static void die (char *);
#endif

static void
init_string_with_size (buffer, size)
     string_type *buffer;
     unsigned int size;
{
  buffer->write_idx = 0;
  buffer->size = size;
  buffer->ptr = (char *) malloc (size);
}

static void
init_string (buffer)
     string_type *buffer;
{
  init_string_with_size (buffer, DEF_SIZE);
}

static int
find (str, what)
     string_type *str;
     char *what;
{
  unsigned int i;
  char *p;
  p = what;
  for (i = 0; i < str->write_idx && *p; i++)
    {
      if (*p == str->ptr[i])
	p++;
      else
	p = what;
    }
  return (*p == 0);
}

static void
write_buffer (buffer, f)
     string_type *buffer;
     FILE *f;
{
  if (buffer->write_idx != 0
      && fwrite (buffer->ptr, buffer->write_idx, 1, f) != 1)
    die ("cannot write output");
}

static void
delete_string (buffer)
     string_type *buffer;
{
  free (buffer->ptr);
}

static char *
addr (buffer, idx)
     string_type *buffer;
     unsigned int idx;
{
  return buffer->ptr + idx;
}

static char
at (buffer, pos)
     string_type *buffer;
     unsigned int pos;
{
  if (pos >= buffer->write_idx)
    return 0;
  return buffer->ptr[pos];
}

static void
catchar (buffer, ch)
     string_type *buffer;
     int ch;
{
  if (buffer->write_idx == buffer->size)
    {
      buffer->size *= 2;
      buffer->ptr = (char *) realloc (buffer->ptr, buffer->size);
    }

  buffer->ptr[buffer->write_idx++] = ch;
}

static void
overwrite_string (dst, src)
     string_type *dst;
     string_type *src;
{
  free (dst->ptr);
  dst->size = src->size;
  dst->write_idx = src->write_idx;
  dst->ptr = src->ptr;
}

static void
catbuf (buffer, buf, len)
     string_type *buffer;
     char *buf;
     unsigned int len;
{
  if (buffer->write_idx + len >= buffer->size)
    {
      while (buffer->write_idx + len >= buffer->size)
	buffer->size *= 2;
      buffer->ptr = (char *) realloc (buffer->ptr, buffer->size);
    }
  memcpy (buffer->ptr + buffer->write_idx, buf, len);
  buffer->write_idx += len;
}

static void
cattext (buffer, string)
     string_type *buffer;
     char *string;
{
  catbuf (buffer, string, (unsigned int) strlen (string));
}

static void
catstr (dst, src)
     string_type *dst;
     string_type *src;
{
  catbuf (dst, src->ptr, src->write_idx);
}

static unsigned int
skip_white_and_stars (src, idx)
     string_type *src;
     unsigned int idx;
{
  char c;
  while ((c = at (src, idx)),
	 isspace ((unsigned char) c)
	 || (c == '*'
	     /* Don't skip past end-of-comment or star as first
		character on its line.  */
	     && at (src, idx +1) != '/'
	     && at (src, idx -1) != '\n'))
    idx++;
  return idx;
}

/***********************************************************************/

string_type stack[STACK];
string_type *tos;

unsigned int idx = 0; /* Pos in input buffer */
string_type *ptr; /* and the buffer */
typedef void (*stinst_type)();
stinst_type *pc;
stinst_type sstack[STACK];
stinst_type *ssp = &sstack[0];
long istack[STACK];
long *isp = &istack[0];

typedef int *word_type;

struct dict_struct
{
  char *word;
  struct dict_struct *next;
  stinst_type *code;
  int code_length;
  int code_end;
  int var;
};

typedef struct dict_struct dict_type;

static void
die (msg)
     char *msg;
{
  fprintf (stderr, "%s\n", msg);
  exit (1);
}

static void
check_range ()
{
  if (tos < stack)
    die ("underflow in string stack");
  if (tos >= stack + STACK)
    die ("overflow in string stack");
}

static void
icheck_range ()
{
  if (isp < istack)
    die ("underflow in integer stack");
  if (isp >= istack + STACK)
    die ("overflow in integer stack");
}

#ifdef __STDC__
static void exec (dict_type *);
static void call (void);
static void remchar (void), strip_trailing_newlines (void), push_number (void);
static void push_text (void);
static void remove_noncomments (string_type *, string_type *);
static void print_stack_level (void);
static void paramstuff (void), translatecomments (void);
static void outputdots (void), courierize (void), bulletize (void);
static void do_fancy_stuff (void);
static int iscommand (string_type *, unsigned int);
static int copy_past_newline (string_type *, unsigned int, string_type *);
static void icopy_past_newline (void), kill_bogus_lines (void), indent (void);
static void get_stuff_in_command (void), swap (void), other_dup (void);
static void drop (void), idrop (void);
static void icatstr (void), skip_past_newline (void), internalmode (void);
static void maybecatstr (void);
static char *nextword (char *, char **);
dict_type *lookup_word (char *);
static void perform (void);
dict_type *newentry (char *);
unsigned int add_to_definition (dict_type *, stinst_type);
void add_intrinsic (char *, void (*)());
void add_var (char *);
void compile (char *);
static void bang (void);
static void atsign (void);
static void hello (void);
static void stdout_ (void);
static void stderr_ (void);
static void print (void);
static void read_in (string_type *, FILE *);
static void usage (void);
static void chew_exit (void);
#endif

static void
exec (word)
     dict_type *word;
{
  pc = word->code;
  while (*pc)
    (*pc) ();
}

static void
call ()
{
  stinst_type *oldpc = pc;
  dict_type *e;
  e = (dict_type *) (pc[1]);
  exec (e);
  pc = oldpc + 2;
}

static void
remchar ()
{
  if (tos->write_idx)
    tos->write_idx--;
  pc++;
}

static void
strip_trailing_newlines ()
{
  while ((isspace ((unsigned char) at (tos, tos->write_idx - 1))
	  || at (tos, tos->write_idx - 1) == '\n')
	 && tos->write_idx > 0)
    tos->write_idx--;
  pc++;
}

static void
push_number ()
{
  isp++;
  icheck_range ();
  pc++;
  *isp = (long) (*pc);
  pc++;
}

static void
push_text ()
{
  tos++;
  check_range ();
  init_string (tos);
  pc++;
  cattext (tos, *((char **) pc));
  pc++;
}

/* This function removes everything not inside comments starting on
   the first char of the line from the  string, also when copying
   comments, removes blank space and leading *'s.
   Blank lines are turned into one blank line.  */

static void
remove_noncomments (src, dst)
     string_type *src;
     string_type *dst;
{
  unsigned int idx = 0;

  while (at (src, idx))
    {
      /* Now see if we have a comment at the start of the line.  */
      if (at (src, idx) == '\n'
	  && at (src, idx + 1) == '/'
	  && at (src, idx + 2) == '*')
	{
	  idx += 3;

	  idx = skip_white_and_stars (src, idx);

	  /* Remove leading dot */
	  if (at (src, idx) == '.')
	    idx++;

	  /* Copy to the end of the line, or till the end of the
	     comment.  */
	  while (at (src, idx))
	    {
	      if (at (src, idx) == '\n')
		{
		  /* end of line, echo and scrape of leading blanks  */
		  if (at (src, idx + 1) == '\n')
		    catchar (dst, '\n');
		  catchar (dst, '\n');
		  idx++;
		  idx = skip_white_and_stars (src, idx);
		}
	      else if (at (src, idx) == '*' && at (src, idx + 1) == '/')
		{
		  idx += 2;
		  cattext (dst, "\nENDDD\n");
		  break;
		}
	      else
		{
		  catchar (dst, at (src, idx));
		  idx++;
		}
	    }
	}
      else
	idx++;
    }
}

static void
print_stack_level ()
{
  fprintf (stderr, "current string stack depth = %ld, ", tos - stack);
  fprintf (stderr, "current integer stack depth = %ld\n", isp - istack);
  pc++;
}

/* turn:
     foobar name(stuff);
   into:
     foobar
     name PARAMS ((stuff));
   and a blank line.
 */

static void
paramstuff ()
{
  unsigned int openp;
  unsigned int fname;
  unsigned int idx;
  unsigned int len;
  string_type out;
  init_string (&out);

#define NO_PARAMS 1

  /* Make sure that it's not already param'd or proto'd.  */
  if (NO_PARAMS
      || find (tos, "PARAMS") || find (tos, "PROTO") || !find (tos, "("))
    {
      catstr (&out, tos);
    }
  else
    {
      /* Find the open paren.  */
      for (openp = 0; at (tos, openp) != '(' && at (tos, openp); openp++)
	;

      fname = openp;
      /* Step back to the fname.  */
      fname--;
      while (fname && isspace ((unsigned char) at (tos, fname)))
	fname--;
      while (fname
	     && !isspace ((unsigned char) at (tos,fname))
	     && at (tos,fname) != '*')
	fname--;

      fname++;

      /* Output type, omitting trailing whitespace character(s), if
         any.  */
      for (len = fname; 0 < len; len--)
	{
	  if (!isspace ((unsigned char) at (tos, len - 1)))
	    break;
	}
      for (idx = 0; idx < len; idx++)
	catchar (&out, at (tos, idx));

      cattext (&out, "\n");	/* Insert a newline between type and fnname */

      /* Output function name, omitting trailing whitespace
         character(s), if any.  */
      for (len = openp; 0 < len; len--)
	{
	  if (!isspace ((unsigned char) at (tos, len - 1)))
	    break;
	}
      for (idx = fname; idx < len; idx++)
	catchar (&out, at (tos, idx));

      cattext (&out, " PARAMS (");

      for (idx = openp; at (tos, idx) && at (tos, idx) != ';'; idx++)
	catchar (&out, at (tos, idx));

      cattext (&out, ");\n\n");
    }
  overwrite_string (tos, &out);
  pc++;

}

/* turn {*
   and *} into comments */

static void
translatecomments ()
{
  unsigned int idx = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '{' && at (tos, idx + 1) == '*')
	{
	  cattext (&out, "/*");
	  idx += 2;
	}
      else if (at (tos, idx) == '*' && at (tos, idx + 1) == '}')
	{
	  cattext (&out, "*/");
	  idx += 2;
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
    }

  overwrite_string (tos, &out);

  pc++;
}

/* Mod tos so that only lines with leading dots remain */
static void
outputdots ()
{
  unsigned int idx = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '\n' && at (tos, idx + 1) == '.')
	{
	  char c;
	  idx += 2;

	  while ((c = at (tos, idx)) && c != '\n')
	    {
	      if (c == '{' && at (tos, idx + 1) == '*')
		{
		  cattext (&out, "/*");
		  idx += 2;
		}
	      else if (c == '*' && at (tos, idx + 1) == '}')
		{
		  cattext (&out, "*/");
		  idx += 2;
		}
	      else
		{
		  catchar (&out, c);
		  idx++;
		}
	    }
	  catchar (&out, '\n');
	}
      else
	{
	  idx++;
	}
    }

  overwrite_string (tos, &out);
  pc++;
}

/* Find lines starting with . and | and put example around them on tos */
static void
courierize ()
{
  string_type out;
  unsigned int idx = 0;
  int command = 0;

  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '\n'
	  && (at (tos, idx +1 ) == '.'
	      || at (tos, idx + 1) == '|'))
	{
	  cattext (&out, "\n@@example\n");
	  do
	    {
	      idx += 2;

	      while (at (tos, idx) && at (tos, idx) != '\n')
		{
		  if (command > 1)
		    {
		      /* We are inside {} parameters of some command;
			 Just pass through until matching brace.  */
		      if (at (tos, idx) == '{')
			++command;
		      else if (at (tos, idx) == '}')
			--command;
		    }
		  else if (command != 0)
		    {
		      if (at (tos, idx) == '{')
			++command;
		      else if (!islower ((unsigned char) at (tos, idx)))
			--command;
		    }
		  else if (at (tos, idx) == '@@'
			   && islower ((unsigned char) at (tos, idx + 1)))
		    {
		      ++command;
		    }
		  else if (at (tos, idx) == '{' && at (tos, idx + 1) == '*')
		    {
		      cattext (&out, "/*");
		      idx += 2;
		      continue;
		    }
		  else if (at (tos, idx) == '*' && at (tos, idx + 1) == '}')
		    {
		      cattext (&out, "*/");
		      idx += 2;
		      continue;
		    }
		  else if (at (tos, idx) == '{'
			   || at (tos, idx) == '}')
		    {
		      catchar (&out, '@@');
		    }

		  catchar (&out, at (tos, idx));
		  idx++;
		}
	      catchar (&out, '\n');
	    }
	  while (at (tos, idx) == '\n'
		 && ((at (tos, idx + 1) == '.')
		     || (at (tos, idx + 1) == '|')))
	    ;
	  cattext (&out, "@@end example");
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
    }

  overwrite_string (tos, &out);
  pc++;
}

/* Finds any lines starting with "o ", if there are any, then turns
   on @@itemize @@bullet, and @@items each of them. Then ends with @@end
   itemize, inplace at TOS*/

static void
bulletize ()
{
  unsigned int idx = 0;
  int on = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '@@'
	  && at (tos, idx + 1) == '*')
	{
	  cattext (&out, "*");
	  idx += 2;
	}
      else if (at (tos, idx) == '\n'
	       && at (tos, idx + 1) == 'o'
	       && isspace ((unsigned char) at (tos, idx + 2)))
	{
	  if (!on)
	    {
	      cattext (&out, "\n@@itemize @@bullet\n");
	      on = 1;

	    }
	  cattext (&out, "\n@@item\n");
	  idx += 3;
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  if (on && at (tos, idx) == '\n'
	      && at (tos, idx + 1) == '\n'
	      && at (tos, idx + 2) != 'o')
	    {
	      cattext (&out, "@@end itemize");
	      on = 0;
	    }
	  idx++;

	}
    }
  if (on)
    {
      cattext (&out, "@@end itemize\n");
    }

  delete_string (tos);
  *tos = out;
  pc++;
}

/* Turn <<foo>> into @@code{foo} in place at TOS*/

static void
do_fancy_stuff ()
{
  unsigned int idx = 0;
  string_type out;
  init_string (&out);
  while (at (tos, idx))
    {
      if (at (tos, idx) == '<'
	  && at (tos, idx + 1) == '<'
	  && !isspace ((unsigned char) at (tos, idx + 2)))
	{
	  /* This qualifies as a << startup.  */
	  idx += 2;
	  cattext (&out, "@@code{");
	  while (at (tos, idx)
		 && at (tos, idx) != '>' )
	    {
	      catchar (&out, at (tos, idx));
	      idx++;

	    }
	  cattext (&out, "}");
	  idx += 2;
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
    }
  delete_string (tos);
  *tos = out;
  pc++;

}

/* A command is all upper case,and alone on a line.  */

static int
iscommand (ptr, idx)
     string_type *ptr;
     unsigned int idx;
{
  unsigned int len = 0;
  while (at (ptr, idx))
    {
      if (isupper ((unsigned char) at (ptr, idx))
	  || at (ptr, idx) == ' ' || at (ptr, idx) == '_')
	{
	  len++;
	  idx++;
	}
      else if (at (ptr, idx) == '\n')
	{
	  if (len > 3)
	    return 1;
	  return 0;
	}
      else
	return 0;
    }
  return 0;
}

static int
copy_past_newline (ptr, idx, dst)
     string_type *ptr;
     unsigned int idx;
     string_type *dst;
{
  int column = 0;

  while (at (ptr, idx) && at (ptr, idx) != '\n')
    {
      if (at (ptr, idx) == '\t')
	{
	  /* Expand tabs.  Neither makeinfo nor TeX can cope well with
	     them.  */
	  do
	    catchar (dst, ' ');
	  while (++column & 7);
	}
      else
	{
	  catchar (dst, at (ptr, idx));
	  column++;
	}
      idx++;

    }
  catchar (dst, at (ptr, idx));
  idx++;
  return idx;

}

static void
icopy_past_newline ()
{
  tos++;
  check_range ();
  init_string (tos);
  idx = copy_past_newline (ptr, idx, tos);
  pc++;
}

/* indent
   Take the string at the top of the stack, do some prettying.  */

static void
kill_bogus_lines ()
{
  int sl;

  int idx = 0;
  int c;
  int dot = 0;

  string_type out;
  init_string (&out);
  /* Drop leading nl.  */
  while (at (tos, idx) == '\n')
    {
      idx++;
    }
  c = idx;

  /* If the first char is a '.' prepend a newline so that it is
     recognized properly later.  */
  if (at (tos, idx) == '.')
    catchar (&out, '\n');

  /* Find the last char.  */
  while (at (tos, idx))
    {
      idx++;
    }

  /* Find the last non white before the nl.  */
  idx--;

  while (idx && isspace ((unsigned char) at (tos, idx)))
    idx--;
  idx++;

  /* Copy buffer upto last char, but blank lines before and after
     dots don't count.  */
  sl = 1;

  while (c < idx)
    {
      if (at (tos, c) == '\n'
	  && at (tos, c + 1) == '\n'
	  && at (tos, c + 2) == '.')
	{
	  /* Ignore two newlines before a dot.  */
	  c++;
	}
      else if (at (tos, c) == '.' && sl)
	{
	  /* remember that this line started with a dot.  */
	  dot = 2;
	}
      else if (at (tos, c) == '\n'
	       && at (tos, c + 1) == '\n'
	       && dot)
	{
	  c++;
	  /* Ignore two newlines when last line was dot.  */
	}

      catchar (&out, at (tos, c));
      if (at (tos, c) == '\n')
	{
	  sl = 1;

	  if (dot == 2)
	    dot = 1;
	  else
	    dot = 0;
	}
      else
	sl = 0;

      c++;

    }

  /* Append nl.  */
  catchar (&out, '\n');
  pc++;
  delete_string (tos);
  *tos = out;

}

static void
indent ()
{
  string_type out;
  int tab = 0;
  int idx = 0;
  int ol = 0;
  init_string (&out);
  while (at (tos, idx))
    {
      switch (at (tos, idx))
	{
	case '\n':
	  cattext (&out, "\n");
	  idx++;
	  if (tab && at (tos, idx))
	    {
	      cattext (&out, "    ");
	    }
	  ol = 0;
	  break;
	case '(':
	  tab++;
	  if (ol == 0)
	    cattext (&out, "   ");
	  idx++;
	  cattext (&out, "(");
	  ol = 1;
	  break;
	case ')':
	  tab--;
	  cattext (&out, ")");
	  idx++;
	  ol = 1;

	  break;
	default:
	  catchar (&out, at (tos, idx));
	  ol = 1;

	  idx++;
	  break;
	}
    }

  pc++;
  delete_string (tos);
  *tos = out;

}

static void
get_stuff_in_command ()
{
  tos++;
  check_range ();
  init_string (tos);

  while (at (ptr, idx))
    {
      if (iscommand (ptr, idx))
	break;
      idx = copy_past_newline (ptr, idx, tos);
    }
  pc++;
}

static void
swap ()
{
  string_type t;

  t = tos[0];
  tos[0] = tos[-1];
  tos[-1] = t;
  pc++;
}

static void
other_dup ()
{
  tos++;
  check_range ();
  init_string (tos);
  catstr (tos, tos - 1);
  pc++;
}

static void
drop ()
{
  tos--;
  check_range ();
  pc++;
}

static void
idrop ()
{
  isp--;
  icheck_range ();
  pc++;
}

static void
icatstr ()
{
  tos--;
  check_range ();
  catstr (tos, tos + 1);
  delete_string (tos + 1);
  pc++;
}

static void
skip_past_newline ()
{
  while (at (ptr, idx)
	 && at (ptr, idx) != '\n')
    idx++;
  idx++;
  pc++;
}

static void
internalmode ()
{
  internal_mode = *(isp);
  isp--;
  icheck_range ();
  pc++;
}

static void
maybecatstr ()
{
  if (internal_wanted == internal_mode)
    {
      catstr (tos - 1, tos);
    }
  delete_string (tos);
  tos--;
  check_range ();
  pc++;
}

char *
nextword (string, word)
     char *string;
     char **word;
{
  char *word_start;
  int idx;
  char *dst;
  char *src;

  int length = 0;

  while (isspace ((unsigned char) *string) || *string == '-')
    {
      if (*string == '-')
	{
	  while (*string && *string != '\n')
	    string++;

	}
      else
	{
	  string++;
	}
    }
  if (!*string)
    return 0;

  word_start = string;
  if (*string == '"')
    {
      do
	{
	  string++;
	  length++;
	  if (*string == '\\')
	    {
	      string += 2;
	      length += 2;
	    }
	}
      while (*string != '"');
    }
  else
    {
      while (!isspace ((unsigned char) *string))
	{
	  string++;
	  length++;

	}
    }

  *word = (char *) malloc (length + 1);

  dst = *word;
  src = word_start;

  for (idx = 0; idx < length; idx++)
    {
      if (src[idx] == '\\')
	switch (src[idx + 1])
	  {
	  case 'n':
	    *dst++ = '\n';
	    idx++;
	    break;
	  case '"':
	  case '\\':
	    *dst++ = src[idx + 1];
	    idx++;
	    break;
	  default:
	    *dst++ = '\\';
	    break;
	  }
      else
	*dst++ = src[idx];
    }
  *dst++ = 0;

  if (*string)
    return string + 1;
  else
    return 0;
}

dict_type *root;

dict_type *
lookup_word (word)
     char *word;
{
  dict_type *ptr = root;
  while (ptr)
    {
      if (strcmp (ptr->word, word) == 0)
	return ptr;
      ptr = ptr->next;
    }
  if (warning)
    fprintf (stderr, "Can't find %s\n", word);
  return 0;
}

static void
perform ()
{
  tos = stack;

  while (at (ptr, idx))
    {
      /* It's worth looking through the command list.  */
      if (iscommand (ptr, idx))
	{
	  char *next;
	  dict_type *word;

	  (void) nextword (addr (ptr, idx), &next);

	  word = lookup_word (next);

	  if (word)
	    {
	      exec (word);
	    }
	  else
	    {
	      if (warning)
		fprintf (stderr, "warning, %s is not recognised\n", next);
	      skip_past_newline ();
	    }
	  free (next);
	}
      else
	skip_past_newline ();
    }
}

dict_type *
newentry (word)
     char *word;
{
  dict_type *new_d = (dict_type *) malloc (sizeof (dict_type));
  new_d->word = word;
  new_d->next = root;
  root = new_d;
  new_d->code = (stinst_type *) malloc (sizeof (stinst_type));
  new_d->code_length = 1;
  new_d->code_end = 0;
  return new_d;
}

unsigned int
add_to_definition (entry, word)
     dict_type *entry;
     stinst_type word;
{
  if (entry->code_end == entry->code_length)
    {
      entry->code_length += 2;
      entry->code =
	(stinst_type *) realloc ((char *) (entry->code),
				 entry->code_length * sizeof (word_type));
    }
  entry->code[entry->code_end] = word;

  return entry->code_end++;
}

void
add_intrinsic (name, func)
     char *name;
     void (*func) ();
{
  dict_type *new_d = newentry (name);
  add_to_definition (new_d, func);
  add_to_definition (new_d, 0);
}

void
add_var (name)
     char *name;
{
  dict_type *new_d = newentry (name);
  add_to_definition (new_d, push_number);
  add_to_definition (new_d, (stinst_type) (&(new_d->var)));
  add_to_definition (new_d, 0);
}

void
compile (string)
     char *string;
{
  /* Add words to the dictionary.  */
  char *word;
  string = nextword (string, &word);
  while (string && *string && word[0])
    {
      if (strcmp (word, "var") == 0)
	{
	  string = nextword (string, &word);

	  add_var (word);
	  string = nextword (string, &word);
	}
      else if (word[0] == ':')
	{
	  dict_type *ptr;
	  /* Compile a word and add to dictionary.  */
	  string = nextword (string, &word);

	  ptr = newentry (word);
	  string = nextword (string, &word);
	  while (word[0] != ';')
	    {
	      switch (word[0])
		{
		case '"':
		  /* got a string, embed magic push string
		     function */
		  add_to_definition (ptr, push_text);
		  add_to_definition (ptr, (stinst_type) (word + 1));
		  break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
		  /* Got a number, embedd the magic push number
		     function */
		  add_to_definition (ptr, push_number);
		  add_to_definition (ptr, (stinst_type) atol (word));
		  break;
		default:
		  add_to_definition (ptr, call);
		  add_to_definition (ptr, (stinst_type) lookup_word (word));
		}

	      string = nextword (string, &word);
	    }
	  add_to_definition (ptr, 0);
	  string = nextword (string, &word);
	}
      else
	{
	  fprintf (stderr, "syntax error at %s\n", string - 1);
	}
    }
}

static void
bang ()
{
  *(long *) ((isp[0])) = isp[-1];
  isp -= 2;
  icheck_range ();
  pc++;
}

static void
atsign ()
{
  isp[0] = *(long *) (isp[0]);
  pc++;
}

static void
hello ()
{
  printf ("hello\n");
  pc++;
}

static void
stdout_ ()
{
  isp++;
  icheck_range ();
  *isp = 1;
  pc++;
}

static void
stderr_ ()
{
  isp++;
  icheck_range ();
  *isp = 2;
  pc++;
}

static void
print ()
{
  if (*isp == 1)
    write_buffer (tos, stdout);
  else if (*isp == 2)
    write_buffer (tos, stderr);
  else
    fprintf (stderr, "print: illegal print destination `%ld'\n", *isp);
  isp--;
  tos--;
  icheck_range ();
  check_range ();
  pc++;
}

static void
read_in (str, file)
     string_type *str;
     FILE *file;
{
  char buff[10000];
  unsigned int r;
  do
    {
      r = fread (buff, 1, sizeof (buff), file);
      catbuf (str, buff, r);
    }
  while (r);
  buff[0] = 0;

  catbuf (str, buff, 1);
}

static void
usage ()
{
  fprintf (stderr, "usage: -[d|i|g] <file >file\n");
  exit (33);
}

/* There is no reliable way to declare exit.  Sometimes it returns
   int, and sometimes it returns void.  Sometimes it changes between
   OS releases.  Trying to get it declared correctly in the hosts file
   is a pointless waste of time.  */

static void
chew_exit ()
{
  exit (0);
}

int
main (ac, av)
     int ac;
     char *av[];
{
  unsigned int i;
  string_type buffer;
  string_type pptr;

  init_string (&buffer);
  init_string (&pptr);
  init_string (stack + 0);
  tos = stack + 1;
  ptr = &pptr;

  add_intrinsic ("push_text", push_text);
  add_intrinsic ("!", bang);
  add_intrinsic ("@@", atsign);
  add_intrinsic ("hello", hello);
  add_intrinsic ("stdout", stdout_);
  add_intrinsic ("stderr", stderr_);
  add_intrinsic ("print", print);
  add_intrinsic ("skip_past_newline", skip_past_newline);
  add_intrinsic ("catstr", icatstr);
  add_intrinsic ("copy_past_newline", icopy_past_newline);
  add_intrinsic ("dup", other_dup);
  add_intrinsic ("drop", drop);
  add_intrinsic ("idrop", idrop);
  add_intrinsic ("remchar", remchar);
  add_intrinsic ("get_stuff_in_command", get_stuff_in_command);
  add_intrinsic ("do_fancy_stuff", do_fancy_stuff);
  add_intrinsic ("bulletize", bulletize);
  add_intrinsic ("courierize", courierize);
  /* If the following line gives an error, exit() is not declared in the
     ../hosts/foo.h file for this host.  Fix it there, not here!  */
  /* No, don't fix it anywhere; see comment on chew_exit--Ian Taylor.  */
  add_intrinsic ("exit", chew_exit);
  add_intrinsic ("swap", swap);
  add_intrinsic ("outputdots", outputdots);
  add_intrinsic ("paramstuff", paramstuff);
  add_intrinsic ("maybecatstr", maybecatstr);
  add_intrinsic ("translatecomments", translatecomments);
  add_intrinsic ("kill_bogus_lines", kill_bogus_lines);
  add_intrinsic ("indent", indent);
  add_intrinsic ("internalmode", internalmode);
  add_intrinsic ("print_stack_level", print_stack_level);
  add_intrinsic ("strip_trailing_newlines", strip_trailing_newlines);

  /* Put a nl at the start.  */
  catchar (&buffer, '\n');

  read_in (&buffer, stdin);
  remove_noncomments (&buffer, ptr);
  for (i = 1; i < (unsigned int) ac; i++)
    {
      if (av[i][0] == '-')
	{
	  if (av[i][1] == 'f')
	    {
	      string_type b;
	      FILE *f;
	      init_string (&b);

	      f = fopen (av[i + 1], "r");
	      if (!f)
		{
		  fprintf (stderr, "Can't open the input file %s\n",
			   av[i + 1]);
		  return 33;
		}

	      read_in (&b, f);
	      compile (b.ptr);
	      perform ();
	    }
	  else if (av[i][1] == 'i')
	    {
	      internal_wanted = 1;
	    }
	  else if (av[i][1] == 'w')
	    {
	      warning = 1;
	    }
	  else
	    usage ();
	}
    }
  write_buffer (stack + 0, stdout);
  if (tos != stack)
    {
      fprintf (stderr, "finishing with current stack level %ld\n",
	       tos - stack);
      return 1;
    }
  return 0;
}
@


1.25
log
@	* chew.c (print_stack_level, main): Use %ld to print stack delta.
@
text
@d1259 1
a1259 1

@


1.24
log
@oops - omitted from previous delta
@
text
@d3 1
a3 1
   2002, 2003, 2005, 2007, 2009
d479 2
a480 2
  fprintf (stderr, "current string stack depth = %d, ", tos - stack);
  fprintf (stderr, "current integer stack depth = %d\n", isp - istack);
d1566 1
a1566 1
      fprintf (stderr, "finishing with current stack level %d\n",
@


1.23
log
@update copyright dates
@
text
@d133 1
a133 1
  buffer->ptr = malloc (size);
d204 1
a204 1
      buffer->ptr = realloc (buffer->ptr, buffer->size);
d231 1
a231 1
      buffer->ptr = realloc (buffer->ptr, buffer->size);
d1180 1
a1180 1
  *word = malloc (length + 1);
@


1.22
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2002, 2003, 2005, 2007
@


1.21
log
@	* chew.c (write_buffer): Check fwrite return value.
@
text
@d1270 8
a1277 8
  dict_type *new = (dict_type *) malloc (sizeof (dict_type));
  new->word = word;
  new->next = root;
  root = new;
  new->code = (stinst_type *) malloc (sizeof (stinst_type));
  new->code_length = 1;
  new->code_end = 0;
  return new;
d1302 3
a1304 3
  dict_type *new = newentry (name);
  add_to_definition (new, func);
  add_to_definition (new, 0);
d1311 4
a1314 4
  dict_type *new = newentry (name);
  add_to_definition (new, push_number);
  add_to_definition (new, (stinst_type) (&(new->var)));
  add_to_definition (new, 0);
@


1.20
log
@Switch sources over to use the GPL version 3
@
text
@d123 1
d166 3
a168 1
  fwrite (buffer->ptr, buffer->write_idx, 1, f);
@


1.19
log
@	* chew.c: Include <string.h>.
@
text
@d3 1
a3 1
   2002, 2003, 2005
d7 1
a7 1
This file is part of BFD, the Binary File Descriptor library.
d9 14
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.18
log
@* chew.c: Include stdlib.h.
@
text
@d90 1
@


1.17
log
@	* chew.c: Don't include sysdep.h.
@
text
@d89 1
@


1.16
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@a85 1
#include "sysdep.h"
@


1.15
log
@Update the FSF address in the copyright/GPL notice
@
text
@d21 1
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.14
log
@update copyright dates
@
text
@d21 1
a21 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.13
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2002, 2003
@


1.12
log
@Convert to C90 and a few tweaks.
@
text
@a590 39
#if 0

/* This is not currently used.  */

/* turn everything not starting with a . into a comment */

static void
manglecomments ()
{
  unsigned int idx = 0;
  string_type out;
  init_string (&out);

  while (at (tos, idx))
    {
      if (at (tos, idx) == '\n' && at (tos, idx + 1) == '*')
	{
	  cattext (&out, "	/*");
	  idx += 2;
	}
      else if (at (tos, idx) == '*' && at (tos, idx + 1) == '}')
	{
	  cattext (&out, "*/");
	  idx += 2;
	}
      else
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
    }

  overwrite_string (tos, &out);

  pc++;
}

#endif

@


1.11
log
@	* chew.c (paramstuff, outputdots, perform, bang and usage): Remove
	void from function definitions.
@
text
@d3 1
a3 1
   2002
d497 2
d500 2
a501 1
  if (find (tos, "PARAMS") || find (tos, "PROTO") || !find (tos, "("))
@


1.11.8.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2002, 2003
a496 2
#define NO_PARAMS 1

d498 1
a498 2
  if (NO_PARAMS
      || find (tos, "PARAMS") || find (tos, "PROTO") || !find (tos, "("))
@


1.11.6.1
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d3 1
a3 1
   2002, 2003
a496 2
#define NO_PARAMS 1

d498 1
a498 2
  if (NO_PARAMS
      || find (tos, "PARAMS") || find (tos, "PROTO") || !find (tos, "("))
@


1.10
log
@	* chew.c: Use #include "" instead of <> for local header files.
@
text
@d488 1
a488 1
paramstuff (void)
d629 1
a629 1
outputdots (void)
d1264 1
a1264 1
perform (void)
d1415 1
a1415 1
bang (void)
d1490 1
a1490 1
usage (void)
@


1.10.4.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-08-28  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* chew.c (paramstuff, outputdots, perform, bang and usage): Remove
	void from function definitions.
@
text
@d488 1
a488 1
paramstuff ()
d629 1
a629 1
outputdots ()
d1264 1
a1264 1
perform ()
d1415 1
a1415 1
bang ()
d1490 1
a1490 1
usage ()
@


1.10.2.1
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d488 1
a488 1
paramstuff ()
d629 1
a629 1
outputdots ()
d1264 1
a1264 1
perform ()
d1415 1
a1415 1
bang ()
d1490 1
a1490 1
usage ()
@


1.9
log
@	* chew.c (WORD): Eliminate.
@
text
@d85 1
a85 1
#include <ansidecl.h>
@


1.9.8.1
log
@merge from trunk
@
text
@d85 1
a85 1
#include "ansidecl.h"
@


1.8
log
@	* chew.c (courierize): Don't modify @@command params.
@
text
@d2 2
a3 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001
a292 2
#define WORD(x) static void x()

d364 2
a365 1
WORD (call)
d374 2
a375 1
WORD (remchar)
d392 2
a393 1
WORD (push_number)
d402 2
a403 1
WORD (push_text)
d557 2
a558 1
WORD (translatecomments)
d594 2
a595 1
WORD (manglecomments)
d673 2
a674 1
WORD (courierize)
d760 2
a761 1
WORD (bulletize)
d815 2
a816 1
WORD (do_fancy_stuff)
d912 2
a913 1
WORD (icopy_past_newline)
d925 2
a926 1
WORD (kill_bogus_lines)
d1012 2
a1013 1
WORD (indent)
d1063 2
a1064 1
WORD (get_stuff_in_command)
d1079 2
a1080 1
WORD (swap)
d1090 2
a1091 1
WORD (other_dup)
d1100 2
a1101 1
WORD (drop)
d1108 2
a1109 1
WORD (idrop)
d1116 2
a1117 1
WORD (icatstr)
d1126 2
a1127 1
WORD (skip_past_newline)
d1136 2
a1137 1
WORD (internalmode)
d1145 2
a1146 1
WORD (maybecatstr)
d1423 2
a1424 1
WORD (atsign)
d1430 2
a1431 1
WORD (hello)
d1437 2
a1438 1
WORD (stdout_)
d1446 2
a1447 1
WORD (stderr_)
d1455 2
a1456 1
WORD (print)
@


1.7
log
@Update copyright notices
@
text
@d689 22
a710 1
		  if (at (tos, idx) == '{' && at (tos, idx + 1) == '*')
d714 1
d720 1
d722 2
a723 11
		  else if (at (tos, idx) == '{' && !command)
		    {
		      cattext (&out, "@@{");
		      idx++;
		    }
		  else if (at (tos, idx) == '}' && !command)
		    {
		      cattext (&out, "@@}");
		      idx++;
		    }
		  else
d725 1
a725 7
		      if (at (tos, idx) == '@@')
			command = 1;
		      else if (isspace ((unsigned char) at (tos, idx))
			       || at (tos, idx) == '}')
			command = 0;
		      catchar (&out, at (tos, idx));
		      idx++;
d728 2
@


1.6
log
@2001-01-25  Kazu Hirata  <kazu@@hxi.com>

	* chew.c: Do not output trailing whitespaces in type and
	functionname.  Update copyright.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1998, 2000, 2001
@


1.6.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 2000, 2001
@


1.5
log
@2001-01-24  Kazu Hirata  <kazu@@hxi.com>

	* chew.c: Do not output a trailing whitespace.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1998, 2000
d490 1
d517 3
a519 1
      for (idx = 0; idx < fname; idx++) 	/* Output type */
d521 1
a521 2
	  /* Omit a trailing whitespace.  */
	  if (idx + 1 == fname && isspace ((unsigned char) at (tos, idx)))
a522 2

	  catchar (&out, at (tos, idx));
d524 2
d529 3
a531 1
      for (idx = fname; idx < openp; idx++) 		/* Output fnname */
d533 2
a534 1
	  catchar (&out, at (tos, idx));
d536 2
d541 3
a543 5
      while (at (tos, idx) && at (tos, idx) != ';')
	{
	  catchar (&out, at (tos, idx));
	  idx++;
	}
@


1.4
log
@2000-09-08  Kazu Hirata  <kazu@@hxi.com>

	* archive.c: Fix formatting.
	* coff-arm.c: Likewise.
	* doc/chew.c: Likewise.
@
text
@d518 4
@


1.3
log
@2000-09-07  Kazu Hirata  <kazu@@hxi.com>

	* doc/chew.c: Remove all uses of DEFUN and DEFUN_VOID.
@
text
@d25 1
a25 1
  
a83 1

d98 1
a98 1
/* Here is a string type ... */
d100 1
a100 1
typedef struct buffer 
a106 1

a121 1

d127 3
a129 3
    buffer->write_idx = 0;
    buffer->size = size;
    buffer->ptr = malloc(size);
d136 1
a136 2
    init_string_with_size(buffer, DEF_SIZE);

d144 9
a152 9
    unsigned int i;
    char *p;
    p = what;
    for (i = 0; i < str->write_idx && *p; i++) 
    {
	if (*p == str->ptr[i])
	 p++;
	else
	 p = what;
d154 1
a154 2
    return (*p == 0);
    
d162 1
a162 1
    fwrite(buffer->ptr, buffer->write_idx, 1, f);
a164 1

d169 1
a169 1
    free(buffer->ptr);
a171 1

d177 1
a177 1
    return buffer->ptr + idx;
d185 1
a185 1
  if (pos >= buffer->write_idx) 
d195 1
a195 1
  if (buffer->write_idx == buffer->size) 
d197 2
a198 2
      buffer->size *=2;
      buffer->ptr = realloc(buffer->ptr, buffer->size);
d201 1
a201 1
  buffer->ptr[buffer->write_idx ++ ] = ch;
a203 1

d209 4
a212 4
    free(dst->ptr);
    dst->size = src->size;
    dst->write_idx = src->write_idx;
    dst->ptr = src->ptr;
d247 1
a247 2

static unsigned int 
d253 1
a253 1
  while ((c = at(src,idx)),
d258 2
a259 2
	     && at(src,idx +1) != '/'
	     && at(src,idx -1) != '\n')) 
a265 1

a279 2


d282 6
a287 7
    char *word;
    struct dict_struct *next;
    stinst_type *code;
    int code_length;
    int code_end;
    int var;
    
d289 1
d291 1
d361 2
a362 2
  while (*pc) 
    (*pc)();
d364 2
a365 1
WORD(call)
d367 5
a371 6
    stinst_type *oldpc = pc;
    dict_type *e;
    e =  (dict_type *)(pc [1]);
    exec(e);
    pc = oldpc + 2;
    
d374 1
a374 1
WORD(remchar)
d377 1
a377 1
    tos->write_idx--;    
d391 1
a391 1
WORD(push_number)
d393 5
a397 16
    isp++;
    icheck_range ();
    pc++;
    *isp = (long)(*pc);
    pc++;
}

WORD(push_text)
{
    tos++;
    check_range ();
    init_string(tos);
    pc++;
    cattext(tos,*((char **)pc));
    pc++;
    
d400 9
d415 2
a416 2
static void 
remove_noncomments (src,dst)
d420 20
a439 20
    unsigned int idx = 0;
    
    while (at(src,idx)) 
    {
	/* Now see if we have a comment at the start of the line */
	if (at(src,idx) == '\n' 
	    && at(src,idx+1) ==  '/' 
	    && at(src,idx+2) == '*') 
	{
	    idx+=3;
	    
	    idx = skip_white_and_stars(src,idx);

	    /* Remove leading dot */
	    if (at(src, idx) == '.')
	     idx++;
	    
	    /* Copy to the end of the line, or till the end of the
	       comment */
	    while (at(src, idx))
d441 1
a441 1
		if (at(src, idx) == '\n') 
d443 6
a448 6
		    /* end of line, echo and scrape of leading blanks  */
		    if (at(src,idx +1) == '\n')
		     catchar(dst,'\n');
		    catchar(dst,'\n');
		    idx++;
		    idx =   skip_white_and_stars(src, idx);
d450 1
a450 1
		else if (at(src, idx) == '*' && at(src,idx+1) == '/') 
d452 3
a454 3
		    idx +=2 ;
		    cattext(dst,"\nENDDD\n");
		    break;
d456 1
a456 1
		else 
d458 2
a459 2
		    catchar(dst, at(src, idx));
		    idx++;
d463 2
a464 1
	else idx++;
d487 5
a491 16
    unsigned int openp;
    unsigned int fname;
    unsigned int idx;
    string_type out;
    init_string(&out);
    

    /* make sure that it's not already param'd or proto'd */
    if(find(tos,"PARAMS") || find(tos,"PROTO") || !find(tos,"(")) {
	    catstr(&out,tos);
	}
    else 
    {
	/* Find the open paren */
	for (openp = 0; at(tos, openp) != '('  && at(tos,openp); openp++)
	 ;
d493 19
a511 2
	fname = openp;
	/* Step back to the fname */
a512 6
	while (fname && isspace((unsigned char) at(tos, fname)))
	 fname --;
	while (fname
	       && !isspace((unsigned char) at(tos,fname))
	       && at(tos,fname) != '*')
	 fname--;
d514 3
a516 3
	fname++;
	
	for (idx = 0; idx < fname; idx++) 	/* Output type */
d518 1
a518 1
	    catchar(&out, at(tos,idx));
a519 2
    
        cattext(&out, "\n");	/* Insert a newline between type and fnname */
d521 3
a523 1
	for (idx = fname; idx < openp; idx++) 		/* Output fnname */
d525 1
a525 1
	    catchar(&out, at(tos,idx));
d528 1
a528 1
	cattext(&out," PARAMS (");
d530 1
a530 1
	while (at(tos,idx) && at(tos,idx) !=';') 
d532 2
a533 2
	    catchar(&out, at(tos, idx));
	    idx++;
d535 1
a535 1
	cattext(&out,");\n\n");
d537 3
a539 3
    overwrite_string(tos, &out);    
    pc++;
    
a541 2


d545 1
a545 1
WORD(translatecomments)
d547 5
a551 5
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) 
d553 1
a553 1
	if (at(tos,idx) == '{' && at(tos,idx+1) =='*') 
d555 2
a556 2
	    cattext(&out,"/*");
	    idx+=2;
d558 1
a558 1
	else if (at(tos,idx) == '*' && at(tos,idx+1) =='}') 
d560 2
a561 2
	    cattext(&out,"*/");
	    idx+=2;
d563 1
a563 1
	else  
d565 2
a566 2
	    catchar(&out, at(tos, idx));
	    idx++;
d570 1
d572 1
a572 4
    overwrite_string(tos, &out);
    
    pc++;
    
d581 1
a581 1
WORD(manglecomments)
d583 5
a587 5
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) 
d589 1
a589 1
	if (at(tos,idx) == '\n' && at(tos,idx+1) =='*') 
d591 2
a592 2
	    cattext(&out,"	/*");
	    idx+=2;
d594 1
a594 1
	else if (at(tos,idx) == '*' && at(tos,idx+1) =='}') 
d596 2
a597 2
	    cattext(&out,"*/");
	    idx+=2;
d599 1
a599 1
	else  
d601 2
a602 2
	    catchar(&out, at(tos, idx));
	    idx++;
d606 1
d608 1
a608 4
    overwrite_string(tos, &out);
    
    pc++;
    
d617 5
a621 5
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) 
d623 1
a623 1
	if (at(tos, idx) == '\n' && at(tos, idx+1) == '.') 
d627 2
a628 2
	    
	    while ((c = at(tos, idx)) && c != '\n')
d630 1
a630 1
	      if (c == '{' && at(tos,idx+1) =='*') 
d632 2
a633 2
		    cattext(&out,"/*");
		    idx+=2;
d635 1
a635 1
	      else if (c == '*' && at(tos,idx+1) =='}') 
d637 2
a638 2
		    cattext(&out,"*/");
		    idx+=2;
d642 2
a643 2
		    catchar(&out, c);
		    idx++;
d646 1
a646 1
	    catchar(&out,'\n');
d648 1
a648 1
	else 
d650 1
a650 1
	    idx++;
d652 1
a652 1
    }	
d654 2
a655 3
    overwrite_string(tos, &out);
    pc++;
    
d659 1
a659 1
WORD(courierize)
d661 11
a671 11
    string_type out;
    unsigned int idx = 0;
    int command = 0;
    
    init_string(&out);
    
    while (at(tos, idx)) 
    {
	if (at(tos, idx) == '\n' 
	    && (at(tos, idx +1 ) == '.'
		|| at(tos,idx+1) == '|')) 
d673 2
a674 2
	    cattext(&out,"\n@@example\n");
	    do 
d676 3
a678 3
		idx += 2;
		
		while (at(tos, idx) && at(tos, idx)!='\n')
d680 1
a680 1
		    if (at(tos,idx)=='{' && at(tos,idx+1) =='*') 
d682 2
a683 2
			cattext(&out,"/*");
			idx+=2;
d685 1
a685 1
		    else if (at(tos,idx)=='*' && at(tos,idx+1) =='}') 
d687 2
a688 2
			cattext(&out,"*/");
			idx+=2;
d690 1
a690 1
	            else if (at(tos,idx) == '{' && !command)
d692 2
a693 2
			cattext(&out,"@@{");
			idx++;
d695 1
a695 1
	            else if (at(tos,idx) == '}' && !command)
d697 2
a698 2
			cattext(&out,"@@}");
			idx++;
d700 1
a700 1
		    else 
d702 7
a708 7
			if (at(tos,idx) == '@@')
			    command = 1;
			else if (isspace((unsigned char) at(tos,idx))
				 || at(tos,idx) == '}')
			    command = 0;
			catchar(&out, at(tos, idx));
			idx++;
d710 1
a710 1
		    
d712 12
a723 12
		catchar(&out,'\n');
	    }  
	    while (at(tos, idx) == '\n' 
		   && ((at(tos, idx+1) == '.')
		       || (at(tos,idx+1) == '|')))
	      ;
	    cattext(&out,"@@end example");
	}
	else 
	{    
	    catchar(&out, at(tos, idx));
	    idx++;
d725 1
a725 1
    }    
d727 2
a728 4
    overwrite_string(tos, &out);
    pc++;

    
d735 6
d742 13
a754 19
WORD(bulletize)
{
    unsigned int idx = 0;
    int on = 0;
    string_type out;
    init_string(&out);
    
    while (at(tos, idx)) {
	if (at(tos, idx) == '@@' &&
	    at(tos, idx+1) == '*') 
	{
	  cattext(&out,"*");
	  idx+=2;
	}
	
	else
	    if (at(tos, idx) == '\n' &&
		at(tos, idx+1) == 'o' &&
		isspace((unsigned char) at(tos, idx +2)))
d756 3
a758 8
		if (!on) 
		{
		    cattext(&out,"\n@@itemize @@bullet\n");
		    on = 1;
		    
		}
		cattext(&out,"\n@@item\n");
		idx+=3;
d760 9
a768 1
	    else 
d770 2
a771 10
		catchar(&out, at(tos, idx));
		if (on && at(tos, idx) == '\n' &&
		    at(tos, idx+1) == '\n' &&
		    at(tos, idx+2) != 'o')
		{
		    cattext(&out, "@@end itemize");
		    on = 0;
		}
		idx++;
		
d773 2
d776 2
a777 1
    if (on) 
d779 2
a780 2
	cattext(&out,"@@end itemize\n");
    }	
d782 3
a784 4
    delete_string(tos);
    *tos = out;
    pc++;
    
a787 1
   
d789 1
a789 1
WORD(do_fancy_stuff)
d791 14
a804 14
    unsigned int idx = 0;
    string_type out;
    init_string(&out);
    while (at(tos, idx)) 
    {
	if (at(tos, idx) == '<' 
	    && at(tos, idx+1) == '<'
	    && !isspace((unsigned char) at(tos,idx + 2))) 
	{
	    /* This qualifies as a << startup */
	    idx +=2;
	    cattext(&out,"@@code{");
	    while(at(tos,idx) &&
		  at(tos,idx) != '>' )
d806 3
a808 3
		catchar(&out, at(tos, idx));
		idx++;
		
d810 2
a811 2
	    cattext(&out,"}");
	    idx+=2;
d813 1
a813 1
	else 
d815 2
a816 2
	    catchar(&out, at(tos, idx));
	    idx++;
d819 4
a822 4
    delete_string(tos);
    *tos = out;
    pc++;
    
d824 4
a827 2
/* A command is all upper case,and alone on a line */
static int 
d832 14
a845 14
    unsigned int len = 0;
    while (at(ptr,idx)) {
	    if (isupper((unsigned char) at(ptr,idx)) || at(ptr,idx) == ' ' ||
		at(ptr,idx) == '_') 
	    {
	     len++;
	     idx++;
	 }
	    else if(at(ptr,idx) == '\n')
	    {
		if (len > 3) return 1;
		return 0;
	    }
	    else return 0;
d847 4
a850 2
    return 0;

a852 1

d859 1
a859 1
    int column = 0;
d861 1
a861 1
    while (at(ptr, idx) && at(ptr, idx) != '\n') 
d863 19
a881 19
	if (at (ptr, idx) == '\t')
	  {
	    /* Expand tabs.  Neither makeinfo nor TeX can cope well with
	       them.  */
	    do
	      catchar (dst, ' ');
	    while (++column & 7);
	  }
	else
	  {
	    catchar(dst, at(ptr, idx));
	    column++;
	  }
	idx++;
	
    }    
    catchar(dst, at(ptr, idx));
    idx++;
    return idx;
d885 1
a885 1
WORD(icopy_past_newline)
d887 5
a891 5
    tos++;
    check_range ();
    init_string(tos);
    idx = copy_past_newline(ptr, idx, tos);
    pc++;	
d895 5
a899 1
   Take the string at the top of the stack, do some prettying */
d901 3
d905 4
a908 12
WORD(kill_bogus_lines)
{
    int sl ;
    
    int idx = 0;
    int c;
    int dot = 0    ;
    
    string_type out;    
    init_string(&out);
    /* Drop leading nl */
    while (at(tos,idx) == '\n')
d910 1
a910 1
	idx++;
d912 1
a912 6
    c = idx;
    
    /* If the first char is a '.' prepend a newline so that it is
       recognized properly later.  */
    if (at (tos, idx) == '.')
      catchar (&out, '\n');
d914 7
a920 2
    /* Find the last char */
    while (at(tos,idx))
d922 1
a922 1
	idx++;
d924 5
a928 2
    
    /* find the last non white before the nl */
d930 5
a934 8
    
    while (idx && isspace((unsigned char) at(tos,idx)))
     idx--;
    idx++;
    
    /* Copy buffer upto last char, but blank lines before and after
       dots don't count */
    sl = 1;
d936 1
a936 1
    while (c < idx)
d938 3
a940 3
	if (at(tos,c) == '\n' 
	    && at(tos,c+1) == '\n'
	    && at(tos,c+2) == '.') 
d942 2
a943 2
	    /* Ignore two newlines before a dot*/
	    c++;
d945 1
a945 1
	else if (at(tos,c) == '.' && sl)
d947 2
a948 2
	    /* remember that this line started with a dot */
	    dot=2;
d950 3
a952 3
	else if (at(tos,c) == '\n' 
		 && at(tos,c+1) == '\n'
		 && dot)
d954 2
a955 2
	    c++;
	    /* Ignore two newlines when last line was dot */
d958 2
a959 2
	catchar(&out, at(tos,c));
	if (at(tos,c) == '\n')
d961 6
a966 3
	    sl = 1;
	    
	    if (dot == 2)dot=1;else dot = 0;
d968 4
a971 4
	else
	  sl = 0;
	
	c++;	
d974 7
a980 8
    
    /* Append nl*/
    catchar(&out, '\n');
    pc++;
    delete_string(tos);
    *tos = out;
    
    
d983 1
a983 1
WORD(indent)
d985 13
a997 7
    string_type out;
    int tab = 0;
    int idx = 0;
    int ol =0;
    init_string(&out);
    while (at(tos,idx)) {
	    switch (at(tos,idx)) 
d999 1
a999 30
	      case '\n':
		cattext(&out,"\n");
		idx++;
		if (tab && at(tos,idx))
		{
		    cattext(&out,"    ");
		}
		ol = 0;
		break;
	      case '(':
		tab++;
		if (ol == 0)
		    cattext(&out,"   ");
		idx++;
		cattext(&out,"(");
		ol = 1;
		break;
	      case ')':
		tab--;
		cattext(&out,")");
		idx++;
		ol=1;
		
		break;
	      default:
		catchar(&out,at(tos,idx));
		ol=1;
		
		idx++;
		break;
d1001 20
a1020 1
	}	
d1022 8
a1029 3
    pc++;
    delete_string(tos);
    *tos = out;
d1033 1
a1033 2

WORD(get_stuff_in_command)
d1035 3
a1037 3
    tos++;
    check_range ();
    init_string(tos);
d1039 7
a1045 5
    while (at(ptr, idx)) {
	    if (iscommand(ptr, idx))  break;
	    idx =   copy_past_newline(ptr, idx, tos);
	}
    pc++;    
d1048 1
a1048 1
WORD(swap)
d1050 6
a1055 7
    string_type t;
    
    t = tos[0];
    tos[0] = tos[-1];
    tos[-1] =t; 
    pc++;
    
d1058 1
a1058 1
WORD(other_dup)
d1060 5
a1064 5
    tos++;
    check_range ();
    init_string(tos);
    catstr(tos, tos-1);
    pc++;
d1067 1
a1067 1
WORD(drop)
d1074 1
a1074 1
WORD(idrop)
d1081 1
a1081 1
WORD(icatstr)
d1083 5
a1087 5
    tos--;
    check_range ();
    catstr(tos, tos+1);
    delete_string(tos+1);
    pc++;
d1090 1
a1090 1
WORD(skip_past_newline)
d1092 2
a1093 3
    while (at(ptr,idx) 
	   && at(ptr,idx) != '\n')
     idx++;
d1095 2
a1096 1
    pc++;
d1099 1
a1099 2

WORD(internalmode)
d1101 4
a1104 4
    internal_mode = *(isp);
    isp--;
    icheck_range ();
    pc++;
d1107 1
a1107 1
WORD(maybecatstr)
d1109 1
a1109 1
    if (internal_wanted == internal_mode) 
d1111 1
a1111 1
	catstr(tos-1, tos);
d1113 4
a1116 4
    delete_string(tos);
    tos--;
    check_range ();
    pc++;
d1124 14
a1137 17
    char *word_start;
    int idx;
    char *dst;
    char *src;
    
    int length = 0;
    
    while (isspace((unsigned char) *string) || *string == '-') {
	    if (*string == '-') 
	    {
		while (*string && *string != '\n') 
		 string++;
		
	    }
	    else {
		    string++;
		}
d1139 1
a1139 20
    if (!*string) return 0;
    
    word_start = string;
    if (*string == '"') 
      {
	do
	  {
	    string++;
	    length++;
	    if (*string == '\\')
	      {
		string += 2;
		length += 2;
	      }
	  }
	while (*string != '"');
      }
    else     
      {
	while (!isspace((unsigned char) *string)) 
d1141 1
a1141 3
	    string++;
	    length++;
	
d1144 2
a1145 2
    
    *word = malloc(length + 1);
d1147 8
a1154 8
    dst = *word;
    src = word_start;


    for (idx= 0; idx < length; idx++) 
      {
	if (src[idx] == '\\')
	  switch (src[idx+1])
d1156 2
a1157 12
	    case 'n':
	      *dst++ = '\n';
	      idx++;
	      break;
	    case '"':
	    case '\\':
	      *dst++ = src[idx+1];
	      idx++;
	      break;
	    default:
	      *dst++ = '\\';
	      break;
d1159 2
a1160 2
	else
	  *dst++ = src[idx];
d1162 6
a1167 1
    *dst++ = 0;
d1169 2
d1172 1
d1174 2
d1177 22
d1200 4
a1203 5
    if(*string)    
     return string + 1;
    else 
     return 0;
    
d1205 1
d1207 1
d1213 4
a1216 2
  while (ptr) {
      if (strcmp(ptr->word, word) == 0) return ptr;
a1217 1
	    
d1220 1
a1220 1
   fprintf(stderr,"Can't find %s\n",word);
a1221 2
    
    
a1227 9
    
  while (at(ptr, idx)) {
      /* It's worth looking through the command list */
      if (iscommand(ptr, idx))
      {
	char *next;
	dict_type *word ;
		
	(void)		nextword(addr(ptr, idx), &next);
d1229 7
d1237 1
a1237 1
	word = lookup_word(next);
d1239 1
d1241 10
a1250 1
		
a1251 3
	if (word) 
	{
	  exec(word);
d1253 2
a1254 10
	else
	{
	  if (warning)
	   fprintf(stderr,"warning, %s is not recognised\n",  next);
	  skip_past_newline();
	}
		
      }
      else skip_past_newline();

d1262 8
a1269 9
    dict_type *new = (dict_type *)malloc(sizeof(dict_type));
    new->word = word;
    new->next = root;
    root = new;
    new->code = (stinst_type *)malloc(sizeof(stinst_type ));
    new->code_length = 1;
    new->code_end = 0;
    return new;
    
a1271 1

d1277 1
a1277 1
    if (entry->code_end == entry->code_length) 
d1279 8
a1286 8
	entry->code_length += 2;
	entry->code =
	 (stinst_type *) realloc((char *)(entry->code),
			       entry->code_length *sizeof(word_type));
    }
    entry->code[entry->code_end] = word;
    
return     entry->code_end++;  
a1288 6






d1292 1
a1292 1
     void (*func)();
d1294 3
a1296 3
    dict_type *new = newentry(name);
    add_to_definition(new, func);
    add_to_definition(new, 0);
d1303 4
a1306 4
    dict_type *new = newentry(name);
    add_to_definition(new, push_number);
    add_to_definition(new, (stinst_type)(&(new->var)));
    add_to_definition(new,0);
d1309 1
a1309 2

void 
d1313 21
a1333 23
    /* add words to the dictionary */
    char *word;
    string = nextword(string, &word);
    while (string && *string && word[0]) 
    {
	if (strcmp(word,"var")==0) 
	{
 string=nextword(string, &word);
	  
	  add_var(word);
 string=nextword(string, &word);
	}
else	
	    
	if (word[0] == ':')
	{
	    dict_type *ptr;
	    /* Compile a word and add to dictionary */
	    string = nextword(string, &word);
	    
	    ptr = newentry(word);
	    string = nextword(string, &word);
	    while (word[0] != ';' ) 
d1335 27
a1361 27
		 switch (word[0]) 
		 {
		   case '"':
		     /* got a string, embed magic push string
			function */
		     add_to_definition(ptr, push_text);
		     add_to_definition(ptr, (stinst_type)(word+1));
		     break;
		   case '0':
		   case '1':
		   case '2':
		   case '3':
		   case '4':
		   case '5':
		   case '6':
		   case '7':
		   case '8':
		   case '9':
		     /* Got a number, embedd the magic push number
			function */
		     add_to_definition(ptr, push_number);
		     add_to_definition(ptr, (stinst_type)atol(word));
		     break;
		   default:
		     add_to_definition(ptr, call);
		     add_to_definition(ptr, (stinst_type)lookup_word(word));
		 }
d1363 1
a1363 1
		string = nextword(string, &word);		     
d1365 2
a1366 2
	    add_to_definition(ptr,0);
	    string = nextword(string, &word);
d1368 1
a1368 1
	else 
d1370 2
a1371 2
	    fprintf(stderr,"syntax error at %s\n",string-1);
	}	    
a1372 1

a1374 1
 
d1378 2
a1379 2
  *(long *)((isp[0])) = isp[-1];
  isp-=2;
d1384 1
a1384 1
WORD(atsign)
d1386 2
a1387 2
    isp[0] = *(long *)(isp[0]);
    pc++;
d1390 1
a1390 1
WORD(hello)
d1392 2
a1393 2
  printf("hello\n");
  pc++;    
d1396 1
a1396 1
WORD(stdout_)
d1404 1
a1404 1
WORD(stderr_)
d1412 1
a1412 1
WORD(print)
a1426 1

d1429 2
a1430 2
      string_type *str;
      FILE *file;
d1432 11
a1442 11
    char buff[10000];    
    unsigned int r;
    do 
    {
	r = fread(buff, 1, sizeof(buff), file);
	catbuf(str, buff, r);
    }
    while (r);
    buff[0] = 0;
    
    catbuf(str, buff,1);
a1444 1

d1448 2
a1449 2
    fprintf(stderr,"usage: -[d|i|g] <file >file\n");
    exit(33);    
d1464 1
a1464 1
main (ac,av)
d1472 4
a1475 4
  init_string(&buffer);
  init_string(&pptr);
  init_string(stack+0);
  tos=stack+1;
d1477 19
a1495 19
    
  add_intrinsic("push_text", push_text);
  add_intrinsic("!", bang);
  add_intrinsic("@@", atsign);
  add_intrinsic("hello",hello);    
  add_intrinsic("stdout",stdout_);    
  add_intrinsic("stderr",stderr_);    
  add_intrinsic("print",print);    
  add_intrinsic("skip_past_newline", skip_past_newline );
  add_intrinsic("catstr", icatstr );
  add_intrinsic("copy_past_newline", icopy_past_newline );
  add_intrinsic("dup", other_dup );
  add_intrinsic("drop", drop);
  add_intrinsic("idrop", idrop);
  add_intrinsic("remchar", remchar );
  add_intrinsic("get_stuff_in_command", get_stuff_in_command );
  add_intrinsic("do_fancy_stuff", do_fancy_stuff );
  add_intrinsic("bulletize", bulletize );
  add_intrinsic("courierize", courierize );
d1499 50
a1548 48
  add_intrinsic("exit", chew_exit );
  add_intrinsic("swap", swap );
  add_intrinsic("outputdots", outputdots );
  add_intrinsic("paramstuff", paramstuff );
  add_intrinsic("maybecatstr", maybecatstr );
  add_intrinsic("translatecomments", translatecomments );
  add_intrinsic("kill_bogus_lines", kill_bogus_lines);
  add_intrinsic("indent", indent);
  add_intrinsic("internalmode", internalmode);
  add_intrinsic("print_stack_level", print_stack_level);
  add_intrinsic("strip_trailing_newlines", strip_trailing_newlines);
    
  /* Put a nl at the start */
  catchar(&buffer,'\n');

  read_in(&buffer, stdin); 
  remove_noncomments(&buffer, ptr);
  for (i= 1; i < (unsigned int) ac; i++) 
  {
    if (av[i][0] == '-')
    {
      if (av[i][1] == 'f')
      {
	string_type b;
	FILE *f;
	init_string(&b);

	f  = fopen(av[i+1],"r");
	if (!f) 
	{
	  fprintf(stderr,"Can't open the input file %s\n",av[i+1]);
	  return 33;
	}

	read_in(&b, f);
	compile(b.ptr);
	perform();	
      }
      else if (av[i][1] == 'i') 
      {
	internal_wanted = 1;
      }
      else if (av[i][1] == 'w') 
      {
	warning = 1;
      }
      else
	usage ();
d1550 1
a1550 2
  }      
  write_buffer(stack+0, stdout);
d1553 2
a1554 1
      fprintf (stderr, "finishing with current stack level %d\n", tos - stack);
@


1.2
log
@Don't add a space before `/*' when processing comments.
@
text
@d125 4
a128 3
static void DEFUN(init_string_with_size,(buffer, size),
	   string_type *buffer AND
	   unsigned int size )
d135 3
a137 2
static void DEFUN(init_string,(buffer),
	   string_type *buffer)
d143 4
a146 3
static int DEFUN(find, (str, what),
	  string_type *str AND
	  char *what)
d162 4
a165 3
static void DEFUN(write_buffer,(buffer, f),
	   string_type *buffer AND
	   FILE *f)
d171 3
a173 2
static void DEFUN(delete_string,(buffer),
	   string_type *buffer)
d179 4
a182 3
static char *DEFUN(addr, (buffer, idx),
	    string_type *buffer AND
	    unsigned int idx)
d187 4
a190 3
static char DEFUN(at,(buffer, pos),
	   string_type *buffer AND
	   unsigned int pos) 
d197 4
a200 3
static void DEFUN(catchar,(buffer, ch), 
	   string_type *buffer AND
	   int ch)
d212 4
a215 3
static void DEFUN(overwrite_string,(dst,   src),
	   string_type *dst AND
	   string_type *src)
d223 5
a227 4
static void DEFUN(catbuf,(buffer, buf, len),
	   string_type *buffer AND
	   char *buf AND
	   unsigned int len)
d239 4
a242 3
static void DEFUN(cattext,(buffer, string),
	   string_type *buffer AND
	   char *string)
d247 4
a250 3
static void DEFUN(catstr,(dst, src),
	   string_type *dst AND
	   string_type *src)
d257 3
a259 3
DEFUN(skip_white_and_stars,(src, idx),
      string_type *src AND
      unsigned int idx)
d367 3
a369 2
static void DEFUN(exec,(word),
		  dict_type *word)
d429 3
a431 3
DEFUN(remove_noncomments,(src,dst),
	   string_type *src AND
	   string_type *dst)
d497 1
a497 1
DEFUN_VOID(paramstuff)
d633 1
a633 1
DEFUN_VOID(outputdots)
d851 3
a853 3
DEFUN( iscommand,(ptr, idx),
      string_type *ptr AND
      unsigned int idx)
d876 4
a879 4
DEFUN(copy_past_newline,(ptr, idx, dst),
      string_type *ptr AND
      unsigned int idx AND
      string_type *dst)
d1141 3
a1143 3
DEFUN(nextword,(string, word),
      char *string AND
      char **word)
d1231 2
a1232 2
DEFUN(lookup_word,(word),
      char *word)
d1247 2
a1248 1
static void DEFUN_VOID(perform)
d1285 2
a1286 2
DEFUN(newentry,(word),
      char *word)
d1301 3
a1303 3
DEFUN(add_to_definition,(entry, word), 
      dict_type *entry AND
      stinst_type word)
d1324 3
a1326 3
DEFUN(add_intrinsic,(name, func),
      char *name AND
      void (*func)())
d1334 2
a1335 2
DEFUN(add_var,(name),
      char *name)
d1345 2
a1346 2
DEFUN(compile, (string), 
      char *string)
d1414 2
a1415 1
static void DEFUN_VOID(bang)
d1467 4
a1470 3
static void DEFUN(read_in, (str, file), 
	   string_type *str AND
		  FILE *file)
d1486 2
a1487 1
static void DEFUN_VOID(usage)
d1504 4
a1507 3
int DEFUN(main,(ac,av),
int ac AND
char *av[])
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 1998
d637 1
a637 1
		    cattext(&out," /*");
d688 1
a688 1
			cattext(&out," /*");
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

