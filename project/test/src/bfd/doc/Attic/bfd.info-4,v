head	1.1;
access;
symbols
	binutils-2_14:1.1.10.1
	binutils-2_14-branch:1.1.0.10
	binutils-2_13_2_1:1.1.8.3
	binutils-2_13_2:1.1.8.3
	binutils-2_13_1:1.1.8.2
	binutils-2_13:1.1.8.1
	binutils-2_13-branch:1.1.0.8
	binutils-2_12_1:1.1.6.2
	binutils-2_12:1.1.6.1
	binutils-2_12-branch:1.1.0.6
	binutils-2_11_2:1.1.4.2
	binutils-2_11_1:1.1.4.1
	binutils-2_11:1.1.4.1
	binutils-2_11-branch:1.1.0.4
	binutils-2_10_1:1.1.2.1
	binutils-2_10:1.1.2.1
	binutils_latest_snapshot:1.1.2.1
	binutils-2_10-branch:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2000.05.29.14.08.51;	author pb;	state dead;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1
	1.1.8.1
	1.1.10.1;
next	;

1.1.2.1
date	2000.05.29.14.08.51;	author pb;	state Exp;
branches;
next	;

1.1.4.1
date	2001.03.12.15.40.29;	author pb;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.06.18.20.19.05;	author pb;	state Exp;
branches;
next	;

1.1.6.1
date	2002.03.08.17.00.52;	author drow;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.05.14.23.51.39;	author drow;	state Exp;
branches;
next	;

1.1.8.1
date	2002.08.05.20.43.44;	author drow;	state Exp;
branches;
next	1.1.8.2;

1.1.8.2
date	2002.10.30.17.02.37;	author drow;	state Exp;
branches;
next	1.1.8.3;

1.1.8.3
date	2002.12.20.21.33.24;	author drow;	state Exp;
branches;
next	;

1.1.10.1
date	2003.04.27.20.36.05;	author drow;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file bfd.info-4 was initially added on branch binutils-2_10-branch.
@
text
@@


1.1.10.1
log
@Add generated files on 2.14 branch.
@
text
@a0 1604
This is bfd.info, produced by makeinfo version 4.3 from bfd.texinfo.

START-INFO-DIR-ENTRY
* Bfd: (bfd).                   The Binary File Descriptor library.
END-INFO-DIR-ENTRY

   This file documents the BFD library.

   Copyright (C) 1991, 2000, 2001, 2003 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
   with no Invariant Sections, with no Front-Cover Texts, and with no
    Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".


File: bfd.info,  Node: howto manager,  Prev: typedef arelent,  Up: Relocations

The howto manager
=================

   When an application wants to create a relocation, but doesn't know
what the target machine might call it, it can find out by using this
bit of code.

`bfd_reloc_code_type'
.....................

   *Description*
The insides of a reloc code.  The idea is that, eventually, there will
be one enumerator for every type of relocation we ever do.  Pass one of
these values to `bfd_reloc_type_lookup', and it'll return a howto
pointer.

   This does mean that the application must determine the correct
enumerator value; you can't get a howto pointer from a random set of
attributes.

   Here are the possible values for `enum bfd_reloc_code_real':

 - : BFD_RELOC_64
 - : BFD_RELOC_32
 - : BFD_RELOC_26
 - : BFD_RELOC_24
 - : BFD_RELOC_16
 - : BFD_RELOC_14
 - : BFD_RELOC_8
     Basic absolute relocations of N bits.

 - : BFD_RELOC_64_PCREL
 - : BFD_RELOC_32_PCREL
 - : BFD_RELOC_24_PCREL
 - : BFD_RELOC_16_PCREL
 - : BFD_RELOC_12_PCREL
 - : BFD_RELOC_8_PCREL
     PC-relative relocations.  Sometimes these are relative to the
     address of the relocation itself; sometimes they are relative to
     the start of the section containing the relocation.  It depends on
     the specific target.

     The 24-bit relocation is used in some Intel 960 configurations.

 - : BFD_RELOC_32_GOT_PCREL
 - : BFD_RELOC_16_GOT_PCREL
 - : BFD_RELOC_8_GOT_PCREL
 - : BFD_RELOC_32_GOTOFF
 - : BFD_RELOC_16_GOTOFF
 - : BFD_RELOC_LO16_GOTOFF
 - : BFD_RELOC_HI16_GOTOFF
 - : BFD_RELOC_HI16_S_GOTOFF
 - : BFD_RELOC_8_GOTOFF
 - : BFD_RELOC_64_PLT_PCREL
 - : BFD_RELOC_32_PLT_PCREL
 - : BFD_RELOC_24_PLT_PCREL
 - : BFD_RELOC_16_PLT_PCREL
 - : BFD_RELOC_8_PLT_PCREL
 - : BFD_RELOC_64_PLTOFF
 - : BFD_RELOC_32_PLTOFF
 - : BFD_RELOC_16_PLTOFF
 - : BFD_RELOC_LO16_PLTOFF
 - : BFD_RELOC_HI16_PLTOFF
 - : BFD_RELOC_HI16_S_PLTOFF
 - : BFD_RELOC_8_PLTOFF
     For ELF.

 - : BFD_RELOC_68K_GLOB_DAT
 - : BFD_RELOC_68K_JMP_SLOT
 - : BFD_RELOC_68K_RELATIVE
     Relocations used by 68K ELF.

 - : BFD_RELOC_32_BASEREL
 - : BFD_RELOC_16_BASEREL
 - : BFD_RELOC_LO16_BASEREL
 - : BFD_RELOC_HI16_BASEREL
 - : BFD_RELOC_HI16_S_BASEREL
 - : BFD_RELOC_8_BASEREL
 - : BFD_RELOC_RVA
     Linkage-table relative.

 - : BFD_RELOC_8_FFnn
     Absolute 8-bit relocation, but used to form an address like 0xFFnn.

 - : BFD_RELOC_32_PCREL_S2
 - : BFD_RELOC_16_PCREL_S2
 - : BFD_RELOC_23_PCREL_S2
     These PC-relative relocations are stored as word displacements -
     i.e., byte displacements shifted right two bits.  The 30-bit word
     displacement (<<32_PCREL_S2>> - 32 bits, shifted 2) is used on the
     SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
     signed 16-bit displacement is used on the MIPS, and the 23-bit
     displacement is used on the Alpha.

 - : BFD_RELOC_HI22
 - : BFD_RELOC_LO10
     High 22 bits and low 10 bits of 32-bit value, placed into lower
     bits of the target word.  These are used on the SPARC.

 - : BFD_RELOC_GPREL16
 - : BFD_RELOC_GPREL32
     For systems that allocate a Global Pointer register, these are
     displacements off that register.  These relocation types are
     handled specially, because the value the register will have is
     decided relatively late.

 - : BFD_RELOC_I960_CALLJ
     Reloc types used for i960/b.out.

 - : BFD_RELOC_NONE
 - : BFD_RELOC_SPARC_WDISP22
 - : BFD_RELOC_SPARC22
 - : BFD_RELOC_SPARC13
 - : BFD_RELOC_SPARC_GOT10
 - : BFD_RELOC_SPARC_GOT13
 - : BFD_RELOC_SPARC_GOT22
 - : BFD_RELOC_SPARC_PC10
 - : BFD_RELOC_SPARC_PC22
 - : BFD_RELOC_SPARC_WPLT30
 - : BFD_RELOC_SPARC_COPY
 - : BFD_RELOC_SPARC_GLOB_DAT
 - : BFD_RELOC_SPARC_JMP_SLOT
 - : BFD_RELOC_SPARC_RELATIVE
 - : BFD_RELOC_SPARC_UA16
 - : BFD_RELOC_SPARC_UA32
 - : BFD_RELOC_SPARC_UA64
     SPARC ELF relocations.  There is probably some overlap with other
     relocation types already defined.

 - : BFD_RELOC_SPARC_BASE13
 - : BFD_RELOC_SPARC_BASE22
     I think these are specific to SPARC a.out (e.g., Sun 4).

 - : BFD_RELOC_SPARC_64
 - : BFD_RELOC_SPARC_10
 - : BFD_RELOC_SPARC_11
 - : BFD_RELOC_SPARC_OLO10
 - : BFD_RELOC_SPARC_HH22
 - : BFD_RELOC_SPARC_HM10
 - : BFD_RELOC_SPARC_LM22
 - : BFD_RELOC_SPARC_PC_HH22
 - : BFD_RELOC_SPARC_PC_HM10
 - : BFD_RELOC_SPARC_PC_LM22
 - : BFD_RELOC_SPARC_WDISP16
 - : BFD_RELOC_SPARC_WDISP19
 - : BFD_RELOC_SPARC_7
 - : BFD_RELOC_SPARC_6
 - : BFD_RELOC_SPARC_5
 - : BFD_RELOC_SPARC_DISP64
 - : BFD_RELOC_SPARC_PLT32
 - : BFD_RELOC_SPARC_PLT64
 - : BFD_RELOC_SPARC_HIX22
 - : BFD_RELOC_SPARC_LOX10
 - : BFD_RELOC_SPARC_H44
 - : BFD_RELOC_SPARC_M44
 - : BFD_RELOC_SPARC_L44
 - : BFD_RELOC_SPARC_REGISTER
     SPARC64 relocations

 - : BFD_RELOC_SPARC_REV32
     SPARC little endian relocation

 - : BFD_RELOC_SPARC_TLS_GD_HI22
 - : BFD_RELOC_SPARC_TLS_GD_LO10
 - : BFD_RELOC_SPARC_TLS_GD_ADD
 - : BFD_RELOC_SPARC_TLS_GD_CALL
 - : BFD_RELOC_SPARC_TLS_LDM_HI22
 - : BFD_RELOC_SPARC_TLS_LDM_LO10
 - : BFD_RELOC_SPARC_TLS_LDM_ADD
 - : BFD_RELOC_SPARC_TLS_LDM_CALL
 - : BFD_RELOC_SPARC_TLS_LDO_HIX22
 - : BFD_RELOC_SPARC_TLS_LDO_LOX10
 - : BFD_RELOC_SPARC_TLS_LDO_ADD
 - : BFD_RELOC_SPARC_TLS_IE_HI22
 - : BFD_RELOC_SPARC_TLS_IE_LO10
 - : BFD_RELOC_SPARC_TLS_IE_LD
 - : BFD_RELOC_SPARC_TLS_IE_LDX
 - : BFD_RELOC_SPARC_TLS_IE_ADD
 - : BFD_RELOC_SPARC_TLS_LE_HIX22
 - : BFD_RELOC_SPARC_TLS_LE_LOX10
 - : BFD_RELOC_SPARC_TLS_DTPMOD32
 - : BFD_RELOC_SPARC_TLS_DTPMOD64
 - : BFD_RELOC_SPARC_TLS_DTPOFF32
 - : BFD_RELOC_SPARC_TLS_DTPOFF64
 - : BFD_RELOC_SPARC_TLS_TPOFF32
 - : BFD_RELOC_SPARC_TLS_TPOFF64
     SPARC TLS relocations

 - : BFD_RELOC_ALPHA_GPDISP_HI16
     Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
     "addend" in some special way.  For GPDISP_HI16 ("gpdisp")
     relocations, the symbol is ignored when writing; when reading, it
     will be the absolute section symbol.  The addend is the
     displacement in bytes of the "lda" instruction from the "ldah"
     instruction (which is at the address of this reloc).

 - : BFD_RELOC_ALPHA_GPDISP_LO16
     For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
     with GPDISP_HI16 relocs.  The addend is ignored when writing the
     relocations out, and is filled in with the file's GP value on
     reading, for convenience.

 - : BFD_RELOC_ALPHA_GPDISP
     The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
     relocation except that there is no accompanying GPDISP_LO16
     relocation.

 - : BFD_RELOC_ALPHA_LITERAL
 - : BFD_RELOC_ALPHA_ELF_LITERAL
 - : BFD_RELOC_ALPHA_LITUSE
     The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
     the assembler turns it into a LDQ instruction to load the address
     of the symbol, and then fills in a register in the real
     instruction.

     The LITERAL reloc, at the LDQ instruction, refers to the .lita
     section symbol.  The addend is ignored when writing, but is filled
     in with the file's GP value on reading, for convenience, as with
     the GPDISP_LO16 reloc.

     The ELF_LITERAL reloc is somewhere between 16_GOTOFF and
     GPDISP_LO16.  It should refer to the symbol to be referenced, as
     with 16_GOTOFF, but it generates output not based on the position
     within the .got section, but relative to the GP value chosen for
     the file during the final link stage.

     The LITUSE reloc, on the instruction using the loaded address,
     gives information to the linker that it might be able to use to
     optimize away some literal section references.  The symbol is
     ignored (read as the absolute section symbol), and the "addend"
     indicates the type of instruction using the register: 1 - "memory"
     fmt insn 2 - byte-manipulation (byte offset reg) 3 - jsr (target
     of branch)

 - : BFD_RELOC_ALPHA_HINT
     The HINT relocation indicates a value that should be filled into
     the "hint" field of a jmp/jsr/ret instruction, for possible branch-
     prediction logic which may be provided on some processors.

 - : BFD_RELOC_ALPHA_LINKAGE
     The LINKAGE relocation outputs a linkage pair in the object file,
     which is filled by the linker.

 - : BFD_RELOC_ALPHA_CODEADDR
     The CODEADDR relocation outputs a STO_CA in the object file, which
     is filled by the linker.

 - : BFD_RELOC_ALPHA_GPREL_HI16
 - : BFD_RELOC_ALPHA_GPREL_LO16
     The GPREL_HI/LO relocations together form a 32-bit offset from the
     GP register.

 - : BFD_RELOC_ALPHA_BRSGP
     Like BFD_RELOC_23_PCREL_S2, except that the source and target must
     share a common GP, and the target address is adjusted for
     STO_ALPHA_STD_GPLOAD.

 - : BFD_RELOC_ALPHA_TLSGD
 - : BFD_RELOC_ALPHA_TLSLDM
 - : BFD_RELOC_ALPHA_DTPMOD64
 - : BFD_RELOC_ALPHA_GOTDTPREL16
 - : BFD_RELOC_ALPHA_DTPREL64
 - : BFD_RELOC_ALPHA_DTPREL_HI16
 - : BFD_RELOC_ALPHA_DTPREL_LO16
 - : BFD_RELOC_ALPHA_DTPREL16
 - : BFD_RELOC_ALPHA_GOTTPREL16
 - : BFD_RELOC_ALPHA_TPREL64
 - : BFD_RELOC_ALPHA_TPREL_HI16
 - : BFD_RELOC_ALPHA_TPREL_LO16
 - : BFD_RELOC_ALPHA_TPREL16
     Alpha thread-local storage relocations.

 - : BFD_RELOC_MIPS_JMP
     Bits 27..2 of the relocation address shifted right 2 bits; simple
     reloc otherwise.

 - : BFD_RELOC_MIPS16_JMP
     The MIPS16 jump instruction.

 - : BFD_RELOC_MIPS16_GPREL
     MIPS16 GP relative reloc.

 - : BFD_RELOC_HI16
     High 16 bits of 32-bit value; simple reloc.

 - : BFD_RELOC_HI16_S
     High 16 bits of 32-bit value but the low 16 bits will be sign
     extended and added to form the final result.  If the low 16 bits
     form a negative number, we need to add one to the high value to
     compensate for the borrow when the low bits are added.

 - : BFD_RELOC_LO16
     Low 16 bits.

 - : BFD_RELOC_PCREL_HI16_S
     Like BFD_RELOC_HI16_S, but PC relative.

 - : BFD_RELOC_PCREL_LO16
     Like BFD_RELOC_LO16, but PC relative.

 - : BFD_RELOC_MIPS_LITERAL
     Relocation against a MIPS literal section.

 - : BFD_RELOC_MIPS_GOT16
 - : BFD_RELOC_MIPS_CALL16
 - : BFD_RELOC_MIPS_GOT_HI16
 - : BFD_RELOC_MIPS_GOT_LO16
 - : BFD_RELOC_MIPS_CALL_HI16
 - : BFD_RELOC_MIPS_CALL_LO16
 - : BFD_RELOC_MIPS_SUB
 - : BFD_RELOC_MIPS_GOT_PAGE
 - : BFD_RELOC_MIPS_GOT_OFST
 - : BFD_RELOC_MIPS_GOT_DISP
 - : BFD_RELOC_MIPS_SHIFT5
 - : BFD_RELOC_MIPS_SHIFT6
 - : BFD_RELOC_MIPS_INSERT_A
 - : BFD_RELOC_MIPS_INSERT_B
 - : BFD_RELOC_MIPS_DELETE
 - : BFD_RELOC_MIPS_HIGHEST
 - : BFD_RELOC_MIPS_HIGHER
 - : BFD_RELOC_MIPS_SCN_DISP
 - : BFD_RELOC_MIPS_REL16
 - : BFD_RELOC_MIPS_RELGOT
 - : BFD_RELOC_MIPS_JALR
      - : BFD_RELOC_FRV_LABEL16
      - : BFD_RELOC_FRV_LABEL24
      - : BFD_RELOC_FRV_LO16
      - : BFD_RELOC_FRV_HI16
      - : BFD_RELOC_FRV_GPREL12
      - : BFD_RELOC_FRV_GPRELU12
      - : BFD_RELOC_FRV_GPREL32
      - : BFD_RELOC_FRV_GPRELHI
      - : BFD_RELOC_FRV_GPRELLO
          Fujitsu Frv Relocations.
     MIPS ELF relocations.

 - : BFD_RELOC_386_GOT32
 - : BFD_RELOC_386_PLT32
 - : BFD_RELOC_386_COPY
 - : BFD_RELOC_386_GLOB_DAT
 - : BFD_RELOC_386_JUMP_SLOT
 - : BFD_RELOC_386_RELATIVE
 - : BFD_RELOC_386_GOTOFF
 - : BFD_RELOC_386_GOTPC
 - : BFD_RELOC_386_TLS_TPOFF
 - : BFD_RELOC_386_TLS_IE
 - : BFD_RELOC_386_TLS_GOTIE
 - : BFD_RELOC_386_TLS_LE
 - : BFD_RELOC_386_TLS_GD
 - : BFD_RELOC_386_TLS_LDM
 - : BFD_RELOC_386_TLS_LDO_32
 - : BFD_RELOC_386_TLS_IE_32
 - : BFD_RELOC_386_TLS_LE_32
 - : BFD_RELOC_386_TLS_DTPMOD32
 - : BFD_RELOC_386_TLS_DTPOFF32
 - : BFD_RELOC_386_TLS_TPOFF32
     i386/elf relocations

 - : BFD_RELOC_X86_64_GOT32
 - : BFD_RELOC_X86_64_PLT32
 - : BFD_RELOC_X86_64_COPY
 - : BFD_RELOC_X86_64_GLOB_DAT
 - : BFD_RELOC_X86_64_JUMP_SLOT
 - : BFD_RELOC_X86_64_RELATIVE
 - : BFD_RELOC_X86_64_GOTPCREL
 - : BFD_RELOC_X86_64_32S
 - : BFD_RELOC_X86_64_DTPMOD64
 - : BFD_RELOC_X86_64_DTPOFF64
 - : BFD_RELOC_X86_64_TPOFF64
 - : BFD_RELOC_X86_64_TLSGD
 - : BFD_RELOC_X86_64_TLSLD
 - : BFD_RELOC_X86_64_DTPOFF32
 - : BFD_RELOC_X86_64_GOTTPOFF
 - : BFD_RELOC_X86_64_TPOFF32
     x86-64/elf relocations

 - : BFD_RELOC_NS32K_IMM_8
 - : BFD_RELOC_NS32K_IMM_16
 - : BFD_RELOC_NS32K_IMM_32
 - : BFD_RELOC_NS32K_IMM_8_PCREL
 - : BFD_RELOC_NS32K_IMM_16_PCREL
 - : BFD_RELOC_NS32K_IMM_32_PCREL
 - : BFD_RELOC_NS32K_DISP_8
 - : BFD_RELOC_NS32K_DISP_16
 - : BFD_RELOC_NS32K_DISP_32
 - : BFD_RELOC_NS32K_DISP_8_PCREL
 - : BFD_RELOC_NS32K_DISP_16_PCREL
 - : BFD_RELOC_NS32K_DISP_32_PCREL
     ns32k relocations

 - : BFD_RELOC_PDP11_DISP_8_PCREL
 - : BFD_RELOC_PDP11_DISP_6_PCREL
     PDP11 relocations

 - : BFD_RELOC_PJ_CODE_HI16
 - : BFD_RELOC_PJ_CODE_LO16
 - : BFD_RELOC_PJ_CODE_DIR16
 - : BFD_RELOC_PJ_CODE_DIR32
 - : BFD_RELOC_PJ_CODE_REL16
 - : BFD_RELOC_PJ_CODE_REL32
     Picojava relocs.  Not all of these appear in object files.

 - : BFD_RELOC_PPC_B26
 - : BFD_RELOC_PPC_BA26
 - : BFD_RELOC_PPC_TOC16
 - : BFD_RELOC_PPC_B16
 - : BFD_RELOC_PPC_B16_BRTAKEN
 - : BFD_RELOC_PPC_B16_BRNTAKEN
 - : BFD_RELOC_PPC_BA16
 - : BFD_RELOC_PPC_BA16_BRTAKEN
 - : BFD_RELOC_PPC_BA16_BRNTAKEN
 - : BFD_RELOC_PPC_COPY
 - : BFD_RELOC_PPC_GLOB_DAT
 - : BFD_RELOC_PPC_JMP_SLOT
 - : BFD_RELOC_PPC_RELATIVE
 - : BFD_RELOC_PPC_LOCAL24PC
 - : BFD_RELOC_PPC_EMB_NADDR32
 - : BFD_RELOC_PPC_EMB_NADDR16
 - : BFD_RELOC_PPC_EMB_NADDR16_LO
 - : BFD_RELOC_PPC_EMB_NADDR16_HI
 - : BFD_RELOC_PPC_EMB_NADDR16_HA
 - : BFD_RELOC_PPC_EMB_SDAI16
 - : BFD_RELOC_PPC_EMB_SDA2I16
 - : BFD_RELOC_PPC_EMB_SDA2REL
 - : BFD_RELOC_PPC_EMB_SDA21
 - : BFD_RELOC_PPC_EMB_MRKREF
 - : BFD_RELOC_PPC_EMB_RELSEC16
 - : BFD_RELOC_PPC_EMB_RELST_LO
 - : BFD_RELOC_PPC_EMB_RELST_HI
 - : BFD_RELOC_PPC_EMB_RELST_HA
 - : BFD_RELOC_PPC_EMB_BIT_FLD
 - : BFD_RELOC_PPC_EMB_RELSDA
 - : BFD_RELOC_PPC64_HIGHER
 - : BFD_RELOC_PPC64_HIGHER_S
 - : BFD_RELOC_PPC64_HIGHEST
 - : BFD_RELOC_PPC64_HIGHEST_S
 - : BFD_RELOC_PPC64_TOC16_LO
 - : BFD_RELOC_PPC64_TOC16_HI
 - : BFD_RELOC_PPC64_TOC16_HA
 - : BFD_RELOC_PPC64_TOC
 - : BFD_RELOC_PPC64_PLTGOT16
 - : BFD_RELOC_PPC64_PLTGOT16_LO
 - : BFD_RELOC_PPC64_PLTGOT16_HI
 - : BFD_RELOC_PPC64_PLTGOT16_HA
 - : BFD_RELOC_PPC64_ADDR16_DS
 - : BFD_RELOC_PPC64_ADDR16_LO_DS
 - : BFD_RELOC_PPC64_GOT16_DS
 - : BFD_RELOC_PPC64_GOT16_LO_DS
 - : BFD_RELOC_PPC64_PLT16_LO_DS
 - : BFD_RELOC_PPC64_SECTOFF_DS
 - : BFD_RELOC_PPC64_SECTOFF_LO_DS
 - : BFD_RELOC_PPC64_TOC16_DS
 - : BFD_RELOC_PPC64_TOC16_LO_DS
 - : BFD_RELOC_PPC64_PLTGOT16_DS
 - : BFD_RELOC_PPC64_PLTGOT16_LO_DS
     Power(rs6000) and PowerPC relocations.

 - : BFD_RELOC_PPC_TLS
 - : BFD_RELOC_PPC_DTPMOD
 - : BFD_RELOC_PPC_TPREL16
 - : BFD_RELOC_PPC_TPREL16_LO
 - : BFD_RELOC_PPC_TPREL16_HI
 - : BFD_RELOC_PPC_TPREL16_HA
 - : BFD_RELOC_PPC_TPREL
 - : BFD_RELOC_PPC_DTPREL16
 - : BFD_RELOC_PPC_DTPREL16_LO
 - : BFD_RELOC_PPC_DTPREL16_HI
 - : BFD_RELOC_PPC_DTPREL16_HA
 - : BFD_RELOC_PPC_DTPREL
 - : BFD_RELOC_PPC_GOT_TLSGD16
 - : BFD_RELOC_PPC_GOT_TLSGD16_LO
 - : BFD_RELOC_PPC_GOT_TLSGD16_HI
 - : BFD_RELOC_PPC_GOT_TLSGD16_HA
 - : BFD_RELOC_PPC_GOT_TLSLD16
 - : BFD_RELOC_PPC_GOT_TLSLD16_LO
 - : BFD_RELOC_PPC_GOT_TLSLD16_HI
 - : BFD_RELOC_PPC_GOT_TLSLD16_HA
 - : BFD_RELOC_PPC_GOT_TPREL16
 - : BFD_RELOC_PPC_GOT_TPREL16_LO
 - : BFD_RELOC_PPC_GOT_TPREL16_HI
 - : BFD_RELOC_PPC_GOT_TPREL16_HA
 - : BFD_RELOC_PPC_GOT_DTPREL16
 - : BFD_RELOC_PPC_GOT_DTPREL16_LO
 - : BFD_RELOC_PPC_GOT_DTPREL16_HI
 - : BFD_RELOC_PPC_GOT_DTPREL16_HA
 - : BFD_RELOC_PPC64_TPREL16_DS
 - : BFD_RELOC_PPC64_TPREL16_LO_DS
 - : BFD_RELOC_PPC64_TPREL16_HIGHER
 - : BFD_RELOC_PPC64_TPREL16_HIGHERA
 - : BFD_RELOC_PPC64_TPREL16_HIGHEST
 - : BFD_RELOC_PPC64_TPREL16_HIGHESTA
 - : BFD_RELOC_PPC64_DTPREL16_DS
 - : BFD_RELOC_PPC64_DTPREL16_LO_DS
 - : BFD_RELOC_PPC64_DTPREL16_HIGHER
 - : BFD_RELOC_PPC64_DTPREL16_HIGHERA
 - : BFD_RELOC_PPC64_DTPREL16_HIGHEST
 - : BFD_RELOC_PPC64_DTPREL16_HIGHESTA
     PowerPC and PowerPC64 thread-local storage relocations.

 - : BFD_RELOC_I370_D12
     IBM 370/390 relocations

 - : BFD_RELOC_CTOR
     The type of reloc used to build a contructor table - at the moment
     probably a 32 bit wide absolute relocation, but the target can
     choose.  It generally does map to one of the other relocation
     types.

 - : BFD_RELOC_ARM_PCREL_BRANCH
     ARM 26 bit pc-relative branch.  The lowest two bits must be zero
     and are not stored in the instruction.

 - : BFD_RELOC_ARM_PCREL_BLX
     ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
     not stored in the instruction.  The 2nd lowest bit comes from a 1
     bit field in the instruction.

 - : BFD_RELOC_THUMB_PCREL_BLX
     Thumb 22 bit pc-relative branch.  The lowest bit must be zero and
     is not stored in the instruction.  The 2nd lowest bit comes from a
     1 bit field in the instruction.

 - : BFD_RELOC_ARM_IMMEDIATE
 - : BFD_RELOC_ARM_ADRL_IMMEDIATE
 - : BFD_RELOC_ARM_OFFSET_IMM
 - : BFD_RELOC_ARM_SHIFT_IMM
 - : BFD_RELOC_ARM_SWI
 - : BFD_RELOC_ARM_MULTI
 - : BFD_RELOC_ARM_CP_OFF_IMM
 - : BFD_RELOC_ARM_CP_OFF_IMM_S2
 - : BFD_RELOC_ARM_ADR_IMM
 - : BFD_RELOC_ARM_LDR_IMM
 - : BFD_RELOC_ARM_LITERAL
 - : BFD_RELOC_ARM_IN_POOL
 - : BFD_RELOC_ARM_OFFSET_IMM8
 - : BFD_RELOC_ARM_HWLITERAL
 - : BFD_RELOC_ARM_THUMB_ADD
 - : BFD_RELOC_ARM_THUMB_IMM
 - : BFD_RELOC_ARM_THUMB_SHIFT
 - : BFD_RELOC_ARM_THUMB_OFFSET
 - : BFD_RELOC_ARM_GOT12
 - : BFD_RELOC_ARM_GOT32
 - : BFD_RELOC_ARM_JUMP_SLOT
 - : BFD_RELOC_ARM_COPY
 - : BFD_RELOC_ARM_GLOB_DAT
 - : BFD_RELOC_ARM_PLT32
 - : BFD_RELOC_ARM_RELATIVE
 - : BFD_RELOC_ARM_GOTOFF
 - : BFD_RELOC_ARM_GOTPC
     These relocs are only used within the ARM assembler.  They are not
     (at present) written to any object files.

 - : BFD_RELOC_SH_PCDISP8BY2
 - : BFD_RELOC_SH_PCDISP12BY2
 - : BFD_RELOC_SH_IMM4
 - : BFD_RELOC_SH_IMM4BY2
 - : BFD_RELOC_SH_IMM4BY4
 - : BFD_RELOC_SH_IMM8
 - : BFD_RELOC_SH_IMM8BY2
 - : BFD_RELOC_SH_IMM8BY4
 - : BFD_RELOC_SH_PCRELIMM8BY2
 - : BFD_RELOC_SH_PCRELIMM8BY4
 - : BFD_RELOC_SH_SWITCH16
 - : BFD_RELOC_SH_SWITCH32
 - : BFD_RELOC_SH_USES
 - : BFD_RELOC_SH_COUNT
 - : BFD_RELOC_SH_ALIGN
 - : BFD_RELOC_SH_CODE
 - : BFD_RELOC_SH_DATA
 - : BFD_RELOC_SH_LABEL
 - : BFD_RELOC_SH_LOOP_START
 - : BFD_RELOC_SH_LOOP_END
 - : BFD_RELOC_SH_COPY
 - : BFD_RELOC_SH_GLOB_DAT
 - : BFD_RELOC_SH_JMP_SLOT
 - : BFD_RELOC_SH_RELATIVE
 - : BFD_RELOC_SH_GOTPC
 - : BFD_RELOC_SH_GOT_LOW16
 - : BFD_RELOC_SH_GOT_MEDLOW16
 - : BFD_RELOC_SH_GOT_MEDHI16
 - : BFD_RELOC_SH_GOT_HI16
 - : BFD_RELOC_SH_GOTPLT_LOW16
 - : BFD_RELOC_SH_GOTPLT_MEDLOW16
 - : BFD_RELOC_SH_GOTPLT_MEDHI16
 - : BFD_RELOC_SH_GOTPLT_HI16
 - : BFD_RELOC_SH_PLT_LOW16
 - : BFD_RELOC_SH_PLT_MEDLOW16
 - : BFD_RELOC_SH_PLT_MEDHI16
 - : BFD_RELOC_SH_PLT_HI16
 - : BFD_RELOC_SH_GOTOFF_LOW16
 - : BFD_RELOC_SH_GOTOFF_MEDLOW16
 - : BFD_RELOC_SH_GOTOFF_MEDHI16
 - : BFD_RELOC_SH_GOTOFF_HI16
 - : BFD_RELOC_SH_GOTPC_LOW16
 - : BFD_RELOC_SH_GOTPC_MEDLOW16
 - : BFD_RELOC_SH_GOTPC_MEDHI16
 - : BFD_RELOC_SH_GOTPC_HI16
 - : BFD_RELOC_SH_COPY64
 - : BFD_RELOC_SH_GLOB_DAT64
 - : BFD_RELOC_SH_JMP_SLOT64
 - : BFD_RELOC_SH_RELATIVE64
 - : BFD_RELOC_SH_GOT10BY4
 - : BFD_RELOC_SH_GOT10BY8
 - : BFD_RELOC_SH_GOTPLT10BY4
 - : BFD_RELOC_SH_GOTPLT10BY8
 - : BFD_RELOC_SH_GOTPLT32
 - : BFD_RELOC_SH_SHMEDIA_CODE
 - : BFD_RELOC_SH_IMMU5
 - : BFD_RELOC_SH_IMMS6
 - : BFD_RELOC_SH_IMMS6BY32
 - : BFD_RELOC_SH_IMMU6
 - : BFD_RELOC_SH_IMMS10
 - : BFD_RELOC_SH_IMMS10BY2
 - : BFD_RELOC_SH_IMMS10BY4
 - : BFD_RELOC_SH_IMMS10BY8
 - : BFD_RELOC_SH_IMMS16
 - : BFD_RELOC_SH_IMMU16
 - : BFD_RELOC_SH_IMM_LOW16
 - : BFD_RELOC_SH_IMM_LOW16_PCREL
 - : BFD_RELOC_SH_IMM_MEDLOW16
 - : BFD_RELOC_SH_IMM_MEDLOW16_PCREL
 - : BFD_RELOC_SH_IMM_MEDHI16
 - : BFD_RELOC_SH_IMM_MEDHI16_PCREL
 - : BFD_RELOC_SH_IMM_HI16
 - : BFD_RELOC_SH_IMM_HI16_PCREL
 - : BFD_RELOC_SH_PT_16
 - : BFD_RELOC_SH_TLS_GD_32
 - : BFD_RELOC_SH_TLS_LD_32
 - : BFD_RELOC_SH_TLS_LDO_32
 - : BFD_RELOC_SH_TLS_IE_32
 - : BFD_RELOC_SH_TLS_LE_32
 - : BFD_RELOC_SH_TLS_DTPMOD32
 - : BFD_RELOC_SH_TLS_DTPOFF32
 - : BFD_RELOC_SH_TLS_TPOFF32
     Renesas / SuperH SH relocs.  Not all of these appear in object
     files.

 - : BFD_RELOC_THUMB_PCREL_BRANCH9
 - : BFD_RELOC_THUMB_PCREL_BRANCH12
 - : BFD_RELOC_THUMB_PCREL_BRANCH23
     Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
     be zero and is not stored in the instruction.

 - : BFD_RELOC_ARC_B22_PCREL
     ARC Cores relocs.  ARC 22 bit pc-relative branch.  The lowest two
     bits must be zero and are not stored in the instruction.  The high
     20 bits are installed in bits 26 through 7 of the instruction.

 - : BFD_RELOC_ARC_B26
     ARC 26 bit absolute branch.  The lowest two bits must be zero and
     are not stored in the instruction.  The high 24 bits are installed
     in bits 23 through 0.

 - : BFD_RELOC_D10V_10_PCREL_R
     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
     bits assumed to be 0.

 - : BFD_RELOC_D10V_10_PCREL_L
     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
     bits assumed to be 0.  This is the same as the previous reloc
     except it is in the left container, i.e., shifted left 15 bits.

 - : BFD_RELOC_D10V_18
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_D10V_18_PCREL
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_D30V_6
     Mitsubishi D30V relocs.  This is a 6-bit absolute reloc.

 - : BFD_RELOC_D30V_9_PCREL
     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
     be 0.

 - : BFD_RELOC_D30V_9_PCREL_R
     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
     be 0. Same as the previous reloc but on the right side of the
     container.

 - : BFD_RELOC_D30V_15
     This is a 12-bit absolute reloc with the right 3 bitsassumed to be
     0.

 - : BFD_RELOC_D30V_15_PCREL
     This is a 12-bit pc-relative reloc with the right 3 bits assumed
     to be 0.

 - : BFD_RELOC_D30V_15_PCREL_R
     This is a 12-bit pc-relative reloc with the right 3 bits assumed
     to be 0. Same as the previous reloc but on the right side of the
     container.

 - : BFD_RELOC_D30V_21
     This is an 18-bit absolute reloc with the right 3 bits assumed to
     be 0.

 - : BFD_RELOC_D30V_21_PCREL
     This is an 18-bit pc-relative reloc with the right 3 bits assumed
     to be 0.

 - : BFD_RELOC_D30V_21_PCREL_R
     This is an 18-bit pc-relative reloc with the right 3 bits assumed
     to be 0. Same as the previous reloc but on the right side of the
     container.

 - : BFD_RELOC_D30V_32
     This is a 32-bit absolute reloc.

 - : BFD_RELOC_D30V_32_PCREL
     This is a 32-bit pc-relative reloc.

 - : BFD_RELOC_DLX_HI16_S
     DLX relocs

 - : BFD_RELOC_DLX_LO16
     DLX relocs

 - : BFD_RELOC_DLX_JMP26
     DLX relocs

 - : BFD_RELOC_M32R_24
     Renesas M32R (formerly Mitsubishi M32R) relocs.  This is a 24 bit
     absolute address.

 - : BFD_RELOC_M32R_10_PCREL
     This is a 10-bit pc-relative reloc with the right 2 bits assumed
     to be 0.

 - : BFD_RELOC_M32R_18_PCREL
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_M32R_26_PCREL
     This is a 26-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_M32R_HI16_ULO
     This is a 16-bit reloc containing the high 16 bits of an address
     used when the lower 16 bits are treated as unsigned.

 - : BFD_RELOC_M32R_HI16_SLO
     This is a 16-bit reloc containing the high 16 bits of an address
     used when the lower 16 bits are treated as signed.

 - : BFD_RELOC_M32R_LO16
     This is a 16-bit reloc containing the lower 16 bits of an address.

 - : BFD_RELOC_M32R_SDA16
     This is a 16-bit reloc containing the small data area offset for
     use in add3, load, and store instructions.

 - : BFD_RELOC_V850_9_PCREL
     This is a 9-bit reloc

 - : BFD_RELOC_V850_22_PCREL
     This is a 22-bit reloc

 - : BFD_RELOC_V850_SDA_16_16_OFFSET
     This is a 16 bit offset from the short data area pointer.

 - : BFD_RELOC_V850_SDA_15_16_OFFSET
     This is a 16 bit offset (of which only 15 bits are used) from the
     short data area pointer.

 - : BFD_RELOC_V850_ZDA_16_16_OFFSET
     This is a 16 bit offset from the zero data area pointer.

 - : BFD_RELOC_V850_ZDA_15_16_OFFSET
     This is a 16 bit offset (of which only 15 bits are used) from the
     zero data area pointer.

 - : BFD_RELOC_V850_TDA_6_8_OFFSET
     This is an 8 bit offset (of which only 6 bits are used) from the
     tiny data area pointer.

 - : BFD_RELOC_V850_TDA_7_8_OFFSET
     This is an 8bit offset (of which only 7 bits are used) from the
     tiny data area pointer.

 - : BFD_RELOC_V850_TDA_7_7_OFFSET
     This is a 7 bit offset from the tiny data area pointer.

 - : BFD_RELOC_V850_TDA_16_16_OFFSET
     This is a 16 bit offset from the tiny data area pointer.

 - : BFD_RELOC_V850_TDA_4_5_OFFSET
     This is a 5 bit offset (of which only 4 bits are used) from the
     tiny data area pointer.

 - : BFD_RELOC_V850_TDA_4_4_OFFSET
     This is a 4 bit offset from the tiny data area pointer.

 - : BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET
     This is a 16 bit offset from the short data area pointer, with the
     bits placed non-contigously in the instruction.

 - : BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET
     This is a 16 bit offset from the zero data area pointer, with the
     bits placed non-contigously in the instruction.

 - : BFD_RELOC_V850_CALLT_6_7_OFFSET
     This is a 6 bit offset from the call table base pointer.

 - : BFD_RELOC_V850_CALLT_16_16_OFFSET
     This is a 16 bit offset from the call table base pointer.

 - : BFD_RELOC_V850_LONGCALL
     Used for relaxing indirect function calls.

 - : BFD_RELOC_V850_LONGJUMP
     Used for relaxing indirect jumps.

 - : BFD_RELOC_V850_ALIGN
     Used to maintain alignment whilst relaxing.

 - : BFD_RELOC_MN10300_32_PCREL
     This is a 32bit pcrel reloc for the mn10300, offset by two bytes
     in the instruction.

 - : BFD_RELOC_MN10300_16_PCREL
     This is a 16bit pcrel reloc for the mn10300, offset by two bytes
     in the instruction.

 - : BFD_RELOC_TIC30_LDP
     This is a 8bit DP reloc for the tms320c30, where the most
     significant 8 bits of a 24 bit word are placed into the least
     significant 8 bits of the opcode.

 - : BFD_RELOC_TIC54X_PARTLS7
     This is a 7bit reloc for the tms320c54x, where the least
     significant 7 bits of a 16 bit word are placed into the least
     significant 7 bits of the opcode.

 - : BFD_RELOC_TIC54X_PARTMS9
     This is a 9bit DP reloc for the tms320c54x, where the most
     significant 9 bits of a 16 bit word are placed into the least
     significant 9 bits of the opcode.

 - : BFD_RELOC_TIC54X_23
     This is an extended address 23-bit reloc for the tms320c54x.

 - : BFD_RELOC_TIC54X_16_OF_23
     This is a 16-bit reloc for the tms320c54x, where the least
     significant 16 bits of a 23-bit extended address are placed into
     the opcode.

 - : BFD_RELOC_TIC54X_MS7_OF_23
     This is a reloc for the tms320c54x, where the most significant 7
     bits of a 23-bit extended address are placed into the opcode.

 - : BFD_RELOC_FR30_48
     This is a 48 bit reloc for the FR30 that stores 32 bits.

 - : BFD_RELOC_FR30_20
     This is a 32 bit reloc for the FR30 that stores 20 bits split up
     into two sections.

 - : BFD_RELOC_FR30_6_IN_4
     This is a 16 bit reloc for the FR30 that stores a 6 bit word
     offset in 4 bits.

 - : BFD_RELOC_FR30_8_IN_8
     This is a 16 bit reloc for the FR30 that stores an 8 bit byte
     offset into 8 bits.

 - : BFD_RELOC_FR30_9_IN_8
     This is a 16 bit reloc for the FR30 that stores a 9 bit short
     offset into 8 bits.

 - : BFD_RELOC_FR30_10_IN_8
     This is a 16 bit reloc for the FR30 that stores a 10 bit word
     offset into 8 bits.

 - : BFD_RELOC_FR30_9_PCREL
     This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
     short offset into 8 bits.

 - : BFD_RELOC_FR30_12_PCREL
     This is a 16 bit reloc for the FR30 that stores a 12 bit pc
     relative short offset into 11 bits.

 - : BFD_RELOC_MCORE_PCREL_IMM8BY4
 - : BFD_RELOC_MCORE_PCREL_IMM11BY2
 - : BFD_RELOC_MCORE_PCREL_IMM4BY2
 - : BFD_RELOC_MCORE_PCREL_32
 - : BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
 - : BFD_RELOC_MCORE_RVA
     Motorola Mcore relocations.

 - : BFD_RELOC_MMIX_GETA
 - : BFD_RELOC_MMIX_GETA_1
 - : BFD_RELOC_MMIX_GETA_2
 - : BFD_RELOC_MMIX_GETA_3
     These are relocations for the GETA instruction.

 - : BFD_RELOC_MMIX_CBRANCH
 - : BFD_RELOC_MMIX_CBRANCH_J
 - : BFD_RELOC_MMIX_CBRANCH_1
 - : BFD_RELOC_MMIX_CBRANCH_2
 - : BFD_RELOC_MMIX_CBRANCH_3
     These are relocations for a conditional branch instruction.

 - : BFD_RELOC_MMIX_PUSHJ
 - : BFD_RELOC_MMIX_PUSHJ_1
 - : BFD_RELOC_MMIX_PUSHJ_2
 - : BFD_RELOC_MMIX_PUSHJ_3
     These are relocations for the PUSHJ instruction.

 - : BFD_RELOC_MMIX_JMP
 - : BFD_RELOC_MMIX_JMP_1
 - : BFD_RELOC_MMIX_JMP_2
 - : BFD_RELOC_MMIX_JMP_3
     These are relocations for the JMP instruction.

 - : BFD_RELOC_MMIX_ADDR19
     This is a relocation for a relative address as in a GETA
     instruction or a branch.

 - : BFD_RELOC_MMIX_ADDR27
     This is a relocation for a relative address as in a JMP
     instruction.

 - : BFD_RELOC_MMIX_REG_OR_BYTE
     This is a relocation for an instruction field that may be a general
     register or a value 0..255.

 - : BFD_RELOC_MMIX_REG
     This is a relocation for an instruction field that may be a general
     register.

 - : BFD_RELOC_MMIX_BASE_PLUS_OFFSET
     This is a relocation for two instruction fields holding a register
     and an offset, the equivalent of the relocation.

 - : BFD_RELOC_MMIX_LOCAL
     This relocation is an assertion that the expression is not
     allocated as a global register.  It does not modify contents.

 - : BFD_RELOC_AVR_7_PCREL
     This is a 16 bit reloc for the AVR that stores 8 bit pc relative
     short offset into 7 bits.

 - : BFD_RELOC_AVR_13_PCREL
     This is a 16 bit reloc for the AVR that stores 13 bit pc relative
     short offset into 12 bits.

 - : BFD_RELOC_AVR_16_PM
     This is a 16 bit reloc for the AVR that stores 17 bit value
     (usually program memory address) into 16 bits.

 - : BFD_RELOC_AVR_LO8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
     data memory address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HI8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
     bit of data memory address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HH8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (most
     high 8 bit of program memory address) into 8 bit immediate value
     of LDI insn.

 - : BFD_RELOC_AVR_LO8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (usually data memory address) into 8 bit immediate value of SUBI
     insn.

 - : BFD_RELOC_AVR_HI8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 8 bit of data memory address) into 8 bit immediate value of
     SUBI insn.

 - : BFD_RELOC_AVR_HH8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (most high 8 bit of program memory address) into 8 bit immediate
     value of LDI or SUBI insn.

 - : BFD_RELOC_AVR_LO8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
     command address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HI8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
     bit of command address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HH8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (most
     high 8 bit of command address) into 8 bit immediate value of LDI
     insn.

 - : BFD_RELOC_AVR_LO8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (usually command address) into 8 bit immediate value of SUBI insn.

 - : BFD_RELOC_AVR_HI8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 8 bit of 16 bit command address) into 8 bit immediate value
     of SUBI insn.

 - : BFD_RELOC_AVR_HH8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 6 bit of 22 bit command address) into 8 bit immediate value
     of SUBI insn.

 - : BFD_RELOC_AVR_CALL
     This is a 32 bit reloc for the AVR that stores 23 bit value into
     22 bits.

 - : BFD_RELOC_390_12
     Direct 12 bit.

 - : BFD_RELOC_390_GOT12
     12 bit GOT offset.

 - : BFD_RELOC_390_PLT32
     32 bit PC relative PLT address.

 - : BFD_RELOC_390_COPY
     Copy symbol at runtime.

 - : BFD_RELOC_390_GLOB_DAT
     Create GOT entry.

 - : BFD_RELOC_390_JMP_SLOT
     Create PLT entry.

 - : BFD_RELOC_390_RELATIVE
     Adjust by program base.

 - : BFD_RELOC_390_GOTPC
     32 bit PC relative offset to GOT.

 - : BFD_RELOC_390_GOT16
     16 bit GOT offset.

 - : BFD_RELOC_390_PC16DBL
     PC relative 16 bit shifted by 1.

 - : BFD_RELOC_390_PLT16DBL
     16 bit PC rel. PLT shifted by 1.

 - : BFD_RELOC_390_PC32DBL
     PC relative 32 bit shifted by 1.

 - : BFD_RELOC_390_PLT32DBL
     32 bit PC rel. PLT shifted by 1.

 - : BFD_RELOC_390_GOTPCDBL
     32 bit PC rel. GOT shifted by 1.

 - : BFD_RELOC_390_GOT64
     64 bit GOT offset.

 - : BFD_RELOC_390_PLT64
     64 bit PC relative PLT address.

 - : BFD_RELOC_390_GOTENT
     32 bit rel. offset to GOT entry.

 - : BFD_RELOC_390_GOTOFF64
     64 bit offset to GOT.

 - : BFD_RELOC_390_GOTPLT12
     12-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_390_GOTPLT16
     16-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_390_GOTPLT32
     32-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_390_GOTPLT64
     64-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_390_GOTPLTENT
     32-bit rel. offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_390_PLTOFF16
     16-bit rel. offset from the GOT to a PLT entry.

 - : BFD_RELOC_390_PLTOFF32
     32-bit rel. offset from the GOT to a PLT entry.

 - : BFD_RELOC_390_PLTOFF64
     64-bit rel. offset from the GOT to a PLT entry.

 - : BFD_RELOC_390_TLS_LOAD
 - : BFD_RELOC_390_TLS_GDCALL
 - : BFD_RELOC_390_TLS_LDCALL
 - : BFD_RELOC_390_TLS_GD32
 - : BFD_RELOC_390_TLS_GD64
 - : BFD_RELOC_390_TLS_GOTIE12
 - : BFD_RELOC_390_TLS_GOTIE32
 - : BFD_RELOC_390_TLS_GOTIE64
 - : BFD_RELOC_390_TLS_LDM32
 - : BFD_RELOC_390_TLS_LDM64
 - : BFD_RELOC_390_TLS_IE32
 - : BFD_RELOC_390_TLS_IE64
 - : BFD_RELOC_390_TLS_IEENT
 - : BFD_RELOC_390_TLS_LE32
 - : BFD_RELOC_390_TLS_LE64
 - : BFD_RELOC_390_TLS_LDO32
 - : BFD_RELOC_390_TLS_LDO64
 - : BFD_RELOC_390_TLS_DTPMOD
 - : BFD_RELOC_390_TLS_DTPOFF
 - : BFD_RELOC_390_TLS_TPOFF
     s390 tls relocations.

 - : BFD_RELOC_IP2K_FR9
     Scenix IP2K - 9-bit register number / data address

 - : BFD_RELOC_IP2K_BANK
     Scenix IP2K - 4-bit register/data bank number

 - : BFD_RELOC_IP2K_ADDR16CJP
     Scenix IP2K - low 13 bits of instruction word address

 - : BFD_RELOC_IP2K_PAGE3
     Scenix IP2K - high 3 bits of instruction word address

 - : BFD_RELOC_IP2K_LO8DATA
 - : BFD_RELOC_IP2K_HI8DATA
 - : BFD_RELOC_IP2K_EX8DATA
     Scenix IP2K - ext/low/high 8 bits of data address

 - : BFD_RELOC_IP2K_LO8INSN
 - : BFD_RELOC_IP2K_HI8INSN
     Scenix IP2K - low/high 8 bits of instruction word address

 - : BFD_RELOC_IP2K_PC_SKIP
     Scenix IP2K - even/odd PC modifier to modify snb pcl.0

 - : BFD_RELOC_IP2K_TEXT
     Scenix IP2K - 16 bit word address in text section.

 - : BFD_RELOC_IP2K_FR_OFFSET
     Scenix IP2K - 7-bit sp or dp offset

 - : BFD_RELOC_VPE4KMATH_DATA
 - : BFD_RELOC_VPE4KMATH_INSN
     Scenix VPE4K coprocessor - data/insn-space addressing

 - : BFD_RELOC_VTABLE_INHERIT
 - : BFD_RELOC_VTABLE_ENTRY
     These two relocations are used by the linker to determine which of
     the entries in a C++ virtual function table are actually used.
     When the -gc-sections option is given, the linker will zero out
     the entries that are not used, so that the code for those
     functions need not be included in the output.

     VTABLE_INHERIT is a zero-space relocation used to describe to the
     linker the inheritence tree of a C++ virtual function table.  The
     relocation's symbol should be the parent class' vtable, and the
     relocation should be located at the child vtable.

     VTABLE_ENTRY is a zero-space relocation that describes the use of a
     virtual function table entry.  The reloc's symbol should refer to
     the table of the class mentioned in the code.  Off of that base,
     an offset describes the entry that is being used.  For Rela hosts,
     this offset is stored in the reloc's addend.  For Rel hosts, we
     are forced to put this offset in the reloc's section offset.

 - : BFD_RELOC_IA64_IMM14
 - : BFD_RELOC_IA64_IMM22
 - : BFD_RELOC_IA64_IMM64
 - : BFD_RELOC_IA64_DIR32MSB
 - : BFD_RELOC_IA64_DIR32LSB
 - : BFD_RELOC_IA64_DIR64MSB
 - : BFD_RELOC_IA64_DIR64LSB
 - : BFD_RELOC_IA64_GPREL22
 - : BFD_RELOC_IA64_GPREL64I
 - : BFD_RELOC_IA64_GPREL32MSB
 - : BFD_RELOC_IA64_GPREL32LSB
 - : BFD_RELOC_IA64_GPREL64MSB
 - : BFD_RELOC_IA64_GPREL64LSB
 - : BFD_RELOC_IA64_LTOFF22
 - : BFD_RELOC_IA64_LTOFF64I
 - : BFD_RELOC_IA64_PLTOFF22
 - : BFD_RELOC_IA64_PLTOFF64I
 - : BFD_RELOC_IA64_PLTOFF64MSB
 - : BFD_RELOC_IA64_PLTOFF64LSB
 - : BFD_RELOC_IA64_FPTR64I
 - : BFD_RELOC_IA64_FPTR32MSB
 - : BFD_RELOC_IA64_FPTR32LSB
 - : BFD_RELOC_IA64_FPTR64MSB
 - : BFD_RELOC_IA64_FPTR64LSB
 - : BFD_RELOC_IA64_PCREL21B
 - : BFD_RELOC_IA64_PCREL21BI
 - : BFD_RELOC_IA64_PCREL21M
 - : BFD_RELOC_IA64_PCREL21F
 - : BFD_RELOC_IA64_PCREL22
 - : BFD_RELOC_IA64_PCREL60B
 - : BFD_RELOC_IA64_PCREL64I
 - : BFD_RELOC_IA64_PCREL32MSB
 - : BFD_RELOC_IA64_PCREL32LSB
 - : BFD_RELOC_IA64_PCREL64MSB
 - : BFD_RELOC_IA64_PCREL64LSB
 - : BFD_RELOC_IA64_LTOFF_FPTR22
 - : BFD_RELOC_IA64_LTOFF_FPTR64I
 - : BFD_RELOC_IA64_LTOFF_FPTR32MSB
 - : BFD_RELOC_IA64_LTOFF_FPTR32LSB
 - : BFD_RELOC_IA64_LTOFF_FPTR64MSB
 - : BFD_RELOC_IA64_LTOFF_FPTR64LSB
 - : BFD_RELOC_IA64_SEGREL32MSB
 - : BFD_RELOC_IA64_SEGREL32LSB
 - : BFD_RELOC_IA64_SEGREL64MSB
 - : BFD_RELOC_IA64_SEGREL64LSB
 - : BFD_RELOC_IA64_SECREL32MSB
 - : BFD_RELOC_IA64_SECREL32LSB
 - : BFD_RELOC_IA64_SECREL64MSB
 - : BFD_RELOC_IA64_SECREL64LSB
 - : BFD_RELOC_IA64_REL32MSB
 - : BFD_RELOC_IA64_REL32LSB
 - : BFD_RELOC_IA64_REL64MSB
 - : BFD_RELOC_IA64_REL64LSB
 - : BFD_RELOC_IA64_LTV32MSB
 - : BFD_RELOC_IA64_LTV32LSB
 - : BFD_RELOC_IA64_LTV64MSB
 - : BFD_RELOC_IA64_LTV64LSB
 - : BFD_RELOC_IA64_IPLTMSB
 - : BFD_RELOC_IA64_IPLTLSB
 - : BFD_RELOC_IA64_COPY
 - : BFD_RELOC_IA64_LTOFF22X
 - : BFD_RELOC_IA64_LDXMOV
 - : BFD_RELOC_IA64_TPREL14
 - : BFD_RELOC_IA64_TPREL22
 - : BFD_RELOC_IA64_TPREL64I
 - : BFD_RELOC_IA64_TPREL64MSB
 - : BFD_RELOC_IA64_TPREL64LSB
 - : BFD_RELOC_IA64_LTOFF_TPREL22
 - : BFD_RELOC_IA64_DTPMOD64MSB
 - : BFD_RELOC_IA64_DTPMOD64LSB
 - : BFD_RELOC_IA64_LTOFF_DTPMOD22
 - : BFD_RELOC_IA64_DTPREL14
 - : BFD_RELOC_IA64_DTPREL22
 - : BFD_RELOC_IA64_DTPREL64I
 - : BFD_RELOC_IA64_DTPREL32MSB
 - : BFD_RELOC_IA64_DTPREL32LSB
 - : BFD_RELOC_IA64_DTPREL64MSB
 - : BFD_RELOC_IA64_DTPREL64LSB
 - : BFD_RELOC_IA64_LTOFF_DTPREL22
     Intel IA64 Relocations.

 - : BFD_RELOC_M68HC11_HI8
     Motorola 68HC11 reloc.  This is the 8 bit high part of an absolute
     address.

 - : BFD_RELOC_M68HC11_LO8
     Motorola 68HC11 reloc.  This is the 8 bit low part of an absolute
     address.

 - : BFD_RELOC_M68HC11_3B
     Motorola 68HC11 reloc.  This is the 3 bit of a value.

 - : BFD_RELOC_M68HC11_RL_JUMP
     Motorola 68HC11 reloc.  This reloc marks the beginning of a
     jump/call instruction.  It is used for linker relaxation to
     correctly identify beginning of instruction and change some
     branchs to use PC-relative addressing mode.

 - : BFD_RELOC_M68HC11_RL_GROUP
     Motorola 68HC11 reloc.  This reloc marks a group of several
     instructions that gcc generates and for which the linker
     relaxation pass can modify and/or remove some of them.

 - : BFD_RELOC_M68HC11_LO16
     Motorola 68HC11 reloc.  This is the 16-bit lower part of an
     address.  It is used for 'call' instruction to specify the symbol
     address without any special transformation (due to memory bank
     window).

 - : BFD_RELOC_M68HC11_PAGE
     Motorola 68HC11 reloc.  This is a 8-bit reloc that specifies the
     page number of an address.  It is used by 'call' instruction to
     specify the page number of the symbol.

 - : BFD_RELOC_M68HC11_24
     Motorola 68HC11 reloc.  This is a 24-bit reloc that represents the
     address with a 16-bit value and a 8-bit page number.  The symbol
     address is transformed to follow the 16K memory bank of 68HC12
     (seen as mapped in the window).

 - : BFD_RELOC_CRIS_BDISP8
 - : BFD_RELOC_CRIS_UNSIGNED_5
 - : BFD_RELOC_CRIS_SIGNED_6
 - : BFD_RELOC_CRIS_UNSIGNED_6
 - : BFD_RELOC_CRIS_UNSIGNED_4
     These relocs are only used within the CRIS assembler.  They are not
     (at present) written to any object files.

 - : BFD_RELOC_CRIS_COPY
 - : BFD_RELOC_CRIS_GLOB_DAT
 - : BFD_RELOC_CRIS_JUMP_SLOT
 - : BFD_RELOC_CRIS_RELATIVE
     Relocs used in ELF shared libraries for CRIS.

 - : BFD_RELOC_CRIS_32_GOT
     32-bit offset to symbol-entry within GOT.

 - : BFD_RELOC_CRIS_16_GOT
     16-bit offset to symbol-entry within GOT.

 - : BFD_RELOC_CRIS_32_GOTPLT
     32-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_CRIS_16_GOTPLT
     16-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_CRIS_32_GOTREL
     32-bit offset to symbol, relative to GOT.

 - : BFD_RELOC_CRIS_32_PLT_GOTREL
     32-bit offset to symbol with PLT entry, relative to GOT.

 - : BFD_RELOC_CRIS_32_PLT_PCREL
     32-bit offset to symbol with PLT entry, relative to this
     relocation.

 - : BFD_RELOC_860_COPY
 - : BFD_RELOC_860_GLOB_DAT
 - : BFD_RELOC_860_JUMP_SLOT
 - : BFD_RELOC_860_RELATIVE
 - : BFD_RELOC_860_PC26
 - : BFD_RELOC_860_PLT26
 - : BFD_RELOC_860_PC16
 - : BFD_RELOC_860_LOW0
 - : BFD_RELOC_860_SPLIT0
 - : BFD_RELOC_860_LOW1
 - : BFD_RELOC_860_SPLIT1
 - : BFD_RELOC_860_LOW2
 - : BFD_RELOC_860_SPLIT2
 - : BFD_RELOC_860_LOW3
 - : BFD_RELOC_860_LOGOT0
 - : BFD_RELOC_860_SPGOT0
 - : BFD_RELOC_860_LOGOT1
 - : BFD_RELOC_860_SPGOT1
 - : BFD_RELOC_860_LOGOTOFF0
 - : BFD_RELOC_860_SPGOTOFF0
 - : BFD_RELOC_860_LOGOTOFF1
 - : BFD_RELOC_860_SPGOTOFF1
 - : BFD_RELOC_860_LOGOTOFF2
 - : BFD_RELOC_860_LOGOTOFF3
 - : BFD_RELOC_860_LOPC
 - : BFD_RELOC_860_HIGHADJ
 - : BFD_RELOC_860_HAGOT
 - : BFD_RELOC_860_HAGOTOFF
 - : BFD_RELOC_860_HAPC
 - : BFD_RELOC_860_HIGH
 - : BFD_RELOC_860_HIGOT
 - : BFD_RELOC_860_HIGOTOFF
     Intel i860 Relocations.

 - : BFD_RELOC_OPENRISC_ABS_26
 - : BFD_RELOC_OPENRISC_REL_26
     OpenRISC Relocations.

 - : BFD_RELOC_H8_DIR16A8
 - : BFD_RELOC_H8_DIR16R8
 - : BFD_RELOC_H8_DIR24A8
 - : BFD_RELOC_H8_DIR24R8
 - : BFD_RELOC_H8_DIR32A16
     H8 elf Relocations.

 - : BFD_RELOC_XSTORMY16_REL_12
 - : BFD_RELOC_XSTORMY16_12
 - : BFD_RELOC_XSTORMY16_24
 - : BFD_RELOC_XSTORMY16_FPTR16
     Sony Xstormy16 Relocations.

 - : BFD_RELOC_VAX_GLOB_DAT
 - : BFD_RELOC_VAX_JMP_SLOT
 - : BFD_RELOC_VAX_RELATIVE
     Relocations used by VAX ELF.

 - : BFD_RELOC_MSP430_10_PCREL
 - : BFD_RELOC_MSP430_16_PCREL
 - : BFD_RELOC_MSP430_16
 - : BFD_RELOC_MSP430_16_PCREL_BYTE
 - : BFD_RELOC_MSP430_16_BYTE
     msp430 specific relocation codes

 - : BFD_RELOC_IQ2000_OFFSET_16
 - : BFD_RELOC_IQ2000_OFFSET_21
 - : BFD_RELOC_IQ2000_UHI16
     IQ2000 Relocations.

 - : BFD_RELOC_XTENSA_RTLD
     Special Xtensa relocation used only by PLT entries in ELF shared
     objects to indicate that the runtime linker should set the value
     to one of its own internal functions or data structures.

 - : BFD_RELOC_XTENSA_GLOB_DAT
 - : BFD_RELOC_XTENSA_JMP_SLOT
 - : BFD_RELOC_XTENSA_RELATIVE
     Xtensa relocations for ELF shared objects.

 - : BFD_RELOC_XTENSA_PLT
     Xtensa relocation used in ELF object files for symbols that may
     require PLT entries.  Otherwise, this is just a generic 32-bit
     relocation.

 - : BFD_RELOC_XTENSA_OP0
 - : BFD_RELOC_XTENSA_OP1
 - : BFD_RELOC_XTENSA_OP2
     Generic Xtensa relocations.  Only the operand number is encoded in
     the relocation.  The details are determined by extracting the
     instruction opcode.

 - : BFD_RELOC_XTENSA_ASM_EXPAND
     Xtensa relocation to mark that the assembler expanded the
     instructions from an original target.  The expansion size is
     encoded in the reloc size.

 - : BFD_RELOC_XTENSA_ASM_SIMPLIFY
     Xtensa relocation to mark that the linker should simplify
     assembler-expanded instructions.  This is commonly used internally
     by the linker after analysis of a BFD_RELOC_XTENSA_ASM_EXPAND.


     typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;

`bfd_reloc_type_lookup'
.......................

   *Synopsis*
     reloc_howto_type *
     bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code);
   *Description*
Return a pointer to a howto structure which, when invoked, will perform
the relocation CODE on data from the architecture noted.

`bfd_default_reloc_type_lookup'
...............................

   *Synopsis*
     reloc_howto_type *bfd_default_reloc_type_lookup
        (bfd *abfd, bfd_reloc_code_real_type  code);
   *Description*
Provides a default relocation lookup routine for any architecture.

`bfd_get_reloc_code_name'
.........................

   *Synopsis*
     const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
   *Description*
Provides a printable name for the supplied relocation code.  Useful
mainly for printing error messages.

`bfd_generic_relax_section'
...........................

   *Synopsis*
     bfd_boolean bfd_generic_relax_section
        (bfd *abfd,
         asection *section,
         struct bfd_link_info *,
         bfd_boolean *);
   *Description*
Provides default handling for relaxing for back ends which don't do
relaxing - i.e., does nothing.

`bfd_generic_gc_sections'
.........................

   *Synopsis*
     bfd_boolean bfd_generic_gc_sections
        (bfd *, struct bfd_link_info *);
   *Description*
Provides default handling for relaxing for back ends which don't do
section gc - i.e., does nothing.

`bfd_generic_merge_sections'
............................

   *Synopsis*
     bfd_boolean bfd_generic_merge_sections
        (bfd *, struct bfd_link_info *);
   *Description*
Provides default handling for SEC_MERGE section merging for back ends
which don't have SEC_MERGE support - i.e., does nothing.

`bfd_generic_get_relocated_section_contents'
............................................

   *Synopsis*
     bfd_byte *
     bfd_generic_get_relocated_section_contents (bfd *abfd,
         struct bfd_link_info *link_info,
         struct bfd_link_order *link_order,
         bfd_byte *data,
         bfd_boolean relocateable,
         asymbol **symbols);
   *Description*
Provides default handling of relocation effort for back ends which
can't be bothered to do it efficiently.


File: bfd.info,  Node: Core Files,  Next: Targets,  Prev: Relocations,  Up: BFD front end

Core files
==========

   *Description*
These are functions pertaining to core files.

`bfd_core_file_failing_command'
...............................

   *Synopsis*
     const char *bfd_core_file_failing_command(bfd *abfd);
   *Description*
Return a read-only string explaining which program was running when it
failed and produced the core file ABFD.

`bfd_core_file_failing_signal'
..............................

   *Synopsis*
     int bfd_core_file_failing_signal(bfd *abfd);
   *Description*
Returns the signal number which caused the core dump which generated
the file the BFD ABFD is attached to.

`core_file_matches_executable_p'
................................

   *Synopsis*
     bfd_boolean core_file_matches_executable_p
        (bfd *core_bfd, bfd *exec_bfd);
   *Description*
Return `TRUE' if the core file attached to CORE_BFD was generated by a
run of the executable file attached to EXEC_BFD, `FALSE' otherwise.


File: bfd.info,  Node: Targets,  Next: Architectures,  Prev: Core Files,  Up: BFD front end

Targets
=======

   *Description*
Each port of BFD to a different machine requries the creation of a
target back end. All the back end provides to the root part of BFD is a
structure containing pointers to functions which perform certain low
level operations on files. BFD translates the applications's requests
through a pointer into calls to the back end routines.

   When a file is opened with `bfd_openr', its format and target are
unknown. BFD uses various mechanisms to determine how to interpret the
file. The operations performed are:

   * Create a BFD by calling the internal routine `_bfd_new_bfd', then
     call `bfd_find_target' with the target string supplied to
     `bfd_openr' and the new BFD pointer.

   * If a null target string was provided to `bfd_find_target', look up
     the environment variable `GNUTARGET' and use that as the target
     string.

   * If the target string is still `NULL', or the target string is
     `default', then use the first item in the target vector as the
     target type, and set `target_defaulted' in the BFD to cause
     `bfd_check_format' to loop through all the targets.  *Note
     bfd_target::.  *Note Formats::.

   * Otherwise, inspect the elements in the target vector one by one,
     until a match on target name is found. When found, use it.

   * Otherwise return the error `bfd_error_invalid_target' to
     `bfd_openr'.

   * `bfd_openr' attempts to open the file using `bfd_open_file', and
     returns the BFD.
   Once the BFD has been opened and the target selected, the file
format may be determined. This is done by calling `bfd_check_format' on
the BFD with a suggested format.  If `target_defaulted' has been set,
each possible target type is tried to see if it recognizes the
specified format.  `bfd_check_format' returns `TRUE' when the caller
guesses right.

* Menu:

* bfd_target::

@


1.1.8.1
log
@Add generated files.
@
text
@a0 1349
This is bfd.info, produced by makeinfo version 4.2 from bfd.texinfo.

START-INFO-DIR-ENTRY
* Bfd: (bfd).                   The Binary File Descriptor library.
END-INFO-DIR-ENTRY

   This file documents the BFD library.

   Copyright (C) 1991, 2000, 2001 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
   with no Invariant Sections, with no Front-Cover Texts, and with no
    Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".


File: bfd.info,  Node: howto manager,  Prev: typedef arelent,  Up: Relocations

The howto manager
=================

   When an application wants to create a relocation, but doesn't know
what the target machine might call it, it can find out by using this
bit of code.

`bfd_reloc_code_type'
.....................

   *Description*
The insides of a reloc code.  The idea is that, eventually, there will
be one enumerator for every type of relocation we ever do.  Pass one of
these values to `bfd_reloc_type_lookup', and it'll return a howto
pointer.

   This does mean that the application must determine the correct
enumerator value; you can't get a howto pointer from a random set of
attributes.

   Here are the possible values for `enum bfd_reloc_code_real':

 - : BFD_RELOC_64
 - : BFD_RELOC_32
 - : BFD_RELOC_26
 - : BFD_RELOC_24
 - : BFD_RELOC_16
 - : BFD_RELOC_14
 - : BFD_RELOC_8
     Basic absolute relocations of N bits.

 - : BFD_RELOC_64_PCREL
 - : BFD_RELOC_32_PCREL
 - : BFD_RELOC_24_PCREL
 - : BFD_RELOC_16_PCREL
 - : BFD_RELOC_12_PCREL
 - : BFD_RELOC_8_PCREL
     PC-relative relocations.  Sometimes these are relative to the
     address of the relocation itself; sometimes they are relative to
     the start of the section containing the relocation.  It depends on
     the specific target.

     The 24-bit relocation is used in some Intel 960 configurations.

 - : BFD_RELOC_32_GOT_PCREL
 - : BFD_RELOC_16_GOT_PCREL
 - : BFD_RELOC_8_GOT_PCREL
 - : BFD_RELOC_32_GOTOFF
 - : BFD_RELOC_16_GOTOFF
 - : BFD_RELOC_LO16_GOTOFF
 - : BFD_RELOC_HI16_GOTOFF
 - : BFD_RELOC_HI16_S_GOTOFF
 - : BFD_RELOC_8_GOTOFF
 - : BFD_RELOC_64_PLT_PCREL
 - : BFD_RELOC_32_PLT_PCREL
 - : BFD_RELOC_24_PLT_PCREL
 - : BFD_RELOC_16_PLT_PCREL
 - : BFD_RELOC_8_PLT_PCREL
 - : BFD_RELOC_64_PLTOFF
 - : BFD_RELOC_32_PLTOFF
 - : BFD_RELOC_16_PLTOFF
 - : BFD_RELOC_LO16_PLTOFF
 - : BFD_RELOC_HI16_PLTOFF
 - : BFD_RELOC_HI16_S_PLTOFF
 - : BFD_RELOC_8_PLTOFF
     For ELF.

 - : BFD_RELOC_68K_GLOB_DAT
 - : BFD_RELOC_68K_JMP_SLOT
 - : BFD_RELOC_68K_RELATIVE
     Relocations used by 68K ELF.

 - : BFD_RELOC_32_BASEREL
 - : BFD_RELOC_16_BASEREL
 - : BFD_RELOC_LO16_BASEREL
 - : BFD_RELOC_HI16_BASEREL
 - : BFD_RELOC_HI16_S_BASEREL
 - : BFD_RELOC_8_BASEREL
 - : BFD_RELOC_RVA
     Linkage-table relative.

 - : BFD_RELOC_8_FFnn
     Absolute 8-bit relocation, but used to form an address like 0xFFnn.

 - : BFD_RELOC_32_PCREL_S2
 - : BFD_RELOC_16_PCREL_S2
 - : BFD_RELOC_23_PCREL_S2
     These PC-relative relocations are stored as word displacements -
     i.e., byte displacements shifted right two bits.  The 30-bit word
     displacement (<<32_PCREL_S2>> - 32 bits, shifted 2) is used on the
     SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
     signed 16-bit displacement is used on the MIPS, and the 23-bit
     displacement is used on the Alpha.

 - : BFD_RELOC_HI22
 - : BFD_RELOC_LO10
     High 22 bits and low 10 bits of 32-bit value, placed into lower
     bits of the target word.  These are used on the SPARC.

 - : BFD_RELOC_GPREL16
 - : BFD_RELOC_GPREL32
     For systems that allocate a Global Pointer register, these are
     displacements off that register.  These relocation types are
     handled specially, because the value the register will have is
     decided relatively late.

 - : BFD_RELOC_I960_CALLJ
     Reloc types used for i960/b.out.

 - : BFD_RELOC_NONE
 - : BFD_RELOC_SPARC_WDISP22
 - : BFD_RELOC_SPARC22
 - : BFD_RELOC_SPARC13
 - : BFD_RELOC_SPARC_GOT10
 - : BFD_RELOC_SPARC_GOT13
 - : BFD_RELOC_SPARC_GOT22
 - : BFD_RELOC_SPARC_PC10
 - : BFD_RELOC_SPARC_PC22
 - : BFD_RELOC_SPARC_WPLT30
 - : BFD_RELOC_SPARC_COPY
 - : BFD_RELOC_SPARC_GLOB_DAT
 - : BFD_RELOC_SPARC_JMP_SLOT
 - : BFD_RELOC_SPARC_RELATIVE
 - : BFD_RELOC_SPARC_UA16
 - : BFD_RELOC_SPARC_UA32
 - : BFD_RELOC_SPARC_UA64
     SPARC ELF relocations.  There is probably some overlap with other
     relocation types already defined.

 - : BFD_RELOC_SPARC_BASE13
 - : BFD_RELOC_SPARC_BASE22
     I think these are specific to SPARC a.out (e.g., Sun 4).

 - : BFD_RELOC_SPARC_64
 - : BFD_RELOC_SPARC_10
 - : BFD_RELOC_SPARC_11
 - : BFD_RELOC_SPARC_OLO10
 - : BFD_RELOC_SPARC_HH22
 - : BFD_RELOC_SPARC_HM10
 - : BFD_RELOC_SPARC_LM22
 - : BFD_RELOC_SPARC_PC_HH22
 - : BFD_RELOC_SPARC_PC_HM10
 - : BFD_RELOC_SPARC_PC_LM22
 - : BFD_RELOC_SPARC_WDISP16
 - : BFD_RELOC_SPARC_WDISP19
 - : BFD_RELOC_SPARC_7
 - : BFD_RELOC_SPARC_6
 - : BFD_RELOC_SPARC_5
 - : BFD_RELOC_SPARC_DISP64
 - : BFD_RELOC_SPARC_PLT32
 - : BFD_RELOC_SPARC_PLT64
 - : BFD_RELOC_SPARC_HIX22
 - : BFD_RELOC_SPARC_LOX10
 - : BFD_RELOC_SPARC_H44
 - : BFD_RELOC_SPARC_M44
 - : BFD_RELOC_SPARC_L44
 - : BFD_RELOC_SPARC_REGISTER
     SPARC64 relocations

 - : BFD_RELOC_SPARC_REV32
     SPARC little endian relocation

 - : BFD_RELOC_ALPHA_GPDISP_HI16
     Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
     "addend" in some special way.  For GPDISP_HI16 ("gpdisp")
     relocations, the symbol is ignored when writing; when reading, it
     will be the absolute section symbol.  The addend is the
     displacement in bytes of the "lda" instruction from the "ldah"
     instruction (which is at the address of this reloc).

 - : BFD_RELOC_ALPHA_GPDISP_LO16
     For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
     with GPDISP_HI16 relocs.  The addend is ignored when writing the
     relocations out, and is filled in with the file's GP value on
     reading, for convenience.

 - : BFD_RELOC_ALPHA_GPDISP
     The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
     relocation except that there is no accompanying GPDISP_LO16
     relocation.

 - : BFD_RELOC_ALPHA_LITERAL
 - : BFD_RELOC_ALPHA_ELF_LITERAL
 - : BFD_RELOC_ALPHA_LITUSE
     The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
     the assembler turns it into a LDQ instruction to load the address
     of the symbol, and then fills in a register in the real
     instruction.

     The LITERAL reloc, at the LDQ instruction, refers to the .lita
     section symbol.  The addend is ignored when writing, but is filled
     in with the file's GP value on reading, for convenience, as with
     the GPDISP_LO16 reloc.

     The ELF_LITERAL reloc is somewhere between 16_GOTOFF and
     GPDISP_LO16.  It should refer to the symbol to be referenced, as
     with 16_GOTOFF, but it generates output not based on the position
     within the .got section, but relative to the GP value chosen for
     the file during the final link stage.

     The LITUSE reloc, on the instruction using the loaded address,
     gives information to the linker that it might be able to use to
     optimize away some literal section references.  The symbol is
     ignored (read as the absolute section symbol), and the "addend"
     indicates the type of instruction using the register: 1 - "memory"
     fmt insn 2 - byte-manipulation (byte offset reg) 3 - jsr (target
     of branch)

 - : BFD_RELOC_ALPHA_HINT
     The HINT relocation indicates a value that should be filled into
     the "hint" field of a jmp/jsr/ret instruction, for possible branch-
     prediction logic which may be provided on some processors.

 - : BFD_RELOC_ALPHA_LINKAGE
     The LINKAGE relocation outputs a linkage pair in the object file,
     which is filled by the linker.

 - : BFD_RELOC_ALPHA_CODEADDR
     The CODEADDR relocation outputs a STO_CA in the object file, which
     is filled by the linker.

 - : BFD_RELOC_ALPHA_GPREL_HI16
 - : BFD_RELOC_ALPHA_GPREL_LO16
     The GPREL_HI/LO relocations together form a 32-bit offset from the
     GP register.

 - : BFD_RELOC_ALPHA_BRSGP
     Like BFD_RELOC_23_PCREL_S2, except that the source and target must
     share a common GP, and the target address is adjusted for
     STO_ALPHA_STD_GPLOAD.

 - : BFD_RELOC_ALPHA_TLSGD
 - : BFD_RELOC_ALPHA_TLSLDM
 - : BFD_RELOC_ALPHA_DTPMOD64
 - : BFD_RELOC_ALPHA_GOTDTPREL16
 - : BFD_RELOC_ALPHA_DTPREL64
 - : BFD_RELOC_ALPHA_DTPREL_HI16
 - : BFD_RELOC_ALPHA_DTPREL_LO16
 - : BFD_RELOC_ALPHA_DTPREL16
 - : BFD_RELOC_ALPHA_GOTTPREL16
 - : BFD_RELOC_ALPHA_TPREL64
 - : BFD_RELOC_ALPHA_TPREL_HI16
 - : BFD_RELOC_ALPHA_TPREL_LO16
 - : BFD_RELOC_ALPHA_TPREL16
     Alpha thread-local storage relocations.

 - : BFD_RELOC_MIPS_JMP
     Bits 27..2 of the relocation address shifted right 2 bits; simple
     reloc otherwise.

 - : BFD_RELOC_MIPS16_JMP
     The MIPS16 jump instruction.

 - : BFD_RELOC_MIPS16_GPREL
     MIPS16 GP relative reloc.

 - : BFD_RELOC_HI16
     High 16 bits of 32-bit value; simple reloc.

 - : BFD_RELOC_HI16_S
     High 16 bits of 32-bit value but the low 16 bits will be sign
     extended and added to form the final result.  If the low 16 bits
     form a negative number, we need to add one to the high value to
     compensate for the borrow when the low bits are added.

 - : BFD_RELOC_LO16
     Low 16 bits.

 - : BFD_RELOC_PCREL_HI16_S
     Like BFD_RELOC_HI16_S, but PC relative.

 - : BFD_RELOC_PCREL_LO16
     Like BFD_RELOC_LO16, but PC relative.

 - : BFD_RELOC_MIPS_LITERAL
     Relocation against a MIPS literal section.

 - : BFD_RELOC_MIPS_GOT16
 - : BFD_RELOC_MIPS_CALL16
 - : BFD_RELOC_MIPS_GOT_HI16
 - : BFD_RELOC_MIPS_GOT_LO16
 - : BFD_RELOC_MIPS_CALL_HI16
 - : BFD_RELOC_MIPS_CALL_LO16
 - : BFD_RELOC_MIPS_SUB
 - : BFD_RELOC_MIPS_GOT_PAGE
 - : BFD_RELOC_MIPS_GOT_OFST
 - : BFD_RELOC_MIPS_GOT_DISP
 - : BFD_RELOC_MIPS_SHIFT5
 - : BFD_RELOC_MIPS_SHIFT6
 - : BFD_RELOC_MIPS_INSERT_A
 - : BFD_RELOC_MIPS_INSERT_B
 - : BFD_RELOC_MIPS_DELETE
 - : BFD_RELOC_MIPS_HIGHEST
 - : BFD_RELOC_MIPS_HIGHER
 - : BFD_RELOC_MIPS_SCN_DISP
 - : BFD_RELOC_MIPS_REL16
 - : BFD_RELOC_MIPS_RELGOT
 - : BFD_RELOC_MIPS_JALR
      - : BFD_RELOC_FRV_LABEL16
      - : BFD_RELOC_FRV_LABEL24
      - : BFD_RELOC_FRV_LO16
      - : BFD_RELOC_FRV_HI16
      - : BFD_RELOC_FRV_GPREL12
      - : BFD_RELOC_FRV_GPRELU12
      - : BFD_RELOC_FRV_GPREL32
      - : BFD_RELOC_FRV_GPRELHI
      - : BFD_RELOC_FRV_GPRELLO
          Fujitsu Frv Relocations.
     MIPS ELF relocations.

 - : BFD_RELOC_386_GOT32
 - : BFD_RELOC_386_PLT32
 - : BFD_RELOC_386_COPY
 - : BFD_RELOC_386_GLOB_DAT
 - : BFD_RELOC_386_JUMP_SLOT
 - : BFD_RELOC_386_RELATIVE
 - : BFD_RELOC_386_GOTOFF
 - : BFD_RELOC_386_GOTPC
 - : BFD_RELOC_386_TLS_LE
 - : BFD_RELOC_386_TLS_GD
 - : BFD_RELOC_386_TLS_LDM
 - : BFD_RELOC_386_TLS_LDO_32
 - : BFD_RELOC_386_TLS_IE_32
 - : BFD_RELOC_386_TLS_LE_32
 - : BFD_RELOC_386_TLS_DTPMOD32
 - : BFD_RELOC_386_TLS_DTPOFF32
 - : BFD_RELOC_386_TLS_TPOFF32
     i386/elf relocations

 - : BFD_RELOC_X86_64_GOT32
 - : BFD_RELOC_X86_64_PLT32
 - : BFD_RELOC_X86_64_COPY
 - : BFD_RELOC_X86_64_GLOB_DAT
 - : BFD_RELOC_X86_64_JUMP_SLOT
 - : BFD_RELOC_X86_64_RELATIVE
 - : BFD_RELOC_X86_64_GOTPCREL
 - : BFD_RELOC_X86_64_32S
     x86-64/elf relocations

 - : BFD_RELOC_NS32K_IMM_8
 - : BFD_RELOC_NS32K_IMM_16
 - : BFD_RELOC_NS32K_IMM_32
 - : BFD_RELOC_NS32K_IMM_8_PCREL
 - : BFD_RELOC_NS32K_IMM_16_PCREL
 - : BFD_RELOC_NS32K_IMM_32_PCREL
 - : BFD_RELOC_NS32K_DISP_8
 - : BFD_RELOC_NS32K_DISP_16
 - : BFD_RELOC_NS32K_DISP_32
 - : BFD_RELOC_NS32K_DISP_8_PCREL
 - : BFD_RELOC_NS32K_DISP_16_PCREL
 - : BFD_RELOC_NS32K_DISP_32_PCREL
     ns32k relocations

 - : BFD_RELOC_PDP11_DISP_8_PCREL
 - : BFD_RELOC_PDP11_DISP_6_PCREL
     PDP11 relocations

 - : BFD_RELOC_PJ_CODE_HI16
 - : BFD_RELOC_PJ_CODE_LO16
 - : BFD_RELOC_PJ_CODE_DIR16
 - : BFD_RELOC_PJ_CODE_DIR32
 - : BFD_RELOC_PJ_CODE_REL16
 - : BFD_RELOC_PJ_CODE_REL32
     Picojava relocs.  Not all of these appear in object files.

 - : BFD_RELOC_PPC_B26
 - : BFD_RELOC_PPC_BA26
 - : BFD_RELOC_PPC_TOC16
 - : BFD_RELOC_PPC_B16
 - : BFD_RELOC_PPC_B16_BRTAKEN
 - : BFD_RELOC_PPC_B16_BRNTAKEN
 - : BFD_RELOC_PPC_BA16
 - : BFD_RELOC_PPC_BA16_BRTAKEN
 - : BFD_RELOC_PPC_BA16_BRNTAKEN
 - : BFD_RELOC_PPC_COPY
 - : BFD_RELOC_PPC_GLOB_DAT
 - : BFD_RELOC_PPC_JMP_SLOT
 - : BFD_RELOC_PPC_RELATIVE
 - : BFD_RELOC_PPC_LOCAL24PC
 - : BFD_RELOC_PPC_EMB_NADDR32
 - : BFD_RELOC_PPC_EMB_NADDR16
 - : BFD_RELOC_PPC_EMB_NADDR16_LO
 - : BFD_RELOC_PPC_EMB_NADDR16_HI
 - : BFD_RELOC_PPC_EMB_NADDR16_HA
 - : BFD_RELOC_PPC_EMB_SDAI16
 - : BFD_RELOC_PPC_EMB_SDA2I16
 - : BFD_RELOC_PPC_EMB_SDA2REL
 - : BFD_RELOC_PPC_EMB_SDA21
 - : BFD_RELOC_PPC_EMB_MRKREF
 - : BFD_RELOC_PPC_EMB_RELSEC16
 - : BFD_RELOC_PPC_EMB_RELST_LO
 - : BFD_RELOC_PPC_EMB_RELST_HI
 - : BFD_RELOC_PPC_EMB_RELST_HA
 - : BFD_RELOC_PPC_EMB_BIT_FLD
 - : BFD_RELOC_PPC_EMB_RELSDA
 - : BFD_RELOC_PPC64_HIGHER
 - : BFD_RELOC_PPC64_HIGHER_S
 - : BFD_RELOC_PPC64_HIGHEST
 - : BFD_RELOC_PPC64_HIGHEST_S
 - : BFD_RELOC_PPC64_TOC16_LO
 - : BFD_RELOC_PPC64_TOC16_HI
 - : BFD_RELOC_PPC64_TOC16_HA
 - : BFD_RELOC_PPC64_TOC
 - : BFD_RELOC_PPC64_PLTGOT16
 - : BFD_RELOC_PPC64_PLTGOT16_LO
 - : BFD_RELOC_PPC64_PLTGOT16_HI
 - : BFD_RELOC_PPC64_PLTGOT16_HA
 - : BFD_RELOC_PPC64_ADDR16_DS
 - : BFD_RELOC_PPC64_ADDR16_LO_DS
 - : BFD_RELOC_PPC64_GOT16_DS
 - : BFD_RELOC_PPC64_GOT16_LO_DS
 - : BFD_RELOC_PPC64_PLT16_LO_DS
 - : BFD_RELOC_PPC64_SECTOFF_DS
 - : BFD_RELOC_PPC64_SECTOFF_LO_DS
 - : BFD_RELOC_PPC64_TOC16_DS
 - : BFD_RELOC_PPC64_TOC16_LO_DS
 - : BFD_RELOC_PPC64_PLTGOT16_DS
 - : BFD_RELOC_PPC64_PLTGOT16_LO_DS
     Power(rs6000) and PowerPC relocations.

 - : BFD_RELOC_I370_D12
     IBM 370/390 relocations

 - : BFD_RELOC_CTOR
     The type of reloc used to build a contructor table - at the moment
     probably a 32 bit wide absolute relocation, but the target can
     choose.  It generally does map to one of the other relocation
     types.

 - : BFD_RELOC_ARM_PCREL_BRANCH
     ARM 26 bit pc-relative branch.  The lowest two bits must be zero
     and are not stored in the instruction.

 - : BFD_RELOC_ARM_PCREL_BLX
     ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
     not stored in the instruction.  The 2nd lowest bit comes from a 1
     bit field in the instruction.

 - : BFD_RELOC_THUMB_PCREL_BLX
     Thumb 22 bit pc-relative branch.  The lowest bit must be zero and
     is not stored in the instruction.  The 2nd lowest bit comes from a
     1 bit field in the instruction.

 - : BFD_RELOC_ARM_IMMEDIATE
 - : BFD_RELOC_ARM_ADRL_IMMEDIATE
 - : BFD_RELOC_ARM_OFFSET_IMM
 - : BFD_RELOC_ARM_SHIFT_IMM
 - : BFD_RELOC_ARM_SWI
 - : BFD_RELOC_ARM_MULTI
 - : BFD_RELOC_ARM_CP_OFF_IMM
 - : BFD_RELOC_ARM_ADR_IMM
 - : BFD_RELOC_ARM_LDR_IMM
 - : BFD_RELOC_ARM_LITERAL
 - : BFD_RELOC_ARM_IN_POOL
 - : BFD_RELOC_ARM_OFFSET_IMM8
 - : BFD_RELOC_ARM_HWLITERAL
 - : BFD_RELOC_ARM_THUMB_ADD
 - : BFD_RELOC_ARM_THUMB_IMM
 - : BFD_RELOC_ARM_THUMB_SHIFT
 - : BFD_RELOC_ARM_THUMB_OFFSET
 - : BFD_RELOC_ARM_GOT12
 - : BFD_RELOC_ARM_GOT32
 - : BFD_RELOC_ARM_JUMP_SLOT
 - : BFD_RELOC_ARM_COPY
 - : BFD_RELOC_ARM_GLOB_DAT
 - : BFD_RELOC_ARM_PLT32
 - : BFD_RELOC_ARM_RELATIVE
 - : BFD_RELOC_ARM_GOTOFF
 - : BFD_RELOC_ARM_GOTPC
     These relocs are only used within the ARM assembler.  They are not
     (at present) written to any object files.

 - : BFD_RELOC_SH_PCDISP8BY2
 - : BFD_RELOC_SH_PCDISP12BY2
 - : BFD_RELOC_SH_IMM4
 - : BFD_RELOC_SH_IMM4BY2
 - : BFD_RELOC_SH_IMM4BY4
 - : BFD_RELOC_SH_IMM8
 - : BFD_RELOC_SH_IMM8BY2
 - : BFD_RELOC_SH_IMM8BY4
 - : BFD_RELOC_SH_PCRELIMM8BY2
 - : BFD_RELOC_SH_PCRELIMM8BY4
 - : BFD_RELOC_SH_SWITCH16
 - : BFD_RELOC_SH_SWITCH32
 - : BFD_RELOC_SH_USES
 - : BFD_RELOC_SH_COUNT
 - : BFD_RELOC_SH_ALIGN
 - : BFD_RELOC_SH_CODE
 - : BFD_RELOC_SH_DATA
 - : BFD_RELOC_SH_LABEL
 - : BFD_RELOC_SH_LOOP_START
 - : BFD_RELOC_SH_LOOP_END
 - : BFD_RELOC_SH_COPY
 - : BFD_RELOC_SH_GLOB_DAT
 - : BFD_RELOC_SH_JMP_SLOT
 - : BFD_RELOC_SH_RELATIVE
 - : BFD_RELOC_SH_GOTPC
 - : BFD_RELOC_SH_GOT_LOW16
 - : BFD_RELOC_SH_GOT_MEDLOW16
 - : BFD_RELOC_SH_GOT_MEDHI16
 - : BFD_RELOC_SH_GOT_HI16
 - : BFD_RELOC_SH_GOTPLT_LOW16
 - : BFD_RELOC_SH_GOTPLT_MEDLOW16
 - : BFD_RELOC_SH_GOTPLT_MEDHI16
 - : BFD_RELOC_SH_GOTPLT_HI16
 - : BFD_RELOC_SH_PLT_LOW16
 - : BFD_RELOC_SH_PLT_MEDLOW16
 - : BFD_RELOC_SH_PLT_MEDHI16
 - : BFD_RELOC_SH_PLT_HI16
 - : BFD_RELOC_SH_GOTOFF_LOW16
 - : BFD_RELOC_SH_GOTOFF_MEDLOW16
 - : BFD_RELOC_SH_GOTOFF_MEDHI16
 - : BFD_RELOC_SH_GOTOFF_HI16
 - : BFD_RELOC_SH_GOTPC_LOW16
 - : BFD_RELOC_SH_GOTPC_MEDLOW16
 - : BFD_RELOC_SH_GOTPC_MEDHI16
 - : BFD_RELOC_SH_GOTPC_HI16
 - : BFD_RELOC_SH_COPY64
 - : BFD_RELOC_SH_GLOB_DAT64
 - : BFD_RELOC_SH_JMP_SLOT64
 - : BFD_RELOC_SH_RELATIVE64
 - : BFD_RELOC_SH_GOT10BY4
 - : BFD_RELOC_SH_GOT10BY8
 - : BFD_RELOC_SH_GOTPLT10BY4
 - : BFD_RELOC_SH_GOTPLT10BY8
 - : BFD_RELOC_SH_GOTPLT32
 - : BFD_RELOC_SH_SHMEDIA_CODE
 - : BFD_RELOC_SH_IMMU5
 - : BFD_RELOC_SH_IMMS6
 - : BFD_RELOC_SH_IMMS6BY32
 - : BFD_RELOC_SH_IMMU6
 - : BFD_RELOC_SH_IMMS10
 - : BFD_RELOC_SH_IMMS10BY2
 - : BFD_RELOC_SH_IMMS10BY4
 - : BFD_RELOC_SH_IMMS10BY8
 - : BFD_RELOC_SH_IMMS16
 - : BFD_RELOC_SH_IMMU16
 - : BFD_RELOC_SH_IMM_LOW16
 - : BFD_RELOC_SH_IMM_LOW16_PCREL
 - : BFD_RELOC_SH_IMM_MEDLOW16
 - : BFD_RELOC_SH_IMM_MEDLOW16_PCREL
 - : BFD_RELOC_SH_IMM_MEDHI16
 - : BFD_RELOC_SH_IMM_MEDHI16_PCREL
 - : BFD_RELOC_SH_IMM_HI16
 - : BFD_RELOC_SH_IMM_HI16_PCREL
 - : BFD_RELOC_SH_PT_16
     Hitachi SH relocs.  Not all of these appear in object files.

 - : BFD_RELOC_THUMB_PCREL_BRANCH9
 - : BFD_RELOC_THUMB_PCREL_BRANCH12
 - : BFD_RELOC_THUMB_PCREL_BRANCH23
     Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
     be zero and is not stored in the instruction.

 - : BFD_RELOC_ARC_B22_PCREL
     ARC Cores relocs.  ARC 22 bit pc-relative branch.  The lowest two
     bits must be zero and are not stored in the instruction.  The high
     20 bits are installed in bits 26 through 7 of the instruction.

 - : BFD_RELOC_ARC_B26
     ARC 26 bit absolute branch.  The lowest two bits must be zero and
     are not stored in the instruction.  The high 24 bits are installed
     in bits 23 through 0.

 - : BFD_RELOC_D10V_10_PCREL_R
     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
     bits assumed to be 0.

 - : BFD_RELOC_D10V_10_PCREL_L
     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
     bits assumed to be 0.  This is the same as the previous reloc
     except it is in the left container, i.e., shifted left 15 bits.

 - : BFD_RELOC_D10V_18
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_D10V_18_PCREL
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_D30V_6
     Mitsubishi D30V relocs.  This is a 6-bit absolute reloc.

 - : BFD_RELOC_D30V_9_PCREL
     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
     be 0.

 - : BFD_RELOC_D30V_9_PCREL_R
     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
     be 0. Same as the previous reloc but on the right side of the
     container.

 - : BFD_RELOC_D30V_15
     This is a 12-bit absolute reloc with the right 3 bitsassumed to be
     0.

 - : BFD_RELOC_D30V_15_PCREL
     This is a 12-bit pc-relative reloc with the right 3 bits assumed
     to be 0.

 - : BFD_RELOC_D30V_15_PCREL_R
     This is a 12-bit pc-relative reloc with the right 3 bits assumed
     to be 0. Same as the previous reloc but on the right side of the
     container.

 - : BFD_RELOC_D30V_21
     This is an 18-bit absolute reloc with the right 3 bits assumed to
     be 0.

 - : BFD_RELOC_D30V_21_PCREL
     This is an 18-bit pc-relative reloc with the right 3 bits assumed
     to be 0.

 - : BFD_RELOC_D30V_21_PCREL_R
     This is an 18-bit pc-relative reloc with the right 3 bits assumed
     to be 0. Same as the previous reloc but on the right side of the
     container.

 - : BFD_RELOC_D30V_32
     This is a 32-bit absolute reloc.

 - : BFD_RELOC_D30V_32_PCREL
     This is a 32-bit pc-relative reloc.

 - : BFD_RELOC_DLX_HI16_S
     DLX relocs

 - : BFD_RELOC_DLX_LO16
     DLX relocs

 - : BFD_RELOC_DLX_JMP26
     DLX relocs

 - : BFD_RELOC_M32R_24
     Mitsubishi M32R relocs.  This is a 24 bit absolute address.

 - : BFD_RELOC_M32R_10_PCREL
     This is a 10-bit pc-relative reloc with the right 2 bits assumed
     to be 0.

 - : BFD_RELOC_M32R_18_PCREL
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_M32R_26_PCREL
     This is a 26-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_M32R_HI16_ULO
     This is a 16-bit reloc containing the high 16 bits of an address
     used when the lower 16 bits are treated as unsigned.

 - : BFD_RELOC_M32R_HI16_SLO
     This is a 16-bit reloc containing the high 16 bits of an address
     used when the lower 16 bits are treated as signed.

 - : BFD_RELOC_M32R_LO16
     This is a 16-bit reloc containing the lower 16 bits of an address.

 - : BFD_RELOC_M32R_SDA16
     This is a 16-bit reloc containing the small data area offset for
     use in add3, load, and store instructions.

 - : BFD_RELOC_V850_9_PCREL
     This is a 9-bit reloc

 - : BFD_RELOC_V850_22_PCREL
     This is a 22-bit reloc

 - : BFD_RELOC_V850_SDA_16_16_OFFSET
     This is a 16 bit offset from the short data area pointer.

 - : BFD_RELOC_V850_SDA_15_16_OFFSET
     This is a 16 bit offset (of which only 15 bits are used) from the
     short data area pointer.

 - : BFD_RELOC_V850_ZDA_16_16_OFFSET
     This is a 16 bit offset from the zero data area pointer.

 - : BFD_RELOC_V850_ZDA_15_16_OFFSET
     This is a 16 bit offset (of which only 15 bits are used) from the
     zero data area pointer.

 - : BFD_RELOC_V850_TDA_6_8_OFFSET
     This is an 8 bit offset (of which only 6 bits are used) from the
     tiny data area pointer.

 - : BFD_RELOC_V850_TDA_7_8_OFFSET
     This is an 8bit offset (of which only 7 bits are used) from the
     tiny data area pointer.

 - : BFD_RELOC_V850_TDA_7_7_OFFSET
     This is a 7 bit offset from the tiny data area pointer.

 - : BFD_RELOC_V850_TDA_16_16_OFFSET
     This is a 16 bit offset from the tiny data area pointer.

 - : BFD_RELOC_V850_TDA_4_5_OFFSET
     This is a 5 bit offset (of which only 4 bits are used) from the
     tiny data area pointer.

 - : BFD_RELOC_V850_TDA_4_4_OFFSET
     This is a 4 bit offset from the tiny data area pointer.

 - : BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET
     This is a 16 bit offset from the short data area pointer, with the
     bits placed non-contigously in the instruction.

 - : BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET
     This is a 16 bit offset from the zero data area pointer, with the
     bits placed non-contigously in the instruction.

 - : BFD_RELOC_V850_CALLT_6_7_OFFSET
     This is a 6 bit offset from the call table base pointer.

 - : BFD_RELOC_V850_CALLT_16_16_OFFSET
     This is a 16 bit offset from the call table base pointer.

 - : BFD_RELOC_MN10300_32_PCREL
     This is a 32bit pcrel reloc for the mn10300, offset by two bytes
     in the instruction.

 - : BFD_RELOC_MN10300_16_PCREL
     This is a 16bit pcrel reloc for the mn10300, offset by two bytes
     in the instruction.

 - : BFD_RELOC_TIC30_LDP
     This is a 8bit DP reloc for the tms320c30, where the most
     significant 8 bits of a 24 bit word are placed into the least
     significant 8 bits of the opcode.

 - : BFD_RELOC_TIC54X_PARTLS7
     This is a 7bit reloc for the tms320c54x, where the least
     significant 7 bits of a 16 bit word are placed into the least
     significant 7 bits of the opcode.

 - : BFD_RELOC_TIC54X_PARTMS9
     This is a 9bit DP reloc for the tms320c54x, where the most
     significant 9 bits of a 16 bit word are placed into the least
     significant 9 bits of the opcode.

 - : BFD_RELOC_TIC54X_23
     This is an extended address 23-bit reloc for the tms320c54x.

 - : BFD_RELOC_TIC54X_16_OF_23
     This is a 16-bit reloc for the tms320c54x, where the least
     significant 16 bits of a 23-bit extended address are placed into
     the opcode.

 - : BFD_RELOC_TIC54X_MS7_OF_23
     This is a reloc for the tms320c54x, where the most significant 7
     bits of a 23-bit extended address are placed into the opcode.

 - : BFD_RELOC_FR30_48
     This is a 48 bit reloc for the FR30 that stores 32 bits.

 - : BFD_RELOC_FR30_20
     This is a 32 bit reloc for the FR30 that stores 20 bits split up
     into two sections.

 - : BFD_RELOC_FR30_6_IN_4
     This is a 16 bit reloc for the FR30 that stores a 6 bit word
     offset in 4 bits.

 - : BFD_RELOC_FR30_8_IN_8
     This is a 16 bit reloc for the FR30 that stores an 8 bit byte
     offset into 8 bits.

 - : BFD_RELOC_FR30_9_IN_8
     This is a 16 bit reloc for the FR30 that stores a 9 bit short
     offset into 8 bits.

 - : BFD_RELOC_FR30_10_IN_8
     This is a 16 bit reloc for the FR30 that stores a 10 bit word
     offset into 8 bits.

 - : BFD_RELOC_FR30_9_PCREL
     This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
     short offset into 8 bits.

 - : BFD_RELOC_FR30_12_PCREL
     This is a 16 bit reloc for the FR30 that stores a 12 bit pc
     relative short offset into 11 bits.

 - : BFD_RELOC_MCORE_PCREL_IMM8BY4
 - : BFD_RELOC_MCORE_PCREL_IMM11BY2
 - : BFD_RELOC_MCORE_PCREL_IMM4BY2
 - : BFD_RELOC_MCORE_PCREL_32
 - : BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
 - : BFD_RELOC_MCORE_RVA
     Motorola Mcore relocations.

 - : BFD_RELOC_MMIX_GETA
 - : BFD_RELOC_MMIX_GETA_1
 - : BFD_RELOC_MMIX_GETA_2
 - : BFD_RELOC_MMIX_GETA_3
     These are relocations for the GETA instruction.

 - : BFD_RELOC_MMIX_CBRANCH
 - : BFD_RELOC_MMIX_CBRANCH_J
 - : BFD_RELOC_MMIX_CBRANCH_1
 - : BFD_RELOC_MMIX_CBRANCH_2
 - : BFD_RELOC_MMIX_CBRANCH_3
     These are relocations for a conditional branch instruction.

 - : BFD_RELOC_MMIX_PUSHJ
 - : BFD_RELOC_MMIX_PUSHJ_1
 - : BFD_RELOC_MMIX_PUSHJ_2
 - : BFD_RELOC_MMIX_PUSHJ_3
     These are relocations for the PUSHJ instruction.

 - : BFD_RELOC_MMIX_JMP
 - : BFD_RELOC_MMIX_JMP_1
 - : BFD_RELOC_MMIX_JMP_2
 - : BFD_RELOC_MMIX_JMP_3
     These are relocations for the JMP instruction.

 - : BFD_RELOC_MMIX_ADDR19
     This is a relocation for a relative address as in a GETA
     instruction or a branch.

 - : BFD_RELOC_MMIX_ADDR27
     This is a relocation for a relative address as in a JMP
     instruction.

 - : BFD_RELOC_MMIX_REG_OR_BYTE
     This is a relocation for an instruction field that may be a general
     register or a value 0..255.

 - : BFD_RELOC_MMIX_REG
     This is a relocation for an instruction field that may be a general
     register.

 - : BFD_RELOC_MMIX_BASE_PLUS_OFFSET
     This is a relocation for two instruction fields holding a register
     and an offset, the equivalent of the relocation.

 - : BFD_RELOC_MMIX_LOCAL
     This relocation is an assertion that the expression is not
     allocated as a global register.  It does not modify contents.

 - : BFD_RELOC_AVR_7_PCREL
     This is a 16 bit reloc for the AVR that stores 8 bit pc relative
     short offset into 7 bits.

 - : BFD_RELOC_AVR_13_PCREL
     This is a 16 bit reloc for the AVR that stores 13 bit pc relative
     short offset into 12 bits.

 - : BFD_RELOC_AVR_16_PM
     This is a 16 bit reloc for the AVR that stores 17 bit value
     (usually program memory address) into 16 bits.

 - : BFD_RELOC_AVR_LO8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
     data memory address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HI8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
     bit of data memory address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HH8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (most
     high 8 bit of program memory address) into 8 bit immediate value
     of LDI insn.

 - : BFD_RELOC_AVR_LO8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (usually data memory address) into 8 bit immediate value of SUBI
     insn.

 - : BFD_RELOC_AVR_HI8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 8 bit of data memory address) into 8 bit immediate value of
     SUBI insn.

 - : BFD_RELOC_AVR_HH8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (most high 8 bit of program memory address) into 8 bit immediate
     value of LDI or SUBI insn.

 - : BFD_RELOC_AVR_LO8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
     command address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HI8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
     bit of command address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HH8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (most
     high 8 bit of command address) into 8 bit immediate value of LDI
     insn.

 - : BFD_RELOC_AVR_LO8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (usually command address) into 8 bit immediate value of SUBI insn.

 - : BFD_RELOC_AVR_HI8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 8 bit of 16 bit command address) into 8 bit immediate value
     of SUBI insn.

 - : BFD_RELOC_AVR_HH8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 6 bit of 22 bit command address) into 8 bit immediate value
     of SUBI insn.

 - : BFD_RELOC_AVR_CALL
     This is a 32 bit reloc for the AVR that stores 23 bit value into
     22 bits.

 - : BFD_RELOC_390_12
     Direct 12 bit.

 - : BFD_RELOC_390_GOT12
     12 bit GOT offset.

 - : BFD_RELOC_390_PLT32
     32 bit PC relative PLT address.

 - : BFD_RELOC_390_COPY
     Copy symbol at runtime.

 - : BFD_RELOC_390_GLOB_DAT
     Create GOT entry.

 - : BFD_RELOC_390_JMP_SLOT
     Create PLT entry.

 - : BFD_RELOC_390_RELATIVE
     Adjust by program base.

 - : BFD_RELOC_390_GOTPC
     32 bit PC relative offset to GOT.

 - : BFD_RELOC_390_GOT16
     16 bit GOT offset.

 - : BFD_RELOC_390_PC16DBL
     PC relative 16 bit shifted by 1.

 - : BFD_RELOC_390_PLT16DBL
     16 bit PC rel. PLT shifted by 1.

 - : BFD_RELOC_390_PC32DBL
     PC relative 32 bit shifted by 1.

 - : BFD_RELOC_390_PLT32DBL
     32 bit PC rel. PLT shifted by 1.

 - : BFD_RELOC_390_GOTPCDBL
     32 bit PC rel. GOT shifted by 1.

 - : BFD_RELOC_390_GOT64
     64 bit GOT offset.

 - : BFD_RELOC_390_PLT64
     64 bit PC relative PLT address.

 - : BFD_RELOC_390_GOTENT
     32 bit rel. offset to GOT entry.

 - : BFD_RELOC_VTABLE_INHERIT
 - : BFD_RELOC_VTABLE_ENTRY
     These two relocations are used by the linker to determine which of
     the entries in a C++ virtual function table are actually used.
     When the -gc-sections option is given, the linker will zero out
     the entries that are not used, so that the code for those
     functions need not be included in the output.

     VTABLE_INHERIT is a zero-space relocation used to describe to the
     linker the inheritence tree of a C++ virtual function table.  The
     relocation's symbol should be the parent class' vtable, and the
     relocation should be located at the child vtable.

     VTABLE_ENTRY is a zero-space relocation that describes the use of a
     virtual function table entry.  The reloc's symbol should refer to
     the table of the class mentioned in the code.  Off of that base,
     an offset describes the entry that is being used.  For Rela hosts,
     this offset is stored in the reloc's addend.  For Rel hosts, we
     are forced to put this offset in the reloc's section offset.

 - : BFD_RELOC_IA64_IMM14
 - : BFD_RELOC_IA64_IMM22
 - : BFD_RELOC_IA64_IMM64
 - : BFD_RELOC_IA64_DIR32MSB
 - : BFD_RELOC_IA64_DIR32LSB
 - : BFD_RELOC_IA64_DIR64MSB
 - : BFD_RELOC_IA64_DIR64LSB
 - : BFD_RELOC_IA64_GPREL22
 - : BFD_RELOC_IA64_GPREL64I
 - : BFD_RELOC_IA64_GPREL32MSB
 - : BFD_RELOC_IA64_GPREL32LSB
 - : BFD_RELOC_IA64_GPREL64MSB
 - : BFD_RELOC_IA64_GPREL64LSB
 - : BFD_RELOC_IA64_LTOFF22
 - : BFD_RELOC_IA64_LTOFF64I
 - : BFD_RELOC_IA64_PLTOFF22
 - : BFD_RELOC_IA64_PLTOFF64I
 - : BFD_RELOC_IA64_PLTOFF64MSB
 - : BFD_RELOC_IA64_PLTOFF64LSB
 - : BFD_RELOC_IA64_FPTR64I
 - : BFD_RELOC_IA64_FPTR32MSB
 - : BFD_RELOC_IA64_FPTR32LSB
 - : BFD_RELOC_IA64_FPTR64MSB
 - : BFD_RELOC_IA64_FPTR64LSB
 - : BFD_RELOC_IA64_PCREL21B
 - : BFD_RELOC_IA64_PCREL21BI
 - : BFD_RELOC_IA64_PCREL21M
 - : BFD_RELOC_IA64_PCREL21F
 - : BFD_RELOC_IA64_PCREL22
 - : BFD_RELOC_IA64_PCREL60B
 - : BFD_RELOC_IA64_PCREL64I
 - : BFD_RELOC_IA64_PCREL32MSB
 - : BFD_RELOC_IA64_PCREL32LSB
 - : BFD_RELOC_IA64_PCREL64MSB
 - : BFD_RELOC_IA64_PCREL64LSB
 - : BFD_RELOC_IA64_LTOFF_FPTR22
 - : BFD_RELOC_IA64_LTOFF_FPTR64I
 - : BFD_RELOC_IA64_LTOFF_FPTR32MSB
 - : BFD_RELOC_IA64_LTOFF_FPTR32LSB
 - : BFD_RELOC_IA64_LTOFF_FPTR64MSB
 - : BFD_RELOC_IA64_LTOFF_FPTR64LSB
 - : BFD_RELOC_IA64_SEGREL32MSB
 - : BFD_RELOC_IA64_SEGREL32LSB
 - : BFD_RELOC_IA64_SEGREL64MSB
 - : BFD_RELOC_IA64_SEGREL64LSB
 - : BFD_RELOC_IA64_SECREL32MSB
 - : BFD_RELOC_IA64_SECREL32LSB
 - : BFD_RELOC_IA64_SECREL64MSB
 - : BFD_RELOC_IA64_SECREL64LSB
 - : BFD_RELOC_IA64_REL32MSB
 - : BFD_RELOC_IA64_REL32LSB
 - : BFD_RELOC_IA64_REL64MSB
 - : BFD_RELOC_IA64_REL64LSB
 - : BFD_RELOC_IA64_LTV32MSB
 - : BFD_RELOC_IA64_LTV32LSB
 - : BFD_RELOC_IA64_LTV64MSB
 - : BFD_RELOC_IA64_LTV64LSB
 - : BFD_RELOC_IA64_IPLTMSB
 - : BFD_RELOC_IA64_IPLTLSB
 - : BFD_RELOC_IA64_COPY
 - : BFD_RELOC_IA64_LTOFF22X
 - : BFD_RELOC_IA64_LDXMOV
 - : BFD_RELOC_IA64_TPREL14
 - : BFD_RELOC_IA64_TPREL22
 - : BFD_RELOC_IA64_TPREL64I
 - : BFD_RELOC_IA64_TPREL64MSB
 - : BFD_RELOC_IA64_TPREL64LSB
 - : BFD_RELOC_IA64_LTOFF_TPREL22
 - : BFD_RELOC_IA64_DTPMOD64MSB
 - : BFD_RELOC_IA64_DTPMOD64LSB
 - : BFD_RELOC_IA64_LTOFF_DTPMOD22
 - : BFD_RELOC_IA64_DTPREL14
 - : BFD_RELOC_IA64_DTPREL22
 - : BFD_RELOC_IA64_DTPREL64I
 - : BFD_RELOC_IA64_DTPREL32MSB
 - : BFD_RELOC_IA64_DTPREL32LSB
 - : BFD_RELOC_IA64_DTPREL64MSB
 - : BFD_RELOC_IA64_DTPREL64LSB
 - : BFD_RELOC_IA64_LTOFF_DTPREL22
     Intel IA64 Relocations.

 - : BFD_RELOC_M68HC11_HI8
     Motorola 68HC11 reloc.  This is the 8 bits high part of an
     absolute address.

 - : BFD_RELOC_M68HC11_LO8
     Motorola 68HC11 reloc.  This is the 8 bits low part of an absolute
     address.

 - : BFD_RELOC_M68HC11_3B
     Motorola 68HC11 reloc.  This is the 3 bits of a value.

 - : BFD_RELOC_CRIS_BDISP8
 - : BFD_RELOC_CRIS_UNSIGNED_5
 - : BFD_RELOC_CRIS_SIGNED_6
 - : BFD_RELOC_CRIS_UNSIGNED_6
 - : BFD_RELOC_CRIS_UNSIGNED_4
     These relocs are only used within the CRIS assembler.  They are not
     (at present) written to any object files.

 - : BFD_RELOC_CRIS_COPY
 - : BFD_RELOC_CRIS_GLOB_DAT
 - : BFD_RELOC_CRIS_JUMP_SLOT
 - : BFD_RELOC_CRIS_RELATIVE
     Relocs used in ELF shared libraries for CRIS.

 - : BFD_RELOC_CRIS_32_GOT
     32-bit offset to symbol-entry within GOT.

 - : BFD_RELOC_CRIS_16_GOT
     16-bit offset to symbol-entry within GOT.

 - : BFD_RELOC_CRIS_32_GOTPLT
     32-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_CRIS_16_GOTPLT
     16-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_CRIS_32_GOTREL
     32-bit offset to symbol, relative to GOT.

 - : BFD_RELOC_CRIS_32_PLT_GOTREL
     32-bit offset to symbol with PLT entry, relative to GOT.

 - : BFD_RELOC_CRIS_32_PLT_PCREL
     32-bit offset to symbol with PLT entry, relative to this
     relocation.

 - : BFD_RELOC_860_COPY
 - : BFD_RELOC_860_GLOB_DAT
 - : BFD_RELOC_860_JUMP_SLOT
 - : BFD_RELOC_860_RELATIVE
 - : BFD_RELOC_860_PC26
 - : BFD_RELOC_860_PLT26
 - : BFD_RELOC_860_PC16
 - : BFD_RELOC_860_LOW0
 - : BFD_RELOC_860_SPLIT0
 - : BFD_RELOC_860_LOW1
 - : BFD_RELOC_860_SPLIT1
 - : BFD_RELOC_860_LOW2
 - : BFD_RELOC_860_SPLIT2
 - : BFD_RELOC_860_LOW3
 - : BFD_RELOC_860_LOGOT0
 - : BFD_RELOC_860_SPGOT0
 - : BFD_RELOC_860_LOGOT1
 - : BFD_RELOC_860_SPGOT1
 - : BFD_RELOC_860_LOGOTOFF0
 - : BFD_RELOC_860_SPGOTOFF0
 - : BFD_RELOC_860_LOGOTOFF1
 - : BFD_RELOC_860_SPGOTOFF1
 - : BFD_RELOC_860_LOGOTOFF2
 - : BFD_RELOC_860_LOGOTOFF3
 - : BFD_RELOC_860_LOPC
 - : BFD_RELOC_860_HIGHADJ
 - : BFD_RELOC_860_HAGOT
 - : BFD_RELOC_860_HAGOTOFF
 - : BFD_RELOC_860_HAPC
 - : BFD_RELOC_860_HIGH
 - : BFD_RELOC_860_HIGOT
 - : BFD_RELOC_860_HIGOTOFF
     Intel i860 Relocations.

 - : BFD_RELOC_OPENRISC_ABS_26
 - : BFD_RELOC_OPENRISC_REL_26
     OpenRISC Relocations.

 - : BFD_RELOC_H8_DIR16A8
 - : BFD_RELOC_H8_DIR16R8
 - : BFD_RELOC_H8_DIR24A8
 - : BFD_RELOC_H8_DIR24R8
 - : BFD_RELOC_H8_DIR32A16
     H8 elf Relocations.

 - : BFD_RELOC_XSTORMY16_REL_12
 - : BFD_RELOC_XSTORMY16_24
 - : BFD_RELOC_XSTORMY16_FPTR16
     Sony Xstormy16 Relocations.

 - : BFD_RELOC_VAX_GLOB_DAT
 - : BFD_RELOC_VAX_JMP_SLOT
 - : BFD_RELOC_VAX_RELATIVE
     Relocations used by VAX ELF.


     typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;

`bfd_reloc_type_lookup'
.......................

   *Synopsis*
     reloc_howto_type *
     bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code);
   *Description*
Return a pointer to a howto structure which, when invoked, will perform
the relocation CODE on data from the architecture noted.

`bfd_default_reloc_type_lookup'
...............................

   *Synopsis*
     reloc_howto_type *bfd_default_reloc_type_lookup
        (bfd *abfd, bfd_reloc_code_real_type  code);
   *Description*
Provides a default relocation lookup routine for any architecture.

`bfd_get_reloc_code_name'
.........................

   *Synopsis*
     const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
   *Description*
Provides a printable name for the supplied relocation code.  Useful
mainly for printing error messages.

`bfd_generic_relax_section'
...........................

   *Synopsis*
     boolean bfd_generic_relax_section
        (bfd *abfd,
         asection *section,
         struct bfd_link_info *,
         boolean *);
   *Description*
Provides default handling for relaxing for back ends which don't do
relaxing - i.e., does nothing.

`bfd_generic_gc_sections'
.........................

   *Synopsis*
     boolean bfd_generic_gc_sections
        (bfd *, struct bfd_link_info *);
   *Description*
Provides default handling for relaxing for back ends which don't do
section gc - i.e., does nothing.

`bfd_generic_merge_sections'
............................

   *Synopsis*
     boolean bfd_generic_merge_sections
        (bfd *, struct bfd_link_info *);
   *Description*
Provides default handling for SEC_MERGE section merging for back ends
which don't have SEC_MERGE support - i.e., does nothing.

`bfd_generic_get_relocated_section_contents'
............................................

   *Synopsis*
     bfd_byte *
     bfd_generic_get_relocated_section_contents (bfd *abfd,
         struct bfd_link_info *link_info,
         struct bfd_link_order *link_order,
         bfd_byte *data,
         boolean relocateable,
         asymbol **symbols);
   *Description*
Provides default handling of relocation effort for back ends which
can't be bothered to do it efficiently.


File: bfd.info,  Node: Core Files,  Next: Targets,  Prev: Relocations,  Up: BFD front end

Core files
==========

   *Description*
These are functions pertaining to core files.

`bfd_core_file_failing_command'
...............................

   *Synopsis*
     const char *bfd_core_file_failing_command(bfd *abfd);
   *Description*
Return a read-only string explaining which program was running when it
failed and produced the core file ABFD.

`bfd_core_file_failing_signal'
..............................

   *Synopsis*
     int bfd_core_file_failing_signal(bfd *abfd);
   *Description*
Returns the signal number which caused the core dump which generated
the file the BFD ABFD is attached to.

`core_file_matches_executable_p'
................................

   *Synopsis*
     boolean core_file_matches_executable_p
        (bfd *core_bfd, bfd *exec_bfd);
   *Description*
Return `true' if the core file attached to CORE_BFD was generated by a
run of the executable file attached to EXEC_BFD, `false' otherwise.


File: bfd.info,  Node: Targets,  Next: Architectures,  Prev: Core Files,  Up: BFD front end

Targets
=======

   *Description*
Each port of BFD to a different machine requries the creation of a
target back end. All the back end provides to the root part of BFD is a
structure containing pointers to functions which perform certain low
level operations on files. BFD translates the applications's requests
through a pointer into calls to the back end routines.

   When a file is opened with `bfd_openr', its format and target are
unknown. BFD uses various mechanisms to determine how to interpret the
file. The operations performed are:

   * Create a BFD by calling the internal routine `_bfd_new_bfd', then
     call `bfd_find_target' with the target string supplied to
     `bfd_openr' and the new BFD pointer.

   * If a null target string was provided to `bfd_find_target', look up
     the environment variable `GNUTARGET' and use that as the target
     string.

   * If the target string is still `NULL', or the target string is
     `default', then use the first item in the target vector as the
     target type, and set `target_defaulted' in the BFD to cause
     `bfd_check_format' to loop through all the targets.  *Note
     bfd_target::.  *Note Formats::.

   * Otherwise, inspect the elements in the target vector one by one,
     until a match on target name is found. When found, use it.

   * Otherwise return the error `bfd_error_invalid_target' to
     `bfd_openr'.

   * `bfd_openr' attempts to open the file using `bfd_open_file', and
     returns the BFD.
   Once the BFD has been opened and the target selected, the file
format may be determined. This is done by calling `bfd_check_format' on
the BFD with a suggested format.  If `target_defaulted' has been set,
each possible target type is tried to see if it recognizes the
specified format.  `bfd_check_format' returns `true' when the caller
guesses right.

* Menu:

* bfd_target::

@


1.1.8.2
log
@Regenerate more generated files.
@
text
@a338 3
 - : BFD_RELOC_386_TLS_TPOFF
 - : BFD_RELOC_386_TLS_IE
 - : BFD_RELOC_386_TLS_GOTIE
@


1.1.8.3
log
@Commit generated files for 2.13.2.
@
text
@d1 1
a1 1
This is bfd.info, produced by makeinfo version 4.3 from bfd.texinfo.
@


1.1.6.1
log
@Add generated files on 2.12 release branch.
@
text
@a0 1288
This is bfd.info, produced by makeinfo version 4.0f from bfd.texinfo.

START-INFO-DIR-ENTRY
* Bfd: (bfd).                   The Binary File Descriptor library.
END-INFO-DIR-ENTRY

   This file documents the BFD library.

   Copyright (C) 1991, 2000, 2001 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
   with no Invariant Sections, with no Front-Cover Texts, and with no
    Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".


File: bfd.info,  Node: howto manager,  Prev: typedef arelent,  Up: Relocations

The howto manager
=================

   When an application wants to create a relocation, but doesn't know
what the target machine might call it, it can find out by using this
bit of code.

`bfd_reloc_code_type'
.....................

   *Description*
The insides of a reloc code.  The idea is that, eventually, there will
be one enumerator for every type of relocation we ever do.  Pass one of
these values to `bfd_reloc_type_lookup', and it'll return a howto
pointer.

   This does mean that the application must determine the correct
enumerator value; you can't get a howto pointer from a random set of
attributes.

   Here are the possible values for `enum bfd_reloc_code_real':

 - : BFD_RELOC_64
 - : BFD_RELOC_32
 - : BFD_RELOC_26
 - : BFD_RELOC_24
 - : BFD_RELOC_16
 - : BFD_RELOC_14
 - : BFD_RELOC_8
     Basic absolute relocations of N bits.

 - : BFD_RELOC_64_PCREL
 - : BFD_RELOC_32_PCREL
 - : BFD_RELOC_24_PCREL
 - : BFD_RELOC_16_PCREL
 - : BFD_RELOC_12_PCREL
 - : BFD_RELOC_8_PCREL
     PC-relative relocations.  Sometimes these are relative to the
     address of the relocation itself; sometimes they are relative to
     the start of the section containing the relocation.  It depends on
     the specific target.

     The 24-bit relocation is used in some Intel 960 configurations.

 - : BFD_RELOC_32_GOT_PCREL
 - : BFD_RELOC_16_GOT_PCREL
 - : BFD_RELOC_8_GOT_PCREL
 - : BFD_RELOC_32_GOTOFF
 - : BFD_RELOC_16_GOTOFF
 - : BFD_RELOC_LO16_GOTOFF
 - : BFD_RELOC_HI16_GOTOFF
 - : BFD_RELOC_HI16_S_GOTOFF
 - : BFD_RELOC_8_GOTOFF
 - : BFD_RELOC_64_PLT_PCREL
 - : BFD_RELOC_32_PLT_PCREL
 - : BFD_RELOC_24_PLT_PCREL
 - : BFD_RELOC_16_PLT_PCREL
 - : BFD_RELOC_8_PLT_PCREL
 - : BFD_RELOC_64_PLTOFF
 - : BFD_RELOC_32_PLTOFF
 - : BFD_RELOC_16_PLTOFF
 - : BFD_RELOC_LO16_PLTOFF
 - : BFD_RELOC_HI16_PLTOFF
 - : BFD_RELOC_HI16_S_PLTOFF
 - : BFD_RELOC_8_PLTOFF
     For ELF.

 - : BFD_RELOC_68K_GLOB_DAT
 - : BFD_RELOC_68K_JMP_SLOT
 - : BFD_RELOC_68K_RELATIVE
     Relocations used by 68K ELF.

 - : BFD_RELOC_32_BASEREL
 - : BFD_RELOC_16_BASEREL
 - : BFD_RELOC_LO16_BASEREL
 - : BFD_RELOC_HI16_BASEREL
 - : BFD_RELOC_HI16_S_BASEREL
 - : BFD_RELOC_8_BASEREL
 - : BFD_RELOC_RVA
     Linkage-table relative.

 - : BFD_RELOC_8_FFnn
     Absolute 8-bit relocation, but used to form an address like 0xFFnn.

 - : BFD_RELOC_32_PCREL_S2
 - : BFD_RELOC_16_PCREL_S2
 - : BFD_RELOC_23_PCREL_S2
     These PC-relative relocations are stored as word displacements -
     i.e., byte displacements shifted right two bits.  The 30-bit word
     displacement (<<32_PCREL_S2>> - 32 bits, shifted 2) is used on the
     SPARC.  (SPARC tools generally refer to this as <<WDISP30>>.)  The
     signed 16-bit displacement is used on the MIPS, and the 23-bit
     displacement is used on the Alpha.

 - : BFD_RELOC_HI22
 - : BFD_RELOC_LO10
     High 22 bits and low 10 bits of 32-bit value, placed into lower
     bits of the target word.  These are used on the SPARC.

 - : BFD_RELOC_GPREL16
 - : BFD_RELOC_GPREL32
     For systems that allocate a Global Pointer register, these are
     displacements off that register.  These relocation types are
     handled specially, because the value the register will have is
     decided relatively late.

 - : BFD_RELOC_I960_CALLJ
     Reloc types used for i960/b.out.

 - : BFD_RELOC_NONE
 - : BFD_RELOC_SPARC_WDISP22
 - : BFD_RELOC_SPARC22
 - : BFD_RELOC_SPARC13
 - : BFD_RELOC_SPARC_GOT10
 - : BFD_RELOC_SPARC_GOT13
 - : BFD_RELOC_SPARC_GOT22
 - : BFD_RELOC_SPARC_PC10
 - : BFD_RELOC_SPARC_PC22
 - : BFD_RELOC_SPARC_WPLT30
 - : BFD_RELOC_SPARC_COPY
 - : BFD_RELOC_SPARC_GLOB_DAT
 - : BFD_RELOC_SPARC_JMP_SLOT
 - : BFD_RELOC_SPARC_RELATIVE
 - : BFD_RELOC_SPARC_UA16
 - : BFD_RELOC_SPARC_UA32
 - : BFD_RELOC_SPARC_UA64
     SPARC ELF relocations.  There is probably some overlap with other
     relocation types already defined.

 - : BFD_RELOC_SPARC_BASE13
 - : BFD_RELOC_SPARC_BASE22
     I think these are specific to SPARC a.out (e.g., Sun 4).

 - : BFD_RELOC_SPARC_64
 - : BFD_RELOC_SPARC_10
 - : BFD_RELOC_SPARC_11
 - : BFD_RELOC_SPARC_OLO10
 - : BFD_RELOC_SPARC_HH22
 - : BFD_RELOC_SPARC_HM10
 - : BFD_RELOC_SPARC_LM22
 - : BFD_RELOC_SPARC_PC_HH22
 - : BFD_RELOC_SPARC_PC_HM10
 - : BFD_RELOC_SPARC_PC_LM22
 - : BFD_RELOC_SPARC_WDISP16
 - : BFD_RELOC_SPARC_WDISP19
 - : BFD_RELOC_SPARC_7
 - : BFD_RELOC_SPARC_6
 - : BFD_RELOC_SPARC_5
 - : BFD_RELOC_SPARC_DISP64
 - : BFD_RELOC_SPARC_PLT32
 - : BFD_RELOC_SPARC_PLT64
 - : BFD_RELOC_SPARC_HIX22
 - : BFD_RELOC_SPARC_LOX10
 - : BFD_RELOC_SPARC_H44
 - : BFD_RELOC_SPARC_M44
 - : BFD_RELOC_SPARC_L44
 - : BFD_RELOC_SPARC_REGISTER
     SPARC64 relocations

 - : BFD_RELOC_SPARC_REV32
     SPARC little endian relocation

 - : BFD_RELOC_ALPHA_GPDISP_HI16
     Alpha ECOFF and ELF relocations.  Some of these treat the symbol or
     "addend" in some special way.  For GPDISP_HI16 ("gpdisp")
     relocations, the symbol is ignored when writing; when reading, it
     will be the absolute section symbol.  The addend is the
     displacement in bytes of the "lda" instruction from the "ldah"
     instruction (which is at the address of this reloc).

 - : BFD_RELOC_ALPHA_GPDISP_LO16
     For GPDISP_LO16 ("ignore") relocations, the symbol is handled as
     with GPDISP_HI16 relocs.  The addend is ignored when writing the
     relocations out, and is filled in with the file's GP value on
     reading, for convenience.

 - : BFD_RELOC_ALPHA_GPDISP
     The ELF GPDISP relocation is exactly the same as the GPDISP_HI16
     relocation except that there is no accompanying GPDISP_LO16
     relocation.

 - : BFD_RELOC_ALPHA_LITERAL
 - : BFD_RELOC_ALPHA_ELF_LITERAL
 - : BFD_RELOC_ALPHA_LITUSE
     The Alpha LITERAL/LITUSE relocs are produced by a symbol reference;
     the assembler turns it into a LDQ instruction to load the address
     of the symbol, and then fills in a register in the real
     instruction.

     The LITERAL reloc, at the LDQ instruction, refers to the .lita
     section symbol.  The addend is ignored when writing, but is filled
     in with the file's GP value on reading, for convenience, as with
     the GPDISP_LO16 reloc.

     The ELF_LITERAL reloc is somewhere between 16_GOTOFF and
     GPDISP_LO16.  It should refer to the symbol to be referenced, as
     with 16_GOTOFF, but it generates output not based on the position
     within the .got section, but relative to the GP value chosen for
     the file during the final link stage.

     The LITUSE reloc, on the instruction using the loaded address,
     gives information to the linker that it might be able to use to
     optimize away some literal section references.  The symbol is
     ignored (read as the absolute section symbol), and the "addend"
     indicates the type of instruction using the register: 1 - "memory"
     fmt insn 2 - byte-manipulation (byte offset reg) 3 - jsr (target
     of branch)

 - : BFD_RELOC_ALPHA_HINT
     The HINT relocation indicates a value that should be filled into
     the "hint" field of a jmp/jsr/ret instruction, for possible branch-
     prediction logic which may be provided on some processors.

 - : BFD_RELOC_ALPHA_LINKAGE
     The LINKAGE relocation outputs a linkage pair in the object file,
     which is filled by the linker.

 - : BFD_RELOC_ALPHA_CODEADDR
     The CODEADDR relocation outputs a STO_CA in the object file, which
     is filled by the linker.

 - : BFD_RELOC_ALPHA_GPREL_HI16
 - : BFD_RELOC_ALPHA_GPREL_LO16
     The GPREL_HI/LO relocations together form a 32-bit offset from the
     GP register.

 - : BFD_RELOC_ALPHA_BRSGP
     Like BFD_RELOC_23_PCREL_S2, except that the source and target must
     share a common GP, and the target address is adjusted for
     STO_ALPHA_STD_GPLOAD.

 - : BFD_RELOC_MIPS_JMP
     Bits 27..2 of the relocation address shifted right 2 bits; simple
     reloc otherwise.

 - : BFD_RELOC_MIPS16_JMP
     The MIPS16 jump instruction.

 - : BFD_RELOC_MIPS16_GPREL
     MIPS16 GP relative reloc.

 - : BFD_RELOC_HI16
     High 16 bits of 32-bit value; simple reloc.

 - : BFD_RELOC_HI16_S
     High 16 bits of 32-bit value but the low 16 bits will be sign
     extended and added to form the final result.  If the low 16 bits
     form a negative number, we need to add one to the high value to
     compensate for the borrow when the low bits are added.

 - : BFD_RELOC_LO16
     Low 16 bits.

 - : BFD_RELOC_PCREL_HI16_S
     Like BFD_RELOC_HI16_S, but PC relative.

 - : BFD_RELOC_PCREL_LO16
     Like BFD_RELOC_LO16, but PC relative.

 - : BFD_RELOC_MIPS_LITERAL
     Relocation against a MIPS literal section.

 - : BFD_RELOC_MIPS_GOT16
 - : BFD_RELOC_MIPS_CALL16
 - : BFD_RELOC_MIPS_GOT_HI16
 - : BFD_RELOC_MIPS_GOT_LO16
 - : BFD_RELOC_MIPS_CALL_HI16
 - : BFD_RELOC_MIPS_CALL_LO16
 - : BFD_RELOC_MIPS_SUB
 - : BFD_RELOC_MIPS_GOT_PAGE
 - : BFD_RELOC_MIPS_GOT_OFST
 - : BFD_RELOC_MIPS_GOT_DISP
 - : BFD_RELOC_MIPS_SHIFT5
 - : BFD_RELOC_MIPS_SHIFT6
 - : BFD_RELOC_MIPS_INSERT_A
 - : BFD_RELOC_MIPS_INSERT_B
 - : BFD_RELOC_MIPS_DELETE
 - : BFD_RELOC_MIPS_HIGHEST
 - : BFD_RELOC_MIPS_HIGHER
 - : BFD_RELOC_MIPS_SCN_DISP
 - : BFD_RELOC_MIPS_REL16
 - : BFD_RELOC_MIPS_RELGOT
 - : BFD_RELOC_MIPS_JALR
 - : BFD_RELOC_SH_GOT_LOW16
 - : BFD_RELOC_SH_GOT_MEDLOW16
 - : BFD_RELOC_SH_GOT_MEDHI16
 - : BFD_RELOC_SH_GOT_HI16
 - : BFD_RELOC_SH_GOTPLT_LOW16
 - : BFD_RELOC_SH_GOTPLT_MEDLOW16
 - : BFD_RELOC_SH_GOTPLT_MEDHI16
 - : BFD_RELOC_SH_GOTPLT_HI16
 - : BFD_RELOC_SH_PLT_LOW16
 - : BFD_RELOC_SH_PLT_MEDLOW16
 - : BFD_RELOC_SH_PLT_MEDHI16
 - : BFD_RELOC_SH_PLT_HI16
 - : BFD_RELOC_SH_GOTOFF_LOW16
 - : BFD_RELOC_SH_GOTOFF_MEDLOW16
 - : BFD_RELOC_SH_GOTOFF_MEDHI16
 - : BFD_RELOC_SH_GOTOFF_HI16
 - : BFD_RELOC_SH_GOTPC_LOW16
 - : BFD_RELOC_SH_GOTPC_MEDLOW16
 - : BFD_RELOC_SH_GOTPC_MEDHI16
 - : BFD_RELOC_SH_GOTPC_HI16
 - : BFD_RELOC_SH_COPY64
 - : BFD_RELOC_SH_GLOB_DAT64
 - : BFD_RELOC_SH_JMP_SLOT64
 - : BFD_RELOC_SH_RELATIVE64
 - : BFD_RELOC_SH_GOT10BY4
 - : BFD_RELOC_SH_GOT10BY8
 - : BFD_RELOC_SH_GOTPLT10BY4
 - : BFD_RELOC_SH_GOTPLT10BY8
 - : BFD_RELOC_SH_GOTPLT32
 - : BFD_RELOC_SH_SHMEDIA_CODE
 - : BFD_RELOC_SH_IMMU5
 - : BFD_RELOC_SH_IMMS6
 - : BFD_RELOC_SH_IMMS6BY32
 - : BFD_RELOC_SH_IMMU6
 - : BFD_RELOC_SH_IMMS10
 - : BFD_RELOC_SH_IMMS10BY2
 - : BFD_RELOC_SH_IMMS10BY4
 - : BFD_RELOC_SH_IMMS10BY8
 - : BFD_RELOC_SH_IMMS16
 - : BFD_RELOC_SH_IMMU16
 - : BFD_RELOC_SH_IMM_LOW16
 - : BFD_RELOC_SH_IMM_LOW16_PCREL
 - : BFD_RELOC_SH_IMM_MEDLOW16
 - : BFD_RELOC_SH_IMM_MEDLOW16_PCREL
 - : BFD_RELOC_SH_IMM_MEDHI16
 - : BFD_RELOC_SH_IMM_MEDHI16_PCREL
 - : BFD_RELOC_SH_IMM_HI16
 - : BFD_RELOC_SH_IMM_HI16_PCREL
 - : BFD_RELOC_SH_PT_16
     MIPS ELF relocations.

 - : BFD_RELOC_386_GOT32
 - : BFD_RELOC_386_PLT32
 - : BFD_RELOC_386_COPY
 - : BFD_RELOC_386_GLOB_DAT
 - : BFD_RELOC_386_JUMP_SLOT
 - : BFD_RELOC_386_RELATIVE
 - : BFD_RELOC_386_GOTOFF
 - : BFD_RELOC_386_GOTPC
     i386/elf relocations

 - : BFD_RELOC_X86_64_GOT32
 - : BFD_RELOC_X86_64_PLT32
 - : BFD_RELOC_X86_64_COPY
 - : BFD_RELOC_X86_64_GLOB_DAT
 - : BFD_RELOC_X86_64_JUMP_SLOT
 - : BFD_RELOC_X86_64_RELATIVE
 - : BFD_RELOC_X86_64_GOTPCREL
 - : BFD_RELOC_X86_64_32S
     x86-64/elf relocations

 - : BFD_RELOC_NS32K_IMM_8
 - : BFD_RELOC_NS32K_IMM_16
 - : BFD_RELOC_NS32K_IMM_32
 - : BFD_RELOC_NS32K_IMM_8_PCREL
 - : BFD_RELOC_NS32K_IMM_16_PCREL
 - : BFD_RELOC_NS32K_IMM_32_PCREL
 - : BFD_RELOC_NS32K_DISP_8
 - : BFD_RELOC_NS32K_DISP_16
 - : BFD_RELOC_NS32K_DISP_32
 - : BFD_RELOC_NS32K_DISP_8_PCREL
 - : BFD_RELOC_NS32K_DISP_16_PCREL
 - : BFD_RELOC_NS32K_DISP_32_PCREL
     ns32k relocations

 - : BFD_RELOC_PDP11_DISP_8_PCREL
 - : BFD_RELOC_PDP11_DISP_6_PCREL
     PDP11 relocations

 - : BFD_RELOC_PJ_CODE_HI16
 - : BFD_RELOC_PJ_CODE_LO16
 - : BFD_RELOC_PJ_CODE_DIR16
 - : BFD_RELOC_PJ_CODE_DIR32
 - : BFD_RELOC_PJ_CODE_REL16
 - : BFD_RELOC_PJ_CODE_REL32
     Picojava relocs.  Not all of these appear in object files.

 - : BFD_RELOC_PPC_B26
 - : BFD_RELOC_PPC_BA26
 - : BFD_RELOC_PPC_TOC16
 - : BFD_RELOC_PPC_B16
 - : BFD_RELOC_PPC_B16_BRTAKEN
 - : BFD_RELOC_PPC_B16_BRNTAKEN
 - : BFD_RELOC_PPC_BA16
 - : BFD_RELOC_PPC_BA16_BRTAKEN
 - : BFD_RELOC_PPC_BA16_BRNTAKEN
 - : BFD_RELOC_PPC_COPY
 - : BFD_RELOC_PPC_GLOB_DAT
 - : BFD_RELOC_PPC_JMP_SLOT
 - : BFD_RELOC_PPC_RELATIVE
 - : BFD_RELOC_PPC_LOCAL24PC
 - : BFD_RELOC_PPC_EMB_NADDR32
 - : BFD_RELOC_PPC_EMB_NADDR16
 - : BFD_RELOC_PPC_EMB_NADDR16_LO
 - : BFD_RELOC_PPC_EMB_NADDR16_HI
 - : BFD_RELOC_PPC_EMB_NADDR16_HA
 - : BFD_RELOC_PPC_EMB_SDAI16
 - : BFD_RELOC_PPC_EMB_SDA2I16
 - : BFD_RELOC_PPC_EMB_SDA2REL
 - : BFD_RELOC_PPC_EMB_SDA21
 - : BFD_RELOC_PPC_EMB_MRKREF
 - : BFD_RELOC_PPC_EMB_RELSEC16
 - : BFD_RELOC_PPC_EMB_RELST_LO
 - : BFD_RELOC_PPC_EMB_RELST_HI
 - : BFD_RELOC_PPC_EMB_RELST_HA
 - : BFD_RELOC_PPC_EMB_BIT_FLD
 - : BFD_RELOC_PPC_EMB_RELSDA
 - : BFD_RELOC_PPC64_HIGHER
 - : BFD_RELOC_PPC64_HIGHER_S
 - : BFD_RELOC_PPC64_HIGHEST
 - : BFD_RELOC_PPC64_HIGHEST_S
 - : BFD_RELOC_PPC64_TOC16_LO
 - : BFD_RELOC_PPC64_TOC16_HI
 - : BFD_RELOC_PPC64_TOC16_HA
 - : BFD_RELOC_PPC64_TOC
 - : BFD_RELOC_PPC64_PLTGOT16
 - : BFD_RELOC_PPC64_PLTGOT16_LO
 - : BFD_RELOC_PPC64_PLTGOT16_HI
 - : BFD_RELOC_PPC64_PLTGOT16_HA
 - : BFD_RELOC_PPC64_ADDR16_DS
 - : BFD_RELOC_PPC64_ADDR16_LO_DS
 - : BFD_RELOC_PPC64_GOT16_DS
 - : BFD_RELOC_PPC64_GOT16_LO_DS
 - : BFD_RELOC_PPC64_PLT16_LO_DS
 - : BFD_RELOC_PPC64_SECTOFF_DS
 - : BFD_RELOC_PPC64_SECTOFF_LO_DS
 - : BFD_RELOC_PPC64_TOC16_DS
 - : BFD_RELOC_PPC64_TOC16_LO_DS
 - : BFD_RELOC_PPC64_PLTGOT16_DS
 - : BFD_RELOC_PPC64_PLTGOT16_LO_DS
     Power(rs6000) and PowerPC relocations.

 - : BFD_RELOC_I370_D12
     IBM 370/390 relocations

 - : BFD_RELOC_CTOR
     The type of reloc used to build a contructor table - at the moment
     probably a 32 bit wide absolute relocation, but the target can
     choose.  It generally does map to one of the other relocation
     types.

 - : BFD_RELOC_ARM_PCREL_BRANCH
     ARM 26 bit pc-relative branch.  The lowest two bits must be zero
     and are not stored in the instruction.

 - : BFD_RELOC_ARM_PCREL_BLX
     ARM 26 bit pc-relative branch.  The lowest bit must be zero and is
     not stored in the instruction.  The 2nd lowest bit comes from a 1
     bit field in the instruction.

 - : BFD_RELOC_THUMB_PCREL_BLX
     Thumb 22 bit pc-relative branch.  The lowest bit must be zero and
     is not stored in the instruction.  The 2nd lowest bit comes from a
     1 bit field in the instruction.

 - : BFD_RELOC_ARM_IMMEDIATE
 - : BFD_RELOC_ARM_ADRL_IMMEDIATE
 - : BFD_RELOC_ARM_OFFSET_IMM
 - : BFD_RELOC_ARM_SHIFT_IMM
 - : BFD_RELOC_ARM_SWI
 - : BFD_RELOC_ARM_MULTI
 - : BFD_RELOC_ARM_CP_OFF_IMM
 - : BFD_RELOC_ARM_ADR_IMM
 - : BFD_RELOC_ARM_LDR_IMM
 - : BFD_RELOC_ARM_LITERAL
 - : BFD_RELOC_ARM_IN_POOL
 - : BFD_RELOC_ARM_OFFSET_IMM8
 - : BFD_RELOC_ARM_HWLITERAL
 - : BFD_RELOC_ARM_THUMB_ADD
 - : BFD_RELOC_ARM_THUMB_IMM
 - : BFD_RELOC_ARM_THUMB_SHIFT
 - : BFD_RELOC_ARM_THUMB_OFFSET
 - : BFD_RELOC_ARM_GOT12
 - : BFD_RELOC_ARM_GOT32
 - : BFD_RELOC_ARM_JUMP_SLOT
 - : BFD_RELOC_ARM_COPY
 - : BFD_RELOC_ARM_GLOB_DAT
 - : BFD_RELOC_ARM_PLT32
 - : BFD_RELOC_ARM_RELATIVE
 - : BFD_RELOC_ARM_GOTOFF
 - : BFD_RELOC_ARM_GOTPC
     These relocs are only used within the ARM assembler.  They are not
     (at present) written to any object files.

 - : BFD_RELOC_SH_PCDISP8BY2
 - : BFD_RELOC_SH_PCDISP12BY2
 - : BFD_RELOC_SH_IMM4
 - : BFD_RELOC_SH_IMM4BY2
 - : BFD_RELOC_SH_IMM4BY4
 - : BFD_RELOC_SH_IMM8
 - : BFD_RELOC_SH_IMM8BY2
 - : BFD_RELOC_SH_IMM8BY4
 - : BFD_RELOC_SH_PCRELIMM8BY2
 - : BFD_RELOC_SH_PCRELIMM8BY4
 - : BFD_RELOC_SH_SWITCH16
 - : BFD_RELOC_SH_SWITCH32
 - : BFD_RELOC_SH_USES
 - : BFD_RELOC_SH_COUNT
 - : BFD_RELOC_SH_ALIGN
 - : BFD_RELOC_SH_CODE
 - : BFD_RELOC_SH_DATA
 - : BFD_RELOC_SH_LABEL
 - : BFD_RELOC_SH_LOOP_START
 - : BFD_RELOC_SH_LOOP_END
 - : BFD_RELOC_SH_COPY
 - : BFD_RELOC_SH_GLOB_DAT
 - : BFD_RELOC_SH_JMP_SLOT
 - : BFD_RELOC_SH_RELATIVE
 - : BFD_RELOC_SH_GOTPC
     Hitachi SH relocs.  Not all of these appear in object files.

 - : BFD_RELOC_THUMB_PCREL_BRANCH9
 - : BFD_RELOC_THUMB_PCREL_BRANCH12
 - : BFD_RELOC_THUMB_PCREL_BRANCH23
     Thumb 23-, 12- and 9-bit pc-relative branches.  The lowest bit must
     be zero and is not stored in the instruction.

 - : BFD_RELOC_ARC_B22_PCREL
     ARC Cores relocs.  ARC 22 bit pc-relative branch.  The lowest two
     bits must be zero and are not stored in the instruction.  The high
     20 bits are installed in bits 26 through 7 of the instruction.

 - : BFD_RELOC_ARC_B26
     ARC 26 bit absolute branch.  The lowest two bits must be zero and
     are not stored in the instruction.  The high 24 bits are installed
     in bits 23 through 0.

 - : BFD_RELOC_D10V_10_PCREL_R
     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
     bits assumed to be 0.

 - : BFD_RELOC_D10V_10_PCREL_L
     Mitsubishi D10V relocs.  This is a 10-bit reloc with the right 2
     bits assumed to be 0.  This is the same as the previous reloc
     except it is in the left container, i.e., shifted left 15 bits.

 - : BFD_RELOC_D10V_18
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_D10V_18_PCREL
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_D30V_6
     Mitsubishi D30V relocs.  This is a 6-bit absolute reloc.

 - : BFD_RELOC_D30V_9_PCREL
     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
     be 0.

 - : BFD_RELOC_D30V_9_PCREL_R
     This is a 6-bit pc-relative reloc with the right 3 bits assumed to
     be 0. Same as the previous reloc but on the right side of the
     container.

 - : BFD_RELOC_D30V_15
     This is a 12-bit absolute reloc with the right 3 bitsassumed to be
     0.

 - : BFD_RELOC_D30V_15_PCREL
     This is a 12-bit pc-relative reloc with the right 3 bits assumed
     to be 0.

 - : BFD_RELOC_D30V_15_PCREL_R
     This is a 12-bit pc-relative reloc with the right 3 bits assumed
     to be 0. Same as the previous reloc but on the right side of the
     container.

 - : BFD_RELOC_D30V_21
     This is an 18-bit absolute reloc with the right 3 bits assumed to
     be 0.

 - : BFD_RELOC_D30V_21_PCREL
     This is an 18-bit pc-relative reloc with the right 3 bits assumed
     to be 0.

 - : BFD_RELOC_D30V_21_PCREL_R
     This is an 18-bit pc-relative reloc with the right 3 bits assumed
     to be 0. Same as the previous reloc but on the right side of the
     container.

 - : BFD_RELOC_D30V_32
     This is a 32-bit absolute reloc.

 - : BFD_RELOC_D30V_32_PCREL
     This is a 32-bit pc-relative reloc.

 - : BFD_RELOC_M32R_24
     Mitsubishi M32R relocs.  This is a 24 bit absolute address.

 - : BFD_RELOC_M32R_10_PCREL
     This is a 10-bit pc-relative reloc with the right 2 bits assumed
     to be 0.

 - : BFD_RELOC_M32R_18_PCREL
     This is an 18-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_M32R_26_PCREL
     This is a 26-bit reloc with the right 2 bits assumed to be 0.

 - : BFD_RELOC_M32R_HI16_ULO
     This is a 16-bit reloc containing the high 16 bits of an address
     used when the lower 16 bits are treated as unsigned.

 - : BFD_RELOC_M32R_HI16_SLO
     This is a 16-bit reloc containing the high 16 bits of an address
     used when the lower 16 bits are treated as signed.

 - : BFD_RELOC_M32R_LO16
     This is a 16-bit reloc containing the lower 16 bits of an address.

 - : BFD_RELOC_M32R_SDA16
     This is a 16-bit reloc containing the small data area offset for
     use in add3, load, and store instructions.

 - : BFD_RELOC_V850_9_PCREL
     This is a 9-bit reloc

 - : BFD_RELOC_V850_22_PCREL
     This is a 22-bit reloc

 - : BFD_RELOC_V850_SDA_16_16_OFFSET
     This is a 16 bit offset from the short data area pointer.

 - : BFD_RELOC_V850_SDA_15_16_OFFSET
     This is a 16 bit offset (of which only 15 bits are used) from the
     short data area pointer.

 - : BFD_RELOC_V850_ZDA_16_16_OFFSET
     This is a 16 bit offset from the zero data area pointer.

 - : BFD_RELOC_V850_ZDA_15_16_OFFSET
     This is a 16 bit offset (of which only 15 bits are used) from the
     zero data area pointer.

 - : BFD_RELOC_V850_TDA_6_8_OFFSET
     This is an 8 bit offset (of which only 6 bits are used) from the
     tiny data area pointer.

 - : BFD_RELOC_V850_TDA_7_8_OFFSET
     This is an 8bit offset (of which only 7 bits are used) from the
     tiny data area pointer.

 - : BFD_RELOC_V850_TDA_7_7_OFFSET
     This is a 7 bit offset from the tiny data area pointer.

 - : BFD_RELOC_V850_TDA_16_16_OFFSET
     This is a 16 bit offset from the tiny data area pointer.

 - : BFD_RELOC_V850_TDA_4_5_OFFSET
     This is a 5 bit offset (of which only 4 bits are used) from the
     tiny data area pointer.

 - : BFD_RELOC_V850_TDA_4_4_OFFSET
     This is a 4 bit offset from the tiny data area pointer.

 - : BFD_RELOC_V850_SDA_16_16_SPLIT_OFFSET
     This is a 16 bit offset from the short data area pointer, with the
     bits placed non-contigously in the instruction.

 - : BFD_RELOC_V850_ZDA_16_16_SPLIT_OFFSET
     This is a 16 bit offset from the zero data area pointer, with the
     bits placed non-contigously in the instruction.

 - : BFD_RELOC_V850_CALLT_6_7_OFFSET
     This is a 6 bit offset from the call table base pointer.

 - : BFD_RELOC_V850_CALLT_16_16_OFFSET
     This is a 16 bit offset from the call table base pointer.

 - : BFD_RELOC_MN10300_32_PCREL
     This is a 32bit pcrel reloc for the mn10300, offset by two bytes
     in the instruction.

 - : BFD_RELOC_MN10300_16_PCREL
     This is a 16bit pcrel reloc for the mn10300, offset by two bytes
     in the instruction.

 - : BFD_RELOC_TIC30_LDP
     This is a 8bit DP reloc for the tms320c30, where the most
     significant 8 bits of a 24 bit word are placed into the least
     significant 8 bits of the opcode.

 - : BFD_RELOC_TIC54X_PARTLS7
     This is a 7bit reloc for the tms320c54x, where the least
     significant 7 bits of a 16 bit word are placed into the least
     significant 7 bits of the opcode.

 - : BFD_RELOC_TIC54X_PARTMS9
     This is a 9bit DP reloc for the tms320c54x, where the most
     significant 9 bits of a 16 bit word are placed into the least
     significant 9 bits of the opcode.

 - : BFD_RELOC_TIC54X_23
     This is an extended address 23-bit reloc for the tms320c54x.

 - : BFD_RELOC_TIC54X_16_OF_23
     This is a 16-bit reloc for the tms320c54x, where the least
     significant 16 bits of a 23-bit extended address are placed into
     the opcode.

 - : BFD_RELOC_TIC54X_MS7_OF_23
     This is a reloc for the tms320c54x, where the most significant 7
     bits of a 23-bit extended address are placed into the opcode.

 - : BFD_RELOC_FR30_48
     This is a 48 bit reloc for the FR30 that stores 32 bits.

 - : BFD_RELOC_FR30_20
     This is a 32 bit reloc for the FR30 that stores 20 bits split up
     into two sections.

 - : BFD_RELOC_FR30_6_IN_4
     This is a 16 bit reloc for the FR30 that stores a 6 bit word
     offset in 4 bits.

 - : BFD_RELOC_FR30_8_IN_8
     This is a 16 bit reloc for the FR30 that stores an 8 bit byte
     offset into 8 bits.

 - : BFD_RELOC_FR30_9_IN_8
     This is a 16 bit reloc for the FR30 that stores a 9 bit short
     offset into 8 bits.

 - : BFD_RELOC_FR30_10_IN_8
     This is a 16 bit reloc for the FR30 that stores a 10 bit word
     offset into 8 bits.

 - : BFD_RELOC_FR30_9_PCREL
     This is a 16 bit reloc for the FR30 that stores a 9 bit pc relative
     short offset into 8 bits.

 - : BFD_RELOC_FR30_12_PCREL
     This is a 16 bit reloc for the FR30 that stores a 12 bit pc
     relative short offset into 11 bits.

 - : BFD_RELOC_MCORE_PCREL_IMM8BY4
 - : BFD_RELOC_MCORE_PCREL_IMM11BY2
 - : BFD_RELOC_MCORE_PCREL_IMM4BY2
 - : BFD_RELOC_MCORE_PCREL_32
 - : BFD_RELOC_MCORE_PCREL_JSR_IMM11BY2
 - : BFD_RELOC_MCORE_RVA
     Motorola Mcore relocations.

 - : BFD_RELOC_MMIX_GETA
 - : BFD_RELOC_MMIX_GETA_1
 - : BFD_RELOC_MMIX_GETA_2
 - : BFD_RELOC_MMIX_GETA_3
     These are relocations for the GETA instruction.

 - : BFD_RELOC_MMIX_CBRANCH
 - : BFD_RELOC_MMIX_CBRANCH_J
 - : BFD_RELOC_MMIX_CBRANCH_1
 - : BFD_RELOC_MMIX_CBRANCH_2
 - : BFD_RELOC_MMIX_CBRANCH_3
     These are relocations for a conditional branch instruction.

 - : BFD_RELOC_MMIX_PUSHJ
 - : BFD_RELOC_MMIX_PUSHJ_1
 - : BFD_RELOC_MMIX_PUSHJ_2
 - : BFD_RELOC_MMIX_PUSHJ_3
     These are relocations for the PUSHJ instruction.

 - : BFD_RELOC_MMIX_JMP
 - : BFD_RELOC_MMIX_JMP_1
 - : BFD_RELOC_MMIX_JMP_2
 - : BFD_RELOC_MMIX_JMP_3
     These are relocations for the JMP instruction.

 - : BFD_RELOC_MMIX_ADDR19
     This is a relocation for a relative address as in a GETA
     instruction or a branch.

 - : BFD_RELOC_MMIX_ADDR27
     This is a relocation for a relative address as in a JMP
     instruction.

 - : BFD_RELOC_MMIX_REG_OR_BYTE
     This is a relocation for an instruction field that may be a general
     register or a value 0..255.

 - : BFD_RELOC_MMIX_REG
     This is a relocation for an instruction field that may be a general
     register.

 - : BFD_RELOC_MMIX_BASE_PLUS_OFFSET
     This is a relocation for two instruction fields holding a register
     and an offset, the equivalent of the relocation.

 - : BFD_RELOC_MMIX_LOCAL
     This relocation is an assertion that the expression is not
     allocated as a global register.  It does not modify contents.

 - : BFD_RELOC_AVR_7_PCREL
     This is a 16 bit reloc for the AVR that stores 8 bit pc relative
     short offset into 7 bits.

 - : BFD_RELOC_AVR_13_PCREL
     This is a 16 bit reloc for the AVR that stores 13 bit pc relative
     short offset into 12 bits.

 - : BFD_RELOC_AVR_16_PM
     This is a 16 bit reloc for the AVR that stores 17 bit value
     (usually program memory address) into 16 bits.

 - : BFD_RELOC_AVR_LO8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
     data memory address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HI8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
     bit of data memory address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HH8_LDI
     This is a 16 bit reloc for the AVR that stores 8 bit value (most
     high 8 bit of program memory address) into 8 bit immediate value
     of LDI insn.

 - : BFD_RELOC_AVR_LO8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (usually data memory address) into 8 bit immediate value of SUBI
     insn.

 - : BFD_RELOC_AVR_HI8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 8 bit of data memory address) into 8 bit immediate value of
     SUBI insn.

 - : BFD_RELOC_AVR_HH8_LDI_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (most high 8 bit of program memory address) into 8 bit immediate
     value of LDI or SUBI insn.

 - : BFD_RELOC_AVR_LO8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (usually
     command address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HI8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (high 8
     bit of command address) into 8 bit immediate value of LDI insn.

 - : BFD_RELOC_AVR_HH8_LDI_PM
     This is a 16 bit reloc for the AVR that stores 8 bit value (most
     high 8 bit of command address) into 8 bit immediate value of LDI
     insn.

 - : BFD_RELOC_AVR_LO8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (usually command address) into 8 bit immediate value of SUBI insn.

 - : BFD_RELOC_AVR_HI8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 8 bit of 16 bit command address) into 8 bit immediate value
     of SUBI insn.

 - : BFD_RELOC_AVR_HH8_LDI_PM_NEG
     This is a 16 bit reloc for the AVR that stores negated 8 bit value
     (high 6 bit of 22 bit command address) into 8 bit immediate value
     of SUBI insn.

 - : BFD_RELOC_AVR_CALL
     This is a 32 bit reloc for the AVR that stores 23 bit value into
     22 bits.

 - : BFD_RELOC_390_12
     Direct 12 bit.

 - : BFD_RELOC_390_GOT12
     12 bit GOT offset.

 - : BFD_RELOC_390_PLT32
     32 bit PC relative PLT address.

 - : BFD_RELOC_390_COPY
     Copy symbol at runtime.

 - : BFD_RELOC_390_GLOB_DAT
     Create GOT entry.

 - : BFD_RELOC_390_JMP_SLOT
     Create PLT entry.

 - : BFD_RELOC_390_RELATIVE
     Adjust by program base.

 - : BFD_RELOC_390_GOTPC
     32 bit PC relative offset to GOT.

 - : BFD_RELOC_390_GOT16
     16 bit GOT offset.

 - : BFD_RELOC_390_PC16DBL
     PC relative 16 bit shifted by 1.

 - : BFD_RELOC_390_PLT16DBL
     16 bit PC rel. PLT shifted by 1.

 - : BFD_RELOC_390_PC32DBL
     PC relative 32 bit shifted by 1.

 - : BFD_RELOC_390_PLT32DBL
     32 bit PC rel. PLT shifted by 1.

 - : BFD_RELOC_390_GOTPCDBL
     32 bit PC rel. GOT shifted by 1.

 - : BFD_RELOC_390_GOT64
     64 bit GOT offset.

 - : BFD_RELOC_390_PLT64
     64 bit PC relative PLT address.

 - : BFD_RELOC_390_GOTENT
     32 bit rel. offset to GOT entry.

 - : BFD_RELOC_VTABLE_INHERIT
 - : BFD_RELOC_VTABLE_ENTRY
     These two relocations are used by the linker to determine which of
     the entries in a C++ virtual function table are actually used.
     When the -gc-sections option is given, the linker will zero out
     the entries that are not used, so that the code for those
     functions need not be included in the output.

     VTABLE_INHERIT is a zero-space relocation used to describe to the
     linker the inheritence tree of a C++ virtual function table.  The
     relocation's symbol should be the parent class' vtable, and the
     relocation should be located at the child vtable.

     VTABLE_ENTRY is a zero-space relocation that describes the use of a
     virtual function table entry.  The reloc's symbol should refer to
     the table of the class mentioned in the code.  Off of that base,
     an offset describes the entry that is being used.  For Rela hosts,
     this offset is stored in the reloc's addend.  For Rel hosts, we
     are forced to put this offset in the reloc's section offset.

 - : BFD_RELOC_IA64_IMM14
 - : BFD_RELOC_IA64_IMM22
 - : BFD_RELOC_IA64_IMM64
 - : BFD_RELOC_IA64_DIR32MSB
 - : BFD_RELOC_IA64_DIR32LSB
 - : BFD_RELOC_IA64_DIR64MSB
 - : BFD_RELOC_IA64_DIR64LSB
 - : BFD_RELOC_IA64_GPREL22
 - : BFD_RELOC_IA64_GPREL64I
 - : BFD_RELOC_IA64_GPREL32MSB
 - : BFD_RELOC_IA64_GPREL32LSB
 - : BFD_RELOC_IA64_GPREL64MSB
 - : BFD_RELOC_IA64_GPREL64LSB
 - : BFD_RELOC_IA64_LTOFF22
 - : BFD_RELOC_IA64_LTOFF64I
 - : BFD_RELOC_IA64_PLTOFF22
 - : BFD_RELOC_IA64_PLTOFF64I
 - : BFD_RELOC_IA64_PLTOFF64MSB
 - : BFD_RELOC_IA64_PLTOFF64LSB
 - : BFD_RELOC_IA64_FPTR64I
 - : BFD_RELOC_IA64_FPTR32MSB
 - : BFD_RELOC_IA64_FPTR32LSB
 - : BFD_RELOC_IA64_FPTR64MSB
 - : BFD_RELOC_IA64_FPTR64LSB
 - : BFD_RELOC_IA64_PCREL21B
 - : BFD_RELOC_IA64_PCREL21BI
 - : BFD_RELOC_IA64_PCREL21M
 - : BFD_RELOC_IA64_PCREL21F
 - : BFD_RELOC_IA64_PCREL22
 - : BFD_RELOC_IA64_PCREL60B
 - : BFD_RELOC_IA64_PCREL64I
 - : BFD_RELOC_IA64_PCREL32MSB
 - : BFD_RELOC_IA64_PCREL32LSB
 - : BFD_RELOC_IA64_PCREL64MSB
 - : BFD_RELOC_IA64_PCREL64LSB
 - : BFD_RELOC_IA64_LTOFF_FPTR22
 - : BFD_RELOC_IA64_LTOFF_FPTR64I
 - : BFD_RELOC_IA64_LTOFF_FPTR32MSB
 - : BFD_RELOC_IA64_LTOFF_FPTR32LSB
 - : BFD_RELOC_IA64_LTOFF_FPTR64MSB
 - : BFD_RELOC_IA64_LTOFF_FPTR64LSB
 - : BFD_RELOC_IA64_SEGREL32MSB
 - : BFD_RELOC_IA64_SEGREL32LSB
 - : BFD_RELOC_IA64_SEGREL64MSB
 - : BFD_RELOC_IA64_SEGREL64LSB
 - : BFD_RELOC_IA64_SECREL32MSB
 - : BFD_RELOC_IA64_SECREL32LSB
 - : BFD_RELOC_IA64_SECREL64MSB
 - : BFD_RELOC_IA64_SECREL64LSB
 - : BFD_RELOC_IA64_REL32MSB
 - : BFD_RELOC_IA64_REL32LSB
 - : BFD_RELOC_IA64_REL64MSB
 - : BFD_RELOC_IA64_REL64LSB
 - : BFD_RELOC_IA64_LTV32MSB
 - : BFD_RELOC_IA64_LTV32LSB
 - : BFD_RELOC_IA64_LTV64MSB
 - : BFD_RELOC_IA64_LTV64LSB
 - : BFD_RELOC_IA64_IPLTMSB
 - : BFD_RELOC_IA64_IPLTLSB
 - : BFD_RELOC_IA64_COPY
 - : BFD_RELOC_IA64_TPREL22
 - : BFD_RELOC_IA64_TPREL64MSB
 - : BFD_RELOC_IA64_TPREL64LSB
 - : BFD_RELOC_IA64_LTOFF_TP22
 - : BFD_RELOC_IA64_LTOFF22X
 - : BFD_RELOC_IA64_LDXMOV
     Intel IA64 Relocations.

 - : BFD_RELOC_M68HC11_HI8
     Motorola 68HC11 reloc.  This is the 8 bits high part of an
     absolute address.

 - : BFD_RELOC_M68HC11_LO8
     Motorola 68HC11 reloc.  This is the 8 bits low part of an absolute
     address.

 - : BFD_RELOC_M68HC11_3B
     Motorola 68HC11 reloc.  This is the 3 bits of a value.

 - : BFD_RELOC_CRIS_BDISP8
 - : BFD_RELOC_CRIS_UNSIGNED_5
 - : BFD_RELOC_CRIS_SIGNED_6
 - : BFD_RELOC_CRIS_UNSIGNED_6
 - : BFD_RELOC_CRIS_UNSIGNED_4
     These relocs are only used within the CRIS assembler.  They are not
     (at present) written to any object files.

 - : BFD_RELOC_CRIS_COPY
 - : BFD_RELOC_CRIS_GLOB_DAT
 - : BFD_RELOC_CRIS_JUMP_SLOT
 - : BFD_RELOC_CRIS_RELATIVE
     Relocs used in ELF shared libraries for CRIS.

 - : BFD_RELOC_CRIS_32_GOT
     32-bit offset to symbol-entry within GOT.

 - : BFD_RELOC_CRIS_16_GOT
     16-bit offset to symbol-entry within GOT.

 - : BFD_RELOC_CRIS_32_GOTPLT
     32-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_CRIS_16_GOTPLT
     16-bit offset to symbol-entry within GOT, with PLT handling.

 - : BFD_RELOC_CRIS_32_GOTREL
     32-bit offset to symbol, relative to GOT.

 - : BFD_RELOC_CRIS_32_PLT_GOTREL
     32-bit offset to symbol with PLT entry, relative to GOT.

 - : BFD_RELOC_CRIS_32_PLT_PCREL
     32-bit offset to symbol with PLT entry, relative to this
     relocation.

 - : BFD_RELOC_860_COPY
 - : BFD_RELOC_860_GLOB_DAT
 - : BFD_RELOC_860_JUMP_SLOT
 - : BFD_RELOC_860_RELATIVE
 - : BFD_RELOC_860_PC26
 - : BFD_RELOC_860_PLT26
 - : BFD_RELOC_860_PC16
 - : BFD_RELOC_860_LOW0
 - : BFD_RELOC_860_SPLIT0
 - : BFD_RELOC_860_LOW1
 - : BFD_RELOC_860_SPLIT1
 - : BFD_RELOC_860_LOW2
 - : BFD_RELOC_860_SPLIT2
 - : BFD_RELOC_860_LOW3
 - : BFD_RELOC_860_LOGOT0
 - : BFD_RELOC_860_SPGOT0
 - : BFD_RELOC_860_LOGOT1
 - : BFD_RELOC_860_SPGOT1
 - : BFD_RELOC_860_LOGOTOFF0
 - : BFD_RELOC_860_SPGOTOFF0
 - : BFD_RELOC_860_LOGOTOFF1
 - : BFD_RELOC_860_SPGOTOFF1
 - : BFD_RELOC_860_LOGOTOFF2
 - : BFD_RELOC_860_LOGOTOFF3
 - : BFD_RELOC_860_LOPC
 - : BFD_RELOC_860_HIGHADJ
 - : BFD_RELOC_860_HAGOT
 - : BFD_RELOC_860_HAGOTOFF
 - : BFD_RELOC_860_HAPC
 - : BFD_RELOC_860_HIGH
 - : BFD_RELOC_860_HIGOT
 - : BFD_RELOC_860_HIGOTOFF
     Intel i860 Relocations.

 - : BFD_RELOC_OPENRISC_ABS_26
 - : BFD_RELOC_OPENRISC_REL_26
     OpenRISC Relocations.

 - : BFD_RELOC_H8_DIR16A8
 - : BFD_RELOC_H8_DIR16R8
 - : BFD_RELOC_H8_DIR24A8
 - : BFD_RELOC_H8_DIR24R8
 - : BFD_RELOC_H8_DIR32A16
     H8 elf Relocations.

 - : BFD_RELOC_XSTORMY16_REL_12
 - : BFD_RELOC_XSTORMY16_24
 - : BFD_RELOC_XSTORMY16_FPTR16
     Sony Xstormy16 Relocations.


     typedef enum bfd_reloc_code_real bfd_reloc_code_real_type;

`bfd_reloc_type_lookup'
.......................

   *Synopsis*
     reloc_howto_type *
     bfd_reloc_type_lookup (bfd *abfd, bfd_reloc_code_real_type code);
   *Description*
Return a pointer to a howto structure which, when invoked, will perform
the relocation CODE on data from the architecture noted.

`bfd_default_reloc_type_lookup'
...............................

   *Synopsis*
     reloc_howto_type *bfd_default_reloc_type_lookup
        (bfd *abfd, bfd_reloc_code_real_type  code);
   *Description*
Provides a default relocation lookup routine for any architecture.

`bfd_get_reloc_code_name'
.........................

   *Synopsis*
     const char *bfd_get_reloc_code_name (bfd_reloc_code_real_type code);
   *Description*
Provides a printable name for the supplied relocation code.  Useful
mainly for printing error messages.

`bfd_generic_relax_section'
...........................

   *Synopsis*
     boolean bfd_generic_relax_section
        (bfd *abfd,
         asection *section,
         struct bfd_link_info *,
         boolean *);
   *Description*
Provides default handling for relaxing for back ends which don't do
relaxing - i.e., does nothing.

`bfd_generic_gc_sections'
.........................

   *Synopsis*
     boolean bfd_generic_gc_sections
        (bfd *, struct bfd_link_info *);
   *Description*
Provides default handling for relaxing for back ends which don't do
section gc - i.e., does nothing.

`bfd_generic_merge_sections'
............................

   *Synopsis*
     boolean bfd_generic_merge_sections
        (bfd *, struct bfd_link_info *);
   *Description*
Provides default handling for SEC_MERGE section merging for back ends
which don't have SEC_MERGE support - i.e., does nothing.

`bfd_generic_get_relocated_section_contents'
............................................

   *Synopsis*
     bfd_byte *
     bfd_generic_get_relocated_section_contents (bfd *abfd,
         struct bfd_link_info *link_info,
         struct bfd_link_order *link_order,
         bfd_byte *data,
         boolean relocateable,
         asymbol **symbols);
   *Description*
Provides default handling of relocation effort for back ends which
can't be bothered to do it efficiently.


File: bfd.info,  Node: Core Files,  Next: Targets,  Prev: Relocations,  Up: BFD front end

Core files
==========

   *Description*
These are functions pertaining to core files.

`bfd_core_file_failing_command'
...............................

   *Synopsis*
     const char *bfd_core_file_failing_command(bfd *abfd);
   *Description*
Return a read-only string explaining which program was running when it
failed and produced the core file ABFD.

`bfd_core_file_failing_signal'
..............................

   *Synopsis*
     int bfd_core_file_failing_signal(bfd *abfd);
   *Description*
Returns the signal number which caused the core dump which generated
the file the BFD ABFD is attached to.

`core_file_matches_executable_p'
................................

   *Synopsis*
     boolean core_file_matches_executable_p
        (bfd *core_bfd, bfd *exec_bfd);
   *Description*
Return `true' if the core file attached to CORE_BFD was generated by a
run of the executable file attached to EXEC_BFD, `false' otherwise.


File: bfd.info,  Node: Targets,  Next: Architectures,  Prev: Core Files,  Up: BFD front end

Targets
=======

   *Description*
Each port of BFD to a different machine requries the creation of a
target back end. All the back end provides to the root part of BFD is a
structure containing pointers to functions which perform certain low
level operations on files. BFD translates the applications's requests
through a pointer into calls to the back end routines.

   When a file is opened with `bfd_openr', its format and target are
unknown. BFD uses various mechanisms to determine how to interpret the
file. The operations performed are:

   * Create a BFD by calling the internal routine `_bfd_new_bfd', then
     call `bfd_find_target' with the target string supplied to
     `bfd_openr' and the new BFD pointer.

   * If a null target string was provided to `bfd_find_target', look up
     the environment variable `GNUTARGET' and use that as the target
     string.

   * If the target string is still `NULL', or the target string is
     `default', then use the first item in the target vector as the
     target type, and set `target_defaulted' in the BFD to cause
     `bfd_check_format' to loop through all the targets.  *Note
     bfd_target::.  *Note Formats::.

   * Otherwise, inspect the elements in the target vector one by one,
     until a match on target name is found. When found, use it.

   * Otherwise return the error `bfd_error_invalid_target' to
     `bfd_openr'.

   * `bfd_openr' attempts to open the file using `bfd_open_file', and
     returns the BFD.
   Once the BFD has been opened and the target selected, the file
format may be determined. This is done by calling `bfd_check_format' on
the BFD with a suggested format.  If `target_defaulted' has been set,
each possible target type is tried to see if it recognizes the
specified format.  `bfd_check_format' returns `true' when the caller
guesses right.

* Menu:

* bfd_target::

@


1.1.6.2
log
@Commit generated files for 2.12.1.
@
text
@d1 1
a1 1
This is bfd.info, produced by makeinfo version 4.1 from bfd.texinfo.
d304 49
a532 49
 - : BFD_RELOC_SH_GOT_LOW16
 - : BFD_RELOC_SH_GOT_MEDLOW16
 - : BFD_RELOC_SH_GOT_MEDHI16
 - : BFD_RELOC_SH_GOT_HI16
 - : BFD_RELOC_SH_GOTPLT_LOW16
 - : BFD_RELOC_SH_GOTPLT_MEDLOW16
 - : BFD_RELOC_SH_GOTPLT_MEDHI16
 - : BFD_RELOC_SH_GOTPLT_HI16
 - : BFD_RELOC_SH_PLT_LOW16
 - : BFD_RELOC_SH_PLT_MEDLOW16
 - : BFD_RELOC_SH_PLT_MEDHI16
 - : BFD_RELOC_SH_PLT_HI16
 - : BFD_RELOC_SH_GOTOFF_LOW16
 - : BFD_RELOC_SH_GOTOFF_MEDLOW16
 - : BFD_RELOC_SH_GOTOFF_MEDHI16
 - : BFD_RELOC_SH_GOTOFF_HI16
 - : BFD_RELOC_SH_GOTPC_LOW16
 - : BFD_RELOC_SH_GOTPC_MEDLOW16
 - : BFD_RELOC_SH_GOTPC_MEDHI16
 - : BFD_RELOC_SH_GOTPC_HI16
 - : BFD_RELOC_SH_COPY64
 - : BFD_RELOC_SH_GLOB_DAT64
 - : BFD_RELOC_SH_JMP_SLOT64
 - : BFD_RELOC_SH_RELATIVE64
 - : BFD_RELOC_SH_GOT10BY4
 - : BFD_RELOC_SH_GOT10BY8
 - : BFD_RELOC_SH_GOTPLT10BY4
 - : BFD_RELOC_SH_GOTPLT10BY8
 - : BFD_RELOC_SH_GOTPLT32
 - : BFD_RELOC_SH_SHMEDIA_CODE
 - : BFD_RELOC_SH_IMMU5
 - : BFD_RELOC_SH_IMMS6
 - : BFD_RELOC_SH_IMMS6BY32
 - : BFD_RELOC_SH_IMMU6
 - : BFD_RELOC_SH_IMMS10
 - : BFD_RELOC_SH_IMMS10BY2
 - : BFD_RELOC_SH_IMMS10BY4
 - : BFD_RELOC_SH_IMMS10BY8
 - : BFD_RELOC_SH_IMMS16
 - : BFD_RELOC_SH_IMMU16
 - : BFD_RELOC_SH_IMM_LOW16
 - : BFD_RELOC_SH_IMM_LOW16_PCREL
 - : BFD_RELOC_SH_IMM_MEDLOW16
 - : BFD_RELOC_SH_IMM_MEDLOW16_PCREL
 - : BFD_RELOC_SH_IMM_MEDHI16
 - : BFD_RELOC_SH_IMM_MEDHI16_PCREL
 - : BFD_RELOC_SH_IMM_HI16
 - : BFD_RELOC_SH_IMM_HI16_PCREL
 - : BFD_RELOC_SH_PT_16
@


1.1.4.1
log
@Add generated files to release branch.
@
text
@a0 1276
This is bfd.info, produced by makeinfo version 4.0 from bfd.texinfo.

START-INFO-DIR-ENTRY
* Bfd: (bfd).                   The Binary File Descriptor library.
END-INFO-DIR-ENTRY

   This file documents the BFD library.

   Copyright (C) 1991, 2000 Free Software Foundation, Inc.

   Permission is granted to copy, distribute and/or modify this document
     under the terms of the GNU Free Documentation License, Version 1.1
     or any later version published by the Free Software Foundation;
   with no Invariant Sections, with no Front-Cover Texts, and with no
    Back-Cover Texts.  A copy of the license is included in the
section entitled "GNU Free Documentation License".


File: bfd.info,  Node: bfd_target,  Prev: Targets,  Up: Targets

bfd_target
----------

   *Description*
This structure contains everything that BFD knows about a target. It
includes things like its byte order, name, and which routines to call
to do various operations.

   Every BFD points to a target structure with its `xvec' member.

   The macros below are used to dispatch to functions through the
`bfd_target' vector. They are used in a number of macros further down
in `bfd.h', and are also used when calling various routines by hand
inside the BFD implementation.  The ARGLIST argument must be
parenthesized; it contains all the arguments to the called function.

   They make the documentation (more) unpleasant to read, so if someone
wants to fix this and not break the above, please do.
     #define BFD_SEND(bfd, message, arglist) \
                    ((*((bfd)->xvec->message)) arglist)
     
     #ifdef DEBUG_BFD_SEND
     #undef BFD_SEND
     #define BFD_SEND(bfd, message, arglist) \
       (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
         ((*((bfd)->xvec->message)) arglist) : \
         (bfd_assert (__FILE__,__LINE__), NULL))
     #endif
   For operations which index on the BFD format:
     #define BFD_SEND_FMT(bfd, message, arglist) \
                 (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist)
     
     #ifdef DEBUG_BFD_SEND
     #undef BFD_SEND_FMT
     #define BFD_SEND_FMT(bfd, message, arglist) \
       (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
        (((bfd)->xvec->message[(int) ((bfd)->format)]) arglist) : \
        (bfd_assert (__FILE__,__LINE__), NULL))
     #endif
   This is the structure which defines the type of BFD this is.  The
`xvec' member of the struct `bfd' itself points here.  Each module that
implements access to a different target under BFD, defines one of these.

   FIXME, these names should be rationalised with the names of the
entry points which call them. Too bad we can't have one macro to define
them both!
     enum bfd_flavour {
       bfd_target_unknown_flavour,
       bfd_target_aout_flavour,
       bfd_target_coff_flavour,
       bfd_target_ecoff_flavour,
       bfd_target_xcoff_flavour,
       bfd_target_elf_flavour,
       bfd_target_ieee_flavour,
       bfd_target_nlm_flavour,
       bfd_target_oasys_flavour,
       bfd_target_tekhex_flavour,
       bfd_target_srec_flavour,
       bfd_target_ihex_flavour,
       bfd_target_som_flavour,
       bfd_target_os9k_flavour,
       bfd_target_versados_flavour,
       bfd_target_msdos_flavour,
       bfd_target_ovax_flavour,
       bfd_target_evax_flavour
     };
     
     enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
     
     /* Forward declaration.  */
     typedef struct bfd_link_info _bfd_link_info;
     
     typedef struct bfd_target
     {
   Identifies the kind of target, e.g., SunOS4, Ultrix, etc.
       char *name;
   The "flavour" of a back end is a general indication about the
contents of a file.
       enum bfd_flavour flavour;
   The order of bytes within the data area of a file.
       enum bfd_endian byteorder;
   The order of bytes within the header parts of a file.
       enum bfd_endian header_byteorder;
   A mask of all the flags which an executable may have set - from the
set `BFD_NO_FLAGS', `HAS_RELOC', ...`D_PAGED'.
       flagword object_flags;
   A mask of all the flags which a section may have set - from the set
`SEC_NO_FLAGS', `SEC_ALLOC', ...`SET_NEVER_LOAD'.
       flagword section_flags;
   The character normally found at the front of a symbol (if any),
perhaps `_'.
       char symbol_leading_char;
   The pad character for file names within an archive header.
       char ar_pad_char;
   The maximum number of characters in an archive header.
       unsigned short ar_max_namelen;
   Entries for byte swapping for data. These are different from the
other entry points, since they don't take a BFD asthe first argument.
Certain other handlers could do the same.
       bfd_vma      (*bfd_getx64) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_getx_signed_64) PARAMS ((const bfd_byte *));
       void         (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
       bfd_vma      (*bfd_getx32) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_getx_signed_32) PARAMS ((const bfd_byte *));
       void         (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
       bfd_vma      (*bfd_getx16) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_getx_signed_16) PARAMS ((const bfd_byte *));
       void         (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));
   Byte swapping for the headers
       bfd_vma      (*bfd_h_getx64) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_h_getx_signed_64) PARAMS ((const bfd_byte *));
       void         (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
       bfd_vma      (*bfd_h_getx32) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_h_getx_signed_32) PARAMS ((const bfd_byte *));
       void         (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
       bfd_vma      (*bfd_h_getx16) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_h_getx_signed_16) PARAMS ((const bfd_byte *));
       void         (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
   Format dependent routines: these are vectors of entry points within
the target vector structure, one for each format to check.

   Check the format of a file being read.  Return a `bfd_target *' or
zero.
       const struct bfd_target *(*_bfd_check_format[bfd_type_end]) PARAMS ((bfd *));
   Set the format of a file being written.
       boolean             (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));
   Write cached information into a file being written, at `bfd_close'.
       boolean             (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));
   The general target vector.  These vectors are initialized using the
BFD_JUMP_TABLE macros.

       /* Generic entry points.  */
     #define BFD_JUMP_TABLE_GENERIC(NAME)\
     CAT(NAME,_close_and_cleanup),\
     CAT(NAME,_bfd_free_cached_info),\
     CAT(NAME,_new_section_hook),\
     CAT(NAME,_get_section_contents),\
     CAT(NAME,_get_section_contents_in_window)
     
       /* Called when the BFD is being closed to do any necessary cleanup.  */
       boolean       (*_close_and_cleanup) PARAMS ((bfd *));
       /* Ask the BFD to free all cached information.  */
       boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
       /* Called when a new section is created.  */
       boolean       (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
       /* Read the contents of a section.  */
       boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
                                                 file_ptr, bfd_size_type));
       boolean       (*_bfd_get_section_contents_in_window)
                               PARAMS ((bfd *, sec_ptr, bfd_window *,
                                        file_ptr, bfd_size_type));
     
       /* Entry points to copy private data.  */
     #define BFD_JUMP_TABLE_COPY(NAME)\
     CAT(NAME,_bfd_copy_private_bfd_data),\
     CAT(NAME,_bfd_merge_private_bfd_data),\
     CAT(NAME,_bfd_copy_private_section_data),\
     CAT(NAME,_bfd_copy_private_symbol_data),\
     CAT(NAME,_bfd_set_private_flags),\
     CAT(NAME,_bfd_print_private_bfd_data)\
       /* Called to copy BFD general private data from one object file
          to another.  */
       boolean       (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
       /* Called to merge BFD general private data from one object file
          to a common output file when linking.  */
       boolean       (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
       /* Called to copy BFD private section data from one object file
          to another.  */
       boolean       (*_bfd_copy_private_section_data) PARAMS ((bfd *, sec_ptr,
                                                            bfd *, sec_ptr));
       /* Called to copy BFD private symbol data from one symbol
          to another.  */
       boolean       (*_bfd_copy_private_symbol_data) PARAMS ((bfd *, asymbol *,
                                                               bfd *, asymbol *));
       /* Called to set private backend flags */
       boolean       (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
     
       /* Called to print private BFD data */
       boolean       (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
     
       /* Core file entry points.  */
     #define BFD_JUMP_TABLE_CORE(NAME)\
     CAT(NAME,_core_file_failing_command),\
     CAT(NAME,_core_file_failing_signal),\
     CAT(NAME,_core_file_matches_executable_p)
       char *   (*_core_file_failing_command) PARAMS ((bfd *));
       int      (*_core_file_failing_signal) PARAMS ((bfd *));
       boolean  (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
     
       /* Archive entry points.  */
     #define BFD_JUMP_TABLE_ARCHIVE(NAME)\
     CAT(NAME,_slurp_armap),\
     CAT(NAME,_slurp_extended_name_table),\
     CAT(NAME,_construct_extended_name_table),\
     CAT(NAME,_truncate_arname),\
     CAT(NAME,_write_armap),\
     CAT(NAME,_read_ar_hdr),\
     CAT(NAME,_openr_next_archived_file),\
     CAT(NAME,_get_elt_at_index),\
     CAT(NAME,_generic_stat_arch_elt),\
     CAT(NAME,_update_armap_timestamp)
       boolean  (*_bfd_slurp_armap) PARAMS ((bfd *));
       boolean  (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
       boolean  (*_bfd_construct_extended_name_table)
                  PARAMS ((bfd *, char **, bfd_size_type *, const char **));
       void     (*_bfd_truncate_arname) PARAMS ((bfd *, CONST char *, char *));
       boolean  (*write_armap) PARAMS ((bfd *arch,
                                   unsigned int elength,
                                   struct orl *map,
                                   unsigned int orl_count,
                                   int stridx));
       PTR (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
       bfd *    (*openr_next_archived_file) PARAMS ((bfd *arch, bfd *prev));
     #define bfd_get_elt_at_index(b,i) BFD_SEND(b, _bfd_get_elt_at_index, (b,i))
       bfd *    (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
       int      (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
       boolean  (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
     
       /* Entry points used for symbols.  */
     #define BFD_JUMP_TABLE_SYMBOLS(NAME)\
     CAT(NAME,_get_symtab_upper_bound),\
     CAT(NAME,_get_symtab),\
     CAT(NAME,_make_empty_symbol),\
     CAT(NAME,_print_symbol),\
     CAT(NAME,_get_symbol_info),\
     CAT(NAME,_bfd_is_local_label_name),\
     CAT(NAME,_get_lineno),\
     CAT(NAME,_find_nearest_line),\
     CAT(NAME,_bfd_make_debug_symbol),\
     CAT(NAME,_read_minisymbols),\
     CAT(NAME,_minisymbol_to_symbol)
       long  (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
       long  (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
                                                  struct symbol_cache_entry **));
       struct symbol_cache_entry  *
                     (*_bfd_make_empty_symbol) PARAMS ((bfd *));
       void          (*_bfd_print_symbol) PARAMS ((bfd *, PTR,
                                           struct symbol_cache_entry *,
                                           bfd_print_symbol_type));
     #define bfd_print_symbol(b,p,s,e) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e))
       void          (*_bfd_get_symbol_info) PARAMS ((bfd *,
                                           struct symbol_cache_entry *,
                                           symbol_info *));
     #define bfd_get_symbol_info(b,p,e) BFD_SEND(b, _bfd_get_symbol_info, (b,p,e))
       boolean       (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
     
       alent *    (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
       boolean    (*_bfd_find_nearest_line) PARAMS ((bfd *abfd,
                         struct sec *section, struct symbol_cache_entry **symbols,
                         bfd_vma offset, CONST char **file, CONST char **func,
                         unsigned int *line));
      /* Back-door to allow format-aware applications to create debug symbols
         while using BFD for everything else.  Currently used by the assembler
         when creating COFF files.  */
       asymbol *  (*_bfd_make_debug_symbol) PARAMS ((
            bfd *abfd,
            void *ptr,
            unsigned long size));
     #define bfd_read_minisymbols(b, d, m, s) \
       BFD_SEND (b, _read_minisymbols, (b, d, m, s))
       long  (*_read_minisymbols) PARAMS ((bfd *, boolean, PTR *,
                                           unsigned int *));
     #define bfd_minisymbol_to_symbol(b, d, m, f) \
       BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
       asymbol *(*_minisymbol_to_symbol) PARAMS ((bfd *, boolean, const PTR,
                                                  asymbol *));
     
       /* Routines for relocs.  */
     #define BFD_JUMP_TABLE_RELOCS(NAME)\
     CAT(NAME,_get_reloc_upper_bound),\
     CAT(NAME,_canonicalize_reloc),\
     CAT(NAME,_bfd_reloc_type_lookup)
       long  (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
       long  (*_bfd_canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **,
                                                 struct symbol_cache_entry **));
       /* See documentation on reloc types.  */
       reloc_howto_type *
            (*reloc_type_lookup) PARAMS ((bfd *abfd,
                                          bfd_reloc_code_real_type code));
     
       /* Routines used when writing an object file.  */
     #define BFD_JUMP_TABLE_WRITE(NAME)\
     CAT(NAME,_set_arch_mach),\
     CAT(NAME,_set_section_contents)
       boolean    (*_bfd_set_arch_mach) PARAMS ((bfd *, enum bfd_architecture,
                         unsigned long));
       boolean       (*_bfd_set_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
                                                 file_ptr, bfd_size_type));
     
       /* Routines used by the linker.  */
     #define BFD_JUMP_TABLE_LINK(NAME)\
     CAT(NAME,_sizeof_headers),\
     CAT(NAME,_bfd_get_relocated_section_contents),\
     CAT(NAME,_bfd_relax_section),\
     CAT(NAME,_bfd_link_hash_table_create),\
     CAT(NAME,_bfd_link_add_symbols),\
     CAT(NAME,_bfd_final_link),\
     CAT(NAME,_bfd_link_split_section),\
     CAT(NAME,_bfd_gc_sections)
       int        (*_bfd_sizeof_headers) PARAMS ((bfd *, boolean));
       bfd_byte * (*_bfd_get_relocated_section_contents) PARAMS ((bfd *,
                         struct bfd_link_info *, struct bfd_link_order *,
                         bfd_byte *data, boolean relocateable,
                         struct symbol_cache_entry **));
     
       boolean    (*_bfd_relax_section) PARAMS ((bfd *, struct sec *,
                         struct bfd_link_info *, boolean *again));
     
       /* Create a hash table for the linker.  Different backends store
          different information in this table.  */
       struct bfd_link_hash_table *(*_bfd_link_hash_table_create) PARAMS ((bfd *));
     
       /* Add symbols from this object file into the hash table.  */
       boolean (*_bfd_link_add_symbols) PARAMS ((bfd *, struct bfd_link_info *));
     
       /* Do a link based on the link_order structures attached to each
          section of the BFD.  */
       boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
     
       /* Should this section be split up into smaller pieces during linking.  */
       boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
     
       /* Remove sections that are not referenced from the output.  */
       boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
     
       /* Routines to handle dynamic symbols and relocs.  */
     #define BFD_JUMP_TABLE_DYNAMIC(NAME)\
     CAT(NAME,_get_dynamic_symtab_upper_bound),\
     CAT(NAME,_canonicalize_dynamic_symtab),\
     CAT(NAME,_get_dynamic_reloc_upper_bound),\
     CAT(NAME,_canonicalize_dynamic_reloc)
       /* Get the amount of memory required to hold the dynamic symbols. */
       long  (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
       /* Read in the dynamic symbols.  */
       long  (*_bfd_canonicalize_dynamic_symtab)
         PARAMS ((bfd *, struct symbol_cache_entry **));
       /* Get the amount of memory required to hold the dynamic relocs.  */
       long  (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
       /* Read in the dynamic relocs.  */
       long  (*_bfd_canonicalize_dynamic_reloc)
         PARAMS ((bfd *, arelent **, struct symbol_cache_entry **));
   A pointer to an alternative bfd_target in case the current one is not
satisfactory.  This can happen when the target cpu supports both big
and little endian code, and target chosen by the linker has the wrong
endianness.  The function open_output() in ld/ldlang.c uses this field
to find an alternative output format that is suitable.
      /* Opposite endian version of this target.  */
      const struct bfd_target * alternative_target;
   Data for use by back-end routines, which isn't generic enough to
belong in this structure.
      PTR backend_data;
     
     } bfd_target;

`bfd_set_default_target'
........................

   *Synopsis*
     boolean bfd_set_default_target (const char *name);
   *Description*
Set the default target vector to use when recognizing a BFD.  This
takes the name of the target, which may be a BFD target name or a
configuration triplet.

`bfd_find_target'
.................

   *Synopsis*
     const bfd_target *bfd_find_target(CONST char *target_name, bfd *abfd);
   *Description*
Return a pointer to the transfer vector for the object target named
TARGET_NAME.  If TARGET_NAME is `NULL', choose the one in the
environment variable `GNUTARGET'; if that is null or not defined, then
choose the first entry in the target list.  Passing in the string
"default" or setting the environment variable to "default" will cause
the first entry in the target list to be returned, and
"target_defaulted" will be set in the BFD.  This causes
`bfd_check_format' to loop over all the targets to find the one that
matches the file being read.

`bfd_target_list'
.................

   *Synopsis*
     const char **bfd_target_list(void);
   *Description*
Return a freshly malloced NULL-terminated vector of the names of all
the valid BFD targets. Do not modify the names.

`bfd_seach_for_target'
......................

   *Synopsis*
     const bfd_target * bfd_search_for_target (int (* search_func) (const bfd_target *, void *), void *);
   *Description*
Return a pointer to the first transfer vector in the list of transfer
vectors maintained by BFD that produces a non-zero result when passed
to the function SEARCH_FUNC.  The parameter DATA is passed, unexamined,
to the search function.


File: bfd.info,  Node: Architectures,  Next: Opening and Closing,  Prev: Targets,  Up: BFD front end

Architectures
=============

   BFD keeps one atom in a BFD describing the architecture of the data
attached to the BFD: a pointer to a `bfd_arch_info_type'.

   Pointers to structures can be requested independently of a BFD so
that an architecture's information can be interrogated without access
to an open BFD.

   The architecture information is provided by each architecture
package.  The set of default architectures is selected by the macro
`SELECT_ARCHITECTURES'.  This is normally set up in the
`config/TARGET.mt' file of your choice.  If the name is not defined,
then all the architectures supported are included.

   When BFD starts up, all the architectures are called with an
initialize method.  It is up to the architecture back end to insert as
many items into the list of architectures as it wants to; generally
this would be one for each machine and one for the default case (an
item with a machine field of 0).

   BFD's idea of an architecture is implemented in `archures.c'.

bfd_architecture
----------------

   *Description*
This enum gives the object file's CPU architecture, in a global
sense--i.e., what processor family does it belong to?  Another field
indicates which processor within the family is in use.  The machine
gives a number which distinguishes different versions of the
architecture, containing, for example, 2 and 3 for Intel i960 KA and
i960 KB, and 68020 and 68030 for Motorola 68020 and 68030.
     enum bfd_architecture
     {
       bfd_arch_unknown,   /* File arch not known */
       bfd_arch_obscure,   /* Arch known, not one of these */
       bfd_arch_m68k,      /* Motorola 68xxx */
     #define bfd_mach_m68000 1
     #define bfd_mach_m68008 2
     #define bfd_mach_m68010 3
     #define bfd_mach_m68020 4
     #define bfd_mach_m68030 5
     #define bfd_mach_m68040 6
     #define bfd_mach_m68060 7
     #define bfd_mach_cpu32  8
       bfd_arch_vax,       /* DEC Vax */
       bfd_arch_i960,      /* Intel 960 */
         /* The order of the following is important.
            lower number indicates a machine type that
            only accepts a subset of the instructions
            available to machines with higher numbers.
            The exception is the "ca", which is
            incompatible with all other machines except
            "core". */
     
     #define bfd_mach_i960_core      1
     #define bfd_mach_i960_ka_sa     2
     #define bfd_mach_i960_kb_sb     3
     #define bfd_mach_i960_mc        4
     #define bfd_mach_i960_xa        5
     #define bfd_mach_i960_ca        6
     #define bfd_mach_i960_jx        7
     #define bfd_mach_i960_hx        8
     
       bfd_arch_a29k,      /* AMD 29000 */
       bfd_arch_sparc,     /* SPARC */
     #define bfd_mach_sparc                 1
     /* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
     #define bfd_mach_sparc_sparclet        2
     #define bfd_mach_sparc_sparclite       3
     #define bfd_mach_sparc_v8plus          4
     #define bfd_mach_sparc_v8plusa         5 /* with ultrasparc add'ns */
     #define bfd_mach_sparc_sparclite_le    6
     #define bfd_mach_sparc_v9              7
     #define bfd_mach_sparc_v9a             8 /* with ultrasparc add'ns */
     #define bfd_mach_sparc_v8plusb         9 /* with cheetah add'ns */
     #define bfd_mach_sparc_v9b             10 /* with cheetah add'ns */
     /* Nonzero if MACH has the v9 instruction set.  */
     #define bfd_mach_sparc_v9_p(mach) \
       ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9b \
        && (mach) != bfd_mach_sparc_sparclite_le)
       bfd_arch_mips,      /* MIPS Rxxxx */
     #define bfd_mach_mips3000              3000
     #define bfd_mach_mips3900              3900
     #define bfd_mach_mips4000              4000
     #define bfd_mach_mips4010              4010
     #define bfd_mach_mips4100              4100
     #define bfd_mach_mips4111              4111
     #define bfd_mach_mips4300              4300
     #define bfd_mach_mips4400              4400
     #define bfd_mach_mips4600              4600
     #define bfd_mach_mips4650              4650
     #define bfd_mach_mips5000              5000
     #define bfd_mach_mips6000              6000
     #define bfd_mach_mips8000              8000
     #define bfd_mach_mips10000             10000
     #define bfd_mach_mips16                16
     #define bfd_mach_mips32                32
     #define bfd_mach_mips32_4k             3204113 /* 32, 04, octal 'K' */
     #define bfd_mach_mips5                 5
     #define bfd_mach_mips64                64
     #define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
       bfd_arch_i386,      /* Intel 386 */
     #define bfd_mach_i386_i386 0
     #define bfd_mach_i386_i8086 1
     #define bfd_mach_i386_i386_intel_syntax 2
     #define bfd_mach_x86_64 3
     #define bfd_mach_x86_64_intel_syntax 4
       bfd_arch_we32k,     /* AT&T WE32xxx */
       bfd_arch_tahoe,     /* CCI/Harris Tahoe */
       bfd_arch_i860,      /* Intel 860 */
       bfd_arch_i370,      /* IBM 360/370 Mainframes */
       bfd_arch_romp,      /* IBM ROMP PC/RT */
       bfd_arch_alliant,   /* Alliant */
       bfd_arch_convex,    /* Convex */
       bfd_arch_m88k,      /* Motorola 88xxx */
       bfd_arch_pyramid,   /* Pyramid Technology */
       bfd_arch_h8300,     /* Hitachi H8/300 */
     #define bfd_mach_h8300   1
     #define bfd_mach_h8300h  2
     #define bfd_mach_h8300s  3
       bfd_arch_powerpc,   /* PowerPC */
     #define bfd_mach_ppc           0
     #define bfd_mach_ppc_403       403
     #define bfd_mach_ppc_403gc     4030
     #define bfd_mach_ppc_505       505
     #define bfd_mach_ppc_601       601
     #define bfd_mach_ppc_602       602
     #define bfd_mach_ppc_603       603
     #define bfd_mach_ppc_ec603e    6031
     #define bfd_mach_ppc_604       604
     #define bfd_mach_ppc_620       620
     #define bfd_mach_ppc_630       630
     #define bfd_mach_ppc_750       750
     #define bfd_mach_ppc_860       860
     #define bfd_mach_ppc_a35       35
     #define bfd_mach_ppc_rs64ii    642
     #define bfd_mach_ppc_rs64iii   643
     #define bfd_mach_ppc_7400      7400
       bfd_arch_rs6000,    /* IBM RS/6000 */
     #define bfd_mach_rs6k          0
     #define bfd_mach_rs6k_rs1      6001
     #define bfd_mach_rs6k_rsc      6003
     #define bfd_mach_rs6k_rs2      6002
       bfd_arch_hppa,      /* HP PA RISC */
       bfd_arch_d10v,      /* Mitsubishi D10V */
     #define bfd_mach_d10v          0
     #define bfd_mach_d10v_ts2      2
     #define bfd_mach_d10v_ts3      3
       bfd_arch_d30v,      /* Mitsubishi D30V */
       bfd_arch_m68hc11,   /* Motorola 68HC11 */
       bfd_arch_m68hc12,   /* Motorola 68HC12 */
       bfd_arch_z8k,       /* Zilog Z8000 */
     #define bfd_mach_z8001         1
     #define bfd_mach_z8002         2
       bfd_arch_h8500,     /* Hitachi H8/500 */
       bfd_arch_sh,        /* Hitachi SH */
     #define bfd_mach_sh            0
     #define bfd_mach_sh2        0x20
     #define bfd_mach_sh_dsp     0x2d
     #define bfd_mach_sh3        0x30
     #define bfd_mach_sh3_dsp    0x3d
     #define bfd_mach_sh3e       0x3e
     #define bfd_mach_sh4        0x40
       bfd_arch_alpha,     /* Dec Alpha */
     #define bfd_mach_alpha_ev4  0x10
     #define bfd_mach_alpha_ev5  0x20
     #define bfd_mach_alpha_ev6  0x30
       bfd_arch_arm,       /* Advanced Risc Machines ARM */
     #define bfd_mach_arm_2         1
     #define bfd_mach_arm_2a        2
     #define bfd_mach_arm_3         3
     #define bfd_mach_arm_3M        4
     #define bfd_mach_arm_4         5
     #define bfd_mach_arm_4T        6
     #define bfd_mach_arm_5         7
     #define bfd_mach_arm_5T        8
     #define bfd_mach_arm_5TE       9
     #define bfd_mach_arm_XScale    10
       bfd_arch_ns32k,     /* National Semiconductors ns32000 */
       bfd_arch_w65,       /* WDC 65816 */
       bfd_arch_tic30,     /* Texas Instruments TMS320C30 */
       bfd_arch_tic54x,    /* Texas Instruments TMS320C54X */
       bfd_arch_tic80,     /* TI TMS320c80 (MVP) */
       bfd_arch_v850,      /* NEC V850 */
     #define bfd_mach_v850          0
     #define bfd_mach_v850e         'E'
     #define bfd_mach_v850ea        'A'
       bfd_arch_arc,       /* ARC Cores */
     #define bfd_mach_arc_5         0
     #define bfd_mach_arc_6         1
     #define bfd_mach_arc_7         2
     #define bfd_mach_arc_8         3
       bfd_arch_m32r,      /* Mitsubishi M32R/D */
     #define bfd_mach_m32r          0 /* backwards compatibility */
     #define bfd_mach_m32rx         'x'
       bfd_arch_mn10200,   /* Matsushita MN10200 */
       bfd_arch_mn10300,   /* Matsushita MN10300 */
     #define bfd_mach_mn10300               300
     #define bfd_mach_am33          330
       bfd_arch_fr30,
     #define bfd_mach_fr30          0x46523330
       bfd_arch_mcore,
       bfd_arch_ia64,      /* HP/Intel ia64 */
     #define bfd_mach_ia64_elf64    0
     #define bfd_mach_ia64_elf32    1
       bfd_arch_pj,
       bfd_arch_avr,       /* Atmel AVR microcontrollers */
     #define bfd_mach_avr1          1
     #define bfd_mach_avr2          2
     #define bfd_mach_avr3          3
     #define bfd_mach_avr4          4
     #define bfd_mach_avr5          5
       bfd_arch_cris,      /* Axis CRIS */
       bfd_arch_last
       };

bfd_arch_info
-------------

   *Description*
This structure contains information on architectures for use within BFD.

     typedef struct bfd_arch_info
     {
       int bits_per_word;
       int bits_per_address;
       int bits_per_byte;
       enum bfd_architecture arch;
       unsigned long mach;
       const char *arch_name;
       const char *printable_name;
       unsigned int section_align_power;
       /* True if this is the default machine for the architecture.  */
       boolean the_default;
       const struct bfd_arch_info * (*compatible)
            PARAMS ((const struct bfd_arch_info *a,
                     const struct bfd_arch_info *b));
     
       boolean (*scan) PARAMS ((const struct bfd_arch_info *, const char *));
     
       const struct bfd_arch_info *next;
     } bfd_arch_info_type;

`bfd_printable_name'
....................

   *Synopsis*
     const char *bfd_printable_name(bfd *abfd);
   *Description*
Return a printable string representing the architecture and machine
from the pointer to the architecture info structure.

`bfd_scan_arch'
...............

   *Synopsis*
     const bfd_arch_info_type *bfd_scan_arch(const char *string);
   *Description*
Figure out if BFD supports any cpu which could be described with the
name STRING.  Return a pointer to an `arch_info' structure if a machine
is found, otherwise NULL.

`bfd_arch_list'
...............

   *Synopsis*
     const char **bfd_arch_list(void);
   *Description*
Return a freshly malloced NULL-terminated vector of the names of all
the valid BFD architectures.  Do not modify the names.

`bfd_arch_get_compatible'
.........................

   *Synopsis*
     const bfd_arch_info_type *bfd_arch_get_compatible(
         const bfd *abfd,
         const bfd *bbfd);
   *Description*
Determine whether two BFDs' architectures and machine types are
compatible.  Calculates the lowest common denominator between the two
architectures and machine types implied by the BFDs and returns a
pointer to an `arch_info' structure describing the compatible machine.

`bfd_default_arch_struct'
.........................

   *Description*
The `bfd_default_arch_struct' is an item of `bfd_arch_info_type' which
has been initialized to a fairly generic state.  A BFD starts life by
pointing to this structure, until the correct back end has determined
the real architecture of the file.
     extern const bfd_arch_info_type bfd_default_arch_struct;

`bfd_set_arch_info'
...................

   *Synopsis*
     void bfd_set_arch_info(bfd *abfd, const bfd_arch_info_type *arg);
   *Description*
Set the architecture info of ABFD to ARG.

`bfd_default_set_arch_mach'
...........................

   *Synopsis*
     boolean bfd_default_set_arch_mach(bfd *abfd,
         enum bfd_architecture arch,
         unsigned long mach);
   *Description*
Set the architecture and machine type in BFD ABFD to ARCH and MACH.
Find the correct pointer to a structure and insert it into the
`arch_info' pointer.

`bfd_get_arch'
..............

   *Synopsis*
     enum bfd_architecture bfd_get_arch(bfd *abfd);
   *Description*
Return the enumerated type which describes the BFD ABFD's architecture.

`bfd_get_mach'
..............

   *Synopsis*
     unsigned long bfd_get_mach(bfd *abfd);
   *Description*
Return the long type which describes the BFD ABFD's machine.

`bfd_arch_bits_per_byte'
........................

   *Synopsis*
     unsigned int bfd_arch_bits_per_byte(bfd *abfd);
   *Description*
Return the number of bits in one of the BFD ABFD's architecture's bytes.

`bfd_arch_bits_per_address'
...........................

   *Synopsis*
     unsigned int bfd_arch_bits_per_address(bfd *abfd);
   *Description*
Return the number of bits in one of the BFD ABFD's architecture's
addresses.

`bfd_default_compatible'
........................

   *Synopsis*
     const bfd_arch_info_type *bfd_default_compatible
        (const bfd_arch_info_type *a,
         const bfd_arch_info_type *b);
   *Description*
The default function for testing for compatibility.

`bfd_default_scan'
..................

   *Synopsis*
     boolean bfd_default_scan(const struct bfd_arch_info *info, const char *string);
   *Description*
The default function for working out whether this is an architecture
hit and a machine hit.

`bfd_get_arch_info'
...................

   *Synopsis*
     const bfd_arch_info_type * bfd_get_arch_info(bfd *abfd);
   *Description*
Return the architecture info struct in ABFD.

`bfd_lookup_arch'
.................

   *Synopsis*
     const bfd_arch_info_type *bfd_lookup_arch
        (enum bfd_architecture
         arch,
         unsigned long machine);
   *Description*
Look for the architecure info structure which matches the arguments
ARCH and MACHINE. A machine of 0 matches the machine/architecture
structure which marks itself as the default.

`bfd_printable_arch_mach'
.........................

   *Synopsis*
     const char *bfd_printable_arch_mach
        (enum bfd_architecture arch, unsigned long machine);
   *Description*
Return a printable string representing the architecture and machine
type.

   This routine is depreciated.

`bfd_octets_per_byte'
.....................

   *Synopsis*
     unsigned int bfd_octets_per_byte(bfd *abfd);
   *Description*
Return the number of octets (8-bit quantities) per target byte (minimum
addressable unit).  In most cases, this will be one, but some DSP
targets have 16, 32, or even 48 bits per byte.

`bfd_arch_mach_octets_per_byte'
...............................

   *Synopsis*
     unsigned int bfd_arch_mach_octets_per_byte(enum bfd_architecture arch,
         unsigned long machine);
   *Description*
See bfd_octets_per_byte.

   This routine is provided for those cases where a bfd * is not
available


File: bfd.info,  Node: Opening and Closing,  Next: Internal,  Prev: Architectures,  Up: BFD front end

Opening and closing BFDs
========================

`bfd_openr'
...........

   *Synopsis*
     bfd *bfd_openr(CONST char *filename, CONST char *target);
   *Description*
Open the file FILENAME (using `fopen') with the target TARGET.  Return
a pointer to the created BFD.

   Calls `bfd_find_target', so TARGET is interpreted as by that
function.

   If `NULL' is returned then an error has occured.   Possible errors
are `bfd_error_no_memory', `bfd_error_invalid_target' or `system_call'
error.

`bfd_fdopenr'
.............

   *Synopsis*
     bfd *bfd_fdopenr(CONST char *filename, CONST char *target, int fd);
   *Description*
`bfd_fdopenr' is to `bfd_fopenr' much like `fdopen' is to `fopen'.  It
opens a BFD on a file already described by the FD supplied.

   When the file is later `bfd_close'd, the file descriptor will be
closed.

   If the caller desires that this file descriptor be cached by BFD
(opened as needed, closed as needed to free descriptors for other
opens), with the supplied FD used as an initial file descriptor (but
subject to closure at any time), call bfd_set_cacheable(bfd, 1) on the
returned BFD.  The default is to assume no cacheing; the file
descriptor will remain open until `bfd_close', and will not be affected
by BFD operations on other files.

   Possible errors are `bfd_error_no_memory',
`bfd_error_invalid_target' and `bfd_error_system_call'.

`bfd_openstreamr'
.................

   *Synopsis*
     bfd *bfd_openstreamr(const char *, const char *, PTR);
   *Description*
Open a BFD for read access on an existing stdio stream.  When the BFD
is passed to `bfd_close', the stream will be closed.

`bfd_openw'
...........

   *Synopsis*
     bfd *bfd_openw(CONST char *filename, CONST char *target);
   *Description*
Create a BFD, associated with file FILENAME, using the file format
TARGET, and return a pointer to it.

   Possible errors are `bfd_error_system_call', `bfd_error_no_memory',
`bfd_error_invalid_target'.

`bfd_close'
...........

   *Synopsis*
     boolean bfd_close(bfd *abfd);
   *Description*
Close a BFD. If the BFD was open for writing, then pending operations
are completed and the file written out and closed. If the created file
is executable, then `chmod' is called to mark it as such.

   All memory attached to the BFD is released.

   The file descriptor associated with the BFD is closed (even if it
was passed in to BFD by `bfd_fdopenr').

   *Returns*
`true' is returned if all is ok, otherwise `false'.

`bfd_close_all_done'
....................

   *Synopsis*
     boolean bfd_close_all_done(bfd *);
   *Description*
Close a BFD.  Differs from `bfd_close' since it does not complete any
pending operations.  This routine would be used if the application had
just used BFD for swapping and didn't want to use any of the writing
code.

   If the created file is executable, then `chmod' is called to mark it
as such.

   All memory attached to the BFD is released.

   *Returns*
`true' is returned if all is ok, otherwise `false'.

`bfd_create'
............

   *Synopsis*
     bfd *bfd_create(CONST char *filename, bfd *templ);
   *Description*
Create a new BFD in the manner of `bfd_openw', but without opening a
file. The new BFD takes the target from the target used by TEMPLATE. The
format is always set to `bfd_object'.

`bfd_make_writable'
...................

   *Synopsis*
     boolean bfd_make_writable(bfd *abfd);
   *Description*
Takes a BFD as created by `bfd_create' and converts it into one like as
returned by `bfd_openw'.  It does this by converting the BFD to
BFD_IN_MEMORY.  It's assumed that you will call `bfd_make_readable' on
this bfd later.

   *Returns*
`true' is returned if all is ok, otherwise `false'.

`bfd_make_readable'
...................

   *Synopsis*
     boolean bfd_make_readable(bfd *abfd);
   *Description*
Takes a BFD as created by `bfd_create' and `bfd_make_writable' and
converts it into one like as returned by `bfd_openr'.  It does this by
writing the contents out to the memory buffer, then reversing the
direction.

   *Returns*
`true' is returned if all is ok, otherwise `false'.

`bfd_alloc'
...........

   *Synopsis*
     PTR bfd_alloc (bfd *abfd, size_t wanted);
   *Description*
Allocate a block of WANTED bytes of memory attached to `abfd' and
return a pointer to it.


File: bfd.info,  Node: Internal,  Next: File Caching,  Prev: Opening and Closing,  Up: BFD front end

Internal functions
==================

   *Description*
These routines are used within BFD.  They are not intended for export,
but are documented here for completeness.

`bfd_write_bigendian_4byte_int'
...............................

   *Synopsis*
     void bfd_write_bigendian_4byte_int(bfd *abfd,  int i);
   *Description*
Write a 4 byte integer I to the output BFD ABFD, in big endian order
regardless of what else is going on.  This is useful in archives.

`bfd_put_size'
..............

`bfd_get_size'
..............

   *Description*
These macros as used for reading and writing raw data in sections; each
access (except for bytes) is vectored through the target format of the
BFD and mangled accordingly. The mangling performs any necessary endian
translations and removes alignment restrictions.  Note that types
accepted and returned by these macros are identical so they can be
swapped around in macros--for example, `libaout.h' defines `GET_WORD'
to either `bfd_get_32' or `bfd_get_64'.

   In the put routines, VAL must be a `bfd_vma'.  If we are on a system
without prototypes, the caller is responsible for making sure that is
true, with a cast if necessary.  We don't cast them in the macro
definitions because that would prevent `lint' or `gcc -Wall' from
detecting sins such as passing a pointer.  To detect calling these with
less than a `bfd_vma', use `gcc -Wconversion' on a host with 64 bit
`bfd_vma''s.

     /* Byte swapping macros for user section data.  */
     
     #define bfd_put_8(abfd, val, ptr) \
                     ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
     #define bfd_put_signed_8 \
                    bfd_put_8
     #define bfd_get_8(abfd, ptr) \
                     (*(unsigned char *) (ptr))
     #define bfd_get_signed_8(abfd, ptr) \
                    ((*(unsigned char *) (ptr) ^ 0x80) - 0x80)
     
     #define bfd_put_16(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
     #define bfd_put_signed_16 \
                     bfd_put_16
     #define bfd_get_16(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx16, (ptr))
     #define bfd_get_signed_16(abfd, ptr) \
                     BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
     
     #define bfd_put_32(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
     #define bfd_put_signed_32 \
                     bfd_put_32
     #define bfd_get_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx32, (ptr))
     #define bfd_get_signed_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx_signed_32, (ptr))
     
     #define bfd_put_64(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
     #define bfd_put_signed_64 \
                     bfd_put_64
     #define bfd_get_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx64, (ptr))
     #define bfd_get_signed_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx_signed_64, (ptr))
     
     #define bfd_get(bits, abfd, ptr)                               \
                     ((bits) == 8 ? bfd_get_8 (abfd, ptr)           \
                     : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
                     : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
                     : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
                     : (abort (), (bfd_vma) - 1))
     
     #define bfd_put(bits, abfd, val, ptr)                          \
                     ((bits) == 8 ? bfd_put_8 (abfd, val, ptr)      \
                     : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
                     : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
                     : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
                     : (abort (), (void) 0))

`bfd_h_put_size'
................

   *Description*
These macros have the same function as their `bfd_get_x' bretheren,
except that they are used for removing information for the header
records of object files. Believe it or not, some object files keep
their header records in big endian order and their data in little
endian order.

     /* Byte swapping macros for file header data.  */
     
     #define bfd_h_put_8(abfd, val, ptr) \
                    bfd_put_8 (abfd, val, ptr)
     #define bfd_h_put_signed_8(abfd, val, ptr) \
                    bfd_put_8 (abfd, val, ptr)
     #define bfd_h_get_8(abfd, ptr) \
                    bfd_get_8 (abfd, ptr)
     #define bfd_h_get_signed_8(abfd, ptr) \
                    bfd_get_signed_8 (abfd, ptr)
     
     #define bfd_h_put_16(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_h_putx16,(val,ptr))
     #define bfd_h_put_signed_16 \
                     bfd_h_put_16
     #define bfd_h_get_16(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx16,(ptr))
     #define bfd_h_get_signed_16(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr))
     
     #define bfd_h_put_32(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_h_putx32,(val,ptr))
     #define bfd_h_put_signed_32 \
                     bfd_h_put_32
     #define bfd_h_get_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx32,(ptr))
     #define bfd_h_get_signed_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr))
     
     #define bfd_h_put_64(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_h_putx64,(val, ptr))
     #define bfd_h_put_signed_64 \
                     bfd_h_put_64
     #define bfd_h_get_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx64,(ptr))
     #define bfd_h_get_signed_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr))

`bfd_log2'
..........

   *Synopsis*
     unsigned int bfd_log2(bfd_vma x);
   *Description*
Return the log base 2 of the value supplied, rounded up.  E.g., an X of
1025 returns 11.


File: bfd.info,  Node: File Caching,  Next: Linker Functions,  Prev: Internal,  Up: BFD front end

File caching
============

   The file caching mechanism is embedded within BFD and allows the
application to open as many BFDs as it wants without regard to the
underlying operating system's file descriptor limit (often as low as 20
open files).  The module in `cache.c' maintains a least recently used
list of `BFD_CACHE_MAX_OPEN' files, and exports the name
`bfd_cache_lookup', which runs around and makes sure that the required
BFD is open. If not, then it chooses a file to close, closes it and
opens the one wanted, returning its file handle.

`BFD_CACHE_MAX_OPEN macro'
..........................

   *Description*
The maximum number of files which the cache will keep open at one time.
     #define BFD_CACHE_MAX_OPEN 10

`bfd_last_cache'
................

   *Synopsis*
     extern bfd *bfd_last_cache;
   *Description*
Zero, or a pointer to the topmost BFD on the chain.  This is used by
the `bfd_cache_lookup' macro in `libbfd.h' to determine when it can
avoid a function call.

`bfd_cache_lookup'
..................

   *Description*
Check to see if the required BFD is the same as the last one looked up.
If so, then it can use the stream in the BFD with impunity, since it
can't have changed since the last lookup; otherwise, it has to perform
the complicated lookup function.
     #define bfd_cache_lookup(x) \
         ((x)==bfd_last_cache? \
           (FILE*) (bfd_last_cache->iostream): \
            bfd_cache_lookup_worker(x))

`bfd_cache_init'
................

   *Synopsis*
     boolean bfd_cache_init (bfd *abfd);
   *Description*
Add a newly opened BFD to the cache.

`bfd_cache_close'
.................

   *Synopsis*
     boolean bfd_cache_close (bfd *abfd);
   *Description*
Remove the BFD ABFD from the cache. If the attached file is open, then
close it too.

   *Returns*
`false' is returned if closing the file fails, `true' is returned if
all is well.

`bfd_open_file'
...............

   *Synopsis*
     FILE* bfd_open_file(bfd *abfd);
   *Description*
Call the OS to open a file for ABFD.  Return the `FILE *' (possibly
`NULL') that results from this operation.  Set up the BFD so that
future accesses know the file is open. If the `FILE *' returned is
`NULL', then it won't have been put in the cache, so it won't have to
be removed from it.

`bfd_cache_lookup_worker'
.........................

   *Synopsis*
     FILE *bfd_cache_lookup_worker(bfd *abfd);
   *Description*
Called when the macro `bfd_cache_lookup' fails to find a quick answer.
Find a file descriptor for ABFD.  If necessary, it open it.  If there
are already more than `BFD_CACHE_MAX_OPEN' files open, it tries to
close one first, to avoid running out of file descriptors.


File: bfd.info,  Node: Linker Functions,  Next: Hash Tables,  Prev: File Caching,  Up: BFD front end

Linker Functions
================

   The linker uses three special entry points in the BFD target vector.
It is not necessary to write special routines for these entry points
when creating a new BFD back end, since generic versions are provided.
However, writing them can speed up linking and make it use
significantly less runtime memory.

   The first routine creates a hash table used by the other routines.
The second routine adds the symbols from an object file to the hash
table.  The third routine takes all the object files and links them
together to create the output file.  These routines are designed so
that the linker proper does not need to know anything about the symbols
in the object files that it is linking.  The linker merely arranges the
sections as directed by the linker script and lets BFD handle the
details of symbols and relocs.

   The second routine and third routines are passed a pointer to a
`struct bfd_link_info' structure (defined in `bfdlink.h') which holds
information relevant to the link, including the linker hash table
(which was created by the first routine) and a set of callback
functions to the linker proper.

   The generic linker routines are in `linker.c', and use the header
file `genlink.h'.  As of this writing, the only back ends which have
implemented versions of these routines are a.out (in `aoutx.h') and
ECOFF (in `ecoff.c').  The a.out routines are used as examples
throughout this section.

* Menu:

* Creating a Linker Hash Table::
* Adding Symbols to the Hash Table::
* Performing the Final Link::

@


1.1.4.2
log
@Update generated files.
@
text
@a18 50
File: bfd.info,  Node: Targets,  Next: Architectures,  Prev: Core Files,  Up: BFD front end

Targets
=======

   *Description*
Each port of BFD to a different machine requries the creation of a
target back end. All the back end provides to the root part of BFD is a
structure containing pointers to functions which perform certain low
level operations on files. BFD translates the applications's requests
through a pointer into calls to the back end routines.

   When a file is opened with `bfd_openr', its format and target are
unknown. BFD uses various mechanisms to determine how to interpret the
file. The operations performed are:

   * Create a BFD by calling the internal routine `_bfd_new_bfd', then
     call `bfd_find_target' with the target string supplied to
     `bfd_openr' and the new BFD pointer.

   * If a null target string was provided to `bfd_find_target', look up
     the environment variable `GNUTARGET' and use that as the target
     string.

   * If the target string is still `NULL', or the target string is
     `default', then use the first item in the target vector as the
     target type, and set `target_defaulted' in the BFD to cause
     `bfd_check_format' to loop through all the targets.  *Note
     bfd_target::.  *Note Formats::.

   * Otherwise, inspect the elements in the target vector one by one,
     until a match on target name is found. When found, use it.

   * Otherwise return the error `bfd_error_invalid_target' to
     `bfd_openr'.

   * `bfd_openr' attempts to open the file using `bfd_open_file', and
     returns the BFD.
   Once the BFD has been opened and the target selected, the file
format may be determined. This is done by calling `bfd_check_format' on
the BFD with a suggested format.  If `target_defaulted' has been set,
each possible target type is tried to see if it recognizes the
specified format.  `bfd_check_format' returns `true' when the caller
guesses right.

* Menu:

* bfd_target::


a470 4
     #define bfd_mach_mcf5200  9
     #define bfd_mach_mcf5206e 10
     #define bfd_mach_mcf5307  11
     #define bfd_mach_mcf5407  12
a521 1
     #define bfd_mach_mips12000             12000
d1237 39
@


1.1.2.1
log
@Add generated files.
@
text
@a0 1292
This is bfd.info, produced by makeinfo version 4.0 from bfd.texinfo.

START-INFO-DIR-ENTRY
* Bfd: (bfd).                   The Binary File Descriptor library.
END-INFO-DIR-ENTRY

   This file documents the BFD library.

   Copyright (C) 1991 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, subject to the
terms of the GNU General Public License, which includes the provision
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: bfd.info,  Node: bfd_target,  Prev: Targets,  Up: Targets

bfd_target
----------

   *Description*
This structure contains everything that BFD knows about a target. It
includes things like its byte order, name, and which routines to call
to do various operations.

   Every BFD points to a target structure with its `xvec' member.

   The macros below are used to dispatch to functions through the
`bfd_target' vector. They are used in a number of macros further down
in `bfd.h', and are also used when calling various routines by hand
inside the BFD implementation.  The ARGLIST argument must be
parenthesized; it contains all the arguments to the called function.

   They make the documentation (more) unpleasant to read, so if someone
wants to fix this and not break the above, please do.
     #define BFD_SEND(bfd, message, arglist) \
                    ((*((bfd)->xvec->message)) arglist)
     
     #ifdef DEBUG_BFD_SEND
     #undef BFD_SEND
     #define BFD_SEND(bfd, message, arglist) \
       (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
         ((*((bfd)->xvec->message)) arglist) : \
         (bfd_assert (__FILE__,__LINE__), NULL))
     #endif
   For operations which index on the BFD format:
     #define BFD_SEND_FMT(bfd, message, arglist) \
                 (((bfd)->xvec->message[(int)((bfd)->format)]) arglist)
     
     #ifdef DEBUG_BFD_SEND
     #undef BFD_SEND_FMT
     #define BFD_SEND_FMT(bfd, message, arglist) \
       (((bfd) && (bfd)->xvec && (bfd)->xvec->message) ? \
        (((bfd)->xvec->message[(int)((bfd)->format)]) arglist) : \
        (bfd_assert (__FILE__,__LINE__), NULL))
     #endif
   This is the structure which defines the type of BFD this is.  The
`xvec' member of the struct `bfd' itself points here.  Each module that
implements access to a different target under BFD, defines one of these.

   FIXME, these names should be rationalised with the names of the
entry points which call them. Too bad we can't have one macro to define
them both!
     enum bfd_flavour {
       bfd_target_unknown_flavour,
       bfd_target_aout_flavour,
       bfd_target_coff_flavour,
       bfd_target_ecoff_flavour,
       bfd_target_elf_flavour,
       bfd_target_ieee_flavour,
       bfd_target_nlm_flavour,
       bfd_target_oasys_flavour,
       bfd_target_tekhex_flavour,
       bfd_target_srec_flavour,
       bfd_target_ihex_flavour,
       bfd_target_som_flavour,
       bfd_target_os9k_flavour,
       bfd_target_versados_flavour,
       bfd_target_msdos_flavour,
       bfd_target_ovax_flavour,
       bfd_target_evax_flavour
     };
     
     enum bfd_endian { BFD_ENDIAN_BIG, BFD_ENDIAN_LITTLE, BFD_ENDIAN_UNKNOWN };
     
      /* Forward declaration.  */
     typedef struct bfd_link_info _bfd_link_info;
     
     typedef struct bfd_target
     {
   Identifies the kind of target, e.g., SunOS4, Ultrix, etc.
       char *name;
   The "flavour" of a back end is a general indication about the
contents of a file.
       enum bfd_flavour flavour;
   The order of bytes within the data area of a file.
       enum bfd_endian byteorder;
   The order of bytes within the header parts of a file.
       enum bfd_endian header_byteorder;
   A mask of all the flags which an executable may have set - from the
set `BFD_NO_FLAGS', `HAS_RELOC', ...`D_PAGED'.
       flagword object_flags;
   A mask of all the flags which a section may have set - from the set
`SEC_NO_FLAGS', `SEC_ALLOC', ...`SET_NEVER_LOAD'.
       flagword section_flags;
   The character normally found at the front of a symbol (if any),
perhaps `_'.
       char symbol_leading_char;
   The pad character for file names within an archive header.
       char ar_pad_char;
   The maximum number of characters in an archive header.
       unsigned short ar_max_namelen;
   Entries for byte swapping for data. These are different from the
other entry points, since they don't take a BFD asthe first argument.
Certain other handlers could do the same.
       bfd_vma      (*bfd_getx64) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_getx_signed_64) PARAMS ((const bfd_byte *));
       void         (*bfd_putx64) PARAMS ((bfd_vma, bfd_byte *));
       bfd_vma      (*bfd_getx32) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_getx_signed_32) PARAMS ((const bfd_byte *));
       void         (*bfd_putx32) PARAMS ((bfd_vma, bfd_byte *));
       bfd_vma      (*bfd_getx16) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_getx_signed_16) PARAMS ((const bfd_byte *));
       void         (*bfd_putx16) PARAMS ((bfd_vma, bfd_byte *));
   Byte swapping for the headers
       bfd_vma      (*bfd_h_getx64) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_h_getx_signed_64) PARAMS ((const bfd_byte *));
       void         (*bfd_h_putx64) PARAMS ((bfd_vma, bfd_byte *));
       bfd_vma      (*bfd_h_getx32) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_h_getx_signed_32) PARAMS ((const bfd_byte *));
       void         (*bfd_h_putx32) PARAMS ((bfd_vma, bfd_byte *));
       bfd_vma      (*bfd_h_getx16) PARAMS ((const bfd_byte *));
       bfd_signed_vma (*bfd_h_getx_signed_16) PARAMS ((const bfd_byte *));
       void         (*bfd_h_putx16) PARAMS ((bfd_vma, bfd_byte *));
   Format dependent routines: these are vectors of entry points within
the target vector structure, one for each format to check.

   Check the format of a file being read.  Return a `bfd_target *' or
zero.
       const struct bfd_target *(*_bfd_check_format[bfd_type_end]) PARAMS ((bfd *));
   Set the format of a file being written.
       boolean             (*_bfd_set_format[bfd_type_end]) PARAMS ((bfd *));
   Write cached information into a file being written, at `bfd_close'.
       boolean             (*_bfd_write_contents[bfd_type_end]) PARAMS ((bfd *));
   The general target vector.  These vectors are initialized using the
BFD_JUMP_TABLE macros.

        /* Generic entry points.  */
     #define BFD_JUMP_TABLE_GENERIC(NAME)\
     CAT(NAME,_close_and_cleanup),\
     CAT(NAME,_bfd_free_cached_info),\
     CAT(NAME,_new_section_hook),\
     CAT(NAME,_get_section_contents),\
     CAT(NAME,_get_section_contents_in_window)
     
        /* Called when the BFD is being closed to do any necessary cleanup.  */
       boolean       (*_close_and_cleanup) PARAMS ((bfd *));
        /* Ask the BFD to free all cached information.  */
       boolean (*_bfd_free_cached_info) PARAMS ((bfd *));
        /* Called when a new section is created.  */
       boolean       (*_new_section_hook) PARAMS ((bfd *, sec_ptr));
        /* Read the contents of a section.  */
       boolean       (*_bfd_get_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
                                                 file_ptr, bfd_size_type));
       boolean       (*_bfd_get_section_contents_in_window)
                               PARAMS ((bfd *, sec_ptr, bfd_window *,
                                        file_ptr, bfd_size_type));
     
        /* Entry points to copy private data.  */
     #define BFD_JUMP_TABLE_COPY(NAME)\
     CAT(NAME,_bfd_copy_private_bfd_data),\
     CAT(NAME,_bfd_merge_private_bfd_data),\
     CAT(NAME,_bfd_copy_private_section_data),\
     CAT(NAME,_bfd_copy_private_symbol_data),\
     CAT(NAME,_bfd_set_private_flags),\
     CAT(NAME,_bfd_print_private_bfd_data)\
        /* Called to copy BFD general private data from one object file
          to another.  */
       boolean       (*_bfd_copy_private_bfd_data) PARAMS ((bfd *, bfd *));
        /* Called to merge BFD general private data from one object file
          to a common output file when linking.  */
       boolean       (*_bfd_merge_private_bfd_data) PARAMS ((bfd *, bfd *));
        /* Called to copy BFD private section data from one object file
          to another.  */
       boolean       (*_bfd_copy_private_section_data) PARAMS ((bfd *, sec_ptr,
                                                            bfd *, sec_ptr));
        /* Called to copy BFD private symbol data from one symbol
          to another.  */
       boolean       (*_bfd_copy_private_symbol_data) PARAMS ((bfd *, asymbol *,
                                                               bfd *, asymbol *));
        /* Called to set private backend flags */
       boolean       (*_bfd_set_private_flags) PARAMS ((bfd *, flagword));
     
        /* Called to print private BFD data */
       boolean       (*_bfd_print_private_bfd_data) PARAMS ((bfd *, PTR));
     
        /* Core file entry points.  */
     #define BFD_JUMP_TABLE_CORE(NAME)\
     CAT(NAME,_core_file_failing_command),\
     CAT(NAME,_core_file_failing_signal),\
     CAT(NAME,_core_file_matches_executable_p)
       char *   (*_core_file_failing_command) PARAMS ((bfd *));
       int      (*_core_file_failing_signal) PARAMS ((bfd *));
       boolean  (*_core_file_matches_executable_p) PARAMS ((bfd *, bfd *));
     
        /* Archive entry points.  */
     #define BFD_JUMP_TABLE_ARCHIVE(NAME)\
     CAT(NAME,_slurp_armap),\
     CAT(NAME,_slurp_extended_name_table),\
     CAT(NAME,_construct_extended_name_table),\
     CAT(NAME,_truncate_arname),\
     CAT(NAME,_write_armap),\
     CAT(NAME,_read_ar_hdr),\
     CAT(NAME,_openr_next_archived_file),\
     CAT(NAME,_get_elt_at_index),\
     CAT(NAME,_generic_stat_arch_elt),\
     CAT(NAME,_update_armap_timestamp)
       boolean  (*_bfd_slurp_armap) PARAMS ((bfd *));
       boolean  (*_bfd_slurp_extended_name_table) PARAMS ((bfd *));
       boolean  (*_bfd_construct_extended_name_table)
                  PARAMS ((bfd *, char **, bfd_size_type *, const char **));
       void     (*_bfd_truncate_arname) PARAMS ((bfd *, CONST char *, char *));
       boolean  (*write_armap) PARAMS ((bfd *arch,
                                   unsigned int elength,
                                   struct orl *map,
                                   unsigned int orl_count,
                                   int stridx));
       PTR (*_bfd_read_ar_hdr_fn) PARAMS ((bfd *));
       bfd *    (*openr_next_archived_file) PARAMS ((bfd *arch, bfd *prev));
     #define bfd_get_elt_at_index(b,i) BFD_SEND(b, _bfd_get_elt_at_index, (b,i))
       bfd *    (*_bfd_get_elt_at_index) PARAMS ((bfd *, symindex));
       int      (*_bfd_stat_arch_elt) PARAMS ((bfd *, struct stat *));
       boolean  (*_bfd_update_armap_timestamp) PARAMS ((bfd *));
     
        /* Entry points used for symbols.  */
     #define BFD_JUMP_TABLE_SYMBOLS(NAME)\
     CAT(NAME,_get_symtab_upper_bound),\
     CAT(NAME,_get_symtab),\
     CAT(NAME,_make_empty_symbol),\
     CAT(NAME,_print_symbol),\
     CAT(NAME,_get_symbol_info),\
     CAT(NAME,_bfd_is_local_label_name),\
     CAT(NAME,_get_lineno),\
     CAT(NAME,_find_nearest_line),\
     CAT(NAME,_bfd_make_debug_symbol),\
     CAT(NAME,_read_minisymbols),\
     CAT(NAME,_minisymbol_to_symbol)
       long  (*_bfd_get_symtab_upper_bound) PARAMS ((bfd *));
       long  (*_bfd_canonicalize_symtab) PARAMS ((bfd *,
                                                  struct symbol_cache_entry **));
       struct symbol_cache_entry  *
                     (*_bfd_make_empty_symbol) PARAMS ((bfd *));
       void          (*_bfd_print_symbol) PARAMS ((bfd *, PTR,
                                           struct symbol_cache_entry *,
                                           bfd_print_symbol_type));
     #define bfd_print_symbol(b,p,s,e) BFD_SEND(b, _bfd_print_symbol, (b,p,s,e))
       void          (*_bfd_get_symbol_info) PARAMS ((bfd *,
                                           struct symbol_cache_entry *,
                                           symbol_info *));
     #define bfd_get_symbol_info(b,p,e) BFD_SEND(b, _bfd_get_symbol_info, (b,p,e))
       boolean       (*_bfd_is_local_label_name) PARAMS ((bfd *, const char *));
     
       alent *    (*_get_lineno) PARAMS ((bfd *, struct symbol_cache_entry *));
       boolean    (*_bfd_find_nearest_line) PARAMS ((bfd *abfd,
                         struct sec *section, struct symbol_cache_entry **symbols,
                         bfd_vma offset, CONST char **file, CONST char **func,
                         unsigned int *line));
       /* Back-door to allow format-aware applications to create debug symbols
         while using BFD for everything else.  Currently used by the assembler
         when creating COFF files.  */
       asymbol *  (*_bfd_make_debug_symbol) PARAMS ((
            bfd *abfd,
            void *ptr,
            unsigned long size));
     #define bfd_read_minisymbols(b, d, m, s) \
       BFD_SEND (b, _read_minisymbols, (b, d, m, s))
       long  (*_read_minisymbols) PARAMS ((bfd *, boolean, PTR *,
                                           unsigned int *));
     #define bfd_minisymbol_to_symbol(b, d, m, f) \
       BFD_SEND (b, _minisymbol_to_symbol, (b, d, m, f))
       asymbol *(*_minisymbol_to_symbol) PARAMS ((bfd *, boolean, const PTR,
                                                  asymbol *));
     
        /* Routines for relocs.  */
     #define BFD_JUMP_TABLE_RELOCS(NAME)\
     CAT(NAME,_get_reloc_upper_bound),\
     CAT(NAME,_canonicalize_reloc),\
     CAT(NAME,_bfd_reloc_type_lookup)
       long  (*_get_reloc_upper_bound) PARAMS ((bfd *, sec_ptr));
       long  (*_bfd_canonicalize_reloc) PARAMS ((bfd *, sec_ptr, arelent **,
                                                 struct symbol_cache_entry **));
        /* See documentation on reloc types.  */
       reloc_howto_type *
            (*reloc_type_lookup) PARAMS ((bfd *abfd,
                                          bfd_reloc_code_real_type code));
     
        /* Routines used when writing an object file.  */
     #define BFD_JUMP_TABLE_WRITE(NAME)\
     CAT(NAME,_set_arch_mach),\
     CAT(NAME,_set_section_contents)
       boolean    (*_bfd_set_arch_mach) PARAMS ((bfd *, enum bfd_architecture,
                         unsigned long));
       boolean       (*_bfd_set_section_contents) PARAMS ((bfd *, sec_ptr, PTR,
                                                 file_ptr, bfd_size_type));
     
        /* Routines used by the linker.  */
     #define BFD_JUMP_TABLE_LINK(NAME)\
     CAT(NAME,_sizeof_headers),\
     CAT(NAME,_bfd_get_relocated_section_contents),\
     CAT(NAME,_bfd_relax_section),\
     CAT(NAME,_bfd_link_hash_table_create),\
     CAT(NAME,_bfd_link_add_symbols),\
     CAT(NAME,_bfd_final_link),\
     CAT(NAME,_bfd_link_split_section),\
     CAT(NAME,_bfd_gc_sections)
       int        (*_bfd_sizeof_headers) PARAMS ((bfd *, boolean));
       bfd_byte * (*_bfd_get_relocated_section_contents) PARAMS ((bfd *,
                         struct bfd_link_info *, struct bfd_link_order *,
                         bfd_byte *data, boolean relocateable,
                         struct symbol_cache_entry **));
     
       boolean    (*_bfd_relax_section) PARAMS ((bfd *, struct sec *,
                         struct bfd_link_info *, boolean *again));
     
        /* Create a hash table for the linker.  Different backends store
          different information in this table.  */
       struct bfd_link_hash_table *(*_bfd_link_hash_table_create) PARAMS ((bfd *));
     
        /* Add symbols from this object file into the hash table.  */
       boolean (*_bfd_link_add_symbols) PARAMS ((bfd *, struct bfd_link_info *));
     
        /* Do a link based on the link_order structures attached to each
          section of the BFD.  */
       boolean (*_bfd_final_link) PARAMS ((bfd *, struct bfd_link_info *));
     
        /* Should this section be split up into smaller pieces during linking.  */
       boolean (*_bfd_link_split_section) PARAMS ((bfd *, struct sec *));
     
        /* Remove sections that are not referenced from the output.  */
       boolean (*_bfd_gc_sections) PARAMS ((bfd *, struct bfd_link_info *));
     
        /* Routines to handle dynamic symbols and relocs.  */
     #define BFD_JUMP_TABLE_DYNAMIC(NAME)\
     CAT(NAME,_get_dynamic_symtab_upper_bound),\
     CAT(NAME,_canonicalize_dynamic_symtab),\
     CAT(NAME,_get_dynamic_reloc_upper_bound),\
     CAT(NAME,_canonicalize_dynamic_reloc)
        /* Get the amount of memory required to hold the dynamic symbols. */
       long  (*_bfd_get_dynamic_symtab_upper_bound) PARAMS ((bfd *));
        /* Read in the dynamic symbols.  */
       long  (*_bfd_canonicalize_dynamic_symtab)
         PARAMS ((bfd *, struct symbol_cache_entry **));
        /* Get the amount of memory required to hold the dynamic relocs.  */
       long  (*_bfd_get_dynamic_reloc_upper_bound) PARAMS ((bfd *));
        /* Read in the dynamic relocs.  */
       long  (*_bfd_canonicalize_dynamic_reloc)
         PARAMS ((bfd *, arelent **, struct symbol_cache_entry **));
   A pointer to an alternative bfd_target in case the current one is not
satisfactory.  This can happen when the target cpu supports both big
and little endian code, and target chosen by the linker has the wrong
endianness.  The function open_output() in ld/ldlang.c uses this field
to find an alternative output format that is suitable.
       /* Opposite endian version of this target.  */
      const struct bfd_target * alternative_target;
   Data for use by back-end routines, which isn't generic enough to
belong in this structure.
      PTR backend_data;
     
     } bfd_target;

`bfd_set_default_target'
........................

   *Synopsis*
     boolean bfd_set_default_target (const char *name);
   *Description*
Set the default target vector to use when recognizing a BFD.  This
takes the name of the target, which may be a BFD target name or a
configuration triplet.

`bfd_find_target'
.................

   *Synopsis*
     const bfd_target *bfd_find_target(CONST char *target_name, bfd *abfd);
   *Description*
Return a pointer to the transfer vector for the object target named
TARGET_NAME.  If TARGET_NAME is `NULL', choose the one in the
environment variable `GNUTARGET'; if that is null or not defined, then
choose the first entry in the target list.  Passing in the string
"default" or setting the environment variable to "default" will cause
the first entry in the target list to be returned, and
"target_defaulted" will be set in the BFD.  This causes
`bfd_check_format' to loop over all the targets to find the one that
matches the file being read.

`bfd_target_list'
.................

   *Synopsis*
     const char **bfd_target_list(void);
   *Description*
Return a freshly malloced NULL-terminated vector of the names of all
the valid BFD targets. Do not modify the names.

`bfd_seach_for_target'
......................

   *Synopsis*
     const bfd_target * bfd_search_for_target (int (* search_func)(const bfd_target *, void *), void *);
   *Description*
Return a pointer to the first transfer vector in the list of transfer
vectors maintained by BFD that produces a non-zero result when passed
to the function SEARCH_FUNC.  The parameter DATA is passed, unexamined,
to the search function.


File: bfd.info,  Node: Architectures,  Next: Opening and Closing,  Prev: Targets,  Up: BFD front end

Architectures
=============

   BFD keeps one atom in a BFD describing the architecture of the data
attached to the BFD: a pointer to a `bfd_arch_info_type'.

   Pointers to structures can be requested independently of a BFD so
that an architecture's information can be interrogated without access
to an open BFD.

   The architecture information is provided by each architecture
package.  The set of default architectures is selected by the macro
`SELECT_ARCHITECTURES'.  This is normally set up in the
`config/TARGET.mt' file of your choice.  If the name is not defined,
then all the architectures supported are included.

   When BFD starts up, all the architectures are called with an
initialize method.  It is up to the architecture back end to insert as
many items into the list of architectures as it wants to; generally
this would be one for each machine and one for the default case (an
item with a machine field of 0).

   BFD's idea of an architecture is implemented in `archures.c'.

bfd_architecture
----------------

   *Description*
This enum gives the object file's CPU architecture, in a global
sense--i.e., what processor family does it belong to?  Another field
indicates which processor within the family is in use.  The machine
gives a number which distinguishes different versions of the
architecture, containing, for example, 2 and 3 for Intel i960 KA and
i960 KB, and 68020 and 68030 for Motorola 68020 and 68030.
     enum bfd_architecture
     {
       bfd_arch_unknown,    /* File arch not known */
       bfd_arch_obscure,    /* Arch known, not one of these */
       bfd_arch_m68k,       /* Motorola 68xxx */
     #define bfd_mach_m68000 1
     #define bfd_mach_m68008 2
     #define bfd_mach_m68010 3
     #define bfd_mach_m68020 4
     #define bfd_mach_m68030 5
     #define bfd_mach_m68040 6
     #define bfd_mach_m68060 7
     #define bfd_mach_cpu32  8
       bfd_arch_vax,        /* DEC Vax */
       bfd_arch_i960,       /* Intel 960 */
          /* The order of the following is important.
            lower number indicates a machine type that
            only accepts a subset of the instructions
            available to machines with higher numbers.
            The exception is the "ca", which is
            incompatible with all other machines except
            "core". */
     
     #define bfd_mach_i960_core      1
     #define bfd_mach_i960_ka_sa     2
     #define bfd_mach_i960_kb_sb     3
     #define bfd_mach_i960_mc        4
     #define bfd_mach_i960_xa        5
     #define bfd_mach_i960_ca        6
     #define bfd_mach_i960_jx        7
     #define bfd_mach_i960_hx        8
     
       bfd_arch_a29k,       /* AMD 29000 */
       bfd_arch_sparc,      /* SPARC */
     #define bfd_mach_sparc                 1
      /* The difference between v8plus and v9 is that v9 is a true 64 bit env.  */
     #define bfd_mach_sparc_sparclet        2
     #define bfd_mach_sparc_sparclite       3
     #define bfd_mach_sparc_v8plus          4
     #define bfd_mach_sparc_v8plusa         5  /* with ultrasparc add'ns */
     #define bfd_mach_sparc_sparclite_le    6
     #define bfd_mach_sparc_v9              7
     #define bfd_mach_sparc_v9a             8  /* with ultrasparc add'ns */
      /* Nonzero if MACH has the v9 instruction set.  */
     #define bfd_mach_sparc_v9_p(mach) \
       ((mach) >= bfd_mach_sparc_v8plus && (mach) <= bfd_mach_sparc_v9a)
       bfd_arch_mips,       /* MIPS Rxxxx */
     #define bfd_mach_mips3000              3000
     #define bfd_mach_mips3900              3900
     #define bfd_mach_mips4000              4000
     #define bfd_mach_mips4010              4010
     #define bfd_mach_mips4100              4100
     #define bfd_mach_mips4111              4111
     #define bfd_mach_mips4300              4300
     #define bfd_mach_mips4400              4400
     #define bfd_mach_mips4600              4600
     #define bfd_mach_mips4650              4650
     #define bfd_mach_mips5000              5000
     #define bfd_mach_mips6000              6000
     #define bfd_mach_mips8000              8000
     #define bfd_mach_mips10000             10000
     #define bfd_mach_mips16                16
       bfd_arch_i386,       /* Intel 386 */
     #define bfd_mach_i386_i386 0
     #define bfd_mach_i386_i8086 1
     #define bfd_mach_i386_i386_intel_syntax 2
       bfd_arch_we32k,      /* AT&T WE32xxx */
       bfd_arch_tahoe,      /* CCI/Harris Tahoe */
       bfd_arch_i860,       /* Intel 860 */
       bfd_arch_i370,       /* IBM 360/370 Mainframes */
       bfd_arch_romp,       /* IBM ROMP PC/RT */
       bfd_arch_alliant,    /* Alliant */
       bfd_arch_convex,     /* Convex */
       bfd_arch_m88k,       /* Motorola 88xxx */
       bfd_arch_pyramid,    /* Pyramid Technology */
       bfd_arch_h8300,      /* Hitachi H8/300 */
     #define bfd_mach_h8300   1
     #define bfd_mach_h8300h  2
     #define bfd_mach_h8300s  3
       bfd_arch_powerpc,    /* PowerPC */
       bfd_arch_rs6000,     /* IBM RS/6000 */
       bfd_arch_hppa,       /* HP PA RISC */
       bfd_arch_d10v,       /* Mitsubishi D10V */
     #define bfd_mach_d10v          0
     #define bfd_mach_d10v_ts2      2
     #define bfd_mach_d10v_ts3      3
       bfd_arch_d30v,       /* Mitsubishi D30V */
       bfd_arch_z8k,        /* Zilog Z8000 */
     #define bfd_mach_z8001         1
     #define bfd_mach_z8002         2
       bfd_arch_h8500,      /* Hitachi H8/500 */
       bfd_arch_sh,         /* Hitachi SH */
     #define bfd_mach_sh            0
     #define bfd_mach_sh2        0x20
     #define bfd_mach_sh_dsp     0x2d
     #define bfd_mach_sh3        0x30
     #define bfd_mach_sh3_dsp    0x3d
     #define bfd_mach_sh3e       0x3e
     #define bfd_mach_sh4        0x40
       bfd_arch_alpha,      /* Dec Alpha */
     #define bfd_mach_alpha_ev4  0x10
     #define bfd_mach_alpha_ev5  0x20
     #define bfd_mach_alpha_ev6  0x30
       bfd_arch_arm,        /* Advanced Risc Machines ARM */
     #define bfd_mach_arm_2         1
     #define bfd_mach_arm_2a        2
     #define bfd_mach_arm_3         3
     #define bfd_mach_arm_3M        4
     #define bfd_mach_arm_4         5
     #define bfd_mach_arm_4T        6
     #define bfd_mach_arm_5         7
     #define bfd_mach_arm_5T        8
       bfd_arch_ns32k,      /* National Semiconductors ns32000 */
       bfd_arch_w65,        /* WDC 65816 */
       bfd_arch_tic30,      /* Texas Instruments TMS320C30 */
       bfd_arch_tic80,      /* TI TMS320c80 (MVP) */
       bfd_arch_v850,       /* NEC V850 */
     #define bfd_mach_v850          0
     #define bfd_mach_v850e         'E'
     #define bfd_mach_v850ea        'A'
       bfd_arch_arc,        /* Argonaut RISC Core */
     #define bfd_mach_arc_base 0
       bfd_arch_m32r,       /* Mitsubishi M32R/D */
     #define bfd_mach_m32r          0  /* backwards compatibility */
     #define bfd_mach_m32rx         'x'
       bfd_arch_mn10200,    /* Matsushita MN10200 */
       bfd_arch_mn10300,    /* Matsushita MN10300 */
     #define bfd_mach_mn10300               300
     #define bfd_mach_am33          330
       bfd_arch_fr30,
     #define bfd_mach_fr30          0x46523330
       bfd_arch_mcore,
       bfd_arch_pj,
       bfd_arch_avr,        /* Atmel AVR microcontrollers */
     #define bfd_mach_avr1          1
     #define bfd_mach_avr2          2
     #define bfd_mach_avr3          3
     #define bfd_mach_avr4          4
       bfd_arch_last
       };

bfd_arch_info
-------------

   *Description*
This structure contains information on architectures for use within BFD.

     typedef struct bfd_arch_info
     {
       int bits_per_word;
       int bits_per_address;
       int bits_per_byte;
       enum bfd_architecture arch;
       unsigned long mach;
       const char *arch_name;
       const char *printable_name;
       unsigned int section_align_power;
       /* true if this is the default machine for the architecture */
       boolean the_default;
       const struct bfd_arch_info * (*compatible)
            PARAMS ((const struct bfd_arch_info *a,
                     const struct bfd_arch_info *b));
     
       boolean (*scan) PARAMS ((const struct bfd_arch_info *, const char *));
     
       const struct bfd_arch_info *next;
     } bfd_arch_info_type;

`bfd_printable_name'
....................

   *Synopsis*
     const char *bfd_printable_name(bfd *abfd);
   *Description*
Return a printable string representing the architecture and machine
from the pointer to the architecture info structure.

`bfd_scan_arch'
...............

   *Synopsis*
     const bfd_arch_info_type *bfd_scan_arch(const char *string);
   *Description*
Figure out if BFD supports any cpu which could be described with the
name STRING.  Return a pointer to an `arch_info' structure if a machine
is found, otherwise NULL.

`bfd_arch_list'
...............

   *Synopsis*
     const char **bfd_arch_list(void);
   *Description*
Return a freshly malloced NULL-terminated vector of the names of all
the valid BFD architectures.  Do not modify the names.

`bfd_arch_get_compatible'
.........................

   *Synopsis*
     const bfd_arch_info_type *bfd_arch_get_compatible(
         const bfd *abfd,
         const bfd *bbfd);
   *Description*
Determine whether two BFDs' architectures and machine types are
compatible.  Calculates the lowest common denominator between the two
architectures and machine types implied by the BFDs and returns a
pointer to an `arch_info' structure describing the compatible machine.

`bfd_default_arch_struct'
.........................

   *Description*
The `bfd_default_arch_struct' is an item of `bfd_arch_info_type' which
has been initialized to a fairly generic state.  A BFD starts life by
pointing to this structure, until the correct back end has determined
the real architecture of the file.
     extern const bfd_arch_info_type bfd_default_arch_struct;

`bfd_set_arch_info'
...................

   *Synopsis*
     void bfd_set_arch_info(bfd *abfd, const bfd_arch_info_type *arg);
   *Description*
Set the architecture info of ABFD to ARG.

`bfd_default_set_arch_mach'
...........................

   *Synopsis*
     boolean bfd_default_set_arch_mach(bfd *abfd,
         enum bfd_architecture arch,
         unsigned long mach);
   *Description*
Set the architecture and machine type in BFD ABFD to ARCH and MACH.
Find the correct pointer to a structure and insert it into the
`arch_info' pointer.

`bfd_get_arch'
..............

   *Synopsis*
     enum bfd_architecture bfd_get_arch(bfd *abfd);
   *Description*
Return the enumerated type which describes the BFD ABFD's architecture.

`bfd_get_mach'
..............

   *Synopsis*
     unsigned long bfd_get_mach(bfd *abfd);
   *Description*
Return the long type which describes the BFD ABFD's machine.

`bfd_arch_bits_per_byte'
........................

   *Synopsis*
     unsigned int bfd_arch_bits_per_byte(bfd *abfd);
   *Description*
Return the number of bits in one of the BFD ABFD's architecture's bytes.

`bfd_arch_bits_per_address'
...........................

   *Synopsis*
     unsigned int bfd_arch_bits_per_address(bfd *abfd);
   *Description*
Return the number of bits in one of the BFD ABFD's architecture's
addresses.

`bfd_default_compatible'
........................

   *Synopsis*
     const bfd_arch_info_type *bfd_default_compatible
        (const bfd_arch_info_type *a,
         const bfd_arch_info_type *b);
   *Description*
The default function for testing for compatibility.

`bfd_default_scan'
..................

   *Synopsis*
     boolean bfd_default_scan(const struct bfd_arch_info *info, const char *string);
   *Description*
The default function for working out whether this is an architecture
hit and a machine hit.

`bfd_get_arch_info'
...................

   *Synopsis*
     const bfd_arch_info_type * bfd_get_arch_info(bfd *abfd);
   *Description*
Return the architecture info struct in ABFD.

`bfd_lookup_arch'
.................

   *Synopsis*
     const bfd_arch_info_type *bfd_lookup_arch
        (enum bfd_architecture
         arch,
         unsigned long machine);
   *Description*
Look for the architecure info structure which matches the arguments
ARCH and MACHINE. A machine of 0 matches the machine/architecture
structure which marks itself as the default.

`bfd_printable_arch_mach'
.........................

   *Synopsis*
     const char *bfd_printable_arch_mach
        (enum bfd_architecture arch, unsigned long machine);
   *Description*
Return a printable string representing the architecture and machine
type.

   This routine is depreciated.

`bfd_octets_per_byte'
.....................

   *Synopsis*
     unsigned int bfd_octets_per_byte(bfd *abfd);
   *Description*
Return the number of octets (8-bit quantities) per target byte (minimum
addressable unit).  In most cases, this will be one, but some DSP
targets have 16, 32, or even 48 bits per byte.

`bfd_arch_mach_octets_per_byte'
...............................

   *Synopsis*
     unsigned int bfd_arch_mach_octets_per_byte(enum bfd_architecture arch,
         unsigned long machine);
   *Description*
See bfd_octets_per_byte.  This routine is provided for those cases
where a bfd * is not available


File: bfd.info,  Node: Opening and Closing,  Next: Internal,  Prev: Architectures,  Up: BFD front end

Opening and closing BFDs
========================

`bfd_openr'
...........

   *Synopsis*
     bfd *bfd_openr(CONST char *filename, CONST char *target);
   *Description*
Open the file FILENAME (using `fopen') with the target TARGET.  Return
a pointer to the created BFD.

   Calls `bfd_find_target', so TARGET is interpreted as by that
function.

   If `NULL' is returned then an error has occured.   Possible errors
are `bfd_error_no_memory', `bfd_error_invalid_target' or `system_call'
error.

`bfd_fdopenr'
.............

   *Synopsis*
     bfd *bfd_fdopenr(CONST char *filename, CONST char *target, int fd);
   *Description*
`bfd_fdopenr' is to `bfd_fopenr' much like `fdopen' is to `fopen'.  It
opens a BFD on a file already described by the FD supplied.

   When the file is later `bfd_close'd, the file descriptor will be
closed.

   If the caller desires that this file descriptor be cached by BFD
(opened as needed, closed as needed to free descriptors for other
opens), with the supplied FD used as an initial file descriptor (but
subject to closure at any time), call bfd_set_cacheable(bfd, 1) on the
returned BFD.  The default is to assume no cacheing; the file
descriptor will remain open until `bfd_close', and will not be affected
by BFD operations on other files.

   Possible errors are `bfd_error_no_memory',
`bfd_error_invalid_target' and `bfd_error_system_call'.

`bfd_openstreamr'
.................

   *Synopsis*
     bfd *bfd_openstreamr(const char *, const char *, PTR);
   *Description*
Open a BFD for read access on an existing stdio stream.  When the BFD
is passed to `bfd_close', the stream will be closed.

`bfd_openw'
...........

   *Synopsis*
     bfd *bfd_openw(CONST char *filename, CONST char *target);
   *Description*
Create a BFD, associated with file FILENAME, using the file format
TARGET, and return a pointer to it.

   Possible errors are `bfd_error_system_call', `bfd_error_no_memory',
`bfd_error_invalid_target'.

`bfd_close'
...........

   *Synopsis*
     boolean bfd_close(bfd *abfd);
   *Description*
Close a BFD. If the BFD was open for writing, then pending operations
are completed and the file written out and closed. If the created file
is executable, then `chmod' is called to mark it as such.

   All memory attached to the BFD is released.

   The file descriptor associated with the BFD is closed (even if it
was passed in to BFD by `bfd_fdopenr').

   *Returns*
`true' is returned if all is ok, otherwise `false'.

`bfd_close_all_done'
....................

   *Synopsis*
     boolean bfd_close_all_done(bfd *);
   *Description*
Close a BFD.  Differs from `bfd_close' since it does not complete any
pending operations.  This routine would be used if the application had
just used BFD for swapping and didn't want to use any of the writing
code.

   If the created file is executable, then `chmod' is called to mark it
as such.

   All memory attached to the BFD is released.

   *Returns*
`true' is returned if all is ok, otherwise `false'.

`bfd_create'
............

   *Synopsis*
     bfd *bfd_create(CONST char *filename, bfd *templ);
   *Description*
Create a new BFD in the manner of `bfd_openw', but without opening a
file. The new BFD takes the target from the target used by TEMPLATE. The
format is always set to `bfd_object'.

`bfd_make_writable'
...................

   *Synopsis*
     boolean bfd_make_writable(bfd *abfd);
   *Description*
Takes a BFD as created by `bfd_create' and converts it into one like as
returned by `bfd_openw'.  It does this by converting the BFD to
BFD_IN_MEMORY.  It's assumed that you will call `bfd_make_readable' on
this bfd later.

   *Returns*
`true' is returned if all is ok, otherwise `false'.

`bfd_make_readable'
...................

   *Synopsis*
     boolean bfd_make_readable(bfd *abfd);
   *Description*
Takes a BFD as created by `bfd_create' and `bfd_make_writable' and
converts it into one like as returned by `bfd_openr'.  It does this by
writing the contents out to the memory buffer, then reversing the
direction.

   *Returns*
`true' is returned if all is ok, otherwise `false'.

`bfd_alloc'
...........

   *Synopsis*
     PTR bfd_alloc (bfd *abfd, size_t wanted);
   *Description*
Allocate a block of WANTED bytes of memory attached to `abfd' and
return a pointer to it.


File: bfd.info,  Node: Internal,  Next: File Caching,  Prev: Opening and Closing,  Up: BFD front end

Internal functions
==================

   *Description*
These routines are used within BFD.  They are not intended for export,
but are documented here for completeness.

`bfd_write_bigendian_4byte_int'
...............................

   *Synopsis*
     void bfd_write_bigendian_4byte_int(bfd *abfd,  int i);
   *Description*
Write a 4 byte integer I to the output BFD ABFD, in big endian order
regardless of what else is going on.  This is useful in archives.

`bfd_put_size'
..............

`bfd_get_size'
..............

   *Description*
These macros as used for reading and writing raw data in sections; each
access (except for bytes) is vectored through the target format of the
BFD and mangled accordingly. The mangling performs any necessary endian
translations and removes alignment restrictions.  Note that types
accepted and returned by these macros are identical so they can be
swapped around in macros--for example, `libaout.h' defines `GET_WORD'
to either `bfd_get_32' or `bfd_get_64'.

   In the put routines, VAL must be a `bfd_vma'.  If we are on a system
without prototypes, the caller is responsible for making sure that is
true, with a cast if necessary.  We don't cast them in the macro
definitions because that would prevent `lint' or `gcc -Wall' from
detecting sins such as passing a pointer.  To detect calling these with
less than a `bfd_vma', use `gcc -Wconversion' on a host with 64 bit
`bfd_vma''s.

      /* Byte swapping macros for user section data.  */
     
     #define bfd_put_8(abfd, val, ptr) \
                     ((void) (*((unsigned char *)(ptr)) = (unsigned char)(val)))
     #define bfd_put_signed_8 \
                    bfd_put_8
     #define bfd_get_8(abfd, ptr) \
                     (*(unsigned char *)(ptr))
     #define bfd_get_signed_8(abfd, ptr) \
                    ((*(unsigned char *)(ptr) ^ 0x80) - 0x80)
     
     #define bfd_put_16(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
     #define bfd_put_signed_16 \
                     bfd_put_16
     #define bfd_get_16(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx16, (ptr))
     #define bfd_get_signed_16(abfd, ptr) \
                     BFD_SEND (abfd, bfd_getx_signed_16, (ptr))
     
     #define bfd_put_32(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
     #define bfd_put_signed_32 \
                     bfd_put_32
     #define bfd_get_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx32, (ptr))
     #define bfd_get_signed_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx_signed_32, (ptr))
     
     #define bfd_put_64(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
     #define bfd_put_signed_64 \
                     bfd_put_64
     #define bfd_get_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx64, (ptr))
     #define bfd_get_signed_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_getx_signed_64, (ptr))
     
     #define bfd_get(bits, abfd, ptr)                               \
                     ((bits) == 8 ? bfd_get_8 (abfd, ptr)           \
                     : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
                     : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
                     : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
                     : (abort (), (bfd_vma) - 1))
     
     #define bfd_put(bits, abfd, val, ptr)                          \
                     ((bits) == 8 ? bfd_put_8 (abfd, val, ptr)      \
                     : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
                     : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
                     : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
                     : (abort (), (void) 0))

`bfd_h_put_size'
................

   *Description*
These macros have the same function as their `bfd_get_x' bretheren,
except that they are used for removing information for the header
records of object files. Believe it or not, some object files keep
their header records in big endian order and their data in little
endian order.

      /* Byte swapping macros for file header data.  */
     
     #define bfd_h_put_8(abfd, val, ptr) \
                    bfd_put_8 (abfd, val, ptr)
     #define bfd_h_put_signed_8(abfd, val, ptr) \
                    bfd_put_8 (abfd, val, ptr)
     #define bfd_h_get_8(abfd, ptr) \
                    bfd_get_8 (abfd, ptr)
     #define bfd_h_get_signed_8(abfd, ptr) \
                    bfd_get_signed_8 (abfd, ptr)
     
     #define bfd_h_put_16(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_h_putx16,(val,ptr))
     #define bfd_h_put_signed_16 \
                     bfd_h_put_16
     #define bfd_h_get_16(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx16,(ptr))
     #define bfd_h_get_signed_16(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr))
     
     #define bfd_h_put_32(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_h_putx32,(val,ptr))
     #define bfd_h_put_signed_32 \
                     bfd_h_put_32
     #define bfd_h_get_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx32,(ptr))
     #define bfd_h_get_signed_32(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr))
     
     #define bfd_h_put_64(abfd, val, ptr) \
                     BFD_SEND(abfd, bfd_h_putx64,(val, ptr))
     #define bfd_h_put_signed_64 \
                     bfd_h_put_64
     #define bfd_h_get_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx64,(ptr))
     #define bfd_h_get_signed_64(abfd, ptr) \
                     BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr))

`bfd_log2'
..........

   *Synopsis*
     unsigned int bfd_log2(bfd_vma x);
   *Description*
Return the log base 2 of the value supplied, rounded up.  E.g., an X of
1025 returns 11.


File: bfd.info,  Node: File Caching,  Next: Linker Functions,  Prev: Internal,  Up: BFD front end

File caching
============

   The file caching mechanism is embedded within BFD and allows the
application to open as many BFDs as it wants without regard to the
underlying operating system's file descriptor limit (often as low as 20
open files).  The module in `cache.c' maintains a least recently used
list of `BFD_CACHE_MAX_OPEN' files, and exports the name
`bfd_cache_lookup', which runs around and makes sure that the required
BFD is open. If not, then it chooses a file to close, closes it and
opens the one wanted, returning its file handle.

`BFD_CACHE_MAX_OPEN macro'
..........................

   *Description*
The maximum number of files which the cache will keep open at one time.
     #define BFD_CACHE_MAX_OPEN 10

`bfd_last_cache'
................

   *Synopsis*
     extern bfd *bfd_last_cache;
   *Description*
Zero, or a pointer to the topmost BFD on the chain.  This is used by
the `bfd_cache_lookup' macro in `libbfd.h' to determine when it can
avoid a function call.

`bfd_cache_lookup'
..................

   *Description*
Check to see if the required BFD is the same as the last one looked up.
If so, then it can use the stream in the BFD with impunity, since it
can't have changed since the last lookup; otherwise, it has to perform
the complicated lookup function.
     #define bfd_cache_lookup(x) \
         ((x)==bfd_last_cache? \
           (FILE*)(bfd_last_cache->iostream): \
            bfd_cache_lookup_worker(x))

`bfd_cache_init'
................

   *Synopsis*
     boolean bfd_cache_init (bfd *abfd);
   *Description*
Add a newly opened BFD to the cache.

`bfd_cache_close'
.................

   *Synopsis*
     boolean bfd_cache_close (bfd *abfd);
   *Description*
Remove the BFD ABFD from the cache. If the attached file is open, then
close it too.

   *Returns*
`false' is returned if closing the file fails, `true' is returned if
all is well.

`bfd_open_file'
...............

   *Synopsis*
     FILE* bfd_open_file(bfd *abfd);
   *Description*
Call the OS to open a file for ABFD.  Return the `FILE *' (possibly
`NULL') that results from this operation.  Set up the BFD so that
future accesses know the file is open. If the `FILE *' returned is
`NULL', then it won't have been put in the cache, so it won't have to
be removed from it.

`bfd_cache_lookup_worker'
.........................

   *Synopsis*
     FILE *bfd_cache_lookup_worker(bfd *abfd);
   *Description*
Called when the macro `bfd_cache_lookup' fails to find a quick answer.
Find a file descriptor for ABFD.  If necessary, it open it.  If there
are already more than `BFD_CACHE_MAX_OPEN' files open, it tries to
close one first, to avoid running out of file descriptors.


File: bfd.info,  Node: Linker Functions,  Next: Hash Tables,  Prev: File Caching,  Up: BFD front end

Linker Functions
================

   The linker uses three special entry points in the BFD target vector.
It is not necessary to write special routines for these entry points
when creating a new BFD back end, since generic versions are provided.
However, writing them can speed up linking and make it use
significantly less runtime memory.

   The first routine creates a hash table used by the other routines.
The second routine adds the symbols from an object file to the hash
table.  The third routine takes all the object files and links them
together to create the output file.  These routines are designed so
that the linker proper does not need to know anything about the symbols
in the object files that it is linking.  The linker merely arranges the
sections as directed by the linker script and lets BFD handle the
details of symbols and relocs.

   The second routine and third routines are passed a pointer to a
`struct bfd_link_info' structure (defined in `bfdlink.h') which holds
information relevant to the link, including the linker hash table
(which was created by the first routine) and a set of callback
functions to the linker proper.

   The generic linker routines are in `linker.c', and use the header
file `genlink.h'.  As of this writing, the only back ends which have
implemented versions of these routines are a.out (in `aoutx.h') and
ECOFF (in `ecoff.c').  The a.out routines are used as examples
throughout this section.

* Menu:

* Creating a Linker Hash Table::
* Adding Symbols to the Hash Table::
* Performing the Final Link::


File: bfd.info,  Node: Creating a Linker Hash Table,  Next: Adding Symbols to the Hash Table,  Prev: Linker Functions,  Up: Linker Functions

Creating a linker hash table
----------------------------

   The linker routines must create a hash table, which must be derived
from `struct bfd_link_hash_table' described in `bfdlink.c'.  *Note Hash
Tables::, for information on how to create a derived hash table.  This
entry point is called using the target vector of the linker output file.

   The `_bfd_link_hash_table_create' entry point must allocate and
initialize an instance of the desired hash table.  If the back end does
not require any additional information to be stored with the entries in
the hash table, the entry point may simply create a `struct
bfd_link_hash_table'.  Most likely, however, some additional
information will be needed.

   For example, with each entry in the hash table the a.out linker
keeps the index the symbol has in the final output file (this index
number is used so that when doing a relocateable link the symbol index
used in the output file can be quickly filled in when copying over a
reloc).  The a.out linker code defines the required structures and
functions for a hash table derived from `struct bfd_link_hash_table'.
The a.out linker hash table is created by the function
`NAME(aout,link_hash_table_create)'; it simply allocates space for the
hash table, initializes it, and returns a pointer to it.

   When writing the linker routines for a new back end, you will
generally not know exactly which fields will be required until you have
finished.  You should simply create a new hash table which defines no
additional fields, and then simply add fields as they become necessary.


File: bfd.info,  Node: Adding Symbols to the Hash Table,  Next: Performing the Final Link,  Prev: Creating a Linker Hash Table,  Up: Linker Functions

Adding symbols to the hash table
--------------------------------

   The linker proper will call the `_bfd_link_add_symbols' entry point
for each object file or archive which is to be linked (typically these
are the files named on the command line, but some may also come from
the linker script).  The entry point is responsible for examining the
file.  For an object file, BFD must add any relevant symbol information
to the hash table.  For an archive, BFD must determine which elements
of the archive should be used and adding them to the link.

   The a.out version of this entry point is
`NAME(aout,link_add_symbols)'.

* Menu:

* Differing file formats::
* Adding symbols from an object file::
* Adding symbols from an archive::

@

