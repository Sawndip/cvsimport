head	1.1;
access;
symbols
	binutils-2_23_2:1.1.24.1
	binutils-2_23_1:1.1.24.1
	binutils-2_23-branch:1.1.0.24
	binutils-2_20_1:1.1.22.1
	binutils-2_20:1.1.22.1
	binutils-2_20-branch:1.1.0.22
	binutils-2_19_1:1.1.20.1
	binutils-2_19:1.1.20.1
	binutils-2_19-branch:1.1.0.20
	binutils-2_18:1.1.18.1
	binutils-2_18-branch:1.1.0.18
	binutils-csl-sourcerygxx-3_4_4-32:1.1.14.1
	binutils-csl-sourcerygxx-3_4_4-25:1.1.14.1
	binutils-2_17:1.1.16.1
	binutils-csl-wrs-linux-3_4_4-24:1.1.14.1
	binutils-csl-wrs-linux-3_4_4-23:1.1.14.1
	binutils-csl-wrs-linux-3_4_4-22:1.1.14.1
	binutils-csl-wrs-linux-3_4_4-21:1.1.14.1
	binutils-csl-wrs-linux-3_4_4-20:1.1.14.1
	binutils-2_17-branch:1.1.0.16
	binutils-csl-gxxpro-3_4-branch:1.1.14.1.0.4
	binutils-csl-gxxpro-3_4-branchpoint:1.1.14.1
	binutils-2_16_1:1.1.14.1
	binutils-csl-arm-2005q1b:1.1.14.1
	binutils-2_16:1.1.14.1
	binutils-csl-arm-2005q1a:1.1.14.1
	binutils-csl-arm-2005q1-branch:1.1.14.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.1.14.1
	binutils-2_16-branch:1.1.0.14
	binutils-2_15:1.1.12.1
	binutils-2_15-branch:1.1.0.12
	binutils-2_14:1.1.10.1
	binutils-2_14-branch:1.1.0.10
	binutils-2_13_2_1:1.1.8.1
	binutils-2_13_2:1.1.8.1
	binutils-2_13_1:1.1.8.1
	binutils-2_13:1.1.8.1
	binutils-2_13-branch:1.1.0.8
	binutils-2_12_1:1.1.6.2
	binutils-2_12:1.1.6.1
	binutils-2_12-branch:1.1.0.6
	binutils-2_11_2:1.1.4.1
	binutils-2_11_1:1.1.4.1
	binutils-2_11:1.1.4.1
	binutils-2_11-branch:1.1.0.4
	binutils-2_10_1:1.1.2.1
	binutils-2_10:1.1.2.1
	binutils_latest_snapshot:1.1.2.1
	binutils-2_10-branch:1.1.0.2;
locks; strict;
comment	@# @;


1.1
date	2000.05.29.14.08.52;	author pb;	state dead;
branches
	1.1.2.1
	1.1.4.1
	1.1.6.1
	1.1.8.1
	1.1.10.1
	1.1.12.1
	1.1.14.1
	1.1.16.1
	1.1.18.1
	1.1.20.1
	1.1.22.1
	1.1.24.1;
next	;

1.1.2.1
date	2000.05.29.14.08.52;	author pb;	state Exp;
branches;
next	;

1.1.4.1
date	2001.03.12.15.40.30;	author pb;	state Exp;
branches;
next	;

1.1.6.1
date	2002.03.08.17.00.49;	author drow;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.05.11.20.00.47;	author drow;	state Exp;
branches;
next	;

1.1.8.1
date	2002.08.05.20.43.45;	author drow;	state Exp;
branches;
next	;

1.1.10.1
date	2003.04.27.20.36.06;	author drow;	state Exp;
branches;
next	;

1.1.12.1
date	2004.04.09.19.32.14;	author drow;	state Exp;
branches;
next	;

1.1.14.1
date	2005.03.08.17.19.42;	author drow;	state Exp;
branches;
next	;

1.1.16.1
date	2006.04.16.18.36.40;	author drow;	state Exp;
branches;
next	;

1.1.18.1
date	2007.08.06.21.05.18;	author drow;	state Exp;
branches;
next	;

1.1.20.1
date	2008.09.11.08.24.13;	author gingold;	state Exp;
branches;
next	;

1.1.22.1
date	2009.10.16.12.07.01;	author gingold;	state Exp;
branches;
next	;

1.1.24.1
date	2012.11.13.14.51.25;	author gingold;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file libbfd.texi was initially added on branch binutils-2_10-branch.
@
text
@@


1.1.24.1
log
@*** empty log message ***
@
text
@a0 179
@@section Implementation details


@@subsection Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
#define bfd_put_signed_8 \
  bfd_put_8
#define bfd_get_8(abfd, ptr) \
  (*(const unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
  (((*(const unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
  bfd_put_16
#define bfd_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
  bfd_put_32
#define bfd_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
  bfd_put_64
#define bfd_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                       \
  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
   : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                  \
  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
   : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Aliases for the above, which should eventually go away.  */

#define H_PUT_64  bfd_h_put_64
#define H_PUT_32  bfd_h_put_32
#define H_PUT_16  bfd_h_put_16
#define H_PUT_8   bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8  bfd_h_put_signed_8
#define H_GET_64  bfd_h_get_64
#define H_GET_32  bfd_h_get_32
#define H_GET_16  bfd_h_get_16
#define H_GET_8   bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8  bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.22.1
log
@bfd/
2009-10-16  Tristan Gingold  <gingold@@adacore.com>

	* configure.in: Bump version to 2.20
	* Makefile.am (RELEASE): Set.
	* configure, Makefile.in: Regenerate.
@
text
@a0 179
@@section Implementation details


@@subsection Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
#define bfd_put_signed_8 \
  bfd_put_8
#define bfd_get_8(abfd, ptr) \
  (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
  bfd_put_16
#define bfd_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
  bfd_put_32
#define bfd_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
  bfd_put_64
#define bfd_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                       \
  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
   : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                  \
  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
   : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Aliases for the above, which should eventually go away.  */

#define H_PUT_64  bfd_h_put_64
#define H_PUT_32  bfd_h_put_32
#define H_PUT_16  bfd_h_put_16
#define H_PUT_8   bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8  bfd_h_put_signed_8
#define H_GET_64  bfd_h_get_64
#define H_GET_32  bfd_h_get_32
#define H_GET_16  bfd_h_get_16
#define H_GET_8   bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8  bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.20.1
log
@Generated files for binutils 2.19.
@
text
@a0 179
@@section Implementation details


@@subsection Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
#define bfd_put_signed_8 \
  bfd_put_8
#define bfd_get_8(abfd, ptr) \
  (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
  bfd_put_16
#define bfd_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
  bfd_put_32
#define bfd_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
  bfd_put_64
#define bfd_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                       \
  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
   : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                  \
  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
   : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Aliases for the above, which should eventually go away.  */

#define H_PUT_64  bfd_h_put_64
#define H_PUT_32  bfd_h_put_32
#define H_PUT_16  bfd_h_put_16
#define H_PUT_8   bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8  bfd_h_put_signed_8
#define H_GET_64  bfd_h_get_64
#define H_GET_32  bfd_h_get_32
#define H_GET_16  bfd_h_get_16
#define H_GET_8   bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8  bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.18.1
log
@Commit generated files for binutils 2.17.90.
@
text
@a0 179
@@section Implementation details


@@subsection Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
#define bfd_put_signed_8 \
  bfd_put_8
#define bfd_get_8(abfd, ptr) \
  (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
  bfd_put_16
#define bfd_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
  bfd_put_32
#define bfd_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
  bfd_put_64
#define bfd_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                       \
  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
   : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                  \
  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
   : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Aliases for the above, which should eventually go away.  */

#define H_PUT_64  bfd_h_put_64
#define H_PUT_32  bfd_h_put_32
#define H_PUT_16  bfd_h_put_16
#define H_PUT_8   bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8  bfd_h_put_signed_8
#define H_GET_64  bfd_h_get_64
#define H_GET_32  bfd_h_get_32
#define H_GET_16  bfd_h_get_16
#define H_GET_8   bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8  bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.16.1
log
@Commit generated files.
@
text
@a0 179
@@section Implementation details


@@subsection Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
#define bfd_put_signed_8 \
  bfd_put_8
#define bfd_get_8(abfd, ptr) \
  (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
  bfd_put_16
#define bfd_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
  bfd_put_32
#define bfd_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
  bfd_put_64
#define bfd_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                       \
  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
   : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                  \
  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
   : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Aliases for the above, which should eventually go away.  */

#define H_PUT_64  bfd_h_put_64
#define H_PUT_32  bfd_h_put_32
#define H_PUT_16  bfd_h_put_16
#define H_PUT_8   bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8  bfd_h_put_signed_8
#define H_GET_64  bfd_h_get_64
#define H_GET_32  bfd_h_get_32
#define H_GET_16  bfd_h_get_16
#define H_GET_8   bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8  bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.14.1
log
@Commit generated files for the binutils 2.16 branch.
@
text
@a0 176
@@section Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
#define bfd_put_signed_8 \
  bfd_put_8
#define bfd_get_8(abfd, ptr) \
  (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
  bfd_put_16
#define bfd_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
  bfd_put_32
#define bfd_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
  bfd_put_64
#define bfd_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                       \
  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
   : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                  \
  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
   : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Aliases for the above, which should eventually go away.  */

#define H_PUT_64  bfd_h_put_64
#define H_PUT_32  bfd_h_put_32
#define H_PUT_16  bfd_h_put_16
#define H_PUT_8   bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8  bfd_h_put_signed_8
#define H_GET_64  bfd_h_get_64
#define H_GET_32  bfd_h_get_32
#define H_GET_16  bfd_h_get_16
#define H_GET_8   bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8  bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.12.1
log
@Generated files for the 2.15 branch.
@
text
@a0 176
@@section Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
  ((void) (*((unsigned char *) (ptr)) = (val) & 0xff))
#define bfd_put_signed_8 \
  bfd_put_8
#define bfd_get_8(abfd, ptr) \
  (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
  (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
  bfd_put_16
#define bfd_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
  bfd_put_32
#define bfd_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
  bfd_put_64
#define bfd_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                       \
  ((bits) == 8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
   : (bits) == 16 ? bfd_get_16 (abfd, ptr)             \
   : (bits) == 32 ? bfd_get_32 (abfd, ptr)             \
   : (bits) == 64 ? bfd_get_64 (abfd, ptr)             \
   : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                  \
  ((bits) == 8 ? bfd_put_8  (abfd, val, ptr)           \
   : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)                \
   : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)                \
   : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)                \
   : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Aliases for the above, which should eventually go away.  */

#define H_PUT_64  bfd_h_put_64
#define H_PUT_32  bfd_h_put_32
#define H_PUT_16  bfd_h_put_16
#define H_PUT_8   bfd_h_put_8
#define H_PUT_S64 bfd_h_put_signed_64
#define H_PUT_S32 bfd_h_put_signed_32
#define H_PUT_S16 bfd_h_put_signed_16
#define H_PUT_S8  bfd_h_put_signed_8
#define H_GET_64  bfd_h_get_64
#define H_GET_32  bfd_h_get_32
#define H_GET_16  bfd_h_get_16
#define H_GET_8   bfd_h_get_8
#define H_GET_S64 bfd_h_get_signed_64
#define H_GET_S32 bfd_h_get_signed_32
#define H_GET_S16 bfd_h_get_signed_16
#define H_GET_S8  bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.10.1
log
@Add generated files on 2.14 branch.
@
text
@a0 204
@@section Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
bfd_boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
                ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
#define bfd_put_signed_8 \
               bfd_put_8
#define bfd_get_8(abfd, ptr) \
                (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
               (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
                bfd_put_16
#define bfd_get_16(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
                BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
                bfd_put_32
#define bfd_get_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
                bfd_put_64
#define bfd_get_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                               \
                ( (bits) ==  8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
                : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
                : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
                : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
                : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                          \
                ( (bits) ==  8 ? bfd_put_8  (abfd, val, ptr)   \
                : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
                : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
                : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
                : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Refinements on the above, which should eventually go away.  Save
   cluttering the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_8 bfd_h_put_8

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S8 bfd_h_put_signed_8

#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

#define H_GET_8 bfd_h_get_8

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

#define H_GET_S8 bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.8.1
log
@Add generated files.
@
text
@a0 204
@@section Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
                ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
#define bfd_put_signed_8 \
               bfd_put_8
#define bfd_get_8(abfd, ptr) \
                (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
               (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
                bfd_put_16
#define bfd_get_16(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
                BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
                bfd_put_32
#define bfd_get_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
                bfd_put_64
#define bfd_get_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                               \
                ( (bits) ==  8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
                : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
                : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
                : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
                : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                          \
                ( (bits) ==  8 ? bfd_put_8  (abfd, val, ptr)   \
                : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
                : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
                : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
                : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Refinements on the above, which should eventually go away.  Save
   cluttering the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_8 bfd_h_put_8

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S8 bfd_h_put_signed_8

#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

#define H_GET_8 bfd_h_get_8

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

#define H_GET_S8 bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.6.1
log
@Add generated files on 2.12 release branch.
@
text
@a0 204
@@section Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
void bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
                ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
#define bfd_put_signed_8 \
               bfd_put_8
#define bfd_get_8(abfd, ptr) \
                (*(unsigned char *) (ptr) & 0xff)
#define bfd_get_signed_8(abfd, ptr) \
               (((*(unsigned char *) (ptr) & 0xff) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
                bfd_put_16
#define bfd_get_16(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
                BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
                bfd_put_32
#define bfd_get_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
                bfd_put_64
#define bfd_get_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                               \
                ( (bits) ==  8 ? (bfd_vma) bfd_get_8 (abfd, ptr)       \
                : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
                : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
                : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
                : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                          \
                ( (bits) ==  8 ? bfd_put_8  (abfd, val, ptr)   \
                : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
                : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
                : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
                : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
brethren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
  bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
  bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
  bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx16, (val, ptr))
#define bfd_h_put_signed_16 \
  bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx16, (ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx32, (val, ptr))
#define bfd_h_put_signed_32 \
  bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx32, (ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
  BFD_SEND (abfd, bfd_h_putx64, (val, ptr))
#define bfd_h_put_signed_64 \
  bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx64, (ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
  BFD_SEND (abfd, bfd_h_getx_signed_64, (ptr))

/* Refinements on the above, which should eventually go away.  Save
   cluttering the source with (bfd_vma) and (bfd_byte *) casts.  */

#define H_PUT_64(abfd, val, where) \
  bfd_h_put_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_32(abfd, val, where) \
  bfd_h_put_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_16(abfd, val, where) \
  bfd_h_put_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_8 bfd_h_put_8

#define H_PUT_S64(abfd, val, where) \
  bfd_h_put_signed_64 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S32(abfd, val, where) \
  bfd_h_put_signed_32 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S16(abfd, val, where) \
  bfd_h_put_signed_16 ((abfd), (bfd_vma) (val), (bfd_byte *) (where))

#define H_PUT_S8 bfd_h_put_signed_8

#define H_GET_64(abfd, where) \
  bfd_h_get_64 ((abfd), (bfd_byte *) (where))

#define H_GET_32(abfd, where) \
  bfd_h_get_32 ((abfd), (bfd_byte *) (where))

#define H_GET_16(abfd, where) \
  bfd_h_get_16 ((abfd), (bfd_byte *) (where))

#define H_GET_8 bfd_h_get_8

#define H_GET_S64(abfd, where) \
  bfd_h_get_signed_64 ((abfd), (bfd_byte *) (where))

#define H_GET_S32(abfd, where) \
  bfd_h_get_signed_32 ((abfd), (bfd_byte *) (where))

#define H_GET_S16(abfd, where) \
  bfd_h_get_signed_16 ((abfd), (bfd_byte *) (where))

#define H_GET_S8 bfd_h_get_signed_8


@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2 (bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.  A @@var{x} of 0 returns 0.

@


1.1.6.2
log
@Update generated files.
@
text
@d13 1
a13 1
boolean bfd_write_bigendian_4byte_int (bfd *, unsigned int);
@


1.1.4.1
log
@Add generated files to release branch.
@
text
@a0 156
@@section Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
void bfd_write_bigendian_4byte_int(bfd *abfd,  int i);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

/* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
                ((void) (*((unsigned char *) (ptr)) = (unsigned char) (val)))
#define bfd_put_signed_8 \
               bfd_put_8
#define bfd_get_8(abfd, ptr) \
                (*(unsigned char *) (ptr))
#define bfd_get_signed_8(abfd, ptr) \
               ((*(unsigned char *) (ptr) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
                bfd_put_16
#define bfd_get_16(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
                BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
                bfd_put_32
#define bfd_get_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
                bfd_put_64
#define bfd_get_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                               \
                ((bits) == 8 ? bfd_get_8 (abfd, ptr)           \
                : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
                : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
                : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
                : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                          \
                ((bits) == 8 ? bfd_put_8 (abfd, val, ptr)      \
                : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
                : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
                : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
                : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
bretheren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

/* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
               bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
               bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
               bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
               bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_h_putx16,(val,ptr))
#define bfd_h_put_signed_16 \
                bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx16,(ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_h_putx32,(val,ptr))
#define bfd_h_put_signed_32 \
                bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx32,(ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_h_putx64,(val, ptr))
#define bfd_h_put_signed_64 \
                bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx64,(ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr))

@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2(bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.

@


1.1.2.1
log
@Add generated files.
@
text
@a0 156
@@section Internal functions


@@strong{Description}@@*
These routines are used within BFD.
They are not intended for export, but are documented here for
completeness.

@@findex bfd_write_bigendian_4byte_int
@@subsubsection @@code{bfd_write_bigendian_4byte_int}
@@strong{Synopsis}
@@example
void bfd_write_bigendian_4byte_int(bfd *abfd,  int i);
@@end example
@@strong{Description}@@*
Write a 4 byte integer @@var{i} to the output BFD @@var{abfd}, in big
endian order regardless of what else is going on.  This is useful in
archives.

@@findex bfd_put_size
@@subsubsection @@code{bfd_put_size}
@@findex bfd_get_size
@@subsubsection @@code{bfd_get_size}
@@strong{Description}@@*
These macros as used for reading and writing raw data in
sections; each access (except for bytes) is vectored through
the target format of the BFD and mangled accordingly. The
mangling performs any necessary endian translations and
removes alignment restrictions.  Note that types accepted and
returned by these macros are identical so they can be swapped
around in macros---for example, @@file{libaout.h} defines @@code{GET_WORD}
to either @@code{bfd_get_32} or @@code{bfd_get_64}.

In the put routines, @@var{val} must be a @@code{bfd_vma}.  If we are on a
system without prototypes, the caller is responsible for making
sure that is true, with a cast if necessary.  We don't cast
them in the macro definitions because that would prevent @@code{lint}
or @@code{gcc -Wall} from detecting sins such as passing a pointer.
To detect calling these with less than a @@code{bfd_vma}, use
@@code{gcc -Wconversion} on a host with 64 bit @@code{bfd_vma}'s.
@@example

 /* Byte swapping macros for user section data.  */

#define bfd_put_8(abfd, val, ptr) \
                ((void) (*((unsigned char *)(ptr)) = (unsigned char)(val)))
#define bfd_put_signed_8 \
               bfd_put_8
#define bfd_get_8(abfd, ptr) \
                (*(unsigned char *)(ptr))
#define bfd_get_signed_8(abfd, ptr) \
               ((*(unsigned char *)(ptr) ^ 0x80) - 0x80)

#define bfd_put_16(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx16, ((val),(ptr)))
#define bfd_put_signed_16 \
                bfd_put_16
#define bfd_get_16(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx16, (ptr))
#define bfd_get_signed_16(abfd, ptr) \
                BFD_SEND (abfd, bfd_getx_signed_16, (ptr))

#define bfd_put_32(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx32, ((val),(ptr)))
#define bfd_put_signed_32 \
                bfd_put_32
#define bfd_get_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx32, (ptr))
#define bfd_get_signed_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_32, (ptr))

#define bfd_put_64(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_putx64, ((val), (ptr)))
#define bfd_put_signed_64 \
                bfd_put_64
#define bfd_get_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx64, (ptr))
#define bfd_get_signed_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_getx_signed_64, (ptr))

#define bfd_get(bits, abfd, ptr)                               \
                ((bits) == 8 ? bfd_get_8 (abfd, ptr)           \
                : (bits) == 16 ? bfd_get_16 (abfd, ptr)        \
                : (bits) == 32 ? bfd_get_32 (abfd, ptr)        \
                : (bits) == 64 ? bfd_get_64 (abfd, ptr)        \
                : (abort (), (bfd_vma) - 1))

#define bfd_put(bits, abfd, val, ptr)                          \
                ((bits) == 8 ? bfd_put_8 (abfd, val, ptr)      \
                : (bits) == 16 ? bfd_put_16 (abfd, val, ptr)   \
                : (bits) == 32 ? bfd_put_32 (abfd, val, ptr)   \
                : (bits) == 64 ? bfd_put_64 (abfd, val, ptr)   \
                : (abort (), (void) 0))

@@end example

@@findex bfd_h_put_size
@@subsubsection @@code{bfd_h_put_size}
@@strong{Description}@@*
These macros have the same function as their @@code{bfd_get_x}
bretheren, except that they are used for removing information
for the header records of object files. Believe it or not,
some object files keep their header records in big endian
order and their data in little endian order.
@@example

 /* Byte swapping macros for file header data.  */

#define bfd_h_put_8(abfd, val, ptr) \
               bfd_put_8 (abfd, val, ptr)
#define bfd_h_put_signed_8(abfd, val, ptr) \
               bfd_put_8 (abfd, val, ptr)
#define bfd_h_get_8(abfd, ptr) \
               bfd_get_8 (abfd, ptr)
#define bfd_h_get_signed_8(abfd, ptr) \
               bfd_get_signed_8 (abfd, ptr)

#define bfd_h_put_16(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_h_putx16,(val,ptr))
#define bfd_h_put_signed_16 \
                bfd_h_put_16
#define bfd_h_get_16(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx16,(ptr))
#define bfd_h_get_signed_16(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx_signed_16, (ptr))

#define bfd_h_put_32(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_h_putx32,(val,ptr))
#define bfd_h_put_signed_32 \
                bfd_h_put_32
#define bfd_h_get_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx32,(ptr))
#define bfd_h_get_signed_32(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx_signed_32, (ptr))

#define bfd_h_put_64(abfd, val, ptr) \
                BFD_SEND(abfd, bfd_h_putx64,(val, ptr))
#define bfd_h_put_signed_64 \
                bfd_h_put_64
#define bfd_h_get_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx64,(ptr))
#define bfd_h_get_signed_64(abfd, ptr) \
                BFD_SEND(abfd, bfd_h_getx_signed_64, (ptr))

@@end example

@@findex bfd_log2
@@subsubsection @@code{bfd_log2}
@@strong{Synopsis}
@@example
unsigned int bfd_log2(bfd_vma x);
@@end example
@@strong{Description}@@*
Return the log base 2 of the value supplied, rounded up.  E.g., an
@@var{x} of 1025 returns 11.

@

