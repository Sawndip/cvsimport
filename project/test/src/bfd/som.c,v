head	1.88;
access;
symbols
	sid-snapshot-20180601:1.88
	sid-snapshot-20180501:1.88
	sid-snapshot-20180401:1.88
	sid-snapshot-20180301:1.88
	sid-snapshot-20180201:1.88
	sid-snapshot-20180101:1.88
	sid-snapshot-20171201:1.88
	sid-snapshot-20171101:1.88
	sid-snapshot-20171001:1.88
	sid-snapshot-20170901:1.88
	sid-snapshot-20170801:1.88
	sid-snapshot-20170701:1.88
	sid-snapshot-20170601:1.88
	sid-snapshot-20170501:1.88
	sid-snapshot-20170401:1.88
	sid-snapshot-20170301:1.88
	sid-snapshot-20170201:1.88
	sid-snapshot-20170101:1.88
	sid-snapshot-20161201:1.88
	sid-snapshot-20161101:1.88
	sid-snapshot-20160901:1.88
	sid-snapshot-20160801:1.88
	sid-snapshot-20160701:1.88
	sid-snapshot-20160601:1.88
	sid-snapshot-20160501:1.88
	sid-snapshot-20160401:1.88
	sid-snapshot-20160301:1.88
	sid-snapshot-20160201:1.88
	sid-snapshot-20160101:1.88
	sid-snapshot-20151201:1.88
	sid-snapshot-20151101:1.88
	sid-snapshot-20151001:1.88
	sid-snapshot-20150901:1.88
	sid-snapshot-20150801:1.88
	sid-snapshot-20150701:1.88
	sid-snapshot-20150601:1.88
	sid-snapshot-20150501:1.88
	sid-snapshot-20150401:1.88
	sid-snapshot-20150301:1.88
	sid-snapshot-20150201:1.88
	sid-snapshot-20150101:1.88
	sid-snapshot-20141201:1.88
	sid-snapshot-20141101:1.88
	sid-snapshot-20141001:1.88
	sid-snapshot-20140901:1.88
	sid-snapshot-20140801:1.88
	sid-snapshot-20140701:1.88
	sid-snapshot-20140601:1.88
	sid-snapshot-20140501:1.88
	sid-snapshot-20140401:1.88
	sid-snapshot-20140301:1.88
	sid-snapshot-20140201:1.88
	sid-snapshot-20140101:1.88
	sid-snapshot-20131201:1.88
	sid-snapshot-20131101:1.88
	sid-snapshot-20131001:1.88
	binutils-2_24-branch:1.88.0.2
	binutils-2_24-branchpoint:1.88
	binutils-2_21_1:1.82.4.1
	sid-snapshot-20130901:1.88
	gdb_7_6_1-2013-08-30-release:1.87
	sid-snapshot-20130801:1.88
	sid-snapshot-20130701:1.88
	sid-snapshot-20130601:1.88
	sid-snapshot-20130501:1.88
	gdb_7_6-2013-04-26-release:1.87
	sid-snapshot-20130401:1.87
	binutils-2_23_2:1.86
	gdb_7_6-branch:1.87.0.2
	gdb_7_6-2013-03-12-branchpoint:1.87
	sid-snapshot-20130301:1.87
	sid-snapshot-20130201:1.87
	sid-snapshot-20130101:1.86
	sid-snapshot-20121201:1.86
	gdb_7_5_1-2012-11-29-release:1.86
	binutils-2_23_1:1.86
	sid-snapshot-20121101:1.86
	binutils-2_23:1.86
	sid-snapshot-20121001:1.86
	sid-snapshot-20120901:1.86
	gdb_7_5-2012-08-17-release:1.86
	sid-snapshot-20120801:1.86
	binutils-2_23-branch:1.86.0.4
	binutils-2_23-branchpoint:1.86
	gdb_7_5-branch:1.86.0.2
	gdb_7_5-2012-07-18-branchpoint:1.86
	sid-snapshot-20120701:1.86
	sid-snapshot-20120601:1.86
	sid-snapshot-20120501:1.85
	binutils-2_22_branch:1.85.0.6
	gdb_7_4_1-2012-04-26-release:1.85
	sid-snapshot-20120401:1.85
	sid-snapshot-20120301:1.85
	sid-snapshot-20120201:1.85
	gdb_7_4-2012-01-24-release:1.85
	sid-snapshot-20120101:1.85
	gdb_7_4-branch:1.85.0.4
	gdb_7_4-2011-12-13-branchpoint:1.85
	sid-snapshot-20111201:1.85
	binutils-2_22:1.85
	sid-snapshot-20111101:1.85
	sid-snapshot-20111001:1.85
	binutils-2_22-branch:1.85.0.2
	binutils-2_22-branchpoint:1.85
	gdb_7_3_1-2011-09-04-release:1.83
	sid-snapshot-20110901:1.85
	sid-snapshot-20110801:1.85
	gdb_7_3-2011-07-26-release:1.83
	sid-snapshot-20110701:1.84
	sid-snapshot-20110601:1.83
	sid-snapshot-20110501:1.83
	gdb_7_3-branch:1.83.0.2
	gdb_7_3-2011-04-01-branchpoint:1.83
	sid-snapshot-20110401:1.83
	sid-snapshot-20110301:1.83
	sid-snapshot-20110201:1.83
	sid-snapshot-20110101:1.82
	binutils-2_21:1.82
	sid-snapshot-20101201:1.82
	binutils-2_21-branch:1.82.0.4
	binutils-2_21-branchpoint:1.82
	sid-snapshot-20101101:1.82
	sid-snapshot-20101001:1.82
	binutils-2_20_1:1.76
	gdb_7_2-2010-09-02-release:1.82
	sid-snapshot-20100901:1.82
	sid-snapshot-20100801:1.82
	gdb_7_2-branch:1.82.0.2
	gdb_7_2-2010-07-07-branchpoint:1.82
	sid-snapshot-20100701:1.82
	sid-snapshot-20100601:1.79
	sid-snapshot-20100501:1.79
	sid-snapshot-20100401:1.79
	gdb_7_1-2010-03-18-release:1.79
	sid-snapshot-20100301:1.79
	gdb_7_1-branch:1.79.0.2
	gdb_7_1-2010-02-18-branchpoint:1.79
	sid-snapshot-20100201:1.79
	sid-snapshot-20100101:1.78
	gdb_7_0_1-2009-12-22-release:1.76
	sid-snapshot-20091201:1.77
	sid-snapshot-20091101:1.76
	binutils-2_20:1.76
	gdb_7_0-2009-10-06-release:1.76
	sid-snapshot-20091001:1.76
	gdb_7_0-branch:1.76.0.4
	gdb_7_0-2009-09-16-branchpoint:1.76
	arc-sim-20090309:1.70
	binutils-arc-20081103-branch:1.71.0.12
	binutils-arc-20081103-branchpoint:1.71
	binutils-2_20-branch:1.76.0.2
	binutils-2_20-branchpoint:1.76
	sid-snapshot-20090901:1.75
	sid-snapshot-20090801:1.74
	msnyder-checkpoint-072509-branch:1.74.0.4
	msnyder-checkpoint-072509-branchpoint:1.74
	sid-snapshot-20090701:1.74
	dje-cgen-play1-branch:1.74.0.2
	dje-cgen-play1-branchpoint:1.74
	sid-snapshot-20090601:1.74
	sid-snapshot-20090501:1.74
	sid-snapshot-20090401:1.73
	arc-20081103-branch:1.71.0.10
	arc-20081103-branchpoint:1.71
	arc-insight_6_8-branch:1.70.0.10
	arc-insight_6_8-branchpoint:1.70
	insight_6_8-branch:1.70.0.8
	insight_6_8-branchpoint:1.70
	sid-snapshot-20090301:1.71
	binutils-2_19_1:1.71
	sid-snapshot-20090201:1.71
	sid-snapshot-20090101:1.71
	reverse-20081226-branch:1.71.0.8
	reverse-20081226-branchpoint:1.71
	sid-snapshot-20081201:1.71
	multiprocess-20081120-branch:1.71.0.6
	multiprocess-20081120-branchpoint:1.71
	sid-snapshot-20081101:1.71
	binutils-2_19:1.71
	sid-snapshot-20081001:1.71
	reverse-20080930-branch:1.71.0.4
	reverse-20080930-branchpoint:1.71
	binutils-2_19-branch:1.71.0.2
	binutils-2_19-branchpoint:1.71
	sid-snapshot-20080901:1.71
	sid-snapshot-20080801:1.70
	reverse-20080717-branch:1.70.0.6
	reverse-20080717-branchpoint:1.70
	sid-snapshot-20080701:1.70
	msnyder-reverse-20080609-branch:1.70.0.4
	msnyder-reverse-20080609-branchpoint:1.70
	drow-reverse-20070409-branch:1.63.0.2
	drow-reverse-20070409-branchpoint:1.63
	sid-snapshot-20080601:1.70
	sid-snapshot-20080501:1.70
	sid-snapshot-20080403:1.70
	sid-snapshot-20080401:1.70
	gdb_6_8-2008-03-27-release:1.70
	sid-snapshot-20080301:1.70
	gdb_6_8-branch:1.70.0.2
	gdb_6_8-2008-02-26-branchpoint:1.70
	sid-snapshot-20080201:1.70
	sid-snapshot-20080101:1.70
	sid-snapshot-20071201:1.69
	sid-snapshot-20071101:1.69
	gdb_6_7_1-2007-10-29-release:1.66
	gdb_6_7-2007-10-10-release:1.66
	sid-snapshot-20071001:1.68
	gdb_6_7-branch:1.66.0.4
	gdb_6_7-2007-09-07-branchpoint:1.66
	binutils-2_18:1.66
	binutils-2_18-branch:1.66.0.2
	binutils-2_18-branchpoint:1.66
	insight_6_6-20070208-release:1.62
	binutils-csl-coldfire-4_1-32:1.59
	binutils-csl-sourcerygxx-4_1-32:1.59
	gdb_6_6-2006-12-18-release:1.62
	binutils-csl-innovasic-fido-3_4_4-33:1.59
	binutils-csl-sourcerygxx-3_4_4-32:1.51
	binutils-csl-coldfire-4_1-30:1.59
	binutils-csl-sourcerygxx-4_1-30:1.59
	binutils-csl-coldfire-4_1-28:1.59
	binutils-csl-sourcerygxx-4_1-29:1.59
	binutils-csl-sourcerygxx-4_1-28:1.59
	gdb_6_6-branch:1.62.0.2
	gdb_6_6-2006-11-15-branchpoint:1.62
	binutils-csl-arm-2006q3-27:1.59
	binutils-csl-sourcerygxx-4_1-27:1.59
	binutils-csl-arm-2006q3-26:1.59
	binutils-csl-sourcerygxx-4_1-26:1.59
	binutils-csl-sourcerygxx-4_1-25:1.59
	binutils-csl-sourcerygxx-4_1-24:1.59
	binutils-csl-sourcerygxx-4_1-23:1.59
	insight_6_5-20061003-release:1.60
	gdb-csl-symbian-6_4_50_20060226-12:1.59
	binutils-csl-sourcerygxx-4_1-21:1.59
	binutils-csl-arm-2006q3-21:1.59
	binutils-csl-sourcerygxx-4_1-22:1.59
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.59
	binutils-csl-sourcerygxx-4_1-20:1.59
	binutils-csl-arm-2006q3-19:1.59
	binutils-csl-sourcerygxx-4_1-19:1.59
	binutils-csl-sourcerygxx-4_1-18:1.59
	binutils-csl-renesas-4_1-9:1.59
	gdb-csl-sourcerygxx-3_4_4-25:1.58
	binutils-csl-sourcerygxx-3_4_4-25:1.51
	nickrob-async-20060828-mergepoint:1.61
	gdb-csl-symbian-6_4_50_20060226-11:1.59
	binutils-csl-renesas-4_1-8:1.59
	binutils-csl-renesas-4_1-7:1.59
	binutils-csl-renesas-4_1-6:1.59
	gdb-csl-sourcerygxx-4_1-17:1.59
	binutils-csl-sourcerygxx-4_1-17:1.59
	gdb-csl-20060226-branch-local-2:1.59
	gdb-csl-sourcerygxx-4_1-14:1.59
	binutils-csl-sourcerygxx-4_1-14:1.59
	binutils-csl-sourcerygxx-4_1-15:1.59
	gdb-csl-sourcerygxx-4_1-13:1.59
	binutils-csl-sourcerygxx-4_1-13:1.59
	binutils-2_17:1.59
	gdb-csl-sourcerygxx-4_1-12:1.59
	binutils-csl-sourcerygxx-4_1-12:1.59
	gdb-csl-sourcerygxx-3_4_4-21:1.59
	binutils-csl-sourcerygxx-3_4_4-21:1.59
	gdb_6_5-20060621-release:1.60
	binutils-csl-wrs-linux-3_4_4-24:1.51
	binutils-csl-wrs-linux-3_4_4-23:1.51
	gdb-csl-sourcerygxx-4_1-9:1.59
	binutils-csl-sourcerygxx-4_1-9:1.59
	gdb-csl-sourcerygxx-4_1-8:1.59
	binutils-csl-sourcerygxx-4_1-8:1.59
	gdb-csl-sourcerygxx-4_1-7:1.59
	binutils-csl-sourcerygxx-4_1-7:1.59
	gdb-csl-arm-2006q1-6:1.59
	binutils-csl-arm-2006q1-6:1.59
	gdb-csl-sourcerygxx-4_1-6:1.59
	binutils-csl-sourcerygxx-4_1-6:1.59
	binutils-csl-wrs-linux-3_4_4-22:1.51
	gdb-csl-symbian-6_4_50_20060226-10:1.59
	gdb-csl-symbian-6_4_50_20060226-9:1.59
	gdb-csl-symbian-6_4_50_20060226-8:1.59
	gdb-csl-coldfire-4_1-11:1.59
	binutils-csl-coldfire-4_1-11:1.59
	gdb-csl-sourcerygxx-3_4_4-19:1.59
	binutils-csl-sourcerygxx-3_4_4-19:1.59
	gdb-csl-coldfire-4_1-10:1.59
	gdb_6_5-branch:1.60.0.4
	gdb_6_5-2006-05-14-branchpoint:1.60
	binutils-csl-coldfire-4_1-10:1.59
	gdb-csl-sourcerygxx-4_1-5:1.59
	binutils-csl-sourcerygxx-4_1-5:1.59
	nickrob-async-20060513-branch:1.60.0.2
	nickrob-async-20060513-branchpoint:1.60
	gdb-csl-sourcerygxx-4_1-4:1.59
	binutils-csl-sourcerygxx-4_1-4:1.59
	msnyder-reverse-20060502-branch:1.59.0.18
	msnyder-reverse-20060502-branchpoint:1.59
	binutils-csl-wrs-linux-3_4_4-21:1.51
	gdb-csl-morpho-4_1-4:1.59
	binutils-csl-morpho-4_1-4:1.59
	gdb-csl-sourcerygxx-3_4_4-17:1.59
	binutils-csl-sourcerygxx-3_4_4-17:1.59
	binutils-csl-wrs-linux-3_4_4-20:1.51
	readline_5_1-import-branch:1.59.0.16
	readline_5_1-import-branchpoint:1.59
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.59
	binutils-2_17-branch:1.59.0.14
	binutils-2_17-branchpoint:1.59
	gdb-csl-symbian-20060226-branch:1.59.0.12
	gdb-csl-symbian-20060226-branchpoint:1.59
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.59
	msnyder-reverse-20060331-branch:1.59.0.10
	msnyder-reverse-20060331-branchpoint:1.59
	binutils-csl-2_17-branch:1.59.0.8
	binutils-csl-2_17-branchpoint:1.59
	gdb-csl-available-20060303-branch:1.59.0.6
	gdb-csl-available-20060303-branchpoint:1.59
	gdb-csl-20060226-branch:1.59.0.4
	gdb-csl-20060226-branchpoint:1.59
	gdb_6_4-20051202-release:1.58
	msnyder-fork-checkpoint-branch:1.59.0.2
	msnyder-fork-checkpoint-branchpoint:1.59
	gdb-csl-gxxpro-6_3-branch:1.58.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.58
	gdb_6_4-branch:1.58.0.4
	gdb_6_4-2005-11-01-branchpoint:1.58
	gdb-csl-arm-20051020-branch:1.58.0.2
	gdb-csl-arm-20051020-branchpoint:1.58
	binutils-csl-gxxpro-3_4-branch:1.51.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.51
	binutils-2_16_1:1.51
	msnyder-tracepoint-checkpoint-branch:1.57.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.57
	gdb-csl-arm-20050325-2005-q1b:1.51
	binutils-csl-arm-2005q1b:1.51
	binutils-2_16:1.51
	gdb-csl-arm-20050325-2005-q1a:1.51
	binutils-csl-arm-2005q1a:1.51
	csl-arm-20050325-branch:1.51.0.6
	csl-arm-20050325-branchpoint:1.51
	binutils-csl-arm-2005q1-branch:1.51.0.4
	binutils-csl-arm-2005q1-branchpoint:1.51
	binutils-2_16-branch:1.51.0.2
	binutils-2_16-branchpoint:1.51
	csl-arm-2004-q3d:1.48
	gdb_6_3-20041109-release:1.48
	gdb_6_3-branch:1.48.0.2
	gdb_6_3-20041019-branchpoint:1.48
	csl-arm-2004-q3:1.47
	drow_intercu-merge-20040921:1.47
	drow_intercu-merge-20040915:1.47
	jimb-gdb_6_2-e500-branch:1.45.0.6
	jimb-gdb_6_2-e500-branchpoint:1.45
	gdb_6_2-20040730-release:1.45
	gdb_6_2-branch:1.45.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.45
	gdb_6_1_1-20040616-release:1.38
	binutils-2_15:1.38
	binutils-2_15-branchpoint:1.38
	csl-arm-2004-q1a:1.41
	csl-arm-2004-q1:1.38
	gdb_6_1-2004-04-05-release:1.38
	drow_intercu-merge-20040402:1.38
	drow_intercu-merge-20040327:1.38
	ezannoni_pie-20040323-branch:1.38.0.14
	ezannoni_pie-20040323-branchpoint:1.38
	cagney_tramp-20040321-mergepoint:1.38
	cagney_tramp-20040309-branch:1.38.0.12
	cagney_tramp-20040309-branchpoint:1.38
	gdb_6_1-branch:1.38.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.38
	drow_intercu-20040221-branch:1.38.0.8
	drow_intercu-20040221-branchpoint:1.38
	binutils-2_15-branch:1.38.0.6
	cagney_bfdfile-20040213-branch:1.38.0.4
	cagney_bfdfile-20040213-branchpoint:1.38
	drow-cplus-merge-20040208:1.38
	carlton_dictionary-20040126-merge:1.38
	cagney_bigcore-20040122-branch:1.38.0.2
	cagney_bigcore-20040122-branchpoint:1.38
	drow-cplus-merge-20040113:1.38
	csl-arm-2003-q4:1.38
	drow-cplus-merge-20031224:1.38
	drow-cplus-merge-20031220:1.38
	carlton_dictionary-20031215-merge:1.38
	drow-cplus-merge-20031214:1.38
	carlton-dictionary-20031111-merge:1.37
	gdb_6_0-2003-10-04-release:1.36
	kettenis_sparc-20030918-branch:1.36.0.36
	kettenis_sparc-20030918-branchpoint:1.36
	carlton_dictionary-20030917-merge:1.36
	ezannoni_pie-20030916-branchpoint:1.36
	ezannoni_pie-20030916-branch:1.36.0.34
	cagney_x86i386-20030821-branch:1.36.0.32
	cagney_x86i386-20030821-branchpoint:1.36
	carlton_dictionary-20030805-merge:1.36
	carlton_dictionary-20030627-merge:1.36
	gdb_6_0-branch:1.36.0.30
	gdb_6_0-2003-06-23-branchpoint:1.36
	jimb-ppc64-linux-20030613-branch:1.36.0.28
	jimb-ppc64-linux-20030613-branchpoint:1.36
	binutils-2_14:1.36
	cagney_convert-20030606-branch:1.36.0.26
	cagney_convert-20030606-branchpoint:1.36
	cagney_writestrings-20030508-branch:1.36.0.24
	cagney_writestrings-20030508-branchpoint:1.36
	jimb-ppc64-linux-20030528-branch:1.36.0.22
	jimb-ppc64-linux-20030528-branchpoint:1.36
	carlton_dictionary-20030523-merge:1.36
	cagney_fileio-20030521-branch:1.36.0.20
	cagney_fileio-20030521-branchpoint:1.36
	kettenis_i386newframe-20030517-mergepoint:1.36
	jimb-ppc64-linux-20030509-branch:1.36.0.18
	jimb-ppc64-linux-20030509-branchpoint:1.36
	kettenis_i386newframe-20030504-mergepoint:1.36
	carlton_dictionary-20030430-merge:1.36
	binutils-2_14-branch:1.36.0.16
	binutils-2_14-branchpoint:1.36
	kettenis_i386newframe-20030419-branch:1.36.0.14
	kettenis_i386newframe-20030419-branchpoint:1.36
	carlton_dictionary-20030416-merge:1.36
	cagney_frameaddr-20030409-mergepoint:1.36
	kettenis_i386newframe-20030406-branch:1.36.0.12
	kettenis_i386newframe-20030406-branchpoint:1.36
	cagney_frameaddr-20030403-branchpoint:1.36
	cagney_frameaddr-20030403-branch:1.36.0.10
	cagney_framebase-20030330-mergepoint:1.36
	cagney_framebase-20030326-branch:1.36.0.8
	cagney_framebase-20030326-branchpoint:1.36
	cagney_lazyid-20030317-branch:1.36.0.6
	cagney_lazyid-20030317-branchpoint:1.36
	kettenis-i386newframe-20030316-mergepoint:1.36
	offbyone-20030313-branch:1.36.0.4
	offbyone-20030313-branchpoint:1.36
	kettenis-i386newframe-20030308-branch:1.36.0.2
	kettenis-i386newframe-20030308-branchpoint:1.36
	carlton_dictionary-20030305-merge:1.35
	cagney_offbyone-20030303-branch:1.35.0.6
	cagney_offbyone-20030303-branchpoint:1.35
	carlton_dictionary-20030207-merge:1.35
	interps-20030202-branch:1.35.0.4
	interps-20030202-branchpoint:1.35
	cagney-unwind-20030108-branch:1.35.0.2
	cagney-unwind-20030108-branchpoint:1.35
	binutils-2_13_2_1:1.33
	binutils-2_13_2:1.33
	carlton_dictionary-20021223-merge:1.35
	gdb_5_3-2002-12-12-release:1.33
	carlton_dictionary-20021115-merge:1.33
	binutils-2_13_1:1.33
	kseitz_interps-20021105-merge:1.33
	kseitz_interps-20021103-merge:1.33
	drow-cplus-merge-20021020:1.33
	drow-cplus-merge-20021025:1.33
	carlton_dictionary-20021025-merge:1.33
	carlton_dictionary-20021011-merge:1.33
	drow-cplus-branch:1.33.0.14
	drow-cplus-branchpoint:1.33
	kseitz_interps-20020930-merge:1.33
	carlton_dictionary-20020927-merge:1.33
	carlton_dictionary-branch:1.33.0.12
	carlton_dictionary-20020920-branchpoint:1.33
	sid-20020905-branchpoint:1.33
	sid-20020905-branch:1.33.0.10
	gdb_5_3-branch:1.33.0.8
	gdb_5_3-2002-09-04-branchpoint:1.33
	kseitz_interps-20020829-merge:1.33
	cagney_sysregs-20020825-branch:1.33.0.6
	cagney_sysregs-20020825-branchpoint:1.33
	readline_4_3-import-branch:1.33.0.4
	readline_4_3-import-branchpoint:1.33
	binutils-2_13:1.33
	gdb_5_2_1-2002-07-23-release:1.28
	binutils-2_13-branchpoint:1.33
	binutils-2_13-branch:1.33.0.2
	kseitz_interps-20020528-branch:1.30.0.2
	kseitz_interps-20020528-branchpoint:1.30
	cagney_regbuf-20020515-branch:1.29.0.4
	cagney_regbuf-20020515-branchpoint:1.29
	binutils-2_12_1:1.28
	jimb-macro-020506-branch:1.29.0.2
	jimb-macro-020506-branchpoint:1.29
	gdb_5_2-2002-04-29-release:1.28
	binutils-2_12:1.28
	gdb_5_2-branch:1.28.0.4
	gdb_5_2-2002-03-03-branchpoint:1.28
	binutils-2_12-branch:1.28.0.2
	binutils-2_12-branchpoint:1.28
	gdb_5_1_1-2002-01-24-release:1.19
	gdb_5_1_0_1-2002-01-03-release:1.19
	cygnus_cvs_20020108_pre:1.27
	gdb_5_1_0_1-2002-01-03-branch:1.19.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.19
	gdb_5_1-2001-11-21-release:1.19
	gdb_s390-2001-09-26-branch:1.19.0.4
	gdb_s390-2001-09-26-branchpoint:1.19
	gdb_5_1-2001-07-29-branch:1.19.0.2
	gdb_5_1-2001-07-29-branchpoint:1.19
	binutils-2_11_2:1.17.2.1
	binutils-2_11_1:1.17.2.1
	binutils-2_11:1.17
	x86_64versiong3:1.17
	binutils-2_11-branch:1.17.0.2
	insight-precleanup-2001-01-01:1.16
	binutils-2_10_1:1.10
	binutils-2_10:1.10
	gdb-premipsmulti-2000-06-06-branch:1.11.0.2
	gdb-premipsmulti-2000-06-06-branchpoint:1.11
	gdb_5_0-2000-05-19-release:1.10
	gdb_4_18_2-2000-05-18-release:1.10
	gdb_4_95_1-2000-05-11-snapshot:1.10
	gdb_4_95_0-2000-04-27-snapshot:1.10
	gdb_5_0-2000-04-10-branch:1.10.0.4
	gdb_5_0-2000-04-10-branchpoint:1.10
	binutils-2_10-branch:1.10.0.2
	binutils-2_10-branchpoint:1.10
	binutils_latest_snapshot:1.88
	repo-unification-2000-02-06:1.8
	binu_ss_19990721:1.3
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.88
date	2013.04.08.20.08.21;	author tromey;	state Exp;
branches;
next	1.87;

1.87
date	2013.01.10.20.03.55;	author hjl;	state Exp;
branches;
next	1.86;

1.86
date	2012.05.17.15.13.20;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2011.07.11.15.03.07;	author clm;	state Exp;
branches;
next	1.84;

1.84
date	2011.06.06.01.26.03;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2011.01.14.12.35.55;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2010.06.27.04.07.53;	author amodra;	state Exp;
branches
	1.82.4.1;
next	1.81;

1.81
date	2010.06.10.08.51.44;	author gingold;	state Exp;
branches;
next	1.80;

1.80
date	2010.06.08.15.43.38;	author gingold;	state Exp;
branches;
next	1.79;

1.79
date	2010.02.01.13.10.38;	author gingold;	state Exp;
branches;
next	1.78;

1.78
date	2009.12.11.15.42.38;	author gingold;	state Exp;
branches;
next	1.77;

1.77
date	2009.11.23.14.41.30;	author pbrook;	state Exp;
branches;
next	1.76;

1.76
date	2009.09.02.07.18.37;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2009.08.29.22.10.58;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2009.04.16.23.06.58;	author rsandifo;	state Exp;
branches;
next	1.73;

1.73
date	2009.03.18.11.27.17;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2009.03.07.23.38.13;	author danglin;	state Exp;
branches;
next	1.71;

1.71
date	2008.08.28.02.33.44;	author danglin;	state Exp;
branches;
next	1.70;

1.70
date	2007.12.29.01.36.40;	author danglin;	state Exp;
branches;
next	1.69;

1.69
date	2007.10.16.15.15.50;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2007.09.26.08.12.59;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2007.09.21.07.58.03;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2007.07.03.14.26.42;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.27.11.54.09;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2007.04.26.14.46.58;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2007.03.26.12.23.03;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2006.06.19.13.17.43;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.03.14.26.40;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2005.11.20.19.21.06;	author danglin;	state Exp;
branches;
next	1.58;

1.58
date	2005.06.15.00.16.10;	author danglin;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.22.20.02.16;	author danglin;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.04.15.53.38;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.04.07.19.36;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2005.04.21.10.47.49;	author guitton;	state Exp;
branches;
next	1.53;

1.53
date	2005.04.17.12.45.30;	author kettenis;	state Exp;
branches;
next	1.52;

1.52
date	2005.04.11.08.23.03;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2005.03.03.11.41.01;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.31.23.13.30;	author bje;	state Exp;
branches;
next	1.49;

1.49
date	2004.11.09.17.40.22;	author mmitchel;	state Exp;
branches;
next	1.48;

1.48
date	2004.10.09.02.51.31;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.28.22.23.53;	author danglin;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.25.18.30.54;	author brobecke;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.24.04.46.26;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2004.05.17.16.40.01;	author bwilson;	state Exp;
branches;
next	1.42;

1.42
date	2004.05.14.17.42.47;	author danglin;	state Exp;
branches;
next	1.41;

1.41
date	2004.05.02.06.21.08;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.28.18.02.48;	author danglin;	state Exp;
branches;
next	1.39;

1.39
date	2004.04.22.23.17.07;	author danglin;	state Exp;
branches;
next	1.38;

1.38
date	2003.11.30.18.40.41;	author kazu;	state Exp;
branches
	1.38.8.1;
next	1.37;

1.37
date	2003.10.16.04.11.08;	author cagney;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.06.12.29.04;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2002.12.20.22.41.13;	author kazu;	state Exp;
branches;
next	1.34;

1.34
date	2002.11.30.08.39.40;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.25.06.21.54;	author amodra;	state Exp;
branches
	1.33.12.1
	1.33.14.1;
next	1.32;

1.32
date	2002.06.07.15.04.48;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.06.05.03.43.11;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.05.15.00.18.58;	author amodra;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2002.04.04.19.53.38;	author drow;	state Exp;
branches
	1.29.4.1;
next	1.28;

1.28
date	2002.01.21.14.03.24;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.11.02.16.19.54;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2001.10.10.12.08.28;	author kazu;	state Exp;
branches;
next	1.25;

1.25
date	2001.10.05.21.55.11;	author law;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.29.06.13.53;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.28.21.35.45;	author brobecke;	state Exp;
branches;
next	1.22;

1.22
date	2001.09.19.05.33.12;	author hjl;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.18.09.57.26;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2001.08.23.15.45.19;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.11.12.23.47;	author jakub;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.08.21.04.02;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.04.23.27.08;	author kazu;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2000.12.14.21.38.31;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.28.08.08.16;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2000.09.26.01.45.26;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.14.01.33.46;	author law;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.04.15.17.37;	author law;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.16.14.20.09;	author clm;	state Exp;
branches;
next	1.10;

1.10
date	2000.02.26.01.45.22;	author law;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.24.13.41.02;	author clm;	state Exp;
branches;
next	1.8;

1.8
date	99.12.10.18.51.35;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.12.10.01.41.22;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	99.11.02.08.46.25;	author law;	state Exp;
branches;
next	1.5;

1.5
date	99.09.19.18.22.20;	author law;	state Exp;
branches;
next	1.4;

1.4
date	99.08.24.06.26.39;	author law;	state Exp;
branches;
next	1.3;

1.3
date	99.07.19.14.55.16;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.05.03.09.12.29;	author law;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.82.4.1
date	2011.02.01.12.25.34;	author amodra;	state Exp;
branches;
next	;

1.38.8.1
date	2004.09.16.17.00.37;	author drow;	state Exp;
branches;
next	;

1.33.12.1
date	2002.12.23.19.37.59;	author carlton;	state Exp;
branches;
next	1.33.12.2;

1.33.12.2
date	2003.04.16.19.56.47;	author carlton;	state Exp;
branches;
next	1.33.12.3;

1.33.12.3
date	2003.11.11.23.50.28;	author carlton;	state Exp;
branches;
next	1.33.12.4;

1.33.12.4
date	2003.12.15.23.59.52;	author carlton;	state Exp;
branches;
next	;

1.33.14.1
date	2003.12.14.20.26.51;	author drow;	state Exp;
branches;
next	;

1.30.2.1
date	2002.06.20.01.31.09;	author kseitz;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	2002.07.22.21.46.49;	author kseitz;	state Exp;
branches;
next	;

1.29.4.1
date	2002.06.15.16.42.40;	author cagney;	state Exp;
branches;
next	;

1.17.2.1
date	2001.06.07.03.08.26;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.58;	author rth;	state Exp;
branches;
next	;


desc
@@


1.88
log
@	PR symtab/8423:
	* solib-som.c (som_solib_section_offsets): Use BFD section
	indices.  Set offsets for all sections.
	* somread.c (som_symtab_read): Compute BFD section for
	symbol.  Use prim_record_minimal_symbol_and_info.
	(som_symfile_read): Fix comment.
	(struct find_section_offset_arg): New.
	(find_section_offset, set_section_index): New functions.
	(som_symfile_offsets): Use set_section_index to compute
	section indices.
bfd/
	* som.c (bfd_section_from_som_symbol): No longer static.
	* som.h (bfd_section_from_som_symbol): Declare.
@
text
@/* bfd back-end for HP PA-RISC SOM objects.
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
   2012, 2013  Free Software Foundation, Inc.

   Contributed by the Center for Software Science at the
   University of Utah.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "sysdep.h"
#include "alloca-conf.h"
#include "bfd.h"

#include "libbfd.h"
#include "som.h"
#include "safe-ctype.h"
#include "som/reloc.h"
#include "aout/ar.h"

static bfd_reloc_status_type hppa_som_reloc
  (bfd *, arelent *, asymbol *, void *, asection *, bfd *, char **);
static bfd_boolean som_mkobject (bfd *);
static bfd_boolean som_is_space (asection *);
static bfd_boolean som_is_subspace (asection *);
static int compare_subspaces (const void *, const void *);
static unsigned long som_compute_checksum (struct som_external_header *);
static bfd_boolean som_build_and_write_symbol_table (bfd *);
static unsigned int som_slurp_symbol_table (bfd *);

/* Magic not defined in standard HP-UX header files until 8.0.  */

#ifndef CPU_PA_RISC1_0
#define CPU_PA_RISC1_0 0x20B
#endif /* CPU_PA_RISC1_0 */

#ifndef CPU_PA_RISC1_1
#define CPU_PA_RISC1_1 0x210
#endif /* CPU_PA_RISC1_1 */

#ifndef CPU_PA_RISC2_0
#define CPU_PA_RISC2_0 0x214
#endif /* CPU_PA_RISC2_0 */

#ifndef _PA_RISC1_0_ID
#define _PA_RISC1_0_ID CPU_PA_RISC1_0
#endif /* _PA_RISC1_0_ID */

#ifndef _PA_RISC1_1_ID
#define _PA_RISC1_1_ID CPU_PA_RISC1_1
#endif /* _PA_RISC1_1_ID */

#ifndef _PA_RISC2_0_ID
#define _PA_RISC2_0_ID CPU_PA_RISC2_0
#endif /* _PA_RISC2_0_ID */

#ifndef _PA_RISC_MAXID
#define _PA_RISC_MAXID	0x2FF
#endif /* _PA_RISC_MAXID */

#ifndef _PA_RISC_ID
#define _PA_RISC_ID(__m_num)		\
    (((__m_num) == _PA_RISC1_0_ID) ||	\
     ((__m_num) >= _PA_RISC1_1_ID && (__m_num) <= _PA_RISC_MAXID))
#endif /* _PA_RISC_ID */

/* HIUX in it's infinite stupidity changed the names for several "well
   known" constants.  Work around such braindamage.  Try the HPUX version
   first, then the HIUX version, and finally provide a default.  */
#ifdef HPUX_AUX_ID
#define EXEC_AUX_ID HPUX_AUX_ID
#endif

#if !defined (EXEC_AUX_ID) && defined (HIUX_AUX_ID)
#define EXEC_AUX_ID HIUX_AUX_ID
#endif

#ifndef EXEC_AUX_ID
#define EXEC_AUX_ID 0
#endif

/* Size (in chars) of the temporary buffers used during fixup and string
   table writes.   */

#define SOM_TMP_BUFSIZE 8192

/* Size of the hash table in archives.  */
#define SOM_LST_HASH_SIZE 31

/* Max number of SOMs to be found in an archive.  */
#define SOM_LST_MODULE_LIMIT 1024

/* Generic alignment macro.  */
#define SOM_ALIGN(val, alignment) \
  (((val) + (alignment) - 1) &~ ((unsigned long) (alignment) - 1))

/* SOM allows any one of the four previous relocations to be reused
   with a "R_PREV_FIXUP" relocation entry.  Since R_PREV_FIXUP
   relocations are always a single byte, using a R_PREV_FIXUP instead
   of some multi-byte relocation makes object files smaller.

   Note one side effect of using a R_PREV_FIXUP is the relocation that
   is being repeated moves to the front of the queue.  */
struct reloc_queue
{
  unsigned char *reloc;
  unsigned int size;
} reloc_queue[4];

/* This fully describes the symbol types which may be attached to
   an EXPORT or IMPORT directive.  Only SOM uses this formation
   (ELF has no need for it).  */
typedef enum
{
  SYMBOL_TYPE_UNKNOWN,
  SYMBOL_TYPE_ABSOLUTE,
  SYMBOL_TYPE_CODE,
  SYMBOL_TYPE_DATA,
  SYMBOL_TYPE_ENTRY,
  SYMBOL_TYPE_MILLICODE,
  SYMBOL_TYPE_PLABEL,
  SYMBOL_TYPE_PRI_PROG,
  SYMBOL_TYPE_SEC_PROG,
} pa_symbol_type;

struct section_to_type
{
  const char *section;
  char type;
};

/* Assorted symbol information that needs to be derived from the BFD symbol
   and/or the BFD backend private symbol data.  */
struct som_misc_symbol_info
{
  unsigned int symbol_type;
  unsigned int symbol_scope;
  unsigned int arg_reloc;
  unsigned int symbol_info;
  unsigned int symbol_value;
  unsigned int priv_level;
  unsigned int secondary_def;
  unsigned int is_comdat;
  unsigned int is_common;
  unsigned int dup_common;
};

/* Map SOM section names to POSIX/BSD single-character symbol types.

   This table includes all the standard subspaces as defined in the
   current "PRO ABI for PA-RISC Systems", $UNWIND$ which for
   some reason was left out, and sections specific to embedded stabs.  */

static const struct section_to_type stt[] =
{
  {"$TEXT$", 't'},
  {"$SHLIB_INFO$", 't'},
  {"$MILLICODE$", 't'},
  {"$LIT$", 't'},
  {"$CODE$", 't'},
  {"$UNWIND_START$", 't'},
  {"$UNWIND$", 't'},
  {"$PRIVATE$", 'd'},
  {"$PLT$", 'd'},
  {"$SHLIB_DATA$", 'd'},
  {"$DATA$", 'd'},
  {"$SHORTDATA$", 'g'},
  {"$DLT$", 'd'},
  {"$GLOBAL$", 'g'},
  {"$SHORTBSS$", 's'},
  {"$BSS$", 'b'},
  {"$GDB_STRINGS$", 'N'},
  {"$GDB_SYMBOLS$", 'N'},
  {0, 0}
};

/* About the relocation formatting table...

   There are 256 entries in the table, one for each possible
   relocation opcode available in SOM.  We index the table by
   the relocation opcode.  The names and operations are those
   defined by a.out_800 (4).

   Right now this table is only used to count and perform minimal
   processing on relocation streams so that they can be internalized
   into BFD and symbolically printed by utilities.  To make actual use
   of them would be much more difficult, BFD's concept of relocations
   is far too simple to handle SOM relocations.  The basic assumption
   that a relocation can be completely processed independent of other
   relocations before an object file is written is invalid for SOM.

   The SOM relocations are meant to be processed as a stream, they
   specify copying of data from the input section to the output section
   while possibly modifying the data in some manner.  They also can
   specify that a variable number of zeros or uninitialized data be
   inserted on in the output segment at the current offset.  Some
   relocations specify that some previous relocation be re-applied at
   the current location in the input/output sections.  And finally a number
   of relocations have effects on other sections (R_ENTRY, R_EXIT,
   R_UNWIND_AUX and a variety of others).  There isn't even enough room
   in the BFD relocation data structure to store enough information to
   perform all the relocations.

   Each entry in the table has three fields.

   The first entry is an index into this "class" of relocations.  This
   index can then be used as a variable within the relocation itself.

   The second field is a format string which actually controls processing
   of the relocation.  It uses a simple postfix machine to do calculations
   based on variables/constants found in the string and the relocation
   stream.

   The third field specifys whether or not this relocation may use
   a constant (V) from the previous R_DATA_OVERRIDE rather than a constant
   stored in the instruction.

   Variables:

   L = input space byte count
   D = index into class of relocations
   M = output space byte count
   N = statement number (unused?)
   O = stack operation
   R = parameter relocation bits
   S = symbol index
   T = first 32 bits of stack unwind information
   U = second 32 bits of stack unwind information
   V = a literal constant (usually used in the next relocation)
   P = a previous relocation

   Lower case letters (starting with 'b') refer to following
   bytes in the relocation stream.  'b' is the next 1 byte,
   c is the next 2 bytes, d is the next 3 bytes, etc...
   This is the variable part of the relocation entries that
   makes our life a living hell.

   numerical constants are also used in the format string.  Note
   the constants are represented in decimal.

   '+', "*" and "=" represents the obvious postfix operators.
   '<' represents a left shift.

   Stack Operations:

   Parameter Relocation Bits:

   Unwind Entries:

   Previous Relocations:  The index field represents which in the queue
   of 4 previous fixups should be re-applied.

   Literal Constants:  These are generally used to represent addend
   parts of relocations when these constants are not stored in the
   fields of the instructions themselves.  For example the instruction
   addil foo-$global$-0x1234 would use an override for "0x1234" rather
   than storing it into the addil itself.  */

struct fixup_format
{
  int D;
  const char *format;
};

static const struct fixup_format som_fixup_formats[256] =
{
  /* R_NO_RELOCATION.  */
  {  0, "LD1+4*=" },		/* 0x00 */
  {  1, "LD1+4*=" },		/* 0x01 */
  {  2, "LD1+4*=" },		/* 0x02 */
  {  3, "LD1+4*=" },		/* 0x03 */
  {  4, "LD1+4*=" },		/* 0x04 */
  {  5, "LD1+4*=" },		/* 0x05 */
  {  6, "LD1+4*=" },		/* 0x06 */
  {  7, "LD1+4*=" },		/* 0x07 */
  {  8, "LD1+4*=" },		/* 0x08 */
  {  9, "LD1+4*=" },		/* 0x09 */
  { 10, "LD1+4*=" },		/* 0x0a */
  { 11, "LD1+4*=" },		/* 0x0b */
  { 12, "LD1+4*=" },		/* 0x0c */
  { 13, "LD1+4*=" },		/* 0x0d */
  { 14, "LD1+4*=" },		/* 0x0e */
  { 15, "LD1+4*=" },		/* 0x0f */
  { 16, "LD1+4*=" },		/* 0x10 */
  { 17, "LD1+4*=" },		/* 0x11 */
  { 18, "LD1+4*=" },		/* 0x12 */
  { 19, "LD1+4*=" },		/* 0x13 */
  { 20, "LD1+4*=" },		/* 0x14 */
  { 21, "LD1+4*=" },		/* 0x15 */
  { 22, "LD1+4*=" },		/* 0x16 */
  { 23, "LD1+4*=" },		/* 0x17 */
  {  0, "LD8<b+1+4*=" },	/* 0x18 */
  {  1, "LD8<b+1+4*=" },	/* 0x19 */
  {  2, "LD8<b+1+4*=" },	/* 0x1a */
  {  3, "LD8<b+1+4*=" },	/* 0x1b */
  {  0, "LD16<c+1+4*=" },	/* 0x1c */
  {  1, "LD16<c+1+4*=" },	/* 0x1d */
  {  2, "LD16<c+1+4*=" },	/* 0x1e */
  {  0, "Ld1+=" },		/* 0x1f */
  /* R_ZEROES.  */
  {  0, "Lb1+4*=" },		/* 0x20 */
  {  1, "Ld1+=" },		/* 0x21 */
  /* R_UNINIT.  */
  {  0, "Lb1+4*=" },		/* 0x22 */
  {  1, "Ld1+=" },		/* 0x23 */
  /* R_RELOCATION.  */
  {  0, "L4=" },		/* 0x24 */
  /* R_DATA_ONE_SYMBOL.  */
  {  0, "L4=Sb=" },		/* 0x25 */
  {  1, "L4=Sd=" },		/* 0x26 */
  /* R_DATA_PLABEL.  */
  {  0, "L4=Sb=" },		/* 0x27 */
  {  1, "L4=Sd=" },		/* 0x28 */
  /* R_SPACE_REF.  */
  {  0, "L4=" },		/* 0x29 */
  /* R_REPEATED_INIT.  */
  {  0, "L4=Mb1+4*=" },		/* 0x2a */
  {  1, "Lb4*=Mb1+L*=" },	/* 0x2b */
  {  2, "Lb4*=Md1+4*=" },	/* 0x2c */
  {  3, "Ld1+=Me1+=" },		/* 0x2d */
  {  0, "" },			/* 0x2e */
  {  0, "" },			/* 0x2f */
  /* R_PCREL_CALL.  */
  {  0, "L4=RD=Sb=" },		/* 0x30 */
  {  1, "L4=RD=Sb=" },		/* 0x31 */
  {  2, "L4=RD=Sb=" },		/* 0x32 */
  {  3, "L4=RD=Sb=" },		/* 0x33 */
  {  4, "L4=RD=Sb=" },		/* 0x34 */
  {  5, "L4=RD=Sb=" },		/* 0x35 */
  {  6, "L4=RD=Sb=" },		/* 0x36 */
  {  7, "L4=RD=Sb=" },		/* 0x37 */
  {  8, "L4=RD=Sb=" },		/* 0x38 */
  {  9, "L4=RD=Sb=" },		/* 0x39 */
  {  0, "L4=RD8<b+=Sb=" },	/* 0x3a */
  {  1, "L4=RD8<b+=Sb=" },	/* 0x3b */
  {  0, "L4=RD8<b+=Sd=" },	/* 0x3c */
  {  1, "L4=RD8<b+=Sd=" },	/* 0x3d */
  /* R_SHORT_PCREL_MODE.  */
  {  0, "" },			/* 0x3e */
  /* R_LONG_PCREL_MODE.  */
  {  0, "" },			/* 0x3f */
  /* R_ABS_CALL.  */
  {  0, "L4=RD=Sb=" },		/* 0x40 */
  {  1, "L4=RD=Sb=" },		/* 0x41 */
  {  2, "L4=RD=Sb=" },		/* 0x42 */
  {  3, "L4=RD=Sb=" },		/* 0x43 */
  {  4, "L4=RD=Sb=" },		/* 0x44 */
  {  5, "L4=RD=Sb=" },		/* 0x45 */
  {  6, "L4=RD=Sb=" },		/* 0x46 */
  {  7, "L4=RD=Sb=" },		/* 0x47 */
  {  8, "L4=RD=Sb=" },		/* 0x48 */
  {  9, "L4=RD=Sb=" },		/* 0x49 */
  {  0, "L4=RD8<b+=Sb=" },	/* 0x4a */
  {  1, "L4=RD8<b+=Sb=" },	/* 0x4b */
  {  0, "L4=RD8<b+=Sd=" },	/* 0x4c */
  {  1, "L4=RD8<b+=Sd=" },	/* 0x4d */
  /* R_RESERVED.  */
  {  0, "" },			/* 0x4e */
  {  0, "" },			/* 0x4f */
  /* R_DP_RELATIVE.  */
  {  0, "L4=SD=" },		/* 0x50 */
  {  1, "L4=SD=" },		/* 0x51 */
  {  2, "L4=SD=" },		/* 0x52 */
  {  3, "L4=SD=" },		/* 0x53 */
  {  4, "L4=SD=" },		/* 0x54 */
  {  5, "L4=SD=" },		/* 0x55 */
  {  6, "L4=SD=" },		/* 0x56 */
  {  7, "L4=SD=" },		/* 0x57 */
  {  8, "L4=SD=" },		/* 0x58 */
  {  9, "L4=SD=" },		/* 0x59 */
  { 10, "L4=SD=" },		/* 0x5a */
  { 11, "L4=SD=" },		/* 0x5b */
  { 12, "L4=SD=" },		/* 0x5c */
  { 13, "L4=SD=" },		/* 0x5d */
  { 14, "L4=SD=" },		/* 0x5e */
  { 15, "L4=SD=" },		/* 0x5f */
  { 16, "L4=SD=" },		/* 0x60 */
  { 17, "L4=SD=" },		/* 0x61 */
  { 18, "L4=SD=" },		/* 0x62 */
  { 19, "L4=SD=" },		/* 0x63 */
  { 20, "L4=SD=" },		/* 0x64 */
  { 21, "L4=SD=" },		/* 0x65 */
  { 22, "L4=SD=" },		/* 0x66 */
  { 23, "L4=SD=" },		/* 0x67 */
  { 24, "L4=SD=" },		/* 0x68 */
  { 25, "L4=SD=" },		/* 0x69 */
  { 26, "L4=SD=" },		/* 0x6a */
  { 27, "L4=SD=" },		/* 0x6b */
  { 28, "L4=SD=" },		/* 0x6c */
  { 29, "L4=SD=" },		/* 0x6d */
  { 30, "L4=SD=" },		/* 0x6e */
  { 31, "L4=SD=" },		/* 0x6f */
  { 32, "L4=Sb=" },		/* 0x70 */
  { 33, "L4=Sd=" },		/* 0x71 */
  /* R_DATA_GPREL.  */
  {  0, "L4=Sd=" },		/* 0x72 */
  /* R_RESERVED.  */
  {  0, "" },			/* 0x73 */
  {  0, "" },			/* 0x74 */
  {  0, "" },			/* 0x75 */
  {  0, "" },			/* 0x76 */
  {  0, "" },			/* 0x77 */
  /* R_DLT_REL.  */
  {  0, "L4=Sb=" },		/* 0x78 */
  {  1, "L4=Sd=" },		/* 0x79 */
  /* R_RESERVED.  */
  {  0, "" },			/* 0x7a */
  {  0, "" },			/* 0x7b */
  {  0, "" },			/* 0x7c */
  {  0, "" },			/* 0x7d */
  {  0, "" },			/* 0x7e */
  {  0, "" },			/* 0x7f */
  /* R_CODE_ONE_SYMBOL.  */
  {  0, "L4=SD=" },		/* 0x80 */
  {  1, "L4=SD=" },		/* 0x81 */
  {  2, "L4=SD=" },		/* 0x82 */
  {  3, "L4=SD=" },		/* 0x83 */
  {  4, "L4=SD=" },		/* 0x84 */
  {  5, "L4=SD=" },		/* 0x85 */
  {  6, "L4=SD=" },		/* 0x86 */
  {  7, "L4=SD=" },		/* 0x87 */
  {  8, "L4=SD=" },		/* 0x88 */
  {  9, "L4=SD=" },		/* 0x89 */
  { 10, "L4=SD=" },		/* 0x8q */
  { 11, "L4=SD=" },		/* 0x8b */
  { 12, "L4=SD=" },		/* 0x8c */
  { 13, "L4=SD=" },		/* 0x8d */
  { 14, "L4=SD=" },		/* 0x8e */
  { 15, "L4=SD=" },		/* 0x8f */
  { 16, "L4=SD=" },		/* 0x90 */
  { 17, "L4=SD=" },		/* 0x91 */
  { 18, "L4=SD=" },		/* 0x92 */
  { 19, "L4=SD=" },		/* 0x93 */
  { 20, "L4=SD=" },		/* 0x94 */
  { 21, "L4=SD=" },		/* 0x95 */
  { 22, "L4=SD=" },		/* 0x96 */
  { 23, "L4=SD=" },		/* 0x97 */
  { 24, "L4=SD=" },		/* 0x98 */
  { 25, "L4=SD=" },		/* 0x99 */
  { 26, "L4=SD=" },		/* 0x9a */
  { 27, "L4=SD=" },		/* 0x9b */
  { 28, "L4=SD=" },		/* 0x9c */
  { 29, "L4=SD=" },		/* 0x9d */
  { 30, "L4=SD=" },		/* 0x9e */
  { 31, "L4=SD=" },		/* 0x9f */
  { 32, "L4=Sb=" },		/* 0xa0 */
  { 33, "L4=Sd=" },		/* 0xa1 */
  /* R_RESERVED.  */
  {  0, "" },			/* 0xa2 */
  {  0, "" },			/* 0xa3 */
  {  0, "" },			/* 0xa4 */
  {  0, "" },			/* 0xa5 */
  {  0, "" },			/* 0xa6 */
  {  0, "" },			/* 0xa7 */
  {  0, "" },			/* 0xa8 */
  {  0, "" },			/* 0xa9 */
  {  0, "" },			/* 0xaa */
  {  0, "" },			/* 0xab */
  {  0, "" },			/* 0xac */
  {  0, "" },			/* 0xad */
  /* R_MILLI_REL.  */
  {  0, "L4=Sb=" },		/* 0xae */
  {  1, "L4=Sd=" },		/* 0xaf */
  /* R_CODE_PLABEL.  */
  {  0, "L4=Sb=" },		/* 0xb0 */
  {  1, "L4=Sd=" },		/* 0xb1 */
  /* R_BREAKPOINT.  */
  {  0, "L4=" },		/* 0xb2 */
  /* R_ENTRY.  */
  {  0, "Te=Ue=" },		/* 0xb3 */
  {  1, "Uf=" },		/* 0xb4 */
  /* R_ALT_ENTRY.  */
  {  0, "" },			/* 0xb5 */
  /* R_EXIT.  */
  {  0, "" },			/* 0xb6 */
  /* R_BEGIN_TRY.  */
  {  0, "" },			/* 0xb7 */
  /* R_END_TRY.  */
  {  0, "R0=" },		/* 0xb8 */
  {  1, "Rb4*=" },		/* 0xb9 */
  {  2, "Rd4*=" },		/* 0xba */
  /* R_BEGIN_BRTAB.  */
  {  0, "" },			/* 0xbb */
  /* R_END_BRTAB.  */
  {  0, "" },			/* 0xbc */
  /* R_STATEMENT.  */
  {  0, "Nb=" },		/* 0xbd */
  {  1, "Nc=" },		/* 0xbe */
  {  2, "Nd=" },		/* 0xbf */
  /* R_DATA_EXPR.  */
  {  0, "L4=" },		/* 0xc0 */
  /* R_CODE_EXPR.  */
  {  0, "L4=" },		/* 0xc1 */
  /* R_FSEL.  */
  {  0, "" },			/* 0xc2 */
  /* R_LSEL.  */
  {  0, "" },			/* 0xc3 */
  /* R_RSEL.  */
  {  0, "" },			/* 0xc4 */
  /* R_N_MODE.  */
  {  0, "" },			/* 0xc5 */
  /* R_S_MODE.  */
  {  0, "" },			/* 0xc6 */
  /* R_D_MODE.  */
  {  0, "" },			/* 0xc7 */
  /* R_R_MODE.  */
  {  0, "" },			/* 0xc8 */
  /* R_DATA_OVERRIDE.  */
  {  0, "V0=" },		/* 0xc9 */
  {  1, "Vb=" },		/* 0xca */
  {  2, "Vc=" },		/* 0xcb */
  {  3, "Vd=" },		/* 0xcc */
  {  4, "Ve=" },		/* 0xcd */
  /* R_TRANSLATED.  */
  {  0, "" },			/* 0xce */
  /* R_AUX_UNWIND.  */
  {  0,"Sd=Ve=Ee=" },	       /* 0xcf */
  /* R_COMP1.  */
  {  0, "Ob=" },		/* 0xd0 */
  /* R_COMP2.  */
  {  0, "Ob=Sd=" },		/* 0xd1 */
  /* R_COMP3.  */
  {  0, "Ob=Ve=" },		/* 0xd2 */
  /* R_PREV_FIXUP.  */
  {  0, "P" },			/* 0xd3 */
  {  1, "P" },			/* 0xd4 */
  {  2, "P" },			/* 0xd5 */
  {  3, "P" },			/* 0xd6 */
  /* R_SEC_STMT.  */
  {  0, "" },			/* 0xd7 */
  /* R_N0SEL.  */
  {  0, "" },			/* 0xd8 */
  /* R_N1SEL.  */
  {  0, "" },			/* 0xd9 */
  /* R_LINETAB.  */
  {  0, "Eb=Sd=Ve=" },		/* 0xda */
  /* R_LINETAB_ESC.  */
  {  0, "Eb=Mb=" },		/* 0xdb */
  /* R_LTP_OVERRIDE.  */
  {  0, "" },			/* 0xdc */
  /* R_COMMENT.  */
  {  0, "Ob=Vf=" },		/* 0xdd */
  /* R_RESERVED.  */
  {  0, "" },			/* 0xde */
  {  0, "" },			/* 0xdf */
  {  0, "" },			/* 0xe0 */
  {  0, "" },			/* 0xe1 */
  {  0, "" },			/* 0xe2 */
  {  0, "" },			/* 0xe3 */
  {  0, "" },			/* 0xe4 */
  {  0, "" },			/* 0xe5 */
  {  0, "" },			/* 0xe6 */
  {  0, "" },			/* 0xe7 */
  {  0, "" },			/* 0xe8 */
  {  0, "" },			/* 0xe9 */
  {  0, "" },			/* 0xea */
  {  0, "" },			/* 0xeb */
  {  0, "" },			/* 0xec */
  {  0, "" },			/* 0xed */
  {  0, "" },			/* 0xee */
  {  0, "" },			/* 0xef */
  {  0, "" },			/* 0xf0 */
  {  0, "" },			/* 0xf1 */
  {  0, "" },			/* 0xf2 */
  {  0, "" },			/* 0xf3 */
  {  0, "" },			/* 0xf4 */
  {  0, "" },			/* 0xf5 */
  {  0, "" },			/* 0xf6 */
  {  0, "" },			/* 0xf7 */
  {  0, "" },			/* 0xf8 */
  {  0, "" },			/* 0xf9 */
  {  0, "" },			/* 0xfa */
  {  0, "" },			/* 0xfb */
  {  0, "" },			/* 0xfc */
  {  0, "" },			/* 0xfd */
  {  0, "" },			/* 0xfe */
  {  0, "" },			/* 0xff */
};

static const int comp1_opcodes[] =
{
  0x00,
  0x40,
  0x41,
  0x42,
  0x43,
  0x44,
  0x45,
  0x46,
  0x47,
  0x48,
  0x49,
  0x4a,
  0x4b,
  0x60,
  0x80,
  0xa0,
  0xc0,
  -1
};

static const int comp2_opcodes[] =
{
  0x00,
  0x80,
  0x82,
  0xc0,
  -1
};

static const int comp3_opcodes[] =
{
  0x00,
  0x02,
  -1
};

/* These apparently are not in older versions of hpux reloc.h (hpux7).  */

/* And these first appeared in hpux10.  */
#ifndef R_SHORT_PCREL_MODE
#define NO_PCREL_MODES
#define R_SHORT_PCREL_MODE 0x3e
#endif

#define SOM_HOWTO(TYPE, NAME)	\
  HOWTO(TYPE, 0, 0, 32, FALSE, 0, 0, hppa_som_reloc, NAME, FALSE, 0, 0, FALSE)

static reloc_howto_type som_hppa_howto_table[] =
{
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_NO_RELOCATION, "R_NO_RELOCATION"),
  SOM_HOWTO (R_ZEROES, "R_ZEROES"),
  SOM_HOWTO (R_ZEROES, "R_ZEROES"),
  SOM_HOWTO (R_UNINIT, "R_UNINIT"),
  SOM_HOWTO (R_UNINIT, "R_UNINIT"),
  SOM_HOWTO (R_RELOCATION, "R_RELOCATION"),
  SOM_HOWTO (R_DATA_ONE_SYMBOL, "R_DATA_ONE_SYMBOL"),
  SOM_HOWTO (R_DATA_ONE_SYMBOL, "R_DATA_ONE_SYMBOL"),
  SOM_HOWTO (R_DATA_PLABEL, "R_DATA_PLABEL"),
  SOM_HOWTO (R_DATA_PLABEL, "R_DATA_PLABEL"),
  SOM_HOWTO (R_SPACE_REF, "R_SPACE_REF"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_REPEATED_INIT, "REPEATED_INIT"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_PCREL_CALL, "R_PCREL_CALL"),
  SOM_HOWTO (R_SHORT_PCREL_MODE, "R_SHORT_PCREL_MODE"),
  SOM_HOWTO (R_LONG_PCREL_MODE, "R_LONG_PCREL_MODE"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_ABS_CALL, "R_ABS_CALL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
  SOM_HOWTO (R_DATA_GPREL, "R_DATA_GPREL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_DLT_REL, "R_DLT_REL"),
  SOM_HOWTO (R_DLT_REL, "R_DLT_REL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_CODE_ONE_SYMBOL, "R_CODE_ONE_SYMBOL"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_MILLI_REL, "R_MILLI_REL"),
  SOM_HOWTO (R_MILLI_REL, "R_MILLI_REL"),
  SOM_HOWTO (R_CODE_PLABEL, "R_CODE_PLABEL"),
  SOM_HOWTO (R_CODE_PLABEL, "R_CODE_PLABEL"),
  SOM_HOWTO (R_BREAKPOINT, "R_BREAKPOINT"),
  SOM_HOWTO (R_ENTRY, "R_ENTRY"),
  SOM_HOWTO (R_ENTRY, "R_ENTRY"),
  SOM_HOWTO (R_ALT_ENTRY, "R_ALT_ENTRY"),
  SOM_HOWTO (R_EXIT, "R_EXIT"),
  SOM_HOWTO (R_BEGIN_TRY, "R_BEGIN_TRY"),
  SOM_HOWTO (R_END_TRY, "R_END_TRY"),
  SOM_HOWTO (R_END_TRY, "R_END_TRY"),
  SOM_HOWTO (R_END_TRY, "R_END_TRY"),
  SOM_HOWTO (R_BEGIN_BRTAB, "R_BEGIN_BRTAB"),
  SOM_HOWTO (R_END_BRTAB, "R_END_BRTAB"),
  SOM_HOWTO (R_STATEMENT, "R_STATEMENT"),
  SOM_HOWTO (R_STATEMENT, "R_STATEMENT"),
  SOM_HOWTO (R_STATEMENT, "R_STATEMENT"),
  SOM_HOWTO (R_DATA_EXPR, "R_DATA_EXPR"),
  SOM_HOWTO (R_CODE_EXPR, "R_CODE_EXPR"),
  SOM_HOWTO (R_FSEL, "R_FSEL"),
  SOM_HOWTO (R_LSEL, "R_LSEL"),
  SOM_HOWTO (R_RSEL, "R_RSEL"),
  SOM_HOWTO (R_N_MODE, "R_N_MODE"),
  SOM_HOWTO (R_S_MODE, "R_S_MODE"),
  SOM_HOWTO (R_D_MODE, "R_D_MODE"),
  SOM_HOWTO (R_R_MODE, "R_R_MODE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_DATA_OVERRIDE, "R_DATA_OVERRIDE"),
  SOM_HOWTO (R_TRANSLATED, "R_TRANSLATED"),
  SOM_HOWTO (R_AUX_UNWIND, "R_AUX_UNWIND"),
  SOM_HOWTO (R_COMP1, "R_COMP1"),
  SOM_HOWTO (R_COMP2, "R_COMP2"),
  SOM_HOWTO (R_COMP3, "R_COMP3"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_PREV_FIXUP, "R_PREV_FIXUP"),
  SOM_HOWTO (R_SEC_STMT, "R_SEC_STMT"),
  SOM_HOWTO (R_N0SEL, "R_N0SEL"),
  SOM_HOWTO (R_N1SEL, "R_N1SEL"),
  SOM_HOWTO (R_LINETAB, "R_LINETAB"),
  SOM_HOWTO (R_LINETAB_ESC, "R_LINETAB_ESC"),
  SOM_HOWTO (R_LTP_OVERRIDE, "R_LTP_OVERRIDE"),
  SOM_HOWTO (R_COMMENT, "R_COMMENT"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED"),
  SOM_HOWTO (R_RESERVED, "R_RESERVED")
};

/* Initialize the SOM relocation queue.  By definition the queue holds
   the last four multibyte fixups.  */

static void
som_initialize_reloc_queue (struct reloc_queue *queue)
{
  queue[0].reloc = NULL;
  queue[0].size = 0;
  queue[1].reloc = NULL;
  queue[1].size = 0;
  queue[2].reloc = NULL;
  queue[2].size = 0;
  queue[3].reloc = NULL;
  queue[3].size = 0;
}

/* Insert a new relocation into the relocation queue.  */

static void
som_reloc_queue_insert (unsigned char *p,
			unsigned int size,
			struct reloc_queue *queue)
{
  queue[3].reloc = queue[2].reloc;
  queue[3].size = queue[2].size;
  queue[2].reloc = queue[1].reloc;
  queue[2].size = queue[1].size;
  queue[1].reloc = queue[0].reloc;
  queue[1].size = queue[0].size;
  queue[0].reloc = p;
  queue[0].size = size;
}

/* When an entry in the relocation queue is reused, the entry moves
   to the front of the queue.  */

static void
som_reloc_queue_fix (struct reloc_queue *queue, unsigned int idx)
{
  if (idx == 0)
    return;

  if (idx == 1)
    {
      unsigned char *tmp1 = queue[0].reloc;
      unsigned int tmp2 = queue[0].size;

      queue[0].reloc = queue[1].reloc;
      queue[0].size = queue[1].size;
      queue[1].reloc = tmp1;
      queue[1].size = tmp2;
      return;
    }

  if (idx == 2)
    {
      unsigned char *tmp1 = queue[0].reloc;
      unsigned int tmp2 = queue[0].size;

      queue[0].reloc = queue[2].reloc;
      queue[0].size = queue[2].size;
      queue[2].reloc = queue[1].reloc;
      queue[2].size = queue[1].size;
      queue[1].reloc = tmp1;
      queue[1].size = tmp2;
      return;
    }

  if (idx == 3)
    {
      unsigned char *tmp1 = queue[0].reloc;
      unsigned int tmp2 = queue[0].size;

      queue[0].reloc = queue[3].reloc;
      queue[0].size = queue[3].size;
      queue[3].reloc = queue[2].reloc;
      queue[3].size = queue[2].size;
      queue[2].reloc = queue[1].reloc;
      queue[2].size = queue[1].size;
      queue[1].reloc = tmp1;
      queue[1].size = tmp2;
      return;
    }
  abort ();
}

/* Search for a particular relocation in the relocation queue.  */

static int
som_reloc_queue_find (unsigned char *p,
		      unsigned int size,
		      struct reloc_queue *queue)
{
  if (queue[0].reloc && !memcmp (p, queue[0].reloc, size)
      && size == queue[0].size)
    return 0;
  if (queue[1].reloc && !memcmp (p, queue[1].reloc, size)
      && size == queue[1].size)
    return 1;
  if (queue[2].reloc && !memcmp (p, queue[2].reloc, size)
      && size == queue[2].size)
    return 2;
  if (queue[3].reloc && !memcmp (p, queue[3].reloc, size)
      && size == queue[3].size)
    return 3;
  return -1;
}

static unsigned char *
try_prev_fixup (bfd *abfd ATTRIBUTE_UNUSED,
		unsigned int *subspace_reloc_sizep,
		unsigned char *p,
		unsigned int size,
		struct reloc_queue *queue)
{
  int queue_index = som_reloc_queue_find (p, size, queue);

  if (queue_index != -1)
    {
      /* Found this in a previous fixup.  Undo the fixup we
	 just built and use R_PREV_FIXUP instead.  We saved
	 a total of size - 1 bytes in the fixup stream.  */
      bfd_put_8 (abfd, R_PREV_FIXUP + queue_index, p);
      p += 1;
      *subspace_reloc_sizep += 1;
      som_reloc_queue_fix (queue, queue_index);
    }
  else
    {
      som_reloc_queue_insert (p, size, queue);
      *subspace_reloc_sizep += size;
      p += size;
    }
  return p;
}

/* Emit the proper R_NO_RELOCATION fixups to map the next SKIP
   bytes without any relocation.  Update the size of the subspace
   relocation stream via SUBSPACE_RELOC_SIZE_P; also return the
   current pointer into the relocation stream.  */

static unsigned char *
som_reloc_skip (bfd *abfd,
		unsigned int skip,
		unsigned char *p,
		unsigned int *subspace_reloc_sizep,
		struct reloc_queue *queue)
{
  /* Use a 4 byte R_NO_RELOCATION entry with a maximal value
     then R_PREV_FIXUPs to get the difference down to a
     reasonable size.  */
  if (skip >= 0x1000000)
    {
      skip -= 0x1000000;
      bfd_put_8 (abfd, R_NO_RELOCATION + 31, p);
      bfd_put_8 (abfd, 0xff, p + 1);
      bfd_put_16 (abfd, (bfd_vma) 0xffff, p + 2);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 4, queue);
      while (skip >= 0x1000000)
	{
	  skip -= 0x1000000;
	  bfd_put_8 (abfd, R_PREV_FIXUP, p);
	  p++;
	  *subspace_reloc_sizep += 1;
	  /* No need to adjust queue here since we are repeating the
	     most recent fixup.  */
	}
    }

  /* The difference must be less than 0x1000000.  Use one
     more R_NO_RELOCATION entry to get to the right difference.  */
  if ((skip & 3) == 0 && skip <= 0xc0000 && skip > 0)
    {
      /* Difference can be handled in a simple single-byte
	 R_NO_RELOCATION entry.  */
      if (skip <= 0x60)
	{
	  bfd_put_8 (abfd, R_NO_RELOCATION + (skip >> 2) - 1, p);
	  *subspace_reloc_sizep += 1;
	  p++;
	}
      /* Handle it with a two byte R_NO_RELOCATION entry.  */
      else if (skip <= 0x1000)
	{
	  bfd_put_8 (abfd, R_NO_RELOCATION + 24 + (((skip >> 2) - 1) >> 8), p);
	  bfd_put_8 (abfd, (skip >> 2) - 1, p + 1);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 2, queue);
	}
      /* Handle it with a three byte R_NO_RELOCATION entry.  */
      else
	{
	  bfd_put_8 (abfd, R_NO_RELOCATION + 28 + (((skip >> 2) - 1) >> 16), p);
	  bfd_put_16 (abfd, (bfd_vma) (skip >> 2) - 1, p + 1);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 3, queue);
	}
    }
  /* Ugh.  Punt and use a 4 byte entry.  */
  else if (skip > 0)
    {
      bfd_put_8 (abfd, R_NO_RELOCATION + 31, p);
      bfd_put_8 (abfd, (skip - 1) >> 16, p + 1);
      bfd_put_16 (abfd, (bfd_vma) skip - 1, p + 2);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 4, queue);
    }
  return p;
}

/* Emit the proper R_DATA_OVERRIDE fixups to handle a nonzero addend
   from a BFD relocation.  Update the size of the subspace relocation
   stream via SUBSPACE_RELOC_SIZE_P; also return the current pointer
   into the relocation stream.  */

static unsigned char *
som_reloc_addend (bfd *abfd,
		  bfd_vma addend,
		  unsigned char *p,
		  unsigned int *subspace_reloc_sizep,
		  struct reloc_queue *queue)
{
  if (addend + 0x80 < 0x100)
    {
      bfd_put_8 (abfd, R_DATA_OVERRIDE + 1, p);
      bfd_put_8 (abfd, addend, p + 1);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 2, queue);
    }
  else if (addend + 0x8000 < 0x10000)
    {
      bfd_put_8 (abfd, R_DATA_OVERRIDE + 2, p);
      bfd_put_16 (abfd, addend, p + 1);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 3, queue);
    }
  else if (addend + 0x800000 < 0x1000000)
    {
      bfd_put_8 (abfd, R_DATA_OVERRIDE + 3, p);
      bfd_put_8 (abfd, addend >> 16, p + 1);
      bfd_put_16 (abfd, addend, p + 2);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 4, queue);
    }
  else
    {
      bfd_put_8 (abfd, R_DATA_OVERRIDE + 4, p);
      bfd_put_32 (abfd, addend, p + 1);
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 5, queue);
    }
  return p;
}

/* Handle a single function call relocation.  */

static unsigned char *
som_reloc_call (bfd *abfd,
		unsigned char *p,
		unsigned int *subspace_reloc_sizep,
		arelent *bfd_reloc,
		int sym_num,
		struct reloc_queue *queue)
{
  int arg_bits = HPPA_R_ARG_RELOC (bfd_reloc->addend);
  int rtn_bits = arg_bits & 0x3;
  int type, done = 0;

  /* You'll never believe all this is necessary to handle relocations
     for function calls.  Having to compute and pack the argument
     relocation bits is the real nightmare.

     If you're interested in how this works, just forget it.  You really
     do not want to know about this braindamage.  */

  /* First see if this can be done with a "simple" relocation.  Simple
     relocations have a symbol number < 0x100 and have simple encodings
     of argument relocations.  */

  if (sym_num < 0x100)
    {
      switch (arg_bits)
	{
	case 0:
	case 1:
	  type = 0;
	  break;
	case 1 << 8:
	case 1 << 8 | 1:
	  type = 1;
	  break;
	case 1 << 8 | 1 << 6:
	case 1 << 8 | 1 << 6 | 1:
	  type = 2;
	  break;
	case 1 << 8 | 1 << 6 | 1 << 4:
	case 1 << 8 | 1 << 6 | 1 << 4 | 1:
	  type = 3;
	  break;
	case 1 << 8 | 1 << 6 | 1 << 4 | 1 << 2:
	case 1 << 8 | 1 << 6 | 1 << 4 | 1 << 2 | 1:
	  type = 4;
	  break;
	default:
	  /* Not one of the easy encodings.  This will have to be
	     handled by the more complex code below.  */
	  type = -1;
	  break;
	}
      if (type != -1)
	{
	  /* Account for the return value too.  */
	  if (rtn_bits)
	    type += 5;

	  /* Emit a 2 byte relocation.  Then see if it can be handled
	     with a relocation which is already in the relocation queue.  */
	  bfd_put_8 (abfd, bfd_reloc->howto->type + type, p);
	  bfd_put_8 (abfd, sym_num, p + 1);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 2, queue);
	  done = 1;
	}
    }

  /* If this could not be handled with a simple relocation, then do a hard
     one.  Hard relocations occur if the symbol number was too high or if
     the encoding of argument relocation bits is too complex.  */
  if (! done)
    {
      /* Don't ask about these magic sequences.  I took them straight
	 from gas-1.36 which took them from the a.out man page.  */
      type = rtn_bits;
      if ((arg_bits >> 6 & 0xf) == 0xe)
	type += 9 * 40;
      else
	type += (3 * (arg_bits >> 8 & 3) + (arg_bits >> 6 & 3)) * 40;
      if ((arg_bits >> 2 & 0xf) == 0xe)
	type += 9 * 4;
      else
	type += (3 * (arg_bits >> 4 & 3) + (arg_bits >> 2 & 3)) * 4;

      /* Output the first two bytes of the relocation.  These describe
	 the length of the relocation and encoding style.  */
      bfd_put_8 (abfd, bfd_reloc->howto->type + 10
		 + 2 * (sym_num >= 0x100) + (type >= 0x100),
		 p);
      bfd_put_8 (abfd, type, p + 1);

      /* Now output the symbol index and see if this bizarre relocation
	 just happened to be in the relocation queue.  */
      if (sym_num < 0x100)
	{
	  bfd_put_8 (abfd, sym_num, p + 2);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 3, queue);
	}
      else
	{
	  bfd_put_8 (abfd, sym_num >> 16, p + 2);
	  bfd_put_16 (abfd, (bfd_vma) sym_num, p + 3);
	  p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 5, queue);
	}
    }
  return p;
}

/* Return the logarithm of X, base 2, considering X unsigned,
   if X is a power of 2.  Otherwise, returns -1.  */

static int
exact_log2 (unsigned int x)
{
  int log = 0;

  /* Test for 0 or a power of 2.  */
  if (x == 0 || x != (x & -x))
    return -1;

  while ((x >>= 1) != 0)
    log++;
  return log;
}

static bfd_reloc_status_type
hppa_som_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		arelent *reloc_entry,
		asymbol *symbol_in ATTRIBUTE_UNUSED,
		void *data ATTRIBUTE_UNUSED,
		asection *input_section,
		bfd *output_bfd,
		char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd)
    reloc_entry->address += input_section->output_offset;

  return bfd_reloc_ok;
}

/* Given a generic HPPA relocation type, the instruction format,
   and a field selector, return one or more appropriate SOM relocations.  */

int **
hppa_som_gen_reloc_type (bfd *abfd,
			 int base_type,
			 int format,
			 enum hppa_reloc_field_selector_type_alt field,
			 int sym_diff,
			 asymbol *sym)
{
  int *final_type, **final_types;

  final_types = bfd_alloc (abfd, (bfd_size_type) sizeof (int *) * 6);
  final_type = bfd_alloc (abfd, (bfd_size_type) sizeof (int));
  if (!final_types || !final_type)
    return NULL;

  /* The field selector may require additional relocations to be
     generated.  It's impossible to know at this moment if additional
     relocations will be needed, so we make them.  The code to actually
     write the relocation/fixup stream is responsible for removing
     any redundant relocations.  */
  switch (field)
    {
    case e_fsel:
    case e_psel:
    case e_lpsel:
    case e_rpsel:
      final_types[0] = final_type;
      final_types[1] = NULL;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_tsel:
    case e_ltsel:
    case e_rtsel:
      final_types[0] = bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      if (field == e_tsel)
	*final_types[0] = R_FSEL;
      else if (field == e_ltsel)
	*final_types[0] = R_LSEL;
      else
	*final_types[0] = R_RSEL;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_lssel:
    case e_rssel:
      final_types[0] = bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_S_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_lsel:
    case e_rsel:
      final_types[0] = bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_N_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_ldsel:
    case e_rdsel:
      final_types[0] = bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_D_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_lrsel:
    case e_rrsel:
      final_types[0] = bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_R_MODE;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_nsel:
      final_types[0] = bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_N1SEL;
      final_types[1] = final_type;
      final_types[2] = NULL;
      *final_type = base_type;
      break;

    case e_nlsel:
    case e_nlrsel:
      final_types[0] = bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[0])
	return NULL;
      *final_types[0] = R_N0SEL;
      final_types[1] = bfd_alloc (abfd, (bfd_size_type) sizeof (int));
      if (!final_types[1])
	return NULL;
      if (field == e_nlsel)
	*final_types[1] = R_N_MODE;
      else
	*final_types[1] = R_R_MODE;
      final_types[2] = final_type;
      final_types[3] = NULL;
      *final_type = base_type;
      break;

    /* FIXME: These two field selectors are not currently supported.  */
    case e_ltpsel:
    case e_rtpsel:
      abort ();
    }

  switch (base_type)
    {
    case R_HPPA:
      /* The difference of two symbols needs *very* special handling.  */
      if (sym_diff)
	{
	  bfd_size_type amt = sizeof (int);

	  final_types[0] = bfd_alloc (abfd, amt);
	  final_types[1] = bfd_alloc (abfd, amt);
	  final_types[2] = bfd_alloc (abfd, amt);
	  final_types[3] = bfd_alloc (abfd, amt);
	  if (!final_types[0] || !final_types[1] || !final_types[2])
	    return NULL;
	  if (field == e_fsel)
	    *final_types[0] = R_FSEL;
	  else if (field == e_rsel)
	    *final_types[0] = R_RSEL;
	  else if (field == e_lsel)
	    *final_types[0] = R_LSEL;
	  *final_types[1] = R_COMP2;
	  *final_types[2] = R_COMP2;
	  *final_types[3] = R_COMP1;
	  final_types[4] = final_type;
	  if (format == 32)
	    *final_types[4] = R_DATA_EXPR;
	  else
	    *final_types[4] = R_CODE_EXPR;
	  final_types[5] = NULL;
	  break;
	}
      /* PLABELs get their own relocation type.  */
      else if (field == e_psel
	       || field == e_lpsel
	       || field == e_rpsel)
	{
	  /* A PLABEL relocation that has a size of 32 bits must
	     be a R_DATA_PLABEL.  All others are R_CODE_PLABELs.  */
	  if (format == 32)
	    *final_type = R_DATA_PLABEL;
	  else
	    *final_type = R_CODE_PLABEL;
	}
      /* PIC stuff.  */
      else if (field == e_tsel
	       || field == e_ltsel
	       || field == e_rtsel)
	*final_type = R_DLT_REL;
      /* A relocation in the data space is always a full 32bits.  */
      else if (format == 32)
	{
	  *final_type = R_DATA_ONE_SYMBOL;

	  /* If there's no SOM symbol type associated with this BFD
	     symbol, then set the symbol type to ST_DATA.

	     Only do this if the type is going to default later when
	     we write the object file.

	     This is done so that the linker never encounters an
	     R_DATA_ONE_SYMBOL reloc involving an ST_CODE symbol.

	     This allows the compiler to generate exception handling
	     tables.

	     Note that one day we may need to also emit BEGIN_BRTAB and
	     END_BRTAB to prevent the linker from optimizing away insns
	     in exception handling regions.  */
	  if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN
	      && (sym->flags & BSF_SECTION_SYM) == 0
	      && (sym->flags & BSF_FUNCTION) == 0
	      && ! bfd_is_com_section (sym->section))
	    som_symbol_data (sym)->som_type = SYMBOL_TYPE_DATA;
	}
      break;

    case R_HPPA_GOTOFF:
      /* More PLABEL special cases.  */
      if (field == e_psel
	  || field == e_lpsel
	  || field == e_rpsel)
	*final_type = R_DATA_PLABEL;
      else if (field == e_fsel && format == 32)
	*final_type = R_DATA_GPREL;
      break;

    case R_HPPA_COMPLEX:
      /* The difference of two symbols needs *very* special handling.  */
      if (sym_diff)
	{
	  bfd_size_type amt = sizeof (int);

	  final_types[0] = bfd_alloc (abfd, amt);
	  final_types[1] = bfd_alloc (abfd, amt);
	  final_types[2] = bfd_alloc (abfd, amt);
	  final_types[3] = bfd_alloc (abfd, amt);
	  if (!final_types[0] || !final_types[1] || !final_types[2])
	    return NULL;
	  if (field == e_fsel)
	    *final_types[0] = R_FSEL;
	  else if (field == e_rsel)
	    *final_types[0] = R_RSEL;
	  else if (field == e_lsel)
	    *final_types[0] = R_LSEL;
	  *final_types[1] = R_COMP2;
	  *final_types[2] = R_COMP2;
	  *final_types[3] = R_COMP1;
	  final_types[4] = final_type;
	  if (format == 32)
	    *final_types[4] = R_DATA_EXPR;
	  else
	    *final_types[4] = R_CODE_EXPR;
	  final_types[5] = NULL;
	  break;
	}
      else
	break;

    case R_HPPA_NONE:
    case R_HPPA_ABS_CALL:
      /* Right now we can default all these.  */
      break;

    case R_HPPA_PCREL_CALL:
      {
#ifndef NO_PCREL_MODES
	/* If we have short and long pcrel modes, then generate the proper
	   mode selector, then the pcrel relocation.  Redundant selectors
	   will be eliminated as the relocs are sized and emitted.  */
	bfd_size_type amt = sizeof (int);

	final_types[0] = bfd_alloc (abfd, amt);
	if (!final_types[0])
	  return NULL;
	if (format == 17)
	  *final_types[0] = R_SHORT_PCREL_MODE;
	else
	  *final_types[0] = R_LONG_PCREL_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
#endif
	break;
      }
    }
  return final_types;
}

/* Return the address of the correct entry in the PA SOM relocation
   howto table.  */

static reloc_howto_type *
som_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   bfd_reloc_code_real_type code)
{
  if ((int) code < (int) R_NO_RELOCATION + 255)
    {
      BFD_ASSERT ((int) som_hppa_howto_table[(int) code].type == (int) code);
      return &som_hppa_howto_table[(int) code];
    }

  return NULL;
}

static reloc_howto_type *
som_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			   const char *r_name)
{
  unsigned int i;

  for (i = 0;
       i < sizeof (som_hppa_howto_table) / sizeof (som_hppa_howto_table[0]);
       i++)
    if (som_hppa_howto_table[i].name != NULL
	&& strcasecmp (som_hppa_howto_table[i].name, r_name) == 0)
      return &som_hppa_howto_table[i];

  return NULL;
}

static void
som_swap_clock_in (struct som_external_clock *src,
                   struct som_clock *dst)
{
  dst->secs = bfd_getb32 (src->secs);
  dst->nanosecs = bfd_getb32 (src->nanosecs);
}

static void
som_swap_clock_out (struct som_clock *src,
                    struct som_external_clock *dst)
{
  bfd_putb32 (src->secs, dst->secs);
  bfd_putb32 (src->nanosecs, dst->nanosecs);
}

static void
som_swap_header_in (struct som_external_header *src,
                    struct som_header *dst)
{
  dst->system_id = bfd_getb16 (src->system_id);
  dst->a_magic = bfd_getb16 (src->a_magic);
  dst->version_id = bfd_getb32 (src->version_id);
  som_swap_clock_in (&src->file_time, &dst->file_time);
  dst->entry_space = bfd_getb32 (src->entry_space);
  dst->entry_subspace = bfd_getb32 (src->entry_subspace);
  dst->entry_offset = bfd_getb32 (src->entry_offset);
  dst->aux_header_location = bfd_getb32 (src->aux_header_location);
  dst->aux_header_size = bfd_getb32 (src->aux_header_size);
  dst->som_length = bfd_getb32 (src->som_length);
  dst->presumed_dp = bfd_getb32 (src->presumed_dp);
  dst->space_location = bfd_getb32 (src->space_location);
  dst->space_total = bfd_getb32 (src->space_total);
  dst->subspace_location = bfd_getb32 (src->subspace_location);
  dst->subspace_total = bfd_getb32 (src->subspace_total);
  dst->loader_fixup_location = bfd_getb32 (src->loader_fixup_location);
  dst->loader_fixup_total = bfd_getb32 (src->loader_fixup_total);
  dst->space_strings_location = bfd_getb32 (src->space_strings_location);
  dst->space_strings_size = bfd_getb32 (src->space_strings_size);
  dst->init_array_location = bfd_getb32 (src->init_array_location);
  dst->init_array_total = bfd_getb32 (src->init_array_total);
  dst->compiler_location = bfd_getb32 (src->compiler_location);
  dst->compiler_total = bfd_getb32 (src->compiler_total);
  dst->symbol_location = bfd_getb32 (src->symbol_location);
  dst->symbol_total = bfd_getb32 (src->symbol_total);
  dst->fixup_request_location = bfd_getb32 (src->fixup_request_location);
  dst->fixup_request_total = bfd_getb32 (src->fixup_request_total);
  dst->symbol_strings_location = bfd_getb32 (src->symbol_strings_location);
  dst->symbol_strings_size = bfd_getb32 (src->symbol_strings_size);
  dst->unloadable_sp_location = bfd_getb32 (src->unloadable_sp_location);
  dst->unloadable_sp_size = bfd_getb32 (src->unloadable_sp_size);
  dst->checksum = bfd_getb32 (src->checksum);
}

static void
som_swap_header_out (struct som_header *src,
                    struct som_external_header *dst)
{
  bfd_putb16 (src->system_id, dst->system_id);
  bfd_putb16 (src->a_magic, dst->a_magic);
  bfd_putb32 (src->version_id, dst->version_id);
  som_swap_clock_out (&src->file_time, &dst->file_time);
  bfd_putb32 (src->entry_space, dst->entry_space);
  bfd_putb32 (src->entry_subspace, dst->entry_subspace);
  bfd_putb32 (src->entry_offset, dst->entry_offset);
  bfd_putb32 (src->aux_header_location, dst->aux_header_location);
  bfd_putb32 (src->aux_header_size, dst->aux_header_size);
  bfd_putb32 (src->som_length, dst->som_length);
  bfd_putb32 (src->presumed_dp, dst->presumed_dp);
  bfd_putb32 (src->space_location, dst->space_location);
  bfd_putb32 (src->space_total, dst->space_total);
  bfd_putb32 (src->subspace_location, dst->subspace_location);
  bfd_putb32 (src->subspace_total, dst->subspace_total);
  bfd_putb32 (src->loader_fixup_location, dst->loader_fixup_location);
  bfd_putb32 (src->loader_fixup_total, dst->loader_fixup_total);
  bfd_putb32 (src->space_strings_location, dst->space_strings_location);
  bfd_putb32 (src->space_strings_size, dst->space_strings_size);
  bfd_putb32 (src->init_array_location, dst->init_array_location);
  bfd_putb32 (src->init_array_total, dst->init_array_total);
  bfd_putb32 (src->compiler_location, dst->compiler_location);
  bfd_putb32 (src->compiler_total, dst->compiler_total);
  bfd_putb32 (src->symbol_location, dst->symbol_location);
  bfd_putb32 (src->symbol_total, dst->symbol_total);
  bfd_putb32 (src->fixup_request_location, dst->fixup_request_location);
  bfd_putb32 (src->fixup_request_total, dst->fixup_request_total);
  bfd_putb32 (src->symbol_strings_location, dst->symbol_strings_location);
  bfd_putb32 (src->symbol_strings_size, dst->symbol_strings_size);
  bfd_putb32 (src->unloadable_sp_location, dst->unloadable_sp_location);
  bfd_putb32 (src->unloadable_sp_size, dst->unloadable_sp_size);
  bfd_putb32 (src->checksum, dst->checksum);
}

static void
som_swap_space_dictionary_in (struct som_external_space_dictionary_record *src,
                              struct som_space_dictionary_record *dst)
{
  unsigned int flags;

  dst->name = bfd_getb32 (src->name);
  flags = bfd_getb32 (src->flags);
  dst->is_loadable = (flags & SOM_SPACE_IS_LOADABLE) != 0;
  dst->is_defined = (flags & SOM_SPACE_IS_DEFINED) != 0;
  dst->is_private = (flags & SOM_SPACE_IS_PRIVATE) != 0;
  dst->has_intermediate_code = (flags & SOM_SPACE_HAS_INTERMEDIATE_CODE) != 0;
  dst->is_tspecific = (flags & SOM_SPACE_IS_TSPECIFIC) != 0;
  dst->reserved = 0;
  dst->sort_key = (flags >> SOM_SPACE_SORT_KEY_SH) & SOM_SPACE_SORT_KEY_MASK;
  dst->reserved2 = 0;
  dst->space_number = bfd_getb32 (src->space_number);
  dst->subspace_index = bfd_getb32 (src->subspace_index);
  dst->subspace_quantity = bfd_getb32 (src->subspace_quantity);
  dst->loader_fix_index = bfd_getb32 (src->loader_fix_index);
  dst->loader_fix_quantity = bfd_getb32 (src->loader_fix_quantity);
  dst->init_pointer_index = bfd_getb32 (src->init_pointer_index);
  dst->init_pointer_quantity = bfd_getb32 (src->init_pointer_quantity);
}

static void
som_swap_space_dictionary_out (struct som_space_dictionary_record *src,
                               struct som_external_space_dictionary_record *dst)
{
  unsigned int flags;

  bfd_putb32 (src->name, dst->name);

  flags = 0;
  if (src->is_loadable)
    flags |= SOM_SPACE_IS_LOADABLE;
  if (src->is_defined)
    flags |= SOM_SPACE_IS_DEFINED;
  if (src->is_private)
    flags |= SOM_SPACE_IS_PRIVATE;
  if (src->has_intermediate_code)
    flags |= SOM_SPACE_HAS_INTERMEDIATE_CODE;
  if (src->is_tspecific)
    flags |= SOM_SPACE_IS_TSPECIFIC;
  flags |= (src->sort_key & SOM_SPACE_SORT_KEY_MASK) << SOM_SPACE_SORT_KEY_SH;
  bfd_putb32 (flags, dst->flags);
  bfd_putb32 (src->space_number, dst->space_number);
  bfd_putb32 (src->subspace_index, dst->subspace_index);
  bfd_putb32 (src->subspace_quantity, dst->subspace_quantity);
  bfd_putb32 (src->loader_fix_index, dst->loader_fix_index);
  bfd_putb32 (src->loader_fix_quantity, dst->loader_fix_quantity);
  bfd_putb32 (src->init_pointer_index, dst->init_pointer_index);
  bfd_putb32 (src->init_pointer_quantity, dst->init_pointer_quantity);
}

static void
som_swap_subspace_dictionary_in
  (struct som_external_subspace_dictionary_record *src,
   struct som_subspace_dictionary_record *dst)
{
  unsigned int flags;
  dst->space_index = bfd_getb32 (src->space_index);
  flags = bfd_getb32 (src->flags);
  dst->access_control_bits = (flags >> SOM_SUBSPACE_ACCESS_CONTROL_BITS_SH)
    & SOM_SUBSPACE_ACCESS_CONTROL_BITS_MASK;
  dst->memory_resident = (flags & SOM_SUBSPACE_MEMORY_RESIDENT) != 0;
  dst->dup_common = (flags & SOM_SUBSPACE_DUP_COMMON) != 0;
  dst->is_common = (flags & SOM_SUBSPACE_IS_COMMON) != 0;
  dst->is_loadable = (flags & SOM_SUBSPACE_IS_LOADABLE) != 0;
  dst->quadrant = (flags >> SOM_SUBSPACE_QUADRANT_SH)
    & SOM_SUBSPACE_QUADRANT_MASK;
  dst->initially_frozen = (flags & SOM_SUBSPACE_INITIALLY_FROZEN) != 0;
  dst->is_first = (flags & SOM_SUBSPACE_IS_FIRST) != 0;
  dst->code_only = (flags & SOM_SUBSPACE_CODE_ONLY) != 0;
  dst->sort_key = (flags >> SOM_SUBSPACE_SORT_KEY_SH)
    & SOM_SUBSPACE_SORT_KEY_MASK;
  dst->replicate_init = (flags & SOM_SUBSPACE_REPLICATE_INIT) != 0;
  dst->continuation = (flags & SOM_SUBSPACE_CONTINUATION) != 0;
  dst->is_tspecific = (flags & SOM_SUBSPACE_IS_TSPECIFIC) != 0;
  dst->is_comdat = (flags & SOM_SUBSPACE_IS_COMDAT) != 0;
  dst->reserved = 0;
  dst->file_loc_init_value = bfd_getb32 (src->file_loc_init_value);
  dst->initialization_length = bfd_getb32 (src->initialization_length);
  dst->subspace_start = bfd_getb32 (src->subspace_start);
  dst->subspace_length = bfd_getb32 (src->subspace_length);
  dst->alignment = bfd_getb32 (src->alignment);
  dst->name = bfd_getb32 (src->name);
  dst->fixup_request_index = bfd_getb32 (src->fixup_request_index);
  dst->fixup_request_quantity = bfd_getb32 (src->fixup_request_quantity);
}

static void
som_swap_subspace_dictionary_record_out
  (struct som_subspace_dictionary_record *src,
   struct som_external_subspace_dictionary_record *dst)
{
  unsigned int flags;

  bfd_putb32 (src->space_index, dst->space_index);
  flags = (src->access_control_bits & SOM_SUBSPACE_ACCESS_CONTROL_BITS_MASK)
    << SOM_SUBSPACE_ACCESS_CONTROL_BITS_SH;
  if (src->memory_resident)
    flags |= SOM_SUBSPACE_MEMORY_RESIDENT;
  if (src->dup_common)
    flags |= SOM_SUBSPACE_DUP_COMMON;
  if (src->is_common)
    flags |= SOM_SUBSPACE_IS_COMMON;
  if (src->is_loadable)
    flags |= SOM_SUBSPACE_IS_LOADABLE;
  flags |= (src->quadrant & SOM_SUBSPACE_QUADRANT_MASK)
    << SOM_SUBSPACE_QUADRANT_SH;
  if (src->initially_frozen)
    flags |= SOM_SUBSPACE_INITIALLY_FROZEN;
  if (src->is_first)
    flags |= SOM_SUBSPACE_IS_FIRST;
  if (src->code_only)
    flags |= SOM_SUBSPACE_CODE_ONLY;
  flags |= (src->sort_key & SOM_SUBSPACE_SORT_KEY_MASK)
    << SOM_SUBSPACE_SORT_KEY_SH;
  if (src->replicate_init)
    flags |= SOM_SUBSPACE_REPLICATE_INIT;
  if (src->continuation)
    flags |= SOM_SUBSPACE_CONTINUATION;
  if (src->is_tspecific)
    flags |= SOM_SUBSPACE_IS_TSPECIFIC;
  if (src->is_comdat)
    flags |= SOM_SUBSPACE_IS_COMDAT;
  bfd_putb32 (flags, dst->flags);
  bfd_putb32 (src->file_loc_init_value, dst->file_loc_init_value);
  bfd_putb32 (src->initialization_length, dst->initialization_length);
  bfd_putb32 (src->subspace_start, dst->subspace_start);
  bfd_putb32 (src->subspace_length, dst->subspace_length);
  bfd_putb32 (src->alignment, dst->alignment);
  bfd_putb32 (src->name, dst->name);
  bfd_putb32 (src->fixup_request_index, dst->fixup_request_index);
  bfd_putb32 (src->fixup_request_quantity, dst->fixup_request_quantity);
}

static void
som_swap_aux_id_in (struct som_external_aux_id *src,
                    struct som_aux_id *dst)
{
  unsigned int flags = bfd_getb32 (src->flags);

  dst->mandatory = (flags & SOM_AUX_ID_MANDATORY) != 0;
  dst->copy = (flags & SOM_AUX_ID_COPY) != 0;
  dst->append = (flags & SOM_AUX_ID_APPEND) != 0;
  dst->ignore = (flags & SOM_AUX_ID_IGNORE) != 0;
  dst->type = (flags >> SOM_AUX_ID_TYPE_SH) & SOM_AUX_ID_TYPE_MASK;
  dst->length = bfd_getb32 (src->length);
}

static void
som_swap_aux_id_out (struct som_aux_id *src,
                    struct som_external_aux_id *dst)
{
  unsigned int flags = 0;

  if (src->mandatory)
    flags |= SOM_AUX_ID_MANDATORY;
  if (src->copy)
    flags |= SOM_AUX_ID_COPY;
  if (src->append)
    flags |= SOM_AUX_ID_APPEND;
  if (src->ignore)
    flags |= SOM_AUX_ID_IGNORE;
  flags |= (src->type & SOM_AUX_ID_TYPE_MASK) << SOM_AUX_ID_TYPE_SH;
  bfd_putb32 (flags, dst->flags);
  bfd_putb32 (src->length, dst->length);
}

static void
som_swap_string_auxhdr_out (struct som_string_auxhdr *src,
                            struct som_external_string_auxhdr *dst)
{
  som_swap_aux_id_out (&src->header_id, &dst->header_id);
  bfd_putb32 (src->string_length, dst->string_length);
}

static void
som_swap_compilation_unit_out (struct som_compilation_unit *src,
                               struct som_external_compilation_unit *dst)
{
  bfd_putb32 (src->name.strx, dst->name);
  bfd_putb32 (src->language_name.strx, dst->language_name);
  bfd_putb32 (src->product_id.strx, dst->product_id);
  bfd_putb32 (src->version_id.strx, dst->version_id);
  bfd_putb32 (src->flags, dst->flags);
  som_swap_clock_out (&src->compile_time, &dst->compile_time);
  som_swap_clock_out (&src->source_time, &dst->source_time);
}

static void
som_swap_exec_auxhdr_in (struct som_external_exec_auxhdr *src,
                         struct som_exec_auxhdr *dst)
{
  som_swap_aux_id_in (&src->som_auxhdr, &dst->som_auxhdr);
  dst->exec_tsize = bfd_getb32 (src->exec_tsize);
  dst->exec_tmem = bfd_getb32 (src->exec_tmem);
  dst->exec_tfile = bfd_getb32 (src->exec_tfile);
  dst->exec_dsize = bfd_getb32 (src->exec_dsize);
  dst->exec_dmem = bfd_getb32 (src->exec_dmem);
  dst->exec_dfile = bfd_getb32 (src->exec_dfile);
  dst->exec_bsize = bfd_getb32 (src->exec_bsize);
  dst->exec_entry = bfd_getb32 (src->exec_entry);
  dst->exec_flags = bfd_getb32 (src->exec_flags);
  dst->exec_bfill = bfd_getb32 (src->exec_bfill);
}

static void
som_swap_exec_auxhdr_out (struct som_exec_auxhdr *src,
                         struct som_external_exec_auxhdr *dst)
{
  som_swap_aux_id_out (&src->som_auxhdr, &dst->som_auxhdr);
  bfd_putb32 (src->exec_tsize, dst->exec_tsize);
  bfd_putb32 (src->exec_tmem, dst->exec_tmem);
  bfd_putb32 (src->exec_tfile, dst->exec_tfile);
  bfd_putb32 (src->exec_dsize, dst->exec_dsize);
  bfd_putb32 (src->exec_dmem, dst->exec_dmem);
  bfd_putb32 (src->exec_dfile, dst->exec_dfile);
  bfd_putb32 (src->exec_bsize, dst->exec_bsize);
  bfd_putb32 (src->exec_entry, dst->exec_entry);
  bfd_putb32 (src->exec_flags, dst->exec_flags);
  bfd_putb32 (src->exec_bfill, dst->exec_bfill);
}

static void
som_swap_lst_header_in (struct som_external_lst_header *src,
                        struct som_lst_header *dst)
{
  dst->system_id = bfd_getb16 (src->system_id);
  dst->a_magic = bfd_getb16 (src->a_magic);
  dst->version_id = bfd_getb32 (src->version_id);
  som_swap_clock_in (&src->file_time, &dst->file_time);
  dst->hash_loc = bfd_getb32 (src->hash_loc);
  dst->hash_size = bfd_getb32 (src->hash_size);
  dst->module_count = bfd_getb32 (src->module_count);
  dst->module_limit = bfd_getb32 (src->module_limit);
  dst->dir_loc = bfd_getb32 (src->dir_loc);
  dst->export_loc = bfd_getb32 (src->export_loc);
  dst->export_count = bfd_getb32 (src->export_count);
  dst->import_loc = bfd_getb32 (src->import_loc);
  dst->aux_loc = bfd_getb32 (src->aux_loc);
  dst->aux_size = bfd_getb32 (src->aux_size);
  dst->string_loc = bfd_getb32 (src->string_loc);
  dst->string_size = bfd_getb32 (src->string_size);
  dst->free_list = bfd_getb32 (src->free_list);
  dst->file_end = bfd_getb32 (src->file_end);
  dst->checksum = bfd_getb32 (src->checksum);
}

/* Perform some initialization for an object.  Save results of this
   initialization in the BFD.  */

static const bfd_target *
som_object_setup (bfd *abfd,
		  struct som_header *file_hdrp,
		  struct som_exec_auxhdr *aux_hdrp,
		  unsigned long current_offset)
{
  asection *section;

  /* som_mkobject will set bfd_error if som_mkobject fails.  */
  if (! som_mkobject (abfd))
    return NULL;

  /* Set BFD flags based on what information is available in the SOM.  */
  abfd->flags = BFD_NO_FLAGS;
  if (file_hdrp->symbol_total)
    abfd->flags |= HAS_LINENO | HAS_DEBUG | HAS_SYMS | HAS_LOCALS;

  switch (file_hdrp->a_magic)
    {
    case DEMAND_MAGIC:
      abfd->flags |= (D_PAGED | WP_TEXT | EXEC_P);
      break;
    case SHARE_MAGIC:
      abfd->flags |= (WP_TEXT | EXEC_P);
      break;
    case EXEC_MAGIC:
      abfd->flags |= (EXEC_P);
      break;
    case RELOC_MAGIC:
      abfd->flags |= HAS_RELOC;
      break;
#ifdef SHL_MAGIC
    case SHL_MAGIC:
#endif
#ifdef DL_MAGIC
    case DL_MAGIC:
#endif
      abfd->flags |= DYNAMIC;
      break;

    default:
      break;
    }

  /* Save the auxiliary header.  */
  obj_som_exec_hdr (abfd) = aux_hdrp;

  /* Allocate space to hold the saved exec header information.  */
  obj_som_exec_data (abfd) = bfd_zalloc (abfd, (bfd_size_type) sizeof (struct som_exec_data));
  if (obj_som_exec_data (abfd) == NULL)
    return NULL;

  /* The braindamaged OSF1 linker switched exec_flags and exec_entry!

     We used to identify OSF1 binaries based on NEW_VERSION_ID, but
     apparently the latest HPUX linker is using NEW_VERSION_ID now.

     It's about time, OSF has used the new id since at least 1992;
     HPUX didn't start till nearly 1995!.

     The new approach examines the entry field for an executable.  If
     it is not 4-byte aligned then it's not a proper code address and
     we guess it's really the executable flags.  For a main program,
     we also consider zero to be indicative of a buggy linker, since
     that is not a valid entry point.  The entry point for a shared
     library, however, can be zero so we do not consider that to be
     indicative of a buggy linker.  */
  if (aux_hdrp)
    {
      int found = 0;

      for (section = abfd->sections; section; section = section->next)
	{
	  bfd_vma entry;

	  if ((section->flags & SEC_CODE) == 0)
	    continue;
	  entry = aux_hdrp->exec_entry + aux_hdrp->exec_tmem;
	  if (entry >= section->vma
	      && entry < section->vma + section->size)
	    found = 1;
	}
      if ((aux_hdrp->exec_entry == 0 && !(abfd->flags & DYNAMIC))
	  || (aux_hdrp->exec_entry & 0x3) != 0
	  || ! found)
	{
	  bfd_get_start_address (abfd) = aux_hdrp->exec_flags;
	  obj_som_exec_data (abfd)->exec_flags = aux_hdrp->exec_entry;
	}
      else
	{
	  bfd_get_start_address (abfd) = aux_hdrp->exec_entry + current_offset;
	  obj_som_exec_data (abfd)->exec_flags = aux_hdrp->exec_flags;
	}
    }

  obj_som_exec_data (abfd)->version_id = file_hdrp->version_id;

  bfd_default_set_arch_mach (abfd, bfd_arch_hppa, pa10);
  bfd_get_symcount (abfd) = file_hdrp->symbol_total;

  /* Initialize the saved symbol table and string table to NULL.
     Save important offsets and sizes from the SOM header into
     the BFD.  */
  obj_som_stringtab (abfd) = NULL;
  obj_som_symtab (abfd) = NULL;
  obj_som_sorted_syms (abfd) = NULL;
  obj_som_stringtab_size (abfd) = file_hdrp->symbol_strings_size;
  obj_som_sym_filepos (abfd) = file_hdrp->symbol_location + current_offset;
  obj_som_str_filepos (abfd) = (file_hdrp->symbol_strings_location
				+ current_offset);
  obj_som_reloc_filepos (abfd) = (file_hdrp->fixup_request_location
				  + current_offset);
  obj_som_exec_data (abfd)->system_id = file_hdrp->system_id;

  return abfd->xvec;
}

/* Convert all of the space and subspace info into BFD sections.  Each space
   contains a number of subspaces, which in turn describe the mapping between
   regions of the exec file, and the address space that the program runs in.
   BFD sections which correspond to spaces will overlap the sections for the
   associated subspaces.  */

static bfd_boolean
setup_sections (bfd *abfd,
		struct som_header *file_hdr,
		unsigned long current_offset)
{
  char *space_strings;
  unsigned int space_index, i;
  unsigned int total_subspaces = 0;
  asection **subspace_sections = NULL;
  asection *section;
  bfd_size_type amt;

  /* First, read in space names.  */
  amt = file_hdr->space_strings_size;
  space_strings = bfd_malloc (amt);
  if (!space_strings && amt != 0)
    goto error_return;

  if (bfd_seek (abfd, current_offset + file_hdr->space_strings_location,
		SEEK_SET) != 0)
    goto error_return;
  if (bfd_bread (space_strings, amt, abfd) != amt)
    goto error_return;

  /* Loop over all of the space dictionaries, building up sections.  */
  for (space_index = 0; space_index < file_hdr->space_total; space_index++)
    {
      struct som_space_dictionary_record space;
      struct som_external_space_dictionary_record ext_space;
      char *space_name;
      struct som_external_subspace_dictionary_record ext_subspace;
      struct som_subspace_dictionary_record subspace, save_subspace;
      unsigned int subspace_index;
      asection *space_asect;
      bfd_size_type space_size = 0;
      char *newname;

      /* Read the space dictionary element.  */
      if (bfd_seek (abfd,
		    (current_offset + file_hdr->space_location
		     + space_index * sizeof (ext_space)),
		    SEEK_SET) != 0)
	goto error_return;
      amt = sizeof ext_space;
      if (bfd_bread (&ext_space, amt, abfd) != amt)
	goto error_return;

      som_swap_space_dictionary_in (&ext_space, &space);

      /* Setup the space name string.  */
      space_name = space.name + space_strings;

      /* Make a section out of it.  */
      amt = strlen (space_name) + 1;
      newname = bfd_alloc (abfd, amt);
      if (!newname)
	goto error_return;
      strcpy (newname, space_name);

      space_asect = bfd_make_section_anyway (abfd, newname);
      if (!space_asect)
	goto error_return;

      if (space.is_loadable == 0)
	space_asect->flags |= SEC_DEBUGGING;

      /* Set up all the attributes for the space.  */
      if (! bfd_som_set_section_attributes (space_asect, space.is_defined,
					    space.is_private, space.sort_key,
					    space.space_number))
	goto error_return;

      /* If the space has no subspaces, then we're done.  */
      if (space.subspace_quantity == 0)
	continue;

      /* Now, read in the first subspace for this space.  */
      if (bfd_seek (abfd,
		    (current_offset + file_hdr->subspace_location
		     + space.subspace_index * sizeof ext_subspace),
		    SEEK_SET) != 0)
	goto error_return;
      amt = sizeof ext_subspace;
      if (bfd_bread (&ext_subspace, amt, abfd) != amt)
	goto error_return;
      /* Seek back to the start of the subspaces for loop below.  */
      if (bfd_seek (abfd,
		    (current_offset + file_hdr->subspace_location
		     + space.subspace_index * sizeof ext_subspace),
		    SEEK_SET) != 0)
	goto error_return;

      som_swap_subspace_dictionary_in (&ext_subspace, &subspace);

      /* Setup the start address and file loc from the first subspace
	 record.  */
      space_asect->vma = subspace.subspace_start;
      space_asect->filepos = subspace.file_loc_init_value + current_offset;
      space_asect->alignment_power = exact_log2 (subspace.alignment);
      if (space_asect->alignment_power == (unsigned) -1)
	goto error_return;

      /* Initialize save_subspace so we can reliably determine if this
	 loop placed any useful values into it.  */
      memset (&save_subspace, 0, sizeof (save_subspace));

      /* Loop over the rest of the subspaces, building up more sections.  */
      for (subspace_index = 0; subspace_index < space.subspace_quantity;
	   subspace_index++)
	{
	  asection *subspace_asect;
          char *subspace_name;

	  /* Read in the next subspace.  */
	  amt = sizeof ext_subspace;
	  if (bfd_bread (&ext_subspace, amt, abfd) != amt)
	    goto error_return;

          som_swap_subspace_dictionary_in (&ext_subspace, &subspace);

	  /* Setup the subspace name string.  */
	  subspace_name = subspace.name + space_strings;

	  amt = strlen (subspace_name) + 1;
	  newname = bfd_alloc (abfd, amt);
	  if (!newname)
	    goto error_return;
	  strcpy (newname, subspace_name);

	  /* Make a section out of this subspace.  */
	  subspace_asect = bfd_make_section_anyway (abfd, newname);
	  if (!subspace_asect)
	    goto error_return;

	  /* Store private information about the section.  */
	  if (! bfd_som_set_subsection_attributes (subspace_asect, space_asect,
						   subspace.access_control_bits,
						   subspace.sort_key,
						   subspace.quadrant,
						   subspace.is_comdat,
						   subspace.is_common,
						   subspace.dup_common))
	    goto error_return;

	  /* Keep an easy mapping between subspaces and sections.
	     Note we do not necessarily read the subspaces in the
	     same order in which they appear in the object file.

	     So to make the target index come out correctly, we
	     store the location of the subspace header in target
	     index, then sort using the location of the subspace
	     header as the key.  Then we can assign correct
	     subspace indices.  */
	  total_subspaces++;
	  subspace_asect->target_index = bfd_tell (abfd) - sizeof (subspace);

	  /* Set SEC_READONLY and SEC_CODE/SEC_DATA as specified
	     by the access_control_bits in the subspace header.  */
	  switch (subspace.access_control_bits >> 4)
	    {
	    /* Readonly data.  */
	    case 0x0:
	      subspace_asect->flags |= SEC_DATA | SEC_READONLY;
	      break;

	    /* Normal data.  */
	    case 0x1:
	      subspace_asect->flags |= SEC_DATA;
	      break;

	    /* Readonly code and the gateways.
	       Gateways have other attributes which do not map
	       into anything BFD knows about.  */
	    case 0x2:
	    case 0x4:
	    case 0x5:
	    case 0x6:
	    case 0x7:
	      subspace_asect->flags |= SEC_CODE | SEC_READONLY;
	      break;

	    /* dynamic (writable) code.  */
	    case 0x3:
	      subspace_asect->flags |= SEC_CODE;
	      break;
	    }

	  if (subspace.is_comdat || subspace.is_common || subspace.dup_common)
	    subspace_asect->flags |= SEC_LINK_ONCE;

	  if (subspace.subspace_length > 0)
	    subspace_asect->flags |= SEC_HAS_CONTENTS;

	  if (subspace.is_loadable)
	    subspace_asect->flags |= SEC_ALLOC | SEC_LOAD;
	  else
	    subspace_asect->flags |= SEC_DEBUGGING;

	  if (subspace.code_only)
	    subspace_asect->flags |= SEC_CODE;

	  /* Both file_loc_init_value and initialization_length will
	     be zero for a BSS like subspace.  */
	  if (subspace.file_loc_init_value == 0
	      && subspace.initialization_length == 0)
	    subspace_asect->flags &= ~(SEC_DATA | SEC_LOAD | SEC_HAS_CONTENTS);

	  /* This subspace has relocations.
	     The fixup_request_quantity is a byte count for the number of
	     entries in the relocation stream; it is not the actual number
	     of relocations in the subspace.  */
	  if (subspace.fixup_request_quantity != 0)
	    {
	      subspace_asect->flags |= SEC_RELOC;
	      subspace_asect->rel_filepos = subspace.fixup_request_index;
	      som_section_data (subspace_asect)->reloc_size
		= subspace.fixup_request_quantity;
	      /* We can not determine this yet.  When we read in the
		 relocation table the correct value will be filled in.  */
	      subspace_asect->reloc_count = (unsigned) -1;
	    }

	  /* Update save_subspace if appropriate.  */
	  if (subspace.file_loc_init_value > save_subspace.file_loc_init_value)
	    save_subspace = subspace;

	  subspace_asect->vma = subspace.subspace_start;
	  subspace_asect->size = subspace.subspace_length;
	  subspace_asect->filepos = (subspace.file_loc_init_value
				     + current_offset);
	  subspace_asect->alignment_power = exact_log2 (subspace.alignment);
	  if (subspace_asect->alignment_power == (unsigned) -1)
	    goto error_return;

	  /* Keep track of the accumulated sizes of the sections.  */
	  space_size += subspace.subspace_length;
	}

      /* This can happen for a .o which defines symbols in otherwise
	 empty subspaces.  */
      if (!save_subspace.file_loc_init_value)
	space_asect->size = 0;
      else
	{
	  if (file_hdr->a_magic != RELOC_MAGIC)
	    {
	      /* Setup the size for the space section based upon the info
		 in the last subspace of the space.  */
	      space_asect->size = (save_subspace.subspace_start
				   - space_asect->vma
				   + save_subspace.subspace_length);
	    }
	  else
	    {
	      /* The subspace_start field is not initialised in relocatable
	         only objects, so it cannot be used for length calculations.
		 Instead we use the space_size value which we have been
		 accumulating.  This isn't an accurate estimate since it
		 ignores alignment and ordering issues.  */
	      space_asect->size = space_size;
	    }
	}
    }
  /* Now that we've read in all the subspace records, we need to assign
     a target index to each subspace.  */
  amt = total_subspaces;
  amt *= sizeof (asection *);
  subspace_sections = bfd_malloc (amt);
  if (subspace_sections == NULL)
    goto error_return;

  for (i = 0, section = abfd->sections; section; section = section->next)
    {
      if (!som_is_subspace (section))
	continue;

      subspace_sections[i] = section;
      i++;
    }
  qsort (subspace_sections, total_subspaces,
	 sizeof (asection *), compare_subspaces);

  /* subspace_sections is now sorted in the order in which the subspaces
     appear in the object file.  Assign an index to each one now.  */
  for (i = 0; i < total_subspaces; i++)
    subspace_sections[i]->target_index = i;

  if (space_strings != NULL)
    free (space_strings);

  if (subspace_sections != NULL)
    free (subspace_sections);

  return TRUE;

 error_return:
  if (space_strings != NULL)
    free (space_strings);

  if (subspace_sections != NULL)
    free (subspace_sections);
  return FALSE;
}


/* Read in a SOM object and make it into a BFD.  */

static const bfd_target *
som_object_p (bfd *abfd)
{
  struct som_external_header ext_file_hdr;
  struct som_header file_hdr;
  struct som_exec_auxhdr *aux_hdr_ptr = NULL;
  unsigned long current_offset = 0;
  struct som_external_lst_header ext_lst_header;
  struct som_external_som_entry ext_som_entry;
  bfd_size_type amt;
  unsigned int loc;
#define ENTRY_SIZE sizeof (struct som_external_som_entry)

  amt = sizeof (struct som_external_header);
  if (bfd_bread (&ext_file_hdr, amt, abfd) != amt)
    {
      if (bfd_get_error () != bfd_error_system_call)
	bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  som_swap_header_in (&ext_file_hdr, &file_hdr);

  if (!_PA_RISC_ID (file_hdr.system_id))
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  switch (file_hdr.a_magic)
    {
    case RELOC_MAGIC:
    case EXEC_MAGIC:
    case SHARE_MAGIC:
    case DEMAND_MAGIC:
    case DL_MAGIC:
    case SHL_MAGIC:
#ifdef SHARED_MAGIC_CNX
    case SHARED_MAGIC_CNX:
#endif
      break;

    case EXECLIBMAGIC:
      /* Read the lst header and determine where the SOM directory begins.  */

      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}

      amt = sizeof (struct som_external_lst_header);
      if (bfd_bread (&ext_lst_header, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}

      /* Position to and read the first directory entry.  */
      loc = bfd_getb32 (ext_lst_header.dir_loc);
      if (bfd_seek (abfd, loc, SEEK_SET) != 0)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}

      amt = ENTRY_SIZE;
      if (bfd_bread (&ext_som_entry, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}

      /* Now position to the first SOM.  */
      current_offset = bfd_getb32 (ext_som_entry.location);
      if (bfd_seek (abfd, current_offset, SEEK_SET) != 0)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}

      /* And finally, re-read the som header.  */
      amt = sizeof (struct som_external_header);
      if (bfd_bread (&ext_file_hdr, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}

      som_swap_header_in (&ext_file_hdr, &file_hdr);

      break;

    default:
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  if (file_hdr.version_id != OLD_VERSION_ID
      && file_hdr.version_id != NEW_VERSION_ID)
    {
      bfd_set_error (bfd_error_wrong_format);
      return NULL;
    }

  /* If the aux_header_size field in the file header is zero, then this
     object is an incomplete executable (a .o file).  Do not try to read
     a non-existant auxiliary header.  */
  if (file_hdr.aux_header_size != 0)
    {
      struct som_external_exec_auxhdr ext_exec_auxhdr;

      aux_hdr_ptr = bfd_zalloc (abfd,
				(bfd_size_type) sizeof (*aux_hdr_ptr));
      if (aux_hdr_ptr == NULL)
	return NULL;
      amt = sizeof (struct som_external_exec_auxhdr);
      if (bfd_bread (&ext_exec_auxhdr, amt, abfd) != amt)
	{
	  if (bfd_get_error () != bfd_error_system_call)
	    bfd_set_error (bfd_error_wrong_format);
	  return NULL;
	}
      som_swap_exec_auxhdr_in (&ext_exec_auxhdr, aux_hdr_ptr);
    }

  if (!setup_sections (abfd, &file_hdr, current_offset))
    {
      /* setup_sections does not bubble up a bfd error code.  */
      bfd_set_error (bfd_error_bad_value);
      return NULL;
    }

  /* This appears to be a valid SOM object.  Do some initialization.  */
  return som_object_setup (abfd, &file_hdr, aux_hdr_ptr, current_offset);
}

/* Create a SOM object.  */

static bfd_boolean
som_mkobject (bfd *abfd)
{
  /* Allocate memory to hold backend information.  */
  abfd->tdata.som_data = bfd_zalloc (abfd, (bfd_size_type) sizeof (struct som_data_struct));
  if (abfd->tdata.som_data == NULL)
    return FALSE;
  return TRUE;
}

/* Initialize some information in the file header.  This routine makes
   not attempt at doing the right thing for a full executable; it
   is only meant to handle relocatable objects.  */

static bfd_boolean
som_prep_headers (bfd *abfd)
{
  struct som_header *file_hdr;
  asection *section;
  bfd_size_type amt = sizeof (struct som_header);

  /* Make and attach a file header to the BFD.  */
  file_hdr = bfd_zalloc (abfd, amt);
  if (file_hdr == NULL)
    return FALSE;
  obj_som_file_hdr (abfd) = file_hdr;

  if (abfd->flags & (EXEC_P | DYNAMIC))
    {
      /* Make and attach an exec header to the BFD.  */
      amt = sizeof (struct som_exec_auxhdr);
      obj_som_exec_hdr (abfd) = bfd_zalloc (abfd, amt);
      if (obj_som_exec_hdr (abfd) == NULL)
	return FALSE;

      if (abfd->flags & D_PAGED)
	file_hdr->a_magic = DEMAND_MAGIC;
      else if (abfd->flags & WP_TEXT)
	file_hdr->a_magic = SHARE_MAGIC;
#ifdef SHL_MAGIC
      else if (abfd->flags & DYNAMIC)
	file_hdr->a_magic = SHL_MAGIC;
#endif
      else
	file_hdr->a_magic = EXEC_MAGIC;
    }
  else
    file_hdr->a_magic = RELOC_MAGIC;

  /* These fields are optional, and embedding timestamps is not always
     a wise thing to do, it makes comparing objects during a multi-stage
     bootstrap difficult.  */
  file_hdr->file_time.secs = 0;
  file_hdr->file_time.nanosecs = 0;

  file_hdr->entry_space = 0;
  file_hdr->entry_subspace = 0;
  file_hdr->entry_offset = 0;
  file_hdr->presumed_dp = 0;

  /* Now iterate over the sections translating information from
     BFD sections to SOM spaces/subspaces.  */
  for (section = abfd->sections; section != NULL; section = section->next)
    {
      /* Ignore anything which has not been marked as a space or
	 subspace.  */
      if (!som_is_space (section) && !som_is_subspace (section))
	continue;

      if (som_is_space (section))
	{
	  /* Allocate space for the space dictionary.  */
	  amt = sizeof (struct som_space_dictionary_record);
	  som_section_data (section)->space_dict = bfd_zalloc (abfd, amt);
	  if (som_section_data (section)->space_dict == NULL)
	    return FALSE;
	  /* Set space attributes.  Note most attributes of SOM spaces
	     are set based on the subspaces it contains.  */
	  som_section_data (section)->space_dict->loader_fix_index = -1;
	  som_section_data (section)->space_dict->init_pointer_index = -1;

	  /* Set more attributes that were stuffed away in private data.  */
	  som_section_data (section)->space_dict->sort_key =
	    som_section_data (section)->copy_data->sort_key;
	  som_section_data (section)->space_dict->is_defined =
	    som_section_data (section)->copy_data->is_defined;
	  som_section_data (section)->space_dict->is_private =
	    som_section_data (section)->copy_data->is_private;
	  som_section_data (section)->space_dict->space_number =
	    som_section_data (section)->copy_data->space_number;
	}
      else
	{
	  /* Allocate space for the subspace dictionary.  */
	  amt = sizeof (struct som_subspace_dictionary_record);
	  som_section_data (section)->subspace_dict = bfd_zalloc (abfd, amt);
	  if (som_section_data (section)->subspace_dict == NULL)
	    return FALSE;

	  /* Set subspace attributes.  Basic stuff is done here, additional
	     attributes are filled in later as more information becomes
	     available.  */
	  if (section->flags & SEC_ALLOC)
	    som_section_data (section)->subspace_dict->is_loadable = 1;

	  if (section->flags & SEC_CODE)
	    som_section_data (section)->subspace_dict->code_only = 1;

	  som_section_data (section)->subspace_dict->subspace_start =
	    section->vma;
	  som_section_data (section)->subspace_dict->subspace_length =
	    section->size;
	  som_section_data (section)->subspace_dict->initialization_length =
	    section->size;
	  som_section_data (section)->subspace_dict->alignment =
	    1 << section->alignment_power;

	  /* Set more attributes that were stuffed away in private data.  */
	  som_section_data (section)->subspace_dict->sort_key =
	    som_section_data (section)->copy_data->sort_key;
	  som_section_data (section)->subspace_dict->access_control_bits =
	    som_section_data (section)->copy_data->access_control_bits;
	  som_section_data (section)->subspace_dict->quadrant =
	    som_section_data (section)->copy_data->quadrant;
	  som_section_data (section)->subspace_dict->is_comdat =
	    som_section_data (section)->copy_data->is_comdat;
	  som_section_data (section)->subspace_dict->is_common =
	    som_section_data (section)->copy_data->is_common;
	  som_section_data (section)->subspace_dict->dup_common =
	    som_section_data (section)->copy_data->dup_common;
	}
    }
  return TRUE;
}

/* Return TRUE if the given section is a SOM space, FALSE otherwise.  */

static bfd_boolean
som_is_space (asection *section)
{
  /* If no copy data is available, then it's neither a space nor a
     subspace.  */
  if (som_section_data (section)->copy_data == NULL)
    return FALSE;

  /* If the containing space isn't the same as the given section,
     then this isn't a space.  */
  if (som_section_data (section)->copy_data->container != section
      && (som_section_data (section)->copy_data->container->output_section
	  != section))
    return FALSE;

  /* OK.  Must be a space.  */
  return TRUE;
}

/* Return TRUE if the given section is a SOM subspace, FALSE otherwise.  */

static bfd_boolean
som_is_subspace (asection *section)
{
  /* If no copy data is available, then it's neither a space nor a
     subspace.  */
  if (som_section_data (section)->copy_data == NULL)
    return FALSE;

  /* If the containing space is the same as the given section,
     then this isn't a subspace.  */
  if (som_section_data (section)->copy_data->container == section
      || (som_section_data (section)->copy_data->container->output_section
	  == section))
    return FALSE;

  /* OK.  Must be a subspace.  */
  return TRUE;
}

/* Return TRUE if the given space contains the given subspace.  It
   is safe to assume space really is a space, and subspace really
   is a subspace.  */

static bfd_boolean
som_is_container (asection *space, asection *subspace)
{
  return (som_section_data (subspace)->copy_data->container == space)
    || (som_section_data (subspace)->copy_data->container->output_section
	== space);
}

/* Count and return the number of spaces attached to the given BFD.  */

static unsigned long
som_count_spaces (bfd *abfd)
{
  int count = 0;
  asection *section;

  for (section = abfd->sections; section != NULL; section = section->next)
    count += som_is_space (section);

  return count;
}

/* Count the number of subspaces attached to the given BFD.  */

static unsigned long
som_count_subspaces (bfd *abfd)
{
  int count = 0;
  asection *section;

  for (section = abfd->sections; section != NULL; section = section->next)
    count += som_is_subspace (section);

  return count;
}

/* Return -1, 0, 1 indicating the relative ordering of sym1 and sym2.

   We desire symbols to be ordered starting with the symbol with the
   highest relocation count down to the symbol with the lowest relocation
   count.  Doing so compacts the relocation stream.  */

static int
compare_syms (const void *arg1, const void *arg2)
{
  asymbol **sym1 = (asymbol **) arg1;
  asymbol **sym2 = (asymbol **) arg2;
  unsigned int count1, count2;

  /* Get relocation count for each symbol.  Note that the count
     is stored in the udata pointer for section symbols!  */
  if ((*sym1)->flags & BSF_SECTION_SYM)
    count1 = (*sym1)->udata.i;
  else
    count1 = som_symbol_data (*sym1)->reloc_count;

  if ((*sym2)->flags & BSF_SECTION_SYM)
    count2 = (*sym2)->udata.i;
  else
    count2 = som_symbol_data (*sym2)->reloc_count;

  /* Return the appropriate value.  */
  if (count1 < count2)
    return 1;
  else if (count1 > count2)
    return -1;
  return 0;
}

/* Return -1, 0, 1 indicating the relative ordering of subspace1
   and subspace.  */

static int
compare_subspaces (const void *arg1, const void *arg2)
{
  asection **subspace1 = (asection **) arg1;
  asection **subspace2 = (asection **) arg2;

  if ((*subspace1)->target_index < (*subspace2)->target_index)
    return -1;
  else if ((*subspace2)->target_index < (*subspace1)->target_index)
    return 1;
  else
    return 0;
}

/* Perform various work in preparation for emitting the fixup stream.  */

static void
som_prep_for_fixups (bfd *abfd, asymbol **syms, unsigned long num_syms)
{
  unsigned long i;
  asection *section;
  asymbol **sorted_syms;
  bfd_size_type amt;

  /* Most SOM relocations involving a symbol have a length which is
     dependent on the index of the symbol.  So symbols which are
     used often in relocations should have a small index.  */

  /* First initialize the counters for each symbol.  */
  for (i = 0; i < num_syms; i++)
    {
      /* Handle a section symbol; these have no pointers back to the
	 SOM symbol info.  So we just use the udata field to hold the
	 relocation count.  */
      if (som_symbol_data (syms[i]) == NULL
	  || syms[i]->flags & BSF_SECTION_SYM)
	{
	  syms[i]->flags |= BSF_SECTION_SYM;
	  syms[i]->udata.i = 0;
	}
      else
	som_symbol_data (syms[i])->reloc_count = 0;
    }

  /* Now that the counters are initialized, make a weighted count
     of how often a given symbol is used in a relocation.  */
  for (section = abfd->sections; section != NULL; section = section->next)
    {
      int j;

      /* Does this section have any relocations?  */
      if ((int) section->reloc_count <= 0)
	continue;

      /* Walk through each relocation for this section.  */
      for (j = 1; j < (int) section->reloc_count; j++)
	{
	  arelent *reloc = section->orelocation[j];
	  int scale;

	  /* A relocation against a symbol in the *ABS* section really
	     does not have a symbol.  Likewise if the symbol isn't associated
	     with any section.  */
	  if (reloc->sym_ptr_ptr == NULL
	      || bfd_is_abs_section ((*reloc->sym_ptr_ptr)->section))
	    continue;

	  /* Scaling to encourage symbols involved in R_DP_RELATIVE
	     and R_CODE_ONE_SYMBOL relocations to come first.  These
	     two relocations have single byte versions if the symbol
	     index is very small.  */
	  if (reloc->howto->type == R_DP_RELATIVE
	      || reloc->howto->type == R_CODE_ONE_SYMBOL)
	    scale = 2;
	  else
	    scale = 1;

	  /* Handle section symbols by storing the count in the udata
	     field.  It will not be used and the count is very important
	     for these symbols.  */
	  if ((*reloc->sym_ptr_ptr)->flags & BSF_SECTION_SYM)
	    {
	      (*reloc->sym_ptr_ptr)->udata.i =
		(*reloc->sym_ptr_ptr)->udata.i + scale;
	      continue;
	    }

	  /* A normal symbol.  Increment the count.  */
	  som_symbol_data (*reloc->sym_ptr_ptr)->reloc_count += scale;
	}
    }

  /* Sort a copy of the symbol table, rather than the canonical
     output symbol table.  */
  amt = num_syms;
  amt *= sizeof (asymbol *);
  sorted_syms = bfd_zalloc (abfd, amt);
  memcpy (sorted_syms, syms, num_syms * sizeof (asymbol *));
  qsort (sorted_syms, num_syms, sizeof (asymbol *), compare_syms);
  obj_som_sorted_syms (abfd) = sorted_syms;

  /* Compute the symbol indexes, they will be needed by the relocation
     code.  */
  for (i = 0; i < num_syms; i++)
    {
      /* A section symbol.  Again, there is no pointer to backend symbol
	 information, so we reuse the udata field again.  */
      if (sorted_syms[i]->flags & BSF_SECTION_SYM)
	sorted_syms[i]->udata.i = i;
      else
	som_symbol_data (sorted_syms[i])->index = i;
    }
}

static bfd_boolean
som_write_fixups (bfd *abfd,
		  unsigned long current_offset,
		  unsigned int *total_reloc_sizep)
{
  unsigned int i, j;
  /* Chunk of memory that we can use as buffer space, then throw
     away.  */
  unsigned char tmp_space[SOM_TMP_BUFSIZE];
  unsigned char *p;
  unsigned int total_reloc_size = 0;
  unsigned int subspace_reloc_size = 0;
  unsigned int num_spaces = obj_som_file_hdr (abfd)->space_total;
  asection *section = abfd->sections;
  bfd_size_type amt;

  memset (tmp_space, 0, SOM_TMP_BUFSIZE);
  p = tmp_space;

  /* All the fixups for a particular subspace are emitted in a single
     stream.  All the subspaces for a particular space are emitted
     as a single stream.

     So, to get all the locations correct one must iterate through all the
     spaces, for each space iterate through its subspaces and output a
     fixups stream.  */
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      /* Now iterate through each of its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{
	  int reloc_offset;
	  unsigned int current_rounding_mode;
#ifndef NO_PCREL_MODES
	  unsigned int current_call_mode;
#endif

	  /* Find a subspace of this space.  */
	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection))
	    continue;

	  /* If this subspace does not have real data, then we are
	     finished with it.  */
	  if ((subsection->flags & SEC_HAS_CONTENTS) == 0)
	    {
	      som_section_data (subsection)->subspace_dict->fixup_request_index
		= -1;
	      continue;
	    }

	  /* This subspace has some relocations.  Put the relocation stream
	     index into the subspace record.  */
	  som_section_data (subsection)->subspace_dict->fixup_request_index
	    = total_reloc_size;

	  /* To make life easier start over with a clean slate for
	     each subspace.  Seek to the start of the relocation stream
	     for this subspace in preparation for writing out its fixup
	     stream.  */
	  if (bfd_seek (abfd, current_offset + total_reloc_size, SEEK_SET) != 0)
	    return FALSE;

	  /* Buffer space has already been allocated.  Just perform some
	     initialization here.  */
	  p = tmp_space;
	  subspace_reloc_size = 0;
	  reloc_offset = 0;
	  som_initialize_reloc_queue (reloc_queue);
	  current_rounding_mode = R_N_MODE;
#ifndef NO_PCREL_MODES
	  current_call_mode = R_SHORT_PCREL_MODE;
#endif

	  /* Translate each BFD relocation into one or more SOM
	     relocations.  */
	  for (j = 0; j < subsection->reloc_count; j++)
	    {
	      arelent *bfd_reloc = subsection->orelocation[j];
	      unsigned int skip;
	      int sym_num;

	      /* Get the symbol number.  Remember it's stored in a
		 special place for section symbols.  */
	      if ((*bfd_reloc->sym_ptr_ptr)->flags & BSF_SECTION_SYM)
		sym_num = (*bfd_reloc->sym_ptr_ptr)->udata.i;
	      else
		sym_num = som_symbol_data (*bfd_reloc->sym_ptr_ptr)->index;

	      /* If there is not enough room for the next couple relocations,
		 then dump the current buffer contents now.  Also reinitialize
		 the relocation queue.

		 No single BFD relocation could ever translate into more
		 than 100 bytes of SOM relocations (20bytes is probably the
		 upper limit, but leave lots of space for growth).  */
	      if (p - tmp_space + 100 > SOM_TMP_BUFSIZE)
		{
		  amt = p - tmp_space;
		  if (bfd_bwrite ((void *) tmp_space, amt, abfd) != amt)
		    return FALSE;

		  p = tmp_space;
		  som_initialize_reloc_queue (reloc_queue);
		}

	      /* Emit R_NO_RELOCATION fixups to map any bytes which were
		 skipped.  */
	      skip = bfd_reloc->address - reloc_offset;
	      p = som_reloc_skip (abfd, skip, p,
				  &subspace_reloc_size, reloc_queue);

	      /* Update reloc_offset for the next iteration.

		 Many relocations do not consume input bytes.  They
		 are markers, or set state necessary to perform some
		 later relocation.  */
	      switch (bfd_reloc->howto->type)
		{
		case R_ENTRY:
		case R_ALT_ENTRY:
		case R_EXIT:
		case R_N_MODE:
		case R_S_MODE:
		case R_D_MODE:
		case R_R_MODE:
		case R_FSEL:
		case R_LSEL:
		case R_RSEL:
		case R_COMP1:
		case R_COMP2:
		case R_BEGIN_BRTAB:
		case R_END_BRTAB:
		case R_BEGIN_TRY:
		case R_END_TRY:
		case R_N0SEL:
		case R_N1SEL:
#ifndef NO_PCREL_MODES
		case R_SHORT_PCREL_MODE:
		case R_LONG_PCREL_MODE:
#endif
		  reloc_offset = bfd_reloc->address;
		  break;

		default:
		  reloc_offset = bfd_reloc->address + 4;
		  break;
		}

	      /* Now the actual relocation we care about.  */
	      switch (bfd_reloc->howto->type)
		{
		case R_PCREL_CALL:
		case R_ABS_CALL:
		  p = som_reloc_call (abfd, p, &subspace_reloc_size,
				      bfd_reloc, sym_num, reloc_queue);
		  break;

		case R_CODE_ONE_SYMBOL:
		case R_DP_RELATIVE:
		  /* Account for any addend.  */
		  if (bfd_reloc->addend)
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p,
					  &subspace_reloc_size, reloc_queue);

		  if (sym_num < 0x20)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + sym_num, p);
		      subspace_reloc_size += 1;
		      p += 1;
		    }
		  else if (sym_num < 0x100)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 32, p);
		      bfd_put_8 (abfd, sym_num, p + 1);
		      p = try_prev_fixup (abfd, &subspace_reloc_size, p,
					  2, reloc_queue);
		    }
		  else if (sym_num < 0x10000000)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 33, p);
		      bfd_put_8 (abfd, sym_num >> 16, p + 1);
		      bfd_put_16 (abfd, (bfd_vma) sym_num, p + 2);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 4, reloc_queue);
		    }
		  else
		    abort ();
		  break;

		case R_DATA_GPREL:
		  /* Account for any addend.  */
		  if (bfd_reloc->addend)
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p,
					  &subspace_reloc_size, reloc_queue);

		  if (sym_num < 0x10000000)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		      bfd_put_8 (abfd, sym_num >> 16, p + 1);
		      bfd_put_16 (abfd, (bfd_vma) sym_num, p + 2);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 4, reloc_queue);
		    }
		  else
		    abort ();
		  break;

		case R_DATA_ONE_SYMBOL:
		case R_DATA_PLABEL:
		case R_CODE_PLABEL:
		case R_DLT_REL:
		  /* Account for any addend using R_DATA_OVERRIDE.  */
		  if (bfd_reloc->howto->type != R_DATA_ONE_SYMBOL
		      && bfd_reloc->addend)
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p,
					  &subspace_reloc_size, reloc_queue);

		  if (sym_num < 0x100)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		      bfd_put_8 (abfd, sym_num, p + 1);
		      p = try_prev_fixup (abfd, &subspace_reloc_size, p,
					  2, reloc_queue);
		    }
		  else if (sym_num < 0x10000000)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 1, p);
		      bfd_put_8 (abfd, sym_num >> 16, p + 1);
		      bfd_put_16 (abfd, (bfd_vma) sym_num, p + 2);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 4, reloc_queue);
		    }
		  else
		    abort ();
		  break;

		case R_ENTRY:
		  {
		    unsigned int tmp;
		    arelent *tmp_reloc = NULL;
		    bfd_put_8 (abfd, R_ENTRY, p);

		    /* R_ENTRY relocations have 64 bits of associated
		       data.  Unfortunately the addend field of a bfd
		       relocation is only 32 bits.  So, we split up
		       the 64bit unwind information and store part in
		       the R_ENTRY relocation, and the rest in the R_EXIT
		       relocation.  */
		    bfd_put_32 (abfd, bfd_reloc->addend, p + 1);

		    /* Find the next R_EXIT relocation.  */
		    for (tmp = j; tmp < subsection->reloc_count; tmp++)
		      {
			tmp_reloc = subsection->orelocation[tmp];
			if (tmp_reloc->howto->type == R_EXIT)
			  break;
		      }

		    if (tmp == subsection->reloc_count)
		      abort ();

		    bfd_put_32 (abfd, tmp_reloc->addend, p + 5);
		    p = try_prev_fixup (abfd, &subspace_reloc_size,
					p, 9, reloc_queue);
		    break;
		  }

		case R_N_MODE:
		case R_S_MODE:
		case R_D_MODE:
		case R_R_MODE:
		  /* If this relocation requests the current rounding
		     mode, then it is redundant.  */
		  if (bfd_reloc->howto->type != current_rounding_mode)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		      subspace_reloc_size += 1;
		      p += 1;
		      current_rounding_mode = bfd_reloc->howto->type;
		    }
		  break;

#ifndef NO_PCREL_MODES
		case R_LONG_PCREL_MODE:
		case R_SHORT_PCREL_MODE:
		  if (bfd_reloc->howto->type != current_call_mode)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		      subspace_reloc_size += 1;
		      p += 1;
		      current_call_mode = bfd_reloc->howto->type;
		    }
		  break;
#endif

		case R_EXIT:
		case R_ALT_ENTRY:
		case R_FSEL:
		case R_LSEL:
		case R_RSEL:
		case R_BEGIN_BRTAB:
		case R_END_BRTAB:
		case R_BEGIN_TRY:
		case R_N0SEL:
		case R_N1SEL:
		  bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  subspace_reloc_size += 1;
		  p += 1;
		  break;

		case R_END_TRY:
		  /* The end of an exception handling region.  The reloc's
		     addend contains the offset of the exception handling
		     code.  */
		  if (bfd_reloc->addend == 0)
		    bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  else if (bfd_reloc->addend < 1024)
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 1, p);
		      bfd_put_8 (abfd, bfd_reloc->addend / 4, p + 1);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 2, reloc_queue);
		    }
		  else
		    {
		      bfd_put_8 (abfd, bfd_reloc->howto->type + 2, p);
		      bfd_put_8 (abfd, (bfd_reloc->addend / 4) >> 16, p + 1);
		      bfd_put_16 (abfd, bfd_reloc->addend / 4, p + 2);
		      p = try_prev_fixup (abfd, &subspace_reloc_size,
					  p, 4, reloc_queue);
		    }
		  break;

		case R_COMP1:
		  /* The only time we generate R_COMP1, R_COMP2 and
		     R_CODE_EXPR relocs is for the difference of two
		     symbols.  Hence we can cheat here.  */
		  bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  bfd_put_8 (abfd, 0x44, p + 1);
		  p = try_prev_fixup (abfd, &subspace_reloc_size,
				      p, 2, reloc_queue);
		  break;

		case R_COMP2:
		  /* The only time we generate R_COMP1, R_COMP2 and
		     R_CODE_EXPR relocs is for the difference of two
		     symbols.  Hence we can cheat here.  */
		  bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  bfd_put_8 (abfd, 0x80, p + 1);
		  bfd_put_8 (abfd, sym_num >> 16, p + 2);
		  bfd_put_16 (abfd, (bfd_vma) sym_num, p + 3);
		  p = try_prev_fixup (abfd, &subspace_reloc_size,
				      p, 5, reloc_queue);
		  break;

		case R_CODE_EXPR:
		case R_DATA_EXPR:
		  /* The only time we generate R_COMP1, R_COMP2 and
		     R_CODE_EXPR relocs is for the difference of two
		     symbols.  Hence we can cheat here.  */
		  bfd_put_8 (abfd, bfd_reloc->howto->type, p);
		  subspace_reloc_size += 1;
		  p += 1;
		  break;

		/* Put a "R_RESERVED" relocation in the stream if
		   we hit something we do not understand.  The linker
		   will complain loudly if this ever happens.  */
		default:
		  bfd_put_8 (abfd, 0xff, p);
		  subspace_reloc_size += 1;
		  p += 1;
		  break;
		}
	    }

	  /* Last BFD relocation for a subspace has been processed.
	     Map the rest of the subspace with R_NO_RELOCATION fixups.  */
	  p = som_reloc_skip (abfd, subsection->size - reloc_offset,
			      p, &subspace_reloc_size, reloc_queue);

	  /* Scribble out the relocations.  */
	  amt = p - tmp_space;
	  if (bfd_bwrite ((void *) tmp_space, amt, abfd) != amt)
	    return FALSE;
	  p = tmp_space;

	  total_reloc_size += subspace_reloc_size;
	  som_section_data (subsection)->subspace_dict->fixup_request_quantity
	    = subspace_reloc_size;
	}
      section = section->next;
    }
  *total_reloc_sizep = total_reloc_size;
  return TRUE;
}

/* Write out the space/subspace string table.  */

static bfd_boolean
som_write_space_strings (bfd *abfd,
			 unsigned long current_offset,
			 unsigned int *string_sizep)
{
  /* Chunk of memory that we can use as buffer space, then throw
     away.  */
  size_t tmp_space_size = SOM_TMP_BUFSIZE;
  char *tmp_space = alloca (tmp_space_size);
  char *p = tmp_space;
  unsigned int strings_size = 0;
  asection *section;
  bfd_size_type amt;

  /* Seek to the start of the space strings in preparation for writing
     them out.  */
  if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
    return FALSE;

  /* Walk through all the spaces and subspaces (order is not important)
     building up and writing string table entries for their names.  */
  for (section = abfd->sections; section != NULL; section = section->next)
    {
      size_t length;

      /* Only work with space/subspaces; avoid any other sections
	 which might have been made (.text for example).  */
      if (!som_is_space (section) && !som_is_subspace (section))
	continue;

      /* Get the length of the space/subspace name.  */
      length = strlen (section->name);

      /* If there is not enough room for the next entry, then dump the
	 current buffer contents now and maybe allocate a larger
	 buffer.  Each entry will take 4 bytes to hold the string
	 length + the string itself + null terminator.  */
      if (p - tmp_space + 5 + length > tmp_space_size)
	{
	  /* Flush buffer before refilling or reallocating.  */
	  amt = p - tmp_space;
	  if (bfd_bwrite ((void *) &tmp_space[0], amt, abfd) != amt)
	    return FALSE;

	  /* Reallocate if now empty buffer still too small.  */
	  if (5 + length > tmp_space_size)
	    {
	      /* Ensure a minimum growth factor to avoid O(n**2) space
		 consumption for n strings.  The optimal minimum
		 factor seems to be 2, as no other value can guarantee
		 wasting less than 50% space.  (Note that we cannot
		 deallocate space allocated by `alloca' without
		 returning from this function.)  The same technique is
		 used a few more times below when a buffer is
		 reallocated.  */
              if (2 * tmp_space_size < length + 5)
                tmp_space_size = length + 5;
              else
                tmp_space_size = 2 * tmp_space_size;
	      tmp_space = alloca (tmp_space_size);
	    }

	  /* Reset to beginning of the (possibly new) buffer space.  */
	  p = tmp_space;
	}

      /* First element in a string table entry is the length of the
	 string.  Alignment issues are already handled.  */
      bfd_put_32 (abfd, (bfd_vma) length, p);
      p += 4;
      strings_size += 4;

      /* Record the index in the space/subspace records.  */
      if (som_is_space (section))
	som_section_data (section)->space_dict->name = strings_size;
      else
	som_section_data (section)->subspace_dict->name = strings_size;

      /* Next comes the string itself + a null terminator.  */
      strcpy (p, section->name);
      p += length + 1;
      strings_size += length + 1;

      /* Always align up to the next word boundary.  */
      while (strings_size % 4)
	{
	  bfd_put_8 (abfd, 0, p);
	  p++;
	  strings_size++;
	}
    }

  /* Done with the space/subspace strings.  Write out any information
     contained in a partial block.  */
  amt = p - tmp_space;
  if (bfd_bwrite ((void *) &tmp_space[0], amt, abfd) != amt)
    return FALSE;
  *string_sizep = strings_size;
  return TRUE;
}

/* Write out the symbol string table.  */

static bfd_boolean
som_write_symbol_strings (bfd *abfd,
			  unsigned long current_offset,
			  asymbol **syms,
			  unsigned int num_syms,
			  unsigned int *string_sizep,
			  struct som_compilation_unit *compilation_unit)
{
  unsigned int i;

  /* Chunk of memory that we can use as buffer space, then throw
     away.  */
  size_t tmp_space_size = SOM_TMP_BUFSIZE;
  char *tmp_space = alloca (tmp_space_size);
  char *p = tmp_space;

  unsigned int strings_size = 0;
  bfd_size_type amt;

  /* This gets a bit gruesome because of the compilation unit.  The
     strings within the compilation unit are part of the symbol
     strings, but don't have symbol_dictionary entries.  So, manually
     write them and update the compilation unit header.  On input, the
     compilation unit header contains local copies of the strings.
     Move them aside.  */

  /* Seek to the start of the space strings in preparation for writing
     them out.  */
  if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
    return FALSE;

  if (compilation_unit)
    {
      for (i = 0; i < 4; i++)
	{
          struct som_name_pt *name;
          size_t length;

	  switch (i)
	    {
	    case 0:
	      name = &compilation_unit->name;
	      break;
	    case 1:
	      name = &compilation_unit->language_name;
	      break;
	    case 2:
	      name = &compilation_unit->product_id;
	      break;
	    case 3:
	      name = &compilation_unit->version_id;
	      break;
            default:
              abort ();
	    }

	  length = strlen (name->name);

	  /* If there is not enough room for the next entry, then dump
	     the current buffer contents now and maybe allocate a
	     larger buffer.  */
	  if (p - tmp_space + 5 + length > tmp_space_size)
	    {
	      /* Flush buffer before refilling or reallocating.  */
	      amt = p - tmp_space;
	      if (bfd_bwrite ((void *) &tmp_space[0], amt, abfd) != amt)
		return FALSE;

	      /* Reallocate if now empty buffer still too small.  */
	      if (5 + length > tmp_space_size)
		{
		  /* See alloca above for discussion of new size.  */
                  if (2 * tmp_space_size < 5 + length)
                    tmp_space_size = 5 + length;
                  else
                    tmp_space_size = 2 * tmp_space_size;
		  tmp_space = alloca (tmp_space_size);
		}

	      /* Reset to beginning of the (possibly new) buffer
		 space.  */
	      p = tmp_space;
	    }

	  /* First element in a string table entry is the length of
	     the string.  This must always be 4 byte aligned.  This is
	     also an appropriate time to fill in the string index
	     field in the symbol table entry.  */
	  bfd_put_32 (abfd, (bfd_vma) length, p);
	  strings_size += 4;
	  p += 4;

	  /* Next comes the string itself + a null terminator.  */
	  strcpy (p, name->name);

          name->strx = strings_size;

	  p += length + 1;
	  strings_size += length + 1;

	  /* Always align up to the next word boundary.  */
	  while (strings_size % 4)
	    {
	      bfd_put_8 (abfd, 0, p);
	      strings_size++;
	      p++;
	    }
	}
    }

  for (i = 0; i < num_syms; i++)
    {
      size_t length = strlen (syms[i]->name);

      /* If there is not enough room for the next entry, then dump the
	 current buffer contents now and maybe allocate a larger buffer.  */
     if (p - tmp_space + 5 + length > tmp_space_size)
	{
	  /* Flush buffer before refilling or reallocating.  */
	  amt = p - tmp_space;
	  if (bfd_bwrite ((void *) &tmp_space[0], amt, abfd) != amt)
	    return FALSE;

	  /* Reallocate if now empty buffer still too small.  */
	  if (5 + length > tmp_space_size)
	    {
	      /* See alloca above for discussion of new size.  */
              if (2 * tmp_space_size < 5 + length)
                tmp_space_size = 5 + length;
              else
                tmp_space_size = 2 * tmp_space_size;
	      tmp_space = alloca (tmp_space_size);
	    }

	  /* Reset to beginning of the (possibly new) buffer space.  */
	  p = tmp_space;
	}

      /* First element in a string table entry is the length of the
	 string.  This must always be 4 byte aligned.  This is also
	 an appropriate time to fill in the string index field in the
	 symbol table entry.  */
      bfd_put_32 (abfd, (bfd_vma) length, p);
      strings_size += 4;
      p += 4;

      /* Next comes the string itself + a null terminator.  */
      strcpy (p, syms[i]->name);

      som_symbol_data (syms[i])->stringtab_offset = strings_size;
      p += length + 1;
      strings_size += length + 1;

      /* Always align up to the next word boundary.  */
      while (strings_size % 4)
	{
	  bfd_put_8 (abfd, 0, p);
	  strings_size++;
	  p++;
	}
    }

  /* Scribble out any partial block.  */
  amt = p - tmp_space;
  if (bfd_bwrite ((void *) &tmp_space[0], amt, abfd) != amt)
    return FALSE;

  *string_sizep = strings_size;
  return TRUE;
}

/* Compute variable information to be placed in the SOM headers,
   space/subspace dictionaries, relocation streams, etc.  Begin
   writing parts of the object file.  */

static bfd_boolean
som_begin_writing (bfd *abfd)
{
  unsigned long current_offset = 0;
  unsigned int strings_size = 0;
  unsigned long num_spaces, num_subspaces, i;
  asection *section;
  unsigned int total_subspaces = 0;
  struct som_exec_auxhdr *exec_header = NULL;

  /* The file header will always be first in an object file,
     everything else can be in random locations.  To keep things
     "simple" BFD will lay out the object file in the manner suggested
     by the PRO ABI for PA-RISC Systems.  */

  /* Before any output can really begin offsets for all the major
     portions of the object file must be computed.  So, starting
     with the initial file header compute (and sometimes write)
     each portion of the object file.  */

  /* Make room for the file header, it's contents are not complete
     yet, so it can not be written at this time.  */
  current_offset += sizeof (struct som_external_header);

  /* Any auxiliary headers will follow the file header.  Right now
     we support only the copyright and version headers.  */
  obj_som_file_hdr (abfd)->aux_header_location = current_offset;
  obj_som_file_hdr (abfd)->aux_header_size = 0;
  if (abfd->flags & (EXEC_P | DYNAMIC))
    {
      /* Parts of the exec header will be filled in later, so
	 delay writing the header itself.  Fill in the defaults,
	 and write it later.  */
      current_offset += sizeof (struct som_external_exec_auxhdr);
      obj_som_file_hdr (abfd)->aux_header_size
	+= sizeof (struct som_external_exec_auxhdr);
      exec_header = obj_som_exec_hdr (abfd);
      exec_header->som_auxhdr.type = EXEC_AUX_ID;
      exec_header->som_auxhdr.length = 40;
    }
  if (obj_som_version_hdr (abfd) != NULL)
    {
      struct som_external_string_auxhdr ext_string_auxhdr;
      bfd_size_type len;

      if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
	return FALSE;

      /* Write the aux_id structure and the string length.  */
      len = sizeof (struct som_external_string_auxhdr);
      obj_som_file_hdr (abfd)->aux_header_size += len;
      current_offset += len;
      som_swap_string_auxhdr_out
        (obj_som_version_hdr (abfd), &ext_string_auxhdr);
      if (bfd_bwrite (&ext_string_auxhdr, len, abfd) != len)
	return FALSE;

      /* Write the version string.  */
      len = obj_som_version_hdr (abfd)->header_id.length - 4;
      obj_som_file_hdr (abfd)->aux_header_size += len;
      current_offset += len;
      if (bfd_bwrite ((void *) obj_som_version_hdr (abfd)->string, len, abfd)
	  != len)
	return FALSE;
    }

  if (obj_som_copyright_hdr (abfd) != NULL)
    {
      struct som_external_string_auxhdr ext_string_auxhdr;
      bfd_size_type len;

      if (bfd_seek (abfd, (file_ptr) current_offset, SEEK_SET) != 0)
	return FALSE;

      /* Write the aux_id structure and the string length.  */
      len = sizeof (struct som_external_string_auxhdr);
      obj_som_file_hdr (abfd)->aux_header_size += len;
      current_offset += len;
      som_swap_string_auxhdr_out
        (obj_som_copyright_hdr (abfd), &ext_string_auxhdr);
      if (bfd_bwrite (&ext_string_auxhdr, len, abfd) != len)
	return FALSE;

      /* Write the copyright string.  */
      len = obj_som_copyright_hdr (abfd)->header_id.length - 4;
      obj_som_file_hdr (abfd)->aux_header_size += len;
      current_offset += len;
      if (bfd_bwrite ((void *) obj_som_copyright_hdr (abfd)->string, len, abfd)
	  != len)
	return FALSE;
    }

  /* Next comes the initialization pointers; we have no initialization
     pointers, so current offset does not change.  */
  obj_som_file_hdr (abfd)->init_array_location = current_offset;
  obj_som_file_hdr (abfd)->init_array_total = 0;

  /* Next are the space records.  These are fixed length records.

     Count the number of spaces to determine how much room is needed
     in the object file for the space records.

     The names of the spaces are stored in a separate string table,
     and the index for each space into the string table is computed
     below.  Therefore, it is not possible to write the space headers
     at this time.  */
  num_spaces = som_count_spaces (abfd);
  obj_som_file_hdr (abfd)->space_location = current_offset;
  obj_som_file_hdr (abfd)->space_total = num_spaces;
  current_offset +=
    num_spaces * sizeof (struct som_external_space_dictionary_record);

  /* Next are the subspace records.  These are fixed length records.

     Count the number of subspaes to determine how much room is needed
     in the object file for the subspace records.

     A variety if fields in the subspace record are still unknown at
     this time (index into string table, fixup stream location/size, etc).  */
  num_subspaces = som_count_subspaces (abfd);
  obj_som_file_hdr (abfd)->subspace_location = current_offset;
  obj_som_file_hdr (abfd)->subspace_total = num_subspaces;
  current_offset
    += num_subspaces * sizeof (struct som_external_subspace_dictionary_record);

  /* Next is the string table for the space/subspace names.  We will
     build and write the string table on the fly.  At the same time
     we will fill in the space/subspace name index fields.  */

  /* The string table needs to be aligned on a word boundary.  */
  if (current_offset % 4)
    current_offset += (4 - (current_offset % 4));

  /* Mark the offset of the space/subspace string table in the
     file header.  */
  obj_som_file_hdr (abfd)->space_strings_location = current_offset;

  /* Scribble out the space strings.  */
  if (! som_write_space_strings (abfd, current_offset, &strings_size))
    return FALSE;

  /* Record total string table size in the header and update the
     current offset.  */
  obj_som_file_hdr (abfd)->space_strings_size = strings_size;
  current_offset += strings_size;

  /* Next is the compilation unit.  */
  obj_som_file_hdr (abfd)->compiler_location = current_offset;
  obj_som_file_hdr (abfd)->compiler_total = 0;
  if (obj_som_compilation_unit (abfd))
    {
      obj_som_file_hdr (abfd)->compiler_total = 1;
      current_offset += sizeof (struct som_external_compilation_unit);
    }

  /* Now compute the file positions for the loadable subspaces, taking
     care to make sure everything stays properly aligned.  */

  section = abfd->sections;
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;
      int first_subspace;
      unsigned int subspace_offset = 0;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      first_subspace = 1;
      /* Now look for all its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{

	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection)
	      || (subsection->flags & SEC_ALLOC) == 0)
	    continue;

	  /* If this is the first subspace in the space, and we are
	     building an executable, then take care to make sure all
	     the alignments are correct and update the exec header.  */
	  if (first_subspace
	      && (abfd->flags & (EXEC_P | DYNAMIC)))
	    {
	      /* Demand paged executables have each space aligned to a
		 page boundary.  Sharable executables (write-protected
		 text) have just the private (aka data & bss) space aligned
		 to a page boundary.  Ugh.  Not true for HPUX.

		 The HPUX kernel requires the text to always be page aligned
		 within the file regardless of the executable's type.  */
	      if (abfd->flags & (D_PAGED | DYNAMIC)
		  || (subsection->flags & SEC_CODE)
		  || ((abfd->flags & WP_TEXT)
		      && (subsection->flags & SEC_DATA)))
		current_offset = SOM_ALIGN (current_offset, PA_PAGESIZE);

	      /* Update the exec header.  */
	      if (subsection->flags & SEC_CODE && exec_header->exec_tfile == 0)
		{
		  exec_header->exec_tmem = section->vma;
		  exec_header->exec_tfile = current_offset;
		}
	      if (subsection->flags & SEC_DATA && exec_header->exec_dfile == 0)
		{
		  exec_header->exec_dmem = section->vma;
		  exec_header->exec_dfile = current_offset;
		}

	      /* Keep track of exactly where we are within a particular
		 space.  This is necessary as the braindamaged HPUX
		 loader will create holes between subspaces *and*
		 subspace alignments are *NOT* preserved.  What a crock.  */
	      subspace_offset = subsection->vma;

	      /* Only do this for the first subspace within each space.  */
	      first_subspace = 0;
	    }
	  else if (abfd->flags & (EXEC_P | DYNAMIC))
	    {
	      /* The braindamaged HPUX loader may have created a hole
		 between two subspaces.  It is *not* sufficient to use
		 the alignment specifications within the subspaces to
		 account for these holes -- I've run into at least one
		 case where the loader left one code subspace unaligned
		 in a final executable.

		 To combat this we keep a current offset within each space,
		 and use the subspace vma fields to detect and preserve
		 holes.  What a crock!

		 ps.  This is not necessary for unloadable space/subspaces.  */
	      current_offset += subsection->vma - subspace_offset;
	      if (subsection->flags & SEC_CODE)
		exec_header->exec_tsize += subsection->vma - subspace_offset;
	      else
		exec_header->exec_dsize += subsection->vma - subspace_offset;
	      subspace_offset += subsection->vma - subspace_offset;
	    }

	  subsection->target_index = total_subspaces++;
	  /* This is real data to be loaded from the file.  */
	  if (subsection->flags & SEC_LOAD)
	    {
	      /* Update the size of the code & data.  */
	      if (abfd->flags & (EXEC_P | DYNAMIC)
		  && subsection->flags & SEC_CODE)
		exec_header->exec_tsize += subsection->size;
	      else if (abfd->flags & (EXEC_P | DYNAMIC)
		       && subsection->flags & SEC_DATA)
		exec_header->exec_dsize += subsection->size;
	      som_section_data (subsection)->subspace_dict->file_loc_init_value
		= current_offset;
	      subsection->filepos = current_offset;
	      current_offset += subsection->size;
	      subspace_offset += subsection->size;
	    }
	  /* Looks like uninitialized data.  */
	  else
	    {
	      /* Update the size of the bss section.  */
	      if (abfd->flags & (EXEC_P | DYNAMIC))
		exec_header->exec_bsize += subsection->size;

	      som_section_data (subsection)->subspace_dict->file_loc_init_value
		= 0;
	      som_section_data (subsection)->subspace_dict->
		initialization_length = 0;
	    }
	}
      /* Goto the next section.  */
      section = section->next;
    }

  /* Finally compute the file positions for unloadable subspaces.
     If building an executable, start the unloadable stuff on its
     own page.  */

  if (abfd->flags & (EXEC_P | DYNAMIC))
    current_offset = SOM_ALIGN (current_offset, PA_PAGESIZE);

  obj_som_file_hdr (abfd)->unloadable_sp_location = current_offset;
  section = abfd->sections;
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      if (abfd->flags & (EXEC_P | DYNAMIC))
	current_offset = SOM_ALIGN (current_offset, PA_PAGESIZE);

      /* Now look for all its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{

	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection)
	      || (subsection->flags & SEC_ALLOC) != 0)
	    continue;

	  subsection->target_index = total_subspaces++;
	  /* This is real data to be loaded from the file.  */
	  if ((subsection->flags & SEC_LOAD) == 0)
	    {
	      som_section_data (subsection)->subspace_dict->file_loc_init_value
		= current_offset;
	      subsection->filepos = current_offset;
	      current_offset += subsection->size;
	    }
	  /* Looks like uninitialized data.  */
	  else
	    {
	      som_section_data (subsection)->subspace_dict->file_loc_init_value
		= 0;
	      som_section_data (subsection)->subspace_dict->
		initialization_length = subsection->size;
	    }
	}
      /* Goto the next section.  */
      section = section->next;
    }

  /* If building an executable, then make sure to seek to and write
     one byte at the end of the file to make sure any necessary
     zeros are filled in.  Ugh.  */
  if (abfd->flags & (EXEC_P | DYNAMIC))
    current_offset = SOM_ALIGN (current_offset, PA_PAGESIZE);
  if (bfd_seek (abfd, (file_ptr) current_offset - 1, SEEK_SET) != 0)
    return FALSE;
  if (bfd_bwrite ((void *) "", (bfd_size_type) 1, abfd) != 1)
    return FALSE;

  obj_som_file_hdr (abfd)->unloadable_sp_size
    = current_offset - obj_som_file_hdr (abfd)->unloadable_sp_location;

  /* Loader fixups are not supported in any way shape or form.  */
  obj_som_file_hdr (abfd)->loader_fixup_location = 0;
  obj_som_file_hdr (abfd)->loader_fixup_total = 0;

  /* Done.  Store the total size of the SOM so far.  */
  obj_som_file_hdr (abfd)->som_length = current_offset;

  return TRUE;
}

/* Finally, scribble out the various headers to the disk.  */

static bfd_boolean
som_finish_writing (bfd *abfd)
{
  int num_spaces = som_count_spaces (abfd);
  asymbol **syms = bfd_get_outsymbols (abfd);
  int i, num_syms;
  int subspace_index = 0;
  file_ptr location;
  asection *section;
  unsigned long current_offset;
  unsigned int strings_size, total_reloc_size;
  bfd_size_type amt;
  struct som_external_header ext_header;

  /* We must set up the version identifier here as objcopy/strip copy
     private BFD data too late for us to handle this in som_begin_writing.  */
  if (obj_som_exec_data (abfd)
      && obj_som_exec_data (abfd)->version_id)
    obj_som_file_hdr (abfd)->version_id = obj_som_exec_data (abfd)->version_id;
  else
    obj_som_file_hdr (abfd)->version_id = NEW_VERSION_ID;

  /* Next is the symbol table.  These are fixed length records.

     Count the number of symbols to determine how much room is needed
     in the object file for the symbol table.

     The names of the symbols are stored in a separate string table,
     and the index for each symbol name into the string table is computed
     below.  Therefore, it is not possible to write the symbol table
     at this time.

     These used to be output before the subspace contents, but they
     were moved here to work around a stupid bug in the hpux linker
     (fixed in hpux10).  */
  current_offset = obj_som_file_hdr (abfd)->som_length;

  /* Make sure we're on a word boundary.  */
  if (current_offset % 4)
    current_offset += (4 - (current_offset % 4));

  num_syms = bfd_get_symcount (abfd);
  obj_som_file_hdr (abfd)->symbol_location = current_offset;
  obj_som_file_hdr (abfd)->symbol_total = num_syms;
  current_offset +=
    num_syms * sizeof (struct som_external_symbol_dictionary_record);

  /* Next are the symbol strings.
     Align them to a word boundary.  */
  if (current_offset % 4)
    current_offset += (4 - (current_offset % 4));
  obj_som_file_hdr (abfd)->symbol_strings_location = current_offset;

  /* Scribble out the symbol strings.  */
  if (! som_write_symbol_strings (abfd, current_offset, syms,
				  num_syms, &strings_size,
				  obj_som_compilation_unit (abfd)))
    return FALSE;

  /* Record total string table size in header and update the
     current offset.  */
  obj_som_file_hdr (abfd)->symbol_strings_size = strings_size;
  current_offset += strings_size;

  /* Do prep work before handling fixups.  */
  som_prep_for_fixups (abfd,
		       bfd_get_outsymbols (abfd),
		       bfd_get_symcount (abfd));

  /* At the end of the file is the fixup stream which starts on a
     word boundary.  */
  if (current_offset % 4)
    current_offset += (4 - (current_offset % 4));
  obj_som_file_hdr (abfd)->fixup_request_location = current_offset;

  /* Write the fixups and update fields in subspace headers which
     relate to the fixup stream.  */
  if (! som_write_fixups (abfd, current_offset, &total_reloc_size))
    return FALSE;

  /* Record the total size of the fixup stream in the file header.  */
  obj_som_file_hdr (abfd)->fixup_request_total = total_reloc_size;

  /* Done.  Store the total size of the SOM.  */
  obj_som_file_hdr (abfd)->som_length = current_offset + total_reloc_size;

  /* Now that the symbol table information is complete, build and
     write the symbol table.  */
  if (! som_build_and_write_symbol_table (abfd))
    return FALSE;

  /* Subspaces are written first so that we can set up information
     about them in their containing spaces as the subspace is written.  */

  /* Seek to the start of the subspace dictionary records.  */
  location = obj_som_file_hdr (abfd)->subspace_location;
  if (bfd_seek (abfd, location, SEEK_SET) != 0)
    return FALSE;

  section = abfd->sections;
  /* Now for each loadable space write out records for its subspaces.  */
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      /* Now look for all its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{
          struct som_external_subspace_dictionary_record ext_subspace_dict;

	  /* Skip any section which does not correspond to a space
	     or subspace.  Or does not have SEC_ALLOC set (and therefore
	     has no real bits on the disk).  */
	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection)
	      || (subsection->flags & SEC_ALLOC) == 0)
	    continue;

	  /* If this is the first subspace for this space, then save
	     the index of the subspace in its containing space.  Also
	     set "is_loadable" in the containing space.  */

	  if (som_section_data (section)->space_dict->subspace_quantity == 0)
	    {
	      som_section_data (section)->space_dict->is_loadable = 1;
	      som_section_data (section)->space_dict->subspace_index
		= subspace_index;
	    }

	  /* Increment the number of subspaces seen and the number of
	     subspaces contained within the current space.  */
	  subspace_index++;
	  som_section_data (section)->space_dict->subspace_quantity++;

	  /* Mark the index of the current space within the subspace's
	     dictionary record.  */
	  som_section_data (subsection)->subspace_dict->space_index = i;

	  /* Dump the current subspace header.  */
          som_swap_subspace_dictionary_record_out
            (som_section_data (subsection)->subspace_dict, &ext_subspace_dict);
	  amt = sizeof (struct som_subspace_dictionary_record);
	  if (bfd_bwrite (&ext_subspace_dict, amt, abfd) != amt)
	    return FALSE;
	}
      /* Goto the next section.  */
      section = section->next;
    }

  /* Now repeat the process for unloadable subspaces.  */
  section = abfd->sections;
  /* Now for each space write out records for its subspaces.  */
  for (i = 0; i < num_spaces; i++)
    {
      asection *subsection;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      /* Now look for all its subspaces.  */
      for (subsection = abfd->sections;
	   subsection != NULL;
	   subsection = subsection->next)
	{
          struct som_external_subspace_dictionary_record ext_subspace_dict;

	  /* Skip any section which does not correspond to a space or
	     subspace, or which SEC_ALLOC set (and therefore handled
	     in the loadable spaces/subspaces code above).  */

	  if (!som_is_subspace (subsection)
	      || !som_is_container (section, subsection)
	      || (subsection->flags & SEC_ALLOC) != 0)
	    continue;

	  /* If this is the first subspace for this space, then save
	     the index of the subspace in its containing space.  Clear
	     "is_loadable".  */

	  if (som_section_data (section)->space_dict->subspace_quantity == 0)
	    {
	      som_section_data (section)->space_dict->is_loadable = 0;
	      som_section_data (section)->space_dict->subspace_index
		= subspace_index;
	    }

	  /* Increment the number of subspaces seen and the number of
	     subspaces contained within the current space.  */
	  som_section_data (section)->space_dict->subspace_quantity++;
	  subspace_index++;

	  /* Mark the index of the current space within the subspace's
	     dictionary record.  */
	  som_section_data (subsection)->subspace_dict->space_index = i;

	  /* Dump this subspace header.  */
          som_swap_subspace_dictionary_record_out
            (som_section_data (subsection)->subspace_dict, &ext_subspace_dict);
	  amt = sizeof (struct som_subspace_dictionary_record);
	  if (bfd_bwrite (&ext_subspace_dict, amt, abfd) != amt)
	    return FALSE;
	}
      /* Goto the next section.  */
      section = section->next;
    }

  /* All the subspace dictionary records are written, and all the
     fields are set up in the space dictionary records.

     Seek to the right location and start writing the space
     dictionary records.  */
  location = obj_som_file_hdr (abfd)->space_location;
  if (bfd_seek (abfd, location, SEEK_SET) != 0)
    return FALSE;

  section = abfd->sections;
  for (i = 0; i < num_spaces; i++)
    {
      struct som_external_space_dictionary_record ext_space_dict;

      /* Find a space.  */
      while (!som_is_space (section))
	section = section->next;

      /* Dump its header.  */
      som_swap_space_dictionary_out (som_section_data (section)->space_dict,
                                     &ext_space_dict);
      amt = sizeof (struct som_external_space_dictionary_record);
      if (bfd_bwrite (&ext_space_dict, amt, abfd) != amt)
	return FALSE;

      /* Goto the next section.  */
      section = section->next;
    }

  /* Write the compilation unit record if there is one.  */
  if (obj_som_compilation_unit (abfd))
    {
      struct som_external_compilation_unit ext_comp_unit;

      location = obj_som_file_hdr (abfd)->compiler_location;
      if (bfd_seek (abfd, location, SEEK_SET) != 0)
	return FALSE;

      som_swap_compilation_unit_out
        (obj_som_compilation_unit (abfd), &ext_comp_unit);

      amt = sizeof (struct som_external_compilation_unit);
      if (bfd_bwrite (&ext_comp_unit, amt, abfd) != amt)
	return FALSE;
    }

  /* Setting of the system_id has to happen very late now that copying of
     BFD private data happens *after* section contents are set.  */
  if (abfd->flags & (EXEC_P | DYNAMIC))
    obj_som_file_hdr (abfd)->system_id = obj_som_exec_data (abfd)->system_id;
  else if (bfd_get_mach (abfd) == pa20)
    obj_som_file_hdr (abfd)->system_id = CPU_PA_RISC2_0;
  else if (bfd_get_mach (abfd) == pa11)
    obj_som_file_hdr (abfd)->system_id = CPU_PA_RISC1_1;
  else
    obj_som_file_hdr (abfd)->system_id = CPU_PA_RISC1_0;

  /* Swap and compute the checksum for the file header just before writing
     the header to disk.  */
  som_swap_header_out (obj_som_file_hdr (abfd), &ext_header);
  bfd_putb32 (som_compute_checksum (&ext_header), ext_header.checksum);

  /* Only thing left to do is write out the file header.  It is always
     at location zero.  Seek there and write it.  */
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) != 0)
    return FALSE;
  amt = sizeof (struct som_external_header);
  if (bfd_bwrite (&ext_header, amt, abfd) != amt)
    return FALSE;

  /* Now write the exec header.  */
  if (abfd->flags & (EXEC_P | DYNAMIC))
    {
      long tmp, som_length;
      struct som_exec_auxhdr *exec_header;
      struct som_external_exec_auxhdr ext_exec_header;

      exec_header = obj_som_exec_hdr (abfd);
      exec_header->exec_entry = bfd_get_start_address (abfd);
      exec_header->exec_flags = obj_som_exec_data (abfd)->exec_flags;

      /* Oh joys.  Ram some of the BSS data into the DATA section
	 to be compatible with how the hp linker makes objects
	 (saves memory space).  */
      tmp = exec_header->exec_dsize;
      tmp = SOM_ALIGN (tmp, PA_PAGESIZE);
      exec_header->exec_bsize -= (tmp - exec_header->exec_dsize);
      if (exec_header->exec_bsize < 0)
	exec_header->exec_bsize = 0;
      exec_header->exec_dsize = tmp;

      /* Now perform some sanity checks.  The idea is to catch bogons now and
	 inform the user, instead of silently generating a bogus file.  */
      som_length = obj_som_file_hdr (abfd)->som_length;
      if (exec_header->exec_tfile + exec_header->exec_tsize > som_length
	  || exec_header->exec_dfile + exec_header->exec_dsize > som_length)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      som_swap_exec_auxhdr_out (exec_header, &ext_exec_header);

      if (bfd_seek (abfd, obj_som_file_hdr (abfd)->aux_header_location,
		    SEEK_SET) != 0)
	return FALSE;

      amt = sizeof (ext_exec_header);
      if (bfd_bwrite (&ext_exec_header, amt, abfd) != amt)
	return FALSE;
    }
  return TRUE;
}

/* Compute and return the checksum for a SOM file header.  */

static unsigned long
som_compute_checksum (struct som_external_header *hdr)
{
  unsigned long checksum, count, i;
  unsigned long *buffer = (unsigned long *) hdr;

  checksum = 0;
  count = sizeof (struct som_external_header) / 4;
  for (i = 0; i < count; i++)
    checksum ^= *(buffer + i);

  return checksum;
}

static void
som_bfd_derive_misc_symbol_info (bfd *abfd ATTRIBUTE_UNUSED,
				 asymbol *sym,
				 struct som_misc_symbol_info *info)
{
  /* Initialize.  */
  memset (info, 0, sizeof (struct som_misc_symbol_info));

  /* The HP SOM linker requires detailed type information about
     all symbols (including undefined symbols!).  Unfortunately,
     the type specified in an import/export statement does not
     always match what the linker wants.  Severe braindamage.  */

  /* Section symbols will not have a SOM symbol type assigned to
     them yet.  Assign all section symbols type ST_DATA.  */
  if (sym->flags & BSF_SECTION_SYM)
    info->symbol_type = ST_DATA;
  else
    {
      /* For BFD style common, the linker will choke unless we set the
	 type and scope to ST_STORAGE and SS_UNSAT, respectively.  */
      if (bfd_is_com_section (sym->section))
	{
	  info->symbol_type = ST_STORAGE;
	  info->symbol_scope = SS_UNSAT;
	}

      /* It is possible to have a symbol without an associated
	 type.  This happens if the user imported the symbol
	 without a type and the symbol was never defined
	 locally.  If BSF_FUNCTION is set for this symbol, then
	 assign it type ST_CODE (the HP linker requires undefined
	 external functions to have type ST_CODE rather than ST_ENTRY).  */
      else if ((som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN
		|| som_symbol_data (sym)->som_type == SYMBOL_TYPE_CODE)
	       && bfd_is_und_section (sym->section)
	       && sym->flags & BSF_FUNCTION)
	info->symbol_type = ST_CODE;

      /* Handle function symbols which were defined in this file.
	 They should have type ST_ENTRY.  Also retrieve the argument
	 relocation bits from the SOM backend information.  */
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_ENTRY
	       || (som_symbol_data (sym)->som_type == SYMBOL_TYPE_CODE
		   && (sym->flags & BSF_FUNCTION))
	       || (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN
		   && (sym->flags & BSF_FUNCTION)))
	{
	  info->symbol_type = ST_ENTRY;
	  info->arg_reloc = som_symbol_data (sym)->tc_data.ap.hppa_arg_reloc;
	  info->priv_level= som_symbol_data (sym)->tc_data.ap.hppa_priv_level;
	}

      /* For unknown symbols set the symbol's type based on the symbol's
	 section (ST_DATA for DATA sections, ST_CODE for CODE sections).  */
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN)
	{
	  if (bfd_is_abs_section (sym->section))
	    info->symbol_type = ST_ABSOLUTE;
	  else if (sym->section->flags & SEC_CODE)
	    info->symbol_type = ST_CODE;
	  else
	    info->symbol_type = ST_DATA;
	}

      /* From now on it's a very simple mapping.  */
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_ABSOLUTE)
	info->symbol_type = ST_ABSOLUTE;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_CODE)
	info->symbol_type = ST_CODE;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_DATA)
	info->symbol_type = ST_DATA;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_MILLICODE)
	info->symbol_type = ST_MILLICODE;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_PLABEL)
	info->symbol_type = ST_PLABEL;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_PRI_PROG)
	info->symbol_type = ST_PRI_PROG;
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_SEC_PROG)
	info->symbol_type = ST_SEC_PROG;
    }

  /* Now handle the symbol's scope.  Exported data which is not
     in the common section has scope SS_UNIVERSAL.  Note scope
     of common symbols was handled earlier!  */
  if (bfd_is_com_section (sym->section))
    ;
  else if (bfd_is_und_section (sym->section))
    info->symbol_scope = SS_UNSAT;
  else if (sym->flags & (BSF_EXPORT | BSF_WEAK))
    info->symbol_scope = SS_UNIVERSAL;
  /* Anything else which is not in the common section has scope
     SS_LOCAL.  */
  else
    info->symbol_scope = SS_LOCAL;

  /* Now set the symbol_info field.  It has no real meaning
     for undefined or common symbols, but the HP linker will
     choke if it's not set to some "reasonable" value.  We
     use zero as a reasonable value.  */
  if (bfd_is_com_section (sym->section)
      || bfd_is_und_section (sym->section)
      || bfd_is_abs_section (sym->section))
    info->symbol_info = 0;
  /* For all other symbols, the symbol_info field contains the
     subspace index of the space this symbol is contained in.  */
  else
    info->symbol_info = sym->section->target_index;

  /* Set the symbol's value.  */
  info->symbol_value = sym->value + sym->section->vma;

  /* The secondary_def field is for "weak" symbols.  */
  if (sym->flags & BSF_WEAK)
    info->secondary_def = TRUE;
  else
    info->secondary_def = FALSE;

  /* The is_comdat, is_common and dup_common fields provide various
     flavors of common.

     For data symbols, setting IS_COMMON provides Fortran style common
     (duplicate definitions and overlapped initialization).  Setting both
     IS_COMMON and DUP_COMMON provides Cobol style common (duplicate
     definitions as long as they are all the same length).  In a shared
     link data symbols retain their IS_COMMON and DUP_COMMON flags.
     An IS_COMDAT data symbol is similar to a IS_COMMON | DUP_COMMON
     symbol except in that it loses its IS_COMDAT flag in a shared link.

     For code symbols, IS_COMDAT and DUP_COMMON have effect.  Universal
     DUP_COMMON code symbols are not exported from shared libraries.
     IS_COMDAT symbols are exported but they lose their IS_COMDAT flag.

     We take a simplified approach to setting the is_comdat, is_common
     and dup_common flags in symbols based on the flag settings of their
     subspace.  This avoids having to add directives like `.comdat' but
     the linker behavior is probably undefined if there is more than one
     universal symbol (comdat key sysmbol) in a subspace.

     The behavior of these flags is not well documentmented, so there
     may be bugs and some surprising interactions with other flags.  */
  if (som_section_data (sym->section)
      && som_section_data (sym->section)->subspace_dict
      && info->symbol_scope == SS_UNIVERSAL
      && (info->symbol_type == ST_ENTRY
	  || info->symbol_type == ST_CODE
	  || info->symbol_type == ST_DATA))
    {
      info->is_comdat
	= som_section_data (sym->section)->subspace_dict->is_comdat;
      info->is_common
	= som_section_data (sym->section)->subspace_dict->is_common;
      info->dup_common
	= som_section_data (sym->section)->subspace_dict->dup_common;
    }
}

/* Build and write, in one big chunk, the entire symbol table for
   this BFD.  */

static bfd_boolean
som_build_and_write_symbol_table (bfd *abfd)
{
  unsigned int num_syms = bfd_get_symcount (abfd);
  file_ptr symtab_location = obj_som_file_hdr (abfd)->symbol_location;
  asymbol **bfd_syms = obj_som_sorted_syms (abfd);
  struct som_external_symbol_dictionary_record *som_symtab = NULL;
  unsigned int i;
  bfd_size_type symtab_size;

  /* Compute total symbol table size and allocate a chunk of memory
     to hold the symbol table as we build it.  */
  symtab_size = num_syms;
  symtab_size *= sizeof (struct som_external_symbol_dictionary_record);
  som_symtab = bfd_zmalloc (symtab_size);
  if (som_symtab == NULL && symtab_size != 0)
    goto error_return;

  /* Walk over each symbol.  */
  for (i = 0; i < num_syms; i++)
    {
      struct som_misc_symbol_info info;
      unsigned int flags;

      /* This is really an index into the symbol strings table.
	 By the time we get here, the index has already been
	 computed and stored into the name field in the BFD symbol.  */
      bfd_putb32 (som_symbol_data (bfd_syms[i])->stringtab_offset,
                  som_symtab[i].name);

      /* Derive SOM information from the BFD symbol.  */
      som_bfd_derive_misc_symbol_info (abfd, bfd_syms[i], &info);

      /* Now use it.  */
      flags = (info.symbol_type << SOM_SYMBOL_TYPE_SH)
        | (info.symbol_scope << SOM_SYMBOL_SCOPE_SH)
        | (info.arg_reloc << SOM_SYMBOL_ARG_RELOC_SH)
        | (3 << SOM_SYMBOL_XLEAST_SH)
        | (info.secondary_def ? SOM_SYMBOL_SECONDARY_DEF : 0)
        | (info.is_common ? SOM_SYMBOL_IS_COMMON : 0)
        | (info.dup_common ? SOM_SYMBOL_DUP_COMMON : 0);
      bfd_putb32 (flags, som_symtab[i].flags);

      flags = (info.symbol_info << SOM_SYMBOL_SYMBOL_INFO_SH)
        | (info.is_comdat ? SOM_SYMBOL_IS_COMDAT : 0);
      bfd_putb32 (flags, som_symtab[i].info);
      bfd_putb32 (info.symbol_value | info.priv_level,
                  som_symtab[i].symbol_value);
    }

  /* Everything is ready, seek to the right location and
     scribble out the symbol table.  */
  if (bfd_seek (abfd, symtab_location, SEEK_SET) != 0)
    return FALSE;

  if (bfd_bwrite ((void *) som_symtab, symtab_size, abfd) != symtab_size)
    goto error_return;

  if (som_symtab != NULL)
    free (som_symtab);
  return TRUE;
 error_return:
  if (som_symtab != NULL)
    free (som_symtab);
  return FALSE;
}

/* Write an object in SOM format.  */

static bfd_boolean
som_write_object_contents (bfd *abfd)
{
  if (! abfd->output_has_begun)
    {
      /* Set up fixed parts of the file, space, and subspace headers.
	 Notify the world that output has begun.  */
      som_prep_headers (abfd);
      abfd->output_has_begun = TRUE;
      /* Start writing the object file.  This include all the string
	 tables, fixup streams, and other portions of the object file.  */
      som_begin_writing (abfd);
    }

  return som_finish_writing (abfd);
}

/* Read and save the string table associated with the given BFD.  */

static bfd_boolean
som_slurp_string_table (bfd *abfd)
{
  char *stringtab;
  bfd_size_type amt;

  /* Use the saved version if its available.  */
  if (obj_som_stringtab (abfd) != NULL)
    return TRUE;

  /* I don't think this can currently happen, and I'm not sure it should
     really be an error, but it's better than getting unpredictable results
     from the host's malloc when passed a size of zero.  */
  if (obj_som_stringtab_size (abfd) == 0)
    {
      bfd_set_error (bfd_error_no_symbols);
      return FALSE;
    }

  /* Allocate and read in the string table.  */
  amt = obj_som_stringtab_size (abfd);
  stringtab = bfd_zmalloc (amt);
  if (stringtab == NULL)
    return FALSE;

  if (bfd_seek (abfd, obj_som_str_filepos (abfd), SEEK_SET) != 0)
    return FALSE;

  if (bfd_bread (stringtab, amt, abfd) != amt)
    return FALSE;

  /* Save our results and return success.  */
  obj_som_stringtab (abfd) = stringtab;
  return TRUE;
}

/* Return the amount of data (in bytes) required to hold the symbol
   table for this object.  */

static long
som_get_symtab_upper_bound (bfd *abfd)
{
  if (!som_slurp_symbol_table (abfd))
    return -1;

  return (bfd_get_symcount (abfd) + 1) * sizeof (asymbol *);
}

/* Convert from a SOM subspace index to a BFD section.  */

asection *
bfd_section_from_som_symbol
  (bfd *abfd, struct som_external_symbol_dictionary_record *symbol)
{
  asection *section;
  unsigned int flags = bfd_getb32 (symbol->flags);
  unsigned int symbol_type = (flags >> SOM_SYMBOL_TYPE_SH) & SOM_SYMBOL_TYPE_MASK;

  /* The meaning of the symbol_info field changes for functions
     within executables.  So only use the quick symbol_info mapping for
     incomplete objects and non-function symbols in executables.  */
  if ((abfd->flags & (EXEC_P | DYNAMIC)) == 0
      || (symbol_type != ST_ENTRY
	  && symbol_type != ST_PRI_PROG
	  && symbol_type != ST_SEC_PROG
	  && symbol_type != ST_MILLICODE))
    {
      int idx = (bfd_getb32 (symbol->info) >> SOM_SYMBOL_SYMBOL_INFO_SH)
        & SOM_SYMBOL_SYMBOL_INFO_MASK;

      for (section = abfd->sections; section != NULL; section = section->next)
	if (section->target_index == idx && som_is_subspace (section))
	  return section;
    }
  else
    {
      unsigned int value = bfd_getb32 (symbol->symbol_value);

      /* For executables we will have to use the symbol's address and
	 find out what section would contain that address.   Yuk.  */
      for (section = abfd->sections; section; section = section->next)
	if (value >= section->vma
	    && value <= section->vma + section->size
	    && som_is_subspace (section))
	  return section;
    }

  /* Could be a symbol from an external library (such as an OMOS
     shared library).  Don't abort.  */
  return bfd_abs_section_ptr;
}

/* Read and save the symbol table associated with the given BFD.  */

static unsigned int
som_slurp_symbol_table (bfd *abfd)
{
  int symbol_count = bfd_get_symcount (abfd);
  int symsize = sizeof (struct som_external_symbol_dictionary_record);
  char *stringtab;
  struct som_external_symbol_dictionary_record *buf = NULL, *bufp, *endbufp;
  som_symbol_type *sym, *symbase;
  bfd_size_type amt;

  /* Return saved value if it exists.  */
  if (obj_som_symtab (abfd) != NULL)
    goto successful_return;

  /* Special case.  This is *not* an error.  */
  if (symbol_count == 0)
    goto successful_return;

  if (!som_slurp_string_table (abfd))
    goto error_return;

  stringtab = obj_som_stringtab (abfd);

  amt = symbol_count;
  amt *= sizeof (som_symbol_type);
  symbase = bfd_zmalloc (amt);
  if (symbase == NULL)
    goto error_return;

  /* Read in the external SOM representation.  */
  amt = symbol_count;
  amt *= symsize;
  buf = bfd_malloc (amt);
  if (buf == NULL && amt != 0)
    goto error_return;
  if (bfd_seek (abfd, obj_som_sym_filepos (abfd), SEEK_SET) != 0)
    goto error_return;
  if (bfd_bread (buf, amt, abfd) != amt)
    goto error_return;

  /* Iterate over all the symbols and internalize them.  */
  endbufp = buf + symbol_count;
  for (bufp = buf, sym = symbase; bufp < endbufp; ++bufp)
    {
      unsigned int flags = bfd_getb32 (bufp->flags);
      unsigned int symbol_type =
        (flags >> SOM_SYMBOL_TYPE_SH) & SOM_SYMBOL_TYPE_MASK;
      unsigned int symbol_scope =
        (flags >> SOM_SYMBOL_SCOPE_SH) & SOM_SYMBOL_SCOPE_MASK;

      /* I don't think we care about these.  */
      if (symbol_type == ST_SYM_EXT || symbol_type == ST_ARG_EXT)
	continue;

      /* Set some private data we care about.  */
      if (symbol_type == ST_NULL)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_UNKNOWN;
      else if (symbol_type == ST_ABSOLUTE)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_ABSOLUTE;
      else if (symbol_type == ST_DATA)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_DATA;
      else if (symbol_type == ST_CODE)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_CODE;
      else if (symbol_type == ST_PRI_PROG)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_PRI_PROG;
      else if (symbol_type == ST_SEC_PROG)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_SEC_PROG;
      else if (symbol_type == ST_ENTRY)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_ENTRY;
      else if (symbol_type == ST_MILLICODE)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_MILLICODE;
      else if (symbol_type == ST_PLABEL)
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_PLABEL;
      else
	som_symbol_data (sym)->som_type = SYMBOL_TYPE_UNKNOWN;
      som_symbol_data (sym)->tc_data.ap.hppa_arg_reloc =
        (flags >> SOM_SYMBOL_ARG_RELOC_SH) & SOM_SYMBOL_ARG_RELOC_MASK;

      /* Some reasonable defaults.  */
      sym->symbol.the_bfd = abfd;
      sym->symbol.name = bfd_getb32 (bufp->name) + stringtab;
      sym->symbol.value = bfd_getb32 (bufp->symbol_value);
      sym->symbol.section = 0;
      sym->symbol.flags = 0;

      switch (symbol_type)
	{
	case ST_ENTRY:
	case ST_MILLICODE:
	  sym->symbol.flags |= BSF_FUNCTION;
	  som_symbol_data (sym)->tc_data.ap.hppa_priv_level =
	    sym->symbol.value & 0x3;
	  sym->symbol.value &= ~0x3;
	  break;

	case ST_STUB:
	case ST_CODE:
	case ST_PRI_PROG:
	case ST_SEC_PROG:
	  som_symbol_data (sym)->tc_data.ap.hppa_priv_level =
	    sym->symbol.value & 0x3;
	  sym->symbol.value &= ~0x3;
	  /* If the symbol's scope is SS_UNSAT, then these are
	     undefined function symbols.  */
	  if (symbol_scope == SS_UNSAT)
	    sym->symbol.flags |= BSF_FUNCTION;

	default:
	  break;
	}

      /* Handle scoping and section information.  */
      switch (symbol_scope)
	{
	/* symbol_info field is undefined for SS_EXTERNAL and SS_UNSAT symbols,
	   so the section associated with this symbol can't be known.  */
	case SS_EXTERNAL:
	  if (symbol_type != ST_STORAGE)
	    sym->symbol.section = bfd_und_section_ptr;
	  else
	    sym->symbol.section = bfd_com_section_ptr;
	  sym->symbol.flags |= (BSF_EXPORT | BSF_GLOBAL);
	  break;

	case SS_UNSAT:
	  if (symbol_type != ST_STORAGE)
	    sym->symbol.section = bfd_und_section_ptr;
	  else
	    sym->symbol.section = bfd_com_section_ptr;
	  break;

	case SS_UNIVERSAL:
	  sym->symbol.flags |= (BSF_EXPORT | BSF_GLOBAL);
	  sym->symbol.section = bfd_section_from_som_symbol (abfd, bufp);
	  sym->symbol.value -= sym->symbol.section->vma;
	  break;

	case SS_LOCAL:
	  sym->symbol.flags |= BSF_LOCAL;
	  sym->symbol.section = bfd_section_from_som_symbol (abfd, bufp);
	  sym->symbol.value -= sym->symbol.section->vma;
	  break;
	}

      /* Check for a weak symbol.  */
      if (flags & SOM_SYMBOL_SECONDARY_DEF)
	sym->symbol.flags |= BSF_WEAK;

      /* Mark section symbols and symbols used by the debugger.
	 Note $START$ is a magic code symbol, NOT a section symbol.  */
      if (sym->symbol.name[0] == '$'
	  && sym->symbol.name[strlen (sym->symbol.name) - 1] == '$'
	  && !strcmp (sym->symbol.name, sym->symbol.section->name))
	sym->symbol.flags |= BSF_SECTION_SYM;
      else if (CONST_STRNEQ (sym->symbol.name, "L$0\002"))
	{
	  sym->symbol.flags |= BSF_SECTION_SYM;
	  sym->symbol.name = sym->symbol.section->name;
	}
      else if (CONST_STRNEQ (sym->symbol.name, "L$0\001"))
	sym->symbol.flags |= BSF_DEBUGGING;

      /* Note increment at bottom of loop, since we skip some symbols
	 we can not include it as part of the for statement.  */
      sym++;
    }

  /* We modify the symbol count to record the number of BFD symbols we
     created.  */
  bfd_get_symcount (abfd) = sym - symbase;

  /* Save our results and return success.  */
  obj_som_symtab (abfd) = symbase;
 successful_return:
  if (buf != NULL)
    free (buf);
  return (TRUE);

 error_return:
  if (buf != NULL)
    free (buf);
  return FALSE;
}

/* Canonicalize a SOM symbol table.  Return the number of entries
   in the symbol table.  */

static long
som_canonicalize_symtab (bfd *abfd, asymbol **location)
{
  int i;
  som_symbol_type *symbase;

  if (!som_slurp_symbol_table (abfd))
    return -1;

  i = bfd_get_symcount (abfd);
  symbase = obj_som_symtab (abfd);

  for (; i > 0; i--, location++, symbase++)
    *location = &symbase->symbol;

  /* Final null pointer.  */
  *location = 0;
  return (bfd_get_symcount (abfd));
}

/* Make a SOM symbol.  There is nothing special to do here.  */

static asymbol *
som_make_empty_symbol (bfd *abfd)
{
  bfd_size_type amt = sizeof (som_symbol_type);
  som_symbol_type *new_symbol_type = bfd_zalloc (abfd, amt);

  if (new_symbol_type == NULL)
    return NULL;
  new_symbol_type->symbol.the_bfd = abfd;

  return &new_symbol_type->symbol;
}

/* Print symbol information.  */

static void
som_print_symbol (bfd *abfd,
		  void *afile,
		  asymbol *symbol,
		  bfd_print_symbol_type how)
{
  FILE *file = (FILE *) afile;

  switch (how)
    {
    case bfd_print_symbol_name:
      fprintf (file, "%s", symbol->name);
      break;
    case bfd_print_symbol_more:
      fprintf (file, "som ");
      fprintf_vma (file, symbol->value);
      fprintf (file, " %lx", (long) symbol->flags);
      break;
    case bfd_print_symbol_all:
      {
	const char *section_name;

	section_name = symbol->section ? symbol->section->name : "(*none*)";
	bfd_print_symbol_vandf (abfd, (void *) file, symbol);
	fprintf (file, " %s\t%s", section_name, symbol->name);
	break;
      }
    }
}

static bfd_boolean
som_bfd_is_local_label_name (bfd *abfd ATTRIBUTE_UNUSED,
			     const char *name)
{
  return name[0] == 'L' && name[1] == '$';
}

/* Count or process variable-length SOM fixup records.

   To avoid code duplication we use this code both to compute the number
   of relocations requested by a stream, and to internalize the stream.

   When computing the number of relocations requested by a stream the
   variables rptr, section, and symbols have no meaning.

   Return the number of relocations requested by the fixup stream.  When
   not just counting

   This needs at least two or three more passes to get it cleaned up.  */

static unsigned int
som_set_reloc_info (unsigned char *fixup,
		    unsigned int end,
		    arelent *internal_relocs,
		    asection *section,
		    asymbol **symbols,
		    bfd_boolean just_count)
{
  unsigned int op, varname, deallocate_contents = 0;
  unsigned char *end_fixups = &fixup[end];
  const struct fixup_format *fp;
  const char *cp;
  unsigned char *save_fixup;
  int variables[26], stack[20], c, v, count, prev_fixup, *sp, saved_unwind_bits;
  const int *subop;
  arelent *rptr = internal_relocs;
  unsigned int offset = 0;

#define	var(c)		variables[(c) - 'A']
#define	push(v)		(*sp++ = (v))
#define	pop()		(*--sp)
#define	emptystack()	(sp == stack)

  som_initialize_reloc_queue (reloc_queue);
  memset (variables, 0, sizeof (variables));
  memset (stack, 0, sizeof (stack));
  count = 0;
  prev_fixup = 0;
  saved_unwind_bits = 0;
  sp = stack;

  while (fixup < end_fixups)
    {
      /* Save pointer to the start of this fixup.  We'll use
	 it later to determine if it is necessary to put this fixup
	 on the queue.  */
      save_fixup = fixup;

      /* Get the fixup code and its associated format.  */
      op = *fixup++;
      fp = &som_fixup_formats[op];

      /* Handle a request for a previous fixup.  */
      if (*fp->format == 'P')
	{
	  /* Get pointer to the beginning of the prev fixup, move
	     the repeated fixup to the head of the queue.  */
	  fixup = reloc_queue[fp->D].reloc;
	  som_reloc_queue_fix (reloc_queue, fp->D);
	  prev_fixup = 1;

	  /* Get the fixup code and its associated format.  */
	  op = *fixup++;
	  fp = &som_fixup_formats[op];
	}

      /* If this fixup will be passed to BFD, set some reasonable defaults.  */
      if (! just_count
	  && som_hppa_howto_table[op].type != R_NO_RELOCATION
	  && som_hppa_howto_table[op].type != R_DATA_OVERRIDE)
	{
	  rptr->address = offset;
	  rptr->howto = &som_hppa_howto_table[op];
	  rptr->addend = 0;
	  rptr->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
	}

      /* Set default input length to 0.  Get the opcode class index
	 into D.  */
      var ('L') = 0;
      var ('D') = fp->D;
      var ('U') = saved_unwind_bits;

      /* Get the opcode format.  */
      cp = fp->format;

      /* Process the format string.  Parsing happens in two phases,
	 parse RHS, then assign to LHS.  Repeat until no more
	 characters in the format string.  */
      while (*cp)
	{
	  /* The variable this pass is going to compute a value for.  */
	  varname = *cp++;

	  /* Start processing RHS.  Continue until a NULL or '=' is found.  */
	  do
	    {
	      c = *cp++;

	      /* If this is a variable, push it on the stack.  */
	      if (ISUPPER (c))
		push (var (c));

	      /* If this is a lower case letter, then it represents
		 additional data from the fixup stream to be pushed onto
		 the stack.  */
	      else if (ISLOWER (c))
		{
		  int bits = (c - 'a') * 8;
		  for (v = 0; c > 'a'; --c)
		    v = (v << 8) | *fixup++;
		  if (varname == 'V')
		    v = sign_extend (v, bits);
		  push (v);
		}

	      /* A decimal constant.  Push it on the stack.  */
	      else if (ISDIGIT (c))
		{
		  v = c - '0';
		  while (ISDIGIT (*cp))
		    v = (v * 10) + (*cp++ - '0');
		  push (v);
		}
	      else
		/* An operator.  Pop two two values from the stack and
		   use them as operands to the given operation.  Push
		   the result of the operation back on the stack.  */
		switch (c)
		  {
		  case '+':
		    v = pop ();
		    v += pop ();
		    push (v);
		    break;
		  case '*':
		    v = pop ();
		    v *= pop ();
		    push (v);
		    break;
		  case '<':
		    v = pop ();
		    v = pop () << v;
		    push (v);
		    break;
		  default:
		    abort ();
		  }
	    }
	  while (*cp && *cp != '=');

	  /* Move over the equal operator.  */
	  cp++;

	  /* Pop the RHS off the stack.  */
	  c = pop ();

	  /* Perform the assignment.  */
	  var (varname) = c;

	  /* Handle side effects. and special 'O' stack cases.  */
	  switch (varname)
	    {
	    /* Consume some bytes from the input space.  */
	    case 'L':
	      offset += c;
	      break;
	    /* A symbol to use in the relocation.  Make a note
	       of this if we are not just counting.  */
	    case 'S':
	      if (! just_count)
		rptr->sym_ptr_ptr = &symbols[c];
	      break;
	    /* Argument relocation bits for a function call.  */
	    case 'R':
	      if (! just_count)
		{
		  unsigned int tmp = var ('R');
		  rptr->addend = 0;

		  if ((som_hppa_howto_table[op].type == R_PCREL_CALL
		       && R_PCREL_CALL + 10 > op)
		      || (som_hppa_howto_table[op].type == R_ABS_CALL
			  && R_ABS_CALL + 10 > op))
		    {
		      /* Simple encoding.  */
		      if (tmp > 4)
			{
			  tmp -= 5;
			  rptr->addend |= 1;
			}
		      if (tmp == 4)
			rptr->addend |= 1 << 8 | 1 << 6 | 1 << 4 | 1 << 2;
		      else if (tmp == 3)
			rptr->addend |= 1 << 8 | 1 << 6 | 1 << 4;
		      else if (tmp == 2)
			rptr->addend |= 1 << 8 | 1 << 6;
		      else if (tmp == 1)
			rptr->addend |= 1 << 8;
		    }
		  else
		    {
		      unsigned int tmp1, tmp2;

		      /* First part is easy -- low order two bits are
			 directly copied, then shifted away.  */
		      rptr->addend = tmp & 0x3;
		      tmp >>= 2;

		      /* Diving the result by 10 gives us the second
			 part.  If it is 9, then the first two words
			 are a double precision paramater, else it is
			 3 * the first arg bits + the 2nd arg bits.  */
		      tmp1 = tmp / 10;
		      tmp -= tmp1 * 10;
		      if (tmp1 == 9)
			rptr->addend += (0xe << 6);
		      else
			{
			  /* Get the two pieces.  */
			  tmp2 = tmp1 / 3;
			  tmp1 -= tmp2 * 3;
			  /* Put them in the addend.  */
			  rptr->addend += (tmp2 << 8) + (tmp1 << 6);
			}

		      /* What's left is the third part.  It's unpacked
			 just like the second.  */
		      if (tmp == 9)
			rptr->addend += (0xe << 2);
		      else
			{
			  tmp2 = tmp / 3;
			  tmp -= tmp2 * 3;
			  rptr->addend += (tmp2 << 4) + (tmp << 2);
			}
		    }
		  rptr->addend = HPPA_R_ADDEND (rptr->addend, 0);
		}
	      break;
	    /* Handle the linker expression stack.  */
	    case 'O':
	      switch (op)
		{
		case R_COMP1:
		  subop = comp1_opcodes;
		  break;
		case R_COMP2:
		  subop = comp2_opcodes;
		  break;
		case R_COMP3:
		  subop = comp3_opcodes;
		  break;
		default:
		  abort ();
		}
	      while (*subop <= (unsigned char) c)
		++subop;
	      --subop;
	      break;
	    /* The lower 32unwind bits must be persistent.  */
	    case 'U':
	      saved_unwind_bits = var ('U');
	      break;

	    default:
	      break;
	    }
	}

      /* If we used a previous fixup, clean up after it.  */
      if (prev_fixup)
	{
	  fixup = save_fixup + 1;
	  prev_fixup = 0;
	}
      /* Queue it.  */
      else if (fixup > save_fixup + 1)
	som_reloc_queue_insert (save_fixup, fixup - save_fixup, reloc_queue);

      /* We do not pass R_DATA_OVERRIDE or R_NO_RELOCATION
	 fixups to BFD.  */
      if (som_hppa_howto_table[op].type != R_DATA_OVERRIDE
	  && som_hppa_howto_table[op].type != R_NO_RELOCATION)
	{
	  /* Done with a single reloction. Loop back to the top.  */
	  if (! just_count)
	    {
	      if (som_hppa_howto_table[op].type == R_ENTRY)
		rptr->addend = var ('T');
	      else if (som_hppa_howto_table[op].type == R_EXIT)
		rptr->addend = var ('U');
	      else if (som_hppa_howto_table[op].type == R_PCREL_CALL
		       || som_hppa_howto_table[op].type == R_ABS_CALL)
		;
	      else if (som_hppa_howto_table[op].type == R_DATA_ONE_SYMBOL)
		{
		  /* Try what was specified in R_DATA_OVERRIDE first
		     (if anything).  Then the hard way using the
		     section contents.  */
		  rptr->addend = var ('V');

		  if (rptr->addend == 0 && !section->contents)
		    {
		      /* Got to read the damn contents first.  We don't
			 bother saving the contents (yet).  Add it one
			 day if the need arises.  */
		      bfd_byte *contents;
		      if (!bfd_malloc_and_get_section (section->owner, section,
						       &contents))
			{
			  if (contents != NULL)
			    free (contents);
			  return (unsigned) -1;
			}
		      section->contents = contents;
		      deallocate_contents = 1;
		    }
		  else if (rptr->addend == 0)
		    rptr->addend = bfd_get_32 (section->owner,
					       (section->contents
						+ offset - var ('L')));

		}
	      else
		rptr->addend = var ('V');
	      rptr++;
	    }
	  count++;
	  /* Now that we've handled a "full" relocation, reset
	     some state.  */
	  memset (variables, 0, sizeof (variables));
	  memset (stack, 0, sizeof (stack));
	}
    }
  if (deallocate_contents)
    free (section->contents);

  return count;

#undef var
#undef push
#undef pop
#undef emptystack
}

/* Read in the relocs (aka fixups in SOM terms) for a section.

   som_get_reloc_upper_bound calls this routine with JUST_COUNT
   set to TRUE to indicate it only needs a count of the number
   of actual relocations.  */

static bfd_boolean
som_slurp_reloc_table (bfd *abfd,
		       asection *section,
		       asymbol **symbols,
		       bfd_boolean just_count)
{
  unsigned char *external_relocs;
  unsigned int fixup_stream_size;
  arelent *internal_relocs;
  unsigned int num_relocs;
  bfd_size_type amt;

  fixup_stream_size = som_section_data (section)->reloc_size;
  /* If there were no relocations, then there is nothing to do.  */
  if (section->reloc_count == 0)
    return TRUE;

  /* If reloc_count is -1, then the relocation stream has not been
     parsed.  We must do so now to know how many relocations exist.  */
  if (section->reloc_count == (unsigned) -1)
    {
      amt = fixup_stream_size;
      external_relocs = bfd_malloc (amt);
      if (external_relocs == NULL)
	return FALSE;
      /* Read in the external forms.  */
      if (bfd_seek (abfd,
		    obj_som_reloc_filepos (abfd) + section->rel_filepos,
		    SEEK_SET)
	  != 0)
	return FALSE;
      if (bfd_bread (external_relocs, amt, abfd) != amt)
	return FALSE;

      /* Let callers know how many relocations found.
	 also save the relocation stream as we will
	 need it again.  */
      section->reloc_count = som_set_reloc_info (external_relocs,
						 fixup_stream_size,
						 NULL, NULL, NULL, TRUE);

      som_section_data (section)->reloc_stream = external_relocs;
    }

  /* If the caller only wanted a count, then return now.  */
  if (just_count)
    return TRUE;

  num_relocs = section->reloc_count;
  external_relocs = som_section_data (section)->reloc_stream;
  /* Return saved information about the relocations if it is available.  */
  if (section->relocation != NULL)
    return TRUE;

  amt = num_relocs;
  amt *= sizeof (arelent);
  internal_relocs = bfd_zalloc (abfd, (amt));
  if (internal_relocs == NULL)
    return FALSE;

  /* Process and internalize the relocations.  */
  som_set_reloc_info (external_relocs, fixup_stream_size,
		      internal_relocs, section, symbols, FALSE);

  /* We're done with the external relocations.  Free them.  */
  free (external_relocs);
  som_section_data (section)->reloc_stream = NULL;

  /* Save our results and return success.  */
  section->relocation = internal_relocs;
  return TRUE;
}

/* Return the number of bytes required to store the relocation
   information associated with the given section.  */

static long
som_get_reloc_upper_bound (bfd *abfd, sec_ptr asect)
{
  /* If section has relocations, then read in the relocation stream
     and parse it to determine how many relocations exist.  */
  if (asect->flags & SEC_RELOC)
    {
      if (! som_slurp_reloc_table (abfd, asect, NULL, TRUE))
	return -1;
      return (asect->reloc_count + 1) * sizeof (arelent *);
    }

  /* There are no relocations.  Return enough space to hold the
     NULL pointer which will be installed if som_canonicalize_reloc
     is called.  */
  return sizeof (arelent *);
}

/* Convert relocations from SOM (external) form into BFD internal
   form.  Return the number of relocations.  */

static long
som_canonicalize_reloc (bfd *abfd,
			sec_ptr section,
			arelent **relptr,
			asymbol **symbols)
{
  arelent *tblptr;
  int count;

  if (! som_slurp_reloc_table (abfd, section, symbols, FALSE))
    return -1;

  count = section->reloc_count;
  tblptr = section->relocation;

  while (count--)
    *relptr++ = tblptr++;

  *relptr = NULL;
  return section->reloc_count;
}

extern const bfd_target som_vec;

/* A hook to set up object file dependent section information.  */

static bfd_boolean
som_new_section_hook (bfd *abfd, asection *newsect)
{
  if (!newsect->used_by_bfd)
    {
      bfd_size_type amt = sizeof (struct som_section_data_struct);

      newsect->used_by_bfd = bfd_zalloc (abfd, amt);
      if (!newsect->used_by_bfd)
	return FALSE;
    }
  newsect->alignment_power = 3;

  /* We allow more than three sections internally.  */
  return _bfd_generic_new_section_hook (abfd, newsect);
}

/* Copy any private info we understand from the input symbol
   to the output symbol.  */

static bfd_boolean
som_bfd_copy_private_symbol_data (bfd *ibfd,
				  asymbol *isymbol,
				  bfd *obfd,
				  asymbol *osymbol)
{
  struct som_symbol *input_symbol = (struct som_symbol *) isymbol;
  struct som_symbol *output_symbol = (struct som_symbol *) osymbol;

  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_som_flavour
      || obfd->xvec->flavour != bfd_target_som_flavour)
    return FALSE;

  /* The only private information we need to copy is the argument relocation
     bits.  */
  output_symbol->tc_data.ap.hppa_arg_reloc =
    input_symbol->tc_data.ap.hppa_arg_reloc;

  return TRUE;
}

/* Copy any private info we understand from the input section
   to the output section.  */

static bfd_boolean
som_bfd_copy_private_section_data (bfd *ibfd,
				   asection *isection,
				   bfd *obfd,
				   asection *osection)
{
  bfd_size_type amt;

  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_som_flavour
      || obfd->xvec->flavour != bfd_target_som_flavour
      || (!som_is_space (isection) && !som_is_subspace (isection)))
    return TRUE;

  amt = sizeof (struct som_copyable_section_data_struct);
  som_section_data (osection)->copy_data = bfd_zalloc (obfd, amt);
  if (som_section_data (osection)->copy_data == NULL)
    return FALSE;

  memcpy (som_section_data (osection)->copy_data,
	  som_section_data (isection)->copy_data,
	  sizeof (struct som_copyable_section_data_struct));

  /* Reparent if necessary.  */
  if (som_section_data (osection)->copy_data->container)
    som_section_data (osection)->copy_data->container =
      som_section_data (osection)->copy_data->container->output_section;

  return TRUE;
}

/* Copy any private info we understand from the input bfd
   to the output bfd.  */

static bfd_boolean
som_bfd_copy_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  /* One day we may try to grok other private data.  */
  if (ibfd->xvec->flavour != bfd_target_som_flavour
      || obfd->xvec->flavour != bfd_target_som_flavour)
    return TRUE;

  /* Allocate some memory to hold the data we need.  */
  obj_som_exec_data (obfd) = bfd_zalloc (obfd, (bfd_size_type) sizeof (struct som_exec_data));
  if (obj_som_exec_data (obfd) == NULL)
    return FALSE;

  /* Now copy the data.  */
  memcpy (obj_som_exec_data (obfd), obj_som_exec_data (ibfd),
	  sizeof (struct som_exec_data));

  return TRUE;
}

/* Display the SOM header.  */

static bfd_boolean
som_bfd_print_private_bfd_data (bfd *abfd, void *farg)
{
  struct som_exec_auxhdr *exec_header;
  struct som_aux_id* auxhdr;
  FILE *f;

  f = (FILE *) farg;

  exec_header = obj_som_exec_hdr (abfd);
  if (exec_header)
    {
      fprintf (f, _("\nExec Auxiliary Header\n"));
      fprintf (f, "  flags              ");
      auxhdr = &exec_header->som_auxhdr;
      if (auxhdr->mandatory)
	fprintf (f, "mandatory ");
      if (auxhdr->copy)
	fprintf (f, "copy ");
      if (auxhdr->append)
	fprintf (f, "append ");
      if (auxhdr->ignore)
	fprintf (f, "ignore ");
      fprintf (f, "\n");
      fprintf (f, "  type               %#x\n", auxhdr->type);
      fprintf (f, "  length             %#x\n", auxhdr->length);

      /* Note that, depending on the HP-UX version, the following fields can be
         either ints, or longs.  */

      fprintf (f, "  text size          %#lx\n", (long) exec_header->exec_tsize);
      fprintf (f, "  text memory offset %#lx\n", (long) exec_header->exec_tmem);
      fprintf (f, "  text file offset   %#lx\n", (long) exec_header->exec_tfile);
      fprintf (f, "  data size          %#lx\n", (long) exec_header->exec_dsize);
      fprintf (f, "  data memory offset %#lx\n", (long) exec_header->exec_dmem);
      fprintf (f, "  data file offset   %#lx\n", (long) exec_header->exec_dfile);
      fprintf (f, "  bss size           %#lx\n", (long) exec_header->exec_bsize);
      fprintf (f, "  entry point        %#lx\n", (long) exec_header->exec_entry);
      fprintf (f, "  loader flags       %#lx\n", (long) exec_header->exec_flags);
      fprintf (f, "  bss initializer    %#lx\n", (long) exec_header->exec_bfill);
    }

  return TRUE;
}

/* Set backend info for sections which can not be described
   in the BFD data structures.  */

bfd_boolean
bfd_som_set_section_attributes (asection *section,
				int defined,
				int private,
				unsigned int sort_key,
				int spnum)
{
  /* Allocate memory to hold the magic information.  */
  if (som_section_data (section)->copy_data == NULL)
    {
      bfd_size_type amt = sizeof (struct som_copyable_section_data_struct);

      som_section_data (section)->copy_data = bfd_zalloc (section->owner, amt);
      if (som_section_data (section)->copy_data == NULL)
	return FALSE;
    }
  som_section_data (section)->copy_data->sort_key = sort_key;
  som_section_data (section)->copy_data->is_defined = defined;
  som_section_data (section)->copy_data->is_private = private;
  som_section_data (section)->copy_data->container = section;
  som_section_data (section)->copy_data->space_number = spnum;
  return TRUE;
}

/* Set backend info for subsections which can not be described
   in the BFD data structures.  */

bfd_boolean
bfd_som_set_subsection_attributes (asection *section,
				   asection *container,
				   int access_ctr,
				   unsigned int sort_key,
				   int quadrant,
				   int comdat,
				   int common,
				   int dup_common)
{
  /* Allocate memory to hold the magic information.  */
  if (som_section_data (section)->copy_data == NULL)
    {
      bfd_size_type amt = sizeof (struct som_copyable_section_data_struct);

      som_section_data (section)->copy_data = bfd_zalloc (section->owner, amt);
      if (som_section_data (section)->copy_data == NULL)
	return FALSE;
    }
  som_section_data (section)->copy_data->sort_key = sort_key;
  som_section_data (section)->copy_data->access_control_bits = access_ctr;
  som_section_data (section)->copy_data->quadrant = quadrant;
  som_section_data (section)->copy_data->container = container;
  som_section_data (section)->copy_data->is_comdat = comdat;
  som_section_data (section)->copy_data->is_common = common;
  som_section_data (section)->copy_data->dup_common = dup_common;
  return TRUE;
}

/* Set the full SOM symbol type.  SOM needs far more symbol information
   than any other object file format I'm aware of.  It is mandatory
   to be able to know if a symbol is an entry point, millicode, data,
   code, absolute, storage request, or procedure label.  If you get
   the symbol type wrong your program will not link.  */

void
bfd_som_set_symbol_type (asymbol *symbol, unsigned int type)
{
  som_symbol_data (symbol)->som_type = type;
}

/* Attach an auxiliary header to the BFD backend so that it may be
   written into the object file.  */

bfd_boolean
bfd_som_attach_aux_hdr (bfd *abfd, int type, char *string)
{
  bfd_size_type amt;

  if (type == VERSION_AUX_ID)
    {
      size_t len = strlen (string);
      int pad = 0;

      if (len % 4)
	pad = (4 - (len % 4));
      amt = sizeof (struct som_string_auxhdr) + len + pad;
      obj_som_version_hdr (abfd) = bfd_zalloc (abfd, amt);
      if (!obj_som_version_hdr (abfd))
	return FALSE;
      obj_som_version_hdr (abfd)->header_id.type = VERSION_AUX_ID;
      obj_som_version_hdr (abfd)->header_id.length = 4 + len + pad;
      obj_som_version_hdr (abfd)->string_length = len;
      memcpy (obj_som_version_hdr (abfd)->string, string, len);
      memset (obj_som_version_hdr (abfd)->string + len, 0, pad);
    }
  else if (type == COPYRIGHT_AUX_ID)
    {
      int len = strlen (string);
      int pad = 0;

      if (len % 4)
	pad = (4 - (len % 4));
      amt = sizeof (struct som_string_auxhdr) + len + pad;
      obj_som_copyright_hdr (abfd) = bfd_zalloc (abfd, amt);
      if (!obj_som_copyright_hdr (abfd))
	return FALSE;
      obj_som_copyright_hdr (abfd)->header_id.type = COPYRIGHT_AUX_ID;
      obj_som_copyright_hdr (abfd)->header_id.length = len + pad + 4;
      obj_som_copyright_hdr (abfd)->string_length = len;
      memcpy (obj_som_copyright_hdr (abfd)->string, string, len);
      memset (obj_som_copyright_hdr (abfd)->string + len, 0, pad);
    }
  return TRUE;
}

/* Attach a compilation unit header to the BFD backend so that it may be
   written into the object file.  */

bfd_boolean
bfd_som_attach_compilation_unit (bfd *abfd,
				 const char *name,
				 const char *language_name,
				 const char *product_id,
				 const char *version_id)
{
  struct som_compilation_unit *n;

  n = (struct som_compilation_unit *) bfd_zalloc
    (abfd, (bfd_size_type) sizeof (*n));
  if (n == NULL)
    return FALSE;

#define STRDUP(f) \
  if (f != NULL) \
    { \
      n->f.name = bfd_alloc (abfd, (bfd_size_type) strlen (f) + 1); \
      if (n->f.name == NULL) \
	return FALSE; \
      strcpy (n->f.name, f); \
    }

  STRDUP (name);
  STRDUP (language_name);
  STRDUP (product_id);
  STRDUP (version_id);

#undef STRDUP

  obj_som_compilation_unit (abfd) = n;

  return TRUE;
}

static bfd_boolean
som_get_section_contents (bfd *abfd,
			  sec_ptr section,
			  void *location,
			  file_ptr offset,
			  bfd_size_type count)
{
  if (count == 0 || ((section->flags & SEC_HAS_CONTENTS) == 0))
    return TRUE;
  if ((bfd_size_type) (offset+count) > section->size
      || bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) != 0
      || bfd_bread (location, count, abfd) != count)
    return FALSE; /* On error.  */
  return TRUE;
}

static bfd_boolean
som_set_section_contents (bfd *abfd,
			  sec_ptr section,
			  const void *location,
			  file_ptr offset,
			  bfd_size_type count)
{
  if (! abfd->output_has_begun)
    {
      /* Set up fixed parts of the file, space, and subspace headers.
	 Notify the world that output has begun.  */
      som_prep_headers (abfd);
      abfd->output_has_begun = TRUE;
      /* Start writing the object file.  This include all the string
	 tables, fixup streams, and other portions of the object file.  */
      som_begin_writing (abfd);
    }

  /* Only write subspaces which have "real" contents (eg. the contents
     are not generated at run time by the OS).  */
  if (!som_is_subspace (section)
      || ((section->flags & SEC_HAS_CONTENTS) == 0))
    return TRUE;

  /* Seek to the proper offset within the object file and write the
     data.  */
  offset += som_section_data (section)->subspace_dict->file_loc_init_value;
  if (bfd_seek (abfd, offset, SEEK_SET) != 0)
    return FALSE;

  if (bfd_bwrite (location, count, abfd) != count)
    return FALSE;
  return TRUE;
}

static bfd_boolean
som_set_arch_mach (bfd *abfd,
		   enum bfd_architecture arch,
		   unsigned long machine)
{
  /* Allow any architecture to be supported by the SOM backend.  */
  return bfd_default_set_arch_mach (abfd, arch, machine);
}

static bfd_boolean
som_find_nearest_line (bfd *abfd,
		       asection *section,
		       asymbol **symbols,
		       bfd_vma offset,
		       const char **filename_ptr,
		       const char **functionname_ptr,
		       unsigned int *line_ptr)
{
  bfd_boolean found;
  asymbol *func;
  bfd_vma low_func;
  asymbol **p;

  if (! _bfd_stab_section_find_nearest_line (abfd, symbols, section, offset,
                                             & found, filename_ptr,
                                             functionname_ptr, line_ptr,
                                             & somdata (abfd).line_info))
    return FALSE;

  if (found)
    return TRUE;

  if (symbols == NULL)
    return FALSE;

  /* Fallback: find function name from symbols table.  */
  func = NULL;
  low_func = 0;

  for (p = symbols; *p != NULL; p++)
    {
      som_symbol_type *q = (som_symbol_type *) *p;

      if (q->som_type == SYMBOL_TYPE_ENTRY
	  && q->symbol.section == section
	  && q->symbol.value >= low_func
	  && q->symbol.value <= offset)
	{
	  func = (asymbol *) q;
	  low_func = q->symbol.value;
	}
    }

  if (func == NULL)
    return FALSE;

  *filename_ptr = NULL;
  *functionname_ptr = bfd_asymbol_name (func);
  *line_ptr = 0;

  return TRUE;
}

static int
som_sizeof_headers (bfd *abfd ATTRIBUTE_UNUSED,
		    struct bfd_link_info *info ATTRIBUTE_UNUSED)
{
  (*_bfd_error_handler) (_("som_sizeof_headers unimplemented"));
  abort ();
  return 0;
}

/* Return the single-character symbol type corresponding to
   SOM section S, or '?' for an unknown SOM section.  */

static char
som_section_type (const char *s)
{
  const struct section_to_type *t;

  for (t = &stt[0]; t->section; t++)
    if (!strcmp (s, t->section))
      return t->type;
  return '?';
}

static int
som_decode_symclass (asymbol *symbol)
{
  char c;

  if (bfd_is_com_section (symbol->section))
    return 'C';
  if (bfd_is_und_section (symbol->section))
    {
      if (symbol->flags & BSF_WEAK)
	{
	  /* If weak, determine if it's specifically an object
	     or non-object weak.  */
	  if (symbol->flags & BSF_OBJECT)
	    return 'v';
	  else
	    return 'w';
	}
      else
	 return 'U';
    }
  if (bfd_is_ind_section (symbol->section))
    return 'I';
  if (symbol->flags & BSF_WEAK)
    {
      /* If weak, determine if it's specifically an object
	 or non-object weak.  */
      if (symbol->flags & BSF_OBJECT)
	return 'V';
      else
	return 'W';
    }
  if (!(symbol->flags & (BSF_GLOBAL | BSF_LOCAL)))
    return '?';

  if (bfd_is_abs_section (symbol->section)
      || (som_symbol_data (symbol) != NULL
	  && som_symbol_data (symbol)->som_type == SYMBOL_TYPE_ABSOLUTE))
    c = 'a';
  else if (symbol->section)
    c = som_section_type (symbol->section->name);
  else
    return '?';
  if (symbol->flags & BSF_GLOBAL)
    c = TOUPPER (c);
  return c;
}

/* Return information about SOM symbol SYMBOL in RET.  */

static void
som_get_symbol_info (bfd *ignore_abfd ATTRIBUTE_UNUSED,
		     asymbol *symbol,
		     symbol_info *ret)
{
  ret->type = som_decode_symclass (symbol);
  if (ret->type != 'U')
    ret->value = symbol->value + symbol->section->vma;
  else
    ret->value = 0;
  ret->name = symbol->name;
}

/* Count the number of symbols in the archive symbol table.  Necessary
   so that we can allocate space for all the carsyms at once.  */

static bfd_boolean
som_bfd_count_ar_symbols (bfd *abfd,
			  struct som_lst_header *lst_header,
			  symindex *count)
{
  unsigned int i;
  unsigned char *hash_table;
  bfd_size_type amt;
  file_ptr lst_filepos;

  lst_filepos = bfd_tell (abfd) - sizeof (struct som_external_lst_header);

  amt = lst_header->hash_size * 4;
  hash_table = bfd_malloc (amt);
  if (hash_table == NULL && amt != 0)
    goto error_return;

  /* Don't forget to initialize the counter!  */
  *count = 0;

  /* Read in the hash table.  The has table is an array of 32bit file offsets
     which point to the hash chains.  */
  if (bfd_bread ((void *) hash_table, amt, abfd) != amt)
    goto error_return;

  /* Walk each chain counting the number of symbols found on that particular
     chain.  */
  for (i = 0; i < lst_header->hash_size; i++)
    {
      struct som_external_lst_symbol_record ext_lst_symbol;
      unsigned int hash_val = bfd_getb32 (hash_table + 4 * i);

      /* An empty chain has zero as it's file offset.  */
      if (hash_val == 0)
	continue;

      /* Seek to the first symbol in this hash chain.  */
      if (bfd_seek (abfd, lst_filepos + hash_val, SEEK_SET) != 0)
	goto error_return;

      /* Read in this symbol and update the counter.  */
      amt = sizeof (ext_lst_symbol);
      if (bfd_bread ((void *) &ext_lst_symbol, amt, abfd) != amt)
	goto error_return;

      (*count)++;

      /* Now iterate through the rest of the symbols on this chain.  */
      while (1)
	{
          unsigned int next_entry = bfd_getb32 (ext_lst_symbol.next_entry);

          if (next_entry == 0)
            break;

	  /* Seek to the next symbol.  */
	  if (bfd_seek (abfd, lst_filepos + next_entry, SEEK_SET) != 0)
	    goto error_return;

	  /* Read the symbol in and update the counter.  */
	  amt = sizeof (ext_lst_symbol);
	  if (bfd_bread ((void *) &ext_lst_symbol, amt, abfd) != amt)
	    goto error_return;

	  (*count)++;
	}
    }
  if (hash_table != NULL)
    free (hash_table);
  return TRUE;

 error_return:
  if (hash_table != NULL)
    free (hash_table);
  return FALSE;
}

/* Fill in the canonical archive symbols (SYMS) from the archive described
   by ABFD and LST_HEADER.  */

static bfd_boolean
som_bfd_fill_in_ar_symbols (bfd *abfd,
			    struct som_lst_header *lst_header,
			    carsym **syms)
{
  unsigned int i;
  carsym *set = syms[0];
  unsigned char *hash_table;
  struct som_external_som_entry *som_dict = NULL;
  bfd_size_type amt;
  file_ptr lst_filepos;
  unsigned int string_loc;

  lst_filepos = bfd_tell (abfd) - sizeof (struct som_external_lst_header);
  amt = lst_header->hash_size * 4;
  hash_table = bfd_malloc (amt);
  if (hash_table == NULL && amt != 0)
    goto error_return;

  /* Read in the hash table.  The has table is an array of 32bit file offsets
     which point to the hash chains.  */
  if (bfd_bread ((void *) hash_table, amt, abfd) != amt)
    goto error_return;

  /* Seek to and read in the SOM dictionary.  We will need this to fill
     in the carsym's filepos field.  */
  if (bfd_seek (abfd, lst_filepos + lst_header->dir_loc, SEEK_SET) != 0)
    goto error_return;

  amt = lst_header->module_count * sizeof (struct som_external_som_entry);
  som_dict = bfd_malloc (amt);
  if (som_dict == NULL && amt != 0)
    goto error_return;

  if (bfd_bread ((void *) som_dict, amt, abfd) != amt)
    goto error_return;

  string_loc = lst_header->string_loc;

  /* Walk each chain filling in the carsyms as we go along.  */
  for (i = 0; i < lst_header->hash_size; i++)
    {
      struct som_external_lst_symbol_record lst_symbol;
      unsigned int hash_val;
      unsigned int len;
      unsigned char ext_len[4];

      /* An empty chain has zero as it's file offset.  */
      hash_val = bfd_getb32 (hash_table + 4 * i);
      if (hash_val == 0)
	continue;

      /* Seek to and read the first symbol on the chain.  */
      if (bfd_seek (abfd, lst_filepos + hash_val, SEEK_SET) != 0)
	goto error_return;

      amt = sizeof (lst_symbol);
      if (bfd_bread ((void *) &lst_symbol, amt, abfd) != amt)
	goto error_return;

      /* Get the name of the symbol, first get the length which is stored
	 as a 32bit integer just before the symbol.

	 One might ask why we don't just read in the entire string table
	 and index into it.  Well, according to the SOM ABI the string
	 index can point *anywhere* in the archive to save space, so just
	 using the string table would not be safe.  */
      if (bfd_seek (abfd, (lst_filepos + string_loc
                           + bfd_getb32 (lst_symbol.name) - 4), SEEK_SET) != 0)
	goto error_return;

      if (bfd_bread (&ext_len, (bfd_size_type) 4, abfd) != 4)
	goto error_return;
      len = bfd_getb32 (ext_len);

      /* Allocate space for the name and null terminate it too.  */
      set->name = bfd_zalloc (abfd, (bfd_size_type) len + 1);
      if (!set->name)
	goto error_return;
      if (bfd_bread (set->name, (bfd_size_type) len, abfd) != len)
	goto error_return;

      set->name[len] = 0;

      /* Fill in the file offset.  Note that the "location" field points
	 to the SOM itself, not the ar_hdr in front of it.  */
      set->file_offset =
        bfd_getb32 (som_dict[bfd_getb32 (lst_symbol.som_index)].location)
        - sizeof (struct ar_hdr);

      /* Go to the next symbol.  */
      set++;

      /* Iterate through the rest of the chain.  */
      while (1)
	{
          unsigned int next_entry = bfd_getb32 (lst_symbol.next_entry);

          if (next_entry == 0)
            break;

	  /* Seek to the next symbol and read it in.  */
	  if (bfd_seek (abfd, lst_filepos + next_entry, SEEK_SET) != 0)
	    goto error_return;

	  amt = sizeof (lst_symbol);
	  if (bfd_bread ((void *) &lst_symbol, amt, abfd) != amt)
	    goto error_return;

	  /* Seek to the name length & string and read them in.  */
	  if (bfd_seek (abfd, lst_filepos + string_loc
                        + bfd_getb32 (lst_symbol.name) - 4, SEEK_SET) != 0)
	    goto error_return;

	  if (bfd_bread (&ext_len, (bfd_size_type) 4, abfd) != 4)
	    goto error_return;
          len = bfd_getb32 (ext_len);

	  /* Allocate space for the name and null terminate it too.  */
	  set->name = bfd_zalloc (abfd, (bfd_size_type) len + 1);
	  if (!set->name)
	    goto error_return;

	  if (bfd_bread (set->name, (bfd_size_type) len, abfd) != len)
	    goto error_return;
	  set->name[len] = 0;

	  /* Fill in the file offset.  Note that the "location" field points
	     to the SOM itself, not the ar_hdr in front of it.  */
	  set->file_offset =
            bfd_getb32 (som_dict[bfd_getb32 (lst_symbol.som_index)].location)
            - sizeof (struct ar_hdr);

	  /* Go on to the next symbol.  */
	  set++;
	}
    }
  /* If we haven't died by now, then we successfully read the entire
     archive symbol table.  */
  if (hash_table != NULL)
    free (hash_table);
  if (som_dict != NULL)
    free (som_dict);
  return TRUE;

 error_return:
  if (hash_table != NULL)
    free (hash_table);
  if (som_dict != NULL)
    free (som_dict);
  return FALSE;
}

/* Read in the LST from the archive.  */

static bfd_boolean
som_slurp_armap (bfd *abfd)
{
  struct som_external_lst_header ext_lst_header;
  struct som_lst_header lst_header;
  struct ar_hdr ar_header;
  unsigned int parsed_size;
  struct artdata *ardata = bfd_ardata (abfd);
  char nextname[17];
  bfd_size_type amt = 16;
  int i = bfd_bread ((void *) nextname, amt, abfd);

  /* Special cases.  */
  if (i == 0)
    return TRUE;
  if (i != 16)
    return FALSE;

  if (bfd_seek (abfd, (file_ptr) -16, SEEK_CUR) != 0)
    return FALSE;

  /* For archives without .o files there is no symbol table.  */
  if (! CONST_STRNEQ (nextname, "/               "))
    {
      bfd_has_map (abfd) = FALSE;
      return TRUE;
    }

  /* Read in and sanity check the archive header.  */
  amt = sizeof (struct ar_hdr);
  if (bfd_bread ((void *) &ar_header, amt, abfd) != amt)
    return FALSE;

  if (strncmp (ar_header.ar_fmag, ARFMAG, 2))
    {
      bfd_set_error (bfd_error_malformed_archive);
      return FALSE;
    }

  /* How big is the archive symbol table entry?  */
  errno = 0;
  parsed_size = strtol (ar_header.ar_size, NULL, 10);
  if (errno != 0)
    {
      bfd_set_error (bfd_error_malformed_archive);
      return FALSE;
    }

  /* Save off the file offset of the first real user data.  */
  ardata->first_file_filepos = bfd_tell (abfd) + parsed_size;

  /* Read in the library symbol table.  We'll make heavy use of this
     in just a minute.  */
  amt = sizeof (struct som_external_lst_header);
  if (bfd_bread ((void *) &ext_lst_header, amt, abfd) != amt)
    return FALSE;

  som_swap_lst_header_in (&ext_lst_header, &lst_header);

  /* Sanity check.  */
  if (lst_header.a_magic != LIBMAGIC)
    {
      bfd_set_error (bfd_error_malformed_archive);
      return FALSE;
    }

  /* Count the number of symbols in the library symbol table.  */
  if (! som_bfd_count_ar_symbols (abfd, &lst_header, &ardata->symdef_count))
    return FALSE;

  /* Get back to the start of the library symbol table.  */
  if (bfd_seek (abfd, (ardata->first_file_filepos - parsed_size
		       + sizeof (struct som_external_lst_header)),
                SEEK_SET) != 0)
    return FALSE;

  /* Initialize the cache and allocate space for the library symbols.  */
  ardata->cache = 0;
  amt = ardata->symdef_count;
  amt *= sizeof (carsym);
  ardata->symdefs = bfd_alloc (abfd, amt);
  if (!ardata->symdefs)
    return FALSE;

  /* Now fill in the canonical archive symbols.  */
  if (! som_bfd_fill_in_ar_symbols (abfd, &lst_header, &ardata->symdefs))
    return FALSE;

  /* Seek back to the "first" file in the archive.  Note the "first"
     file may be the extended name table.  */
  if (bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET) != 0)
    return FALSE;

  /* Notify the generic archive code that we have a symbol map.  */
  bfd_has_map (abfd) = TRUE;
  return TRUE;
}

/* Begin preparing to write a SOM library symbol table.

   As part of the prep work we need to determine the number of symbols
   and the size of the associated string section.  */

static bfd_boolean
som_bfd_prep_for_ar_write (bfd *abfd,
			   unsigned int *num_syms,
			   unsigned int *stringsize)
{
  bfd *curr_bfd = abfd->archive_head;

  /* Some initialization.  */
  *num_syms = 0;
  *stringsize = 0;

  /* Iterate over each BFD within this archive.  */
  while (curr_bfd != NULL)
    {
      unsigned int curr_count, i;
      som_symbol_type *sym;

      /* Don't bother for non-SOM objects.  */
      if (curr_bfd->format != bfd_object
	  || curr_bfd->xvec->flavour != bfd_target_som_flavour)
	{
	  curr_bfd = curr_bfd->archive_next;
	  continue;
	}

      /* Make sure the symbol table has been read, then snag a pointer
	 to it.  It's a little slimey to grab the symbols via obj_som_symtab,
	 but doing so avoids allocating lots of extra memory.  */
      if (! som_slurp_symbol_table (curr_bfd))
	return FALSE;

      sym = obj_som_symtab (curr_bfd);
      curr_count = bfd_get_symcount (curr_bfd);

      /* Examine each symbol to determine if it belongs in the
	 library symbol table.  */
      for (i = 0; i < curr_count; i++, sym++)
	{
	  struct som_misc_symbol_info info;

	  /* Derive SOM information from the BFD symbol.  */
	  som_bfd_derive_misc_symbol_info (curr_bfd, &sym->symbol, &info);

	  /* Should we include this symbol?  */
	  if (info.symbol_type == ST_NULL
	      || info.symbol_type == ST_SYM_EXT
	      || info.symbol_type == ST_ARG_EXT)
	    continue;

	  /* Only global symbols and unsatisfied commons.  */
	  if (info.symbol_scope != SS_UNIVERSAL
	      && info.symbol_type != ST_STORAGE)
	    continue;

	  /* Do no include undefined symbols.  */
	  if (bfd_is_und_section (sym->symbol.section))
	    continue;

	  /* Bump the various counters, being careful to honor
	     alignment considerations in the string table.  */
	  (*num_syms)++;
	  *stringsize += strlen (sym->symbol.name) + 5;
	  while (*stringsize % 4)
	    (*stringsize)++;
	}

      curr_bfd = curr_bfd->archive_next;
    }
  return TRUE;
}

/* Hash a symbol name based on the hashing algorithm presented in the
   SOM ABI.  */

static unsigned int
som_bfd_ar_symbol_hash (asymbol *symbol)
{
  unsigned int len = strlen (symbol->name);

  /* Names with length 1 are special.  */
  if (len == 1)
    return 0x1000100 | (symbol->name[0] << 16) | symbol->name[0];

  return ((len & 0x7f) << 24) | (symbol->name[1] << 16)
	  | (symbol->name[len - 2] << 8) | symbol->name[len - 1];
}

/* Do the bulk of the work required to write the SOM library
   symbol table.  */

static bfd_boolean
som_bfd_ar_write_symbol_stuff (bfd *abfd,
			       unsigned int nsyms,
			       unsigned int string_size,
			       struct som_external_lst_header lst,
			       unsigned elength)
{
  char *strings = NULL, *p;
  struct som_external_lst_symbol_record *lst_syms = NULL, *curr_lst_sym;
  bfd *curr_bfd;
  unsigned char *hash_table = NULL;
  struct som_external_som_entry *som_dict = NULL;
  struct som_external_lst_symbol_record **last_hash_entry = NULL;
  unsigned int curr_som_offset, som_index = 0;
  bfd_size_type amt;
  unsigned int module_count;
  unsigned int hash_size;

  hash_size = bfd_getb32 (lst.hash_size);
  amt = hash_size * 4;
  hash_table = bfd_zmalloc (amt);
  if (hash_table == NULL && hash_size != 0)
    goto error_return;

  module_count = bfd_getb32 (lst.module_count);
  amt = module_count * sizeof (struct som_external_som_entry);
  som_dict = bfd_zmalloc (amt);
  if (som_dict == NULL && module_count != 0)
    goto error_return;

  amt = hash_size * sizeof (struct som_external_lst_symbol_record *);
  last_hash_entry = bfd_zmalloc (amt);
  if (last_hash_entry == NULL && hash_size != 0)
    goto error_return;

  /* Symbols have som_index fields, so we have to keep track of the
     index of each SOM in the archive.

     The SOM dictionary has (among other things) the absolute file
     position for the SOM which a particular dictionary entry
     describes.  We have to compute that information as we iterate
     through the SOMs/symbols.  */
  som_index = 0;

  /* We add in the size of the archive header twice as the location
     in the SOM dictionary is the actual offset of the SOM, not the
     archive header before the SOM.  */
  curr_som_offset = 8 + 2 * sizeof (struct ar_hdr) + bfd_getb32 (lst.file_end);

  /* Make room for the archive header and the contents of the
     extended string table.  Note that elength includes the size
     of the archive header for the extended name table!  */
  if (elength)
    curr_som_offset += elength;

  /* Make sure we're properly aligned.  */
  curr_som_offset = (curr_som_offset + 0x1) & ~0x1;

  /* FIXME should be done with buffers just like everything else...  */
  amt = nsyms;
  amt *= sizeof (struct som_external_lst_symbol_record);
  lst_syms = bfd_malloc (amt);
  if (lst_syms == NULL && nsyms != 0)
    goto error_return;
  strings = bfd_malloc ((bfd_size_type) string_size);
  if (strings == NULL && string_size != 0)
    goto error_return;

  p = strings;
  curr_lst_sym = lst_syms;

  curr_bfd = abfd->archive_head;
  while (curr_bfd != NULL)
    {
      unsigned int curr_count, i;
      som_symbol_type *sym;

      /* Don't bother for non-SOM objects.  */
      if (curr_bfd->format != bfd_object
	  || curr_bfd->xvec->flavour != bfd_target_som_flavour)
	{
	  curr_bfd = curr_bfd->archive_next;
	  continue;
	}

      /* Make sure the symbol table has been read, then snag a pointer
	 to it.  It's a little slimey to grab the symbols via obj_som_symtab,
	 but doing so avoids allocating lots of extra memory.  */
      if (! som_slurp_symbol_table (curr_bfd))
	goto error_return;

      sym = obj_som_symtab (curr_bfd);
      curr_count = bfd_get_symcount (curr_bfd);

      for (i = 0; i < curr_count; i++, sym++)
	{
	  struct som_misc_symbol_info info;
          struct som_external_lst_symbol_record *last;
          unsigned int symbol_pos;
          unsigned int slen;
          unsigned int symbol_key;
          unsigned int flags;

	  /* Derive SOM information from the BFD symbol.  */
	  som_bfd_derive_misc_symbol_info (curr_bfd, &sym->symbol, &info);

	  /* Should we include this symbol?  */
	  if (info.symbol_type == ST_NULL
	      || info.symbol_type == ST_SYM_EXT
	      || info.symbol_type == ST_ARG_EXT)
	    continue;

	  /* Only global symbols and unsatisfied commons.  */
	  if (info.symbol_scope != SS_UNIVERSAL
	      && info.symbol_type != ST_STORAGE)
	    continue;

	  /* Do no include undefined symbols.  */
	  if (bfd_is_und_section (sym->symbol.section))
	    continue;

	  /* If this is the first symbol from this SOM, then update
	     the SOM dictionary too.  */
	  if (bfd_getb32 (som_dict[som_index].location) == 0)
	    {
	      bfd_putb32 (curr_som_offset, som_dict[som_index].location);
	      bfd_putb32 (arelt_size (curr_bfd), som_dict[som_index].length);
	    }

          symbol_key = som_bfd_ar_symbol_hash (&sym->symbol);

	  /* Fill in the lst symbol record.  */
          flags = 0;
          if (info.secondary_def)
            flags |= LST_SYMBOL_SECONDARY_DEF;
          flags |= info.symbol_type << LST_SYMBOL_SYMBOL_TYPE_SH;
          flags |= info.symbol_scope << LST_SYMBOL_SYMBOL_SCOPE_SH;
          if (bfd_is_com_section (sym->symbol.section))
            flags |= LST_SYMBOL_IS_COMMON;
          if (info.dup_common)
            flags |= LST_SYMBOL_DUP_COMMON;
          flags |= 3 << LST_SYMBOL_XLEAST_SH;
          flags |= info.arg_reloc << LST_SYMBOL_ARG_RELOC_SH;
          bfd_putb32 (flags, curr_lst_sym->flags);
          bfd_putb32 (p - strings + 4, curr_lst_sym->name);
          bfd_putb32 (0, curr_lst_sym->qualifier_name);
          bfd_putb32 (info.symbol_info, curr_lst_sym->symbol_info);
          bfd_putb32 (info.symbol_value | info.priv_level,
                      curr_lst_sym->symbol_value);
          bfd_putb32 (0, curr_lst_sym->symbol_descriptor);
          curr_lst_sym->reserved = 0;
          bfd_putb32 (som_index, curr_lst_sym->som_index);
          bfd_putb32 (symbol_key, curr_lst_sym->symbol_key);
          bfd_putb32 (0, curr_lst_sym->next_entry);

	  /* Insert into the hash table.  */
          symbol_pos =
            (curr_lst_sym - lst_syms)
            * sizeof (struct som_external_lst_symbol_record)
            + hash_size * 4
            + module_count * sizeof (struct som_external_som_entry)
            + sizeof (struct som_external_lst_header);
          last = last_hash_entry[symbol_key % hash_size];
	  if (last != NULL)
	    {
	      /* There is already something at the head of this hash chain,
		 so tack this symbol onto the end of the chain.  */
	      bfd_putb32 (symbol_pos, last->next_entry);
	    }
	  else
	    /* First entry in this hash chain.  */
            bfd_putb32 (symbol_pos, hash_table + 4 * (symbol_key % hash_size));

	  /* Keep track of the last symbol we added to this chain so we can
	     easily update its next_entry pointer.  */
          last_hash_entry[symbol_key % hash_size] = curr_lst_sym;

	  /* Update the string table.  */
          slen = strlen (sym->symbol.name);
	  bfd_put_32 (abfd, slen, p);
	  p += 4;
          slen++; /* Nul terminator.  */
	  memcpy (p, sym->symbol.name, slen);
	  p += slen;
	  while (slen % 4)
	    {
	      bfd_put_8 (abfd, 0, p);
	      p++;
              slen++;
	    }
          BFD_ASSERT (p <= strings + string_size);

	  /* Head to the next symbol.  */
	  curr_lst_sym++;
	}

      /* Keep track of where each SOM will finally reside; then look
	 at the next BFD.  */
      curr_som_offset += arelt_size (curr_bfd) + sizeof (struct ar_hdr);

      /* A particular object in the archive may have an odd length; the
	 linker requires objects begin on an even boundary.  So round
	 up the current offset as necessary.  */
      curr_som_offset = (curr_som_offset + 0x1) &~ (unsigned) 1;
      curr_bfd = curr_bfd->archive_next;
      som_index++;
    }

  /* Now scribble out the hash table.  */
  amt = hash_size * 4;
  if (bfd_bwrite ((void *) hash_table, amt, abfd) != amt)
    goto error_return;

  /* Then the SOM dictionary.  */
  amt = module_count * sizeof (struct som_external_som_entry);
  if (bfd_bwrite ((void *) som_dict, amt, abfd) != amt)
    goto error_return;

  /* The library symbols.  */
  amt = nsyms * sizeof (struct som_external_lst_symbol_record);
  if (bfd_bwrite ((void *) lst_syms, amt, abfd) != amt)
    goto error_return;

  /* And finally the strings.  */
  amt = string_size;
  if (bfd_bwrite ((void *) strings, amt, abfd) != amt)
    goto error_return;

  if (hash_table != NULL)
    free (hash_table);
  if (som_dict != NULL)
    free (som_dict);
  if (last_hash_entry != NULL)
    free (last_hash_entry);
  if (lst_syms != NULL)
    free (lst_syms);
  if (strings != NULL)
    free (strings);
  return TRUE;

 error_return:
  if (hash_table != NULL)
    free (hash_table);
  if (som_dict != NULL)
    free (som_dict);
  if (last_hash_entry != NULL)
    free (last_hash_entry);
  if (lst_syms != NULL)
    free (lst_syms);
  if (strings != NULL)
    free (strings);

  return FALSE;
}

/* Write out the LST for the archive.

   You'll never believe this is really how armaps are handled in SOM...  */

static bfd_boolean
som_write_armap (bfd *abfd,
		 unsigned int elength,
		 struct orl *map ATTRIBUTE_UNUSED,
		 unsigned int orl_count ATTRIBUTE_UNUSED,
		 int stridx ATTRIBUTE_UNUSED)
{
  bfd *curr_bfd;
  struct stat statbuf;
  unsigned int i, lst_size, nsyms, stringsize;
  struct ar_hdr hdr;
  struct som_external_lst_header lst;
  unsigned char *p;
  bfd_size_type amt;
  unsigned int csum;
  unsigned int module_count;

  /* We'll use this for the archive's date and mode later.  */
  if (stat (abfd->filename, &statbuf) != 0)
    {
      bfd_set_error (bfd_error_system_call);
      return FALSE;
    }
  /* Fudge factor.  */
  bfd_ardata (abfd)->armap_timestamp = statbuf.st_mtime + 60;

  /* Account for the lst header first.  */
  lst_size = sizeof (struct som_external_lst_header);

  /* Start building the LST header.  */
  /* FIXME:  Do we need to examine each element to determine the
     largest id number?  */
  bfd_putb16 (CPU_PA_RISC1_0, &lst.system_id);
  bfd_putb16 (LIBMAGIC, &lst.a_magic);
  bfd_putb32 (VERSION_ID, &lst.version_id);
  bfd_putb32 (0, &lst.file_time.secs);
  bfd_putb32 (0, &lst.file_time.nanosecs);

  bfd_putb32 (lst_size, &lst.hash_loc);
  bfd_putb32 (SOM_LST_HASH_SIZE, &lst.hash_size);

  /* Hash table is a SOM_LST_HASH_SIZE 32bit offsets.  */
  lst_size += 4 * SOM_LST_HASH_SIZE;

  /* We need to count the number of SOMs in this archive.  */
  curr_bfd = abfd->archive_head;
  module_count = 0;
  while (curr_bfd != NULL)
    {
      /* Only true SOM objects count.  */
      if (curr_bfd->format == bfd_object
	  && curr_bfd->xvec->flavour == bfd_target_som_flavour)
	module_count++;
      curr_bfd = curr_bfd->archive_next;
    }
  bfd_putb32 (module_count, &lst.module_count);
  bfd_putb32 (module_count, &lst.module_limit);
  bfd_putb32 (lst_size, &lst.dir_loc);
  lst_size += sizeof (struct som_external_som_entry) * module_count;

  /* We don't support import/export tables, auxiliary headers,
     or free lists yet.  Make the linker work a little harder
     to make our life easier.  */

  bfd_putb32 (0, &lst.export_loc);
  bfd_putb32 (0, &lst.export_count);
  bfd_putb32 (0, &lst.import_loc);
  bfd_putb32 (0, &lst.aux_loc);
  bfd_putb32 (0, &lst.aux_size);

  /* Count how many symbols we will have on the hash chains and the
     size of the associated string table.  */
  if (! som_bfd_prep_for_ar_write (abfd, &nsyms, &stringsize))
    return FALSE;

  lst_size += sizeof (struct som_external_lst_symbol_record) * nsyms;

  /* For the string table.  One day we might actually use this info
     to avoid small seeks/reads when reading archives.  */
  bfd_putb32 (lst_size, &lst.string_loc);
  bfd_putb32 (stringsize, &lst.string_size);
  lst_size += stringsize;

  /* SOM ABI says this must be zero.  */
  bfd_putb32 (0, &lst.free_list);
  bfd_putb32 (lst_size, &lst.file_end);

  /* Compute the checksum.  Must happen after the entire lst header
     has filled in.  */
  p = (unsigned char *) &lst;
  csum = 0;
  for (i = 0; i < sizeof (struct som_external_lst_header) - sizeof (int);
       i += 4)
    csum ^= bfd_getb32 (&p[i]);
  bfd_putb32 (csum, &lst.checksum);

  sprintf (hdr.ar_name, "/              ");
  _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%-12ld",
                    bfd_ardata (abfd)->armap_timestamp);
  _bfd_ar_spacepad (hdr.ar_uid, sizeof (hdr.ar_uid), "%ld",
                    statbuf.st_uid);
  _bfd_ar_spacepad (hdr.ar_gid, sizeof (hdr.ar_gid), "%ld",
                    statbuf.st_gid);
  _bfd_ar_spacepad (hdr.ar_mode, sizeof (hdr.ar_mode), "%-8o",
                    (unsigned int)statbuf.st_mode);
  _bfd_ar_spacepad (hdr.ar_size, sizeof (hdr.ar_size), "%-10d",
                    (int) lst_size);
  hdr.ar_fmag[0] = '`';
  hdr.ar_fmag[1] = '\012';

  /* Turn any nulls into spaces.  */
  for (i = 0; i < sizeof (struct ar_hdr); i++)
    if (((char *) (&hdr))[i] == '\0')
      (((char *) (&hdr))[i]) = ' ';

  /* Scribble out the ar header.  */
  amt = sizeof (struct ar_hdr);
  if (bfd_bwrite ((void *) &hdr, amt, abfd) != amt)
    return FALSE;

  /* Now scribble out the lst header.  */
  amt = sizeof (struct som_external_lst_header);
  if (bfd_bwrite ((void *) &lst, amt, abfd) != amt)
    return FALSE;

  /* Build and write the armap.  */
  if (!som_bfd_ar_write_symbol_stuff (abfd, nsyms, stringsize, lst, elength))
    return FALSE;

  /* Done.  */
  return TRUE;
}

/* Free all information we have cached for this BFD.  We can always
   read it again later if we need it.  */

static bfd_boolean
som_bfd_free_cached_info (bfd *abfd)
{
  asection *o;

  if (bfd_get_format (abfd) != bfd_object)
    return TRUE;

#define FREE(x) if (x != NULL) { free (x); x = NULL; }
  /* Free the native string and symbol tables.  */
  FREE (obj_som_symtab (abfd));
  FREE (obj_som_stringtab (abfd));
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      /* Free the native relocations.  */
      o->reloc_count = (unsigned) -1;
      FREE (som_section_data (o)->reloc_stream);
      /* Do not free the generic relocations as they are objalloc'ed.  */
    }
#undef FREE

  return TRUE;
}

/* End of miscellaneous support functions.  */

/* Linker support functions.  */

static bfd_boolean
som_bfd_link_split_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  return som_is_subspace (sec) && sec->size > 240000;
}

#define	som_close_and_cleanup		        som_bfd_free_cached_info
#define som_read_ar_hdr			        _bfd_generic_read_ar_hdr
#define som_write_ar_hdr		        _bfd_generic_write_ar_hdr
#define som_openr_next_archived_file	        bfd_generic_openr_next_archived_file
#define som_get_elt_at_index		        _bfd_generic_get_elt_at_index
#define som_generic_stat_arch_elt	        bfd_generic_stat_arch_elt
#define som_truncate_arname		        bfd_bsd_truncate_arname
#define som_slurp_extended_name_table	        _bfd_slurp_extended_name_table
#define som_construct_extended_name_table       _bfd_archive_coff_construct_extended_name_table
#define som_update_armap_timestamp	        bfd_true
#define som_bfd_is_target_special_symbol   ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
#define som_get_lineno			        _bfd_nosymbols_get_lineno
#define som_bfd_make_debug_symbol	        _bfd_nosymbols_bfd_make_debug_symbol
#define som_read_minisymbols		        _bfd_generic_read_minisymbols
#define som_minisymbol_to_symbol	        _bfd_generic_minisymbol_to_symbol
#define som_get_section_contents_in_window      _bfd_generic_get_section_contents_in_window
#define som_bfd_get_relocated_section_contents  bfd_generic_get_relocated_section_contents
#define som_bfd_relax_section                   bfd_generic_relax_section
#define som_bfd_link_hash_table_create          _bfd_generic_link_hash_table_create
#define som_bfd_link_hash_table_free            _bfd_generic_link_hash_table_free
#define som_bfd_link_add_symbols                _bfd_generic_link_add_symbols
#define som_bfd_link_just_syms                  _bfd_generic_link_just_syms
#define som_bfd_copy_link_hash_symbol_type \
  _bfd_generic_copy_link_hash_symbol_type
#define som_bfd_final_link                      _bfd_generic_final_link
#define som_bfd_gc_sections		        bfd_generic_gc_sections
#define som_bfd_lookup_section_flags            bfd_generic_lookup_section_flags
#define som_bfd_merge_sections		        bfd_generic_merge_sections
#define som_bfd_is_group_section	        bfd_generic_is_group_section
#define som_bfd_discard_group		        bfd_generic_discard_group
#define som_section_already_linked              _bfd_generic_section_already_linked
#define som_bfd_define_common_symbol            bfd_generic_define_common_symbol
#define som_bfd_merge_private_bfd_data		_bfd_generic_bfd_merge_private_bfd_data
#define som_bfd_copy_private_header_data	_bfd_generic_bfd_copy_private_header_data
#define som_bfd_set_private_flags		_bfd_generic_bfd_set_private_flags
#define som_find_inliner_info			_bfd_nosymbols_find_inliner_info

const bfd_target som_vec =
{
  "som",			/* Name.  */
  bfd_target_som_flavour,
  BFD_ENDIAN_BIG,		/* Target byte order.  */
  BFD_ENDIAN_BIG,		/* Target headers byte order.  */
  (HAS_RELOC | EXEC_P |		/* Object flags.  */
   HAS_LINENO | HAS_DEBUG |
   HAS_SYMS | HAS_LOCALS | WP_TEXT | D_PAGED | DYNAMIC),
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS | SEC_LINK_ONCE
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),		/* Section flags.  */

  /* Leading_symbol_char: is the first char of a user symbol
     predictable, and if so what is it.  */
  0,
  '/',				/* AR_pad_char.  */
  14,				/* AR_max_namelen.  */
  0,				/* match priority.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* Data.  */
  bfd_getb64, bfd_getb_signed_64, bfd_putb64,
  bfd_getb32, bfd_getb_signed_32, bfd_putb32,
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* Headers.  */
  {_bfd_dummy_target,
   som_object_p,		/* bfd_check_format.  */
   bfd_generic_archive_p,
   _bfd_dummy_target
  },
  {
    bfd_false,
    som_mkobject,
    _bfd_generic_mkarchive,
    bfd_false
  },
  {
    bfd_false,
    som_write_object_contents,
    _bfd_write_archive_contents,
    bfd_false,
  },
#undef som

  BFD_JUMP_TABLE_GENERIC (som),
  BFD_JUMP_TABLE_COPY (som),
  BFD_JUMP_TABLE_CORE (_bfd_nocore),
  BFD_JUMP_TABLE_ARCHIVE (som),
  BFD_JUMP_TABLE_SYMBOLS (som),
  BFD_JUMP_TABLE_RELOCS (som),
  BFD_JUMP_TABLE_WRITE (som),
  BFD_JUMP_TABLE_LINK (som),
  BFD_JUMP_TABLE_DYNAMIC (_bfd_nodynamic),

  NULL,

  NULL
};

@


1.87
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d4 1
a4 1
   2012  Free Software Foundation, Inc.
d4575 1
a4575 1
static asection *
@


1.86
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@d2499 1
a2499 1
      aux_hdr_ptr = bfd_zalloc (abfd, 
d5749 1
a5749 1
    { 
d5751 1
a5751 1
  
@


1.85
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d3 2
a4 2
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
d26 1
a27 1
#include "sysdep.h"
@


1.84
log
@	* targets.c (bfd_target): Make ar_max_namelen an unsigned char.
	Add match_priority.
	* configure.in: Bump bfd version.
	* elfcode.h (elf_object_p): Delete hacks preventing match of
	EM_NONE and ELFOSABI_NONE targets when a better match exists.
	* elfxx-target.h (elf_match_priority): Define and use.
	* format.c (bfd_check_format_matches): Use target match_priority
	to choose best of multiple matching targets.  In cases with multiple
	matches rerun _bfd_check_format if we don't choose the last match.
	* aout-adobe.c, * aout-arm.c, * aout-target.h, * aout-tic30.c,
	* binary.c, * bout.c, * coff-alpha.c, * coff-i386.c, * coff-i860.c,
	* coff-i960.c, * coff-ia64.c, * coff-mips.c, * coff-or32.c,
	* coff-ppc.c, * coff-rs6000.c, * coff-sh.c, * coff-tic30.c,
	* coff-tic54x.c, * coff-x86_64.c, * coff64-rs6000.c, * coffcode.h,
	* i386msdos.c, * i386os9k.c, * ieee.c, * ihex.c, * mach-o-target.c,
	* mipsbsd.c, * mmo.c, * nlm-target.h, * oasys.c, * pdp11.c,
	* pe-mips.c, * pef.c, * plugin.c, * ppcboot.c, * som.c, * srec.c,
	* tekhex.c, * trad-core.c, * verilog.c, * versados.c, * vms-alpha.c,
	* vms-lib.c, * xsym.c: Init match_priority field.
	* configure: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d6744 1
@


1.83
log
@	* bfd.c (bfd_perror): Flush stdout before and stderr after printing
	error.
	(_bfd_default_error_handler): Likewise.
	* elf.c (print_segment_map): Likewise.
	* libbfd.c (warn_deprecated): Likewise.
	* som.c (som_sizeof_headers): No need to do so here.
	* coff-i860.c: Replace use of printf for error messages with
	_bfd_error_handler.
	* coff-ppc.c: Likewise.
	* coff-sh.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-mep.c: Likewise.
	* elf32-v850.c: Likewise.
	* mach-o.c: Likewise.
	* pef.c: Likewise.
@
text
@d6771 1
@


1.82
log
@fix set but unused variable warnings
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
a5776 1
  fflush (stderr);
@


1.82.4.1
log
@backport from mainline
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d5777 1
@


1.81
log
@bfd/
2010-06-10  Tristan Gingold  <gingold@@adacore.com>

	* som.c: Can now be compiled on any host.
	Include bfd headers instead of system one.
	(som_compute_checksum): Parameter is now a pointer to a
	som_external_header structure.  Adjust.
	(struct section_to_type): Field section is now const.
	(R_DLT_REL, R_AUX_UNWIND, R_SEC_STMT): Removed conditional
	definition.
	(R_LONG_PCREL_MODE, R_N0SEL, R_N1SEL, R_LINETAB): Ditto.
	(R_LINETAB_ESC, R_LTP_OVERRIDE, R_COMMENT): Ditto.
	(som_swap_clock_in, som_swap_clock_out): New functions.
	(som_swap_header_in, som_swap_header_out): Likewise.
	(som_swap_space_dictionary_in): Likewise.
	(som_swap_space_dictionary_out): Likewise.
	(som_swap_subspace_dictionary_in): Likewise.
	(som_swap_subspace_dictionary_record_out): Likewise.
	(som_swap_aux_id_in, som_swap_aux_id_out): Likewise.
	(som_swap_string_auxhdr_out): Likewise.
	(som_swap_compilation_unit_out): Likewise.
	(som_swap_exec_auxhdr_in): Likewise.
	(som_swap_exec_auxhdr_out): Likewise.
	(som_swap_lst_header_in): Likewise.
	(som_object_setup): Adjust parameter type using bfd types.
	(setup_sections): Likewise.  Ditto for object file types.
	Use intermediate variables for external representation and use the
	swap functions to convert.
	(som_object_p): Ditto.  Remove #ifdef/#endif on always defined
	macros.
	(som_prep_headers): Likewise.
	(som_write_symbol_strings): Likewise.
	(som_begin_writing): Likewise.
	(som_finish_writing): Likewise.
	(som_build_and_write_symbol_table): Likewise.
	(bfd_section_from_som_symbol): Likewise.
	(som_slurp_symbol_table): Likewise.
	(som_bfd_print_private_bfd_data): Likewise.
	(bfd_som_attach_aux_hdr): Likewise.  Clear the padding.
	(bfd_som_attach_compilation_unit): Likewise.
	(som_bfd_count_ar_symbols): Likewise.
	(som_bfd_fill_in_ar_symbols): Likewise.
	(som_slurp_armap): Likewise.
	(som_bfd_ar_write_symbol_stuff): Likewise.
	(som_write_armap): Likewise.  Use _bfd_ar_spacepad instead of
	sprintf to write header fields.
	* som.h: Include bfd headers instead of system one.
	(FILE_HDR_SIZE, AUX_HDR_SIZE): Removed.
	(struct somdata): Use bfd structures instead of system ones.
	(struct som_section_data_struct): Likewise.
	(struct som_subspace_dictionary_record): Removed (now in
	include/som/internal.h)

gas/
2010-06-10  Tristan Gingold  <gingold@@adacore.com>

	* config/obj-som.h: Includes som/reloc.h
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
a6296 1
  file_ptr lst_filepos;
a6324 4
  /* Lots of fields are file positions relative to the start
     of the lst record.  So save its location.  */
  lst_filepos = bfd_tell (abfd) - sizeof (struct som_external_lst_header);

@


1.80
log
@2010-06-08  Tristan Gingold  <gingold@@adacore.com>

	* som.c (som_bfd_free_cached_info): Do not free relocations as
	they were allocated with bfd_zalloc.
@
text
@a29 2
#if defined (HOST_HPPAHPUX) || defined (HOST_HPPABSD) || defined (HOST_HPPAOSF) || defined(HOST_HPPAMPEIX)

d33 2
a34 5

#include <sys/param.h>
#include <signal.h>
#include <machine/reg.h>
#include <sys/file.h>
d42 1
a42 1
static unsigned long som_compute_checksum (bfd *);
d143 1
a143 1
  char *section;
a633 11
#ifndef R_DLT_REL
#define R_DLT_REL 0x78
#endif

#ifndef R_AUX_UNWIND
#define R_AUX_UNWIND 0xcf
#endif

#ifndef R_SEC_STMT
#define R_SEC_STMT 0xd7
#endif
a640 28
#ifndef R_LONG_PCREL_MODE
#define R_LONG_PCREL_MODE 0x3f
#endif

#ifndef R_N0SEL
#define R_N0SEL 0xd8
#endif

#ifndef R_N1SEL
#define R_N1SEL 0xd9
#endif

#ifndef R_LINETAB
#define R_LINETAB 0xda
#endif

#ifndef R_LINETAB_ESC
#define R_LINETAB_ESC 0xdb
#endif

#ifndef R_LTP_OVERRIDE
#define R_LTP_OVERRIDE 0xdc
#endif

#ifndef R_COMMENT
#define R_COMMENT 0xdd
#endif

d1604 343
d1952 1
a1952 1
		  struct header *file_hdrp,
d2076 1
a2076 1
		struct header *file_hdr,
d2101 4
a2104 1
      struct space_dictionary_record space;
d2114 1
a2114 1
		     + space_index * sizeof space),
d2117 2
a2118 2
      amt = sizeof space;
      if (bfd_bread (&space, amt, abfd) != amt)
d2121 2
d2124 1
a2124 1
      space.name.n_name = space.name.n_strx + space_strings;
d2127 1
a2127 1
      amt = strlen (space.name.n_name) + 1;
d2131 1
a2131 1
      strcpy (newname, space.name.n_name);
d2153 1
a2153 1
		     + space.subspace_index * sizeof subspace),
d2156 2
a2157 2
      amt = sizeof subspace;
      if (bfd_bread (&subspace, amt, abfd) != amt)
d2162 1
a2162 1
		     + space.subspace_index * sizeof subspace),
d2166 2
d2185 1
d2188 2
a2189 2
	  amt = sizeof subspace;
	  if (bfd_bread (&subspace, amt, abfd) != amt)
d2192 2
d2195 1
a2195 1
	  subspace.name.n_name = subspace.name.n_strx + space_strings;
d2197 1
a2197 1
	  amt = strlen (subspace.name.n_name) + 1;
d2201 1
a2201 1
	  strcpy (newname, subspace.name.n_name);
d2378 1
d2384 2
a2385 1
  struct header file_hdr;
d2388 2
a2389 2
  struct lst_header lst_header;
  struct som_entry som_entry;
d2391 2
a2392 1
#define ENTRY_SIZE sizeof (struct som_entry)
d2394 2
a2395 2
  amt = FILE_HDR_SIZE;
  if (bfd_bread ((void *) &file_hdr, amt, abfd) != amt)
d2402 2
a2415 1
#ifdef DL_MAGIC
a2416 2
#endif
#ifdef SHL_MAGIC
a2417 1
#endif
a2422 1
#ifdef EXECLIBMAGIC
d2433 2
a2434 2
      amt = SLSTHDR;
      if (bfd_bread ((void *) &lst_header, amt, abfd) != amt)
d2442 2
a2443 2

      if (bfd_seek (abfd, lst_header.dir_loc, SEEK_SET) != 0)
d2451 1
a2451 1
      if (bfd_bread ((void *) &som_entry, amt, abfd) != amt)
d2459 2
a2460 2

      if (bfd_seek (abfd, som_entry.location, SEEK_SET) != 0)
a2466 2
      current_offset = som_entry.location;

d2468 2
a2469 2
      amt = FILE_HDR_SIZE;
      if (bfd_bread ((void *) &file_hdr, amt, abfd) != amt)
d2476 2
a2478 1
#endif
d2485 1
a2485 1
  if (file_hdr.version_id != VERSION_ID
d2497 2
d2503 2
a2504 2
      amt = AUX_HDR_SIZE;
      if (bfd_bread ((void *) aux_hdr_ptr, amt, abfd) != amt)
d2510 1
d2543 1
a2543 1
  struct header *file_hdr;
d2545 1
a2545 1
  bfd_size_type amt = sizeof (struct header);
d2598 1
a2598 1
	  amt = sizeof (struct space_dictionary_record);
d3356 4
a3359 1
	      tmp_space_size = MAX (2 * tmp_space_size, 5 + length);
d3375 1
a3375 1
	som_section_data (section)->space_dict->name.n_strx = strings_size;
d3377 1
a3377 1
	som_section_data (section)->subspace_dict->name.n_strx = strings_size;
d3410 1
a3410 1
			  COMPUNIT *compilation_unit)
a3420 1
  char *comp[4];
a3428 7
  if (compilation_unit)
    {
      comp[0] = compilation_unit->name.n_name;
      comp[1] = compilation_unit->language_name.n_name;
      comp[2] = compilation_unit->product_id.n_name;
      comp[3] = compilation_unit->version_id.n_name;
    }
d3439 22
a3460 1
	  size_t length = strlen (comp[i]);
d3476 4
a3479 1
		  tmp_space_size = MAX (2 * tmp_space_size, 5 + length);
d3497 1
a3497 1
	  strcpy (p, comp[i]);
d3499 1
a3499 18
	  switch (i)
	    {
	    case 0:
	      obj_som_compilation_unit (abfd)->name.n_strx = strings_size;
	      break;
	    case 1:
	      obj_som_compilation_unit (abfd)->language_name.n_strx =
		strings_size;
	      break;
	    case 2:
	      obj_som_compilation_unit (abfd)->product_id.n_strx =
		strings_size;
	      break;
	    case 3:
	      obj_som_compilation_unit (abfd)->version_id.n_strx =
		strings_size;
	      break;
	    }
d3531 4
a3534 1
	      tmp_space_size = MAX (2 * tmp_space_size, 5 + length);
d3601 1
a3601 1
  current_offset += sizeof (struct header);
d3612 1
a3612 1
      current_offset += sizeof (struct som_exec_auxhdr);
d3614 1
a3614 1
	+= sizeof (struct som_exec_auxhdr);
d3621 1
d3628 1
a3628 1
      len = sizeof (struct aux_id) + sizeof (unsigned int);
d3631 3
a3633 1
      if (bfd_bwrite ((void *) obj_som_version_hdr (abfd), len, abfd) != len)
d3637 1
a3637 1
      len = obj_som_version_hdr (abfd)->header_id.length - sizeof (int);
d3640 1
a3640 1
      if (bfd_bwrite ((void *) obj_som_version_hdr (abfd)->user_string, len, abfd)
d3647 1
d3654 1
a3654 1
      len = sizeof (struct aux_id) + sizeof (unsigned int);
d3657 3
a3659 1
      if (bfd_bwrite ((void *) obj_som_copyright_hdr (abfd), len, abfd) != len)
d3663 1
a3663 1
      len = obj_som_copyright_hdr (abfd)->header_id.length - sizeof (int);
d3666 1
a3666 1
      if (bfd_bwrite ((void *) obj_som_copyright_hdr (abfd)->copyright, len, abfd)
d3688 2
a3689 1
  current_offset += num_spaces * sizeof (struct space_dictionary_record);
d3702 1
a3702 1
    += num_subspaces * sizeof (struct som_subspace_dictionary_record);
d3731 1
a3731 1
      current_offset += COMPUNITSZ;
d3946 1
d3978 2
a3979 1
  current_offset += num_syms * sizeof (struct symbol_dictionary_record);
d4048 1
d4079 2
d4082 1
a4082 2
	  if (bfd_bwrite ((void *) som_section_data (subsection)->subspace_dict,
			 amt, abfd) != amt)
d4105 1
d4137 2
d4140 1
a4140 2
	  if (bfd_bwrite ((void *) som_section_data (subsection)->subspace_dict,
			 amt, abfd) != amt)
d4159 2
d4166 4
a4169 3
      amt = sizeof (struct space_dictionary_record);
      if (bfd_bwrite ((void *) som_section_data (section)->space_dict,
		     amt, abfd) != amt)
d4179 2
d4185 5
a4189 2
      amt = COMPUNITSZ;
      if (bfd_bwrite ((void *) obj_som_compilation_unit (abfd), amt, abfd) != amt)
d4204 1
a4204 1
  /* Compute the checksum for the file header just before writing
d4206 2
a4207 1
  obj_som_file_hdr (abfd)->checksum = som_compute_checksum (abfd);
d4213 2
a4214 2
  amt = sizeof (struct header);
  if (bfd_bwrite ((void *) obj_som_file_hdr (abfd), amt, abfd) != amt)
d4222 1
d4248 2
d4254 2
a4255 2
      amt = AUX_HDR_SIZE;
      if (bfd_bwrite ((void *) exec_header, amt, abfd) != amt)
d4264 1
a4264 1
som_compute_checksum (bfd *abfd)
d4267 1
a4267 1
  unsigned long *buffer = (unsigned long *) obj_som_file_hdr (abfd);
d4270 1
a4270 1
  count = sizeof (struct header) / sizeof (unsigned long);
d4443 1
a4443 1
  struct symbol_dictionary_record *som_symtab = NULL;
d4450 1
a4450 1
  symtab_size *= sizeof (struct symbol_dictionary_record);
d4459 1
d4464 2
a4465 1
      som_symtab[i].name.n_strx = som_symbol_data(bfd_syms[i])->stringtab_offset;
d4471 14
a4484 10
      som_symtab[i].symbol_type = info.symbol_type;
      som_symtab[i].symbol_scope = info.symbol_scope;
      som_symtab[i].arg_reloc = info.arg_reloc;
      som_symtab[i].symbol_info = info.symbol_info;
      som_symtab[i].xleast = 3;
      som_symtab[i].symbol_value = info.symbol_value | info.priv_level;
      som_symtab[i].secondary_def = info.secondary_def;
      som_symtab[i].is_comdat = info.is_comdat;
      som_symtab[i].is_common = info.is_common;
      som_symtab[i].dup_common = info.dup_common;
d4576 2
a4577 1
bfd_section_from_som_symbol (bfd *abfd, struct symbol_dictionary_record *symbol)
d4580 2
d4587 4
a4590 4
      || (symbol->symbol_type != ST_ENTRY
	  && symbol->symbol_type != ST_PRI_PROG
	  && symbol->symbol_type != ST_SEC_PROG
	  && symbol->symbol_type != ST_MILLICODE))
d4592 2
a4593 1
      int idx = symbol->symbol_info;
d4601 1
a4601 1
      unsigned int value = symbol->symbol_value;
d4623 1
a4623 1
  int symsize = sizeof (struct symbol_dictionary_record);
d4625 1
a4625 1
  struct symbol_dictionary_record *buf = NULL, *bufp, *endbufp;
d4663 6
d4670 1
a4670 2
      if (bufp->symbol_type == ST_SYM_EXT
	  || bufp->symbol_type == ST_ARG_EXT)
d4674 1
a4674 1
      if (bufp->symbol_type == ST_NULL)
d4676 1
a4676 1
      else if (bufp->symbol_type == ST_ABSOLUTE)
d4678 1
a4678 1
      else if (bufp->symbol_type == ST_DATA)
d4680 1
a4680 1
      else if (bufp->symbol_type == ST_CODE)
d4682 1
a4682 1
      else if (bufp->symbol_type == ST_PRI_PROG)
d4684 1
a4684 1
      else if (bufp->symbol_type == ST_SEC_PROG)
d4686 1
a4686 1
      else if (bufp->symbol_type == ST_ENTRY)
d4688 1
a4688 1
      else if (bufp->symbol_type == ST_MILLICODE)
d4690 1
a4690 1
      else if (bufp->symbol_type == ST_PLABEL)
d4694 2
a4695 1
      som_symbol_data (sym)->tc_data.ap.hppa_arg_reloc = bufp->arg_reloc;
d4699 2
a4700 2
      sym->symbol.name = bufp->name.n_strx + stringtab;
      sym->symbol.value = bufp->symbol_value;
d4704 1
a4704 1
      switch (bufp->symbol_type)
d4723 1
a4723 1
	  if (bufp->symbol_scope == SS_UNSAT)
d4731 1
a4731 1
      switch (bufp->symbol_scope)
d4736 1
a4736 1
	  if (bufp->symbol_type != ST_STORAGE)
d4744 1
a4744 1
	  if (bufp->symbol_type != ST_STORAGE)
d4764 1
a4764 1
      if (bufp->secondary_def)
d5463 1
a5463 1
  struct aux_id* auxhdr;
d5590 1
a5590 1
      amt = sizeof (struct aux_id) + sizeof (unsigned int) + len + pad;
d5595 1
a5595 2
      obj_som_version_hdr (abfd)->header_id.length = len + pad;
      obj_som_version_hdr (abfd)->header_id.length += sizeof (int);
d5597 2
a5598 1
      strncpy (obj_som_version_hdr (abfd)->user_string, string, len);
d5607 1
a5607 1
      amt = sizeof (struct aux_id) + sizeof (unsigned int) + len + pad;
d5612 1
a5612 2
      obj_som_copyright_hdr (abfd)->header_id.length = len + pad;
      obj_som_copyright_hdr (abfd)->header_id.length += sizeof (int);
d5614 2
a5615 1
      strcpy (obj_som_copyright_hdr (abfd)->copyright, string);
d5630 1
a5630 1
  COMPUNIT *n = (COMPUNIT *) bfd_zalloc (abfd, (bfd_size_type) COMPUNITSZ);
d5632 2
d5640 2
a5641 2
      n->f.n_name = bfd_alloc (abfd, (bfd_size_type) strlen (f) + 1); \
      if (n->f.n_name == NULL) \
d5643 1
a5643 1
      strcpy (n->f.n_name, f); \
d5864 1
a5864 1
			  struct lst_header *lst_header,
d5868 1
a5868 1
  unsigned int *hash_table = NULL;
d5870 1
a5870 1
  file_ptr lst_filepos = bfd_tell (abfd) - sizeof (struct lst_header);
d5872 3
a5874 2
  amt = lst_header->hash_size;
  amt *= sizeof (unsigned int);
d5876 1
a5876 1
  if (hash_table == NULL && lst_header->hash_size != 0)
d5891 2
a5892 1
      struct lst_symbol_record lst_symbol;
d5895 1
a5895 1
      if (hash_table[i] == 0)
d5899 1
a5899 1
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) != 0)
d5903 2
a5904 2
      amt = sizeof (lst_symbol);
      if (bfd_bread ((void *) &lst_symbol, amt, abfd) != amt)
d5910 1
a5910 1
      while (lst_symbol.next_entry)
d5912 4
d5918 1
a5918 2
	  if (bfd_seek (abfd, lst_filepos + lst_symbol.next_entry, SEEK_SET)
	      != 0)
d5922 2
a5923 2
	  amt = sizeof (lst_symbol);
	  if (bfd_bread ((void *) &lst_symbol, amt, abfd) != amt)
d5944 1
a5944 1
			    struct lst_header *lst_header,
d5947 1
a5947 1
  unsigned int i, len;
d5949 2
a5950 2
  unsigned int *hash_table = NULL;
  struct som_entry *som_dict = NULL;
d5952 2
a5953 1
  file_ptr lst_filepos = bfd_tell (abfd) - sizeof (struct lst_header);
d5955 2
a5956 2
  amt = lst_header->hash_size;
  amt *= sizeof (unsigned int);
d5958 1
a5958 1
  if (hash_table == NULL && lst_header->hash_size != 0)
d5971 1
a5971 2
  amt = lst_header->module_count;
  amt *= sizeof (struct som_entry);
d5973 1
a5973 1
  if (som_dict == NULL && lst_header->module_count != 0)
d5979 2
d5984 4
a5987 1
      struct lst_symbol_record lst_symbol;
d5990 2
a5991 1
      if (hash_table[i] == 0)
d5995 1
a5995 1
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) != 0)
d6009 2
a6010 2
      if (bfd_seek (abfd, lst_filepos + lst_header->string_loc
			    + lst_symbol.name.n_strx - 4, SEEK_SET) != 0)
d6013 1
a6013 1
      if (bfd_bread (&len, (bfd_size_type) 4, abfd) != 4)
d6015 1
d6028 3
a6030 2
      set->file_offset = som_dict[lst_symbol.som_index].location
			  - sizeof (struct ar_hdr);
d6036 1
a6036 1
      while (lst_symbol.next_entry)
d6038 5
d6044 1
a6044 2
	  if (bfd_seek (abfd, lst_filepos + lst_symbol.next_entry, SEEK_SET)
	      != 0)
d6052 2
a6053 2
	  if (bfd_seek (abfd, lst_filepos + lst_header->string_loc
				+ lst_symbol.name.n_strx - 4, SEEK_SET) != 0)
d6056 1
a6056 1
	  if (bfd_bread (&len, (bfd_size_type) 4, abfd) != 4)
d6058 1
d6071 3
a6073 2
	  set->file_offset = som_dict[lst_symbol.som_index].location
			       - sizeof (struct ar_hdr);
d6100 2
a6101 1
  struct lst_header lst_header;
d6150 2
a6151 2
  amt = sizeof (struct lst_header);
  if (bfd_bread ((void *) &lst_header, amt, abfd) != amt)
d6154 2
d6169 2
a6170 1
		       + sizeof (struct lst_header)), SEEK_SET) != 0)
d6261 1
a6261 1
	  *stringsize = *stringsize + strlen (sym->symbol.name) + 5;
d6294 1
a6294 1
			       struct lst_header lst,
d6299 1
a6299 1
  struct lst_symbol_record *lst_syms = NULL, *curr_lst_sym;
d6301 3
a6303 3
  unsigned int *hash_table = NULL;
  struct som_entry *som_dict = NULL;
  struct lst_symbol_record **last_hash_entry = NULL;
d6306 2
d6309 2
a6310 2
  amt = lst.hash_size;
  amt *= sizeof (unsigned int);
d6312 1
a6312 1
  if (hash_table == NULL && lst.hash_size != 0)
d6315 2
a6316 2
  amt = lst.module_count;
  amt *= sizeof (struct som_entry);
d6318 1
a6318 1
  if (som_dict == NULL && lst.module_count != 0)
d6321 1
a6321 2
  amt = lst.hash_size;
  amt *= sizeof (struct lst_symbol_record *);
d6323 1
a6323 1
  if (last_hash_entry == NULL && lst.hash_size != 0)
d6328 1
a6328 1
  lst_filepos = bfd_tell (abfd) - sizeof (struct lst_header);
d6342 1
a6342 1
  curr_som_offset = 8 + 2 * sizeof (struct ar_hdr) + lst.file_end;
d6355 1
a6355 1
  amt *= sizeof (struct lst_symbol_record);
d6392 5
d6418 1
a6418 1
	  if (som_dict[som_index].location == 0)
d6420 2
a6421 2
	      som_dict[som_index].location = curr_som_offset;
	      som_dict[som_index].length = arelt_size (curr_bfd);
d6424 2
d6427 22
a6448 21
	  curr_lst_sym->hidden = 0;
	  curr_lst_sym->secondary_def = info.secondary_def;
	  curr_lst_sym->symbol_type = info.symbol_type;
	  curr_lst_sym->symbol_scope = info.symbol_scope;
	  curr_lst_sym->check_level = 0;
	  curr_lst_sym->must_qualify = 0;
	  curr_lst_sym->initially_frozen = 0;
	  curr_lst_sym->memory_resident = 0;
	  curr_lst_sym->is_common = bfd_is_com_section (sym->symbol.section);
	  curr_lst_sym->dup_common = info.dup_common;
	  curr_lst_sym->xleast = 3;
	  curr_lst_sym->arg_reloc = info.arg_reloc;
	  curr_lst_sym->name.n_strx = p - strings + 4;
	  curr_lst_sym->qualifier_name.n_strx = 0;
	  curr_lst_sym->symbol_info = info.symbol_info;
	  curr_lst_sym->symbol_value = info.symbol_value | info.priv_level;
	  curr_lst_sym->symbol_descriptor = 0;
	  curr_lst_sym->reserved = 0;
	  curr_lst_sym->som_index = som_index;
	  curr_lst_sym->symbol_key = som_bfd_ar_symbol_hash (&sym->symbol);
	  curr_lst_sym->next_entry = 0;
d6451 8
a6458 1
	  if (hash_table[curr_lst_sym->symbol_key % lst.hash_size])
a6459 2
	      struct lst_symbol_record *tmp;

d6462 1
a6462 6
	      tmp = last_hash_entry[curr_lst_sym->symbol_key % lst.hash_size];
	      tmp->next_entry
		= (curr_lst_sym - lst_syms) * sizeof (struct lst_symbol_record)
		  + lst.hash_size * 4
		  + lst.module_count * sizeof (struct som_entry)
		  + sizeof (struct lst_header);
d6466 1
a6466 5
	    hash_table[curr_lst_sym->symbol_key % lst.hash_size]
	      = (curr_lst_sym - lst_syms) * sizeof (struct lst_symbol_record)
	      + lst.hash_size * 4
	      + lst.module_count * sizeof (struct som_entry)
	      + sizeof (struct lst_header);
d6470 1
a6470 2
	  last_hash_entry[curr_lst_sym->symbol_key % lst.hash_size]
	    = curr_lst_sym;
d6473 2
a6474 1
	  bfd_put_32 (abfd, strlen (sym->symbol.name), p);
d6476 4
a6479 3
	  strcpy (p, sym->symbol.name);
	  p += strlen (sym->symbol.name) + 1;
	  while ((int) p % 4)
d6483 1
d6485 1
d6504 1
a6504 1
  amt = lst.hash_size * 4;
d6509 1
a6509 1
  amt = lst.module_count * sizeof (struct som_entry);
d6514 1
a6514 1
  amt = nsyms * sizeof (struct lst_symbol_record);
d6565 2
a6566 2
  struct lst_header lst;
  int *p;
d6568 2
d6581 1
a6581 1
  lst_size = sizeof (struct lst_header);
d6586 5
a6590 5
  lst.system_id = CPU_PA_RISC1_0;
  lst.a_magic = LIBMAGIC;
  lst.version_id = VERSION_ID;
  lst.file_time.secs = 0;
  lst.file_time.nanosecs = 0;
d6592 2
a6593 2
  lst.hash_loc = lst_size;
  lst.hash_size = SOM_LST_HASH_SIZE;
d6600 1
a6600 1
  lst.module_count = 0;
d6606 1
a6606 1
	lst.module_count++;
d6609 4
a6612 3
  lst.module_limit = lst.module_count;
  lst.dir_loc = lst_size;
  lst_size += sizeof (struct som_entry) * lst.module_count;
d6618 5
a6622 5
  lst.export_loc = 0;
  lst.export_count = 0;
  lst.import_loc = 0;
  lst.aux_loc = 0;
  lst.aux_size = 0;
d6629 1
a6629 1
  lst_size += sizeof (struct lst_symbol_record) * nsyms;
d6633 2
a6634 2
  lst.string_loc = lst_size;
  lst.string_size = stringsize;
d6638 2
a6639 2
  lst.free_list = 0;
  lst.file_end = lst_size;
d6643 18
a6660 11
  p = (int *) &lst;
  lst.checksum = 0;
  for (i = 0; i < sizeof (struct lst_header) / sizeof (int) - 1; i++)
    lst.checksum ^= *p++;

  sprintf (hdr.ar_name, "/               ");
  sprintf (hdr.ar_date, "%ld", bfd_ardata (abfd)->armap_timestamp);
  sprintf (hdr.ar_uid, "%ld", (long) getuid ());
  sprintf (hdr.ar_gid, "%ld", (long) getgid ());
  sprintf (hdr.ar_mode, "%-8o", (unsigned int) statbuf.st_mode);
  sprintf (hdr.ar_size, "%-10d", (int) lst_size);
d6675 1
a6675 1
  amt = sizeof (struct lst_header);
a6816 1
#endif /* HOST_HPPAHPUX || HOST_HPPABSD || HOST_HPPAOSF */
@


1.79
log
@2010-02-01  Tristan Gingold  <gingold@@adacore.com>

	* som.c (som_write_ar_hdr): Define this macro.
@
text
@d6307 1
a6307 2
      /* Free the generic relocations.  */
      FREE (o->relocation);
@


1.78
log
@2009-12-11  Tristan Gingold  <gingold@@adacore.com>

	* som.c (bfd_som_set_subsection_attributes)
	(bfd_section_from_som_symbol, som_reloc_queue_fix): Fix shadowed
	variable warnings.
	* cache.c (close_one): Likewise.
@
text
@d6327 1
@


1.77
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@d985 1
a985 1
som_reloc_queue_fix (struct reloc_queue *queue, unsigned int index)
d987 1
a987 1
  if (index == 0)
d990 1
a990 1
  if (index == 1)
d1002 1
a1002 1
  if (index == 2)
d1016 1
a1016 1
  if (index == 3)
d4242 1
a4242 1
      int index = symbol->symbol_info;
d4245 1
a4245 1
	if (section->target_index == index && som_is_subspace (section))
d5180 1
a5180 1
				   int access,
d5197 1
a5197 1
  som_section_data (section)->copy_data->access_control_bits = access;
@


1.76
log
@update copyright dates
@
text
@d6346 2
@


1.75
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
@


1.74
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d4475 1
a4475 1
  som_symbol_type *new = bfd_zalloc (abfd, amt);
d4477 1
a4477 1
  if (new == NULL)
d4479 1
a4479 1
  new->symbol.the_bfd = abfd;
d4481 1
a4481 1
  return &new->symbol;
@


1.73
log
@include/
	* alloca-conf.h: Revise based on autoconf-2.61, autoconf-2.13
	documentation.
bfd/
	* elf32-m68hc1x.c: Include alloca-conf.h.
	* xsym.c: Likewise.
	* elf64-hppa.c: Likewise.  Remove existing #if's handling alloca.
	* som.c: Likewise.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* sysdep.h: Include alloca-conf.h instead of config.h and remove
	existing #if's handling alloca.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
gas/
	* as.h: Include alloca-conf.h instead of config.h and remove
	existing #if's handling alloca.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* openrisc-opc.c: Regenerate.
ld/
	* ld.h: Remove alloca handling.
@
text
@d6352 1
@


1.72
log
@	PR binutils/9921
	* som.c (som_bfd_derive_misc_symbol_info): Set symbol type ST_ABSOLUTE
	for unknown symbols in absolute section.
@
text
@d26 1
a40 26
/* This is the code recommended in the autoconf documentation, almost
   verbatim.  */

#ifndef __GNUC__
# if HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifdef _AIX
/* Indented so that pre-ansi C compilers will ignore it, rather than
   choke on it.  Some versions of AIX require this to be the first
   thing in the file.  */
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
#    if !defined (__STDC__) && !defined (__hpux)
extern char *alloca ();
#    else
extern void *alloca ();
#    endif /* __STDC__, __hpux */
#   endif /* alloca */
#  endif /* _AIX */
# endif /* HAVE_ALLOCA_H */
#else
extern void *alloca (size_t);
#endif /* __GNUC__ */

@


1.71
log
@	* elf-hppa.h (elf_hppa_reloc_final_type): Handle R_PARISC_GPREL64,
	R_PARISC_SEGREL32 and R_PARISC_SEGREL64.
	* som.c (som_fixup_formats): Add R_DATA_GPREL fixup.
	(som_hppa_howto_table): Likewise.
	(hppa_som_gen_reloc_type): In case R_HPPA_GOTOFF, detect R_DATA_GPREL
	final type.
	(som_write_fixups): Handle R_DATA_GPREL.

	* config/tc-hppa.c (is_SB_relative): New macro.
	(fix_new_hppa): Remove $segrel$ marker.
	(cons_fix_new_hppa): Set reloc type R_PARISC_SEGREL32 if expression is
	segment relative.
	* config/tc-hppa.h (tc_frob_symbol): Check for $segrel$.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d4018 3
a4020 1
	  if (sym->section->flags & SEC_CODE)
@


1.70
log
@	PR binutils/5146
	* elf64-hppa.c: Declare alloca when __GNUC__ is defined.
	* som.c: Likewise.
@
text
@d356 1
a356 1
  /* R_DATA_PLEBEL.  */
d440 2
a442 1
  {  0, "" },			/* 0x72 */
d829 1
a829 1
  SOM_HOWTO (R_DP_RELATIVE, "R_DP_RELATIVE"),
d1575 2
d2805 18
@


1.69
log
@PR 5146
* configure.in (AC_CHECK_HEADERS): Add alloca.h
* configure: Regenerate.
* config.in: Regenerate.
* som.c: Replace alloca-conf.h inclusion with code recommended in autoconf documentation.
* elf64-hppa.c: Likewise.
@
text
@d62 2
@


1.68
log
@* som.c (som_get_reloc_upper_bound): If there are no relocs return enough
  space to hold a NULL pointer.
@
text
@a25 1
#include "alloca-conf.h"
d40 24
@


1.67
log
@* syms.c (_bfd_stab_section_find_nearest_line): Look at the
  specific SOM sections for stabs if the regular ones are not found.
* som.h (struct somdata): Add a line_info field, to be used by som_find_nearest_line.
* som.c (som_find_nearest_line): Implement using the bfd stabs function above.
@
text
@d4942 5
a4946 2
  /* There are no relocations.  */
  return 0;
@


1.66
log
@Switch sources over to use the GPL version 3
@
text
@d5334 7
a5340 7
som_find_nearest_line (bfd *abfd ATTRIBUTE_UNUSED,
		       asection *section ATTRIBUTE_UNUSED,
		       asymbol **symbols ATTRIBUTE_UNUSED,
		       bfd_vma offset ATTRIBUTE_UNUSED,
		       const char **filename_ptr ATTRIBUTE_UNUSED,
		       const char **functionname_ptr ATTRIBUTE_UNUSED,
		       unsigned int *line_ptr ATTRIBUTE_UNUSED)
d5342 43
a5384 1
  return FALSE;
@


1.65
log
@bfd/
	* bfd.c (struct bfd): Rename "next" to "archive_next".
	* archive.c: Rename uses throughout file.
	* archive64.c: Likewise.
	* coff-rs6000.c: Likewise.
	* ecoff.c: Likewise.
	* som.c: Likewise.
	* bfd-in2.h: Regenerate.
binutils/
	* ar.c: Rename uses of bfd.next to bfd.archive_next throughout.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* objcopy.c: Likewise.
	* dlltool.c: Likewise.
ld/
	* pe-dll.c: Rename uses of bfd.next to bfd.archive_next throughout.
@
text
@d13 1
a13 1
   the Free Software Foundation; either version 2 of the License, or
@


1.64
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5771 1
a5771 1
	  curr_bfd = curr_bfd->next;
d5816 1
a5816 1
      curr_bfd = curr_bfd->next;
d5925 1
a5925 1
	  curr_bfd = curr_bfd->next;
d6041 1
a6041 1
      curr_bfd = curr_bfd->next;
d6147 1
a6147 1
      curr_bfd = curr_bfd->next;
@


1.63
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d27 1
a28 1
#include "sysdep.h"
@


1.62
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
d1629 16
@


1.61
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d4377 1
a4377 1
      else if (!strncmp (sym->symbol.name, "L$0\002", 4))
d4382 1
a4382 1
      else if (!strncmp (sym->symbol.name, "L$0\001", 4))
d5656 1
a5656 1
  if (strncmp (nextname, "/               ", 16))
@


1.60
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d5331 1
a5331 1
		    bfd_boolean reloc ATTRIBUTE_UNUSED)
@


1.59
log
@	* som.c (som_decode_symclass): Decode BSF_WEAK symbols in the same
	manner as bfd_decode_symclass.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
d4962 3
a4964 1
  bfd_size_type amt = sizeof (struct som_section_data_struct);
d4966 4
a4969 3
  newsect->used_by_bfd = bfd_zalloc (abfd, amt);
  if (!newsect->used_by_bfd)
    return FALSE;
d4973 1
a4973 1
  return TRUE;
@


1.58
log
@	* som.c (som_find_inliner_info): New.
@
text
@d5358 13
a5370 1
    return 'U';
d5374 8
a5381 1
    return 'W';
@


1.57
log
@	* som.c (try_prev_fixup): Changed type of subspace_reloc_sizep to
	unsigned int *.
	(som_write_space_strings): Change type of tmp_space and p to char *.
	(som_write_symbol_strings): Likewise.  Also change type of comp to
	char *comp[4].
	(som_begin_writing): Change type of strings_size to unsigned int.
	(som_finish_writing): Likewise.
	(som_slurp_reloc_table): Change type of external_relocs to unsigned
	char *.
	* som.h (struct som_section_data_struct): Change type of reloc_stream
	field to unsigned char *.
@
text
@d6249 1
@


1.56
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d1057 1
a1057 1
		int *subspace_reloc_sizep,
d2961 2
a2962 2
  unsigned char *tmp_space = alloca (tmp_space_size);
  unsigned char *p = tmp_space;
d3066 2
a3067 2
  unsigned char *tmp_space = alloca (tmp_space_size);
  unsigned char *p = tmp_space;
d3070 1
a3070 1
  unsigned char *comp[4];
d3230 1
a3230 1
  int strings_size = 0;
d3579 1
a3579 1
  int i, num_syms, strings_size;
d3584 1
a3584 1
  unsigned int total_reloc_size;
d4845 1
a4845 1
  char *external_relocs;
@


1.55
log
@Update the FSF address in the copyright/GPL notice
@
text
@d23 1
a23 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
@


1.54
log
@	* som.c (som_bfd_print_private_bfd_data): Add explicit cast to long
	for struct som_exec_auxhdr fields.
@
text
@d24 1
a24 1
   02111-1307, USA.  */
@


1.53
log
@* som.c (hppa_som_reloc, som_mkobject, som_is_space)
(som_is_subspace, compare_subspaces, som_compute_checksum)
(som_build_and_write_symbol_table, som_slurp_symbol_table): New
protoypes.
(hppa_som_reloc, compare_syms, compare_subspaces)
(som_print_symbol, som_get_section_contents)
(som_set_section_contents): Remove space after 'void *'.
(som_bfd_print_private_bfd_data): Use %lx to print longs.
(som_bfd_merge_private_bfd_data)
(som_bfd_copy_private_header_data, som_bfd_set_private_flags): New
defines.
@
text
@d5083 14
a5096 10
      fprintf (f, "  text size          %#lx\n", exec_header->exec_tsize);
      fprintf (f, "  text memory offset %#lx\n", exec_header->exec_tmem);
      fprintf (f, "  text file offset   %#lx\n", exec_header->exec_tfile);
      fprintf (f, "  data size          %#lx\n", exec_header->exec_dsize);
      fprintf (f, "  data memory offset %#lx\n", exec_header->exec_dmem);
      fprintf (f, "  data file offset   %#lx\n", exec_header->exec_dfile);
      fprintf (f, "  bss size           %#lx\n", exec_header->exec_bsize);
      fprintf (f, "  entry point        %#lx\n", exec_header->exec_entry);
      fprintf (f, "  loader flags       %#lx\n", exec_header->exec_flags);
      fprintf (f, "  bss initializer    %#lx\n", exec_header->exec_bfill);
@


1.52
log
@Convert to ISO C90 formatting
@
text
@d41 10
d1326 1
a1326 1
		void * data ATTRIBUTE_UNUSED,
d2420 1
a2420 1
compare_syms (const void * arg1, const void * arg2)
d2450 1
a2450 1
compare_subspaces (const void * arg1, const void * arg2)
d4449 1
a4449 1
		  void * afile,
d5083 10
a5092 10
      fprintf (f, "  text size          %#x\n", exec_header->exec_tsize);
      fprintf (f, "  text memory offset %#x\n", exec_header->exec_tmem);
      fprintf (f, "  text file offset   %#x\n", exec_header->exec_tfile);
      fprintf (f, "  data size          %#x\n", exec_header->exec_dsize);
      fprintf (f, "  data memory offset %#x\n", exec_header->exec_dmem);
      fprintf (f, "  data file offset   %#x\n", exec_header->exec_dfile);
      fprintf (f, "  bss size           %#x\n", exec_header->exec_bsize);
      fprintf (f, "  entry point        %#x\n", exec_header->exec_entry);
      fprintf (f, "  loader flags       %#x\n", exec_header->exec_flags);
      fprintf (f, "  bss initializer    %#x\n", exec_header->exec_bfill);
d5253 1
a5253 1
			  void * location,
d5269 1
a5269 1
			  const void * location,
d6242 3
@


1.51
log
@update copyright dates
@
text
@d114 2
a115 1
struct reloc_queue {
d123 2
a124 1
typedef enum {
d136 2
a137 1
struct section_to_type {
d144 2
a145 1
struct som_misc_symbol_info {
a157 148
/* Forward declarations.  */

static bfd_boolean som_mkobject
  PARAMS ((bfd *));
static const bfd_target * som_object_setup
  PARAMS ((bfd *, struct header *, struct som_exec_auxhdr *, unsigned long));
static bfd_boolean setup_sections
  PARAMS ((bfd *, struct header *, unsigned long));
static const bfd_target * som_object_p
  PARAMS ((bfd *));
static bfd_boolean som_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean som_slurp_string_table
  PARAMS ((bfd *));
static unsigned int som_slurp_symbol_table
  PARAMS ((bfd *));
static long som_get_symtab_upper_bound
  PARAMS ((bfd *));
static long som_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
static long som_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static unsigned int som_set_reloc_info
  PARAMS ((unsigned char *, unsigned int, arelent *, asection *,
	   asymbol **, bfd_boolean));
static bfd_boolean som_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
static long som_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
static asymbol * som_make_empty_symbol
  PARAMS ((bfd *));
static void som_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean som_new_section_hook
  PARAMS ((bfd *, asection *));
static bfd_boolean som_bfd_copy_private_symbol_data
  PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
static bfd_boolean som_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));
static bfd_boolean som_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
#define som_bfd_copy_private_header_data \
  _bfd_generic_bfd_copy_private_header_data
#define som_bfd_merge_private_bfd_data _bfd_generic_bfd_merge_private_bfd_data
#define som_bfd_set_private_flags _bfd_generic_bfd_set_private_flags
static bfd_boolean som_bfd_print_private_bfd_data
  (bfd *, void *);
static bfd_boolean som_bfd_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean som_set_section_contents
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
static bfd_boolean som_get_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean som_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static bfd_boolean som_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static void som_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static asection * bfd_section_from_som_symbol
  PARAMS ((bfd *, struct symbol_dictionary_record *));
static int exact_log2
  PARAMS ((unsigned int));
static bfd_reloc_status_type hppa_som_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void som_initialize_reloc_queue
  PARAMS ((struct reloc_queue *));
static void som_reloc_queue_insert
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static void som_reloc_queue_fix
  PARAMS ((struct reloc_queue *, unsigned int));
static int som_reloc_queue_find
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static unsigned char * try_prev_fixup
  PARAMS ((bfd *, int *, unsigned char *, unsigned int, struct reloc_queue *));
static unsigned char * som_reloc_skip
  PARAMS ((bfd *, unsigned int, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_addend
  PARAMS ((bfd *, bfd_vma, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_call
  PARAMS ((bfd *, unsigned char *, unsigned int *, arelent *, int,
	   struct reloc_queue *));
static unsigned long som_count_spaces
  PARAMS ((bfd *));
static unsigned long som_count_subspaces
  PARAMS ((bfd *));
static int compare_syms
  PARAMS ((const void *, const void *));
static int compare_subspaces
  PARAMS ((const void *, const void *));
static unsigned long som_compute_checksum
  PARAMS ((bfd *));
static bfd_boolean som_prep_headers
  PARAMS ((bfd *));
static int som_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean som_finish_writing
  PARAMS ((bfd *));
static bfd_boolean som_build_and_write_symbol_table
  PARAMS ((bfd *));
static void som_prep_for_fixups
  PARAMS ((bfd *, asymbol **, unsigned long));
static bfd_boolean som_write_fixups
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_space_strings
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_symbol_strings
  PARAMS ((bfd *, unsigned long, asymbol **, unsigned int, unsigned *,
	   COMPUNIT *));
static bfd_boolean som_begin_writing
  PARAMS ((bfd *));
static reloc_howto_type * som_bfd_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static char som_section_type
  PARAMS ((const char *));
static int som_decode_symclass
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_count_ar_symbols
  PARAMS ((bfd *, struct lst_header *, symindex *));
static bfd_boolean som_bfd_fill_in_ar_symbols
  PARAMS ((bfd *, struct lst_header *, carsym **));
static bfd_boolean som_slurp_armap
  PARAMS ((bfd *));
static bfd_boolean som_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static void som_bfd_derive_misc_symbol_info
  PARAMS ((bfd *, asymbol *, struct som_misc_symbol_info *));
static bfd_boolean som_bfd_prep_for_ar_write
  PARAMS ((bfd *, unsigned int *, unsigned int *));
static unsigned int som_bfd_ar_symbol_hash
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_ar_write_symbol_stuff
  PARAMS ((bfd *, unsigned int, unsigned int, struct lst_header,
	   unsigned int));
static bfd_boolean som_is_space
  PARAMS ((asection *));
static bfd_boolean som_is_subspace
  PARAMS ((asection *));
static bfd_boolean som_is_container
  PARAMS ((asection *, asection *));
static bfd_boolean som_bfd_free_cached_info
  PARAMS ((bfd *));
static bfd_boolean som_bfd_link_split_section
  PARAMS ((bfd *, asection *));

d164 2
a165 1
static const struct section_to_type stt[] = {
d269 2
a270 1
struct fixup_format {
d275 3
a277 2
static const struct fixup_format som_fixup_formats[256] = {
  /* R_NO_RELOCATION */
d310 1
a310 1
  /* R_ZEROES */
d313 1
a313 1
  /* R_UNINIT */
d316 1
a316 1
  /* R_RELOCATION */
d318 1
a318 1
  /* R_DATA_ONE_SYMBOL */
d321 1
a321 1
  /* R_DATA_PLEBEL */
d324 1
a324 1
  /* R_SPACE_REF */
d326 1
a326 1
  /* R_REPEATED_INIT */
d333 1
a333 1
  /* R_PCREL_CALL */
d348 1
a348 1
  /* R_SHORT_PCREL_MODE */
d350 1
a350 1
  /* R_LONG_PCREL_MODE */
d352 1
a352 1
  /* R_ABS_CALL */
d367 1
a367 1
  /* R_RESERVED */
d370 1
a370 1
  /* R_DP_RELATIVE */
d405 1
a405 1
  /* R_RESERVED */
d412 1
a412 1
  /* R_DLT_REL */
d415 1
a415 1
  /* R_RESERVED */
d422 1
a422 1
  /* R_CODE_ONE_SYMBOL */
d457 1
a457 1
  /* R_RESERVED */
d470 1
a470 1
  /* R_MILLI_REL */
d473 1
a473 1
  /* R_CODE_PLABEL */
d476 1
a476 1
  /* R_BREAKPOINT */
d478 1
a478 1
  /* R_ENTRY */
d481 1
a481 1
  /* R_ALT_ENTRY */
d483 1
a483 1
  /* R_EXIT */
d485 1
a485 1
  /* R_BEGIN_TRY */
d487 1
a487 1
  /* R_END_TRY */
d491 1
a491 1
  /* R_BEGIN_BRTAB */
d493 1
a493 1
  /* R_END_BRTAB */
d495 1
a495 1
  /* R_STATEMENT */
d499 1
a499 1
  /* R_DATA_EXPR */
d501 1
a501 1
  /* R_CODE_EXPR */
d503 1
a503 1
  /* R_FSEL */
d505 1
a505 1
  /* R_LSEL */
d507 1
a507 1
  /* R_RSEL */
d509 1
a509 1
  /* R_N_MODE */
d511 1
a511 1
  /* R_S_MODE */
d513 1
a513 1
  /* R_D_MODE */
d515 1
a515 1
  /* R_R_MODE */
d517 1
a517 1
  /* R_DATA_OVERRIDE */
d523 1
a523 1
  /* R_TRANSLATED */
d525 1
a525 1
  /* R_AUX_UNWIND */
d527 1
a527 1
  /* R_COMP1 */
d529 1
a529 1
  /* R_COMP2 */
d531 1
a531 1
  /* R_COMP3 */
d533 1
a533 1
  /* R_PREV_FIXUP */
d538 1
a538 1
  /* R_SEC_STMT */
d540 1
a540 1
  /* R_N0SEL */
d542 1
a542 1
  /* R_N1SEL */
d544 1
a544 1
  /* R_LINETAB */
d546 1
a546 1
  /* R_LINETAB_ESC */
d548 1
a548 1
  /* R_LTP_OVERRIDE */
d550 1
a550 1
  /* R_COMMENT */
d552 1
a552 1
  /* R_RESERVED */
d589 2
a590 1
static const int comp1_opcodes[] = {
d611 2
a612 1
static const int comp2_opcodes[] = {
d620 2
a621 1
static const int comp3_opcodes[] = {
d677 2
a678 1
static reloc_howto_type som_hppa_howto_table[] = {
d941 1
a941 2
som_initialize_reloc_queue (queue)
     struct reloc_queue *queue;
d956 3
a958 4
som_reloc_queue_insert (p, size, queue)
     unsigned char *p;
     unsigned int size;
     struct reloc_queue *queue;
d974 1
a974 3
som_reloc_queue_fix (queue, index)
     struct reloc_queue *queue;
     unsigned int index;
d983 1
d995 1
d1009 1
d1026 3
a1028 4
som_reloc_queue_find (p, size, queue)
     unsigned char *p;
     unsigned int size;
     struct reloc_queue *queue;
d1046 5
a1050 6
try_prev_fixup (abfd, subspace_reloc_sizep, p, size, queue)
     bfd *abfd ATTRIBUTE_UNUSED;
     int *subspace_reloc_sizep;
     unsigned char *p;
     unsigned int size;
     struct reloc_queue *queue;
d1079 5
a1083 6
som_reloc_skip (abfd, skip, p, subspace_reloc_sizep, queue)
     bfd *abfd;
     unsigned int skip;
     unsigned char *p;
     unsigned int *subspace_reloc_sizep;
     struct reloc_queue *queue;
d1150 5
a1154 6
som_reloc_addend (abfd, addend, p, subspace_reloc_sizep, queue)
     bfd *abfd;
     bfd_vma addend;
     unsigned char *p;
     unsigned int *subspace_reloc_sizep;
     struct reloc_queue *queue;
d1187 6
a1192 7
som_reloc_call (abfd, p, subspace_reloc_sizep, bfd_reloc, sym_num, queue)
     bfd *abfd;
     unsigned char *p;
     unsigned int *subspace_reloc_sizep;
     arelent *bfd_reloc;
     int sym_num;
     struct reloc_queue *queue;
d1299 1
a1299 2
exact_log2 (x)
     unsigned int x;
d1313 7
a1319 9
hppa_som_reloc (abfd, reloc_entry, symbol_in, data,
		input_section, output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol_in ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d1322 2
a1323 4
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
d1331 6
a1336 7
hppa_som_gen_reloc_type (abfd, base_type, format, field, sym_diff, sym)
     bfd *abfd;
     int base_type;
     int format;
     enum hppa_reloc_field_selector_type_alt field;
     int sym_diff;
     asymbol *sym;
d1340 2
a1341 2
  final_types = (int **) bfd_alloc (abfd, (bfd_size_type) sizeof (int *) * 6);
  final_type = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1365 1
a1365 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1381 1
a1381 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1392 1
a1392 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1403 1
a1403 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1414 1
a1414 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1424 1
a1424 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1435 1
a1435 1
      final_types[0] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1439 1
a1439 1
      final_types[1] = (int *) bfd_alloc (abfd, (bfd_size_type) sizeof (int));
d1464 5
a1468 4
	  final_types[0] = (int *) bfd_alloc (abfd, amt);
	  final_types[1] = (int *) bfd_alloc (abfd, amt);
	  final_types[2] = (int *) bfd_alloc (abfd, amt);
	  final_types[3] = (int *) bfd_alloc (abfd, amt);
d1546 5
a1550 4
	  final_types[0] = (int *) bfd_alloc (abfd, amt);
	  final_types[1] = (int *) bfd_alloc (abfd, amt);
	  final_types[2] = (int *) bfd_alloc (abfd, amt);
	  final_types[3] = (int *) bfd_alloc (abfd, amt);
d1585 2
a1586 1
	final_types[0] = (int *) bfd_alloc (abfd, amt);
d1607 2
a1608 3
som_bfd_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d1616 1
a1616 1
  return (reloc_howto_type *) 0;
d1623 4
a1626 5
som_object_setup (abfd, file_hdrp, aux_hdrp, current_offset)
     bfd *abfd;
     struct header *file_hdrp;
     struct som_exec_auxhdr *aux_hdrp;
     unsigned long current_offset;
d1632 1
a1632 1
    return 0;
d1670 1
a1670 2
  obj_som_exec_data (abfd) = (struct som_exec_data *)
    bfd_zalloc (abfd, (bfd_size_type) sizeof (struct som_exec_data));
d1726 2
a1727 2
  obj_som_stringtab (abfd) = (char *) NULL;
  obj_som_symtab (abfd) = (som_symbol_type *) NULL;
d1747 3
a1749 4
setup_sections (abfd, file_hdr, current_offset)
     bfd *abfd;
     struct header *file_hdr;
     unsigned long current_offset;
a1758 1

d2003 1
a2003 1
  subspace_sections = (asection **) bfd_malloc (amt);
d2043 1
a2043 2
som_object_p (abfd)
     bfd *abfd;
d2054 1
a2054 1
  if (bfd_bread ((PTR) &file_hdr, amt, abfd) != amt)
d2058 1
a2058 1
      return 0;
d2064 1
a2064 1
      return 0;
d2092 1
a2092 1
	  return 0;
d2096 1
a2096 1
      if (bfd_bread ((PTR) &lst_header, amt, abfd) != amt)
d2100 1
a2100 1
	  return 0;
d2109 1
a2109 1
	  return 0;
d2113 1
a2113 1
      if (bfd_bread ((PTR) &som_entry, amt, abfd) != amt)
d2117 1
a2117 1
	  return 0;
d2126 1
a2126 1
	  return 0;
d2133 1
a2133 1
      if (bfd_bread ((PTR) &file_hdr, amt, abfd) != amt)
d2137 1
a2137 1
	  return 0;
d2145 1
a2145 1
      return 0;
d2152 1
a2152 1
      return 0;
d2165 1
a2165 1
      if (bfd_bread ((PTR) aux_hdr_ptr, amt, abfd) != amt)
d2169 1
a2169 1
	  return 0;
d2177 1
a2177 1
      return 0;
d2187 1
a2187 2
som_mkobject (abfd)
     bfd *abfd;
d2190 1
a2190 2
  abfd->tdata.som_data = (struct som_data_struct *)
    bfd_zalloc (abfd, (bfd_size_type) sizeof (struct som_data_struct));
d2201 1
a2201 2
som_prep_headers (abfd)
     bfd *abfd;
d2208 1
a2208 1
  file_hdr = (struct header *) bfd_zalloc (abfd, amt);
d2217 1
a2217 2
      obj_som_exec_hdr (abfd) =
	(struct som_exec_auxhdr *) bfd_zalloc (abfd, amt);
a2247 1

d2259 1
a2259 2
	  som_section_data (section)->space_dict =
	    (struct space_dictionary_record *) bfd_zalloc (abfd, amt);
d2281 1
a2281 2
	  som_section_data (section)->subspace_dict =
	    (struct som_subspace_dictionary_record *) bfd_zalloc (abfd, amt);
d2324 1
a2324 2
som_is_space (section)
     asection *section;
d2345 1
a2345 2
som_is_subspace (section)
     asection *section;
d2368 1
a2368 2
som_is_container (space, subspace)
     asection *space, *subspace;
d2370 3
a2372 3
  return (som_section_data (subspace)->copy_data->container == space
	  || (som_section_data (subspace)->copy_data->container->output_section
	      == space));
d2378 1
a2378 2
som_count_spaces (abfd)
     bfd *abfd;
d2392 1
a2392 2
som_count_subspaces (abfd)
     bfd *abfd;
d2410 1
a2410 4
compare_syms (arg1, arg2)
     const PTR arg1;
     const PTR arg2;

d2440 1
a2440 4
compare_subspaces (arg1, arg2)
     const PTR arg1;
     const PTR arg2;

d2456 1
a2456 4
som_prep_for_fixups (abfd, syms, num_syms)
     bfd *abfd;
     asymbol **syms;
     unsigned long num_syms;
d2535 1
a2535 1
  sorted_syms = (asymbol **) bfd_zalloc (abfd, amt);
d2554 3
a2556 4
som_write_fixups (abfd, current_offset, total_reloc_sizep)
     bfd *abfd;
     unsigned long current_offset;
     unsigned int *total_reloc_sizep;
d2660 1
a2660 1
		  if (bfd_bwrite ((PTR) tmp_space, amt, abfd) != amt)
d2927 1
a2927 1
	  if (bfd_bwrite ((PTR) tmp_space, amt, abfd) != amt)
d2944 3
a2946 4
som_write_space_strings (abfd, current_offset, string_sizep)
     bfd *abfd;
     unsigned long current_offset;
     unsigned int *string_sizep;
d2984 1
a2984 1
	  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
d3035 1
a3035 1
  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
d3044 6
a3049 8
som_write_symbol_strings (abfd, current_offset, syms, num_syms, string_sizep,
			  compilation_unit)
     bfd *abfd;
     unsigned long current_offset;
     asymbol **syms;
     unsigned int num_syms;
     unsigned int *string_sizep;
     COMPUNIT *compilation_unit;
d3095 1
a3095 1
	      if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
d3164 1
a3164 1
	  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
d3205 1
a3205 1
  if (bfd_bwrite ((PTR) &tmp_space[0], amt, abfd) != amt)
d3217 1
a3217 2
som_begin_writing (abfd)
     bfd *abfd;
d3267 1
a3267 1
      if (bfd_bwrite ((PTR) obj_som_version_hdr (abfd), len, abfd) != len)
d3274 1
a3274 1
      if (bfd_bwrite ((PTR) obj_som_version_hdr (abfd)->user_string, len, abfd)
d3290 1
a3290 1
      if (bfd_bwrite ((PTR) obj_som_copyright_hdr (abfd), len, abfd) != len)
d3297 1
a3297 1
      if (bfd_bwrite ((PTR) obj_som_copyright_hdr (abfd)->copyright, len, abfd)
d3546 1
a3546 1
  if (bfd_bwrite ((PTR) "", (bfd_size_type) 1, abfd) != 1)
d3565 1
a3565 2
som_finish_writing (abfd)
     bfd *abfd;
d3707 1
a3707 1
	  if (bfd_bwrite ((PTR) som_section_data (subsection)->subspace_dict,
d3763 1
a3763 1
	  if (bfd_bwrite ((PTR) som_section_data (subsection)->subspace_dict,
d3789 1
a3789 1
      if (bfd_bwrite ((PTR) som_section_data (section)->space_dict,
d3805 1
a3805 1
      if (bfd_bwrite ((PTR) obj_som_compilation_unit (abfd), amt, abfd) != amt)
d3829 1
a3829 1
  if (bfd_bwrite ((PTR) obj_som_file_hdr (abfd), amt, abfd) != amt)
d3867 1
a3867 1
      if (bfd_bwrite ((PTR) exec_header, amt, abfd) != amt)
d3876 1
a3876 2
som_compute_checksum (abfd)
     bfd *abfd;
d3890 3
a3892 4
som_bfd_derive_misc_symbol_info (abfd, sym, info)
     bfd *abfd ATTRIBUTE_UNUSED;
     asymbol *sym;
     struct som_misc_symbol_info *info;
d4048 1
a4048 2
som_build_and_write_symbol_table (abfd)
     bfd *abfd;
d4061 1
a4061 1
  som_symtab = (struct symbol_dictionary_record *) bfd_zmalloc (symtab_size);
d4096 1
a4096 1
  if (bfd_bwrite ((PTR) som_symtab, symtab_size, abfd) != symtab_size)
d4111 1
a4111 2
som_write_object_contents (abfd)
     bfd *abfd;
d4124 1
a4124 1
  return (som_finish_writing (abfd));
d4130 1
a4130 2
som_slurp_string_table (abfd)
     bfd *abfd;
d4169 1
a4169 2
som_get_symtab_upper_bound (abfd)
     bfd *abfd;
d4174 1
a4174 1
  return (bfd_get_symcount (abfd) + 1) * (sizeof (asymbol *));
d4180 1
a4180 3
bfd_section_from_som_symbol (abfd, symbol)
     bfd *abfd;
     struct symbol_dictionary_record *symbol;
d4194 1
a4197 5

      /* Could be a symbol from an external library (such as an OMOS
	 shared library).  Don't abort.  */
      return bfd_abs_section_ptr;

d4206 5
a4210 10
	{
	  if (value >= section->vma
	      && value <= section->vma + section->size
	      && som_is_subspace (section))
	    return section;
	}

      /* Could be a symbol from an external library (such as an OMOS
	 shared library).  Don't abort.  */
      return bfd_abs_section_ptr;
d4212 3
a4214 1
    }
d4220 1
a4220 2
som_slurp_symbol_table (abfd)
     bfd *abfd;
d4244 1
a4244 1
  symbase = (som_symbol_type *) bfd_zmalloc (amt);
a4262 1

d4401 1
a4401 3
som_canonicalize_symtab (abfd, location)
     bfd *abfd;
     asymbol **location;
d4423 1
a4423 2
som_make_empty_symbol (abfd)
     bfd *abfd;
d4426 2
a4427 1
  som_symbol_type *new = (som_symbol_type *) bfd_zalloc (abfd, amt);
d4429 1
a4429 1
    return 0;
d4438 4
a4441 5
som_print_symbol (abfd, afile, symbol, how)
     bfd *abfd;
     PTR afile;
     asymbol *symbol;
     bfd_print_symbol_type how;
d4444 1
d4458 1
d4460 1
a4460 1
	bfd_print_symbol_vandf (abfd, (PTR) file, symbol);
d4468 2
a4469 3
som_bfd_is_local_label_name (abfd, name)
     bfd *abfd ATTRIBUTE_UNUSED;
     const char *name;
d4471 1
a4471 1
  return (name[0] == 'L' && name[1] == '$');
d4488 6
a4493 7
som_set_reloc_info (fixup, end, internal_relocs, section, symbols, just_count)
     unsigned char *fixup;
     unsigned int end;
     arelent *internal_relocs;
     asection *section;
     asymbol **symbols;
     bfd_boolean just_count;
a4519 1

d4830 4
a4833 5
som_slurp_reloc_table (abfd, section, symbols, just_count)
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_boolean just_count;
d4851 2
a4852 2
      external_relocs = (char *) bfd_malloc (amt);
      if (external_relocs == (char *) NULL)
d4880 1
a4880 1
  if (section->relocation != (arelent *) NULL)
d4885 2
a4886 2
  internal_relocs = (arelent *) bfd_zalloc (abfd, (amt));
  if (internal_relocs == (arelent *) NULL)
d4906 1
a4906 3
som_get_reloc_upper_bound (abfd, asect)
     bfd *abfd;
     sec_ptr asect;
d4924 4
a4927 5
som_canonicalize_reloc (abfd, section, relptr, symbols)
     bfd *abfd;
     sec_ptr section;
     arelent **relptr;
     asymbol **symbols;
d4941 1
a4941 1
  *relptr = (arelent *) NULL;
d4950 1
a4950 3
som_new_section_hook (abfd, newsect)
     bfd *abfd;
     asection *newsect;
d4953 2
a4954 1
  newsect->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d4967 4
a4970 5
som_bfd_copy_private_symbol_data (ibfd, isymbol, obfd, osymbol)
     bfd *ibfd;
     asymbol *isymbol;
     bfd *obfd;
     asymbol *osymbol;
d4992 4
a4995 5
som_bfd_copy_private_section_data (ibfd, isection, obfd, osection)
     bfd *ibfd;
     asection *isection;
     bfd *obfd;
     asection *osection;
d5006 1
a5006 2
  som_section_data (osection)->copy_data =
    (struct som_copyable_section_data_struct *) bfd_zalloc (obfd, amt);
d5026 1
a5026 2
som_bfd_copy_private_bfd_data (ibfd, obfd)
     bfd *ibfd, *obfd;
d5034 1
a5034 2
  obj_som_exec_data (obfd) = (struct som_exec_data *)
    bfd_zalloc (obfd, (bfd_size_type) sizeof (struct som_exec_data));
d5092 5
a5096 6
bfd_som_set_section_attributes (section, defined, private, sort_key, spnum)
     asection *section;
     int defined;
     int private;
     unsigned int sort_key;
     int spnum;
d5102 2
a5103 3
      som_section_data (section)->copy_data =
	(struct som_copyable_section_data_struct *) bfd_zalloc (section->owner,
								amt);
d5119 8
a5126 8
bfd_som_set_subsection_attributes (section, container, access,
				   sort_key, quadrant, comdat,
				   common, dup_common)
     asection *section;
     asection *container;
     int access;
     unsigned int sort_key;
     int quadrant, comdat, common, dup_common;
d5132 2
a5133 3
      som_section_data (section)->copy_data =
	(struct som_copyable_section_data_struct *) bfd_zalloc (section->owner,
								amt);
d5154 1
a5154 3
bfd_som_set_symbol_type (symbol, type)
     asymbol *symbol;
     unsigned int type;
d5163 1
a5163 4
bfd_som_attach_aux_hdr (abfd, type, string)
     bfd *abfd;
     int type;
     char *string;
d5175 1
a5175 2
      obj_som_version_hdr (abfd) =
	(struct user_string_aux_hdr *) bfd_zalloc (abfd, amt);
d5192 1
a5192 2
      obj_som_copyright_hdr (abfd) =
	(struct copyright_aux_hdr *) bfd_zalloc (abfd, amt);
d5208 5
a5212 7
bfd_som_attach_compilation_unit (abfd, name, language_name, product_id,
				 version_id)
     bfd *abfd;
     const char *name;
     const char *language_name;
     const char *product_id;
     const char *version_id;
d5215 1
d5241 5
a5245 6
som_get_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     PTR location;
     file_ptr offset;
     bfd_size_type count;
d5257 5
a5261 6
som_set_section_contents (abfd, section, location, offset, count)
     bfd *abfd;
     sec_ptr section;
     const PTR location;
     file_ptr offset;
     bfd_size_type count;
d5292 3
a5294 4
som_set_arch_mach (abfd, arch, machine)
     bfd *abfd;
     enum bfd_architecture arch;
     unsigned long machine;
d5301 7
a5307 9
som_find_nearest_line (abfd, section, symbols, offset, filename_ptr,
		       functionname_ptr, line_ptr)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section ATTRIBUTE_UNUSED;
     asymbol **symbols ATTRIBUTE_UNUSED;
     bfd_vma offset ATTRIBUTE_UNUSED;
     const char **filename_ptr ATTRIBUTE_UNUSED;
     const char **functionname_ptr ATTRIBUTE_UNUSED;
     unsigned int *line_ptr ATTRIBUTE_UNUSED;
d5313 2
a5314 3
som_sizeof_headers (abfd, reloc)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d5326 1
a5326 2
som_section_type (s)
     const char *s;
d5337 1
a5337 2
som_decode_symclass (symbol)
     asymbol *symbol;
d5368 3
a5370 4
som_get_symbol_info (ignore_abfd, symbol, ret)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
     asymbol *symbol;
     symbol_info *ret;
d5384 3
a5386 4
som_bfd_count_ar_symbols (abfd, lst_header, count)
     bfd *abfd;
     struct lst_header *lst_header;
     symindex *count;
d5395 1
a5395 1
  hash_table = (unsigned int *) bfd_malloc (amt);
d5404 1
a5404 1
  if (bfd_bread ((PTR) hash_table, amt, abfd) != amt)
d5423 1
a5423 1
      if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
d5439 1
a5439 1
	  if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
d5459 3
a5461 4
som_bfd_fill_in_ar_symbols (abfd, lst_header, syms)
     bfd *abfd;
     struct lst_header *lst_header;
     carsym **syms;
d5472 1
a5472 1
  hash_table = (unsigned int *) bfd_malloc (amt);
d5478 1
a5478 1
  if (bfd_bread ((PTR) hash_table, amt, abfd) != amt)
d5488 1
a5488 1
  som_dict = (struct som_entry *) bfd_malloc (amt);
d5492 1
a5492 1
  if (bfd_bread ((PTR) som_dict, amt, abfd) != amt)
d5509 1
a5509 1
      if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
d5552 1
a5552 1
	  if (bfd_bread ((PTR) &lst_symbol, amt, abfd) != amt)
d5600 1
a5600 2
som_slurp_armap (abfd)
     bfd *abfd;
d5608 1
a5608 1
  int i = bfd_bread ((PTR) nextname, amt, abfd);
d5628 1
a5628 1
  if (bfd_bread ((PTR) &ar_header, amt, abfd) != amt)
d5652 1
a5652 1
  if (bfd_bread ((PTR) &lst_header, amt, abfd) != amt)
d5675 1
a5675 1
  ardata->symdefs = (carsym *) bfd_alloc (abfd, amt);
d5699 3
a5701 3
som_bfd_prep_for_ar_write (abfd, num_syms, stringsize)
     bfd *abfd;
     unsigned int *num_syms, *stringsize;
d5773 1
a5773 2
som_bfd_ar_symbol_hash (symbol)
     asymbol *symbol;
d5789 5
a5793 5
som_bfd_ar_write_symbol_stuff (abfd, nsyms, string_size, lst, elength)
     bfd *abfd;
     unsigned int nsyms, string_size;
     struct lst_header lst;
     unsigned elength;
d5807 1
a5807 1
  hash_table = (unsigned int *) bfd_zmalloc (amt);
d5813 1
a5813 1
  som_dict = (struct som_entry *) bfd_zmalloc (amt);
d5819 1
a5819 1
  last_hash_entry = ((struct lst_symbol_record **) bfd_zmalloc (amt));
d5954 6
a5959 8
	    {
	      /* First entry in this hash chain.  */
	      hash_table[curr_lst_sym->symbol_key % lst.hash_size]
		= (curr_lst_sym - lst_syms) * sizeof (struct lst_symbol_record)
		  + lst.hash_size * 4
		  + lst.module_count * sizeof (struct som_entry)
		  + sizeof (struct lst_header);
	    }
d5995 1
a5995 1
  if (bfd_bwrite ((PTR) hash_table, amt, abfd) != amt)
d6000 1
a6000 1
  if (bfd_bwrite ((PTR) som_dict, amt, abfd) != amt)
d6005 1
a6005 1
  if (bfd_bwrite ((PTR) lst_syms, amt, abfd) != amt)
d6010 1
a6010 1
  if (bfd_bwrite ((PTR) strings, amt, abfd) != amt)
d6045 5
a6049 6
som_write_armap (abfd, elength, map, orl_count, stridx)
     bfd *abfd;
     unsigned int elength;
     struct orl *map ATTRIBUTE_UNUSED;
     unsigned int orl_count ATTRIBUTE_UNUSED;
     int stridx ATTRIBUTE_UNUSED;
d6151 1
a6151 1
  if (bfd_bwrite ((PTR) &hdr, amt, abfd) != amt)
d6156 1
a6156 1
  if (bfd_bwrite ((PTR) &lst, amt, abfd) != amt)
d6171 1
a6171 2
som_bfd_free_cached_info (abfd)
     bfd *abfd;
d6182 1
a6182 1
  for (o = abfd->sections; o != (asection *) NULL; o = o->next)
d6200 4
a6203 43
som_bfd_link_split_section (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
{
  return (som_is_subspace (sec) && sec->size > 240000);
}

#define	som_close_and_cleanup		som_bfd_free_cached_info

#define som_read_ar_hdr			_bfd_generic_read_ar_hdr
#define som_openr_next_archived_file	bfd_generic_openr_next_archived_file
#define som_get_elt_at_index		_bfd_generic_get_elt_at_index
#define som_generic_stat_arch_elt	bfd_generic_stat_arch_elt
#define som_truncate_arname		bfd_bsd_truncate_arname
#define som_slurp_extended_name_table	_bfd_slurp_extended_name_table
#define som_construct_extended_name_table \
  _bfd_archive_coff_construct_extended_name_table
#define som_update_armap_timestamp	bfd_true

#define som_bfd_is_target_special_symbol \
  ((bfd_boolean (*) (bfd *, asymbol *)) bfd_false)
#define som_get_lineno			_bfd_nosymbols_get_lineno
#define som_bfd_make_debug_symbol	_bfd_nosymbols_bfd_make_debug_symbol
#define som_read_minisymbols		_bfd_generic_read_minisymbols
#define som_minisymbol_to_symbol	_bfd_generic_minisymbol_to_symbol
#define som_get_section_contents_in_window \
  _bfd_generic_get_section_contents_in_window

#define som_bfd_get_relocated_section_contents \
 bfd_generic_get_relocated_section_contents
#define som_bfd_relax_section bfd_generic_relax_section
#define som_bfd_link_hash_table_create _bfd_generic_link_hash_table_create
#define som_bfd_link_hash_table_free _bfd_generic_link_hash_table_free
#define som_bfd_link_add_symbols _bfd_generic_link_add_symbols
#define som_bfd_link_just_syms _bfd_generic_link_just_syms
#define som_bfd_final_link _bfd_generic_final_link

#define som_bfd_gc_sections		bfd_generic_gc_sections
#define som_bfd_merge_sections		bfd_generic_merge_sections
#define som_bfd_is_group_section	bfd_generic_is_group_section
#define som_bfd_discard_group		bfd_generic_discard_group
#define som_section_already_linked \
  _bfd_generic_section_already_linked
d6205 31
a6235 2
const bfd_target som_vec = {
  "som",			/* name */
d6237 3
a6239 3
  BFD_ENDIAN_BIG,		/* target byte order */
  BFD_ENDIAN_BIG,		/* target headers byte order */
  (HAS_RELOC | EXEC_P |		/* object flags */
d6243 1
a6243 1
   | SEC_ALLOC | SEC_LOAD | SEC_RELOC),		/* section flags */
d6245 2
a6246 2
/* leading_symbol_char: is the first char of a user symbol
   predictable, and if so what is it.  */
d6248 2
a6249 2
  '/',				/* ar_pad_char */
  14,				/* ar_max_namelen */
d6252 1
a6252 1
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* data */
d6255 1
a6255 1
  bfd_getb16, bfd_getb_signed_16, bfd_putb16,	/* hdrs */
d6257 1
a6257 1
   som_object_p,		/* bfd_check_format */
d6287 1
a6287 1
  (PTR) 0
@


1.50
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
@


1.49
log
@	* som.c (som_bfd_print_private_bfd_data): New function.
	(som_object_setup): Save the auxiliary header.  Don't assume that
	zero is an invalid entry point for a shared library.
	(som_object_p): Allocate the auxiliary header on the heap.
@
text
@a4545 5
#if 0
	/* SS_GLOBAL and SS_LOCAL are two names for the same thing.
	   Sound dumb?  It is.  */
	case SS_GLOBAL:
#endif
@


1.48
log
@	* coff-rs6000.c (rs6000coff_vec): Add initializer for
	bfd_is_target_special_symbol.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	* som.c (som_bfd_is_target_special_symbol): Define.
@
text
@d199 2
a1776 1
  int found;
d1814 3
d1831 8
a1838 5
     The new approach examines the entry field.  If it's zero or not 4
     byte aligned then it's not a proper code address and we guess it's
     really the executable flags.  */
  found = 0;
  for (section = abfd->sections; section; section = section->next)
d1840 5
a1844 1
      bfd_vma entry;
d1846 19
a1864 18
      if ((section->flags & SEC_CODE) == 0)
	continue;
      entry = aux_hdrp->exec_entry;
      if (entry >= section->vma
	  && entry < section->vma + section->size)
	found = 1;
    }
  if (aux_hdrp->exec_entry == 0
      || (aux_hdrp->exec_entry & 0x3) != 0
      || ! found)
    {
      bfd_get_start_address (abfd) = aux_hdrp->exec_flags;
      obj_som_exec_data (abfd)->exec_flags = aux_hdrp->exec_entry;
    }
  else
    {
      bfd_get_start_address (abfd) = aux_hdrp->exec_entry + current_offset;
      obj_som_exec_data (abfd)->exec_flags = aux_hdrp->exec_flags;
d2198 1
a2198 1
  struct som_exec_auxhdr aux_hdr;
a2309 1
  memset (&aux_hdr, 0, sizeof (struct som_exec_auxhdr));
d2312 4
d2317 1
a2317 1
      if (bfd_bread ((PTR) &aux_hdr, amt, abfd) != amt)
d2333 1
a2333 1
  return som_object_setup (abfd, &file_hdr, &aux_hdr, current_offset);
d5260 43
a6460 1
#define som_bfd_print_private_bfd_data  _bfd_generic_bfd_print_private_bfd_data
@


1.47
log
@	PR 273
	* som.c (setup_sections): Improve estimation of space sizes in
	relocatable objects.
@
text
@d6405 2
@


1.46
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d1916 1
d2108 3
d2118 19
a2136 5
	/* Setup the size for the space section based upon the info in the
	   last subspace of the space.  */
	space_asect->size = (save_subspace.subspace_start
			     - space_asect->vma
			     + save_subspace.subspace_length);
@


1.45
log
@        * som.c (som_set_reloc_info): Correct small typo.
@
text
@d6407 2
@


1.44
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d4956 1
a4956 1
		      bfd_bute *contents;
@


1.43
log
@binutils ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* objcopy.c (setup_bfd_headers): New function.
	(copy_object): Call setup_bfd_headers.
bfd ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* aout-target.h (MY_bfd_copy_private_header_data): Define.
	* aout-tic30.c (MY_bfd_copy_private_header_data): Define.
	* bfd.c (bfd_copy_private_header_data): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add entries for new
	interface.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_copy_private_header_data): Define.
	* elf-bfd.h (_bfd_elf_copy_private_header_data): Declare.
	* elf.c (_bfd_elf_copy_private_section_data): Remove code to set up
	segments by calling copy_private_bfd_data.
	(_bfd_elf_copy_private_header_data): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_private_header_data): Define.
	* libbfd-in.h (_bfd_generic_bfd_copy_private_header_data): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_private_header_data): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_private_header_data): Define.
	* mmo.c (mmo_bfd_copy_private_header_data): Define.
	* ppcboot.c (ppcboot_bfd_copy_private_header_data): Define.
	* som.c (som_bfd_copy_private_header_data): Define.
	* targets.c (BFD_JUMP_TABLE_COPY): Add _bfd_copy_private_header_data.
	* vms.c (vms_bfd_copy_private_header_data): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d1839 1
a1839 1
	  && entry < section->vma + section->_cooked_size)
d2101 1
a2101 2
	  subspace_asect->_cooked_size = subspace.subspace_length;
	  subspace_asect->_raw_size = subspace.subspace_length;
d2112 1
a2112 4
	{
	  space_asect->_cooked_size = 0;
	  space_asect->_raw_size = 0;
	}
d2114 5
a2118 10
	{
	  /* Setup the sizes for the space section based upon the info in the
	     last subspace of the space.  */
	  space_asect->_cooked_size = (save_subspace.subspace_start
				       - space_asect->vma
				       + save_subspace.subspace_length);
	  space_asect->_raw_size = (save_subspace.file_loc_init_value
				    - space_asect->filepos
				    + save_subspace.initialization_length);
	}
d2423 1
a2423 1
	    bfd_section_size (abfd, section);
d2425 1
a2425 1
	    bfd_section_size (abfd, section);
d3063 1
a3063 2
	  p = som_reloc_skip (abfd, (bfd_section_size (abfd, subsection)
				     - reloc_offset),
d3604 1
a3604 1
		exec_header->exec_tsize += subsection->_cooked_size;
d3607 1
a3607 1
		exec_header->exec_dsize += subsection->_cooked_size;
d3611 2
a3612 2
	      current_offset += bfd_section_size (abfd, subsection);
	      subspace_offset += bfd_section_size (abfd, subsection);
d3619 1
a3619 1
		exec_header->exec_bsize += subsection->_cooked_size;
d3669 1
a3669 1
	      current_offset += bfd_section_size (abfd, subsection);
d3677 1
a3677 1
		initialization_length = bfd_section_size (abfd, subsection);
d4366 1
a4366 1
	      && value <= section->vma + section->_cooked_size
d4956 9
a4964 4
		      section->contents = bfd_malloc (section->_raw_size);
		      if (section->contents == NULL)
			return (unsigned) -1;

a4965 5
		      bfd_get_section_contents (section->owner,
						section,
						section->contents,
						(bfd_vma) 0,
						section->_raw_size);
d5400 1
a5400 1
  if ((bfd_size_type) (offset+count) > section->_raw_size
d6371 1
a6371 1
  return (som_is_subspace (sec) && sec->_raw_size > 240000);
@


1.42
log
@	* som.c (log2): Rename to exact_log2.  Adjust all callers.
@
text
@d195 2
@


1.41
log
@	* som.c (som_bfd_is_group_section): Define.
@
text
@d212 1
a212 1
static int log2
d1434 2
a1435 2
/* Return the logarithm of X, base 2, considering X unsigned.
   Abort -1 if X is not a power or two or is zero.  */
d1438 1
a1438 1
log2 (x)
d1973 1
a1973 1
      space_asect->alignment_power = log2 (subspace.alignment);
d2103 1
a2103 1
	  subspace_asect->alignment_power = log2 (subspace.alignment);
@


1.40
log
@	* som.c (struct som_misc_symbol_info): Add is_comdat, is_common and
	dup_common fields.
	(setup_sections): Use som_subspace_dictionary_record struct instead
	subspace_dictionary_record.  Set SEC_LINK_ONCE if subspace is
	is_comdat, is_common or dup_common.
	(som_prep_headers): Use som_subspace_dictionary_record struct.  Set
	is_comdat, is_common and dup_common in section subspace_dict from
	copy_data.
	(som_begin_writing): Use som_subspace_dictionary_record struct.
	(som_finish_writing): Likewise.
	(som_bfd_derive_misc_symbol_info): Add support to set is_comdat,
	is_common and dup_common flags in info for symbol.  Add comment
	regarding linker support for these fields.  Slightly reorganize
	function.
	(som_build_and_write_symbol_table): Set is_comdat, is_common and
	dup_common fields in symbol table from symbol info.
	(bfd_som_set_subsection_attributes): Add comdat, common and dup_common
	arguments.  Set corresponding fields in copy_data.  Change all callers.
	(som_bfd_ar_write_symbol_stuff): Set dup_common flag in library
	symbol table.
	(som_vec): Add SEC_LINK_ONCE to applicable section flags.
	* som.h (som_subspace_dictionary_record): Define.
	(som_copyable_section_data_struct): Add is_comdat, is_common and
	dup_common fields.
	(som_section_data_struct): Use som_subspace_dictionary_record struct
	instead of subspace_dictionary_record.
	(bfd_boolean bfd_som_set_subsection_attributes): Adjust prototype.
	* config/obj-som.c (obj_som_init_stab_section): Add new arguments in
	call to obj_set_subsection_attributes.
	(obj_som_init_stab_section): Likewise.
	* config/tc-hppa.c (default_subspace_dict): Add comdat field.
	(pa_def_subspaces): Provide comdat default.
	(pa_subspace): Handle new "comdat" parameter.  Set SEC_LINK_ONCE and
	not SEC_IS_COMMON if section is comdat, common or dup_common.  Update
	calls to create_new_subspace and update_subspace to pass comdat flag.
	(create_new_subspace, update_subspace): Add new comdat argument.  Use
	it in calls to obj_set_subsection_attributes.
	* doc/c-hppa.texi (.subspa, .nsubspa): Document new comdat parameter
	and use of comdat, common and dup_comm parameters.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d6413 1
@


1.39
log
@	* hpux-core.c (hpux_core_core_file_p): Add cast in call to
	make_bfd_asection.
	* som.c (som_set_section_contents): Constantify second argument.
	(hppa_som_gen_reloc_type): Abort for unsupported selectors.
	(som_object_setup): Rework to avoid warning.
	(setup_sections, som_write_fixups, bfd_section_from_som_symbol):
	Likewise.
@
text
@d149 3
d1911 1
a1911 1
      struct subspace_dictionary_record subspace, save_subspace;
d1979 1
a1979 1
      memset (&save_subspace, 0, sizeof (struct subspace_dictionary_record));
d2010 4
a2013 1
						   subspace.quadrant))
d2059 4
a2062 3
	  if (subspace.dup_common || subspace.is_common)
	    subspace_asect->flags |= SEC_IS_COMMON;
	  else if (subspace.subspace_length > 0)
d2412 1
a2412 1
	  amt = sizeof (struct subspace_dictionary_record);
d2414 1
a2414 1
	    (struct subspace_dictionary_record *) bfd_zalloc (abfd, amt);
a2420 6
	  if (section->flags & SEC_IS_COMMON)
	    {
	      som_section_data (section)->subspace_dict->dup_common = 1;
	      som_section_data (section)->subspace_dict->is_common = 1;
	    }

d2443 6
d3484 2
a3485 1
  current_offset += num_subspaces * sizeof (struct subspace_dictionary_record);
d3860 1
a3860 1
	  amt = sizeof (struct subspace_dictionary_record);
d3916 1
a3916 1
	  amt = sizeof (struct subspace_dictionary_record);
d4064 2
a4065 2
      /* Common symbols must have scope SS_UNSAT and type
	 ST_STORAGE or the linker will choke.  */
d4068 1
a4069 1
	  info->symbol_type = ST_STORAGE;
a4107 3
      else if (som_symbol_data (sym)->som_type == SYMBOL_TYPE_UNKNOWN)
	info->symbol_type = ST_DATA;

d4128 3
a4130 1
  if (bfd_is_und_section (sym->section))
d4132 1
a4132 2
  else if (sym->flags & (BSF_EXPORT | BSF_WEAK)
	   && ! bfd_is_com_section (sym->section))
d4136 1
a4136 1
  else if (! bfd_is_com_section (sym->section))
d4155 1
a4155 1
  /* The secondary_def field is for weak symbols.  */
d4161 37
d4243 3
d5269 2
a5270 1
				   sort_key, quadrant)
d5275 1
a5275 1
     int quadrant;
d5291 3
d6097 1
a6097 1
	  curr_lst_sym->dup_common = 0;
d6423 1
a6423 1
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS
@


1.38
log
@	* ChangeLog: Fix typos.
	* ecoff.c: Fix comment typos.
	* ecofflink.c: Likewise.
	* format.c: Likewise.
	* hp300hpux.c: Likewise.
	* i386linux.c: Likewise.
	* ieee.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* oasys.c: Likewise.
	* opncls.c: Likewise.
	* peXXigen.c: Likewise.
	* reloc.c: Likewise.
	* reloc16.c: Likewise.
	* section.c: Likewise.
	* simple.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* srec.c: Likewise.
	* syms.c: Likewise.
	* targets.c: Likewise.
	* tekhex.c: Likewise.
	* versados.c: Likewise.
	* vms-gsd.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-misc.c: Likewise.
	* xcofflink.c: Likewise.
	* xsym.h: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d197 1
a197 1
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
d1592 5
d1828 2
d1832 3
a1834 2
      if (aux_hdrp->exec_entry >= section->vma
	  && aux_hdrp->exec_entry < section->vma + section->_cooked_size)
d1909 1
a1909 1
      int subspace_index;
d2736 1
a2736 1
	  int current_call_mode;
d4309 1
a4309 1
      unsigned int index = symbol->symbol_info;
d5369 1
a5369 1
     PTR location;
d5396 1
a5396 1
  if (bfd_bwrite ((PTR) location, count, abfd) != count)
@


1.38.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
a148 3
  unsigned int is_comdat;
  unsigned int is_common;
  unsigned int dup_common;
a191 2
#define som_bfd_copy_private_header_data \
  _bfd_generic_bfd_copy_private_header_data
d197 1
a197 1
  PARAMS ((bfd *, sec_ptr, const PTR, file_ptr, bfd_size_type));
d209 1
a209 1
static int exact_log2
d1431 2
a1432 2
/* Return the logarithm of X, base 2, considering X unsigned,
   if X is a power of 2.  Otherwise, returns -1.  */
d1435 1
a1435 1
exact_log2 (x)
a1591 5

    /* FIXME: These two field selectors are not currently supported.  */
    case e_ltpsel:
    case e_rtpsel:
      abort ();
a1822 2
      bfd_vma entry;

d1825 2
a1826 3
      entry = aux_hdrp->exec_entry;
      if (entry >= section->vma
	  && entry < section->vma + section->size)
d1900 2
a1901 2
      struct som_subspace_dictionary_record subspace, save_subspace;
      unsigned int subspace_index;
a1902 1
      bfd_size_type space_size = 0;
d1962 1
a1962 1
      space_asect->alignment_power = exact_log2 (subspace.alignment);
d1968 1
a1968 1
      memset (&save_subspace, 0, sizeof (save_subspace));
d1999 1
a1999 4
						   subspace.quadrant,
						   subspace.is_comdat,
						   subspace.is_common,
						   subspace.dup_common))
d2045 3
a2047 4
	  if (subspace.is_comdat || subspace.is_common || subspace.dup_common)
	    subspace_asect->flags |= SEC_LINK_ONCE;

	  if (subspace.subspace_length > 0)
d2084 2
a2085 1
	  subspace_asect->size = subspace.subspace_length;
d2088 1
a2088 1
	  subspace_asect->alignment_power = exact_log2 (subspace.alignment);
a2090 3

	  /* Keep track of the accumulated sizes of the sections.  */
	  space_size += subspace.subspace_length;
d2096 4
a2099 1
	space_asect->size = 0;
d2102 8
a2109 17
	  if (file_hdr->a_magic != RELOC_MAGIC)
	    {
	      /* Setup the size for the space section based upon the info
		 in the last subspace of the space.  */
	      space_asect->size = (save_subspace.subspace_start
				   - space_asect->vma
				   + save_subspace.subspace_length);
	    }
	  else
	    {
	      /* The subspace_start field is not initialised in relocatable
	         only objects, so it cannot be used for length calculations.
		 Instead we use the space_size value which we have been
		 accumulating.  This isn't an accurate estimate since it
		 ignores alignment and ordering issues.  */
	      space_asect->size = space_size;
	    }
d2397 1
a2397 1
	  amt = sizeof (struct som_subspace_dictionary_record);
d2399 1
a2399 1
	    (struct som_subspace_dictionary_record *) bfd_zalloc (abfd, amt);
d2406 6
d2421 1
a2421 1
	    section->size;
d2423 1
a2423 1
	    section->size;
a2433 6
	  som_section_data (section)->subspace_dict->is_comdat =
	    som_section_data (section)->copy_data->is_comdat;
	  som_section_data (section)->subspace_dict->is_common =
	    som_section_data (section)->copy_data->is_common;
	  som_section_data (section)->subspace_dict->dup_common =
	    som_section_data (section)->copy_data->dup_common;
d2728 1
a2728 1
	  unsigned int current_call_mode;
d3055 2
a3056 1
	  p = som_reloc_skip (abfd, subsection->size - reloc_offset,
d3469 1
a3469 2
  current_offset
    += num_subspaces * sizeof (struct som_subspace_dictionary_record);
d3596 1
a3596 1
		exec_header->exec_tsize += subsection->size;
d3599 1
a3599 1
		exec_header->exec_dsize += subsection->size;
d3603 2
a3604 2
	      current_offset += subsection->size;
	      subspace_offset += subsection->size;
d3611 1
a3611 1
		exec_header->exec_bsize += subsection->size;
d3661 1
a3661 1
	      current_offset += subsection->size;
d3669 1
a3669 1
		initialization_length = subsection->size;
d3844 1
a3844 1
	  amt = sizeof (struct som_subspace_dictionary_record);
d3900 1
a3900 1
	  amt = sizeof (struct som_subspace_dictionary_record);
d4048 2
a4049 2
      /* For BFD style common, the linker will choke unless we set the
	 type and scope to ST_STORAGE and SS_UNSAT, respectively.  */
d4052 1
a4053 1
	  info->symbol_scope = SS_UNSAT;
d4092 3
d4115 1
a4115 3
  if (bfd_is_com_section (sym->section))
    ;
  else if (bfd_is_und_section (sym->section))
d4117 2
a4118 1
  else if (sym->flags & (BSF_EXPORT | BSF_WEAK))
d4122 1
a4122 1
  else
d4141 1
a4141 1
  /* The secondary_def field is for "weak" symbols.  */
a4146 37
  /* The is_comdat, is_common and dup_common fields provide various
     flavors of common.

     For data symbols, setting IS_COMMON provides Fortran style common
     (duplicate definitions and overlapped initialization).  Setting both
     IS_COMMON and DUP_COMMON provides Cobol style common (duplicate
     definitions as long as they are all the same length).  In a shared
     link data symbols retain their IS_COMMON and DUP_COMMON flags.
     An IS_COMDAT data symbol is similar to a IS_COMMON | DUP_COMMON
     symbol except in that it loses its IS_COMDAT flag in a shared link.

     For code symbols, IS_COMDAT and DUP_COMMON have effect.  Universal
     DUP_COMMON code symbols are not exported from shared libraries.
     IS_COMDAT symbols are exported but they lose their IS_COMDAT flag.

     We take a simplified approach to setting the is_comdat, is_common
     and dup_common flags in symbols based on the flag settings of their
     subspace.  This avoids having to add directives like `.comdat' but
     the linker behavior is probably undefined if there is more than one
     universal symbol (comdat key sysmbol) in a subspace.

     The behavior of these flags is not well documentmented, so there
     may be bugs and some surprising interactions with other flags.  */
  if (som_section_data (sym->section)
      && som_section_data (sym->section)->subspace_dict
      && info->symbol_scope == SS_UNIVERSAL
      && (info->symbol_type == ST_ENTRY
	  || info->symbol_type == ST_CODE
	  || info->symbol_type == ST_DATA))
    {
      info->is_comdat
	= som_section_data (sym->section)->subspace_dict->is_comdat;
      info->is_common
	= som_section_data (sym->section)->subspace_dict->is_common;
      info->dup_common
	= som_section_data (sym->section)->subspace_dict->dup_common;
    }
a4191 3
      som_symtab[i].is_comdat = info.is_comdat;
      som_symtab[i].is_common = info.is_common;
      som_symtab[i].dup_common = info.dup_common;
d4301 1
a4301 1
      int index = symbol->symbol_info;
d4320 1
a4320 1
	      && value <= section->vma + section->size
d4910 4
a4913 9
		      bfd_byte *contents;
		      if (!bfd_malloc_and_get_section (section->owner, section,
						       &contents))
			{
			  if (contents != NULL)
			    free (contents);
			  return (unsigned) -1;
			}
		      section->contents = contents;
d4915 5
d5215 1
a5215 2
				   sort_key, quadrant, comdat,
				   common, dup_common)
d5220 1
a5220 1
     int quadrant, comdat, common, dup_common;
a5235 3
  som_section_data (section)->copy_data->is_comdat = comdat;
  som_section_data (section)->copy_data->is_common = common;
  som_section_data (section)->copy_data->dup_common = dup_common;
d5350 1
a5350 1
  if ((bfd_size_type) (offset+count) > section->size
d5361 1
a5361 1
     const PTR location;
d5388 1
a5388 1
  if (bfd_bwrite (location, count, abfd) != count)
d6039 1
a6039 1
	  curr_lst_sym->dup_common = info.dup_common;
d6321 1
a6321 1
  return (som_is_subspace (sec) && sec->size > 240000);
a6354 1
#define som_bfd_is_group_section	bfd_generic_is_group_section
a6355 2
#define som_section_already_linked \
  _bfd_generic_section_already_linked
d6365 1
a6365 1
  (SEC_CODE | SEC_DATA | SEC_ROM | SEC_HAS_CONTENTS | SEC_LINK_ONCE
@


1.37
log
@Index: doc/ChangeLog
2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* bfdint.texi (BFD target vector symbols): Rename _get_symtab to
	_canonicalize_symtab.

2003-10-15  Andrew Cagney  <cagney@@redhat.com>

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Replace NAME##_get_symtab
	with NAME##_canonicalize_symtab.
	* libcoff-in.h (coff_canonicalize_symtab): Update.
	* xsym.h (bfd_sym_canonicalize_symtab): Update.
	* elf-bfd.h (_bfd_elf_canonicalize_symtab): Update.
	* coffgen.c (coff_canonicalize_symtab): Update.
	* libbfd-in.h (_bfd_nosymbols_canonicalize_symtab): Update.
	* libnlm.h (nlmNAME(canonicalize_symtab)): Update.
	* ieee.c (ieee_vec): Update comment.
	* libecoff.h (_bfd_ecoff_canonicalize_symtab): Update.
	* mmo.c (mmo_canonicalize_symtab): Update.
	* nlm-target.h (nlm_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* i386msdos.c (msdos_canonicalize_symtab): Update.
	* hp300hpux.c (MY (canonicalize_symtab)): Update.
	* oasys.c (oasys_canonicalize_symtab): Update.
	* som.c (som_canonicalize_symtab): Update.
	* pef.c (bfd_pef_canonicalize_symtab): Update.
	* nlmcode.h (nlm_canonicalize_symtab): Update.
	* xsym.c (bfd_sym_canonicalize_symtab): Update.
	* vms.c (vms_canonicalize_symtab): Update.
	* versados.c (versados_canonicalize_symtab): Update.
	* mach-o.c (bfd_mach_o_canonicalize_symtab): Update.
	* ieee.c (ieee_canonicalize_symtab): Update.
	* pdp11.c (NAME(aout,canonicalize_symtab)): Update.
	* reloc.c: Update comment.
	* libaout.h (NAME(aout,canonicalize_symtab)): Update.
	* coff64-rs6000.c (aix5coff64_vec): Update.
	* coff64-rs6000.c (bfd_xcoff_aix5_backend_data): Update.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update.
	* aoutx.h (NAME(aout,canonicalize_symtab)): Update.
	* elfxx-target.h (bfd_elfNN_canonicalize_symtab): Update.
	* hp300hpux.c (MY_canonicalize_symtab): Update.
	* ecoff.c (_bfd_ecoff_canonicalize_symtab): Update.
	* aout-tic30.c (MY_canonicalize_symtab): Update.
	* aout-target.h (MY_canonicalize_symtab): Update.
	* ppcboot.c (ppcboot_canonicalize_symtab): Update.
	* elf.c (_bfd_elf_canonicalize_symtab): Update.
	* elfcode.h (elf_canonicalize_symtab): Update.
	* ihex.c (ihex_canonicalize_symtab): Update.
	* tekhex.c (tekhex_canonicalize_symtab): Update.
	* binary.c (binary_canonicalize_symtab): Update.
	* srec.c (srec_canonicalize_symtab): Update.
@
text
@d1718 1
a1718 1
	   will be eliminted as the relocs are sized and emitted.  */
d2483 1
a2483 1
/* Return TRUE if the given space containins the given subspace.  It
d2737 1
a2737 1
	     finised with it.  */
d3203 1
a3203 1
     write them and update the compliation unit header.  On input, the
d3909 1
a3909 1
  /* All the subspace dictiondary records are written, and all the
d3981 1
a3981 1
	 to be compatable with how the hp linker makes objects
d5783 1
a5783 1
  /* Initializae the cache and allocate space for the library symbols.  */
@


1.36
log
@(som_fixup_formats): Correct formats for R_AUX_UNWIND and R_COMMENT.
@
text
@d178 1
a178 1
static long som_get_symtab
d4523 1
a4523 1
som_get_symtab (abfd, location)
@


1.35
log
@	* coff-h8300.c: Fix comment typos.
	* coffcode.h: Likewise.
	* cpu-cris.c: Likewise.
	* elf32-vax.c: Likewise.
	* genlink.h: Likewise.
	* linker.c: Likewise.
	* som.c: Likewise.
	* tekhex.c: Likewise.
	* vms-misc.c: Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d41 1
a41 1
/* Magic not defined in standard HP-UX header files until 8.0 */
d151 1
a151 1
/* Forward declarations */
a222 1

a268 1

d270 1
a270 1
  PARAMS ((bfd *, struct lst_header *, carsym **syms));
d660 1
a660 1
  {  0,"Sd=Vf=Ef=" },	       /* 0xcf */
d685 1
a685 1
  {  0, "Ob=Ve=" },		/* 0xdd */
a2328 1

d5353 1
a5353 1
    return FALSE; /* on error */
d6369 1
a6369 1
   predictable, and if so what is it */
@


1.34
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d5306 1
a5306 1
/* Attach an compilation unit header to the BFD backend so that it may be
@


1.33
log
@	* aout-adobe.c: Don't compare against "true" or "false.
	* aout-target.h: Likewise.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* cache.c: Likewise.
	* coff-a29k.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-d30v.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.h: Likewise.
	* elfxx-mips.c: Likewise.
	* i386os9k.c: Likewise.
	* ieee.c: Likewise.
	* libbfd.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* nlm32-alpha.c: Likewise.
	* nlm32-i386.c: Likewise.
	* nlm32-ppc.c: Likewise.
	* nlm32-sparc.c: Likewise.
	* nlmcode.h: Likewise.
	* oasys.c: Likewise.
	* pdp11.c: Likewise.
	* peicode.h: Likewise.
	* reloc.c: Likewise.
	* som.c: Likewise.
	* srec.c: Likewise.
	* tekhex.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* elf64-sparc.c: Edit comment to not use "== false".

	* aoutf1.h: Don't use "? true : false".
	* ecoff.c: Likewise.
	* format.c: Likewise.
	* ieee.c: Likewise.
	* linker.c: Likewise.
	* mmo.c: Likewise.
	* oasys.c: Likewise.
@
text
@d153 39
a191 29
static boolean som_mkobject PARAMS ((bfd *));
static const bfd_target * som_object_setup PARAMS ((bfd *,
						    struct header *,
						    struct som_exec_auxhdr *,
						    unsigned long));
static boolean setup_sections PARAMS ((bfd *, struct header *, unsigned long));
static const bfd_target * som_object_p PARAMS ((bfd *));
static boolean som_write_object_contents PARAMS ((bfd *));
static boolean som_slurp_string_table PARAMS ((bfd *));
static unsigned int som_slurp_symbol_table PARAMS ((bfd *));
static long som_get_symtab_upper_bound PARAMS ((bfd *));
static long som_canonicalize_reloc PARAMS ((bfd *, sec_ptr,
					    arelent **, asymbol **));
static long som_get_reloc_upper_bound PARAMS ((bfd *, sec_ptr));
static unsigned int som_set_reloc_info PARAMS ((unsigned char *, unsigned int,
						arelent *, asection *,
						asymbol **, boolean));
static boolean som_slurp_reloc_table PARAMS ((bfd *, asection *,
					      asymbol **, boolean));
static long som_get_symtab PARAMS ((bfd *, asymbol **));
static asymbol * som_make_empty_symbol PARAMS ((bfd *));
static void som_print_symbol PARAMS ((bfd *, PTR,
				      asymbol *, bfd_print_symbol_type));
static boolean som_new_section_hook PARAMS ((bfd *, asection *));
static boolean som_bfd_copy_private_symbol_data PARAMS ((bfd *, asymbol *,
							  bfd *, asymbol *));
static boolean som_bfd_copy_private_section_data PARAMS ((bfd *, asection *,
							  bfd *, asection *));
static boolean som_bfd_copy_private_bfd_data PARAMS ((bfd *, bfd *));
d194 68
a261 59
static boolean som_bfd_is_local_label_name PARAMS ((bfd *, const char *));
static boolean som_set_section_contents PARAMS ((bfd *, sec_ptr, PTR,
						 file_ptr, bfd_size_type));
static boolean som_get_section_contents PARAMS ((bfd *, sec_ptr, PTR,
						 file_ptr, bfd_size_type));
static boolean som_set_arch_mach PARAMS ((bfd *, enum bfd_architecture,
					  unsigned long));
static boolean som_find_nearest_line PARAMS ((bfd *, asection *,
					      asymbol **, bfd_vma,
					      const char **,
					      const char **,
					      unsigned int *));
static void som_get_symbol_info PARAMS ((bfd *, asymbol *, symbol_info *));
static asection * bfd_section_from_som_symbol PARAMS ((bfd *,
					struct symbol_dictionary_record *));
static int log2 PARAMS ((unsigned int));
static bfd_reloc_status_type hppa_som_reloc PARAMS ((bfd *, arelent *,
						     asymbol *, PTR,
						     asection *, bfd *,
						     char **));
static void som_initialize_reloc_queue PARAMS ((struct reloc_queue *));
static void som_reloc_queue_insert PARAMS ((unsigned char *, unsigned int,
					    struct reloc_queue *));
static void som_reloc_queue_fix PARAMS ((struct reloc_queue *, unsigned int));
static int som_reloc_queue_find PARAMS ((unsigned char *, unsigned int,
					 struct reloc_queue *));
static unsigned char * try_prev_fixup PARAMS ((bfd *, int *, unsigned char *,
					       unsigned int,
					       struct reloc_queue *));

static unsigned char * som_reloc_skip PARAMS ((bfd *, unsigned int,
					       unsigned char *, unsigned int *,
					       struct reloc_queue *));
static unsigned char * som_reloc_addend PARAMS ((bfd *, bfd_vma,
						 unsigned char *,
					         unsigned int *,
						 struct reloc_queue *));
static unsigned char * som_reloc_call PARAMS ((bfd *, unsigned char *,
					       unsigned int *,
					       arelent *, int,
					       struct reloc_queue *));
static unsigned long som_count_spaces PARAMS ((bfd *));
static unsigned long som_count_subspaces PARAMS ((bfd *));
static int compare_syms PARAMS ((const void *, const void *));
static int compare_subspaces PARAMS ((const void *, const void *));
static unsigned long som_compute_checksum PARAMS ((bfd *));
static boolean som_prep_headers PARAMS ((bfd *));
static int som_sizeof_headers PARAMS ((bfd *, boolean));
static boolean som_finish_writing PARAMS ((bfd *));
static boolean som_build_and_write_symbol_table PARAMS ((bfd *));
static void som_prep_for_fixups PARAMS ((bfd *, asymbol **, unsigned long));
static boolean som_write_fixups PARAMS ((bfd *, unsigned long, unsigned int *));
static boolean som_write_space_strings PARAMS ((bfd *, unsigned long,
						unsigned int *));
static boolean som_write_symbol_strings PARAMS ((bfd *, unsigned long,
						 asymbol **, unsigned int,
						 unsigned *,
						 COMPUNIT *));
static boolean som_begin_writing PARAMS ((bfd *));
d263 33
a295 25
	PARAMS ((bfd *, bfd_reloc_code_real_type));
static char som_section_type PARAMS ((const char *));
static int som_decode_symclass PARAMS ((asymbol *));
static boolean som_bfd_count_ar_symbols PARAMS ((bfd *, struct lst_header *,
						 symindex *));

static boolean som_bfd_fill_in_ar_symbols PARAMS ((bfd *, struct lst_header *,
						   carsym **syms));
static boolean som_slurp_armap PARAMS ((bfd *));
static boolean som_write_armap PARAMS ((bfd *, unsigned int, struct orl *,
					unsigned int, int));
static void som_bfd_derive_misc_symbol_info PARAMS ((bfd *, asymbol *,
					     struct som_misc_symbol_info *));
static boolean som_bfd_prep_for_ar_write PARAMS ((bfd *, unsigned int *,
						  unsigned int *));
static unsigned int som_bfd_ar_symbol_hash PARAMS ((asymbol *));
static boolean som_bfd_ar_write_symbol_stuff PARAMS ((bfd *, unsigned int,
						      unsigned int,
						      struct lst_header,
						      unsigned int));
static boolean som_is_space PARAMS ((asection *));
static boolean som_is_subspace PARAMS ((asection *));
static boolean som_is_container PARAMS ((asection *, asection *));
static boolean som_bfd_free_cached_info PARAMS ((bfd *));
static boolean som_bfd_link_split_section PARAMS ((bfd *, asection *));
d808 1
a808 1
  HOWTO(TYPE, 0, 0, 32, false, 0, 0, hppa_som_reloc, NAME, false, 0, 0, false)
d1872 1
a1872 1
static boolean
d1961 1
a1961 1
         record.  */
d2096 1
a2096 1
         empty subspaces.  */
d2144 1
a2144 1
  return true;
d2152 1
a2152 1
  return false;
d2299 1
a2299 1
static boolean
d2307 2
a2308 2
    return false;
  return true;
d2315 1
a2315 1
static boolean
d2326 1
a2326 1
    return false;
d2337 1
a2337 1
	return false;
d2381 1
a2381 1
	    return false;
d2404 1
a2404 1
	    return false;
d2439 1
a2439 1
  return true;
d2442 1
a2442 1
/* Return true if the given section is a SOM space, false otherwise.  */
d2444 1
a2444 1
static boolean
d2451 1
a2451 1
    return false;
d2458 1
a2458 1
    return false;
d2461 1
a2461 1
  return true;
d2464 1
a2464 1
/* Return true if the given section is a SOM subspace, false otherwise.  */
d2466 1
a2466 1
static boolean
d2473 1
a2473 1
    return false;
d2480 1
a2480 1
    return false;
d2483 1
a2483 1
  return true;
d2486 1
a2486 1
/* Return true if the given space containins the given subspace.  It
d2490 1
a2490 1
static boolean
d2688 1
a2688 1
static boolean
d2758 1
a2758 1
	    return false;
d2797 1
a2797 1
		    return false;
d3058 2
a3059 2
	  p = som_reloc_skip (abfd, bfd_section_size (abfd, subsection)
			              - reloc_offset,
d3065 1
a3065 1
	    return false;
d3075 1
a3075 1
  return true;
d3080 1
a3080 1
static boolean
d3098 1
a3098 1
    return false;
d3115 3
a3117 3
         current buffer contents now and maybe allocate a larger
         buffer.  Each entry will take 4 bytes to hold the string
         length + the string itself + null terminator.  */
d3123 1
a3123 1
	    return false;
d3129 7
a3135 7
                 consumption for n strings.  The optimal minimum
                 factor seems to be 2, as no other value can guarantee
                 wasting less than 50% space.  (Note that we cannot
                 deallocate space allocated by `alloca' without
                 returning from this function.)  The same technique is
                 used a few more times below when a buffer is
                 reallocated.  */
d3174 1
a3174 1
    return false;
d3176 1
a3176 1
  return true;
d3181 1
a3181 1
static boolean
d3220 1
a3220 1
    return false;
d3236 1
a3236 1
		return false;
d3247 1
a3247 1
                 space.  */
d3305 1
a3305 1
	    return false;
d3346 1
a3346 1
    return false;
d3349 1
a3349 1
  return true;
d3356 1
a3356 1
static boolean
d3402 1
a3402 1
	return false;
d3409 1
a3409 1
	return false;
d3417 1
a3417 1
	return false;
d3425 1
a3425 1
	return false;
d3432 1
a3432 1
	return false;
d3440 1
a3440 1
	return false;
d3488 1
a3488 1
    return false;
d3685 1
a3685 1
    return false;
d3687 1
a3687 1
    return false;
d3699 1
a3699 1
  return true;
d3704 1
a3704 1
static boolean
d3760 1
a3760 1
    return false;
d3781 1
a3781 1
    return false;
d3792 1
a3792 1
    return false;
d3800 1
a3800 1
    return false;
d3850 1
a3850 1
	    return false;
d3906 1
a3906 1
	    return false;
d3919 1
a3919 1
    return false;
d3932 1
a3932 1
	return false;
d3943 1
a3943 1
	return false;
d3947 1
a3947 1
	return false;
d3968 1
a3968 1
    return false;
d3971 1
a3971 1
    return false;
d4000 1
a4000 1
	  return false;
d4005 1
a4005 1
	return false;
d4009 1
a4009 1
	return false;
d4011 1
a4011 1
  return true;
d4146 1
a4146 1
    info->secondary_def = true;
d4148 1
a4148 1
    info->secondary_def = false;
d4155 1
a4155 1
static boolean
d4200 1
a4200 1
    return false;
d4207 1
a4207 1
  return true;
d4211 1
a4211 1
  return false;
d4216 1
a4216 1
static boolean
d4225 1
a4225 1
      abfd->output_has_begun = true;
d4236 1
a4236 1
static boolean
d4245 1
a4245 1
    return true;
d4253 1
a4253 1
      return false;
d4260 1
a4260 1
    return false;
d4263 1
a4263 1
    return false;
d4266 1
a4266 1
    return false;
d4270 1
a4270 1
  return true;
d4501 1
a4501 1
         we can not include it as part of the for statement.  */
d4514 1
a4514 1
  return (true);
d4519 1
a4519 1
  return false;
d4593 1
a4593 1
static boolean
d4621 1
a4621 1
     boolean just_count;
d4911 1
a4911 1
		         bother saving the contents (yet).  Add it one
d4955 1
a4955 1
   set to true to indicate it only needs a count of the number
d4958 1
a4958 1
static boolean
d4963 1
a4963 1
     boolean just_count;
d4974 1
a4974 1
    return true;
d4983 1
a4983 1
	return false;
d4989 1
a4989 1
	return false;
d4991 1
a4991 1
	return false;
d4998 1
a4998 1
						 NULL, NULL, NULL, true);
d5005 1
a5005 1
    return true;
d5011 1
a5011 1
    return true;
d5017 1
a5017 1
    return false;
d5021 1
a5021 1
		      internal_relocs, section, symbols, false);
d5029 1
a5029 1
  return (true);
d5044 1
a5044 1
      if (! som_slurp_reloc_table (abfd, asect, NULL, true))
d5065 1
a5065 1
  if (! som_slurp_reloc_table (abfd, section, symbols, false))
d5082 1
a5082 1
static boolean
d5090 1
a5090 1
    return false;
d5094 1
a5094 1
  return true;
d5100 1
a5100 1
static boolean
d5113 1
a5113 1
    return false;
d5120 1
a5120 1
  return true;
d5126 1
a5126 1
static boolean
d5139 1
a5139 1
    return true;
d5145 1
a5145 1
    return false;
d5156 1
a5156 1
  return true;
d5162 1
a5162 1
static boolean
d5169 1
a5169 1
    return true;
d5175 1
a5175 1
    return false;
d5181 1
a5181 1
  return true;
d5187 1
a5187 1
boolean
d5203 1
a5203 1
	return false;
d5210 1
a5210 1
  return true;
d5216 1
a5216 1
boolean
d5233 1
a5233 1
	return false;
d5239 1
a5239 1
  return true;
d5259 1
a5259 1
boolean
d5278 1
a5278 1
	return false;
d5296 1
a5296 1
	return false;
d5303 1
a5303 1
  return true;
d5309 1
a5309 1
boolean
d5320 1
a5320 1
    return false;
d5327 1
a5327 1
	return false; \
d5340 1
a5340 1
  return true;
d5343 1
a5343 1
static boolean
d5352 1
a5352 1
    return true;
d5356 2
a5357 2
    return (false); /* on error */
  return (true);
d5360 1
a5360 1
static boolean
d5373 1
a5373 1
      abfd->output_has_begun = true;
d5383 1
a5383 1
    return true;
d5389 1
a5389 1
    return false;
d5392 2
a5393 2
    return false;
  return true;
d5396 1
a5396 1
static boolean
d5406 1
a5406 1
static boolean
d5417 1
a5417 1
  return (false);
d5423 1
a5423 1
     boolean reloc ATTRIBUTE_UNUSED;
d5428 1
a5428 1
  return (0);
d5495 1
a5495 1
static boolean
d5560 1
a5560 1
  return true;
d5565 1
a5565 1
  return false;
d5571 1
a5571 1
static boolean
d5701 1
a5701 1
  return true;
d5708 1
a5708 1
  return false;
d5713 1
a5713 1
static boolean
d5727 1
a5727 1
    return true;
d5729 1
a5729 1
    return false;
d5732 1
a5732 1
    return false;
d5737 2
a5738 2
      bfd_has_map (abfd) = false;
      return true;
d5744 1
a5744 1
    return false;
d5749 1
a5749 1
      return false;
d5758 1
a5758 1
      return false;
d5768 1
a5768 1
    return false;
d5774 1
a5774 1
      return false;
d5779 1
a5779 1
    return false;
d5784 1
a5784 1
    return false;
d5792 1
a5792 1
    return false;
d5796 1
a5796 1
    return false;
d5801 1
a5801 1
    return false;
d5804 2
a5805 2
  bfd_has_map (abfd) = true;
  return true;
d5813 1
a5813 1
static boolean
d5842 1
a5842 1
	return false;
d5881 1
a5881 1
  return true;
d5904 1
a5904 1
static boolean
d6141 1
a6141 1
  return true;
d6155 1
a6155 1
  return false;
d6162 1
a6162 1
static boolean
d6182 1
a6182 1
      return false;
d6233 1
a6233 1
    return false;
d6271 1
a6271 1
    return false;
d6276 1
a6276 1
    return false;
d6280 1
a6280 1
    return false;
d6283 1
a6283 1
  return true;
d6289 1
a6289 1
static boolean
d6296 1
a6296 1
    return true;
d6312 1
a6312 1
  return true;
d6319 1
a6319 1
static boolean
d6340 1
a6340 1
#define som_get_lineno                  _bfd_nosymbols_get_lineno
@


1.33.14.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d41 1
a41 1
/* Magic not defined in standard HP-UX header files until 8.0.  */
d151 1
a151 1
/* Forward declarations.  */
d153 29
a181 39
static bfd_boolean som_mkobject
  PARAMS ((bfd *));
static const bfd_target * som_object_setup
  PARAMS ((bfd *, struct header *, struct som_exec_auxhdr *, unsigned long));
static bfd_boolean setup_sections
  PARAMS ((bfd *, struct header *, unsigned long));
static const bfd_target * som_object_p
  PARAMS ((bfd *));
static bfd_boolean som_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean som_slurp_string_table
  PARAMS ((bfd *));
static unsigned int som_slurp_symbol_table
  PARAMS ((bfd *));
static long som_get_symtab_upper_bound
  PARAMS ((bfd *));
static long som_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
static long som_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static unsigned int som_set_reloc_info
  PARAMS ((unsigned char *, unsigned int, arelent *, asection *,
	   asymbol **, bfd_boolean));
static bfd_boolean som_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
static long som_canonicalize_symtab
  PARAMS ((bfd *, asymbol **));
static asymbol * som_make_empty_symbol
  PARAMS ((bfd *));
static void som_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean som_new_section_hook
  PARAMS ((bfd *, asection *));
static bfd_boolean som_bfd_copy_private_symbol_data
  PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
static bfd_boolean som_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));
static bfd_boolean som_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
d184 59
a242 67
static bfd_boolean som_bfd_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean som_set_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean som_get_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean som_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static bfd_boolean som_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static void som_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static asection * bfd_section_from_som_symbol
  PARAMS ((bfd *, struct symbol_dictionary_record *));
static int log2
  PARAMS ((unsigned int));
static bfd_reloc_status_type hppa_som_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void som_initialize_reloc_queue
  PARAMS ((struct reloc_queue *));
static void som_reloc_queue_insert
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static void som_reloc_queue_fix
  PARAMS ((struct reloc_queue *, unsigned int));
static int som_reloc_queue_find
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static unsigned char * try_prev_fixup
  PARAMS ((bfd *, int *, unsigned char *, unsigned int, struct reloc_queue *));
static unsigned char * som_reloc_skip
  PARAMS ((bfd *, unsigned int, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_addend
  PARAMS ((bfd *, bfd_vma, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_call
  PARAMS ((bfd *, unsigned char *, unsigned int *, arelent *, int,
	   struct reloc_queue *));
static unsigned long som_count_spaces
  PARAMS ((bfd *));
static unsigned long som_count_subspaces
  PARAMS ((bfd *));
static int compare_syms
  PARAMS ((const void *, const void *));
static int compare_subspaces
  PARAMS ((const void *, const void *));
static unsigned long som_compute_checksum
  PARAMS ((bfd *));
static bfd_boolean som_prep_headers
  PARAMS ((bfd *));
static int som_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean som_finish_writing
  PARAMS ((bfd *));
static bfd_boolean som_build_and_write_symbol_table
  PARAMS ((bfd *));
static void som_prep_for_fixups
  PARAMS ((bfd *, asymbol **, unsigned long));
static bfd_boolean som_write_fixups
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_space_strings
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_symbol_strings
  PARAMS ((bfd *, unsigned long, asymbol **, unsigned int, unsigned *,
	   COMPUNIT *));
static bfd_boolean som_begin_writing
  PARAMS ((bfd *));
d244 25
a268 32
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static char som_section_type
  PARAMS ((const char *));
static int som_decode_symclass
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_count_ar_symbols
  PARAMS ((bfd *, struct lst_header *, symindex *));
static bfd_boolean som_bfd_fill_in_ar_symbols
  PARAMS ((bfd *, struct lst_header *, carsym **));
static bfd_boolean som_slurp_armap
  PARAMS ((bfd *));
static bfd_boolean som_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static void som_bfd_derive_misc_symbol_info
  PARAMS ((bfd *, asymbol *, struct som_misc_symbol_info *));
static bfd_boolean som_bfd_prep_for_ar_write
  PARAMS ((bfd *, unsigned int *, unsigned int *));
static unsigned int som_bfd_ar_symbol_hash
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_ar_write_symbol_stuff
  PARAMS ((bfd *, unsigned int, unsigned int, struct lst_header,
	   unsigned int));
static bfd_boolean som_is_space
  PARAMS ((asection *));
static bfd_boolean som_is_subspace
  PARAMS ((asection *));
static bfd_boolean som_is_container
  PARAMS ((asection *, asection *));
static bfd_boolean som_bfd_free_cached_info
  PARAMS ((bfd *));
static bfd_boolean som_bfd_link_split_section
  PARAMS ((bfd *, asection *));
d635 1
a635 1
  {  0,"Sd=Ve=Ee=" },	       /* 0xcf */
d660 1
a660 1
  {  0, "Ob=Vf=" },		/* 0xdd */
d781 1
a781 1
  HOWTO(TYPE, 0, 0, 32, FALSE, 0, 0, hppa_som_reloc, NAME, FALSE, 0, 0, FALSE)
d1693 1
a1693 1
	   will be eliminated as the relocs are sized and emitted.  */
d1845 1
a1845 1
static bfd_boolean
d1934 1
a1934 1
	 record.  */
d2069 1
a2069 1
	 empty subspaces.  */
d2117 1
a2117 1
  return TRUE;
d2125 1
a2125 1
  return FALSE;
d2272 1
a2272 1
static bfd_boolean
d2280 2
a2281 2
    return FALSE;
  return TRUE;
d2288 1
a2288 1
static bfd_boolean
d2299 1
a2299 1
    return FALSE;
d2304 1
d2310 1
a2310 1
	return FALSE;
d2354 1
a2354 1
	    return FALSE;
d2377 1
a2377 1
	    return FALSE;
d2412 1
a2412 1
  return TRUE;
d2415 1
a2415 1
/* Return TRUE if the given section is a SOM space, FALSE otherwise.  */
d2417 1
a2417 1
static bfd_boolean
d2424 1
a2424 1
    return FALSE;
d2431 1
a2431 1
    return FALSE;
d2434 1
a2434 1
  return TRUE;
d2437 1
a2437 1
/* Return TRUE if the given section is a SOM subspace, FALSE otherwise.  */
d2439 1
a2439 1
static bfd_boolean
d2446 1
a2446 1
    return FALSE;
d2453 1
a2453 1
    return FALSE;
d2456 1
a2456 1
  return TRUE;
d2459 1
a2459 1
/* Return TRUE if the given space contains the given subspace.  It
d2463 1
a2463 1
static bfd_boolean
d2661 1
a2661 1
static bfd_boolean
d2713 1
a2713 1
	     finished with it.  */
d2731 1
a2731 1
	    return FALSE;
d2770 1
a2770 1
		    return FALSE;
d3031 2
a3032 2
	  p = som_reloc_skip (abfd, (bfd_section_size (abfd, subsection)
				     - reloc_offset),
d3038 1
a3038 1
	    return FALSE;
d3048 1
a3048 1
  return TRUE;
d3053 1
a3053 1
static bfd_boolean
d3071 1
a3071 1
    return FALSE;
d3088 3
a3090 3
	 current buffer contents now and maybe allocate a larger
	 buffer.  Each entry will take 4 bytes to hold the string
	 length + the string itself + null terminator.  */
d3096 1
a3096 1
	    return FALSE;
d3102 7
a3108 7
		 consumption for n strings.  The optimal minimum
		 factor seems to be 2, as no other value can guarantee
		 wasting less than 50% space.  (Note that we cannot
		 deallocate space allocated by `alloca' without
		 returning from this function.)  The same technique is
		 used a few more times below when a buffer is
		 reallocated.  */
d3147 1
a3147 1
    return FALSE;
d3149 1
a3149 1
  return TRUE;
d3154 1
a3154 1
static bfd_boolean
d3179 1
a3179 1
     write them and update the compilation unit header.  On input, the
d3193 1
a3193 1
    return FALSE;
d3209 1
a3209 1
		return FALSE;
d3220 1
a3220 1
		 space.  */
d3278 1
a3278 1
	    return FALSE;
d3319 1
a3319 1
    return FALSE;
d3322 1
a3322 1
  return TRUE;
d3329 1
a3329 1
static bfd_boolean
d3375 1
a3375 1
	return FALSE;
d3382 1
a3382 1
	return FALSE;
d3390 1
a3390 1
	return FALSE;
d3398 1
a3398 1
	return FALSE;
d3405 1
a3405 1
	return FALSE;
d3413 1
a3413 1
	return FALSE;
d3461 1
a3461 1
    return FALSE;
d3658 1
a3658 1
    return FALSE;
d3660 1
a3660 1
    return FALSE;
d3672 1
a3672 1
  return TRUE;
d3677 1
a3677 1
static bfd_boolean
d3733 1
a3733 1
    return FALSE;
d3754 1
a3754 1
    return FALSE;
d3765 1
a3765 1
    return FALSE;
d3773 1
a3773 1
    return FALSE;
d3823 1
a3823 1
	    return FALSE;
d3879 1
a3879 1
	    return FALSE;
d3885 1
a3885 1
  /* All the subspace dictionary records are written, and all the
d3892 1
a3892 1
    return FALSE;
d3905 1
a3905 1
	return FALSE;
d3916 1
a3916 1
	return FALSE;
d3920 1
a3920 1
	return FALSE;
d3941 1
a3941 1
    return FALSE;
d3944 1
a3944 1
    return FALSE;
d3957 1
a3957 1
	 to be compatible with how the hp linker makes objects
d3973 1
a3973 1
	  return FALSE;
d3978 1
a3978 1
	return FALSE;
d3982 1
a3982 1
	return FALSE;
d3984 1
a3984 1
  return TRUE;
d4119 1
a4119 1
    info->secondary_def = TRUE;
d4121 1
a4121 1
    info->secondary_def = FALSE;
d4128 1
a4128 1
static bfd_boolean
d4173 1
a4173 1
    return FALSE;
d4180 1
a4180 1
  return TRUE;
d4184 1
a4184 1
  return FALSE;
d4189 1
a4189 1
static bfd_boolean
d4198 1
a4198 1
      abfd->output_has_begun = TRUE;
d4209 1
a4209 1
static bfd_boolean
d4218 1
a4218 1
    return TRUE;
d4226 1
a4226 1
      return FALSE;
d4233 1
a4233 1
    return FALSE;
d4236 1
a4236 1
    return FALSE;
d4239 1
a4239 1
    return FALSE;
d4243 1
a4243 1
  return TRUE;
d4474 1
a4474 1
	 we can not include it as part of the for statement.  */
d4487 1
a4487 1
  return (TRUE);
d4492 1
a4492 1
  return FALSE;
d4499 1
a4499 1
som_canonicalize_symtab (abfd, location)
d4566 1
a4566 1
static bfd_boolean
d4594 1
a4594 1
     bfd_boolean just_count;
d4884 1
a4884 1
			 bother saving the contents (yet).  Add it one
d4928 1
a4928 1
   set to TRUE to indicate it only needs a count of the number
d4931 1
a4931 1
static bfd_boolean
d4936 1
a4936 1
     bfd_boolean just_count;
d4947 1
a4947 1
    return TRUE;
d4956 1
a4956 1
	return FALSE;
d4962 1
a4962 1
	return FALSE;
d4964 1
a4964 1
	return FALSE;
d4971 1
a4971 1
						 NULL, NULL, NULL, TRUE);
d4978 1
a4978 1
    return TRUE;
d4984 1
a4984 1
    return TRUE;
d4990 1
a4990 1
    return FALSE;
d4994 1
a4994 1
		      internal_relocs, section, symbols, FALSE);
d5002 1
a5002 1
  return TRUE;
d5017 1
a5017 1
      if (! som_slurp_reloc_table (abfd, asect, NULL, TRUE))
d5038 1
a5038 1
  if (! som_slurp_reloc_table (abfd, section, symbols, FALSE))
d5055 1
a5055 1
static bfd_boolean
d5063 1
a5063 1
    return FALSE;
d5067 1
a5067 1
  return TRUE;
d5073 1
a5073 1
static bfd_boolean
d5086 1
a5086 1
    return FALSE;
d5093 1
a5093 1
  return TRUE;
d5099 1
a5099 1
static bfd_boolean
d5112 1
a5112 1
    return TRUE;
d5118 1
a5118 1
    return FALSE;
d5129 1
a5129 1
  return TRUE;
d5135 1
a5135 1
static bfd_boolean
d5142 1
a5142 1
    return TRUE;
d5148 1
a5148 1
    return FALSE;
d5154 1
a5154 1
  return TRUE;
d5160 1
a5160 1
bfd_boolean
d5176 1
a5176 1
	return FALSE;
d5183 1
a5183 1
  return TRUE;
d5189 1
a5189 1
bfd_boolean
d5206 1
a5206 1
	return FALSE;
d5212 1
a5212 1
  return TRUE;
d5232 1
a5232 1
bfd_boolean
d5251 1
a5251 1
	return FALSE;
d5269 1
a5269 1
	return FALSE;
d5276 1
a5276 1
  return TRUE;
d5279 1
a5279 1
/* Attach a compilation unit header to the BFD backend so that it may be
d5282 1
a5282 1
bfd_boolean
d5293 1
a5293 1
    return FALSE;
d5300 1
a5300 1
	return FALSE; \
d5313 1
a5313 1
  return TRUE;
d5316 1
a5316 1
static bfd_boolean
d5325 1
a5325 1
    return TRUE;
d5329 2
a5330 2
    return FALSE; /* On error.  */
  return TRUE;
d5333 1
a5333 1
static bfd_boolean
d5346 1
a5346 1
      abfd->output_has_begun = TRUE;
d5356 1
a5356 1
    return TRUE;
d5362 1
a5362 1
    return FALSE;
d5365 2
a5366 2
    return FALSE;
  return TRUE;
d5369 1
a5369 1
static bfd_boolean
d5379 1
a5379 1
static bfd_boolean
d5390 1
a5390 1
  return FALSE;
d5396 1
a5396 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d5401 1
a5401 1
  return 0;
d5468 1
a5468 1
static bfd_boolean
d5533 1
a5533 1
  return TRUE;
d5538 1
a5538 1
  return FALSE;
d5544 1
a5544 1
static bfd_boolean
d5674 1
a5674 1
  return TRUE;
d5681 1
a5681 1
  return FALSE;
d5686 1
a5686 1
static bfd_boolean
d5700 1
a5700 1
    return TRUE;
d5702 1
a5702 1
    return FALSE;
d5705 1
a5705 1
    return FALSE;
d5710 2
a5711 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d5717 1
a5717 1
    return FALSE;
d5722 1
a5722 1
      return FALSE;
d5731 1
a5731 1
      return FALSE;
d5741 1
a5741 1
    return FALSE;
d5747 1
a5747 1
      return FALSE;
d5752 1
a5752 1
    return FALSE;
d5757 1
a5757 1
    return FALSE;
d5759 1
a5759 1
  /* Initialize the cache and allocate space for the library symbols.  */
d5765 1
a5765 1
    return FALSE;
d5769 1
a5769 1
    return FALSE;
d5774 1
a5774 1
    return FALSE;
d5777 2
a5778 2
  bfd_has_map (abfd) = TRUE;
  return TRUE;
d5786 1
a5786 1
static bfd_boolean
d5815 1
a5815 1
	return FALSE;
d5854 1
a5854 1
  return TRUE;
d5877 1
a5877 1
static bfd_boolean
d6114 1
a6114 1
  return TRUE;
d6128 1
a6128 1
  return FALSE;
d6135 1
a6135 1
static bfd_boolean
d6155 1
a6155 1
      return FALSE;
d6206 1
a6206 1
    return FALSE;
d6244 1
a6244 1
    return FALSE;
d6249 1
a6249 1
    return FALSE;
d6253 1
a6253 1
    return FALSE;
d6256 1
a6256 1
  return TRUE;
d6262 1
a6262 1
static bfd_boolean
d6269 1
a6269 1
    return TRUE;
d6285 1
a6285 1
  return TRUE;
d6292 1
a6292 1
static bfd_boolean
d6313 1
a6313 1
#define som_get_lineno			_bfd_nosymbols_get_lineno
d6345 1
a6345 1
   predictable, and if so what is it.  */
@


1.33.12.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d153 29
a181 39
static bfd_boolean som_mkobject
  PARAMS ((bfd *));
static const bfd_target * som_object_setup
  PARAMS ((bfd *, struct header *, struct som_exec_auxhdr *, unsigned long));
static bfd_boolean setup_sections
  PARAMS ((bfd *, struct header *, unsigned long));
static const bfd_target * som_object_p
  PARAMS ((bfd *));
static bfd_boolean som_write_object_contents
  PARAMS ((bfd *));
static bfd_boolean som_slurp_string_table
  PARAMS ((bfd *));
static unsigned int som_slurp_symbol_table
  PARAMS ((bfd *));
static long som_get_symtab_upper_bound
  PARAMS ((bfd *));
static long som_canonicalize_reloc
  PARAMS ((bfd *, sec_ptr, arelent **, asymbol **));
static long som_get_reloc_upper_bound
  PARAMS ((bfd *, sec_ptr));
static unsigned int som_set_reloc_info
  PARAMS ((unsigned char *, unsigned int, arelent *, asection *,
	   asymbol **, bfd_boolean));
static bfd_boolean som_slurp_reloc_table
  PARAMS ((bfd *, asection *, asymbol **, bfd_boolean));
static long som_get_symtab
  PARAMS ((bfd *, asymbol **));
static asymbol * som_make_empty_symbol
  PARAMS ((bfd *));
static void som_print_symbol
  PARAMS ((bfd *, PTR, asymbol *, bfd_print_symbol_type));
static bfd_boolean som_new_section_hook
  PARAMS ((bfd *, asection *));
static bfd_boolean som_bfd_copy_private_symbol_data
  PARAMS ((bfd *, asymbol *, bfd *, asymbol *));
static bfd_boolean som_bfd_copy_private_section_data
  PARAMS ((bfd *, asection *, bfd *, asection *));
static bfd_boolean som_bfd_copy_private_bfd_data
  PARAMS ((bfd *, bfd *));
d184 59
a242 68
static bfd_boolean som_bfd_is_local_label_name
  PARAMS ((bfd *, const char *));
static bfd_boolean som_set_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean som_get_section_contents
  PARAMS ((bfd *, sec_ptr, PTR, file_ptr, bfd_size_type));
static bfd_boolean som_set_arch_mach
  PARAMS ((bfd *, enum bfd_architecture, unsigned long));
static bfd_boolean som_find_nearest_line
  PARAMS ((bfd *, asection *, asymbol **, bfd_vma, const char **,
	   const char **, unsigned int *));
static void som_get_symbol_info
  PARAMS ((bfd *, asymbol *, symbol_info *));
static asection * bfd_section_from_som_symbol
  PARAMS ((bfd *, struct symbol_dictionary_record *));
static int log2
  PARAMS ((unsigned int));
static bfd_reloc_status_type hppa_som_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static void som_initialize_reloc_queue
  PARAMS ((struct reloc_queue *));
static void som_reloc_queue_insert
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static void som_reloc_queue_fix
  PARAMS ((struct reloc_queue *, unsigned int));
static int som_reloc_queue_find
  PARAMS ((unsigned char *, unsigned int, struct reloc_queue *));
static unsigned char * try_prev_fixup
  PARAMS ((bfd *, int *, unsigned char *, unsigned int, struct reloc_queue *));

static unsigned char * som_reloc_skip
  PARAMS ((bfd *, unsigned int, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_addend
  PARAMS ((bfd *, bfd_vma, unsigned char *, unsigned int *,
	   struct reloc_queue *));
static unsigned char * som_reloc_call
  PARAMS ((bfd *, unsigned char *, unsigned int *, arelent *, int,
	   struct reloc_queue *));
static unsigned long som_count_spaces
  PARAMS ((bfd *));
static unsigned long som_count_subspaces
  PARAMS ((bfd *));
static int compare_syms
  PARAMS ((const void *, const void *));
static int compare_subspaces
  PARAMS ((const void *, const void *));
static unsigned long som_compute_checksum
  PARAMS ((bfd *));
static bfd_boolean som_prep_headers
  PARAMS ((bfd *));
static int som_sizeof_headers
  PARAMS ((bfd *, bfd_boolean));
static bfd_boolean som_finish_writing
  PARAMS ((bfd *));
static bfd_boolean som_build_and_write_symbol_table
  PARAMS ((bfd *));
static void som_prep_for_fixups
  PARAMS ((bfd *, asymbol **, unsigned long));
static bfd_boolean som_write_fixups
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_space_strings
  PARAMS ((bfd *, unsigned long, unsigned int *));
static bfd_boolean som_write_symbol_strings
  PARAMS ((bfd *, unsigned long, asymbol **, unsigned int, unsigned *,
	   COMPUNIT *));
static bfd_boolean som_begin_writing
  PARAMS ((bfd *));
d244 25
a268 33
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static char som_section_type
  PARAMS ((const char *));
static int som_decode_symclass
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_count_ar_symbols
  PARAMS ((bfd *, struct lst_header *, symindex *));

static bfd_boolean som_bfd_fill_in_ar_symbols
  PARAMS ((bfd *, struct lst_header *, carsym **syms));
static bfd_boolean som_slurp_armap
  PARAMS ((bfd *));
static bfd_boolean som_write_armap
  PARAMS ((bfd *, unsigned int, struct orl *, unsigned int, int));
static void som_bfd_derive_misc_symbol_info
  PARAMS ((bfd *, asymbol *, struct som_misc_symbol_info *));
static bfd_boolean som_bfd_prep_for_ar_write
  PARAMS ((bfd *, unsigned int *, unsigned int *));
static unsigned int som_bfd_ar_symbol_hash
  PARAMS ((asymbol *));
static bfd_boolean som_bfd_ar_write_symbol_stuff
  PARAMS ((bfd *, unsigned int, unsigned int, struct lst_header,
	   unsigned int));
static bfd_boolean som_is_space
  PARAMS ((asection *));
static bfd_boolean som_is_subspace
  PARAMS ((asection *));
static bfd_boolean som_is_container
  PARAMS ((asection *, asection *));
static bfd_boolean som_bfd_free_cached_info
  PARAMS ((bfd *));
static bfd_boolean som_bfd_link_split_section
  PARAMS ((bfd *, asection *));
d781 1
a781 1
  HOWTO(TYPE, 0, 0, 32, FALSE, 0, 0, hppa_som_reloc, NAME, FALSE, 0, 0, FALSE)
d1845 1
a1845 1
static bfd_boolean
d1934 1
a1934 1
	 record.  */
d2069 1
a2069 1
	 empty subspaces.  */
d2117 1
a2117 1
  return TRUE;
d2125 1
a2125 1
  return FALSE;
d2272 1
a2272 1
static bfd_boolean
d2280 2
a2281 2
    return FALSE;
  return TRUE;
d2288 1
a2288 1
static bfd_boolean
d2299 1
a2299 1
    return FALSE;
d2310 1
a2310 1
	return FALSE;
d2354 1
a2354 1
	    return FALSE;
d2377 1
a2377 1
	    return FALSE;
d2412 1
a2412 1
  return TRUE;
d2415 1
a2415 1
/* Return TRUE if the given section is a SOM space, FALSE otherwise.  */
d2417 1
a2417 1
static bfd_boolean
d2424 1
a2424 1
    return FALSE;
d2431 1
a2431 1
    return FALSE;
d2434 1
a2434 1
  return TRUE;
d2437 1
a2437 1
/* Return TRUE if the given section is a SOM subspace, FALSE otherwise.  */
d2439 1
a2439 1
static bfd_boolean
d2446 1
a2446 1
    return FALSE;
d2453 1
a2453 1
    return FALSE;
d2456 1
a2456 1
  return TRUE;
d2459 1
a2459 1
/* Return TRUE if the given space containins the given subspace.  It
d2463 1
a2463 1
static bfd_boolean
d2661 1
a2661 1
static bfd_boolean
d2731 1
a2731 1
	    return FALSE;
d2770 1
a2770 1
		    return FALSE;
d3031 2
a3032 2
	  p = som_reloc_skip (abfd, (bfd_section_size (abfd, subsection)
				     - reloc_offset),
d3038 1
a3038 1
	    return FALSE;
d3048 1
a3048 1
  return TRUE;
d3053 1
a3053 1
static bfd_boolean
d3071 1
a3071 1
    return FALSE;
d3088 3
a3090 3
	 current buffer contents now and maybe allocate a larger
	 buffer.  Each entry will take 4 bytes to hold the string
	 length + the string itself + null terminator.  */
d3096 1
a3096 1
	    return FALSE;
d3102 7
a3108 7
		 consumption for n strings.  The optimal minimum
		 factor seems to be 2, as no other value can guarantee
		 wasting less than 50% space.  (Note that we cannot
		 deallocate space allocated by `alloca' without
		 returning from this function.)  The same technique is
		 used a few more times below when a buffer is
		 reallocated.  */
d3147 1
a3147 1
    return FALSE;
d3149 1
a3149 1
  return TRUE;
d3154 1
a3154 1
static bfd_boolean
d3193 1
a3193 1
    return FALSE;
d3209 1
a3209 1
		return FALSE;
d3220 1
a3220 1
		 space.  */
d3278 1
a3278 1
	    return FALSE;
d3319 1
a3319 1
    return FALSE;
d3322 1
a3322 1
  return TRUE;
d3329 1
a3329 1
static bfd_boolean
d3375 1
a3375 1
	return FALSE;
d3382 1
a3382 1
	return FALSE;
d3390 1
a3390 1
	return FALSE;
d3398 1
a3398 1
	return FALSE;
d3405 1
a3405 1
	return FALSE;
d3413 1
a3413 1
	return FALSE;
d3461 1
a3461 1
    return FALSE;
d3658 1
a3658 1
    return FALSE;
d3660 1
a3660 1
    return FALSE;
d3672 1
a3672 1
  return TRUE;
d3677 1
a3677 1
static bfd_boolean
d3733 1
a3733 1
    return FALSE;
d3754 1
a3754 1
    return FALSE;
d3765 1
a3765 1
    return FALSE;
d3773 1
a3773 1
    return FALSE;
d3823 1
a3823 1
	    return FALSE;
d3879 1
a3879 1
	    return FALSE;
d3892 1
a3892 1
    return FALSE;
d3905 1
a3905 1
	return FALSE;
d3916 1
a3916 1
	return FALSE;
d3920 1
a3920 1
	return FALSE;
d3941 1
a3941 1
    return FALSE;
d3944 1
a3944 1
    return FALSE;
d3973 1
a3973 1
	  return FALSE;
d3978 1
a3978 1
	return FALSE;
d3982 1
a3982 1
	return FALSE;
d3984 1
a3984 1
  return TRUE;
d4119 1
a4119 1
    info->secondary_def = TRUE;
d4121 1
a4121 1
    info->secondary_def = FALSE;
d4128 1
a4128 1
static bfd_boolean
d4173 1
a4173 1
    return FALSE;
d4180 1
a4180 1
  return TRUE;
d4184 1
a4184 1
  return FALSE;
d4189 1
a4189 1
static bfd_boolean
d4198 1
a4198 1
      abfd->output_has_begun = TRUE;
d4209 1
a4209 1
static bfd_boolean
d4218 1
a4218 1
    return TRUE;
d4226 1
a4226 1
      return FALSE;
d4233 1
a4233 1
    return FALSE;
d4236 1
a4236 1
    return FALSE;
d4239 1
a4239 1
    return FALSE;
d4243 1
a4243 1
  return TRUE;
d4474 1
a4474 1
	 we can not include it as part of the for statement.  */
d4487 1
a4487 1
  return (TRUE);
d4492 1
a4492 1
  return FALSE;
d4566 1
a4566 1
static bfd_boolean
d4594 1
a4594 1
     bfd_boolean just_count;
d4884 1
a4884 1
			 bother saving the contents (yet).  Add it one
d4928 1
a4928 1
   set to TRUE to indicate it only needs a count of the number
d4931 1
a4931 1
static bfd_boolean
d4936 1
a4936 1
     bfd_boolean just_count;
d4947 1
a4947 1
    return TRUE;
d4956 1
a4956 1
	return FALSE;
d4962 1
a4962 1
	return FALSE;
d4964 1
a4964 1
	return FALSE;
d4971 1
a4971 1
						 NULL, NULL, NULL, TRUE);
d4978 1
a4978 1
    return TRUE;
d4984 1
a4984 1
    return TRUE;
d4990 1
a4990 1
    return FALSE;
d4994 1
a4994 1
		      internal_relocs, section, symbols, FALSE);
d5002 1
a5002 1
  return TRUE;
d5017 1
a5017 1
      if (! som_slurp_reloc_table (abfd, asect, NULL, TRUE))
d5038 1
a5038 1
  if (! som_slurp_reloc_table (abfd, section, symbols, FALSE))
d5055 1
a5055 1
static bfd_boolean
d5063 1
a5063 1
    return FALSE;
d5067 1
a5067 1
  return TRUE;
d5073 1
a5073 1
static bfd_boolean
d5086 1
a5086 1
    return FALSE;
d5093 1
a5093 1
  return TRUE;
d5099 1
a5099 1
static bfd_boolean
d5112 1
a5112 1
    return TRUE;
d5118 1
a5118 1
    return FALSE;
d5129 1
a5129 1
  return TRUE;
d5135 1
a5135 1
static bfd_boolean
d5142 1
a5142 1
    return TRUE;
d5148 1
a5148 1
    return FALSE;
d5154 1
a5154 1
  return TRUE;
d5160 1
a5160 1
bfd_boolean
d5176 1
a5176 1
	return FALSE;
d5183 1
a5183 1
  return TRUE;
d5189 1
a5189 1
bfd_boolean
d5206 1
a5206 1
	return FALSE;
d5212 1
a5212 1
  return TRUE;
d5232 1
a5232 1
bfd_boolean
d5251 1
a5251 1
	return FALSE;
d5269 1
a5269 1
	return FALSE;
d5276 1
a5276 1
  return TRUE;
d5279 1
a5279 1
/* Attach a compilation unit header to the BFD backend so that it may be
d5282 1
a5282 1
bfd_boolean
d5293 1
a5293 1
    return FALSE;
d5300 1
a5300 1
	return FALSE; \
d5313 1
a5313 1
  return TRUE;
d5316 1
a5316 1
static bfd_boolean
d5325 1
a5325 1
    return TRUE;
d5329 2
a5330 2
    return FALSE; /* on error */
  return TRUE;
d5333 1
a5333 1
static bfd_boolean
d5346 1
a5346 1
      abfd->output_has_begun = TRUE;
d5356 1
a5356 1
    return TRUE;
d5362 1
a5362 1
    return FALSE;
d5365 2
a5366 2
    return FALSE;
  return TRUE;
d5369 1
a5369 1
static bfd_boolean
d5379 1
a5379 1
static bfd_boolean
d5390 1
a5390 1
  return FALSE;
d5396 1
a5396 1
     bfd_boolean reloc ATTRIBUTE_UNUSED;
d5401 1
a5401 1
  return 0;
d5468 1
a5468 1
static bfd_boolean
d5533 1
a5533 1
  return TRUE;
d5538 1
a5538 1
  return FALSE;
d5544 1
a5544 1
static bfd_boolean
d5674 1
a5674 1
  return TRUE;
d5681 1
a5681 1
  return FALSE;
d5686 1
a5686 1
static bfd_boolean
d5700 1
a5700 1
    return TRUE;
d5702 1
a5702 1
    return FALSE;
d5705 1
a5705 1
    return FALSE;
d5710 2
a5711 2
      bfd_has_map (abfd) = FALSE;
      return TRUE;
d5717 1
a5717 1
    return FALSE;
d5722 1
a5722 1
      return FALSE;
d5731 1
a5731 1
      return FALSE;
d5741 1
a5741 1
    return FALSE;
d5747 1
a5747 1
      return FALSE;
d5752 1
a5752 1
    return FALSE;
d5757 1
a5757 1
    return FALSE;
d5765 1
a5765 1
    return FALSE;
d5769 1
a5769 1
    return FALSE;
d5774 1
a5774 1
    return FALSE;
d5777 2
a5778 2
  bfd_has_map (abfd) = TRUE;
  return TRUE;
d5786 1
a5786 1
static bfd_boolean
d5815 1
a5815 1
	return FALSE;
d5854 1
a5854 1
  return TRUE;
d5877 1
a5877 1
static bfd_boolean
d6114 1
a6114 1
  return TRUE;
d6128 1
a6128 1
  return FALSE;
d6135 1
a6135 1
static bfd_boolean
d6155 1
a6155 1
      return FALSE;
d6206 1
a6206 1
    return FALSE;
d6244 1
a6244 1
    return FALSE;
d6249 1
a6249 1
    return FALSE;
d6253 1
a6253 1
    return FALSE;
d6256 1
a6256 1
  return TRUE;
d6262 1
a6262 1
static bfd_boolean
d6269 1
a6269 1
    return TRUE;
d6285 1
a6285 1
  return TRUE;
d6292 1
a6292 1
static bfd_boolean
d6313 1
a6313 1
#define som_get_lineno			_bfd_nosymbols_get_lineno
@


1.33.12.2
log
@2003-04-16  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030416-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d41 1
a41 1
/* Magic not defined in standard HP-UX header files until 8.0.  */
d151 1
a151 1
/* Forward declarations.  */
d223 1
d270 1
d272 1
a272 1
  PARAMS ((bfd *, struct lst_header *, carsym **));
d662 1
a662 1
  {  0,"Sd=Ve=Ee=" },	       /* 0xcf */
d687 1
a687 1
  {  0, "Ob=Vf=" },		/* 0xdd */
d2331 1
d5356 1
a5356 1
    return FALSE; /* On error.  */
d6372 1
a6372 1
   predictable, and if so what is it.  */
@


1.33.12.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d178 1
a178 1
static long som_canonicalize_symtab
d4523 1
a4523 1
som_canonicalize_symtab (abfd, location)
@


1.33.12.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d1718 1
a1718 1
	   will be eliminated as the relocs are sized and emitted.  */
d2483 1
a2483 1
/* Return TRUE if the given space contains the given subspace.  It
d2737 1
a2737 1
	     finished with it.  */
d3203 1
a3203 1
     write them and update the compilation unit header.  On input, the
d3909 1
a3909 1
  /* All the subspace dictionary records are written, and all the
d3981 1
a3981 1
	 to be compatible with how the hp linker makes objects
d5783 1
a5783 1
  /* Initialize the cache and allocate space for the library symbols.  */
@


1.32
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d1743 1
a1743 1
  if (som_mkobject (abfd) != true)
d1908 3
a1910 3
      if (bfd_som_set_section_attributes (space_asect, space.is_defined,
					  space.is_private, space.sort_key,
					  space.space_number) == false)
d1971 4
a1974 4
	  if (bfd_som_set_subsection_attributes (subspace_asect, space_asect,
						 subspace.access_control_bits,
						 subspace.sort_key,
						 subspace.quadrant) == false)
d3460 1
a3460 1
  if (som_write_space_strings (abfd, current_offset, &strings_size) == false)
d3730 3
a3732 4
  if (som_write_symbol_strings (abfd, current_offset, syms,
				num_syms, &strings_size,
				obj_som_compilation_unit (abfd))
      == false)
d3753 1
a3753 1
  if (som_write_fixups (abfd, current_offset, &total_reloc_size) == false)
d3764 1
a3764 1
  if (som_build_and_write_symbol_table (abfd) == false)
d4193 1
a4193 1
  if (abfd->output_has_begun == false)
d5038 1
a5038 1
  if (som_slurp_reloc_table (abfd, section, symbols, false) == false)
d5341 1
a5341 1
  if (abfd->output_has_begun == false)
d5751 1
a5751 2
  if (som_bfd_count_ar_symbols (abfd, &lst_header, &ardata->symdef_count)
      == false)
d5768 1
a5768 2
  if (som_bfd_fill_in_ar_symbols (abfd, &lst_header, &ardata->symdefs)
      == false)
d5814 1
a5814 1
      if (som_slurp_symbol_table (curr_bfd) == false)
d5969 1
a5969 1
      if (som_slurp_symbol_table (curr_bfd) == false)
d6205 1
a6205 1
  if (som_bfd_prep_for_ar_write (abfd, &nsyms, &stringsize) == false)
@


1.31
log
@	* bfd-in.h: Remove "taken from the source" comment.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.

	* elf.c (bfd_elf_discard_group): Return true.
	* elf-bfd.h (bfd_elf_discard_group): Declare.
	* bfd-in.h (bfd_elf_discard_group): Don't declare here.
	* section.c (bfd_discard_group): Rename to bfd_generic_discard_group.
	* bfd.c (bfd_discard_group): Define.
	* targets.c (struct bfd_target): Add _bfd_discard_group.
	(BFD_JUMP_TABLE_LINK): Here too.
	* libbfd-in.h (_bfd_nolink_bfd_discard_group): Define.
	* aout-adobe.c (aout_32_bfd_discard_group): Define.
	* aout-target.h (MY_bfd_discard_group): Define.
	* aout-tic30.c (MY_bfd_discard_group): Define.
	* binary.c (binary_bfd_discard_group): Define.
	* bout.c (b_out_bfd_discard_group): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_discard_group): Define.
	* coffcode.h (coff_bfd_discard_group): Define.
	* coff-mips.c (_bfd_ecoff_bfd_discard_group): Define.
	* elfxx-target.h (bfd_elfNN_bfd_discard_group): Define.
	* i386msdos.c (msdos_bfd_discard_group): Define.
	* i386os9k.c (os9k_bfd_discard_group): Define.
	* ieee.c (ieee_bfd_discard_group): Define.
	* ihex.c (ihex_bfd_discard_group): Define.
	* mmo.c (mmo_bfd_discard_group): Define.
	* nlm-target.h (nlm_bfd_discard_group): Define.
	* oasys.c (oasys_bfd_discard_group): Define.
	* ppcboot.c (ppcboot_bfd_discard_group): Define.
	* som.c (som_bfd_discard_group): Define.
	* srec.c (srec_bfd_discard_group): Define.
	* tekhex.c (tekhex_bfd_discard_group): Define.
	* versados.c (versados_bfd_discard_group): Define.
	* vms.c (vms_bfd_discard_group): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_discard_group): Define.
	* coff64-rs6000.c (rs6000coff64_vec): Update initialiser.
	(aix5coff64_vec): Likewise.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
@
text
@d4144 1
a4144 1
  som_symtab = (struct symbol_dictionary_record *) bfd_malloc (symtab_size);
a4146 1
  memset (som_symtab, 0, (size_t) symtab_size);
d4232 1
a4232 1
  stringtab = bfd_malloc (amt);
a4234 1
  memset (stringtab, 0, obj_som_stringtab_size (abfd));
d4337 1
a4337 1
  symbase = (som_symbol_type *) bfd_malloc (amt);
a4339 1
  memset (symbase, 0, symbol_count * sizeof (som_symbol_type));
d5899 1
a5899 1
  hash_table = (unsigned int *) bfd_malloc (amt);
d5905 1
a5905 1
  som_dict = (struct som_entry *) bfd_malloc (amt);
d5911 1
a5911 1
  last_hash_entry = ((struct lst_symbol_record **) bfd_malloc (amt));
a5917 6

  /* Some initialization.  */
  memset (hash_table, 0, 4 * lst.hash_size);
  memset (som_dict, 0, lst.module_count * sizeof (struct som_entry));
  memset (last_hash_entry, 0,
	  lst.hash_size * sizeof (struct lst_symbol_record *));
@


1.30
log
@Fix ld --just-symbols
	* aix5ppc-core.c: Warning fixes.
	* aout-adobe.c (aout_32_bfd_link_just_syms): Define.
	* aout-target.h (MY_bfd_link_just_syms): Define.
	* aout-tic30.c (MY_bfd_link_just_syms): Define.
	* bfd.c (bfd_link_just_syms): Define.
	* binary.c (binary_bfd_link_just_syms): Define.
	* bout.c (b_out_bfd_link_just_syms): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Update initializer.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_just_syms): Define.
	* elf-bfd.h (enum elf_link_info_type): Add ELF_INFO_TYPE_JUST_SYMS.
	(elf_discarded_section): Check for ELF_INFO_TYPE_JUST_SYMS.
	(_bfd_elf_link_just_syms): Declare.
	* elf.c (_bfd_elf_link_just_syms): New function.
	* elf-eh-frame.c (_bfd_elf_maybe_strip_eh_frame_hdr): Check that
	sections haven't already been discarded by the linker.
	* elflink.h (elf_link_add_object_symbols): Likewise for stab
	sections and SEC_MERGE sections.
	(elf_bfd_discard_info): Similarly here.
	* elfxx-target.h (bfd_elfNN_bfd_link_just_syms): Define.
	* i386msdos.c (msdos_bfd_link_just_syms): Define.
	* i386os9k.c (os9k_bfd_link_just_syms): Define.
	* ieee.c (ieee_bfd_link_just_syms): Define.
	* ihex.c (ihex_bfd_link_just_syms): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_just_syms): Define.
	(_bfd_generic_link_just_syms): Declare.
	* libecoff.h (_bfd_ecoff_bfd_link_just_syms): Define.
	* linker.c (_bfd_generic_link_just_syms): New function.
	* mmo.c (mmo_bfd_link_just_syms): Define.
	* nlm-target.h (nlm_bfd_link_just_syms): Define.
	* oasys.c (oasys_bfd_link_just_syms): Define.
	* ppcboot.c (ppcboot_bfd_link_just_syms): Define.
	* som.c (som_bfd_link_just_syms): Define.
	* srec.c (srec_bfd_link_just_syms): Define.
	* targets.c (struct bfd_target): Add _bfd_link_just_syms.
	(BFD_JUMP_TABLE_LINK): And here.
	* tekhex.c (tekhex_bfd_link_just_syms): Define.
	* versados.c (versados_bfd_link_just_syms): Define.
	* vms.c (vms_bfd_link_just_syms): Define.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d6343 1
@


1.30.2.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d4144 1
a4144 1
  som_symtab = (struct symbol_dictionary_record *) bfd_zmalloc (symtab_size);
d4147 1
d4233 1
a4233 1
  stringtab = bfd_zmalloc (amt);
d4236 1
d4339 1
a4339 1
  symbase = (som_symbol_type *) bfd_zmalloc (amt);
d4342 1
d5902 1
a5902 1
  hash_table = (unsigned int *) bfd_zmalloc (amt);
d5908 1
a5908 1
  som_dict = (struct som_entry *) bfd_zmalloc (amt);
d5914 1
a5914 1
  last_hash_entry = ((struct lst_symbol_record **) bfd_zmalloc (amt));
d5922 6
a6342 1
#define som_bfd_discard_group		bfd_generic_discard_group
@


1.30.2.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d1743 1
a1743 1
  if (! som_mkobject (abfd))
d1908 3
a1910 3
      if (! bfd_som_set_section_attributes (space_asect, space.is_defined,
					    space.is_private, space.sort_key,
					    space.space_number))
d1971 4
a1974 4
	  if (! bfd_som_set_subsection_attributes (subspace_asect, space_asect,
						   subspace.access_control_bits,
						   subspace.sort_key,
						   subspace.quadrant))
d3460 1
a3460 1
  if (! som_write_space_strings (abfd, current_offset, &strings_size))
d3730 4
a3733 3
  if (! som_write_symbol_strings (abfd, current_offset, syms,
				  num_syms, &strings_size,
				  obj_som_compilation_unit (abfd)))
d3754 1
a3754 1
  if (! som_write_fixups (abfd, current_offset, &total_reloc_size))
d3765 1
a3765 1
  if (! som_build_and_write_symbol_table (abfd))
d4194 1
a4194 1
  if (! abfd->output_has_begun)
d5039 1
a5039 1
  if (! som_slurp_reloc_table (abfd, section, symbols, false))
d5342 1
a5342 1
  if (! abfd->output_has_begun)
d5752 2
a5753 1
  if (! som_bfd_count_ar_symbols (abfd, &lst_header, &ardata->symdef_count))
d5770 2
a5771 1
  if (! som_bfd_fill_in_ar_symbols (abfd, &lst_header, &ardata->symdefs))
d5817 1
a5817 1
      if (! som_slurp_symbol_table (curr_bfd))
d5972 1
a5972 1
      if (! som_slurp_symbol_table (curr_bfd))
d6208 1
a6208 1
  if (! som_bfd_prep_for_ar_write (abfd, &nsyms, &stringsize))
@


1.29
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d6338 1
@


1.29.4.1
log
@merge from trunk
@
text
@d4144 1
a4144 1
  som_symtab = (struct symbol_dictionary_record *) bfd_zmalloc (symtab_size);
d4147 1
d4233 1
a4233 1
  stringtab = bfd_zmalloc (amt);
d4236 1
d4339 1
a4339 1
  symbase = (som_symbol_type *) bfd_zmalloc (amt);
d4342 1
d5902 1
a5902 1
  hash_table = (unsigned int *) bfd_zmalloc (amt);
d5908 1
a5908 1
  som_dict = (struct som_entry *) bfd_zmalloc (amt);
d5914 1
a5914 1
  last_hash_entry = ((struct lst_symbol_record **) bfd_zmalloc (amt));
d5922 6
a6337 1
#define som_bfd_link_just_syms _bfd_generic_link_just_syms
a6341 1
#define som_bfd_discard_group		bfd_generic_discard_group
@


1.28
log
@comment typo fixes
@
text
@d6336 1
@


1.27
log
@Initialize subspace_sections.
@
text
@d3 1
a3 1
   2000, 2001
d3104 1
a3104 1
                 wasting less then 50% space.  (Note that we cannot
@


1.26
log
@	* aout-encap.c: Fix comment typos.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mips.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m32r.c: Likewise.
	* libcoff-in.h: Likewise.
	* libecoff.h: Likewise.
	* libxcoff.h: Likewise.
	* nlm32-i386.c: Likewise.
	* pdp11.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libcoff.h: Likewise.
@
text
@d1854 2
a1855 1
  asection **subspace_sections, *section;
@


1.25
log
@        * som.h (som_exec_data): New field "version_id".
        * som.c (som_object_setup): Record the version_id if it
        exists.
        (som_prep_headers): Do not initialize version_id here.
        (som_finish_writing): Initialize version_id here.
@
text
@d2963 1
a2963 1
		  /* The end of a exception handling region.  The reloc's
@


1.24
log
@	* som.c (som_write_symbol_strings): Cast current_offset in
	bfd_seek call to match param type.
@
text
@d1817 2
a2324 3
  /* Only new format SOM is supported.  */
  file_hdr->version_id = NEW_VERSION_ID;

d3689 8
@


1.23
log
@som_write_symbol_strings: Fix incorrect type of current_offset to match
the function definition. Fixes a build failure on HPUX-11.00.
@
text
@d3192 1
a3192 1
  if (bfd_seek (abfd, current_offset, SEEK_SET) != 0)
@


1.22
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d3158 1
a3158 1
     file_ptr current_offset;
@


1.21
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d34 1
a39 1
#include <ctype.h>
d4675 1
a4675 1
	      if (isupper (c))
d4681 1
a4681 1
	      else if (islower (c))
d4692 1
a4692 1
	      else if (isdigit (c))
d4695 1
a4695 1
		  while (isdigit (*cp))
d5441 1
a5441 1
    c = toupper (c);
@


1.20
log
@2001-08-23  H.J. Lu  <hjl@@gnu.org>

	* syms.c (bfd_print_symbol_vandf): Add abfd to arg.
	* bfd-in2.h (bfd_print_symbol_vandf): Regenerated.

	* aoutx.h (NAME(aout,print_symbol)): Pass abfd to
	bfd_print_symbol_vandf.
	* coffgen.c (coff_print_symbol): Likewise.
	* elf.c (bfd_elf_print_symbol): Likewise.
	* ieee.c (ieee_print_symbol): Likewise.
	* nlmcode.h (nlm_print_symbol): Likewise.
	* oasys.c (oasys_print_symbol): Likewise.
	* pdp11.c (NAME(aout,print_symbol)): Likewise.
	* som.c (som_print_symbol): Likewise.
	* srec.c (srec_print_symbol): Likewise.
	* tekhex.c (tekhex_print_symbol): Likewise.
	* versados.c (versados_print_symbol): Likewise.
	* vms.c (vms_print_symbol): Likewise.

	* elf.c (_bfd_elf_print_private_bfd_data): Replace fprintf_vma
	with bfd_fprintf_vma.
	(bfd_elf_print_symbol): Likewise.
	* syms.c (bfd_print_symbol_vandf): Likewise.
@
text
@d105 1
a105 1
  (((val) + (alignment) - 1) & ~((alignment) - 1))
d193 2
a194 2
					      CONST char **,
					      CONST char **,
d217 2
a218 1
static unsigned char * som_reloc_addend PARAMS ((bfd *, int, unsigned char *,
d387 32
a418 32
  0,   "LD1+4*=",       /* 0x00 */
  1,   "LD1+4*=",	/* 0x01 */
  2,   "LD1+4*=",	/* 0x02 */
  3,   "LD1+4*=",	/* 0x03 */
  4,   "LD1+4*=",	/* 0x04 */
  5,   "LD1+4*=",	/* 0x05 */
  6,   "LD1+4*=",	/* 0x06 */
  7,   "LD1+4*=",	/* 0x07 */
  8,   "LD1+4*=",	/* 0x08 */
  9,   "LD1+4*=",	/* 0x09 */
  10,  "LD1+4*=",	/* 0x0a */
  11,  "LD1+4*=",	/* 0x0b */
  12,  "LD1+4*=",	/* 0x0c */
  13,  "LD1+4*=",	/* 0x0d */
  14,  "LD1+4*=",	/* 0x0e */
  15,  "LD1+4*=",	/* 0x0f */
  16,  "LD1+4*=",	/* 0x10 */
  17,  "LD1+4*=",	/* 0x11 */
  18,  "LD1+4*=",	/* 0x12 */
  19,  "LD1+4*=",	/* 0x13 */
  20,  "LD1+4*=",	/* 0x14 */
  21,  "LD1+4*=",	/* 0x15 */
  22,  "LD1+4*=",	/* 0x16 */
  23,  "LD1+4*=",	/* 0x17 */
  0,   "LD8<b+1+4*=",	/* 0x18 */
  1,   "LD8<b+1+4*=",	/* 0x19 */
  2,   "LD8<b+1+4*=",	/* 0x1a */
  3,   "LD8<b+1+4*=",	/* 0x1b */
  0,   "LD16<c+1+4*=",	/* 0x1c */
  1,   "LD16<c+1+4*=",	/* 0x1d */
  2,   "LD16<c+1+4*=",	/* 0x1e */
  0,   "Ld1+=",         /* 0x1f */
d420 2
a421 2
  0,    "Lb1+4*=",	/* 0x20 */
  1,    "Ld1+=",	/* 0x21 */
d423 2
a424 2
  0,    "Lb1+4*=",	/* 0x22 */
  1,    "Ld1+=",	/* 0x23 */
d426 1
a426 1
  0,    "L4=",          /* 0x24 */
d428 2
a429 2
  0,    "L4=Sb=",	/* 0x25 */
  1,    "L4=Sd=",	/* 0x26 */
d431 2
a432 2
  0,    "L4=Sb=",	/* 0x27 */
  1,    "L4=Sd=",	/* 0x28 */
d434 1
a434 1
  0,    "L4=",          /* 0x29 */
d436 6
a441 6
  0,    "L4=Mb1+4*=",	/* 0x2a */
  1,    "Lb4*=Mb1+L*=",	/* 0x2b */
  2,    "Lb4*=Md1+4*=",	/* 0x2c */
  3,    "Ld1+=Me1+=",	/* 0x2d */
  0,   	"",	        /* 0x2e */
  0,   	"",	        /* 0x2f */
d443 14
a456 14
  0,    "L4=RD=Sb=",	/* 0x30 */
  1,    "L4=RD=Sb=",	/* 0x31 */
  2,    "L4=RD=Sb=",	/* 0x32 */
  3,    "L4=RD=Sb=",	/* 0x33 */
  4,    "L4=RD=Sb=",	/* 0x34 */
  5,    "L4=RD=Sb=",	/* 0x35 */
  6,    "L4=RD=Sb=",	/* 0x36 */
  7,    "L4=RD=Sb=",	/* 0x37 */
  8,    "L4=RD=Sb=",	/* 0x38 */
  9,    "L4=RD=Sb=",	/* 0x39 */
  0,    "L4=RD8<b+=Sb=",/* 0x3a */
  1,    "L4=RD8<b+=Sb=",/* 0x3b */
  0,    "L4=RD8<b+=Sd=",/* 0x3c */
  1,    "L4=RD8<b+=Sd=",/* 0x3d */
d458 1
a458 1
  0,    "",	        /* 0x3e */
d460 1
a460 1
  0,    "",	        /* 0x3f */
d462 14
a475 14
  0,    "L4=RD=Sb=",	/* 0x40 */
  1,    "L4=RD=Sb=",	/* 0x41 */
  2,    "L4=RD=Sb=",	/* 0x42 */
  3,    "L4=RD=Sb=",	/* 0x43 */
  4,    "L4=RD=Sb=",	/* 0x44 */
  5,    "L4=RD=Sb=",	/* 0x45 */
  6,    "L4=RD=Sb=",	/* 0x46 */
  7,    "L4=RD=Sb=",	/* 0x47 */
  8,    "L4=RD=Sb=",	/* 0x48 */
  9,    "L4=RD=Sb=",	/* 0x49 */
  0,    "L4=RD8<b+=Sb=",/* 0x4a */
  1,    "L4=RD8<b+=Sb=",/* 0x4b */
  0,    "L4=RD8<b+=Sd=",/* 0x4c */
  1,    "L4=RD8<b+=Sd=",/* 0x4d */
d477 2
a478 2
  0,     "",	        /* 0x4e */
  0,     "",	        /* 0x4f */
d480 34
a513 34
  0,    "L4=SD=",	/* 0x50 */
  1,    "L4=SD=",	/* 0x51 */
  2,    "L4=SD=",	/* 0x52 */
  3,    "L4=SD=",	/* 0x53 */
  4,    "L4=SD=",	/* 0x54 */
  5,    "L4=SD=",	/* 0x55 */
  6,    "L4=SD=",	/* 0x56 */
  7,    "L4=SD=",	/* 0x57 */
  8,    "L4=SD=",	/* 0x58 */
  9,    "L4=SD=",	/* 0x59 */
  10,   "L4=SD=",	/* 0x5a */
  11,   "L4=SD=",	/* 0x5b */
  12,   "L4=SD=",	/* 0x5c */
  13,   "L4=SD=",	/* 0x5d */
  14,   "L4=SD=",	/* 0x5e */
  15,   "L4=SD=",	/* 0x5f */
  16,   "L4=SD=",	/* 0x60 */
  17,   "L4=SD=",	/* 0x61 */
  18,   "L4=SD=",	/* 0x62 */
  19,   "L4=SD=",	/* 0x63 */
  20,   "L4=SD=",	/* 0x64 */
  21,   "L4=SD=",	/* 0x65 */
  22,   "L4=SD=",	/* 0x66 */
  23,   "L4=SD=",	/* 0x67 */
  24,   "L4=SD=",	/* 0x68 */
  25,   "L4=SD=",	/* 0x69 */
  26,   "L4=SD=",	/* 0x6a */
  27,   "L4=SD=",	/* 0x6b */
  28,   "L4=SD=",	/* 0x6c */
  29,   "L4=SD=",	/* 0x6d */
  30,   "L4=SD=",	/* 0x6e */
  31,   "L4=SD=",	/* 0x6f */
  32,   "L4=Sb=",	/* 0x70 */
  33,   "L4=Sd=",	/* 0x71 */
d515 6
a520 6
  0,    "",	        /* 0x72 */
  0,    "",	        /* 0x73 */
  0,    "",	        /* 0x74 */
  0,    "",	        /* 0x75 */
  0,    "",	        /* 0x76 */
  0,    "",      	/* 0x77 */
d522 2
a523 2
  0,    "L4=Sb=",	/* 0x78 */
  1,    "L4=Sd=",	/* 0x79 */
d525 6
a530 6
  0,    "",        	/* 0x7a */
  0,    "",	        /* 0x7b */
  0,    "",	        /* 0x7c */
  0,    "",	        /* 0x7d */
  0,    "",	        /* 0x7e */
  0,    "",	        /* 0x7f */
d532 34
a565 34
  0,    "L4=SD=",	/* 0x80 */
  1,    "L4=SD=",	/* 0x81 */
  2,    "L4=SD=",	/* 0x82 */
  3,    "L4=SD=",	/* 0x83 */
  4,    "L4=SD=",	/* 0x84 */
  5,    "L4=SD=",	/* 0x85 */
  6,    "L4=SD=",	/* 0x86 */
  7,    "L4=SD=",	/* 0x87 */
  8,    "L4=SD=",	/* 0x88 */
  9,    "L4=SD=",	/* 0x89 */
  10,   "L4=SD=",	/* 0x8q */
  11,   "L4=SD=",	/* 0x8b */
  12,   "L4=SD=",	/* 0x8c */
  13,   "L4=SD=",	/* 0x8d */
  14,   "L4=SD=",	/* 0x8e */
  15,   "L4=SD=",	/* 0x8f */
  16,   "L4=SD=",	/* 0x90 */
  17,   "L4=SD=",	/* 0x91 */
  18,   "L4=SD=",	/* 0x92 */
  19,   "L4=SD=",	/* 0x93 */
  20,   "L4=SD=",	/* 0x94 */
  21,   "L4=SD=",	/* 0x95 */
  22,   "L4=SD=",	/* 0x96 */
  23,   "L4=SD=",	/* 0x97 */
  24,   "L4=SD=",	/* 0x98 */
  25,   "L4=SD=",	/* 0x99 */
  26,   "L4=SD=",	/* 0x9a */
  27,   "L4=SD=",	/* 0x9b */
  28,   "L4=SD=",	/* 0x9c */
  29,   "L4=SD=",	/* 0x9d */
  30,   "L4=SD=",	/* 0x9e */
  31,   "L4=SD=",	/* 0x9f */
  32,   "L4=Sb=",	/* 0xa0 */
  33,   "L4=Sd=",	/* 0xa1 */
d567 12
a578 12
  0,    "",	        /* 0xa2 */
  0,    "",	        /* 0xa3 */
  0,    "",	        /* 0xa4 */
  0,    "",	        /* 0xa5 */
  0,    "",	        /* 0xa6 */
  0,    "",	        /* 0xa7 */
  0,    "",	        /* 0xa8 */
  0,    "",	        /* 0xa9 */
  0,    "",	        /* 0xaa */
  0,    "",	        /* 0xab */
  0,    "",	        /* 0xac */
  0,    "",	        /* 0xad */
d580 2
a581 2
  0,    "L4=Sb=",	/* 0xae */
  1,    "L4=Sd=",	/* 0xaf */
d583 2
a584 2
  0,    "L4=Sb=",	/* 0xb0 */
  1,    "L4=Sd=",	/* 0xb1 */
d586 1
a586 1
  0,    "L4=",	        /* 0xb2 */
d588 2
a589 2
  0,    "Te=Ue=",       /* 0xb3 */
  1,    "Uf=",	        /* 0xb4 */
d591 1
a591 1
  0,    "",	        /* 0xb5 */
d593 1
a593 1
  0,    "",		/* 0xb6 */
d595 1
a595 1
  0,    "",	        /* 0xb7 */
d597 3
a599 3
  0,    "R0=",	        /* 0xb8 */
  1,    "Rb4*=",	/* 0xb9 */
  2,    "Rd4*=",	/* 0xba */
d601 1
a601 1
  0,    "",	        /* 0xbb */
d603 1
a603 1
  0,    "",	        /* 0xbc */
d605 3
a607 3
  0,    "Nb=",	        /* 0xbd */
  1,    "Nc=",	        /* 0xbe */
  2,    "Nd=",	        /* 0xbf */
d609 1
a609 1
  0,    "L4=",	        /* 0xc0 */
d611 1
a611 1
  0,    "L4=",	        /* 0xc1 */
d613 1
a613 1
  0,    "",		/* 0xc2 */
d615 1
a615 1
  0,    "",		/* 0xc3 */
d617 1
a617 1
  0,    "",		/* 0xc4 */
d619 1
a619 1
  0,    "",		/* 0xc5 */
d621 1
a621 1
  0,    "",		/* 0xc6 */
d623 1
a623 1
  0,    "",		/* 0xc7 */
d625 1
a625 1
  0,    "",		/* 0xc8 */
d627 5
a631 5
  0,    "V0=",	        /* 0xc9 */
  1,    "Vb=",	        /* 0xca */
  2,    "Vc=",	        /* 0xcb */
  3,    "Vd=",	        /* 0xcc */
  4,    "Ve=",	        /* 0xcd */
d633 1
a633 1
  0,    "",	        /* 0xce */
d635 1
a635 1
  0,    "Sd=Vf=Ef=",    /* 0xcf */
d637 1
a637 1
  0,    "Ob=",	        /* 0xd0 */
d639 1
a639 1
  0,    "Ob=Sd=",	/* 0xd1 */
d641 1
a641 1
  0,    "Ob=Ve=",	/* 0xd2 */
d643 4
a646 4
  0,    "P",   	        /* 0xd3 */
  1,    "P",	        /* 0xd4 */
  2,    "P",	        /* 0xd5 */
  3,    "P",	        /* 0xd6 */
d648 1
a648 1
  0,	"",		/* 0xd7 */
d650 1
a650 1
  0,	"",		/* 0xd8 */
d652 1
a652 1
  0,	"",		/* 0xd9 */
d654 1
a654 1
  0,	"Eb=Sd=Ve=",	/* 0xda */
d656 1
a656 1
  0,	"Eb=Mb=",	/* 0xdb */
d658 1
a658 1
  0,	"",		/* 0xdc */
d660 1
a660 1
  0,    "Ob=Ve=",	/* 0xdd */
d662 34
a695 34
  0,	"",		/* 0xde */
  0,	"",		/* 0xdf */
  0,	"",		/* 0xe0 */
  0,	"",		/* 0xe1 */
  0,	"",		/* 0xe2 */
  0,	"",		/* 0xe3 */
  0,	"",		/* 0xe4 */
  0,	"",		/* 0xe5 */
  0,	"",		/* 0xe6 */
  0,	"",		/* 0xe7 */
  0,	"",		/* 0xe8 */
  0,	"",		/* 0xe9 */
  0,	"",		/* 0xea */
  0,	"",		/* 0xeb */
  0,	"",		/* 0xec */
  0,	"",		/* 0xed */
  0,	"",		/* 0xee */
  0,	"",		/* 0xef */
  0,	"",		/* 0xf0 */
  0,	"",		/* 0xf1 */
  0,	"",		/* 0xf2 */
  0,	"",		/* 0xf3 */
  0,	"",		/* 0xf4 */
  0,	"",		/* 0xf5 */
  0,	"",		/* 0xf6 */
  0,	"",		/* 0xf7 */
  0,	"",		/* 0xf8 */
  0,	"",		/* 0xf9 */
  0,	"",		/* 0xfa */
  0,	"",		/* 0xfb */
  0,	"",		/* 0xfc */
  0,	"",		/* 0xfd */
  0,	"",		/* 0xfe */
  0,	"",		/* 0xff */
d1202 1
a1202 1
      bfd_put_16 (abfd, 0xffff, p + 2);
d1238 1
a1238 1
	  bfd_put_16 (abfd, (skip >> 2) - 1, p + 1);
d1247 1
a1247 1
      bfd_put_16 (abfd, skip - 1, p + 2);
d1261 1
a1261 1
     int addend;
d1266 1
a1266 1
  if ((unsigned) (addend) + 0x80 < 0x100)
d1272 1
a1272 1
  else if ((unsigned) (addend) + 0x8000 < 0x10000)
d1278 1
a1278 1
  else if ((unsigned) (addend) + 0x800000 < 0x1000000)
d1399 1
a1399 1
	  bfd_put_16 (abfd, sym_num, p + 3);
d1457 2
a1458 2
  final_types = (int **) bfd_alloc (abfd, sizeof (int *) * 6);
  final_type = (int *) bfd_alloc (abfd, sizeof (int));
d1482 1
a1482 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1498 1
a1498 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1509 1
a1509 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1520 1
a1520 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1531 1
a1531 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1541 1
a1541 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1552 1
a1552 1
      final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1556 1
a1556 1
      final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
d1575 5
a1579 4
	  final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *) bfd_alloc (abfd, sizeof (int));
d1656 5
a1660 4
	  final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *) bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *) bfd_alloc (abfd, sizeof (int));
d1694 2
a1695 1
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
d1780 1
a1780 1
    bfd_zalloc (abfd, sizeof (struct som_exec_data));
d1853 1
d1857 3
a1859 2
  space_strings = bfd_malloc (file_hdr->space_strings_size);
  if (!space_strings && file_hdr->space_strings_size != 0)
d1863 1
a1863 1
		SEEK_SET) < 0)
d1865 1
a1865 2
  if (bfd_read (space_strings, 1, file_hdr->space_strings_size, abfd)
      != file_hdr->space_strings_size)
d1881 1
a1881 1
		    SEEK_SET) < 0)
d1883 2
a1884 1
      if (bfd_read (&space, 1, sizeof space, abfd) != sizeof space)
d1891 2
a1892 1
      newname = bfd_alloc (abfd, strlen (space.name.n_name) + 1);
d1918 1
a1918 1
		    SEEK_SET) < 0)
d1920 2
a1921 1
      if (bfd_read (&subspace, 1, sizeof subspace, abfd) != sizeof subspace)
d1927 1
a1927 1
		    SEEK_SET) < 0)
d1935 1
a1935 1
      if (space_asect->alignment_power == -1)
d1949 2
a1950 2
	  if (bfd_read (&subspace, 1, sizeof subspace, abfd)
	      != sizeof subspace)
d1956 2
a1957 1
	  newname = bfd_alloc (abfd, strlen (subspace.name.n_name) + 1);
d2048 1
a2048 1
	      subspace_asect->reloc_count = -1;
d2061 1
a2061 1
	  if (subspace_asect->alignment_power == -1)
d2086 3
a2088 2
  subspace_sections = (asection **) bfd_malloc (total_subspaces
						* sizeof (asection *));
d2136 1
d2139 2
a2140 1
  if (bfd_read ((PTR) & file_hdr, 1, FILE_HDR_SIZE, abfd) != FILE_HDR_SIZE)
d2174 1
a2174 1
      if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) < 0)
d2181 2
a2182 1
      if (bfd_read ((PTR) & lst_header, 1, SLSTHDR, abfd) != SLSTHDR)
d2191 1
a2191 1
      if (bfd_seek (abfd, lst_header.dir_loc, SEEK_SET) < 0)
d2198 2
a2199 1
      if (bfd_read ((PTR) & som_entry, 1, ENTRY_SIZE, abfd) != ENTRY_SIZE)
d2208 1
a2208 1
      if (bfd_seek (abfd, som_entry.location, SEEK_SET) < 0)
d2218 2
a2219 2

      if (bfd_read ((PTR) & file_hdr, 1, FILE_HDR_SIZE, abfd) != FILE_HDR_SIZE)
d2247 2
a2248 1
      if (bfd_read ((PTR) & aux_hdr, 1, AUX_HDR_SIZE, abfd) != AUX_HDR_SIZE)
d2275 1
a2275 1
    bfd_zalloc (abfd, sizeof (struct som_data_struct));
d2291 1
d2294 1
a2294 1
  file_hdr = (struct header *) bfd_zalloc (abfd, sizeof (struct header));
d2303 3
a2305 2
      obj_som_exec_hdr (abfd) = (struct som_exec_auxhdr *)
	bfd_zalloc (abfd, sizeof (struct som_exec_auxhdr));
d2350 1
d2352 1
a2352 2
	    (struct space_dictionary_record *)
	    bfd_zalloc (abfd, sizeof (struct space_dictionary_record));
d2373 3
a2375 3
	  som_section_data (section)->subspace_dict
	    = (struct subspace_dictionary_record *)
	      bfd_zalloc (abfd, sizeof (struct subspace_dictionary_record));
d2566 1
a2566 1
  int i;
d2569 1
d2595 1
a2595 1
      int i;
d2598 1
a2598 1
      if (section->reloc_count <= 0)
d2602 1
a2602 1
      for (i = 1; i < section->reloc_count; i++)
d2604 1
a2604 1
	  arelent *reloc = section->orelocation[i];
d2641 3
a2643 1
  sorted_syms = (asymbol **) bfd_zalloc (abfd, num_syms * sizeof (asymbol *));
d2676 1
d2701 2
a2702 1
	  int reloc_offset, current_rounding_mode;
d2730 1
a2730 1
	  if (bfd_seek (abfd, current_offset + total_reloc_size, SEEK_SET) < 0)
d2768 2
a2769 2
		  if (bfd_write ((PTR) tmp_space, p - tmp_space, 1, abfd)
		      != p - tmp_space)
d2852 1
a2852 1
		      bfd_put_16 (abfd, sym_num, p + 2);
d2881 1
a2881 1
		      bfd_put_16 (abfd, sym_num, p + 2);
d2891 1
a2891 1
		    int tmp;
d3003 1
a3003 1
		  bfd_put_16 (abfd, sym_num, p + 3);
d3036 2
a3037 2
	  if (bfd_write ((PTR) tmp_space, p - tmp_space, 1, abfd)
	      != p - tmp_space)
d3066 1
d3070 1
a3070 1
  if (bfd_seek (abfd, current_offset, SEEK_SET) < 0)
d3094 2
a3095 2
	  if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd)
	      != p - tmp_space)
d3119 1
a3119 1
      bfd_put_32 (abfd, length, p);
d3145 2
a3146 1
  if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd) != p - tmp_space)
d3158 1
a3158 1
     unsigned long current_offset;
d3174 1
d3192 1
a3192 1
  if (bfd_seek (abfd, current_offset, SEEK_SET) < 0)
d3207 2
a3208 2
	      if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd)
		  != p - tmp_space)
d3228 1
a3228 1
	  bfd_put_32 (abfd, length, p);
d3276 2
a3277 2
	  if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd)
	      != p - tmp_space)
d3296 1
a3296 1
      bfd_put_32 (abfd, length, p);
d3317 2
a3318 1
  if (bfd_write ((PTR) &tmp_space[0], p - tmp_space, 1, abfd) != p - tmp_space)
d3372 1
a3372 1
      unsigned int len;
d3374 1
a3374 1
      if (bfd_seek (abfd, current_offset, SEEK_SET) < 0)
d3381 1
a3381 1
      if (bfd_write ((PTR) obj_som_version_hdr (abfd), len, 1, abfd) != len)
d3388 2
a3389 2
      if (bfd_write ((PTR) obj_som_version_hdr (abfd)->user_string,
		     len, 1, abfd) != len)
d3395 1
a3395 1
      unsigned int len;
d3397 1
a3397 1
      if (bfd_seek (abfd, current_offset, SEEK_SET) < 0)
d3404 1
a3404 1
      if (bfd_write ((PTR) obj_som_copyright_hdr (abfd), len, 1, abfd) != len)
d3411 2
a3412 2
      if (bfd_write ((PTR) obj_som_copyright_hdr (abfd)->copyright,
		     len, 1, abfd) != len)
d3657 1
a3657 1
  if (bfd_seek (abfd, current_offset - 1, SEEK_SET) < 0)
d3659 1
a3659 1
  if (bfd_write ((PTR) "", 1, 1, abfd) != 1)
d3689 1
d3765 1
a3765 1
  if (bfd_seek (abfd, location, SEEK_SET) < 0)
d3813 3
a3815 3
	  if (bfd_write ((PTR) som_section_data (subsection)->subspace_dict,
			 sizeof (struct subspace_dictionary_record), 1, abfd)
	      != sizeof (struct subspace_dictionary_record))
d3869 3
a3871 3
	  if (bfd_write ((PTR) som_section_data (subsection)->subspace_dict,
			 sizeof (struct subspace_dictionary_record), 1, abfd)
	      != sizeof (struct subspace_dictionary_record))
d3884 1
a3884 1
  if (bfd_seek (abfd, location, SEEK_SET) < 0)
d3895 3
a3897 3
      if (bfd_write ((PTR) som_section_data (section)->space_dict,
		     sizeof (struct space_dictionary_record), 1, abfd)
	  != sizeof (struct space_dictionary_record))
d3908 1
a3908 1
      if (bfd_seek (abfd, location, SEEK_SET) < 0)
d3911 2
a3912 2
      if (bfd_write ((PTR) obj_som_compilation_unit (abfd),
		     COMPUNITSZ, 1, abfd) != COMPUNITSZ)
d3933 1
a3933 1
  if (bfd_seek (abfd, (file_ptr) 0, SEEK_SET) < 0)
d3935 2
a3936 3
  if (bfd_write ((PTR) obj_som_file_hdr (abfd),
		 sizeof (struct header), 1, abfd)
      != sizeof (struct header))
d3970 1
a3970 1
		    SEEK_SET) < 0)
d3973 2
a3974 2
      if (bfd_write ((PTR) exec_header, AUX_HDR_SIZE, 1, abfd)
	  != AUX_HDR_SIZE)
d4129 2
a4130 1
  int i, symtab_size;
d4134 2
a4135 1
  symtab_size = num_syms * sizeof (struct symbol_dictionary_record);
d4139 1
a4139 1
  memset (som_symtab, 0, symtab_size);
d4169 1
a4169 1
  if (bfd_write ((PTR) som_symtab, symtab_size, 1, abfd) != symtab_size)
d4208 1
d4224 2
a4225 1
  stringtab = bfd_malloc (obj_som_stringtab_size (abfd));
d4230 1
a4230 1
  if (bfd_seek (abfd, obj_som_str_filepos (abfd), SEEK_SET) < 0)
d4233 1
a4233 2
  if (bfd_read (stringtab, obj_som_stringtab_size (abfd), 1, abfd)
      != obj_som_stringtab_size (abfd))
d4314 1
d4329 3
a4331 2
  symbase = ((som_symbol_type *)
	     bfd_malloc (symbol_count * sizeof (som_symbol_type)));
d4337 4
a4340 2
  buf = bfd_malloc (symbol_count * symsize);
  if (buf == NULL && symbol_count * symsize != 0)
d4342 1
a4342 1
  if (bfd_seek (abfd, obj_som_sym_filepos (abfd), SEEK_SET) < 0)
d4344 1
a4344 2
  if (bfd_read (buf, symbol_count * symsize, 1, abfd)
      != symbol_count * symsize)
d4522 2
a4523 2
  som_symbol_type *new =
    (som_symbol_type *) bfd_zalloc (abfd, sizeof (som_symbol_type));
d4553 1
a4553 1
	CONST char *section_name;
d4884 1
a4884 1
			return -1;
d4890 1
a4890 1
						0,
d4938 1
d4947 1
a4947 1
  if (section->reloc_count == -1)
d4949 2
a4950 1
      external_relocs = (char *) bfd_malloc (fixup_stream_size);
d4959 1
a4959 2
      if (bfd_read (external_relocs, 1, fixup_stream_size, abfd)
	  != fixup_stream_size)
d4982 3
a4984 2
  internal_relocs = (arelent *)
    bfd_zalloc (abfd, (num_relocs * sizeof (arelent)));
d5056 2
a5057 2
  newsect->used_by_bfd =
    (PTR) bfd_zalloc (abfd, sizeof (struct som_section_data_struct));
d5102 2
d5110 1
d5112 1
a5112 2
    (struct som_copyable_section_data_struct *)
    bfd_zalloc (obfd, sizeof (struct som_copyable_section_data_struct));
d5142 1
a5142 1
    bfd_zalloc (obfd, sizeof (struct som_exec_data));
d5167 1
d5169 2
a5170 3
	(struct som_copyable_section_data_struct *)
	bfd_zalloc (section->owner,
		    sizeof (struct som_copyable_section_data_struct));
d5197 1
d5199 2
a5200 3
	(struct som_copyable_section_data_struct *)
	bfd_zalloc (section->owner,
		    sizeof (struct som_copyable_section_data_struct));
d5234 2
d5238 1
a5238 1
      int len = strlen (string);
d5243 3
a5245 3
      obj_som_version_hdr (abfd) = (struct user_string_aux_hdr *)
	bfd_zalloc (abfd, sizeof (struct aux_id)
			      + sizeof (unsigned int) + len + pad);
d5261 3
a5263 3
      obj_som_copyright_hdr (abfd) = (struct copyright_aux_hdr *)
	bfd_zalloc (abfd, sizeof (struct aux_id)
			    + sizeof (unsigned int) + len + pad);
d5287 1
a5287 1
  COMPUNIT *n = (COMPUNIT *) bfd_zalloc (abfd, COMPUNITSZ);
d5294 1
a5294 1
      n->f.n_name = bfd_alloc (abfd, strlen (f) + 1); \
d5323 2
a5324 2
      || bfd_seek (abfd, (file_ptr) (section->filepos + offset), SEEK_SET) == -1
      || bfd_read (location, (bfd_size_type) 1, count, abfd) != count)
d5357 1
a5357 1
  if (bfd_seek (abfd, offset, SEEK_SET) == -1)
d5360 1
a5360 1
  if (bfd_write ((PTR) location, 1, count, abfd) != count)
d5382 2
a5383 2
     CONST char **filename_ptr ATTRIBUTE_UNUSED;
     CONST char **functionname_ptr ATTRIBUTE_UNUSED;
d5472 1
d5475 3
a5477 3
  hash_table =
    (unsigned int *) bfd_malloc (lst_header->hash_size
				 * sizeof (unsigned int));
d5486 1
a5486 2
  if (bfd_read ((PTR) hash_table, lst_header->hash_size, 4, abfd)
      != lst_header->hash_size * 4)
d5500 1
a5500 1
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) < 0)
d5504 2
a5505 2
      if (bfd_read ((PTR) & lst_symbol, 1, sizeof (lst_symbol), abfd)
	  != sizeof (lst_symbol))
d5516 1
a5516 1
	      < 0)
d5520 2
a5521 2
	  if (bfd_read ((PTR) & lst_symbol, 1, sizeof (lst_symbol), abfd)
	      != sizeof (lst_symbol))
d5550 1
d5553 3
a5555 3
  hash_table =
    (unsigned int *) bfd_malloc (lst_header->hash_size
				 * sizeof (unsigned int));
a5558 6
  som_dict =
    (struct som_entry *) bfd_malloc (lst_header->module_count
				     * sizeof (struct som_entry));
  if (som_dict == NULL && lst_header->module_count != 0)
    goto error_return;

d5561 1
a5561 2
  if (bfd_read ((PTR) hash_table, lst_header->hash_size, 4, abfd)
      != lst_header->hash_size * 4)
d5566 7
a5572 1
  if (bfd_seek (abfd, lst_filepos + lst_header->dir_loc, SEEK_SET) < 0)
d5575 1
a5575 3
  if (bfd_read ((PTR) som_dict, lst_header->module_count,
		sizeof (struct som_entry), abfd)
      != lst_header->module_count * sizeof (struct som_entry))
d5588 1
a5588 1
      if (bfd_seek (abfd, lst_filepos + hash_table[i], SEEK_SET) < 0)
d5591 2
a5592 2
      if (bfd_read ((PTR) & lst_symbol, 1, sizeof (lst_symbol), abfd)
	  != sizeof (lst_symbol))
d5603 1
a5603 1
			    + lst_symbol.name.n_strx - 4, SEEK_SET) < 0)
d5606 1
a5606 1
      if (bfd_read (&len, 1, 4, abfd) != 4)
d5610 1
a5610 1
      set->name = bfd_zalloc (abfd, len + 1);
d5613 1
a5613 1
      if (bfd_read (set->name, 1, len, abfd) != len)
d5630 2
a5631 1
	  if (bfd_seek (abfd, lst_filepos + lst_symbol.next_entry, SEEK_SET) <0)
d5634 2
a5635 2
	  if (bfd_read ((PTR) & lst_symbol, 1, sizeof (lst_symbol), abfd)
	      != sizeof (lst_symbol))
d5640 1
a5640 1
				+ lst_symbol.name.n_strx - 4, SEEK_SET) < 0)
d5643 1
a5643 1
	  if (bfd_read (&len, 1, 4, abfd) != 4)
d5647 1
a5647 1
	  set->name = bfd_zalloc (abfd, len + 1);
d5651 1
a5651 1
	  if (bfd_read (set->name, 1, len, abfd) != len)
d5691 2
a5692 1
  int i = bfd_read ((PTR) nextname, 1, 16, abfd);
d5700 1
a5700 1
  if (bfd_seek (abfd, (file_ptr) - 16, SEEK_CUR) < 0)
d5711 2
a5712 2
  if (bfd_read ((PTR) &ar_header, 1, sizeof (struct ar_hdr), abfd)
      != sizeof (struct ar_hdr))
d5735 2
a5736 2
  if (bfd_read ((PTR) & lst_header, 1, sizeof (struct lst_header), abfd)
      != sizeof (struct lst_header))
d5752 2
a5753 2
  if (bfd_seek (abfd, ardata->first_file_filepos - parsed_size
			+ sizeof (struct lst_header), SEEK_SET) < 0)
d5758 3
a5760 3
  ardata->symdefs = (carsym *) bfd_alloc (abfd,
					  (ardata->symdef_count
					   * sizeof (carsym)));
d5771 1
a5771 1
  if (bfd_seek (abfd, ardata->first_file_filepos, SEEK_SET) < 0)
d5890 1
d5892 3
a5894 2
  hash_table =
    (unsigned int *) bfd_malloc (lst.hash_size * sizeof (unsigned int));
d5897 4
a5900 3
  som_dict =
    (struct som_entry *) bfd_malloc (lst.module_count
				     * sizeof (struct som_entry));
d5904 3
a5906 3
  last_hash_entry =
    ((struct lst_symbol_record **)
     bfd_malloc (lst.hash_size * sizeof (struct lst_symbol_record *)));
d5944 3
a5946 1
  lst_syms = bfd_malloc (nsyms * sizeof (struct lst_symbol_record));
d5949 1
a5949 1
  strings = bfd_malloc (string_size);
d6083 1
a6083 1
      curr_som_offset = (curr_som_offset + 0x1) & ~0x1;
d6089 2
a6090 2
  if (bfd_write ((PTR) hash_table, lst.hash_size, 4, abfd)
      != lst.hash_size * 4)
d6094 2
a6095 3
  if (bfd_write ((PTR) som_dict, lst.module_count,
		 sizeof (struct som_entry), abfd)
      != lst.module_count * sizeof (struct som_entry))
d6099 2
a6100 2
  if (bfd_write ((PTR) lst_syms, nsyms, sizeof (struct lst_symbol_record), abfd)
      != nsyms * sizeof (struct lst_symbol_record))
d6104 2
a6105 1
  if (bfd_write ((PTR) strings, string_size, 1, abfd) != string_size)
d6153 1
d6246 2
a6247 2
  if (bfd_write ((PTR) &hdr, 1, sizeof (struct ar_hdr), abfd)
      != sizeof (struct ar_hdr))
d6251 2
a6252 2
  if (bfd_write ((PTR) &lst, 1, sizeof (struct lst_header), abfd)
      != sizeof (struct lst_header))
d6256 1
a6256 2
  if (som_bfd_ar_write_symbol_stuff (abfd, nsyms, stringsize, lst, elength)
      == false)
d6282 1
a6282 1
      o->reloc_count = -1;
@


1.19
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@d4502 2
a4503 2
som_print_symbol (ignore_abfd, afile, symbol, how)
     bfd *ignore_abfd ATTRIBUTE_UNUSED;
d4523 1
a4523 1
	bfd_print_symbol_vandf ((PTR) file, symbol);
@


1.18
log
@Update copyright notices
@
text
@d6289 1
@


1.17
log
@2001-01-04  Kazu Hirata  <kazu@@hxi.com>

	* som.c: Fix formatting.
@
text
@d2 2
a3 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 1998, 2000
@


1.17.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.16
log
@2000-12-14  Kazu Hirata  <kazu@@hxi.com>

	* peigen.c: Fix formatting.
	* som.c: Likewise.
	* som.h: Likewise.
@
text
@d113 4
a116 5
struct reloc_queue
  {
    unsigned char *reloc;
    unsigned int size;
  } reloc_queue[4];
d121 1
a121 2
typedef enum
{
d133 1
a133 2
struct section_to_type
{
d140 1
a140 2
struct som_misc_symbol_info
{
d378 1
a378 2
struct fixup_format
{
d383 1
a383 2
static const struct fixup_format som_fixup_formats[256] =
{
d696 1
a696 2
static const int comp1_opcodes[] =
{
d717 1
a717 2
static const int comp2_opcodes[] =
{
d725 1
a725 2
static const int comp3_opcodes[] =
{
d781 1
a781 2
static reloc_howto_type som_hppa_howto_table[] =
{
d1037 2
a1038 1
  SOM_HOWTO (R_RESERVED, "R_RESERVED")};
d1467 9
a1475 9
      case e_fsel:
      case e_psel:
      case e_lpsel:
      case e_rpsel:
	final_types[0] = final_type;
	final_types[1] = NULL;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1477 16
a1492 16
      case e_tsel:
      case e_ltsel:
      case e_rtsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	if (field == e_tsel)
	  *final_types[0] = R_FSEL;
	else if (field == e_ltsel)
	  *final_types[0] = R_LSEL;
	else
	  *final_types[0] = R_RSEL;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1494 10
a1503 10
      case e_lssel:
      case e_rssel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_S_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1505 10
a1514 10
      case e_lsel:
      case e_rsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_N_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1516 10
a1525 10
      case e_ldsel:
      case e_rdsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_D_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1527 10
a1536 10
      case e_lrsel:
      case e_rrsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_R_MODE;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1538 9
a1546 9
      case e_nsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_N1SEL;
	final_types[1] = final_type;
	final_types[2] = NULL;
	*final_type = base_type;
	break;
d1548 17
a1564 17
      case e_nlsel:
      case e_nlrsel:
	final_types[0] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[0])
	  return NULL;
	*final_types[0] = R_N0SEL;
	final_types[1] = (int *) bfd_alloc (abfd, sizeof (int));
	if (!final_types[1])
	  return NULL;
	if (field == e_nlsel)
	  *final_types[1] = R_N_MODE;
	else
	  *final_types[1] = R_R_MODE;
	final_types[2] = final_type;
	final_types[3] = NULL;
	*final_type = base_type;
	break;
d1573 4
a1576 4
	  final_types[0] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *)bfd_alloc (abfd, sizeof (int));
d1578 1
a1578 1
            return NULL;
d1598 2
a1599 2
	  || field == e_lpsel
	  || field == e_rpsel)
d1610 2
a1611 2
	  || field == e_ltsel
	  || field == e_rtsel)
d1653 4
a1656 4
	  final_types[0] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[1] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[2] = (int *)bfd_alloc (abfd, sizeof (int));
	  final_types[3] = (int *)bfd_alloc (abfd, sizeof (int));
d1658 1
a1658 1
            return NULL;
a1709 1
/*ARGSUSED*/
d1775 1
a1775 1
    bfd_zalloc (abfd, sizeof (struct som_exec_data ));
d1818 1
a1818 1
  obj_som_stringtab (abfd) = (char  *) NULL;
d1849 1
a1849 1
  /* First, read in space names */
d1856 1
a1856 1
  		SEEK_SET) < 0)
d1862 1
a1862 1
  /* Loop over all of the space dictionaries, building up sections */
d1871 1
a1871 1
      /* Read the space dictionary element */
d1880 1
a1880 1
      /* Setup the space name string */
d1883 1
a1883 1
      /* Make a section out of it */
d1893 1
a1893 1
       if (space.is_loadable == 0)
d1906 1
a1906 1
      /* Now, read in the first subspace for this space */
d1914 1
a1914 1
      /* Seek back to the start of the subspaces for loop below */
d1921 2
a1922 1
      /* Setup the start address and file loc from the first subspace record */
d1933 1
a1933 1
      /* Loop over the rest of the subspaces, building up more sections */
d1939 1
a1939 1
	  /* Read in the next subspace */
d1944 1
a1944 1
	  /* Setup the subspace name string */
d1952 1
a1952 1
	  /* Make a section out of this subspace */
d2159 1
a2159 1
      /* Read the lst header and determine where the SOM directory begins */
d2162 2
a2163 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2165 2
a2166 2
          return 0;
        }
d2169 2
a2170 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2172 2
a2173 2
          return 0;
        }
d2175 1
a2175 1
      /* Position to and read the first directory entry */
d2178 2
a2179 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2181 2
a2182 2
          return 0;
        }
d2185 2
a2186 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2188 2
a2189 2
          return 0;
        }
d2191 1
a2191 1
      /* Now position to the first SOM */
d2194 2
a2195 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2197 2
a2198 2
          return 0;
        }
d2202 1
a2202 1
      /* And finally, re-read the som header */
d2205 2
a2206 2
        {
          if (bfd_get_error () != bfd_error_system_call)
d2208 2
a2209 2
          return 0;
        }
d2332 3
a2334 3
	  som_section_data (section)->space_dict
	    = (struct space_dictionary_record *)
	      bfd_zalloc (abfd, sizeof (struct space_dictionary_record));
d2464 1
a2464 1
      count += som_is_space (section);
d2636 1
a2636 1
        som_symbol_data (sorted_syms[i])->index = i;
d2681 1
a2681 1
 	  int current_call_mode;
d2883 1
a2883 1
		        tmp_reloc = subsection->orelocation[tmp];
d3277 1
a3277 1
      som_symbol_data(syms[i])->stringtab_offset = strings_size;
d3283 1
a3283 1
        {
d3287 1
a3287 1
        }
a3861 1

d3866 1
a3866 1
      /* Dump its header  */
d3881 1
a3881 1
        return false;
d3885 1
a3885 1
        return false;
d3891 1
a3891 1
    obj_som_file_hdr(abfd)->system_id = obj_som_exec_data (abfd)->system_id;
d3893 1
a3893 1
    obj_som_file_hdr(abfd)->system_id = CPU_PA_RISC2_0;
d3895 1
a3895 1
    obj_som_file_hdr(abfd)->system_id = CPU_PA_RISC1_1;
d3897 1
a3897 1
    obj_som_file_hdr(abfd)->system_id = CPU_PA_RISC1_0;
a4170 1

d4420 1
a4420 1
        sym->symbol.flags |= BSF_WEAK;
d4490 1
a4490 1
  (som_symbol_type *) bfd_zalloc (abfd, sizeof (som_symbol_type));
d4566 1
a4566 1
  arelent *rptr= internal_relocs;
a4666 1

d5027 1
a5027 1
  /* We allow more than three sections internally */
d5059 1
d5073 3
a5075 3
  som_section_data (osection)->copy_data
    = (struct som_copyable_section_data_struct *)
      bfd_zalloc (obfd, sizeof (struct som_copyable_section_data_struct));
d5130 4
a5133 4
      som_section_data (section)->copy_data
	= (struct som_copyable_section_data_struct *)
	  bfd_zalloc (section->owner,
		      sizeof (struct som_copyable_section_data_struct));
d5160 4
a5163 4
      som_section_data (section)->copy_data
	= (struct som_copyable_section_data_struct *)
	  bfd_zalloc (section->owner,
		      sizeof (struct som_copyable_section_data_struct));
d5190 1
d5241 1
a5241 1
                                 version_id)
d5285 1
a5285 1
      || bfd_read (location, (bfd_size_type)1, count, abfd) != count)
d5332 1
a5332 1
  /* Allow any architecture to be supported by the SOM backend */
d5338 1
a5338 1
			functionname_ptr, line_ptr)
d5390 1
a5390 1
  if (!(symbol->flags & (BSF_GLOBAL|BSF_LOCAL)))
d5416 1
a5416 1
    ret->value = symbol->value+symbol->section->vma;
d5643 1
d5818 1
d5830 1
a5830 1
	  | (symbol->name[len-2] << 8) | symbol->name[len-1];
d6022 1
a6022 1
	  while ((int)p % 4)
a6094 1
/*ARGSUSED*/
d6181 1
a6181 1
  p = (int *)&lst;
d6183 1
a6183 1
  for (i = 0; i < sizeof (struct lst_header)/sizeof (int) - 1; i++)
d6251 1
d6289 1
a6289 2
const bfd_target som_vec =
{
@


1.15
log
@* som.c: Include alloca-conf.h
@
text
@a75 1

d93 1
a93 1
   
d109 1
a109 1
   of some multi-byte relocation makes object files smaller. 
d200 1
a200 1
static asection * bfd_section_from_som_symbol PARAMS ((bfd *, 
d271 1
a271 1
	
d274 2
a275 2
   This table includes all the standard subspaces as defined in the 
   current "PRO ABI for PA-RISC Systems", $UNWIND$ which for 
d309 1
a309 1
   into BFD and symbolically printed by utilities.  To make actual use 
d317 1
a317 1
   while possibly modifying the data in some manner.  They also can 
d327 1
a327 1
   Each entry in the table has three fields. 
d335 1
a335 1
   stream.  
d337 1
a337 1
   The third field specifys whether or not this relocation may use 
d341 2
a342 2
   Variables:  
  
d354 2
a355 2
  
   Lower case letters (starting with 'b') refer to following 
d357 1
a357 1
   c is the next 2 bytes, d is the next 3 bytes, etc...  
d362 1
a362 1
   the constants are represented in decimal. 
d365 1
a365 1
   '<' represents a left shift. 
d371 2
a372 2
   Unwind Entries:  
   
d1048 1
a1048 1
  
d1051 1
a1051 1
  
d1133 1
a1133 1
  abort();
d1172 1
a1172 1
	 just built and use R_PREV_FIXUP instead.  We saved 
d1190 1
a1190 1
   relocation stream via SUBSPACE_RELOC_SIZE_P; also return the 
d1221 2
a1222 2
  
  /* The difference must be less than 0x1000000.  Use one 
d1273 1
a1273 1
  if ((unsigned)(addend) + 0x80 < 0x100)
d1277 1
a1277 1
      p = try_prev_fixup (abfd, subspace_reloc_sizep, p, 2, queue); 
d1315 1
a1315 1
  
d1319 1
a1319 1
     
d1371 1
a1371 1
  
d1388 1
a1388 1
      
d1395 1
a1395 1
      
d1413 1
a1413 2

/* Return the logarithm of X, base 2, considering X unsigned. 
d1469 1
a1469 1
  /* The field selector may require additional relocations to be 
d1575 1
a1575 1
  
a1649 1

d1796 1
a1796 1
    
d1825 1
a1825 1
  /* Initialize the saved symbol table and string table to NULL.  
d1865 1
a1865 1
  if (bfd_seek (abfd, current_offset + file_hdr->space_strings_location, 
d1898 1
a1898 1
			   
d1973 1
a1973 1
	  /* Keep an easy mapping between subspaces and sections. 
d1989 1
a1989 1
	    /* Readonly data.  */  
d1994 1
a1994 1
	    /* Normal data.  */  
d2015 2
a2016 2
	  
	  if (subspace.dup_common || subspace.is_common) 
d2045 1
a2045 1
	      /* We can not determine this yet.  When we read in the 
d2100 1
a2100 1
  
d2134 1
a2134 1
#define ENTRY_SIZE sizeof(struct som_entry)
d2321 1
a2321 1
  file_hdr->file_time.nanosecs = 0; 
d2337 1
a2337 1
      
d2352 1
a2352 1
	  som_section_data (section)->space_dict->sort_key = 
d2354 1
a2354 1
	  som_section_data (section)->space_dict->is_defined = 
d2356 1
a2356 1
	  som_section_data (section)->space_dict->is_private = 
d2385 1
a2385 1
	  som_section_data (section)->subspace_dict->subspace_start = 
d2391 1
a2391 1
	  som_section_data (section)->subspace_dict->alignment = 
d2508 1
a2508 1
  
d2540 1
a2540 1
  
d2604 1
a2604 1
	  /* Scaling to encourage symbols involved in R_DP_RELATIVE 
d2712 1
a2712 1
	  /* To make life easier start over with a clean slate for 
d2730 1
a2730 1
	  /* Translate each BFD relocation into one or more SOM 
d2738 1
a2738 1
	      /* Get the symbol number.  Remember it's stored in a 
d2744 1
a2744 1
	      
d2747 1
a2747 1
		 the relocation queue. 
d2818 1
a2818 1
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p, 
d2838 1
a2838 1
		      bfd_put_16 (abfd, sym_num, p + 2); 
d2853 1
a2853 1
		    p = som_reloc_addend (abfd, bfd_reloc->addend, p, 
d2867 1
a2867 1
		      bfd_put_16 (abfd, sym_num, p + 2); 
d2888 1
a2888 1
		
d2905 1
a2905 1
		  
d2971 1
a2971 1
		      
d2973 1
a2973 1
		  /* The only time we generate R_COMP1, R_COMP2 and 
d2983 1
a2983 1
		  /* The only time we generate R_COMP1, R_COMP2 and 
d2996 1
a2996 1
		  /* The only time we generate R_COMP1, R_COMP2 and 
d3017 1
a3017 1
	  p = som_reloc_skip (abfd, bfd_section_size (abfd, subsection) 
d3080 1
a3080 1
	      != p - tmp_space) 
d3149 1
a3149 1
  
d3189 1
a3189 1
	      /* Flush buffer before refilling or reallocating. */
d3220 1
a3220 1
	    case 0:	
d3224 1
a3224 1
	      obj_som_compilation_unit (abfd)->language_name.n_strx = 
d3228 1
a3228 1
	      obj_som_compilation_unit (abfd)->product_id.n_strx = 
d3232 1
a3232 1
	      obj_som_compilation_unit (abfd)->version_id.n_strx = 
d3258 1
a3258 1
	  /* Flush buffer before refilling or reallocating. */
d3307 1
a3307 1
/* Compute variable information to be placed in the SOM headers, 
d3311 1
a3311 1
static boolean 
d3322 1
a3322 1
  /* The file header will always be first in an object file, 
d3334 1
a3334 1
  current_offset += sizeof (struct header);  
d3437 1
a3437 1
  /* Mark the offset of the space/subspace string table in the 
d3450 1
a3450 1
  /* Next is the compilation unit. */
d3453 1
a3453 1
  if (obj_som_compilation_unit (abfd)) 
d3456 1
a3456 1
      current_offset += COMPUNITSZ; 
d3518 1
a3518 1
		 loader will create holes between subspaces *and* 
a3546 1

d3561 1
a3561 1
	      current_offset += bfd_section_size (abfd, subsection); 
d3578 1
a3578 1
      section = section->next; 
d3606 1
a3606 1
	  
d3619 1
a3619 1
	      current_offset += bfd_section_size (abfd, subsection); 
d3631 1
a3631 1
      section = section->next; 
d3680 1
a3680 1
     at this time. 
d3689 1
a3689 1
    current_offset += (4 - (current_offset % 4)); 
d3722 1
a3722 1
    current_offset += (4 - (current_offset % 4)); 
d3735 1
a3735 1
 
d3764 1
a3764 1
	  
d3792 1
a3792 1
	  
d3800 1
a3800 1
      section = section->next; 
d3819 1
a3819 1
	  
d3843 1
a3843 1
	  subspace_index++; 
d3848 1
a3848 1
	  
d3856 1
a3856 1
      section = section->next; 
d3993 1
a3993 1
	 
d4043 1
a4043 1
  
d4063 1
a4063 1
	
d4085 1
a4085 1
  /* For all other symbols, the symbol_info field contains the 
d4127 2
a4128 2
      /* This is really an index into the symbol strings table.  
	 By the time we get here, the index has already been 
d4162 1
a4162 1
/* Write an object in SOM format.  */  
d4212 1
a4212 1
  
d4217 1
a4217 1
  /* Save our results and return success. */
d4321 1
a4321 1
  if (bfd_read (buf, symbol_count * symsize, 1, abfd) 
a4385 1
	     
d4557 1
a4557 1
   not just counting 
d4640 1
a4640 1
	 parse RHS, then assign to LHS.  Repeat until no more 
d4834 1
a4834 1
      /* We do not pass R_DATA_OVERRIDE or R_NO_RELOCATION 
d4876 1
a4876 1
			
d4900 1
a4900 1
/* Read in the relocs (aka fixups in SOM terms) for a section. 
d4902 1
a4902 1
   som_get_reloc_upper_bound calls this routine with JUST_COUNT 
d4923 1
a4923 1
  /* If reloc_count is -1, then the relocation stream has not been 
d4930 1
a4930 1
      /* Read in the external forms. */
d4960 1
a4960 1
  internal_relocs = (arelent *) 
d4979 1
a4979 1
   information associated with the given section.  */ 
d5156 1
a5156 1
/* Set backend info for subsections which can not be described 
d5293 2
a5294 2
  if ((bfd_size_type)(offset+count) > section->_raw_size
      || bfd_seek (abfd, (file_ptr)(section->filepos + offset), SEEK_SET) == -1
d5327 1
a5327 1
  offset += som_section_data (section)->subspace_dict->file_loc_init_value; 
d5445 1
a5445 1
  hash_table = 
d5523 1
a5523 1
  hash_table = 
d5546 1
a5546 1
  if (bfd_read ((PTR) som_dict, lst_header->module_count, 
d5611 1
a5611 1
	  if (bfd_seek (abfd, lst_filepos + lst_header->string_loc 
d5636 1
a5636 1
  /* If we haven't died by now, then we successfully read the entire 
d5722 1
a5722 1
  if (bfd_seek (abfd, ardata->first_file_filepos - parsed_size 
d5843 1
a5843 1
   
d5883 1
a5883 1
  memset (last_hash_entry, 0, 	
d5909 1
a5909 1
  /* FIXME should be done with buffers just like everything else... */
d6006 1
a6006 1
		  + lst.hash_size * 4 
d6015 1
a6015 1
		  + lst.hash_size * 4 
a6024 1

d6043 1
a6043 1
 
d6118 1
a6118 1
 
d6223 1
a6223 1
  
d6257 1
a6257 1
/* End of miscellaneous support functions. */
a6296 1

d6350 1
a6350 1
  
@


1.14
log
@Make weak symbols SS_UNIVERSAL (ie. global)
@
text
@d25 1
@


1.13
log
@        * som.c (som_write_symbol_strings): Do not used fixed buffers,
        use size_t as a counter.
        (som_write_space_strings): Similarly.
@
text
@d4072 2
a4073 1
  else if (sym->flags & BSF_EXPORT && ! bfd_is_com_section (sym->section))
@


1.12
log
@        * som.c (struct fixup_format): Constify `format'.
        (som_hppa_howto_table): Use SOM_HOWTO macro.
        (try_prev_fixup, hppa_som_reloc): Decorate unused parameter.
        (som_bfd_reloc_type_lookup): Likewise.
        (compare_subspaces): Remove unused `count1', `count2'.
        (som_begin_writing): Remove unused `total_reloc_size'.
        (som_bfd_derive_misc_symbol_info): Decorate unused parameter.
        (som_print_symbol, som_bfd_is_local_label_name): Likewise.
        (som_set_reloc_info): Constify `cp'. Remove unused `addend'.
        (som_find_nearest_line): Decorate unused parameter(s).
        (som_sizeof_headers, som_get_symbol_info, som_write_armap): Likewise.
        (som_bfd_link_split_section): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 94, 95, 96, 97, 1998
d6 1
a6 1
   University of Utah (pa-gdb-bugs@@cs.utah.edu).
d3049 3
a3051 2
  unsigned char tmp_space[SOM_TMP_BUFSIZE];
  unsigned char *p;
a3054 3
  memset (tmp_space, 0, SOM_TMP_BUFSIZE);
  p = tmp_space;

d3064 1
a3064 1
      int length;
d3075 4
a3078 3
	 current buffer contents now.  Each entry will take 4 bytes to
	 hold the string length + the string itself + null terminator.  */
      if (p - tmp_space + 5 + length > SOM_TMP_BUFSIZE)
d3080 1
d3084 17
a3100 1
	  /* Reset to beginning of the buffer space.  */
d3154 4
a3157 2
  unsigned char tmp_space[SOM_TMP_BUFSIZE];
  unsigned char *p;
a3174 3
  memset (tmp_space, 0, SOM_TMP_BUFSIZE);
  p = tmp_space;

d3184 1
a3184 1
	  int length = strlen (comp[i]);
d3187 3
a3189 2
	     the current buffer contents now.  */
	  if (p - tmp_space + 5 + length > SOM_TMP_BUFSIZE)
d3191 1
d3195 11
a3205 1
	      /* Reset to beginning of the buffer space.  */
d3254 1
a3254 1
      int length = strlen (syms[i]->name);
d3257 2
a3258 2
	 current buffer contents now.  */
     if (p - tmp_space + 5 + length > SOM_TMP_BUFSIZE)
d3260 1
d3264 10
a3273 1
	  /* Reset to beginning of the buffer space.  */
@


1.11
log
@        * som.c (som_decode_symclass):  Recognize weak symbols.
@
text
@d385 1
a385 1
  char *format;
d792 256
a1047 256
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_NO_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_NO_RELOCATION"},
  {R_ZEROES, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ZEROES"},
  {R_ZEROES, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ZEROES"},
  {R_UNINIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_UNINIT"},
  {R_UNINIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_UNINIT"},
  {R_RELOCATION, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RELOCATION"},
  {R_DATA_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_ONE_SYMBOL"},
  {R_DATA_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_ONE_SYMBOL"},
  {R_DATA_PLABEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_PLABEL"},
  {R_DATA_PLABEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_PLABEL"},
  {R_SPACE_REF, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_SPACE_REF"},
  {R_REPEATED_INIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "REPEATED_INIT"},
  {R_REPEATED_INIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "REPEATED_INIT"},
  {R_REPEATED_INIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "REPEATED_INIT"},
  {R_REPEATED_INIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "REPEATED_INIT"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_PCREL_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PCREL_CALL"},
  {R_SHORT_PCREL_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_SHORT_PCREL_MODE"},
  {R_LONG_PCREL_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LONG_PCREL_MODE"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_ABS_CALL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ABS_CALL"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_DP_RELATIVE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DP_RELATIVE"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_DLT_REL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DLT_REL"},
  {R_DLT_REL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DLT_REL"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_CODE_ONE_SYMBOL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_ONE_SYMBOL"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_MILLI_REL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_MILLI_REL"},
  {R_MILLI_REL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_MILLI_REL"},
  {R_CODE_PLABEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_PLABEL"},
  {R_CODE_PLABEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_PLABEL"},
  {R_BREAKPOINT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_BREAKPOINT"},
  {R_ENTRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ENTRY"},
  {R_ENTRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ENTRY"},
  {R_ALT_ENTRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_ALT_ENTRY"},
  {R_EXIT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_EXIT"},
  {R_BEGIN_TRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_BEGIN_TRY"},
  {R_END_TRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_END_TRY"},
  {R_END_TRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_END_TRY"},
  {R_END_TRY, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_END_TRY"},
  {R_BEGIN_BRTAB, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_BEGIN_BRTAB"},
  {R_END_BRTAB, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_END_BRTAB"},
  {R_STATEMENT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_STATEMENT"},
  {R_STATEMENT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_STATEMENT"},
  {R_STATEMENT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_STATEMENT"},
  {R_DATA_EXPR, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_EXPR"},
  {R_CODE_EXPR, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_CODE_EXPR"},
  {R_FSEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_FSEL"},
  {R_LSEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LSEL"},
  {R_RSEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RSEL"},
  {R_N_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_N_MODE"},
  {R_S_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_S_MODE"},
  {R_D_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_D_MODE"},
  {R_R_MODE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_R_MODE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_DATA_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_DATA_OVERRIDE"},
  {R_TRANSLATED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_TRANSLATED"},
  {R_AUX_UNWIND, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_AUX_UNWIND"},
  {R_COMP1, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_COMP1"},
  {R_COMP2, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_COMP2"},
  {R_COMP3, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_COMP3"},
  {R_PREV_FIXUP, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PREV_FIXUP"},
  {R_PREV_FIXUP, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PREV_FIXUP"},
  {R_PREV_FIXUP, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PREV_FIXUP"},
  {R_PREV_FIXUP, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_PREV_FIXUP"},
  {R_SEC_STMT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_SEC_STMT"},
  {R_N0SEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_N0SEL"},
  {R_N1SEL, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_N1SEL"},
  {R_LINETAB, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LINETAB"},
  {R_LINETAB_ESC, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LINETAB_ESC"},
  {R_LTP_OVERRIDE, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_LTP_OVERRIDE"},
  {R_COMMENT, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_COMMENT"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"},
  {R_RESERVED, 0, 0, 32, false, 0, 0, hppa_som_reloc, "R_RESERVED"}};
d1161 1
a1161 1
     bfd *abfd;
d1435 1
a1435 1
     bfd *abfd;
d1437 2
a1438 2
     asymbol *symbol_in;
     PTR data;
d1441 1
a1441 1
     char **error_message;
d1724 1
a1724 1
     bfd *abfd;
a2541 1
  unsigned int count1, count2;
a3281 1
  unsigned int total_reloc_size = 0;
d3948 1
a3948 1
     bfd *abfd;
d4479 1
a4479 1
     bfd *ignore_abfd;
d4508 1
a4508 1
     bfd *abfd;
d4539 1
a4539 1
  char *cp;
a4816 2
		  unsigned addend = var ('V');

d5315 7
a5321 7
     bfd *abfd;
     asection *section;
     asymbol **symbols;
     bfd_vma offset;
     CONST char **filename_ptr;
     CONST char **functionname_ptr;
     unsigned int *line_ptr;
d5328 2
a5329 2
     bfd *abfd;
     boolean reloc;
d5386 1
a5386 1
     bfd *ignore_abfd;
d6075 3
a6077 3
     struct orl *map;
     unsigned int orl_count;
     int stridx;
d6229 1
a6229 1
     bfd *abfd;
@


1.10
log
@        * som.c (SOM_HOWTO): Define.
        (som_hppa_howto_table): Use it.
@
text
@d5368 2
@


1.9
log
@        * som.c (som_misc_symbol_info):  Add field
        secondary_def.
        (som_bfd_derive_misc_symbol_info):  Initialize
        secondary_def.
        (som_build_and_write_symbol_table): Keep track
        of secondary_def field.
        (som_slurp_symbol_table): Set BSF_WEAK symbol flag
        if secondary_def field is set.
        (som_bfd_ar_write_symbol_stuff): Initialize
        secondary_def.
@
text
@d787 3
@


1.8
log
@Revert previous patch.
@
text
@d151 1
d4056 7
d4106 1
d4394 4
d5940 1
a5940 1
	  curr_lst_sym->secondary_def = 0;
@


1.7
log
@Change AR for ELF so that common symbols are not included in archive map.
Change LD for ELF so that archive elements whoes archive map contains a
 reference to a common symbol will get linkled in.
Add new field to bfd_target structure and initialise it for all bfd targets.
@
text
@a6231 1
#define som_allow_commons_in_armap	bfd_true
@


1.6
log
@        * som.c (som_fixup_formats): Improve handling of R_AUX_UNWIND,
        R_LINETAB, R_LINETAB_ESC, and R_COMMENT.
@
text
@d6232 1
@


1.5
log
@
        * som.c (NO_PCREL_MODES): Define if the system does not define
        R_SHORT_PCREL_MODE.
        (hppa_som_gen_reloc_type): Handle both short and long pcrel branches.
        (som_write_fixups): Eliminate redundant pcrel mode relocs.  Handle
        R_LONG_PCREL_MODE and R_SHORT_PCREL_MODE
        * libhppa.h (dis_assemble_22): New function.
        (bfd_hppa_insn2fmt): Handle long branch.

        * libhppa.h (bfd_hppa_insn2fmt): Decode and handle formats found
        in PA2.0.
@
text
@d637 2
a638 2
  /* R_RESERVED */
  0,    "",	        /* 0xcf */
d657 1
a657 1
  0,	"",		/* 0xda */
d659 1
a659 1
  0,	"",		/* 0xdb */
d663 1
a663 1
  0,	"",		/* 0xdd */
@


1.4
log
@        * som.c (som_slurp_symbol_table): Fix typo in comment.
@
text
@d754 1
a1687 1
    case R_HPPA_PCREL_CALL:
d1690 20
d2688 3
d2725 3
d2792 4
d2919 13
@


1.3
log
@Add new field to bfd_target structure.
Initialise this field for all known bfd targets.
Add new search function to targets.c
@
text
@d4294 1
a4294 1
	  /* If the symbol's scope is ST_UNSAT, then these are
@


1.2
log
@M
        * som.c (som_fixup_formats): Fix comments for R_SHORT_PCREL_MODE
        and R_LONG_PCREL_MODE.
@
text
@d6260 2
@


1.1
log
@Initial revision
@
text
@a442 1
  /* R_SHORT_PCREL_MODE */
a443 1
  /* R_LONG_PCREL_MODE */
d460 1
a460 1
  /* R_RESERVED */
d462 1
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

