head	1.16;
access;
symbols
	sid-snapshot-20180601:1.16
	sid-snapshot-20180501:1.16
	sid-snapshot-20180401:1.16
	sid-snapshot-20180301:1.16
	sid-snapshot-20180201:1.16
	sid-snapshot-20180101:1.16
	sid-snapshot-20171201:1.16
	sid-snapshot-20171101:1.16
	sid-snapshot-20171001:1.16
	sid-snapshot-20170901:1.16
	sid-snapshot-20170801:1.16
	sid-snapshot-20170701:1.16
	sid-snapshot-20170601:1.16
	sid-snapshot-20170501:1.16
	sid-snapshot-20170401:1.16
	sid-snapshot-20170301:1.16
	sid-snapshot-20170201:1.16
	sid-snapshot-20170101:1.16
	sid-snapshot-20161201:1.16
	sid-snapshot-20161101:1.16
	sid-snapshot-20160901:1.16
	sid-snapshot-20160801:1.16
	sid-snapshot-20160701:1.16
	sid-snapshot-20160601:1.16
	sid-snapshot-20160501:1.16
	sid-snapshot-20160401:1.16
	sid-snapshot-20160301:1.16
	sid-snapshot-20160201:1.16
	sid-snapshot-20160101:1.16
	sid-snapshot-20151201:1.16
	sid-snapshot-20151101:1.16
	sid-snapshot-20151001:1.16
	sid-snapshot-20150901:1.16
	sid-snapshot-20150801:1.16
	sid-snapshot-20150701:1.16
	sid-snapshot-20150601:1.16
	sid-snapshot-20150501:1.16
	sid-snapshot-20150401:1.16
	sid-snapshot-20150301:1.16
	sid-snapshot-20150201:1.16
	sid-snapshot-20150101:1.16
	sid-snapshot-20141201:1.16
	sid-snapshot-20141101:1.16
	sid-snapshot-20141001:1.16
	sid-snapshot-20140901:1.16
	sid-snapshot-20140801:1.16
	sid-snapshot-20140701:1.16
	sid-snapshot-20140601:1.16
	sid-snapshot-20140501:1.16
	sid-snapshot-20140401:1.16
	sid-snapshot-20140301:1.16
	sid-snapshot-20140201:1.16
	sid-snapshot-20140101:1.16
	sid-snapshot-20131201:1.16
	sid-snapshot-20131101:1.16
	sid-snapshot-20131001:1.16
	binutils-2_24-branch:1.16.0.4
	binutils-2_24-branchpoint:1.16
	binutils-2_21_1:1.13.2.1
	sid-snapshot-20130901:1.16
	gdb_7_6_1-2013-08-30-release:1.16
	sid-snapshot-20130801:1.16
	sid-snapshot-20130701:1.16
	sid-snapshot-20130601:1.16
	sid-snapshot-20130501:1.16
	gdb_7_6-2013-04-26-release:1.16
	sid-snapshot-20130401:1.16
	binutils-2_23_2:1.15.4.1
	gdb_7_6-branch:1.16.0.2
	gdb_7_6-2013-03-12-branchpoint:1.16
	sid-snapshot-20130301:1.16
	sid-snapshot-20130201:1.15
	sid-snapshot-20130101:1.15
	sid-snapshot-20121201:1.15
	gdb_7_5_1-2012-11-29-release:1.15
	binutils-2_23_1:1.15
	sid-snapshot-20121101:1.15
	binutils-2_23:1.15
	sid-snapshot-20121001:1.15
	sid-snapshot-20120901:1.15
	gdb_7_5-2012-08-17-release:1.15
	sid-snapshot-20120801:1.15
	binutils-2_23-branch:1.15.0.4
	binutils-2_23-branchpoint:1.15
	gdb_7_5-branch:1.15.0.2
	gdb_7_5-2012-07-18-branchpoint:1.15
	sid-snapshot-20120701:1.15
	sid-snapshot-20120601:1.15
	sid-snapshot-20120501:1.14
	binutils-2_22_branch:1.14.0.8
	gdb_7_4_1-2012-04-26-release:1.14
	sid-snapshot-20120401:1.14
	sid-snapshot-20120301:1.14
	sid-snapshot-20120201:1.14
	gdb_7_4-2012-01-24-release:1.14
	sid-snapshot-20120101:1.14
	gdb_7_4-branch:1.14.0.6
	gdb_7_4-2011-12-13-branchpoint:1.14
	sid-snapshot-20111201:1.14
	binutils-2_22:1.14
	sid-snapshot-20111101:1.14
	sid-snapshot-20111001:1.14
	binutils-2_22-branch:1.14.0.4
	binutils-2_22-branchpoint:1.14
	gdb_7_3_1-2011-09-04-release:1.14
	sid-snapshot-20110901:1.14
	sid-snapshot-20110801:1.14
	gdb_7_3-2011-07-26-release:1.14
	sid-snapshot-20110701:1.14
	sid-snapshot-20110601:1.14
	sid-snapshot-20110501:1.14
	gdb_7_3-branch:1.14.0.2
	gdb_7_3-2011-04-01-branchpoint:1.14
	sid-snapshot-20110401:1.14
	sid-snapshot-20110301:1.14
	sid-snapshot-20110201:1.14
	sid-snapshot-20110101:1.14
	binutils-2_21:1.13
	sid-snapshot-20101201:1.14
	binutils-2_21-branch:1.13.0.2
	binutils-2_21-branchpoint:1.13
	sid-snapshot-20101101:1.12
	sid-snapshot-20101001:1.12
	binutils-2_20_1:1.9.2.1
	gdb_7_2-2010-09-02-release:1.12
	sid-snapshot-20100901:1.12
	sid-snapshot-20100801:1.12
	gdb_7_2-branch:1.12.0.2
	gdb_7_2-2010-07-07-branchpoint:1.12
	sid-snapshot-20100701:1.12
	sid-snapshot-20100601:1.11
	sid-snapshot-20100501:1.11
	sid-snapshot-20100401:1.11
	gdb_7_1-2010-03-18-release:1.11
	sid-snapshot-20100301:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	sid-snapshot-20100201:1.11
	sid-snapshot-20100101:1.11
	gdb_7_0_1-2009-12-22-release:1.10
	sid-snapshot-20091201:1.10
	sid-snapshot-20091101:1.10
	binutils-2_20:1.9.2.1
	gdb_7_0-2009-10-06-release:1.10
	sid-snapshot-20091001:1.10
	gdb_7_0-branch:1.10.0.2
	gdb_7_0-2009-09-16-branchpoint:1.10
	arc-sim-20090309:1.2
	binutils-arc-20081103-branch:1.2.0.26
	binutils-arc-20081103-branchpoint:1.2
	binutils-2_20-branch:1.9.0.2
	binutils-2_20-branchpoint:1.9
	sid-snapshot-20090901:1.8
	sid-snapshot-20090801:1.8
	msnyder-checkpoint-072509-branch:1.8.0.4
	msnyder-checkpoint-072509-branchpoint:1.8
	sid-snapshot-20090701:1.8
	dje-cgen-play1-branch:1.8.0.2
	dje-cgen-play1-branchpoint:1.8
	sid-snapshot-20090601:1.8
	sid-snapshot-20090501:1.8
	sid-snapshot-20090401:1.8
	arc-20081103-branch:1.2.0.24
	arc-20081103-branchpoint:1.2
	arc-insight_6_8-branch:1.2.0.22
	arc-insight_6_8-branchpoint:1.2
	insight_6_8-branch:1.2.0.20
	insight_6_8-branchpoint:1.2
	sid-snapshot-20090301:1.7
	binutils-2_19_1:1.2
	sid-snapshot-20090201:1.7
	sid-snapshot-20090101:1.2
	reverse-20081226-branch:1.2.0.18
	reverse-20081226-branchpoint:1.2
	sid-snapshot-20081201:1.2
	multiprocess-20081120-branch:1.2.0.16
	multiprocess-20081120-branchpoint:1.2
	sid-snapshot-20081101:1.2
	binutils-2_19:1.2
	sid-snapshot-20081001:1.2
	reverse-20080930-branch:1.2.0.14
	reverse-20080930-branchpoint:1.2
	binutils-2_19-branch:1.2.0.12
	binutils-2_19-branchpoint:1.2
	sid-snapshot-20080901:1.2
	sid-snapshot-20080801:1.2
	reverse-20080717-branch:1.2.0.10
	reverse-20080717-branchpoint:1.2
	sid-snapshot-20080701:1.2
	msnyder-reverse-20080609-branch:1.2.0.8
	msnyder-reverse-20080609-branchpoint:1.2
	sid-snapshot-20080601:1.2
	sid-snapshot-20080501:1.2
	sid-snapshot-20080403:1.2
	sid-snapshot-20080401:1.2
	gdb_6_8-2008-03-27-release:1.2
	sid-snapshot-20080301:1.2
	gdb_6_8-branch:1.2.0.6
	gdb_6_8-2008-02-26-branchpoint:1.2
	sid-snapshot-20080201:1.2
	sid-snapshot-20080101:1.2
	sid-snapshot-20071201:1.2
	sid-snapshot-20071101:1.2
	gdb_6_7_1-2007-10-29-release:1.2
	gdb_6_7-2007-10-10-release:1.2
	sid-snapshot-20071001:1.2
	gdb_6_7-branch:1.2.0.4
	gdb_6_7-2007-09-07-branchpoint:1.2
	binutils-2_18:1.2
	binutils-2_18-branch:1.2.0.2
	binutils-2_18-branchpoint:1.2
	binutils_latest_snapshot:1.16;
locks; strict;
comment	@ * @;


1.16
date	2013.02.07.03.44.26;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2012.05.05.03.05.25;	author amodra;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2010.11.05.13.02.09;	author jsm28;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.04.11.35.00;	author jsm28;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2010.06.15.23.10.10;	author jsm28;	state Exp;
branches;
next	1.11;

1.11
date	2009.12.28.18.37.30;	author dgutson;	state Exp;
branches;
next	1.10;

1.10
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2009.03.28.23.19.00;	author mmitchel;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.29.16.35.03;	author jsm28;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.19.12.14.04;	author ams;	state Exp;
branches;
next	1.5;

1.5
date	2009.01.19.11.55.35;	author ams;	state Exp;
branches;
next	1.4;

1.4
date	2009.01.19.11.50.31;	author ams;	state Exp;
branches;
next	1.3;

1.3
date	2009.01.15.13.03.05;	author ams;	state Exp;
branches;
next	1.2;

1.2
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2007.06.29.16.29.15;	author jsm28;	state Exp;
branches;
next	;

1.15.4.1
date	2013.02.07.03.44.41;	author amodra;	state Exp;
branches;
next	;

1.13.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	;

1.9.2.1
date	2009.09.09.21.40.18;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.16
log
@	PR binutils/14873
	* elf-attrs.c (_bfd_elf_copy_obj_attributes): Don't attempt to
	copy attributes from or to non-ELF.
@
text
@/* ELF attributes support (based on ARM EABI attributes).
   Copyright 2005, 2006, 2007, 2009, 2010, 2012
   Free Software Foundation, Inc.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "libbfd.h"
#include "elf-bfd.h"

/* Return the number of bytes needed by I in uleb128 format.  */
static int
uleb128_size (unsigned int i)
{
  int size;
  size = 1;
  while (i >= 0x80)
    {
      i >>= 7;
      size++;
    }
  return size;
}

/* Return TRUE if the attribute has the default value (0/"").  */
static bfd_boolean
is_default_attr (obj_attribute *attr)
{
  if (ATTR_TYPE_HAS_INT_VAL (attr->type) && attr->i != 0)
    return FALSE;
  if (ATTR_TYPE_HAS_STR_VAL (attr->type) && attr->s && *attr->s)
    return FALSE;
  if (ATTR_TYPE_HAS_NO_DEFAULT (attr->type))
    return FALSE;

  return TRUE;
}

/* Return the size of a single attribute.  */
static bfd_vma
obj_attr_size (int tag, obj_attribute *attr)
{
  bfd_vma size;

  if (is_default_attr (attr))
    return 0;

  size = uleb128_size (tag);
  if (ATTR_TYPE_HAS_INT_VAL (attr->type))
    size += uleb128_size (attr->i);
  if (ATTR_TYPE_HAS_STR_VAL (attr->type))
    size += strlen ((char *)attr->s) + 1;
  return size;
}

/* Return the vendor name for a given object attributes section.  */
static const char *
vendor_obj_attr_name (bfd *abfd, int vendor)
{
  return (vendor == OBJ_ATTR_PROC
	  ? get_elf_backend_data (abfd)->obj_attrs_vendor
	  : "gnu");
}

/* Return the size of the object attributes section for VENDOR
   (OBJ_ATTR_PROC or OBJ_ATTR_GNU), or 0 if there are no attributes
   for that vendor to record and the vendor is OBJ_ATTR_GNU.  */
static bfd_vma
vendor_obj_attr_size (bfd *abfd, int vendor)
{
  bfd_vma size;
  obj_attribute *attr;
  obj_attribute_list *list;
  int i;
  const char *vendor_name = vendor_obj_attr_name (abfd, vendor);

  if (!vendor_name)
    return 0;

  attr = elf_known_obj_attributes (abfd)[vendor];
  size = 0;
  for (i = LEAST_KNOWN_OBJ_ATTRIBUTE; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++)
    size += obj_attr_size (i, &attr[i]);

  for (list = elf_other_obj_attributes (abfd)[vendor];
       list;
       list = list->next)
    size += obj_attr_size (list->tag, &list->attr);

  /* <size> <vendor_name> NUL 0x1 <size> */
  return ((size || vendor == OBJ_ATTR_PROC)
	  ? size + 10 + strlen (vendor_name)
	  : 0);
}

/* Return the size of the object attributes section.  */
bfd_vma
bfd_elf_obj_attr_size (bfd *abfd)
{
  bfd_vma size;

  size = vendor_obj_attr_size (abfd, OBJ_ATTR_PROC);
  size += vendor_obj_attr_size (abfd, OBJ_ATTR_GNU);

  /* 'A' <sections for each vendor> */
  return (size ? size + 1 : 0);
}

/* Write VAL in uleb128 format to P, returning a pointer to the
   following byte.  */
static bfd_byte *
write_uleb128 (bfd_byte *p, unsigned int val)
{
  bfd_byte c;
  do
    {
      c = val & 0x7f;
      val >>= 7;
      if (val)
	c |= 0x80;
      *(p++) = c;
    }
  while (val);
  return p;
}

/* Write attribute ATTR to butter P, and return a pointer to the following
   byte.  */
static bfd_byte *
write_obj_attribute (bfd_byte *p, int tag, obj_attribute *attr)
{
  /* Suppress default entries.  */
  if (is_default_attr (attr))
    return p;

  p = write_uleb128 (p, tag);
  if (ATTR_TYPE_HAS_INT_VAL (attr->type))
    p = write_uleb128 (p, attr->i);
  if (ATTR_TYPE_HAS_STR_VAL (attr->type))
    {
      int len;

      len = strlen (attr->s) + 1;
      memcpy (p, attr->s, len);
      p += len;
    }

  return p;
}

/* Write the contents of the object attributes section (length SIZE)
   for VENDOR to CONTENTS.  */
static void
vendor_set_obj_attr_contents (bfd *abfd, bfd_byte *contents, bfd_vma size,
			      int vendor)
{
  bfd_byte *p;
  obj_attribute *attr;
  obj_attribute_list *list;
  int i;
  const char *vendor_name = vendor_obj_attr_name (abfd, vendor);
  size_t vendor_length = strlen (vendor_name) + 1;

  p = contents;
  bfd_put_32 (abfd, size, p);
  p += 4;
  memcpy (p, vendor_name, vendor_length);
  p += vendor_length;
  *(p++) = Tag_File;
  bfd_put_32 (abfd, size - 4 - vendor_length, p);
  p += 4;

  attr = elf_known_obj_attributes (abfd)[vendor];
  for (i = LEAST_KNOWN_OBJ_ATTRIBUTE; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++)
    {
      int tag = i;
      if (get_elf_backend_data (abfd)->obj_attrs_order)
	tag = get_elf_backend_data (abfd)->obj_attrs_order (i);
      p = write_obj_attribute (p, tag, &attr[tag]);
    }

  for (list = elf_other_obj_attributes (abfd)[vendor];
       list;
       list = list->next)
    p = write_obj_attribute (p, list->tag, &list->attr);
}

/* Write the contents of the object attributes section to CONTENTS.  */
void
bfd_elf_set_obj_attr_contents (bfd *abfd, bfd_byte *contents, bfd_vma size)
{
  bfd_byte *p;
  int vendor;
  bfd_vma my_size;

  p = contents;
  *(p++) = 'A';
  my_size = 1;
  for (vendor = OBJ_ATTR_FIRST; vendor <= OBJ_ATTR_LAST; vendor++)
    {
      bfd_vma vendor_size = vendor_obj_attr_size (abfd, vendor);
      if (vendor_size)
	vendor_set_obj_attr_contents (abfd, p, vendor_size, vendor);
      p += vendor_size;
      my_size += vendor_size;
    }

  if (size != my_size)
    abort ();
}

/* Allocate/find an object attribute.  */
static obj_attribute *
elf_new_obj_attr (bfd *abfd, int vendor, int tag)
{
  obj_attribute *attr;
  obj_attribute_list *list;
  obj_attribute_list *p;
  obj_attribute_list **lastp;


  if (tag < NUM_KNOWN_OBJ_ATTRIBUTES)
    {
      /* Known tags are preallocated.  */
      attr = &elf_known_obj_attributes (abfd)[vendor][tag];
    }
  else
    {
      /* Create a new tag.  */
      list = (obj_attribute_list *)
	bfd_alloc (abfd, sizeof (obj_attribute_list));
      memset (list, 0, sizeof (obj_attribute_list));
      list->tag = tag;
      /* Keep the tag list in order.  */
      lastp = &elf_other_obj_attributes (abfd)[vendor];
      for (p = *lastp; p; p = p->next)
	{
	  if (tag < p->tag)
	    break;
	  lastp = &p->next;
	}
      list->next = *lastp;
      *lastp = list;
      attr = &list->attr;
    }

  return attr;
}

/* Return the value of an integer object attribute.  */
int
bfd_elf_get_obj_attr_int (bfd *abfd, int vendor, int tag)
{
  obj_attribute_list *p;

  if (tag < NUM_KNOWN_OBJ_ATTRIBUTES)
    {
      /* Known tags are preallocated.  */
      return elf_known_obj_attributes (abfd)[vendor][tag].i;
    }
  else
    {
      for (p = elf_other_obj_attributes (abfd)[vendor];
	   p;
	   p = p->next)
	{
	  if (tag == p->tag)
	    return p->attr.i;
	  if (tag < p->tag)
	    break;
	}
      return 0;
    }
}

/* Add an integer object attribute.  */
void
bfd_elf_add_obj_attr_int (bfd *abfd, int vendor, int tag, unsigned int i)
{
  obj_attribute *attr;

  attr = elf_new_obj_attr (abfd, vendor, tag);
  attr->type = _bfd_elf_obj_attrs_arg_type (abfd, vendor, tag);
  attr->i = i;
}

/* Duplicate an object attribute string value.  */
char *
_bfd_elf_attr_strdup (bfd *abfd, const char * s)
{
  char * p;
  int len;

  len = strlen (s) + 1;
  p = (char *) bfd_alloc (abfd, len);
  return (char *) memcpy (p, s, len);
}

/* Add a string object attribute.  */
void
bfd_elf_add_obj_attr_string (bfd *abfd, int vendor, int tag, const char *s)
{
  obj_attribute *attr;

  attr = elf_new_obj_attr (abfd, vendor, tag);
  attr->type = _bfd_elf_obj_attrs_arg_type (abfd, vendor, tag);
  attr->s = _bfd_elf_attr_strdup (abfd, s);
}

/* Add a int+string object attribute.  */
void
bfd_elf_add_obj_attr_int_string (bfd *abfd, int vendor, int tag,
				 unsigned int i, const char *s)
{
  obj_attribute *attr;

  attr = elf_new_obj_attr (abfd, vendor, tag);
  attr->type = _bfd_elf_obj_attrs_arg_type (abfd, vendor, tag);
  attr->i = i;
  attr->s = _bfd_elf_attr_strdup (abfd, s);
}

/* Copy the object attributes from IBFD to OBFD.  */
void
_bfd_elf_copy_obj_attributes (bfd *ibfd, bfd *obfd)
{
  obj_attribute *in_attr;
  obj_attribute *out_attr;
  obj_attribute_list *list;
  int i;
  int vendor;

  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return;

  for (vendor = OBJ_ATTR_FIRST; vendor <= OBJ_ATTR_LAST; vendor++)
    {
      in_attr
	= &elf_known_obj_attributes (ibfd)[vendor][LEAST_KNOWN_OBJ_ATTRIBUTE];
      out_attr
	= &elf_known_obj_attributes (obfd)[vendor][LEAST_KNOWN_OBJ_ATTRIBUTE];
      for (i = LEAST_KNOWN_OBJ_ATTRIBUTE; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++)
	{
	  out_attr->type = in_attr->type;
	  out_attr->i = in_attr->i;
	  if (in_attr->s && *in_attr->s)
	    out_attr->s = _bfd_elf_attr_strdup (obfd, in_attr->s);
	  in_attr++;
	  out_attr++;
	}

      for (list = elf_other_obj_attributes (ibfd)[vendor];
	   list;
	   list = list->next)
	{
	  in_attr = &list->attr;
	  switch (in_attr->type & (ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL))
	    {
	    case ATTR_TYPE_FLAG_INT_VAL:
	      bfd_elf_add_obj_attr_int (obfd, vendor, list->tag, in_attr->i);
	      break;
	    case ATTR_TYPE_FLAG_STR_VAL:
	      bfd_elf_add_obj_attr_string (obfd, vendor, list->tag,
					   in_attr->s);
	      break;
	    case ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL:
	      bfd_elf_add_obj_attr_int_string (obfd, vendor, list->tag,
					       in_attr->i, in_attr->s);
	      break;
	    default:
	      abort ();
	    }
	}
    }
}

/* Determine whether a GNU object attribute tag takes an integer, a
   string or both.  */
static int
gnu_obj_attrs_arg_type (int tag)
{
  /* Except for Tag_compatibility, for GNU attributes we follow the
     same rule ARM ones > 32 follow: odd-numbered tags take strings
     and even-numbered tags take integers.  In addition, tag & 2 is
     nonzero for architecture-independent tags and zero for
     architecture-dependent ones.  */
  if (tag == Tag_compatibility)
    return 3;
  else
    return (tag & 1) != 0 ? 2 : 1;
}

/* Determine what arguments an attribute tag takes.  */
int
_bfd_elf_obj_attrs_arg_type (bfd *abfd, int vendor, int tag)
{
  switch (vendor)
    {
    case OBJ_ATTR_PROC:
      return get_elf_backend_data (abfd)->obj_attrs_arg_type (tag);
      break;
    case OBJ_ATTR_GNU:
      return gnu_obj_attrs_arg_type (tag);
      break;
    default:
      abort ();
    }
}

/* Parse an object attributes section.  */
void
_bfd_elf_parse_attributes (bfd *abfd, Elf_Internal_Shdr * hdr)
{
  bfd_byte *contents;
  bfd_byte *p;
  bfd_vma len;
  const char *std_sec;

  contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
  if (!contents)
    return;
  if (!bfd_get_section_contents (abfd, hdr->bfd_section, contents, 0,
				 hdr->sh_size))
    {
      free (contents);
      return;
    }
  p = contents;
  std_sec = get_elf_backend_data (abfd)->obj_attrs_vendor;
  if (*(p++) == 'A')
    {
      len = hdr->sh_size - 1;
      while (len > 0)
	{
	  int namelen;
	  bfd_vma section_len;
	  int vendor;

	  section_len = bfd_get_32 (abfd, p);
	  p += 4;
	  if (section_len > len)
	    section_len = len;
	  len -= section_len;
	  namelen = strlen ((char *) p) + 1;
	  section_len -= namelen + 4;
	  if (std_sec && strcmp ((char *) p, std_sec) == 0)
	    vendor = OBJ_ATTR_PROC;
	  else if (strcmp ((char *) p, "gnu") == 0)
	    vendor = OBJ_ATTR_GNU;
	  else
	    {
	      /* Other vendor section.  Ignore it.  */
	      p += namelen + section_len;
	      continue;
	    }

	  p += namelen;
	  while (section_len > 0)
	    {
	      int tag;
	      unsigned int n;
	      unsigned int val;
	      bfd_vma subsection_len;
	      bfd_byte *end;

	      tag = read_unsigned_leb128 (abfd, p, &n);
	      p += n;
	      subsection_len = bfd_get_32 (abfd, p);
	      p += 4;
	      if (subsection_len > section_len)
		subsection_len = section_len;
	      section_len -= subsection_len;
	      subsection_len -= n + 4;
	      end = p + subsection_len;
	      switch (tag)
		{
		case Tag_File:
		  while (p < end)
		    {
		      int type;

		      tag = read_unsigned_leb128 (abfd, p, &n);
		      p += n;
		      type = _bfd_elf_obj_attrs_arg_type (abfd, vendor, tag);
		      switch (type & (ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL))
			{
			case ATTR_TYPE_FLAG_INT_VAL | ATTR_TYPE_FLAG_STR_VAL:
			  val = read_unsigned_leb128 (abfd, p, &n);
			  p += n;
			  bfd_elf_add_obj_attr_int_string (abfd, vendor, tag,
							   val, (char *)p);
			  p += strlen ((char *)p) + 1;
			  break;
			case ATTR_TYPE_FLAG_STR_VAL:
			  bfd_elf_add_obj_attr_string (abfd, vendor, tag,
						       (char *)p);
			  p += strlen ((char *)p) + 1;
			  break;
			case ATTR_TYPE_FLAG_INT_VAL:
			  val = read_unsigned_leb128 (abfd, p, &n);
			  p += n;
			  bfd_elf_add_obj_attr_int (abfd, vendor, tag, val);
			  break;
			default:
			  abort ();
			}
		    }
		  break;
		case Tag_Section:
		case Tag_Symbol:
		  /* Don't have anywhere convenient to attach these.
		     Fall through for now.  */
		default:
		  /* Ignore things we don't kow about.  */
		  p += subsection_len;
		  subsection_len = 0;
		  break;
		}
	    }
	}
    }
  free (contents);
}

/* Merge common object attributes from IBFD into OBFD.  Raise an error
   if there are conflicting attributes.  Any processor-specific
   attributes have already been merged.  This must be called from the
   bfd_elfNN_bfd_merge_private_bfd_data hook for each individual
   target, along with any target-specific merging.  Because there are
   no common attributes other than Tag_compatibility at present, and
   non-"gnu" Tag_compatibility is not expected in "gnu" sections, this
   is not presently called for targets without their own
   attributes.  */

bfd_boolean
_bfd_elf_merge_object_attributes (bfd *ibfd, bfd *obfd)
{
  obj_attribute *in_attr;
  obj_attribute *out_attr;
  int vendor;

  /* The only common attribute is currently Tag_compatibility,
     accepted in both processor and "gnu" sections.  */
  for (vendor = OBJ_ATTR_FIRST; vendor <= OBJ_ATTR_LAST; vendor++)
    {
      /* Handle Tag_compatibility.  The tags are only compatible if the flags
	 are identical and, if the flags are '1', the strings are identical.
	 If the flags are non-zero, then we can only use the string "gnu".  */
      in_attr = &elf_known_obj_attributes (ibfd)[vendor][Tag_compatibility];
      out_attr = &elf_known_obj_attributes (obfd)[vendor][Tag_compatibility];

      if (in_attr->i > 0 && strcmp (in_attr->s, "gnu") != 0)
	{
	  _bfd_error_handler
		(_("error: %B: Object has vendor-specific contents that "
		   "must be processed by the '%s' toolchain"),
		 ibfd, in_attr->s);
	  return FALSE;
	}

      if (in_attr->i != out_attr->i
	  || (in_attr->i != 0 && strcmp (in_attr->s, out_attr->s) != 0))
	{
	  _bfd_error_handler (_("error: %B: Object tag '%d, %s' is "
				"incompatible with tag '%d, %s'"),
			      ibfd,
			      in_attr->i, in_attr->s ? in_attr->s : "",
			      out_attr->i, out_attr->s ? out_attr->s : "");
	  return FALSE;
	}
    }

  return TRUE;
}

/* Merge an unknown processor-specific attribute TAG, within the range
   of known attributes, from IBFD into OBFD; return TRUE if the link
   is OK, FALSE if it must fail.  */

bfd_boolean
_bfd_elf_merge_unknown_attribute_low (bfd *ibfd, bfd *obfd, int tag)
{
  obj_attribute *in_attr;
  obj_attribute *out_attr;
  bfd *err_bfd = NULL;
  bfd_boolean result = TRUE;

  in_attr = elf_known_obj_attributes_proc (ibfd);
  out_attr = elf_known_obj_attributes_proc (obfd);

  if (out_attr[tag].i != 0 || out_attr[tag].s != NULL)
    err_bfd = obfd;
  else if (in_attr[tag].i != 0 || in_attr[tag].s != NULL)
    err_bfd = ibfd;

  if (err_bfd != NULL)
    result
      = get_elf_backend_data (err_bfd)->obj_attrs_handle_unknown (err_bfd, tag);

  /* Only pass on attributes that match in both inputs.  */
  if (in_attr[tag].i != out_attr[tag].i
      || (in_attr[tag].s == NULL) != (out_attr[tag].s == NULL)
      || (in_attr[tag].s != NULL && out_attr[tag].s != NULL
	  && strcmp (in_attr[tag].s, out_attr[tag].s) != 0))
    {
      out_attr[tag].i = 0;
      out_attr[tag].s = NULL;
    }

  return result;
}

/* Merge the lists of unknown processor-specific attributes, outside
   the known range, from IBFD into OBFD; return TRUE if the link is
   OK, FALSE if it must fail.  */

bfd_boolean
_bfd_elf_merge_unknown_attribute_list (bfd *ibfd, bfd *obfd)
{
  obj_attribute_list *in_list;
  obj_attribute_list *out_list;
  obj_attribute_list **out_listp;
  bfd_boolean result = TRUE;

  in_list = elf_other_obj_attributes_proc (ibfd);
  out_listp = &elf_other_obj_attributes_proc (obfd);
  out_list = *out_listp;

  for (; in_list || out_list; )
    {
      bfd *err_bfd = NULL;
      int err_tag = 0;

      /* The tags for each list are in numerical order.  */
      /* If the tags are equal, then merge.  */
      if (out_list && (!in_list || in_list->tag > out_list->tag))
	{
	  /* This attribute only exists in obfd.  We can't merge, and we don't
	     know what the tag means, so delete it.  */
	  err_bfd = obfd;
	  err_tag = out_list->tag;
	  *out_listp = out_list->next;
	  out_list = *out_listp;
	}
      else if (in_list && (!out_list || in_list->tag < out_list->tag))
	{
	  /* This attribute only exists in ibfd. We can't merge, and we don't
	     know what the tag means, so ignore it.  */
	  err_bfd = ibfd;
	  err_tag = in_list->tag;
	  in_list = in_list->next;
	}
      else /* The tags are equal.  */
	{
	  /* As present, all attributes in the list are unknown, and
	     therefore can't be merged meaningfully.  */
	  err_bfd = obfd;
	  err_tag = out_list->tag;

	  /*  Only pass on attributes that match in both inputs.  */
	  if (in_list->attr.i != out_list->attr.i
	      || (in_list->attr.s == NULL) != (out_list->attr.s == NULL)
	      || (in_list->attr.s && out_list->attr.s
		  && strcmp (in_list->attr.s, out_list->attr.s) != 0))
	    {
	      /* No match.  Delete the attribute.  */
	      *out_listp = out_list->next;
	      out_list = *out_listp;
	    }
	  else
	    {
	      /* Matched.  Keep the attribute and move to the next.  */
	      out_list = out_list->next;
	      in_list = in_list->next;
	    }
	}

      if (err_bfd)
	result = result
	  && get_elf_backend_data (err_bfd)->obj_attrs_handle_unknown (err_bfd,
								       err_tag);
    }

  return result;
}
@


1.15
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d350 4
@


1.15.4.1
log
@	PR binutils/14873
	* elf-attrs.c (_bfd_elf_copy_obj_attributes): Don't attempt to
	copy attributes from or to non-ELF.
@
text
@a349 4
  if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour
      || bfd_get_flavour (obfd) != bfd_target_elf_flavour)
    return;

@


1.14
log
@	* elf-attrs.c (_bfd_elf_merge_unknown_attribute_low,
	_bfd_elf_merge_unknown_attribute_list): Correct test for matching
	string attributes.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2009, 2010
d431 1
a431 1
  const char *std_section;
d443 1
a443 1
  std_section = get_elf_backend_data (abfd)->obj_attrs_vendor;
d458 1
a458 1
	  namelen = strlen ((char *)p) + 1;
d460 1
a460 1
	  if (std_section && strcmp ((char *)p, std_section) == 0)
d462 1
a462 1
	  else if (strcmp ((char *)p, "gnu") == 0)
@


1.13
log
@	* elf-attrs.c (_bfd_elf_merge_unknown_attribute_low,
	_bfd_elf_merge_unknown_attribute_list): New.
	* elf-bfd.h (struct elf_backend_data): Add
	obj_attrs_handle_unknown.
	(_bfd_elf_merge_unknown_attribute_low,
	_bfd_elf_merge_unknown_attribute_list): Declare.
	* elf32-arm.c (elf32_arm_obj_attrs_handle_unknown): New.  Split
	out from elf32_arm_merge_eabi_attributes.
	(elf32_arm_merge_eabi_attributes): Use
	_bfd_elf_merge_unknown_attribute_low and
	_bfd_elf_merge_unknown_attribute_list.
	(elf_backend_obj_attrs_handle_unknown): Define.
	* elfxx-target.h (elf_backend_obj_attrs_handle_unknown): Define.
	(elfNN_bed): Update initializer.
@
text
@d616 1
a616 1
      || in_attr[tag].s != out_attr[tag].s
d676 1
a676 1
	      || in_list->attr.s != out_list->attr.s
@


1.13.2.1
log
@backport from mainline
@
text
@d616 1
a616 1
      || (in_attr[tag].s == NULL) != (out_attr[tag].s == NULL)
d676 1
a676 1
	      || (in_list->attr.s == NULL) != (out_list->attr.s == NULL)
@


1.12
log
@	* elf-bfd.h (LEAST_KNOWN_OBJ_ATTRIBUTE): Define.
	(struct elf_backend_data): Update comment on obj_attrs_order.
	* elf-attrs.c (vendor_obj_attr_size, vendor_set_obj_attr_contents,
	_bfd_elf_copy_obj_attributes): Use LEAST_KNOWN_OBJ_ATTRIBUTE
	instead of hardcoded 4.
	* elf32-arm.c (elf32_arm_obj_attrs_order): Use
	LEAST_KNOWN_OBJ_ATTRIBUTE and LEAST_KNOWN_OBJ_ATTRIBUTE + 1
	instead of hardcoded 4 and 5.
	(elf32_arm_merge_eabi_attributes): Use LEAST_KNOWN_OBJ_ATTRIBUTE
	instead of hardcoded 4.
@
text
@d589 111
@


1.11
log
@2009-12-28  Daniel Gutson  <dgutson@@codesourcery.com>

        * elf-attrs.c (_bfd_elf_merge_object_attributes): Error
        message rephrased.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2009
d99 1
a99 1
  for (i = 4; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++)
d191 1
a191 1
  for (i = 4; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++)
d352 5
a356 3
      in_attr = &elf_known_obj_attributes (ibfd)[vendor][4];
      out_attr = &elf_known_obj_attributes (obfd)[vendor][4];
      for (i = 4; i < NUM_KNOWN_OBJ_ATTRIBUTES; i++)
@


1.10
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d567 2
a568 1
		(_("error: %B: Must be processed by '%s' toolchain"),
@


1.9
log
@update copyright dates
@
text
@d310 1
a310 1
  
d313 1
a313 1
  return memcpy (p, s, len);
d431 1
a431 1
  contents = bfd_malloc (hdr->sh_size);
@


1.9.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d310 1
a310 1

d313 1
a313 1
  return (char *) memcpy (p, s, len);
d431 1
a431 1
  contents = (bfd_byte *) bfd_malloc (hdr->sh_size);
@


1.8
log
@	* coff-arm.c (coff_arm_merge_private_bfd_data): Use "error:", not
	"ERROR:", in error messages.
	* cpu-arm.c (bfd_arm_merge_machines): Likewise.
	* elf-attrs.c (_bfd_elf_merge_object_attributes): Likewise.
	* elf32-arm.c (tag_cpu_arch_combine): Likewise.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(elf32_arm_merge_private_bfd_data): Likewise.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007
@


1.7
log
@2009-01-29  Daniel Jacobowitz  <dan@@codesourcery.com>
            Mark Shinwell  <shinwell@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>

	* elf-attrs.c, elflink.c, elfxx-mips.c: Correct typos in comments.
@
text
@d567 1
a567 1
		(_("ERROR: %B: Must be processed by '%s' toolchain"),
d575 1
a575 1
	  _bfd_error_handler (_("ERROR: %B: Object tag '%d, %s' is "
@


1.6
log
@2009-01-19  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (vendor_set_obj_attr_contents): Support tag ordering.
	* elf-bfd.h (elf_backend_data): Add obj_attrs_order.
	* elf32-arm.c (elf32_arm_obj_attrs_order): New function.
	(elf_backend_obj_attrs_order): New define.
	* elfxx-target.h (elf_backend_obj_attrs_order): New define.
	(elfNN_bed): Add elf_backend_obj_attrs_order.

	gas/testsuite/
	* gas/arm/attr-order.d: New file.
	* gas/arm/attr-order.s: New file.
@
text
@d241 1
a241 1
      /* Knwon tags are preallocated.  */
d275 1
a275 1
      /* Knwon tags are preallocated.  */
@


1.5
log
@2009-01-19  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (is_default_attr): Substitute magic numbers with macros.
	(obj_attr_size): Likewise.
	(write_obj_attribute): Likewise.
	(_bfd_elf_copy_obj_attributes): Likewise.
	(_bfd_elf_parse_attributes): Likewise.
	* elf-bfd.h (ATTR_TYPE_FLAG_INT_VAL): New define.
	(ATTR_TYPE_FLAG_STR_VAL, ATTR_TYPE_FLAG_NO_DEFAULT): New defines.
	(ATTR_TYPE_HAS_INT_VAL, ATTR_TYPE_HAS_STR_VAL): New defines.
	(ATTR_TYPE_HAS_NO_DEFAULT): New define.
	* elf32-arm.c (elf32_arm_obj_attrs_arg_type): Replace magic numbers
	with macros.
@
text
@d192 6
a197 1
    p = write_obj_attribute (p, i, &attr[i]);
@


1.4
log
@2009-01-19  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (is_default_attr): Support defaultless attributes.
	(bfd_elf_add_obj_attr_int): Get type from _bfd_elf_obj_attrs_arg_type.
	(bfd_elf_add_obj_attr_string): Likewise.
	(bfd_elf_add_obj_attr_int_string): Likewise.
	(_bfd_elf_parse_attributes): Allow for unknown flag bits in type.
	* elf-bfd.h (struct obj_attribute): Document new flag bit.
	* elf32-arm.c (elf32_arm_obj_attrs_arg_type): Specify that
	Tag_nodefaults has no default value.
	(elf32_arm_merge_eabi_attributes): Modify the Tag_nodefaults
	comment to reflect the new state.

	gas/
	* read.c (s_vendor_attribute): Allow for unknown flag bits in type.
@
text
@d46 1
a46 1
  if ((attr->type & 1) && attr->i != 0)
d48 1
a48 1
  if ((attr->type & 2) && attr->s && *attr->s)
d50 1
a50 1
  if (attr->type & 4)
d66 1
a66 1
  if (attr->type & 1)
d68 1
a68 1
  if (attr->type & 2)
d154 1
a154 1
  if (attr->type & 1)
d156 1
a156 1
  if (attr->type & 2)
d364 1
a364 1
	  switch (in_attr->type)
d366 1
a366 1
	    case 1:
d369 1
a369 1
	    case 2:
d373 1
a373 1
	    case 3:
d492 1
a492 1
		      switch (type & 3)
d494 1
a494 1
			case 3:
d501 1
a501 1
			case 2:
d506 1
a506 1
			case 1:
@


1.3
log
@2009-01-15  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (bfd_elf_add_obj_attr_compat): Rename to
	bfd_elf_add_obj_attr_int_string.
	Read Tag_compatibility from its new location in the attribute array,
	rather than the attribute list.
	(_bfd_elf_copy_obj_attributes): bfd_elf_add_obj_attr_compat ->
	bfd_elf_add_obj_attr_int_string.
	(_bfd_elf_parse_attributes): Likewise.
	(_bfd_elf_merge_object_attributes): There's now only one
	Tag_compatibility, and it's in the array, not the list.
	* elf-bfd.h (NUM_KNOWN_OBJ_ATTRIBUTES): Set to 33 to include
	Tag_compatibility.
	(bfd_elf_add_obj_attr_compat): Rename to
	bfd_elf_add_obj_attr_int_string.
	(bfd_elf_add_proc_attr_compat): Rename to
	bfd_elf_add_proc_attr_int_string.
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Explicitly don't handle
	Tag_compatibility.

	gas/
	* read.c (s_vendor_attribute): bfd_elf_add_obj_attr_compat ->
	bfd_elf_add_obj_attr_int_string.
@
text
@d50 2
d295 1
a295 1
  attr->type = 1;
d318 1
a318 1
  attr->type = 2;
d330 1
a330 1
  attr->type = 3;
d492 1
a492 1
		      switch (type)
@


1.2
log
@Switch sources over to use the GPL version 3
@
text
@d320 1
a320 1
/* Add a Tag_compatibility object attribute.  */
d322 2
a323 2
bfd_elf_add_obj_attr_compat (bfd *abfd, int vendor, unsigned int i,
			     const char *s)
d325 1
a325 11
  obj_attribute_list *list;
  obj_attribute_list *p;
  obj_attribute_list **lastp;

  list = (obj_attribute_list *)
    bfd_alloc (abfd, sizeof (obj_attribute_list));
  memset (list, 0, sizeof (obj_attribute_list));
  list->tag = Tag_compatibility;
  list->attr.type = 3;
  list->attr.i = i;
  list->attr.s = _bfd_elf_attr_strdup (abfd, s);
d327 4
a330 13
  lastp = &elf_other_obj_attributes (abfd)[vendor];
  for (p = *lastp; p; p = p->next)
    {
      int cmp;
      if (p->tag != Tag_compatibility)
	break;
      cmp = strcmp(s, p->attr.s);
      if (cmp < 0 || (cmp == 0 && i < p->attr.i))
	break;
      lastp = &p->next;
    }
  list->next = *lastp;
  *lastp = list;
d372 2
a373 2
	      bfd_elf_add_obj_attr_compat (obfd, vendor, in_attr->i,
					   in_attr->s);
d495 2
a496 2
			  bfd_elf_add_obj_attr_compat (abfd, vendor, val,
						       (char *)p);
a544 2
  obj_attribute_list *in_list;
  obj_attribute_list *out_list;
d551 7
a557 3
      in_list = elf_other_obj_attributes (ibfd)[vendor];
      out_list = elf_other_obj_attributes (ibfd)[vendor];
      while (in_list && in_list->tag == Tag_compatibility)
d559 1
a559 6
	  in_attr = &in_list->attr;
	  if (in_attr->i == 0)
	    continue;
	  if (in_attr->i == 1 && strcmp (in_attr->s, "gnu") != 0)
	    {
	      _bfd_error_handler
d562 2
a563 31
	      return FALSE;
	    }
	  if (!out_list || out_list->tag != Tag_compatibility
	      || strcmp (in_attr->s, out_list->attr.s) != 0)
	    {
	      /* Add this compatibility tag to the output.  */
	      bfd_elf_add_proc_attr_compat (obfd, in_attr->i, in_attr->s);
	      continue;
	    }
	  out_attr = &out_list->attr;
	  /* Check all the input tags with the same identifier.  */
	  for (;;)
	    {
	      if (out_list->tag != Tag_compatibility
		  || in_attr->i != out_attr->i
		  || strcmp (in_attr->s, out_attr->s) != 0)
		{
		  _bfd_error_handler
		    (_("ERROR: %B: Incompatible object tag '%s':%d"),
		     ibfd, in_attr->s, in_attr->i);
		  return FALSE;
		}
	      in_list = in_list->next;
	      if (in_list->tag != Tag_compatibility
		  || strcmp (in_attr->s, in_list->attr.s) != 0)
		break;
	      in_attr = &in_list->attr;
	      out_list = out_list->next;
	      if (out_list)
		out_attr = &out_list->attr;
	    }
d565 9
a573 9
	  /* Check the output doesn't have extra tags with this identifier.  */
	  if (out_list && out_list->tag == Tag_compatibility
	      && strcmp (in_attr->s, out_list->attr.s) == 0)
	    {
	      _bfd_error_handler
		(_("ERROR: %B: Incompatible object tag '%s':%d"),
		 ibfd, in_attr->s, out_list->attr.i);
	      return FALSE;
	    }
@


1.1
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@

