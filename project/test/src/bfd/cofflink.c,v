head	1.84;
access;
symbols
	sid-snapshot-20180601:1.84
	sid-snapshot-20180501:1.84
	sid-snapshot-20180401:1.84
	sid-snapshot-20180301:1.84
	sid-snapshot-20180201:1.84
	sid-snapshot-20180101:1.84
	sid-snapshot-20171201:1.84
	sid-snapshot-20171101:1.84
	sid-snapshot-20171001:1.84
	sid-snapshot-20170901:1.84
	sid-snapshot-20170801:1.84
	sid-snapshot-20170701:1.84
	sid-snapshot-20170601:1.84
	sid-snapshot-20170501:1.84
	sid-snapshot-20170401:1.84
	sid-snapshot-20170301:1.84
	sid-snapshot-20170201:1.84
	sid-snapshot-20170101:1.84
	sid-snapshot-20161201:1.84
	sid-snapshot-20161101:1.84
	sid-snapshot-20160901:1.84
	sid-snapshot-20160801:1.84
	sid-snapshot-20160701:1.84
	sid-snapshot-20160601:1.84
	sid-snapshot-20160501:1.84
	sid-snapshot-20160401:1.84
	sid-snapshot-20160301:1.84
	sid-snapshot-20160201:1.84
	sid-snapshot-20160101:1.84
	sid-snapshot-20151201:1.84
	sid-snapshot-20151101:1.84
	sid-snapshot-20151001:1.84
	sid-snapshot-20150901:1.84
	sid-snapshot-20150801:1.84
	sid-snapshot-20150701:1.84
	sid-snapshot-20150601:1.84
	sid-snapshot-20150501:1.84
	sid-snapshot-20150401:1.84
	sid-snapshot-20150301:1.84
	sid-snapshot-20150201:1.84
	sid-snapshot-20150101:1.84
	sid-snapshot-20141201:1.84
	sid-snapshot-20141101:1.84
	sid-snapshot-20141001:1.84
	sid-snapshot-20140901:1.84
	sid-snapshot-20140801:1.84
	sid-snapshot-20140701:1.84
	sid-snapshot-20140601:1.84
	sid-snapshot-20140501:1.84
	sid-snapshot-20140401:1.84
	sid-snapshot-20140301:1.84
	sid-snapshot-20140201:1.84
	sid-snapshot-20140101:1.84
	sid-snapshot-20131201:1.84
	sid-snapshot-20131101:1.84
	sid-snapshot-20131001:1.84
	binutils-2_24-branch:1.84.0.4
	binutils-2_24-branchpoint:1.84
	binutils-2_21_1:1.74.2.2
	sid-snapshot-20130901:1.84
	gdb_7_6_1-2013-08-30-release:1.84
	sid-snapshot-20130801:1.84
	sid-snapshot-20130701:1.84
	sid-snapshot-20130601:1.84
	sid-snapshot-20130501:1.84
	gdb_7_6-2013-04-26-release:1.84
	sid-snapshot-20130401:1.84
	binutils-2_23_2:1.82
	gdb_7_6-branch:1.84.0.2
	gdb_7_6-2013-03-12-branchpoint:1.84
	sid-snapshot-20130301:1.84
	sid-snapshot-20130201:1.84
	sid-snapshot-20130101:1.83
	sid-snapshot-20121201:1.83
	gdb_7_5_1-2012-11-29-release:1.82
	binutils-2_23_1:1.82
	sid-snapshot-20121101:1.83
	binutils-2_23:1.82
	sid-snapshot-20121001:1.82
	sid-snapshot-20120901:1.82
	gdb_7_5-2012-08-17-release:1.82
	sid-snapshot-20120801:1.82
	binutils-2_23-branch:1.82.0.4
	binutils-2_23-branchpoint:1.82
	gdb_7_5-branch:1.82.0.2
	gdb_7_5-2012-07-18-branchpoint:1.82
	sid-snapshot-20120701:1.81
	sid-snapshot-20120601:1.81
	sid-snapshot-20120501:1.80
	binutils-2_22_branch:1.79.0.4
	gdb_7_4_1-2012-04-26-release:1.80
	sid-snapshot-20120401:1.80
	sid-snapshot-20120301:1.80
	sid-snapshot-20120201:1.80
	gdb_7_4-2012-01-24-release:1.80
	sid-snapshot-20120101:1.80
	gdb_7_4-branch:1.80.0.2
	gdb_7_4-2011-12-13-branchpoint:1.80
	sid-snapshot-20111201:1.80
	binutils-2_22:1.79
	sid-snapshot-20111101:1.79
	sid-snapshot-20111001:1.79
	binutils-2_22-branch:1.79.0.2
	binutils-2_22-branchpoint:1.79
	gdb_7_3_1-2011-09-04-release:1.75
	sid-snapshot-20110901:1.79
	sid-snapshot-20110801:1.78
	gdb_7_3-2011-07-26-release:1.75
	sid-snapshot-20110701:1.77
	sid-snapshot-20110601:1.76
	sid-snapshot-20110501:1.75
	gdb_7_3-branch:1.75.0.2
	gdb_7_3-2011-04-01-branchpoint:1.75
	sid-snapshot-20110401:1.75
	sid-snapshot-20110301:1.75
	sid-snapshot-20110201:1.75
	sid-snapshot-20110101:1.75
	binutils-2_21:1.74
	sid-snapshot-20101201:1.74
	binutils-2_21-branch:1.74.0.2
	binutils-2_21-branchpoint:1.74
	sid-snapshot-20101101:1.74
	sid-snapshot-20101001:1.73
	binutils-2_20_1:1.69.2.3
	gdb_7_2-2010-09-02-release:1.73
	sid-snapshot-20100901:1.73
	sid-snapshot-20100801:1.73
	gdb_7_2-branch:1.73.0.4
	gdb_7_2-2010-07-07-branchpoint:1.73
	sid-snapshot-20100701:1.73
	sid-snapshot-20100601:1.73
	sid-snapshot-20100501:1.73
	sid-snapshot-20100401:1.73
	gdb_7_1-2010-03-18-release:1.73
	sid-snapshot-20100301:1.73
	gdb_7_1-branch:1.73.0.2
	gdb_7_1-2010-02-18-branchpoint:1.73
	sid-snapshot-20100201:1.73
	sid-snapshot-20100101:1.73
	gdb_7_0_1-2009-12-22-release:1.71
	sid-snapshot-20091201:1.73
	sid-snapshot-20091101:1.73
	binutils-2_20:1.69.2.3
	gdb_7_0-2009-10-06-release:1.71
	sid-snapshot-20091001:1.71
	gdb_7_0-branch:1.71.0.2
	gdb_7_0-2009-09-16-branchpoint:1.71
	arc-sim-20090309:1.66
	binutils-arc-20081103-branch:1.67.0.8
	binutils-arc-20081103-branchpoint:1.67
	binutils-2_20-branch:1.69.0.2
	binutils-2_20-branchpoint:1.69
	sid-snapshot-20090901:1.68
	sid-snapshot-20090801:1.68
	msnyder-checkpoint-072509-branch:1.68.0.4
	msnyder-checkpoint-072509-branchpoint:1.68
	sid-snapshot-20090701:1.68
	dje-cgen-play1-branch:1.68.0.2
	dje-cgen-play1-branchpoint:1.68
	sid-snapshot-20090601:1.68
	sid-snapshot-20090501:1.67
	sid-snapshot-20090401:1.67
	arc-20081103-branch:1.67.0.6
	arc-20081103-branchpoint:1.67
	arc-insight_6_8-branch:1.66.0.14
	arc-insight_6_8-branchpoint:1.66
	insight_6_8-branch:1.66.0.12
	insight_6_8-branchpoint:1.66
	sid-snapshot-20090301:1.67
	binutils-2_19_1:1.66
	sid-snapshot-20090201:1.67
	sid-snapshot-20090101:1.67
	reverse-20081226-branch:1.67.0.4
	reverse-20081226-branchpoint:1.67
	sid-snapshot-20081201:1.67
	multiprocess-20081120-branch:1.67.0.2
	multiprocess-20081120-branchpoint:1.67
	sid-snapshot-20081101:1.67
	binutils-2_19:1.66
	sid-snapshot-20081001:1.66
	reverse-20080930-branch:1.66.0.10
	reverse-20080930-branchpoint:1.66
	binutils-2_19-branch:1.66.0.8
	binutils-2_19-branchpoint:1.66
	sid-snapshot-20080901:1.66
	sid-snapshot-20080801:1.66
	reverse-20080717-branch:1.66.0.6
	reverse-20080717-branchpoint:1.66
	sid-snapshot-20080701:1.66
	msnyder-reverse-20080609-branch:1.66.0.4
	msnyder-reverse-20080609-branchpoint:1.66
	drow-reverse-20070409-branch:1.62.0.4
	drow-reverse-20070409-branchpoint:1.62
	sid-snapshot-20080601:1.66
	sid-snapshot-20080501:1.66
	sid-snapshot-20080403:1.66
	sid-snapshot-20080401:1.66
	gdb_6_8-2008-03-27-release:1.66
	sid-snapshot-20080301:1.66
	gdb_6_8-branch:1.66.0.2
	gdb_6_8-2008-02-26-branchpoint:1.66
	sid-snapshot-20080201:1.65
	sid-snapshot-20080101:1.65
	sid-snapshot-20071201:1.65
	sid-snapshot-20071101:1.65
	gdb_6_7_1-2007-10-29-release:1.65
	gdb_6_7-2007-10-10-release:1.65
	sid-snapshot-20071001:1.65
	gdb_6_7-branch:1.65.0.4
	gdb_6_7-2007-09-07-branchpoint:1.65
	binutils-2_18:1.65
	binutils-2_18-branch:1.65.0.2
	binutils-2_18-branchpoint:1.65
	insight_6_6-20070208-release:1.62
	binutils-csl-coldfire-4_1-32:1.58
	binutils-csl-sourcerygxx-4_1-32:1.58
	gdb_6_6-2006-12-18-release:1.62
	binutils-csl-innovasic-fido-3_4_4-33:1.58
	binutils-csl-sourcerygxx-3_4_4-32:1.53
	binutils-csl-coldfire-4_1-30:1.58
	binutils-csl-sourcerygxx-4_1-30:1.58
	binutils-csl-coldfire-4_1-28:1.58
	binutils-csl-sourcerygxx-4_1-29:1.58
	binutils-csl-sourcerygxx-4_1-28:1.58
	gdb_6_6-branch:1.62.0.2
	gdb_6_6-2006-11-15-branchpoint:1.62
	binutils-csl-arm-2006q3-27:1.58
	binutils-csl-sourcerygxx-4_1-27:1.58
	binutils-csl-arm-2006q3-26:1.58
	binutils-csl-sourcerygxx-4_1-26:1.58
	binutils-csl-sourcerygxx-4_1-25:1.58
	binutils-csl-sourcerygxx-4_1-24:1.58
	binutils-csl-sourcerygxx-4_1-23:1.58
	insight_6_5-20061003-release:1.59
	gdb-csl-symbian-6_4_50_20060226-12:1.57
	binutils-csl-sourcerygxx-4_1-21:1.58
	binutils-csl-arm-2006q3-21:1.58
	binutils-csl-sourcerygxx-4_1-22:1.58
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.58
	binutils-csl-sourcerygxx-4_1-20:1.58
	binutils-csl-arm-2006q3-19:1.58
	binutils-csl-sourcerygxx-4_1-19:1.58
	binutils-csl-sourcerygxx-4_1-18:1.58
	binutils-csl-renesas-4_1-9:1.58
	gdb-csl-sourcerygxx-3_4_4-25:1.57
	binutils-csl-sourcerygxx-3_4_4-25:1.53
	nickrob-async-20060828-mergepoint:1.60
	gdb-csl-symbian-6_4_50_20060226-11:1.57
	binutils-csl-renesas-4_1-8:1.58
	binutils-csl-renesas-4_1-7:1.58
	binutils-csl-renesas-4_1-6:1.58
	gdb-csl-sourcerygxx-4_1-17:1.57
	binutils-csl-sourcerygxx-4_1-17:1.58
	gdb-csl-20060226-branch-local-2:1.57
	gdb-csl-sourcerygxx-4_1-14:1.57
	binutils-csl-sourcerygxx-4_1-14:1.58
	binutils-csl-sourcerygxx-4_1-15:1.58
	gdb-csl-sourcerygxx-4_1-13:1.57
	binutils-csl-sourcerygxx-4_1-13:1.58
	binutils-2_17:1.58
	gdb-csl-sourcerygxx-4_1-12:1.57
	binutils-csl-sourcerygxx-4_1-12:1.58
	gdb-csl-sourcerygxx-3_4_4-21:1.57
	binutils-csl-sourcerygxx-3_4_4-21:1.58
	gdb_6_5-20060621-release:1.59
	binutils-csl-wrs-linux-3_4_4-24:1.53
	binutils-csl-wrs-linux-3_4_4-23:1.53
	gdb-csl-sourcerygxx-4_1-9:1.57
	binutils-csl-sourcerygxx-4_1-9:1.58
	gdb-csl-sourcerygxx-4_1-8:1.57
	binutils-csl-sourcerygxx-4_1-8:1.58
	gdb-csl-sourcerygxx-4_1-7:1.57
	binutils-csl-sourcerygxx-4_1-7:1.58
	gdb-csl-arm-2006q1-6:1.57
	binutils-csl-arm-2006q1-6:1.58
	gdb-csl-sourcerygxx-4_1-6:1.57
	binutils-csl-sourcerygxx-4_1-6:1.58
	binutils-csl-wrs-linux-3_4_4-22:1.53
	gdb-csl-symbian-6_4_50_20060226-10:1.57
	gdb-csl-symbian-6_4_50_20060226-9:1.57
	gdb-csl-symbian-6_4_50_20060226-8:1.57
	gdb-csl-coldfire-4_1-11:1.57
	binutils-csl-coldfire-4_1-11:1.58
	gdb-csl-sourcerygxx-3_4_4-19:1.57
	binutils-csl-sourcerygxx-3_4_4-19:1.58
	gdb-csl-coldfire-4_1-10:1.57
	gdb_6_5-branch:1.59.0.4
	gdb_6_5-2006-05-14-branchpoint:1.59
	binutils-csl-coldfire-4_1-10:1.58
	gdb-csl-sourcerygxx-4_1-5:1.57
	binutils-csl-sourcerygxx-4_1-5:1.58
	nickrob-async-20060513-branch:1.59.0.2
	nickrob-async-20060513-branchpoint:1.59
	gdb-csl-sourcerygxx-4_1-4:1.57
	binutils-csl-sourcerygxx-4_1-4:1.58
	msnyder-reverse-20060502-branch:1.58.0.10
	msnyder-reverse-20060502-branchpoint:1.58
	binutils-csl-wrs-linux-3_4_4-21:1.53
	gdb-csl-morpho-4_1-4:1.57
	binutils-csl-morpho-4_1-4:1.58
	gdb-csl-sourcerygxx-3_4_4-17:1.57
	binutils-csl-sourcerygxx-3_4_4-17:1.58
	binutils-csl-wrs-linux-3_4_4-20:1.53
	readline_5_1-import-branch:1.58.0.8
	readline_5_1-import-branchpoint:1.58
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.57
	binutils-2_17-branch:1.58.0.6
	binutils-2_17-branchpoint:1.58
	gdb-csl-symbian-20060226-branch:1.57.0.14
	gdb-csl-symbian-20060226-branchpoint:1.57
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.57
	msnyder-reverse-20060331-branch:1.58.0.4
	msnyder-reverse-20060331-branchpoint:1.58
	binutils-csl-2_17-branch:1.58.0.2
	binutils-csl-2_17-branchpoint:1.58
	gdb-csl-available-20060303-branch:1.57.0.12
	gdb-csl-available-20060303-branchpoint:1.57
	gdb-csl-20060226-branch:1.57.0.10
	gdb-csl-20060226-branchpoint:1.57
	gdb_6_4-20051202-release:1.57
	msnyder-fork-checkpoint-branch:1.57.0.8
	msnyder-fork-checkpoint-branchpoint:1.57
	gdb-csl-gxxpro-6_3-branch:1.57.0.6
	gdb-csl-gxxpro-6_3-branchpoint:1.57
	gdb_6_4-branch:1.57.0.4
	gdb_6_4-2005-11-01-branchpoint:1.57
	gdb-csl-arm-20051020-branch:1.57.0.2
	gdb-csl-arm-20051020-branchpoint:1.57
	binutils-csl-gxxpro-3_4-branch:1.53.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.53
	binutils-2_16_1:1.53
	msnyder-tracepoint-checkpoint-branch:1.56.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.56
	gdb-csl-arm-20050325-2005-q1b:1.53
	binutils-csl-arm-2005q1b:1.53
	binutils-2_16:1.53
	gdb-csl-arm-20050325-2005-q1a:1.53
	binutils-csl-arm-2005q1a:1.53
	csl-arm-20050325-branch:1.53.0.6
	csl-arm-20050325-branchpoint:1.53
	binutils-csl-arm-2005q1-branch:1.53.0.4
	binutils-csl-arm-2005q1-branchpoint:1.53
	binutils-2_16-branch:1.53.0.2
	binutils-2_16-branchpoint:1.53
	csl-arm-2004-q3d:1.50
	gdb_6_3-20041109-release:1.49
	gdb_6_3-branch:1.49.0.2
	gdb_6_3-20041019-branchpoint:1.49
	csl-arm-2004-q3:1.49
	drow_intercu-merge-20040921:1.49
	drow_intercu-merge-20040915:1.49
	jimb-gdb_6_2-e500-branch:1.46.0.6
	jimb-gdb_6_2-e500-branchpoint:1.46
	gdb_6_2-20040730-release:1.46
	gdb_6_2-branch:1.46.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.46
	gdb_6_1_1-20040616-release:1.43
	binutils-2_15:1.43
	binutils-2_15-branchpoint:1.43
	csl-arm-2004-q1a:1.43
	csl-arm-2004-q1:1.43
	gdb_6_1-2004-04-05-release:1.43
	drow_intercu-merge-20040402:1.43
	drow_intercu-merge-20040327:1.43
	ezannoni_pie-20040323-branch:1.43.0.14
	ezannoni_pie-20040323-branchpoint:1.43
	cagney_tramp-20040321-mergepoint:1.43
	cagney_tramp-20040309-branch:1.43.0.12
	cagney_tramp-20040309-branchpoint:1.43
	gdb_6_1-branch:1.43.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.43
	drow_intercu-20040221-branch:1.43.0.8
	drow_intercu-20040221-branchpoint:1.43
	binutils-2_15-branch:1.43.0.6
	cagney_bfdfile-20040213-branch:1.43.0.4
	cagney_bfdfile-20040213-branchpoint:1.43
	drow-cplus-merge-20040208:1.43
	carlton_dictionary-20040126-merge:1.43
	cagney_bigcore-20040122-branch:1.43.0.2
	cagney_bigcore-20040122-branchpoint:1.43
	drow-cplus-merge-20040113:1.43
	csl-arm-2003-q4:1.43
	drow-cplus-merge-20031224:1.43
	drow-cplus-merge-20031220:1.43
	carlton_dictionary-20031215-merge:1.43
	drow-cplus-merge-20031214:1.43
	carlton-dictionary-20031111-merge:1.42
	gdb_6_0-2003-10-04-release:1.36
	kettenis_sparc-20030918-branch:1.39.0.4
	kettenis_sparc-20030918-branchpoint:1.39
	carlton_dictionary-20030917-merge:1.39
	ezannoni_pie-20030916-branchpoint:1.39
	ezannoni_pie-20030916-branch:1.39.0.2
	cagney_x86i386-20030821-branch:1.37.0.2
	cagney_x86i386-20030821-branchpoint:1.37
	carlton_dictionary-20030805-merge:1.37
	carlton_dictionary-20030627-merge:1.37
	gdb_6_0-branch:1.36.0.36
	gdb_6_0-2003-06-23-branchpoint:1.36
	jimb-ppc64-linux-20030613-branch:1.36.0.34
	jimb-ppc64-linux-20030613-branchpoint:1.36
	binutils-2_14:1.36
	cagney_convert-20030606-branch:1.36.0.32
	cagney_convert-20030606-branchpoint:1.36
	cagney_writestrings-20030508-branch:1.36.0.30
	cagney_writestrings-20030508-branchpoint:1.36
	jimb-ppc64-linux-20030528-branch:1.36.0.28
	jimb-ppc64-linux-20030528-branchpoint:1.36
	carlton_dictionary-20030523-merge:1.36
	cagney_fileio-20030521-branch:1.36.0.26
	cagney_fileio-20030521-branchpoint:1.36
	kettenis_i386newframe-20030517-mergepoint:1.36
	jimb-ppc64-linux-20030509-branch:1.36.0.24
	jimb-ppc64-linux-20030509-branchpoint:1.36
	kettenis_i386newframe-20030504-mergepoint:1.36
	carlton_dictionary-20030430-merge:1.36
	binutils-2_14-branch:1.36.0.22
	binutils-2_14-branchpoint:1.36
	kettenis_i386newframe-20030419-branch:1.36.0.20
	kettenis_i386newframe-20030419-branchpoint:1.36
	carlton_dictionary-20030416-merge:1.36
	cagney_frameaddr-20030409-mergepoint:1.36
	kettenis_i386newframe-20030406-branch:1.36.0.18
	kettenis_i386newframe-20030406-branchpoint:1.36
	cagney_frameaddr-20030403-branchpoint:1.36
	cagney_frameaddr-20030403-branch:1.36.0.16
	cagney_framebase-20030330-mergepoint:1.36
	cagney_framebase-20030326-branch:1.36.0.14
	cagney_framebase-20030326-branchpoint:1.36
	cagney_lazyid-20030317-branch:1.36.0.12
	cagney_lazyid-20030317-branchpoint:1.36
	kettenis-i386newframe-20030316-mergepoint:1.36
	offbyone-20030313-branch:1.36.0.10
	offbyone-20030313-branchpoint:1.36
	kettenis-i386newframe-20030308-branch:1.36.0.8
	kettenis-i386newframe-20030308-branchpoint:1.36
	carlton_dictionary-20030305-merge:1.36
	cagney_offbyone-20030303-branch:1.36.0.6
	cagney_offbyone-20030303-branchpoint:1.36
	carlton_dictionary-20030207-merge:1.36
	interps-20030202-branch:1.36.0.4
	interps-20030202-branchpoint:1.36
	cagney-unwind-20030108-branch:1.36.0.2
	cagney-unwind-20030108-branchpoint:1.36
	binutils-2_13_2_1:1.34.2.1
	binutils-2_13_2:1.34.2.1
	carlton_dictionary-20021223-merge:1.36
	gdb_5_3-2002-12-12-release:1.34
	carlton_dictionary-20021115-merge:1.35
	binutils-2_13_1:1.34.2.1
	kseitz_interps-20021105-merge:1.35
	kseitz_interps-20021103-merge:1.35
	drow-cplus-merge-20021020:1.35
	drow-cplus-merge-20021025:1.35
	carlton_dictionary-20021025-merge:1.35
	carlton_dictionary-20021011-merge:1.35
	drow-cplus-branch:1.34.0.14
	drow-cplus-branchpoint:1.34
	kseitz_interps-20020930-merge:1.34
	carlton_dictionary-20020927-merge:1.34
	carlton_dictionary-branch:1.34.0.12
	carlton_dictionary-20020920-branchpoint:1.34
	sid-20020905-branchpoint:1.34
	sid-20020905-branch:1.34.0.10
	gdb_5_3-branch:1.34.0.8
	gdb_5_3-2002-09-04-branchpoint:1.34
	kseitz_interps-20020829-merge:1.34
	cagney_sysregs-20020825-branch:1.34.0.6
	cagney_sysregs-20020825-branchpoint:1.34
	readline_4_3-import-branch:1.34.0.4
	readline_4_3-import-branchpoint:1.34
	binutils-2_13:1.34
	gdb_5_2_1-2002-07-23-release:1.30
	binutils-2_13-branchpoint:1.34
	binutils-2_13-branch:1.34.0.2
	kseitz_interps-20020528-branch:1.32.0.6
	kseitz_interps-20020528-branchpoint:1.32
	cagney_regbuf-20020515-branch:1.32.0.4
	cagney_regbuf-20020515-branchpoint:1.32
	binutils-2_12_1:1.30.2.1
	jimb-macro-020506-branch:1.32.0.2
	jimb-macro-020506-branchpoint:1.32
	gdb_5_2-2002-04-29-release:1.30
	binutils-2_12:1.30
	gdb_5_2-branch:1.30.0.4
	gdb_5_2-2002-03-03-branchpoint:1.30
	binutils-2_12-branch:1.30.0.2
	binutils-2_12-branchpoint:1.30
	gdb_5_1_1-2002-01-24-release:1.24
	gdb_5_1_0_1-2002-01-03-release:1.24
	cygnus_cvs_20020108_pre:1.30
	gdb_5_1_0_1-2002-01-03-branch:1.24.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.24
	gdb_5_1-2001-11-21-release:1.24
	gdb_s390-2001-09-26-branch:1.24.0.4
	gdb_s390-2001-09-26-branchpoint:1.24
	gdb_5_1-2001-07-29-branch:1.24.0.2
	gdb_5_1-2001-07-29-branchpoint:1.24
	binutils-2_11_2:1.22.2.1
	binutils-2_11_1:1.22.2.1
	binutils-2_11:1.22
	x86_64versiong3:1.22
	binutils-2_11-branch:1.22.0.2
	insight-precleanup-2001-01-01:1.21
	binutils-2_10_1:1.15
	binutils-2_10:1.15
	gdb-premipsmulti-2000-06-06-branch:1.15.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.15
	gdb_5_0-2000-05-19-release:1.15
	gdb_4_18_2-2000-05-18-release:1.15
	gdb_4_95_1-2000-05-11-snapshot:1.15
	gdb_4_95_0-2000-04-27-snapshot:1.15
	gdb_5_0-2000-04-10-branch:1.15.0.4
	gdb_5_0-2000-04-10-branchpoint:1.15
	binutils-2_10-branch:1.15.0.2
	binutils-2_10-branchpoint:1.15
	binutils_latest_snapshot:1.84
	repo-unification-2000-02-06:1.14
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.84
date	2013.01.10.20.03.52;	author hjl;	state Exp;
branches;
next	1.83;

1.83
date	2012.10.18.17.42.29;	author ktietz;	state Exp;
branches;
next	1.82;

1.82
date	2012.07.13.14.22.45;	author nickc;	state Exp;
branches;
next	1.81;

1.81
date	2012.05.01.16.07.33;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2011.11.02.14.53.03;	author jbeulich;	state Exp;
branches;
next	1.79;

1.79
date	2011.08.17.00.39.38;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2011.07.09.06.20.50;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2011.06.13.00.59.09;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2011.05.07.14.29.08;	author davek;	state Exp;
branches;
next	1.75;

1.75
date	2010.12.13.01.06.15;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2010.10.14.01.31.26;	author davek;	state Exp;
branches
	1.74.2.1;
next	1.73;

1.73
date	2009.10.10.04.58.48;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2009.10.01.19.48.12;	author davek;	state Exp;
branches;
next	1.71;

1.71
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2009.09.05.07.56.22;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2009.05.19.16.08.03;	author davek;	state Exp;
branches;
next	1.67;

1.67
date	2008.10.09.09.00.07;	author ktietz;	state Exp;
branches;
next	1.66;

1.66
date	2008.02.15.03.35.52;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2007.07.27.22.04.23;	author msnyder;	state Exp;
branches;
next	1.64;

1.64
date	2007.07.03.14.26.40;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2006.09.17.14.38.51;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2006.09.16.18.12.13;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2006.07.05.10.21.39;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.04.05.05.25;	author bje;	state Exp;
branches;
next	1.58;

1.58
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2005.08.17.08.58.01;	author dannysmith;	state Exp;
branches;
next	1.56;

1.56
date	2005.05.04.15.53.05;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2005.05.04.11.00.08;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.20.14.59.06;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2005.01.31.23.13.17;	author bje;	state Exp;
branches;
next	1.51;

1.51
date	2004.11.08.08.51.47;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2004.10.21.15.28.19;	author hjl;	state Exp;
branches;
next	1.49;

1.49
date	2004.08.18.09.44.11;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2004.08.13.03.15.56;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2004.07.21.15.42.57;	author hjl;	state Exp;
branches;
next	1.46;

1.46
date	2004.07.03.16.07.47;	author cgf;	state Exp;
branches;
next	1.45;

1.45
date	2004.06.28.13.57.58;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2004.06.24.04.46.16;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2003.11.24.18.06.40;	author kazu;	state Exp;
branches
	1.43.8.1;
next	1.42;

1.42
date	2003.10.09.18.15.59;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2003.10.07.08.53.41;	author nathan;	state Exp;
branches;
next	1.40;

1.40
date	2003.10.07.08.49.11;	author nathan;	state Exp;
branches;
next	1.39;

1.39
date	2003.09.03.16.06.12;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2003.08.21.16.20.39;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2003.06.25.06.40.19;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.30.08.39.36;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2002.10.07.16.27.39;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.08.05.34.07;	author mmitchel;	state Exp;
branches
	1.34.2.1
	1.34.12.1
	1.34.14.1;
next	1.33;

1.33
date	2002.06.07.15.04.47;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.04.19.53.35;	author drow;	state Exp;
branches
	1.32.4.1
	1.32.6.1;
next	1.31;

1.31
date	2002.03.28.03.27.42;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2001.10.10.12.08.27;	author kazu;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2001.09.29.12.07.00;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.20.23.30.34;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.18.09.57.22;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.17.08.57.42;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.08.02.23.05.54;	author cwilson;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.03.15.49.46;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2001.03.08.21.03.57;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.23.11.45.52;	author kazu;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2000.11.28.01.33.15;	author kazu;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.27.12.45.17;	author pb;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.27.11.08.15;	author pb;	state Exp;
branches;
next	1.18;

1.18
date	2000.07.03.18.45.18;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.06.19.01.22.37;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.16.20.35.08;	author nsd;	state Exp;
branches;
next	1.15;

1.15
date	2000.03.01.19.40.53;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2000.01.13.22.10.36;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	99.09.12.16.28.20;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	99.09.11.22.04.16;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	99.09.11.21.27.15;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	99.09.11.21.15.16;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.09.11.15.26.22;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.09.07.02.58.00;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.08.19.00.55.50;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.08.18.06.00.13;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.08.05.21.01.37;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.07.24.03.16.49;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.07.22.00.29.35;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.12.10.28.53;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.74.2.1
date	2011.02.01.12.25.33;	author amodra;	state Exp;
branches;
next	1.74.2.2;

1.74.2.2
date	2011.05.29.04.51.02;	author amodra;	state Exp;
branches;
next	;

1.69.2.1
date	2009.09.05.08.00.19;	author nickc;	state Exp;
branches;
next	1.69.2.2;

1.69.2.2
date	2009.09.09.21.40.18;	author nickc;	state Exp;
branches;
next	1.69.2.3;

1.69.2.3
date	2009.10.02.14.40.18;	author davek;	state Exp;
branches;
next	;

1.43.8.1
date	2004.09.16.17.00.14;	author drow;	state Exp;
branches;
next	;

1.34.2.1
date	2002.10.28.18.45.43;	author drow;	state Exp;
branches;
next	;

1.34.12.1
date	2002.10.11.22.22.46;	author carlton;	state Exp;
branches;
next	1.34.12.2;

1.34.12.2
date	2002.12.23.19.37.30;	author carlton;	state Exp;
branches;
next	1.34.12.3;

1.34.12.3
date	2003.06.27.21.49.08;	author carlton;	state Exp;
branches;
next	1.34.12.4;

1.34.12.4
date	2003.09.17.21.27.48;	author carlton;	state Exp;
branches;
next	1.34.12.5;

1.34.12.5
date	2003.11.11.23.50.09;	author carlton;	state Exp;
branches;
next	1.34.12.6;

1.34.12.6
date	2003.12.15.23.59.15;	author carlton;	state Exp;
branches;
next	;

1.34.14.1
date	2002.10.26.17.11.56;	author drow;	state Exp;
branches;
next	1.34.14.2;

1.34.14.2
date	2003.12.14.20.26.35;	author drow;	state Exp;
branches;
next	;

1.32.4.1
date	2002.06.15.16.42.35;	author cagney;	state Exp;
branches;
next	;

1.32.6.1
date	2002.06.20.01.29.47;	author kseitz;	state Exp;
branches;
next	1.32.6.2;

1.32.6.2
date	2002.07.22.21.46.39;	author kseitz;	state Exp;
branches;
next	1.32.6.3;

1.32.6.3
date	2002.11.03.22.01.34;	author ezannoni;	state Exp;
branches;
next	;

1.30.2.1
date	2002.04.04.14.52.54;	author amodra;	state Exp;
branches;
next	;

1.22.2.1
date	2001.06.07.03.08.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.55;	author rth;	state Exp;
branches;
next	;


desc
@@


1.84
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@/* COFF specific linker code.
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2009, 2011 Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/* This file contains the COFF backend linker code.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "libcoff.h"
#include "safe-ctype.h"

static bfd_boolean coff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info);
static bfd_boolean coff_link_check_archive_element (bfd *abfd, struct bfd_link_info *info, bfd_boolean *pneeded);
static bfd_boolean coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info);

/* Return TRUE if SYM is a weak, external symbol.  */
#define IS_WEAK_EXTERNAL(abfd, sym)			\
  ((sym).n_sclass == C_WEAKEXT				\
   || (obj_pe (abfd) && (sym).n_sclass == C_NT_WEAK))

/* Return TRUE if SYM is an external symbol.  */
#define IS_EXTERNAL(abfd, sym)				\
  ((sym).n_sclass == C_EXT || IS_WEAK_EXTERNAL (abfd, sym))

/* Define macros so that the ISFCN, et. al., macros work correctly.
   These macros are defined in include/coff/internal.h in terms of
   N_TMASK, etc.  These definitions require a user to define local
   variables with the appropriate names, and with values from the
   coff_data (abfd) structure.  */

#define N_TMASK n_tmask
#define N_BTSHFT n_btshft
#define N_BTMASK n_btmask

/* Create an entry in a COFF linker hash table.  */

struct bfd_hash_entry *
_bfd_coff_link_hash_newfunc (struct bfd_hash_entry *entry,
			     struct bfd_hash_table *table,
			     const char *string)
{
  struct coff_link_hash_entry *ret = (struct coff_link_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct coff_link_hash_entry *) NULL)
    ret = ((struct coff_link_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct coff_link_hash_entry)));
  if (ret == (struct coff_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct coff_link_hash_entry *)
	 _bfd_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				 table, string));
  if (ret != (struct coff_link_hash_entry *) NULL)
    {
      /* Set local fields.  */
      ret->indx = -1;
      ret->type = T_NULL;
      ret->symbol_class = C_NULL;
      ret->numaux = 0;
      ret->auxbfd = NULL;
      ret->aux = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Initialize a COFF linker hash table.  */

bfd_boolean
_bfd_coff_link_hash_table_init (struct coff_link_hash_table *table,
				bfd *abfd,
				struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
								   struct bfd_hash_table *,
								   const char *),
				unsigned int entsize)
{
  memset (&table->stab_info, 0, sizeof (table->stab_info));
  return _bfd_link_hash_table_init (&table->root, abfd, newfunc, entsize);
}

/* Create a COFF linker hash table.  */

struct bfd_link_hash_table *
_bfd_coff_link_hash_table_create (bfd *abfd)
{
  struct coff_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct coff_link_hash_table);

  ret = (struct coff_link_hash_table *) bfd_malloc (amt);
  if (ret == NULL)
    return NULL;

  if (! _bfd_coff_link_hash_table_init (ret, abfd,
					_bfd_coff_link_hash_newfunc,
					sizeof (struct coff_link_hash_entry)))
    {
      free (ret);
      return (struct bfd_link_hash_table *) NULL;
    }
  return &ret->root;
}

/* Create an entry in a COFF debug merge hash table.  */

struct bfd_hash_entry *
_bfd_coff_debug_merge_hash_newfunc (struct bfd_hash_entry *entry,
				    struct bfd_hash_table *table,
				    const char *string)
{
  struct coff_debug_merge_hash_entry *ret =
    (struct coff_debug_merge_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct coff_debug_merge_hash_entry *) NULL)
    ret = ((struct coff_debug_merge_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct coff_debug_merge_hash_entry)));
  if (ret == (struct coff_debug_merge_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

  /* Call the allocation method of the superclass.  */
  ret = ((struct coff_debug_merge_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
  if (ret != (struct coff_debug_merge_hash_entry *) NULL)
    {
      /* Set local fields.  */
      ret->types = NULL;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Given a COFF BFD, add symbols to the global hash table as
   appropriate.  */

bfd_boolean
_bfd_coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
{
  switch (bfd_get_format (abfd))
    {
    case bfd_object:
      return coff_link_add_object_symbols (abfd, info);
    case bfd_archive:
      return _bfd_generic_link_add_archive_symbols
	(abfd, info, coff_link_check_archive_element);
    default:
      bfd_set_error (bfd_error_wrong_format);
      return FALSE;
    }
}

/* Add symbols from a COFF object file.  */

static bfd_boolean
coff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
{
  if (! _bfd_coff_get_external_symbols (abfd))
    return FALSE;
  if (! coff_link_add_symbols (abfd, info))
    return FALSE;

  if (! info->keep_memory
      && ! _bfd_coff_free_symbols (abfd))
    return FALSE;

  return TRUE;
}

/* Look through the symbols to see if this object file should be
   included in the link.  */

static bfd_boolean
coff_link_check_ar_symbols (bfd *abfd,
			    struct bfd_link_info *info,
			    bfd_boolean *pneeded,
			    bfd **subsbfd)
{
  bfd_size_type symesz;
  bfd_byte *esym;
  bfd_byte *esym_end;

  *pneeded = FALSE;

  symesz = bfd_coff_symesz (abfd);
  esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esym_end = esym + obj_raw_syment_count (abfd) * symesz;
  while (esym < esym_end)
    {
      struct internal_syment sym;
      enum coff_symbol_classification classification;

      bfd_coff_swap_sym_in (abfd, esym, &sym);

      classification = bfd_coff_classify_symbol (abfd, &sym);
      if (classification == COFF_SYMBOL_GLOBAL
	  || classification == COFF_SYMBOL_COMMON)
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];
	  struct bfd_link_hash_entry *h;

	  /* This symbol is externally visible, and is defined by this
             object file.  */
	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
	  if (name == NULL)
	    return FALSE;
	  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

	  /* Auto import.  */
	  if (!h
	      && info->pei386_auto_import
	      && CONST_STRNEQ (name, "__imp_"))
	    h = bfd_link_hash_lookup (info->hash, name + 6, FALSE, FALSE, TRUE);

	  /* We are only interested in symbols that are currently
	     undefined.  If a symbol is currently known to be common,
	     COFF linkers do not bring in an object file which defines
	     it.  */
	  if (h != (struct bfd_link_hash_entry *) NULL
	      && h->type == bfd_link_hash_undefined)
	    {
	      if (!(*info->callbacks
		    ->add_archive_element) (info, abfd, name, subsbfd))
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
	    }
	}

      esym += (sym.n_numaux + 1) * symesz;
    }

  /* We do not need this object file.  */
  return TRUE;
}

/* Check a single archive element to see if we need to include it in
   the link.  *PNEEDED is set according to whether this element is
   needed in the link or not.  This is called via
   _bfd_generic_link_add_archive_symbols.  */

static bfd_boolean
coff_link_check_archive_element (bfd *abfd,
				 struct bfd_link_info *info,
				 bfd_boolean *pneeded)
{
  bfd *oldbfd;
  bfd_boolean needed;

  if (!_bfd_coff_get_external_symbols (abfd))
    return FALSE;

  oldbfd = abfd;
  if (!coff_link_check_ar_symbols (abfd, info, pneeded, &abfd))
    return FALSE;

  needed = *pneeded;
  if (needed)
    {
      /* Potentially, the add_archive_element hook may have set a
	 substitute BFD for us.  */
      if (abfd != oldbfd)
	{
	  if (!info->keep_memory
	      && !_bfd_coff_free_symbols (oldbfd))
	    return FALSE;
	  if (!_bfd_coff_get_external_symbols (abfd))
	    return FALSE;
	}
      if (!coff_link_add_symbols (abfd, info))
	return FALSE;
    }

  if (!info->keep_memory || !needed)
    {
      if (!_bfd_coff_free_symbols (abfd))
	return FALSE;
    }
  return TRUE;
}

/* Add all the symbols from an object file to the hash table.  */

static bfd_boolean
coff_link_add_symbols (bfd *abfd,
		       struct bfd_link_info *info)
{
  unsigned int n_tmask = coff_data (abfd)->local_n_tmask;
  unsigned int n_btshft = coff_data (abfd)->local_n_btshft;
  unsigned int n_btmask = coff_data (abfd)->local_n_btmask;
  bfd_boolean keep_syms;
  bfd_boolean default_copy;
  bfd_size_type symcount;
  struct coff_link_hash_entry **sym_hash;
  bfd_size_type symesz;
  bfd_byte *esym;
  bfd_byte *esym_end;
  bfd_size_type amt;

  symcount = obj_raw_syment_count (abfd);

  if (symcount == 0)
    return TRUE;		/* Nothing to do.  */

  /* Keep the symbols during this function, in case the linker needs
     to read the generic symbols in order to report an error message.  */
  keep_syms = obj_coff_keep_syms (abfd);
  obj_coff_keep_syms (abfd) = TRUE;

  if (info->keep_memory)
    default_copy = FALSE;
  else
    default_copy = TRUE;

  /* We keep a list of the linker hash table entries that correspond
     to particular symbols.  */
  amt = symcount * sizeof (struct coff_link_hash_entry *);
  sym_hash = (struct coff_link_hash_entry **) bfd_zalloc (abfd, amt);
  if (sym_hash == NULL)
    goto error_return;
  obj_coff_sym_hashes (abfd) = sym_hash;

  symesz = bfd_coff_symesz (abfd);
  BFD_ASSERT (symesz == bfd_coff_auxesz (abfd));
  esym = (bfd_byte *) obj_coff_external_syms (abfd);
  esym_end = esym + symcount * symesz;
  while (esym < esym_end)
    {
      struct internal_syment sym;
      enum coff_symbol_classification classification;
      bfd_boolean copy;

      bfd_coff_swap_sym_in (abfd, esym, &sym);

      classification = bfd_coff_classify_symbol (abfd, &sym);
      if (classification != COFF_SYMBOL_LOCAL)
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];
	  flagword flags;
	  asection *section;
	  bfd_vma value;
	  bfd_boolean addit;

	  /* This symbol is externally visible.  */

	  name = _bfd_coff_internal_syment_name (abfd, &sym, buf);
	  if (name == NULL)
	    goto error_return;

	  /* We must copy the name into memory if we got it from the
             syment itself, rather than the string table.  */
	  copy = default_copy;
	  if (sym._n._n_n._n_zeroes != 0
	      || sym._n._n_n._n_offset == 0)
	    copy = TRUE;

	  value = sym.n_value;

	  switch (classification)
	    {
	    default:
	      abort ();

	    case COFF_SYMBOL_GLOBAL:
	      flags = BSF_EXPORT | BSF_GLOBAL;
	      section = coff_section_from_bfd_index (abfd, sym.n_scnum);
	      if (! obj_pe (abfd))
		value -= section->vma;
	      break;

	    case COFF_SYMBOL_UNDEFINED:
	      flags = 0;
	      section = bfd_und_section_ptr;
	      break;

	    case COFF_SYMBOL_COMMON:
	      flags = BSF_GLOBAL;
	      section = bfd_com_section_ptr;
	      break;

	    case COFF_SYMBOL_PE_SECTION:
	      flags = BSF_SECTION_SYM | BSF_GLOBAL;
	      section = coff_section_from_bfd_index (abfd, sym.n_scnum);
	      break;
	    }

	  if (IS_WEAK_EXTERNAL (abfd, sym))
	    flags = BSF_WEAK;

	  addit = TRUE;

	  /* In the PE format, section symbols actually refer to the
             start of the output section.  We handle them specially
             here.  */
	  if (obj_pe (abfd) && (flags & BSF_SECTION_SYM) != 0)
	    {
	      *sym_hash = coff_link_hash_lookup (coff_hash_table (info),
						 name, FALSE, copy, FALSE);
	      if (*sym_hash != NULL)
		{
		  if (((*sym_hash)->coff_link_hash_flags
		       & COFF_LINK_HASH_PE_SECTION_SYMBOL) == 0
		      && (*sym_hash)->root.type != bfd_link_hash_undefined
		      && (*sym_hash)->root.type != bfd_link_hash_undefweak)
		    (*_bfd_error_handler)
		      ("Warning: symbol `%s' is both section and non-section",
		       name);

		  addit = FALSE;
		}
	    }

	  /* The Microsoft Visual C compiler does string pooling by
	     hashing the constants to an internal symbol name, and
	     relying on the linker comdat support to discard
	     duplicate names.  However, if one string is a literal and
	     one is a data initializer, one will end up in the .data
	     section and one will end up in the .rdata section.  The
	     Microsoft linker will combine them into the .data
	     section, which seems to be wrong since it might cause the
	     literal to change.

	     As long as there are no external references to the
	     symbols, which there shouldn't be, we can treat the .data
	     and .rdata instances as separate symbols.  The comdat
	     code in the linker will do the appropriate merging.  Here
	     we avoid getting a multiple definition error for one of
	     these special symbols.

	     FIXME: I don't think this will work in the case where
	     there are two object files which use the constants as a
	     literal and two object files which use it as a data
	     initializer.  One or the other of the second object files
	     is going to wind up with an inappropriate reference.  */
	  if (obj_pe (abfd)
	      && (classification == COFF_SYMBOL_GLOBAL
		  || classification == COFF_SYMBOL_PE_SECTION)
	      && coff_section_data (abfd, section) != NULL
	      && coff_section_data (abfd, section)->comdat != NULL
	      && CONST_STRNEQ (name, "??_")
	      && strcmp (name, coff_section_data (abfd, section)->comdat->name) == 0)
	    {
	      if (*sym_hash == NULL)
		*sym_hash = coff_link_hash_lookup (coff_hash_table (info),
						   name, FALSE, copy, FALSE);
	      if (*sym_hash != NULL
		  && (*sym_hash)->root.type == bfd_link_hash_defined
		  && coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat != NULL
		  && strcmp (coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat->name,
			     coff_section_data (abfd, section)->comdat->name) == 0)
		addit = FALSE;
	    }

	  if (addit)
	    {
	      if (! (bfd_coff_link_add_one_symbol
		     (info, abfd, name, flags, section, value,
		      (const char *) NULL, copy, FALSE,
		      (struct bfd_link_hash_entry **) sym_hash)))
		goto error_return;
	    }

	  if (obj_pe (abfd) && (flags & BSF_SECTION_SYM) != 0)
	    (*sym_hash)->coff_link_hash_flags |=
	      COFF_LINK_HASH_PE_SECTION_SYMBOL;

	  /* Limit the alignment of a common symbol to the possible
             alignment of a section.  There is no point to permitting
             a higher alignment for a common symbol: we can not
             guarantee it, and it may cause us to allocate extra space
             in the common section.  */
	  if (section == bfd_com_section_ptr
	      && (*sym_hash)->root.type == bfd_link_hash_common
	      && ((*sym_hash)->root.u.c.p->alignment_power
		  > bfd_coff_default_section_alignment_power (abfd)))
	    (*sym_hash)->root.u.c.p->alignment_power
	      = bfd_coff_default_section_alignment_power (abfd);

	  if (bfd_get_flavour (info->output_bfd) == bfd_get_flavour (abfd))
	    {
	      /* If we don't have any symbol information currently in
                 the hash table, or if we are looking at a symbol
                 definition, then update the symbol class and type in
                 the hash table.  */
  	      if (((*sym_hash)->symbol_class == C_NULL
  		   && (*sym_hash)->type == T_NULL)
  		  || sym.n_scnum != 0
  		  || (sym.n_value != 0
  		      && (*sym_hash)->root.type != bfd_link_hash_defined
  		      && (*sym_hash)->root.type != bfd_link_hash_defweak))
  		{
  		  (*sym_hash)->symbol_class = sym.n_sclass;
  		  if (sym.n_type != T_NULL)
  		    {
  		      /* We want to warn if the type changed, but not
  			 if it changed from an unspecified type.
  			 Testing the whole type byte may work, but the
  			 change from (e.g.) a function of unspecified
  			 type to function of known type also wants to
  			 skip the warning.  */
  		      if ((*sym_hash)->type != T_NULL
  			  && (*sym_hash)->type != sym.n_type
  		          && !(DTYPE ((*sym_hash)->type) == DTYPE (sym.n_type)
  		               && (BTYPE ((*sym_hash)->type) == T_NULL
  		                   || BTYPE (sym.n_type) == T_NULL)))
  			(*_bfd_error_handler)
  			  (_("Warning: type of symbol `%s' changed from %d to %d in %B"),
  			   abfd, name, (*sym_hash)->type, sym.n_type);

  		      /* We don't want to change from a meaningful
  			 base type to a null one, but if we know
  			 nothing, take what little we might now know.  */
  		      if (BTYPE (sym.n_type) != T_NULL
  			  || (*sym_hash)->type == T_NULL)
			(*sym_hash)->type = sym.n_type;
  		    }
  		  (*sym_hash)->auxbfd = abfd;
		  if (sym.n_numaux != 0)
		    {
		      union internal_auxent *alloc;
		      unsigned int i;
		      bfd_byte *eaux;
		      union internal_auxent *iaux;

		      (*sym_hash)->numaux = sym.n_numaux;
		      alloc = ((union internal_auxent *)
			       bfd_hash_allocate (&info->hash->table,
						  (sym.n_numaux
						   * sizeof (*alloc))));
		      if (alloc == NULL)
			goto error_return;
		      for (i = 0, eaux = esym + symesz, iaux = alloc;
			   i < sym.n_numaux;
			   i++, eaux += symesz, iaux++)
			bfd_coff_swap_aux_in (abfd, eaux, sym.n_type,
					      sym.n_sclass, (int) i,
					      sym.n_numaux, iaux);
		      (*sym_hash)->aux = alloc;
		    }
		}
	    }

	  if (classification == COFF_SYMBOL_PE_SECTION
	      && (*sym_hash)->numaux != 0)
	    {
	      /* Some PE sections (such as .bss) have a zero size in
                 the section header, but a non-zero size in the AUX
                 record.  Correct that here.

		 FIXME: This is not at all the right place to do this.
		 For example, it won't help objdump.  This needs to be
		 done when we swap in the section header.  */
	      BFD_ASSERT ((*sym_hash)->numaux == 1);
	      if (section->size == 0)
		section->size = (*sym_hash)->aux[0].x_scn.x_scnlen;

	      /* FIXME: We could test whether the section sizes
                 matches the size in the aux entry, but apparently
                 that sometimes fails unexpectedly.  */
	    }
	}

      esym += (sym.n_numaux + 1) * symesz;
      sym_hash += sym.n_numaux + 1;
    }

  /* If this is a non-traditional, non-relocatable link, try to
     optimize the handling of any .stab/.stabstr sections.  */
  if (! info->relocatable
      && ! info->traditional_format
      && bfd_get_flavour (info->output_bfd) == bfd_get_flavour (abfd)
      && (info->strip != strip_all && info->strip != strip_debugger))
    {
      asection *stabstr;

      stabstr = bfd_get_section_by_name (abfd, ".stabstr");

      if (stabstr != NULL)
	{
	  bfd_size_type string_offset = 0;
	  asection *stab;

	  for (stab = abfd->sections; stab; stab = stab->next)
	    if (CONST_STRNEQ (stab->name, ".stab")
		&& (!stab->name[5]
		    || (stab->name[5] == '.' && ISDIGIT (stab->name[6]))))
	    {
	      struct coff_link_hash_table *table;
	      struct coff_section_tdata *secdata
		= coff_section_data (abfd, stab);

	      if (secdata == NULL)
		{
		  amt = sizeof (struct coff_section_tdata);
		  stab->used_by_bfd = bfd_zalloc (abfd, amt);
		  if (stab->used_by_bfd == NULL)
		    goto error_return;
		  secdata = coff_section_data (abfd, stab);
		}

	      table = coff_hash_table (info);

	      if (! _bfd_link_section_stabs (abfd, &table->stab_info,
					     stab, stabstr,
					     &secdata->stab_info,
					     &string_offset))
		goto error_return;
	    }
	}
    }

  obj_coff_keep_syms (abfd) = keep_syms;

  return TRUE;

 error_return:
  obj_coff_keep_syms (abfd) = keep_syms;
  return FALSE;
}

/* Do the final link step.  */

bfd_boolean
_bfd_coff_final_link (bfd *abfd,
		      struct bfd_link_info *info)
{
  bfd_size_type symesz;
  struct coff_final_link_info flaginfo;
  bfd_boolean debug_merge_allocated;
  bfd_boolean long_section_names;
  asection *o;
  struct bfd_link_order *p;
  bfd_size_type max_sym_count;
  bfd_size_type max_lineno_count;
  bfd_size_type max_reloc_count;
  bfd_size_type max_output_reloc_count;
  bfd_size_type max_contents_size;
  file_ptr rel_filepos;
  unsigned int relsz;
  file_ptr line_filepos;
  unsigned int linesz;
  bfd *sub;
  bfd_byte *external_relocs = NULL;
  char strbuf[STRING_SIZE_SIZE];
  bfd_size_type amt;

  symesz = bfd_coff_symesz (abfd);

  flaginfo.info = info;
  flaginfo.output_bfd = abfd;
  flaginfo.strtab = NULL;
  flaginfo.section_info = NULL;
  flaginfo.last_file_index = -1;
  flaginfo.last_bf_index = -1;
  flaginfo.internal_syms = NULL;
  flaginfo.sec_ptrs = NULL;
  flaginfo.sym_indices = NULL;
  flaginfo.outsyms = NULL;
  flaginfo.linenos = NULL;
  flaginfo.contents = NULL;
  flaginfo.external_relocs = NULL;
  flaginfo.internal_relocs = NULL;
  flaginfo.global_to_static = FALSE;
  debug_merge_allocated = FALSE;

  coff_data (abfd)->link_info = info;

  flaginfo.strtab = _bfd_stringtab_init ();
  if (flaginfo.strtab == NULL)
    goto error_return;

  if (! coff_debug_merge_hash_table_init (&flaginfo.debug_merge))
    goto error_return;
  debug_merge_allocated = TRUE;

  /* Compute the file positions for all the sections.  */
  if (! abfd->output_has_begun)
    {
      if (! bfd_coff_compute_section_file_positions (abfd))
	goto error_return;
    }

  /* Count the line numbers and relocation entries required for the
     output file.  Set the file positions for the relocs.  */
  rel_filepos = obj_relocbase (abfd);
  relsz = bfd_coff_relsz (abfd);
  max_contents_size = 0;
  max_lineno_count = 0;
  max_reloc_count = 0;

  long_section_names = FALSE;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      o->reloc_count = 0;
      o->lineno_count = 0;
      for (p = o->map_head.link_order; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order)
	    {
	      asection *sec;

	      sec = p->u.indirect.section;

	      /* Mark all sections which are to be included in the
		 link.  This will normally be every section.  We need
		 to do this so that we can identify any sections which
		 the linker has decided to not include.  */
	      sec->linker_mark = TRUE;

	      if (info->strip == strip_none
		  || info->strip == strip_some)
		o->lineno_count += sec->lineno_count;

	      if (info->relocatable)
		o->reloc_count += sec->reloc_count;

	      if (sec->rawsize > max_contents_size)
		max_contents_size = sec->rawsize;
	      if (sec->size > max_contents_size)
		max_contents_size = sec->size;
	      if (sec->lineno_count > max_lineno_count)
		max_lineno_count = sec->lineno_count;
	      if (sec->reloc_count > max_reloc_count)
		max_reloc_count = sec->reloc_count;
	    }
	  else if (info->relocatable
		   && (p->type == bfd_section_reloc_link_order
		       || p->type == bfd_symbol_reloc_link_order))
	    ++o->reloc_count;
	}
      if (o->reloc_count == 0)
	o->rel_filepos = 0;
      else
	{
	  o->flags |= SEC_RELOC;
	  o->rel_filepos = rel_filepos;
	  rel_filepos += o->reloc_count * relsz;
	  /* In PE COFF, if there are at least 0xffff relocations an
	     extra relocation will be written out to encode the count.  */
	  if (obj_pe (abfd) && o->reloc_count >= 0xffff)
	    rel_filepos += relsz;
	}

      if (bfd_coff_long_section_names (abfd)
	  && strlen (o->name) > SCNNMLEN)
	{
	  /* This section has a long name which must go in the string
             table.  This must correspond to the code in
             coff_write_object_contents which puts the string index
             into the s_name field of the section header.  That is why
             we pass hash as FALSE.  */
	  if (_bfd_stringtab_add (flaginfo.strtab, o->name, FALSE, FALSE)
	      == (bfd_size_type) -1)
	    goto error_return;
	  long_section_names = TRUE;
	}
    }

  /* If doing a relocatable link, allocate space for the pointers we
     need to keep.  */
  if (info->relocatable)
    {
      unsigned int i;

      /* We use section_count + 1, rather than section_count, because
         the target_index fields are 1 based.  */
      amt = abfd->section_count + 1;
      amt *= sizeof (struct coff_link_section_info);
      flaginfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);
      if (flaginfo.section_info == NULL)
	goto error_return;
      for (i = 0; i <= abfd->section_count; i++)
	{
	  flaginfo.section_info[i].relocs = NULL;
	  flaginfo.section_info[i].rel_hashes = NULL;
	}
    }

  /* We now know the size of the relocs, so we can determine the file
     positions of the line numbers.  */
  line_filepos = rel_filepos;
  linesz = bfd_coff_linesz (abfd);
  max_output_reloc_count = 0;
  for (o = abfd->sections; o != NULL; o = o->next)
    {
      if (o->lineno_count == 0)
	o->line_filepos = 0;
      else
	{
	  o->line_filepos = line_filepos;
	  line_filepos += o->lineno_count * linesz;
	}

      if (o->reloc_count != 0)
	{
	  /* We don't know the indices of global symbols until we have
             written out all the local symbols.  For each section in
             the output file, we keep an array of pointers to hash
             table entries.  Each entry in the array corresponds to a
             reloc.  When we find a reloc against a global symbol, we
             set the corresponding entry in this array so that we can
             fix up the symbol index after we have written out all the
             local symbols.

	     Because of this problem, we also keep the relocs in
	     memory until the end of the link.  This wastes memory,
	     but only when doing a relocatable link, which is not the
	     common case.  */
	  BFD_ASSERT (info->relocatable);
	  amt = o->reloc_count;
	  amt *= sizeof (struct internal_reloc);
	  flaginfo.section_info[o->target_index].relocs =
              (struct internal_reloc *) bfd_malloc (amt);
	  amt = o->reloc_count;
	  amt *= sizeof (struct coff_link_hash_entry *);
	  flaginfo.section_info[o->target_index].rel_hashes =
              (struct coff_link_hash_entry **) bfd_malloc (amt);
	  if (flaginfo.section_info[o->target_index].relocs == NULL
	      || flaginfo.section_info[o->target_index].rel_hashes == NULL)
	    goto error_return;

	  if (o->reloc_count > max_output_reloc_count)
	    max_output_reloc_count = o->reloc_count;
	}

      /* Reset the reloc and lineno counts, so that we can use them to
	 count the number of entries we have output so far.  */
      o->reloc_count = 0;
      o->lineno_count = 0;
    }

  obj_sym_filepos (abfd) = line_filepos;

  /* Figure out the largest number of symbols in an input BFD.  Take
     the opportunity to clear the output_has_begun fields of all the
     input BFD's.  */
  max_sym_count = 0;
  for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
    {
      size_t sz;

      sub->output_has_begun = FALSE;
      sz = bfd_family_coff (sub) ? obj_raw_syment_count (sub) : 2;
      if (sz > max_sym_count)
	max_sym_count = sz;
    }

  /* Allocate some buffers used while linking.  */
  amt = max_sym_count * sizeof (struct internal_syment);
  flaginfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
  amt = max_sym_count * sizeof (asection *);
  flaginfo.sec_ptrs = (asection **) bfd_malloc (amt);
  amt = max_sym_count * sizeof (long);
  flaginfo.sym_indices = (long int *) bfd_malloc (amt);
  flaginfo.outsyms = (bfd_byte *) bfd_malloc ((max_sym_count + 1) * symesz);
  amt = max_lineno_count * bfd_coff_linesz (abfd);
  flaginfo.linenos = (bfd_byte *) bfd_malloc (amt);
  flaginfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
  amt = max_reloc_count * relsz;
  flaginfo.external_relocs = (bfd_byte *) bfd_malloc (amt);
  if (! info->relocatable)
    {
      amt = max_reloc_count * sizeof (struct internal_reloc);
      flaginfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);
    }
  if ((flaginfo.internal_syms == NULL && max_sym_count > 0)
      || (flaginfo.sec_ptrs == NULL && max_sym_count > 0)
      || (flaginfo.sym_indices == NULL && max_sym_count > 0)
      || flaginfo.outsyms == NULL
      || (flaginfo.linenos == NULL && max_lineno_count > 0)
      || (flaginfo.contents == NULL && max_contents_size > 0)
      || (flaginfo.external_relocs == NULL && max_reloc_count > 0)
      || (! info->relocatable
	  && flaginfo.internal_relocs == NULL
	  && max_reloc_count > 0))
    goto error_return;

  /* We now know the position of everything in the file, except that
     we don't know the size of the symbol table and therefore we don't
     know where the string table starts.  We just build the string
     table in memory as we go along.  We process all the relocations
     for a single input file at once.  */
  obj_raw_syment_count (abfd) = 0;

  if (coff_backend_info (abfd)->_bfd_coff_start_final_link)
    {
      if (! bfd_coff_start_final_link (abfd, info))
	goto error_return;
    }

  for (o = abfd->sections; o != NULL; o = o->next)
    {
      for (p = o->map_head.link_order; p != NULL; p = p->next)
	{
	  if (p->type == bfd_indirect_link_order
	      && bfd_family_coff (p->u.indirect.section->owner))
	    {
	      sub = p->u.indirect.section->owner;
	      if (! bfd_coff_link_output_has_begun (sub, & flaginfo))
		{
		  if (! _bfd_coff_link_input_bfd (&flaginfo, sub))
		    goto error_return;
		  sub->output_has_begun = TRUE;
		}
	    }
	  else if (p->type == bfd_section_reloc_link_order
		   || p->type == bfd_symbol_reloc_link_order)
	    {
	      if (! _bfd_coff_reloc_link_order (abfd, &flaginfo, o, p))
		goto error_return;
	    }
	  else
	    {
	      if (! _bfd_default_link_order (abfd, info, o, p))
		goto error_return;
	    }
	}
    }

  if (flaginfo.info->strip != strip_all && flaginfo.info->discard != discard_all)
    {
      /* Add local symbols from foreign inputs.  */
      for (sub = info->input_bfds; sub != NULL; sub = sub->link_next)
	{
	  unsigned int i;

	  if (bfd_family_coff (sub) || ! bfd_get_outsymbols (sub))
	    continue;
	  for (i = 0; i < bfd_get_symcount (sub); ++i)
	    {
	      asymbol *sym = bfd_get_outsymbols (sub) [i];
	      file_ptr pos;
	      struct internal_syment isym;
	      bfd_size_type string_size = 0;
	      bfd_vma written = 0;
	      bfd_boolean rewrite = FALSE;

	      if (! (sym->flags & BSF_LOCAL)
		  || (sym->flags & (BSF_SECTION_SYM | BSF_DEBUGGING_RELOC
				    | BSF_THREAD_LOCAL | BSF_RELC | BSF_SRELC
				    | BSF_SYNTHETIC))
		  || ((sym->flags & BSF_DEBUGGING)
		      && ! (sym->flags & BSF_FILE)))
		continue;

	      /* See if we are discarding symbols with this name.  */
	      if ((flaginfo.info->strip == strip_some
		   && (bfd_hash_lookup (flaginfo.info->keep_hash,
					bfd_asymbol_name(sym), FALSE, FALSE)
		       == NULL))
		  || (((flaginfo.info->discard == discard_sec_merge
			&& (bfd_get_section (sym)->flags & SEC_MERGE)
			&& ! flaginfo.info->relocatable)
		       || flaginfo.info->discard == discard_l)
		      && bfd_is_local_label_name (sub, bfd_asymbol_name(sym))))
		continue;

	      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd)
					     * symesz;
	      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
		goto error_return;
	      if (! coff_write_alien_symbol(abfd, sym, &isym, &written,
					    &string_size, NULL, NULL))
		goto error_return;

	      if (string_size)
		{
		  bfd_boolean hash = ! (abfd->flags & BFD_TRADITIONAL_FORMAT);
		  bfd_size_type indx;

		  indx = _bfd_stringtab_add (flaginfo.strtab,
					     bfd_asymbol_name (sym), hash,
					     FALSE);
		  if (indx == (bfd_size_type) -1)
		    goto error_return;
		  isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
		  bfd_coff_swap_sym_out (abfd, &isym, flaginfo.outsyms);
		  rewrite = TRUE;
		}

	      if (isym.n_sclass == C_FILE)
		{
		  if (flaginfo.last_file_index != -1)
		    {
		      flaginfo.last_file.n_value = obj_raw_syment_count (abfd);
		      bfd_coff_swap_sym_out (abfd, &flaginfo.last_file,
					     flaginfo.outsyms);
		      pos = obj_sym_filepos (abfd) + flaginfo.last_file_index
						     * symesz;
		      rewrite = TRUE;
		    }
		  flaginfo.last_file_index = obj_raw_syment_count (abfd);
		  flaginfo.last_file = isym;
		}

	      if (rewrite
		  && (bfd_seek (abfd, pos, SEEK_SET) != 0
		      || bfd_bwrite (flaginfo.outsyms, symesz, abfd) != symesz))
		goto error_return;

	      obj_raw_syment_count (abfd) += written;
	    }
	}
    }

  if (! bfd_coff_final_link_postscript (abfd, & flaginfo))
    goto error_return;

  /* Free up the buffers used by _bfd_coff_link_input_bfd.  */

  coff_debug_merge_hash_table_free (&flaginfo.debug_merge);
  debug_merge_allocated = FALSE;

  if (flaginfo.internal_syms != NULL)
    {
      free (flaginfo.internal_syms);
      flaginfo.internal_syms = NULL;
    }
  if (flaginfo.sec_ptrs != NULL)
    {
      free (flaginfo.sec_ptrs);
      flaginfo.sec_ptrs = NULL;
    }
  if (flaginfo.sym_indices != NULL)
    {
      free (flaginfo.sym_indices);
      flaginfo.sym_indices = NULL;
    }
  if (flaginfo.linenos != NULL)
    {
      free (flaginfo.linenos);
      flaginfo.linenos = NULL;
    }
  if (flaginfo.contents != NULL)
    {
      free (flaginfo.contents);
      flaginfo.contents = NULL;
    }
  if (flaginfo.external_relocs != NULL)
    {
      free (flaginfo.external_relocs);
      flaginfo.external_relocs = NULL;
    }
  if (flaginfo.internal_relocs != NULL)
    {
      free (flaginfo.internal_relocs);
      flaginfo.internal_relocs = NULL;
    }

  /* The value of the last C_FILE symbol is supposed to be the symbol
     index of the first external symbol.  Write it out again if
     necessary.  */
  if (flaginfo.last_file_index != -1
      && (unsigned int) flaginfo.last_file.n_value != obj_raw_syment_count (abfd))
    {
      file_ptr pos;

      flaginfo.last_file.n_value = obj_raw_syment_count (abfd);
      bfd_coff_swap_sym_out (abfd, &flaginfo.last_file,
			     flaginfo.outsyms);

      pos = obj_sym_filepos (abfd) + flaginfo.last_file_index * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (flaginfo.outsyms, symesz, abfd) != symesz)
	return FALSE;
    }

  /* If doing task linking (ld --task-link) then make a pass through the
     global symbols, writing out any that are defined, and making them
     static.  */
  if (info->task_link)
    {
      flaginfo.failed = FALSE;
      coff_link_hash_traverse (coff_hash_table (info),
			       _bfd_coff_write_task_globals, &flaginfo);
      if (flaginfo.failed)
	goto error_return;
    }

  /* Write out the global symbols.  */
  flaginfo.failed = FALSE;
  bfd_hash_traverse (&info->hash->table, _bfd_coff_write_global_sym, &flaginfo);
  if (flaginfo.failed)
    goto error_return;

  /* The outsyms buffer is used by _bfd_coff_write_global_sym.  */
  if (flaginfo.outsyms != NULL)
    {
      free (flaginfo.outsyms);
      flaginfo.outsyms = NULL;
    }

  if (info->relocatable && max_output_reloc_count > 0)
    {
      /* Now that we have written out all the global symbols, we know
	 the symbol indices to use for relocs against them, and we can
	 finally write out the relocs.  */
      amt = max_output_reloc_count * relsz;
      external_relocs = (bfd_byte *) bfd_malloc (amt);
      if (external_relocs == NULL)
	goto error_return;

      for (o = abfd->sections; o != NULL; o = o->next)
	{
	  struct internal_reloc *irel;
	  struct internal_reloc *irelend;
	  struct coff_link_hash_entry **rel_hash;
	  bfd_byte *erel;

	  if (o->reloc_count == 0)
	    continue;

	  irel = flaginfo.section_info[o->target_index].relocs;
	  irelend = irel + o->reloc_count;
	  rel_hash = flaginfo.section_info[o->target_index].rel_hashes;
	  erel = external_relocs;
	  for (; irel < irelend; irel++, rel_hash++, erel += relsz)
	    {
	      if (*rel_hash != NULL)
		{
		  BFD_ASSERT ((*rel_hash)->indx >= 0);
		  irel->r_symndx = (*rel_hash)->indx;
		}
	      bfd_coff_swap_reloc_out (abfd, irel, erel);
	    }

	  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0)
	    goto error_return;
	  if (obj_pe (abfd) && o->reloc_count >= 0xffff)
	    {
	      /* In PE COFF, write the count of relocs as the first
		 reloc.  The header overflow bit will be set
		 elsewhere. */
	      struct internal_reloc incount;
	      bfd_byte *excount = (bfd_byte *)bfd_malloc (relsz);

	      memset (&incount, 0, sizeof (incount));
	      incount.r_vaddr = o->reloc_count + 1;
	      bfd_coff_swap_reloc_out (abfd, &incount, excount);
	      if (bfd_bwrite (excount, relsz, abfd) != relsz)
		/* We'll leak, but it's an error anyway. */
		goto error_return;
	      free (excount);
	    }
	  if (bfd_bwrite (external_relocs,
			  (bfd_size_type) relsz * o->reloc_count, abfd)
	      != (bfd_size_type) relsz * o->reloc_count)
	    goto error_return;
	}

      free (external_relocs);
      external_relocs = NULL;
    }

  /* Free up the section information.  */
  if (flaginfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (flaginfo.section_info[i].relocs != NULL)
	    free (flaginfo.section_info[i].relocs);
	  if (flaginfo.section_info[i].rel_hashes != NULL)
	    free (flaginfo.section_info[i].rel_hashes);
	}
      free (flaginfo.section_info);
      flaginfo.section_info = NULL;
    }

  /* If we have optimized stabs strings, output them.  */
  if (coff_hash_table (info)->stab_info.stabstr != NULL)
    {
      if (! _bfd_write_stab_strings (abfd, &coff_hash_table (info)->stab_info))
	return FALSE;
    }

  /* Write out the string table.  */
  if (obj_raw_syment_count (abfd) != 0 || long_section_names)
    {
      file_ptr pos;

      pos = obj_sym_filepos (abfd) + obj_raw_syment_count (abfd) * symesz;
      if (bfd_seek (abfd, pos, SEEK_SET) != 0)
	return FALSE;

#if STRING_SIZE_SIZE == 4
      H_PUT_32 (abfd,
		_bfd_stringtab_size (flaginfo.strtab) + STRING_SIZE_SIZE,
		strbuf);
#else
 #error Change H_PUT_32 above
#endif

      if (bfd_bwrite (strbuf, (bfd_size_type) STRING_SIZE_SIZE, abfd)
	  != STRING_SIZE_SIZE)
	return FALSE;

      if (! _bfd_stringtab_emit (abfd, flaginfo.strtab))
	return FALSE;

      obj_coff_strings_written (abfd) = TRUE;
    }

  _bfd_stringtab_free (flaginfo.strtab);

  /* Setting bfd_get_symcount to 0 will cause write_object_contents to
     not try to write out the symbols.  */
  bfd_get_symcount (abfd) = 0;

  return TRUE;

 error_return:
  if (debug_merge_allocated)
    coff_debug_merge_hash_table_free (&flaginfo.debug_merge);
  if (flaginfo.strtab != NULL)
    _bfd_stringtab_free (flaginfo.strtab);
  if (flaginfo.section_info != NULL)
    {
      unsigned int i;

      for (i = 0; i < abfd->section_count; i++)
	{
	  if (flaginfo.section_info[i].relocs != NULL)
	    free (flaginfo.section_info[i].relocs);
	  if (flaginfo.section_info[i].rel_hashes != NULL)
	    free (flaginfo.section_info[i].rel_hashes);
	}
      free (flaginfo.section_info);
    }
  if (flaginfo.internal_syms != NULL)
    free (flaginfo.internal_syms);
  if (flaginfo.sec_ptrs != NULL)
    free (flaginfo.sec_ptrs);
  if (flaginfo.sym_indices != NULL)
    free (flaginfo.sym_indices);
  if (flaginfo.outsyms != NULL)
    free (flaginfo.outsyms);
  if (flaginfo.linenos != NULL)
    free (flaginfo.linenos);
  if (flaginfo.contents != NULL)
    free (flaginfo.contents);
  if (flaginfo.external_relocs != NULL)
    free (flaginfo.external_relocs);
  if (flaginfo.internal_relocs != NULL)
    free (flaginfo.internal_relocs);
  if (external_relocs != NULL)
    free (external_relocs);
  return FALSE;
}

/* Parse out a -heap <reserved>,<commit> line.  */

static char *
dores_com (char *ptr, bfd *output_bfd, int heap)
{
  if (coff_data(output_bfd)->pe)
    {
      int val = strtoul (ptr, &ptr, 0);

      if (heap)
	pe_data(output_bfd)->pe_opthdr.SizeOfHeapReserve = val;
      else
	pe_data(output_bfd)->pe_opthdr.SizeOfStackReserve = val;

      if (ptr[0] == ',')
	{
	  val = strtoul (ptr+1, &ptr, 0);
	  if (heap)
	    pe_data(output_bfd)->pe_opthdr.SizeOfHeapCommit = val;
	  else
	    pe_data(output_bfd)->pe_opthdr.SizeOfStackCommit = val;
	}
    }
  return ptr;
}

static char *
get_name (char *ptr, char **dst)
{
  while (*ptr == ' ')
    ptr++;
  *dst = ptr;
  while (*ptr && *ptr != ' ')
    ptr++;
  *ptr = 0;
  return ptr+1;
}

/* Process any magic embedded commands in a section called .drectve.  */

static int
process_embedded_commands (bfd *output_bfd,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   bfd *abfd)
{
  asection *sec = bfd_get_section_by_name (abfd, ".drectve");
  char *s;
  char *e;
  bfd_byte *copy;

  if (!sec)
    return 1;

  if (!bfd_malloc_and_get_section (abfd, sec, &copy))
    {
      if (copy != NULL)
	free (copy);
      return 0;
    }
  e = (char *) copy + sec->size;

  for (s = (char *) copy; s < e ; )
    {
      if (s[0] != '-')
	{
	  s++;
	  continue;
	}
      if (CONST_STRNEQ (s, "-attr"))
	{
	  char *name;
	  char *attribs;
	  asection *asec;
	  int loop = 1;
	  int had_write = 0;
	  int had_exec= 0;

	  s += 5;
	  s = get_name (s, &name);
	  s = get_name (s, &attribs);

	  while (loop)
	    {
	      switch (*attribs++)
		{
		case 'W':
		  had_write = 1;
		  break;
		case 'R':
		  break;
		case 'S':
		  break;
		case 'X':
		  had_exec = 1;
		  break;
		default:
		  loop = 0;
		}
	    }
	  asec = bfd_get_section_by_name (abfd, name);
	  if (asec)
	    {
	      if (had_exec)
		asec->flags |= SEC_CODE;
	      if (!had_write)
		asec->flags |= SEC_READONLY;
	    }
	}
      else if (CONST_STRNEQ (s, "-heap"))
	s = dores_com (s + 5, output_bfd, 1);

      else if (CONST_STRNEQ (s, "-stack"))
	s = dores_com (s + 6, output_bfd, 0);

      /* GNU extension for aligned commons.  */
      else if (CONST_STRNEQ (s, "-aligncomm:"))
	{
	  /* Common symbols must be aligned on reading, as it
	  is too late to do anything here, after they have
	  already been allocated, so just skip the directive.  */
	  s += 11;
	}

      else
	s++;
    }
  free (copy);
  return 1;
}

/* Place a marker against all symbols which are used by relocations.
   This marker can be picked up by the 'do we skip this symbol ?'
   loop in _bfd_coff_link_input_bfd() and used to prevent skipping
   that symbol.  */

static void
mark_relocs (struct coff_final_link_info *flaginfo, bfd *input_bfd)
{
  asection * a;

  if ((bfd_get_file_flags (input_bfd) & HAS_SYMS) == 0)
    return;

  for (a = input_bfd->sections; a != (asection *) NULL; a = a->next)
    {
      struct internal_reloc *	internal_relocs;
      struct internal_reloc *	irel;
      struct internal_reloc *	irelend;

      if ((a->flags & SEC_RELOC) == 0 || a->reloc_count  < 1
	  || a->linker_mark == 0)
	continue;
      /* Don't mark relocs in excluded sections.  */
      if (a->output_section == bfd_abs_section_ptr)
	continue;

      /* Read in the relocs.  */
      internal_relocs = _bfd_coff_read_internal_relocs
	(input_bfd, a, FALSE,
	 flaginfo->external_relocs,
	 flaginfo->info->relocatable,
	 (flaginfo->info->relocatable
	  ? (flaginfo->section_info[ a->output_section->target_index ].relocs + a->output_section->reloc_count)
	  : flaginfo->internal_relocs)
	);

      if (internal_relocs == NULL)
	continue;

      irel     = internal_relocs;
      irelend  = irel + a->reloc_count;

      /* Place a mark in the sym_indices array (whose entries have
	 been initialised to 0) for all of the symbols that are used
	 in the relocation table.  This will then be picked up in the
	 skip/don't-skip pass.  */
      for (; irel < irelend; irel++)
	flaginfo->sym_indices[ irel->r_symndx ] = -1;
    }
}

/* Link an input file into the linker output file.  This function
   handles all the sections and relocations of the input file at once.  */

bfd_boolean
_bfd_coff_link_input_bfd (struct coff_final_link_info *flaginfo, bfd *input_bfd)
{
  unsigned int n_tmask = coff_data (input_bfd)->local_n_tmask;
  unsigned int n_btshft = coff_data (input_bfd)->local_n_btshft;
  bfd_boolean (*adjust_symndx)
    (bfd *, struct bfd_link_info *, bfd *, asection *,
     struct internal_reloc *, bfd_boolean *);
  bfd *output_bfd;
  const char *strings;
  bfd_size_type syment_base;
  bfd_boolean copy, hash;
  bfd_size_type isymesz;
  bfd_size_type osymesz;
  bfd_size_type linesz;
  bfd_byte *esym;
  bfd_byte *esym_end;
  struct internal_syment *isymp;
  asection **secpp;
  long *indexp;
  unsigned long output_index;
  bfd_byte *outsym;
  struct coff_link_hash_entry **sym_hash;
  asection *o;

  /* Move all the symbols to the output file.  */

  output_bfd = flaginfo->output_bfd;
  strings = NULL;
  syment_base = obj_raw_syment_count (output_bfd);
  isymesz = bfd_coff_symesz (input_bfd);
  osymesz = bfd_coff_symesz (output_bfd);
  linesz = bfd_coff_linesz (input_bfd);
  BFD_ASSERT (linesz == bfd_coff_linesz (output_bfd));

  copy = FALSE;
  if (! flaginfo->info->keep_memory)
    copy = TRUE;
  hash = TRUE;
  if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
    hash = FALSE;

  if (! _bfd_coff_get_external_symbols (input_bfd))
    return FALSE;

  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
  isymp = flaginfo->internal_syms;
  secpp = flaginfo->sec_ptrs;
  indexp = flaginfo->sym_indices;
  output_index = syment_base;
  outsym = flaginfo->outsyms;

  if (coff_data (output_bfd)->pe
      && ! process_embedded_commands (output_bfd, flaginfo->info, input_bfd))
    return FALSE;

  /* If we are going to perform relocations and also strip/discard some
     symbols then we must make sure that we do not strip/discard those
     symbols that are going to be involved in the relocations.  */
  if ((   flaginfo->info->strip   != strip_none
       || flaginfo->info->discard != discard_none)
      && flaginfo->info->relocatable)
    {
      /* Mark the symbol array as 'not-used'.  */
      memset (indexp, 0, obj_raw_syment_count (input_bfd) * sizeof * indexp);

      mark_relocs (flaginfo, input_bfd);
    }

  while (esym < esym_end)
    {
      struct internal_syment isym;
      enum coff_symbol_classification classification;
      bfd_boolean skip;
      bfd_boolean global;
      bfd_boolean dont_skip_symbol;
      int add;

      bfd_coff_swap_sym_in (input_bfd, esym, isymp);

      /* Make a copy of *isymp so that the relocate_section function
	 always sees the original values.  This is more reliable than
	 always recomputing the symbol value even if we are stripping
	 the symbol.  */
      isym = *isymp;

      classification = bfd_coff_classify_symbol (input_bfd, &isym);
      switch (classification)
	{
	default:
	  abort ();
	case COFF_SYMBOL_GLOBAL:
	case COFF_SYMBOL_PE_SECTION:
	case COFF_SYMBOL_LOCAL:
	  *secpp = coff_section_from_bfd_index (input_bfd, isym.n_scnum);
	  break;
	case COFF_SYMBOL_COMMON:
	  *secpp = bfd_com_section_ptr;
	  break;
	case COFF_SYMBOL_UNDEFINED:
	  *secpp = bfd_und_section_ptr;
	  break;
	}

      /* Extract the flag indicating if this symbol is used by a
         relocation.  */
      if ((flaginfo->info->strip != strip_none
	   || flaginfo->info->discard != discard_none)
	  && flaginfo->info->relocatable)
	dont_skip_symbol = *indexp;
      else
	dont_skip_symbol = FALSE;

      *indexp = -1;

      skip = FALSE;
      global = FALSE;
      add = 1 + isym.n_numaux;

      /* If we are stripping all symbols, we want to skip this one.  */
      if (flaginfo->info->strip == strip_all && ! dont_skip_symbol)
	skip = TRUE;

      if (! skip)
	{
	  switch (classification)
	    {
	    default:
	      abort ();
	    case COFF_SYMBOL_GLOBAL:
	    case COFF_SYMBOL_COMMON:
	    case COFF_SYMBOL_PE_SECTION:
	      /* This is a global symbol.  Global symbols come at the
		 end of the symbol table, so skip them for now.
		 Locally defined function symbols, however, are an
		 exception, and are not moved to the end.  */
	      global = TRUE;
	      if (! ISFCN (isym.n_type))
		skip = TRUE;
	      break;

	    case COFF_SYMBOL_UNDEFINED:
	      /* Undefined symbols are left for the end.  */
	      global = TRUE;
	      skip = TRUE;
	      break;

	    case COFF_SYMBOL_LOCAL:
	      /* This is a local symbol.  Skip it if we are discarding
                 local symbols.  */
	      if (flaginfo->info->discard == discard_all && ! dont_skip_symbol)
		skip = TRUE;
	      break;
	    }
	}

#ifndef COFF_WITH_PE
      /* Skip section symbols for sections which are not going to be
	 emitted.  */
      if (!skip
	  && !dont_skip_symbol
	  && isym.n_sclass == C_STAT
	  && isym.n_type == T_NULL
	  && isym.n_numaux > 0
	  && ((*secpp)->output_section == bfd_abs_section_ptr
	      || bfd_section_removed_from_list (output_bfd,
						(*secpp)->output_section)))
	skip = TRUE;
#endif

      /* If we stripping debugging symbols, and this is a debugging
         symbol, then skip it.  FIXME: gas sets the section to N_ABS
         for some types of debugging symbols; I don't know if this is
         a bug or not.  In any case, we handle it here.  */
      if (! skip
	  && flaginfo->info->strip == strip_debugger
	  && ! dont_skip_symbol
	  && (isym.n_scnum == N_DEBUG
	      || (isym.n_scnum == N_ABS
		  && (isym.n_sclass == C_AUTO
		      || isym.n_sclass == C_REG
		      || isym.n_sclass == C_MOS
		      || isym.n_sclass == C_MOE
		      || isym.n_sclass == C_MOU
		      || isym.n_sclass == C_ARG
		      || isym.n_sclass == C_REGPARM
		      || isym.n_sclass == C_FIELD
		      || isym.n_sclass == C_EOS))))
	skip = TRUE;

      /* If some symbols are stripped based on the name, work out the
	 name and decide whether to skip this symbol.  */
      if (! skip
	  && (flaginfo->info->strip == strip_some
	      || flaginfo->info->discard == discard_l))
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];

	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
	  if (name == NULL)
	    return FALSE;

	  if (! dont_skip_symbol
	      && ((flaginfo->info->strip == strip_some
		   && (bfd_hash_lookup (flaginfo->info->keep_hash, name, FALSE,
				    FALSE) == NULL))
		   || (! global
		       && flaginfo->info->discard == discard_l
		       && bfd_is_local_label_name (input_bfd, name))))
	    skip = TRUE;
	}

      /* If this is an enum, struct, or union tag, see if we have
         already output an identical type.  */
      if (! skip
	  && (flaginfo->output_bfd->flags & BFD_TRADITIONAL_FORMAT) == 0
	  && (isym.n_sclass == C_ENTAG
	      || isym.n_sclass == C_STRTAG
	      || isym.n_sclass == C_UNTAG)
	  && isym.n_numaux == 1)
	{
	  const char *name;
	  char buf[SYMNMLEN + 1];
	  struct coff_debug_merge_hash_entry *mh;
	  struct coff_debug_merge_type *mt;
	  union internal_auxent aux;
	  struct coff_debug_merge_element **epp;
	  bfd_byte *esl, *eslend;
	  struct internal_syment *islp;
	  bfd_size_type amt;

	  name = _bfd_coff_internal_syment_name (input_bfd, &isym, buf);
	  if (name == NULL)
	    return FALSE;

	  /* Ignore fake names invented by compiler; treat them all as
             the same name.  */
	  if (*name == '~' || *name == '.' || *name == '$'
	      || (*name == bfd_get_symbol_leading_char (input_bfd)
		  && (name[1] == '~' || name[1] == '.' || name[1] == '$')))
	    name = "";

	  mh = coff_debug_merge_hash_lookup (&flaginfo->debug_merge, name,
					     TRUE, TRUE);
	  if (mh == NULL)
	    return FALSE;

	  /* Allocate memory to hold type information.  If this turns
             out to be a duplicate, we pass this address to
             bfd_release.  */
	  amt = sizeof (struct coff_debug_merge_type);
	  mt = (struct coff_debug_merge_type *) bfd_alloc (input_bfd, amt);
	  if (mt == NULL)
	    return FALSE;
	  mt->type_class = isym.n_sclass;

	  /* Pick up the aux entry, which points to the end of the tag
             entries.  */
	  bfd_coff_swap_aux_in (input_bfd, (esym + isymesz),
				isym.n_type, isym.n_sclass, 0, isym.n_numaux,
				&aux);

	  /* Gather the elements.  */
	  epp = &mt->elements;
	  mt->elements = NULL;
	  islp = isymp + 2;
	  esl = esym + 2 * isymesz;
	  eslend = ((bfd_byte *) obj_coff_external_syms (input_bfd)
		    + aux.x_sym.x_fcnary.x_fcn.x_endndx.l * isymesz);
	  while (esl < eslend)
	    {
	      const char *elename;
	      char elebuf[SYMNMLEN + 1];
	      char *name_copy;

	      bfd_coff_swap_sym_in (input_bfd, esl, islp);

	      amt = sizeof (struct coff_debug_merge_element);
	      *epp = (struct coff_debug_merge_element *)
                  bfd_alloc (input_bfd, amt);
	      if (*epp == NULL)
		return FALSE;

	      elename = _bfd_coff_internal_syment_name (input_bfd, islp,
							elebuf);
	      if (elename == NULL)
		return FALSE;

	      amt = strlen (elename) + 1;
	      name_copy = (char *) bfd_alloc (input_bfd, amt);
	      if (name_copy == NULL)
		return FALSE;
	      strcpy (name_copy, elename);

	      (*epp)->name = name_copy;
	      (*epp)->type = islp->n_type;
	      (*epp)->tagndx = 0;
	      if (islp->n_numaux >= 1
		  && islp->n_type != T_NULL
		  && islp->n_sclass != C_EOS)
		{
		  union internal_auxent eleaux;
		  long indx;

		  bfd_coff_swap_aux_in (input_bfd, (esl + isymesz),
					islp->n_type, islp->n_sclass, 0,
					islp->n_numaux, &eleaux);
		  indx = eleaux.x_sym.x_tagndx.l;

		  /* FIXME: If this tagndx entry refers to a symbol
		     defined later in this file, we just ignore it.
		     Handling this correctly would be tedious, and may
		     not be required.  */
		  if (indx > 0
		      && (indx
			  < ((esym -
			      (bfd_byte *) obj_coff_external_syms (input_bfd))
			     / (long) isymesz)))
		    {
		      (*epp)->tagndx = flaginfo->sym_indices[indx];
		      if ((*epp)->tagndx < 0)
			(*epp)->tagndx = 0;
		    }
		}
	      epp = &(*epp)->next;
	      *epp = NULL;

	      esl += (islp->n_numaux + 1) * isymesz;
	      islp += islp->n_numaux + 1;
	    }

	  /* See if we already have a definition which matches this
             type.  We always output the type if it has no elements,
             for simplicity.  */
	  if (mt->elements == NULL)
	    bfd_release (input_bfd, mt);
	  else
	    {
	      struct coff_debug_merge_type *mtl;

	      for (mtl = mh->types; mtl != NULL; mtl = mtl->next)
		{
		  struct coff_debug_merge_element *me, *mel;

		  if (mtl->type_class != mt->type_class)
		    continue;

		  for (me = mt->elements, mel = mtl->elements;
		       me != NULL && mel != NULL;
		       me = me->next, mel = mel->next)
		    {
		      if (strcmp (me->name, mel->name) != 0
			  || me->type != mel->type
			  || me->tagndx != mel->tagndx)
			break;
		    }

		  if (me == NULL && mel == NULL)
		    break;
		}

	      if (mtl == NULL || (bfd_size_type) mtl->indx >= syment_base)
		{
		  /* This is the first definition of this type.  */
		  mt->indx = output_index;
		  mt->next = mh->types;
		  mh->types = mt;
		}
	      else
		{
		  /* This is a redefinition which can be merged.  */
		  bfd_release (input_bfd, mt);
		  *indexp = mtl->indx;
		  add = (eslend - esym) / isymesz;
		  skip = TRUE;
		}
	    }
	}

      /* We now know whether we are to skip this symbol or not.  */
      if (! skip)
	{
	  /* Adjust the symbol in order to output it.  */

	  if (isym._n._n_n._n_zeroes == 0
	      && isym._n._n_n._n_offset != 0)
	    {
	      const char *name;
	      bfd_size_type indx;

	      /* This symbol has a long name.  Enter it in the string
		 table we are building.  Note that we do not check
		 bfd_coff_symname_in_debug.  That is only true for
		 XCOFF, and XCOFF requires different linking code
		 anyhow.  */
	      name = _bfd_coff_internal_syment_name (input_bfd, &isym, NULL);
	      if (name == NULL)
		return FALSE;
	      indx = _bfd_stringtab_add (flaginfo->strtab, name, hash, copy);
	      if (indx == (bfd_size_type) -1)
		return FALSE;
	      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
	    }

	  switch (isym.n_sclass)
	    {
	    case C_AUTO:
	    case C_MOS:
	    case C_EOS:
	    case C_MOE:
	    case C_MOU:
	    case C_UNTAG:
	    case C_STRTAG:
	    case C_ENTAG:
	    case C_TPDEF:
	    case C_ARG:
	    case C_USTATIC:
	    case C_REG:
	    case C_REGPARM:
	    case C_FIELD:
	      /* The symbol value should not be modified.  */
	      break;

	    case C_FCN:
	      if (obj_pe (input_bfd)
		  && strcmp (isym.n_name, ".bf") != 0
		  && isym.n_scnum > 0)
		{
		  /* For PE, .lf and .ef get their value left alone,
		     while .bf gets relocated.  However, they all have
		     "real" section numbers, and need to be moved into
		     the new section.  */
		  isym.n_scnum = (*secpp)->output_section->target_index;
		  break;
		}
	      /* Fall through.  */
	    default:
	    case C_LABEL:  /* Not completely sure about these 2 */
	    case C_EXTDEF:
	    case C_BLOCK:
	    case C_EFCN:
	    case C_NULL:
	    case C_EXT:
	    case C_STAT:
	    case C_SECTION:
	    case C_NT_WEAK:
	      /* Compute new symbol location.  */
	    if (isym.n_scnum > 0)
	      {
		isym.n_scnum = (*secpp)->output_section->target_index;
		isym.n_value += (*secpp)->output_offset;
		if (! obj_pe (input_bfd))
		  isym.n_value -= (*secpp)->vma;
		if (! obj_pe (flaginfo->output_bfd))
		  isym.n_value += (*secpp)->output_section->vma;
	      }
	    break;

	    case C_FILE:
	      /* The value of a C_FILE symbol is the symbol index of
		 the next C_FILE symbol.  The value of the last C_FILE
		 symbol is the symbol index to the first external
		 symbol (actually, coff_renumber_symbols does not get
		 this right--it just sets the value of the last C_FILE
		 symbol to zero--and nobody has ever complained about
		 it).  We try to get this right, below, just before we
		 write the symbols out, but in the general case we may
		 have to write the symbol out twice.  */
	      if (flaginfo->last_file_index != -1
		  && flaginfo->last_file.n_value != (bfd_vma) output_index)
		{
		  /* We must correct the value of the last C_FILE
                     entry.  */
		  flaginfo->last_file.n_value = output_index;
		  if ((bfd_size_type) flaginfo->last_file_index >= syment_base)
		    {
		      /* The last C_FILE symbol is in this input file.  */
		      bfd_coff_swap_sym_out (output_bfd,
					     &flaginfo->last_file,
					     (flaginfo->outsyms
					      + ((flaginfo->last_file_index
						  - syment_base)
						 * osymesz)));
		    }
		  else
		    {
		      file_ptr pos;

		      /* We have already written out the last C_FILE
			 symbol.  We need to write it out again.  We
			 borrow *outsym temporarily.  */
		      bfd_coff_swap_sym_out (output_bfd,
					     &flaginfo->last_file, outsym);
		      pos = obj_sym_filepos (output_bfd);
		      pos += flaginfo->last_file_index * osymesz;
		      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
			  || bfd_bwrite (outsym, osymesz, output_bfd) != osymesz)
			return FALSE;
		    }
		}

	      flaginfo->last_file_index = output_index;
	      flaginfo->last_file = isym;
	      break;
	    }

	  /* If doing task linking, convert normal global function symbols to
	     static functions.  */
	  if (flaginfo->info->task_link && IS_EXTERNAL (input_bfd, isym))
	    isym.n_sclass = C_STAT;

	  /* Output the symbol.  */
	  bfd_coff_swap_sym_out (output_bfd, &isym, outsym);

	  *indexp = output_index;

	  if (global)
	    {
	      long indx;
	      struct coff_link_hash_entry *h;

	      indx = ((esym - (bfd_byte *) obj_coff_external_syms (input_bfd))
		      / isymesz);
	      h = obj_coff_sym_hashes (input_bfd)[indx];
	      if (h == NULL)
		{
		  /* This can happen if there were errors earlier in
                     the link.  */
		  bfd_set_error (bfd_error_bad_value);
		  return FALSE;
		}
	      h->indx = output_index;
	    }

	  output_index += add;
	  outsym += add * osymesz;
	}

      esym += add * isymesz;
      isymp += add;
      ++secpp;
      ++indexp;
      for (--add; add > 0; --add)
	{
	  *secpp++ = NULL;
	  *indexp++ = -1;
	}
    }

  /* Fix up the aux entries.  This must be done in a separate pass,
     because we don't know the correct symbol indices until we have
     already decided which symbols we are going to keep.  */
  esym = (bfd_byte *) obj_coff_external_syms (input_bfd);
  esym_end = esym + obj_raw_syment_count (input_bfd) * isymesz;
  isymp = flaginfo->internal_syms;
  indexp = flaginfo->sym_indices;
  sym_hash = obj_coff_sym_hashes (input_bfd);
  outsym = flaginfo->outsyms;

  while (esym < esym_end)
    {
      int add;

      add = 1 + isymp->n_numaux;

      if ((*indexp < 0
	   || (bfd_size_type) *indexp < syment_base)
	  && (*sym_hash == NULL
	      || (*sym_hash)->auxbfd != input_bfd))
	esym += add * isymesz;
      else
	{
	  struct coff_link_hash_entry *h;
	  int i;

	  h = NULL;
	  if (*indexp < 0)
	    {
	      h = *sym_hash;

	      /* The m68k-motorola-sysv assembler will sometimes
                 generate two symbols with the same name, but only one
                 will have aux entries.  */
	      BFD_ASSERT (isymp->n_numaux == 0
			  || h->numaux == 0
			  || h->numaux == isymp->n_numaux);
	    }

	  esym += isymesz;

	  if (h == NULL)
	    outsym += osymesz;

	  /* Handle the aux entries.  This handling is based on
	     coff_pointerize_aux.  I don't know if it always correct.  */
	  for (i = 0; i < isymp->n_numaux && esym < esym_end; i++)
	    {
	      union internal_auxent aux;
	      union internal_auxent *auxp;

	      if (h != NULL && h->aux != NULL && (h->numaux > i))
		auxp = h->aux + i;
	      else
		{
		  bfd_coff_swap_aux_in (input_bfd, esym, isymp->n_type,
					isymp->n_sclass, i, isymp->n_numaux, &aux);
		  auxp = &aux;
		}

	      if (isymp->n_sclass == C_FILE)
		{
		  /* If this is a long filename, we must put it in the
		     string table.  */
		  if (auxp->x_file.x_n.x_zeroes == 0
		      && auxp->x_file.x_n.x_offset != 0)
		    {
		      const char *filename;
		      bfd_size_type indx;

		      BFD_ASSERT (auxp->x_file.x_n.x_offset
				  >= STRING_SIZE_SIZE);
		      if (strings == NULL)
			{
			  strings = _bfd_coff_read_string_table (input_bfd);
			  if (strings == NULL)
			    return FALSE;
			}
		      filename = strings + auxp->x_file.x_n.x_offset;
		      indx = _bfd_stringtab_add (flaginfo->strtab, filename,
						 hash, copy);
		      if (indx == (bfd_size_type) -1)
			return FALSE;
		      auxp->x_file.x_n.x_offset = STRING_SIZE_SIZE + indx;
		    }
		}
	      else if ((isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
		       && isymp->n_sclass != C_NT_WEAK)
		{
		  unsigned long indx;

		  if (ISFCN (isymp->n_type)
		      || ISTAG (isymp->n_sclass)
		      || isymp->n_sclass == C_BLOCK
		      || isymp->n_sclass == C_FCN)
		    {
		      indx = auxp->x_sym.x_fcnary.x_fcn.x_endndx.l;
		      if (indx > 0
			  && indx < obj_raw_syment_count (input_bfd))
			{
			  /* We look forward through the symbol for
                             the index of the next symbol we are going
                             to include.  I don't know if this is
                             entirely right.  */
			  while ((flaginfo->sym_indices[indx] < 0
				  || ((bfd_size_type) flaginfo->sym_indices[indx]
				      < syment_base))
				 && indx < obj_raw_syment_count (input_bfd))
			    ++indx;
			  if (indx >= obj_raw_syment_count (input_bfd))
			    indx = output_index;
			  else
			    indx = flaginfo->sym_indices[indx];
			  auxp->x_sym.x_fcnary.x_fcn.x_endndx.l = indx;
			}
		    }

		  indx = auxp->x_sym.x_tagndx.l;
		  if (indx > 0 && indx < obj_raw_syment_count (input_bfd))
		    {
		      long symindx;

		      symindx = flaginfo->sym_indices[indx];
		      if (symindx < 0)
			auxp->x_sym.x_tagndx.l = 0;
		      else
			auxp->x_sym.x_tagndx.l = symindx;
		    }

		  /* The .bf symbols are supposed to be linked through
		     the endndx field.  We need to carry this list
		     across object files.  */
		  if (i == 0
		      && h == NULL
		      && isymp->n_sclass == C_FCN
		      && (isymp->_n._n_n._n_zeroes != 0
			  || isymp->_n._n_n._n_offset == 0)
		      && isymp->_n._n_name[0] == '.'
		      && isymp->_n._n_name[1] == 'b'
		      && isymp->_n._n_name[2] == 'f'
		      && isymp->_n._n_name[3] == '\0')
		    {
		      if (flaginfo->last_bf_index != -1)
			{
			  flaginfo->last_bf.x_sym.x_fcnary.x_fcn.x_endndx.l =
			    *indexp;

			  if ((bfd_size_type) flaginfo->last_bf_index
			      >= syment_base)
			    {
			      void *auxout;

			      /* The last .bf symbol is in this input
				 file.  This will only happen if the
				 assembler did not set up the .bf
				 endndx symbols correctly.  */
			      auxout = (flaginfo->outsyms
					+ ((flaginfo->last_bf_index
					    - syment_base)
					   * osymesz));

			      bfd_coff_swap_aux_out (output_bfd,
						     &flaginfo->last_bf,
						     isymp->n_type,
						     isymp->n_sclass,
						     0, isymp->n_numaux,
						     auxout);
			    }
			  else
			    {
			      file_ptr pos;

			      /* We have already written out the last
                                 .bf aux entry.  We need to write it
                                 out again.  We borrow *outsym
                                 temporarily.  FIXME: This case should
                                 be made faster.  */
			      bfd_coff_swap_aux_out (output_bfd,
						     &flaginfo->last_bf,
						     isymp->n_type,
						     isymp->n_sclass,
						     0, isymp->n_numaux,
						     outsym);
			      pos = obj_sym_filepos (output_bfd);
			      pos += flaginfo->last_bf_index * osymesz;
			      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
				  || (bfd_bwrite (outsym, osymesz, output_bfd)
				      != osymesz))
				return FALSE;
			    }
			}

		      if (auxp->x_sym.x_fcnary.x_fcn.x_endndx.l != 0)
			flaginfo->last_bf_index = -1;
		      else
			{
			  /* The endndx field of this aux entry must
                             be updated with the symbol number of the
                             next .bf symbol.  */
			  flaginfo->last_bf = *auxp;
			  flaginfo->last_bf_index = (((outsym - flaginfo->outsyms)
						   / osymesz)
						  + syment_base);
			}
		    }
		}

	      if (h == NULL)
		{
		  bfd_coff_swap_aux_out (output_bfd, auxp, isymp->n_type,
					 isymp->n_sclass, i, isymp->n_numaux,
					 outsym);
		  outsym += osymesz;
		}

	      esym += isymesz;
	    }
	}

      indexp += add;
      isymp += add;
      sym_hash += add;
    }

  /* Relocate the line numbers, unless we are stripping them.  */
  if (flaginfo->info->strip == strip_none
      || flaginfo->info->strip == strip_some)
    {
      for (o = input_bfd->sections; o != NULL; o = o->next)
	{
	  bfd_vma offset;
	  bfd_byte *eline;
	  bfd_byte *elineend;
	  bfd_byte *oeline;
	  bfd_boolean skipping;
	  file_ptr pos;
	  bfd_size_type amt;

	  /* FIXME: If SEC_HAS_CONTENTS is not for the section, then
	     build_link_order in ldwrite.c will not have created a
	     link order, which means that we will not have seen this
	     input section in _bfd_coff_final_link, which means that
	     we will not have allocated space for the line numbers of
	     this section.  I don't think line numbers can be
	     meaningful for a section which does not have
	     SEC_HAS_CONTENTS set, but, if they do, this must be
	     changed.  */
	  if (o->lineno_count == 0
	      || (o->output_section->flags & SEC_HAS_CONTENTS) == 0)
	    continue;

	  if (bfd_seek (input_bfd, o->line_filepos, SEEK_SET) != 0
	      || bfd_bread (flaginfo->linenos, linesz * o->lineno_count,
			   input_bfd) != linesz * o->lineno_count)
	    return FALSE;

	  offset = o->output_section->vma + o->output_offset - o->vma;
	  eline = flaginfo->linenos;
	  oeline = flaginfo->linenos;
	  elineend = eline + linesz * o->lineno_count;
	  skipping = FALSE;
	  for (; eline < elineend; eline += linesz)
	    {
	      struct internal_lineno iline;

	      bfd_coff_swap_lineno_in (input_bfd, eline, &iline);

	      if (iline.l_lnno != 0)
		iline.l_addr.l_paddr += offset;
	      else if (iline.l_addr.l_symndx >= 0
		       && ((unsigned long) iline.l_addr.l_symndx
			   < obj_raw_syment_count (input_bfd)))
		{
		  long indx;

		  indx = flaginfo->sym_indices[iline.l_addr.l_symndx];

		  if (indx < 0)
		    {
		      /* These line numbers are attached to a symbol
			 which we are stripping.  We must discard the
			 line numbers because reading them back with
			 no associated symbol (or associating them all
			 with symbol #0) will fail.  We can't regain
			 the space in the output file, but at least
			 they're dense.  */
		      skipping = TRUE;
		    }
		  else
		    {
		      struct internal_syment is;
		      union internal_auxent ia;

		      /* Fix up the lnnoptr field in the aux entry of
			 the symbol.  It turns out that we can't do
			 this when we modify the symbol aux entries,
			 because gas sometimes screws up the lnnoptr
			 field and makes it an offset from the start
			 of the line numbers rather than an absolute
			 file index.  */
		      bfd_coff_swap_sym_in (output_bfd,
					    (flaginfo->outsyms
					     + ((indx - syment_base)
						* osymesz)), &is);
		      if ((ISFCN (is.n_type)
			   || is.n_sclass == C_BLOCK)
			  && is.n_numaux >= 1)
			{
			  void *auxptr;

			  auxptr = (flaginfo->outsyms
				    + ((indx - syment_base + 1)
				       * osymesz));
			  bfd_coff_swap_aux_in (output_bfd, auxptr,
						is.n_type, is.n_sclass,
						0, is.n_numaux, &ia);
			  ia.x_sym.x_fcnary.x_fcn.x_lnnoptr =
			    (o->output_section->line_filepos
			     + o->output_section->lineno_count * linesz
			     + eline - flaginfo->linenos);
			  bfd_coff_swap_aux_out (output_bfd, &ia,
						 is.n_type, is.n_sclass, 0,
						 is.n_numaux, auxptr);
			}

		      skipping = FALSE;
		    }

		  iline.l_addr.l_symndx = indx;
		}

	      if (!skipping)
	        {
		  bfd_coff_swap_lineno_out (output_bfd, &iline, oeline);
		  oeline += linesz;
		}
	    }

	  pos = o->output_section->line_filepos;
	  pos += o->output_section->lineno_count * linesz;
	  amt = oeline - flaginfo->linenos;
	  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
	      || bfd_bwrite (flaginfo->linenos, amt, output_bfd) != amt)
	    return FALSE;

	  o->output_section->lineno_count += amt / linesz;
	}
    }

  /* If we swapped out a C_FILE symbol, guess that the next C_FILE
     symbol will be the first symbol in the next input file.  In the
     normal case, this will save us from writing out the C_FILE symbol
     again.  */
  if (flaginfo->last_file_index != -1
      && (bfd_size_type) flaginfo->last_file_index >= syment_base)
    {
      flaginfo->last_file.n_value = output_index;
      bfd_coff_swap_sym_out (output_bfd, &flaginfo->last_file,
			     (flaginfo->outsyms
			      + ((flaginfo->last_file_index - syment_base)
				 * osymesz)));
    }

  /* Write the modified symbols to the output file.  */
  if (outsym > flaginfo->outsyms)
    {
      file_ptr pos;
      bfd_size_type amt;

      pos = obj_sym_filepos (output_bfd) + syment_base * osymesz;
      amt = outsym - flaginfo->outsyms;
      if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
	  || bfd_bwrite (flaginfo->outsyms, amt, output_bfd) != amt)
	return FALSE;

      BFD_ASSERT ((obj_raw_syment_count (output_bfd)
		   + (outsym - flaginfo->outsyms) / osymesz)
		  == output_index);

      obj_raw_syment_count (output_bfd) = output_index;
    }

  /* Relocate the contents of each section.  */
  adjust_symndx = coff_backend_info (input_bfd)->_bfd_coff_adjust_symndx;
  for (o = input_bfd->sections; o != NULL; o = o->next)
    {
      bfd_byte *contents;
      struct coff_section_tdata *secdata;

      if (! o->linker_mark)
	/* This section was omitted from the link.  */
	continue;

      if ((o->flags & SEC_LINKER_CREATED) != 0)
	continue;

      if ((o->flags & SEC_HAS_CONTENTS) == 0
	  || (o->size == 0 && (o->flags & SEC_RELOC) == 0))
	{
	  if ((o->flags & SEC_RELOC) != 0
	      && o->reloc_count != 0)
	    {
	      (*_bfd_error_handler)
		(_("%B: relocs in section `%A', but it has no contents"),
		 input_bfd, o);
	      bfd_set_error (bfd_error_no_contents);
	      return FALSE;
	    }

	  continue;
	}

      secdata = coff_section_data (input_bfd, o);
      if (secdata != NULL && secdata->contents != NULL)
	contents = secdata->contents;
      else
	{
	  contents = flaginfo->contents;
	  if (! bfd_get_full_section_contents (input_bfd, o, &contents))
	    return FALSE;
	}

      if ((o->flags & SEC_RELOC) != 0)
	{
	  int target_index;
	  struct internal_reloc *internal_relocs;
	  struct internal_reloc *irel;

	  /* Read in the relocs.  */
	  target_index = o->output_section->target_index;
	  internal_relocs = (_bfd_coff_read_internal_relocs
			     (input_bfd, o, FALSE, flaginfo->external_relocs,
			      flaginfo->info->relocatable,
			      (flaginfo->info->relocatable
			       ? (flaginfo->section_info[target_index].relocs
				  + o->output_section->reloc_count)
			       : flaginfo->internal_relocs)));
	  if (internal_relocs == NULL
	      && o->reloc_count > 0)
	    return FALSE;

	  /* Run through the relocs looking for relocs against symbols
	     coming from discarded sections and complain about them.  */
	  irel = internal_relocs;
	  for (; irel < &internal_relocs[o->reloc_count]; irel++)
	    {
	      struct coff_link_hash_entry *h;
	      asection *ps = NULL;
	      long symndx = irel->r_symndx;
	      if (symndx < 0)
		continue;
	      h = obj_coff_sym_hashes (input_bfd)[symndx];
	      if (h == NULL)
		continue;
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct coff_link_hash_entry *) h->root.u.i.link;
	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		ps = h->root.u.def.section;
	      if (ps == NULL)
		continue;
	      /* Complain if definition comes from an excluded section.  */
	      if (ps->flags & SEC_EXCLUDE)
		(*flaginfo->info->callbacks->einfo)
		  (_("%X`%s' referenced in section `%A' of %B: "
		     "defined in discarded section `%A' of %B\n"),
		   h->root.root.string, o, input_bfd, ps, ps->owner);
	    }

	  /* Call processor specific code to relocate the section
             contents.  */
	  if (! bfd_coff_relocate_section (output_bfd, flaginfo->info,
					   input_bfd, o,
					   contents,
					   internal_relocs,
					   flaginfo->internal_syms,
					   flaginfo->sec_ptrs))
	    return FALSE;

	  if (flaginfo->info->relocatable)
	    {
	      bfd_vma offset;
	      struct internal_reloc *irelend;
	      struct coff_link_hash_entry **rel_hash;

	      offset = o->output_section->vma + o->output_offset - o->vma;
	      irel = internal_relocs;
	      irelend = irel + o->reloc_count;
	      rel_hash = (flaginfo->section_info[target_index].rel_hashes
			  + o->output_section->reloc_count);
	      for (; irel < irelend; irel++, rel_hash++)
		{
		  struct coff_link_hash_entry *h;
		  bfd_boolean adjusted;

		  *rel_hash = NULL;

		  /* Adjust the reloc address and symbol index.  */
		  irel->r_vaddr += offset;

		  if (irel->r_symndx == -1)
		    continue;

		  if (adjust_symndx)
		    {
		      if (! (*adjust_symndx) (output_bfd, flaginfo->info,
					      input_bfd, o, irel,
					      &adjusted))
			return FALSE;
		      if (adjusted)
			continue;
		    }

		  h = obj_coff_sym_hashes (input_bfd)[irel->r_symndx];
		  if (h != NULL)
		    {
		      /* This is a global symbol.  */
		      if (h->indx >= 0)
			irel->r_symndx = h->indx;
		      else
			{
			  /* This symbol is being written at the end
			     of the file, and we do not yet know the
			     symbol index.  We save the pointer to the
			     hash table entry in the rel_hash list.
			     We set the indx field to -2 to indicate
			     that this symbol must not be stripped.  */
			  *rel_hash = h;
			  h->indx = -2;
			}
		    }
		  else
		    {
		      long indx;

		      indx = flaginfo->sym_indices[irel->r_symndx];
		      if (indx != -1)
			irel->r_symndx = indx;
		      else
			{
			  struct internal_syment *is;
			  const char *name;
			  char buf[SYMNMLEN + 1];

			  /* This reloc is against a symbol we are
                             stripping.  This should have been handled
			     by the 'dont_skip_symbol' code in the while
			     loop at the top of this function.  */
			  is = flaginfo->internal_syms + irel->r_symndx;

			  name = (_bfd_coff_internal_syment_name
				  (input_bfd, is, buf));
			  if (name == NULL)
			    return FALSE;

			  if (! ((*flaginfo->info->callbacks->unattached_reloc)
				 (flaginfo->info, name, input_bfd, o,
				  irel->r_vaddr)))
			    return FALSE;
			}
		    }
		}

	      o->output_section->reloc_count += o->reloc_count;
	    }
	}

      /* Write out the modified section contents.  */
      if (secdata == NULL || secdata->stab_info == NULL)
	{
	  file_ptr loc = o->output_offset * bfd_octets_per_byte (output_bfd);
	  if (! bfd_set_section_contents (output_bfd, o->output_section,
					  contents, loc, o->size))
	    return FALSE;
	}
      else
	{
	  if (! (_bfd_write_section_stabs
		 (output_bfd, &coff_hash_table (flaginfo->info)->stab_info,
		  o, &secdata->stab_info, contents)))
	    return FALSE;
	}
    }

  if (! flaginfo->info->keep_memory
      && ! _bfd_coff_free_symbols (input_bfd))
    return FALSE;

  return TRUE;
}

/* Write out a global symbol.  Called via bfd_hash_traverse.  */

bfd_boolean
_bfd_coff_write_global_sym (struct bfd_hash_entry *bh, void *data)
{
  struct coff_link_hash_entry *h = (struct coff_link_hash_entry *) bh;
  struct coff_final_link_info *flaginfo = (struct coff_final_link_info *) data;
  bfd *output_bfd;
  struct internal_syment isym;
  bfd_size_type symesz;
  unsigned int i;
  file_ptr pos;

  output_bfd = flaginfo->output_bfd;

  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct coff_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return TRUE;
    }

  if (h->indx >= 0)
    return TRUE;

  if (h->indx != -2
      && (flaginfo->info->strip == strip_all
	  || (flaginfo->info->strip == strip_some
	      && (bfd_hash_lookup (flaginfo->info->keep_hash,
				   h->root.root.string, FALSE, FALSE)
		  == NULL))))
    return TRUE;

  switch (h->root.type)
    {
    default:
    case bfd_link_hash_new:
    case bfd_link_hash_warning:
      abort ();
      return FALSE;

    case bfd_link_hash_undefined:
    case bfd_link_hash_undefweak:
      isym.n_scnum = N_UNDEF;
      isym.n_value = 0;
      break;

    case bfd_link_hash_defined:
    case bfd_link_hash_defweak:
      {
	asection *sec;

	sec = h->root.u.def.section->output_section;
	if (bfd_is_abs_section (sec))
	  isym.n_scnum = N_ABS;
	else
	  isym.n_scnum = sec->target_index;
	isym.n_value = (h->root.u.def.value
			+ h->root.u.def.section->output_offset);
	if (! obj_pe (flaginfo->output_bfd))
	  isym.n_value += sec->vma;
      }
      break;

    case bfd_link_hash_common:
      isym.n_scnum = N_UNDEF;
      isym.n_value = h->root.u.c.size;
      break;

    case bfd_link_hash_indirect:
      /* Just ignore these.  They can't be handled anyhow.  */
      return TRUE;
    }

  if (strlen (h->root.root.string) <= SYMNMLEN)
    strncpy (isym._n._n_name, h->root.root.string, SYMNMLEN);
  else
    {
      bfd_boolean hash;
      bfd_size_type indx;

      hash = TRUE;
      if ((output_bfd->flags & BFD_TRADITIONAL_FORMAT) != 0)
	hash = FALSE;
      indx = _bfd_stringtab_add (flaginfo->strtab, h->root.root.string, hash,
				 FALSE);
      if (indx == (bfd_size_type) -1)
	{
	  flaginfo->failed = TRUE;
	  return FALSE;
	}
      isym._n._n_n._n_zeroes = 0;
      isym._n._n_n._n_offset = STRING_SIZE_SIZE + indx;
    }

  isym.n_sclass = h->symbol_class;
  isym.n_type = h->type;

  if (isym.n_sclass == C_NULL)
    isym.n_sclass = C_EXT;

  /* If doing task linking and this is the pass where we convert
     defined globals to statics, then do that conversion now.  If the
     symbol is not being converted, just ignore it and it will be
     output during a later pass.  */
  if (flaginfo->global_to_static)
    {
      if (! IS_EXTERNAL (output_bfd, isym))
	return TRUE;

      isym.n_sclass = C_STAT;
    }

  /* When a weak symbol is not overridden by a strong one,
     turn it into an external symbol when not building a
     shared or relocatable object.  */
  if (! flaginfo->info->shared
      && ! flaginfo->info->relocatable
      && IS_WEAK_EXTERNAL (flaginfo->output_bfd, isym))
    isym.n_sclass = C_EXT;

  isym.n_numaux = h->numaux;

  bfd_coff_swap_sym_out (output_bfd, &isym, flaginfo->outsyms);

  symesz = bfd_coff_symesz (output_bfd);

  pos = obj_sym_filepos (output_bfd);
  pos += obj_raw_syment_count (output_bfd) * symesz;
  if (bfd_seek (output_bfd, pos, SEEK_SET) != 0
      || bfd_bwrite (flaginfo->outsyms, symesz, output_bfd) != symesz)
    {
      flaginfo->failed = TRUE;
      return FALSE;
    }

  h->indx = obj_raw_syment_count (output_bfd);

  ++obj_raw_syment_count (output_bfd);

  /* Write out any associated aux entries.  Most of the aux entries
     will have been modified in _bfd_coff_link_input_bfd.  We have to
     handle section aux entries here, now that we have the final
     relocation and line number counts.  */
  for (i = 0; i < isym.n_numaux; i++)
    {
      union internal_auxent *auxp;

      auxp = h->aux + i;

      /* Look for a section aux entry here using the same tests that
         coff_swap_aux_out uses.  */
      if (i == 0
	  && (isym.n_sclass == C_STAT
	      || isym.n_sclass == C_HIDDEN)
	  && isym.n_type == T_NULL
	  && (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak))
	{
	  asection *sec;

	  sec = h->root.u.def.section->output_section;
	  if (sec != NULL)
	    {
	      auxp->x_scn.x_scnlen = sec->size;

	      /* For PE, an overflow on the final link reportedly does
                 not matter.  FIXME: Why not?  */
	      if (sec->reloc_count > 0xffff
		  && (! obj_pe (output_bfd)
		      || flaginfo->info->relocatable))
		(*_bfd_error_handler)
		  (_("%s: %s: reloc overflow: 0x%lx > 0xffff"),
		   bfd_get_filename (output_bfd),
		   bfd_get_section_name (output_bfd, sec),
		   sec->reloc_count);

	      if (sec->lineno_count > 0xffff
		  && (! obj_pe (output_bfd)
		      || flaginfo->info->relocatable))
		(*_bfd_error_handler)
		  (_("%s: warning: %s: line number overflow: 0x%lx > 0xffff"),
		   bfd_get_filename (output_bfd),
		   bfd_get_section_name (output_bfd, sec),
		   sec->lineno_count);

	      auxp->x_scn.x_nreloc = sec->reloc_count;
	      auxp->x_scn.x_nlinno = sec->lineno_count;
	      auxp->x_scn.x_checksum = 0;
	      auxp->x_scn.x_associated = 0;
	      auxp->x_scn.x_comdat = 0;
	    }
	}

      bfd_coff_swap_aux_out (output_bfd, auxp, isym.n_type,
			     isym.n_sclass, (int) i, isym.n_numaux,
			     flaginfo->outsyms);
      if (bfd_bwrite (flaginfo->outsyms, symesz, output_bfd) != symesz)
	{
	  flaginfo->failed = TRUE;
	  return FALSE;
	}
      ++obj_raw_syment_count (output_bfd);
    }

  return TRUE;
}

/* Write out task global symbols, converting them to statics.  Called
   via coff_link_hash_traverse.  Calls bfd_coff_write_global_sym to do
   the dirty work, if the symbol we are processing needs conversion.  */

bfd_boolean
_bfd_coff_write_task_globals (struct coff_link_hash_entry *h, void *data)
{
  struct coff_final_link_info *flaginfo = (struct coff_final_link_info *) data;
  bfd_boolean rtnval = TRUE;
  bfd_boolean save_global_to_static;

  if (h->root.type == bfd_link_hash_warning)
    h = (struct coff_link_hash_entry *) h->root.u.i.link;

  if (h->indx < 0)
    {
      switch (h->root.type)
	{
	case bfd_link_hash_defined:
	case bfd_link_hash_defweak:
	  save_global_to_static = flaginfo->global_to_static;
	  flaginfo->global_to_static = TRUE;
	  rtnval = _bfd_coff_write_global_sym (&h->root.root, data);
	  flaginfo->global_to_static = save_global_to_static;
	  break;
	default:
	  break;
	}
    }
  return (rtnval);
}

/* Handle a link order which is supposed to generate a reloc.  */

bfd_boolean
_bfd_coff_reloc_link_order (bfd *output_bfd,
			    struct coff_final_link_info *flaginfo,
			    asection *output_section,
			    struct bfd_link_order *link_order)
{
  reloc_howto_type *howto;
  struct internal_reloc *irel;
  struct coff_link_hash_entry **rel_hash_ptr;

  howto = bfd_reloc_type_lookup (output_bfd, link_order->u.reloc.p->reloc);
  if (howto == NULL)
    {
      bfd_set_error (bfd_error_bad_value);
      return FALSE;
    }

  if (link_order->u.reloc.p->addend != 0)
    {
      bfd_size_type size;
      bfd_byte *buf;
      bfd_reloc_status_type rstat;
      bfd_boolean ok;
      file_ptr loc;

      size = bfd_get_reloc_size (howto);
      buf = (bfd_byte *) bfd_zmalloc (size);
      if (buf == NULL)
	return FALSE;

      rstat = _bfd_relocate_contents (howto, output_bfd,
				      (bfd_vma) link_order->u.reloc.p->addend,\
				      buf);
      switch (rstat)
	{
	case bfd_reloc_ok:
	  break;
	default:
	case bfd_reloc_outofrange:
	  abort ();
	case bfd_reloc_overflow:
	  if (! ((*flaginfo->info->callbacks->reloc_overflow)
		 (flaginfo->info, NULL,
		  (link_order->type == bfd_section_reloc_link_order
		   ? bfd_section_name (output_bfd,
				       link_order->u.reloc.p->u.section)
		   : link_order->u.reloc.p->u.name),
		  howto->name, link_order->u.reloc.p->addend,
		  (bfd *) NULL, (asection *) NULL, (bfd_vma) 0)))
	    {
	      free (buf);
	      return FALSE;
	    }
	  break;
	}
      loc = link_order->offset * bfd_octets_per_byte (output_bfd);
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
                                     loc, size);
      free (buf);
      if (! ok)
	return FALSE;
    }

  /* Store the reloc information in the right place.  It will get
     swapped and written out at the end of the final_link routine.  */
  irel = (flaginfo->section_info[output_section->target_index].relocs
	  + output_section->reloc_count);
  rel_hash_ptr = (flaginfo->section_info[output_section->target_index].rel_hashes
		  + output_section->reloc_count);

  memset (irel, 0, sizeof (struct internal_reloc));
  *rel_hash_ptr = NULL;

  irel->r_vaddr = output_section->vma + link_order->offset;

  if (link_order->type == bfd_section_reloc_link_order)
    {
      /* We need to somehow locate a symbol in the right section.  The
         symbol must either have a value of zero, or we must adjust
         the addend by the value of the symbol.  FIXME: Write this
         when we need it.  The old linker couldn't handle this anyhow.  */
      abort ();
      *rel_hash_ptr = NULL;
      irel->r_symndx = 0;
    }
  else
    {
      struct coff_link_hash_entry *h;

      h = ((struct coff_link_hash_entry *)
	   bfd_wrapped_link_hash_lookup (output_bfd, flaginfo->info,
					 link_order->u.reloc.p->u.name,
					 FALSE, FALSE, TRUE));
      if (h != NULL)
	{
	  if (h->indx >= 0)
	    irel->r_symndx = h->indx;
	  else
	    {
	      /* Set the index to -2 to force this symbol to get
		 written out.  */
	      h->indx = -2;
	      *rel_hash_ptr = h;
	      irel->r_symndx = 0;
	    }
	}
      else
	{
	  if (! ((*flaginfo->info->callbacks->unattached_reloc)
		 (flaginfo->info, link_order->u.reloc.p->u.name, (bfd *) NULL,
		  (asection *) NULL, (bfd_vma) 0)))
	    return FALSE;
	  irel->r_symndx = 0;
	}
    }

  /* FIXME: Is this always right?  */
  irel->r_type = howto->type;

  /* r_size is only used on the RS/6000, which needs its own linker
     routines anyhow.  r_extern is only used for ECOFF.  */

  /* FIXME: What is the right value for r_offset?  Is zero OK?  */
  ++output_section->reloc_count;

  return TRUE;
}

/* A basic reloc handling routine which may be used by processors with
   simple relocs.  */

bfd_boolean
_bfd_coff_generic_relocate_section (bfd *output_bfd,
				    struct bfd_link_info *info,
				    bfd *input_bfd,
				    asection *input_section,
				    bfd_byte *contents,
				    struct internal_reloc *relocs,
				    struct internal_syment *syms,
				    asection **sections)
{
  struct internal_reloc *rel;
  struct internal_reloc *relend;

  rel = relocs;
  relend = rel + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      long symndx;
      struct coff_link_hash_entry *h;
      struct internal_syment *sym;
      bfd_vma addend;
      bfd_vma val;
      reloc_howto_type *howto;
      bfd_reloc_status_type rstat;

      symndx = rel->r_symndx;

      if (symndx == -1)
	{
	  h = NULL;
	  sym = NULL;
	}
      else if (symndx < 0
	       || (unsigned long) symndx >= obj_raw_syment_count (input_bfd))
	{
	  (*_bfd_error_handler)
	    ("%B: illegal symbol index %ld in relocs", input_bfd, symndx);
	  return FALSE;
	}
      else
	{
	  h = obj_coff_sym_hashes (input_bfd)[symndx];
	  sym = syms + symndx;
	}

      /* COFF treats common symbols in one of two ways.  Either the
         size of the symbol is included in the section contents, or it
         is not.  We assume that the size is not included, and force
         the rtype_to_howto function to adjust the addend as needed.  */
      if (sym != NULL && sym->n_scnum != 0)
	addend = - sym->n_value;
      else
	addend = 0;

      howto = bfd_coff_rtype_to_howto (input_bfd, input_section, rel, h,
				       sym, &addend);
      if (howto == NULL)
	return FALSE;

      /* If we are doing a relocatable link, then we can just ignore
         a PC relative reloc that is pcrel_offset.  It will already
         have the correct value.  If this is not a relocatable link,
         then we should ignore the symbol value.  */
      if (howto->pc_relative && howto->pcrel_offset)
	{
	  if (info->relocatable)
	    continue;
	  if (sym != NULL && sym->n_scnum != 0)
	    addend += sym->n_value;
	}

      val = 0;

      if (h == NULL)
	{
	  asection *sec;

	  if (symndx == -1)
	    {
	      sec = bfd_abs_section_ptr;
	      val = 0;
	    }
	  else
	    {
	      sec = sections[symndx];
              val = (sec->output_section->vma
		     + sec->output_offset
		     + sym->n_value);
	      if (! obj_pe (input_bfd))
		val -= sec->vma;
	    }
	}
      else
	{
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      /* Defined weak symbols are a GNU extension. */
	      asection *sec;

	      sec = h->root.u.def.section;
	      val = (h->root.u.def.value
		     + sec->output_section->vma
		     + sec->output_offset);
	    }

	  else if (h->root.type == bfd_link_hash_undefweak)
	    {
              if (h->symbol_class == C_NT_WEAK && h->numaux == 1)
		{
		  /* See _Microsoft Portable Executable and Common Object
                     File Format Specification_, section 5.5.3.
		     Note that weak symbols without aux records are a GNU
		     extension.
		     FIXME: All weak externals are treated as having
		     characteristic IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY (1).
		     These behave as per SVR4 ABI:  A library member
		     will resolve a weak external only if a normal
		     external causes the library member to be linked.
		     See also linker.c: generic_link_check_archive_element. */
		  asection *sec;
		  struct coff_link_hash_entry *h2 =
		    h->auxbfd->tdata.coff_obj_data->sym_hashes[
		    h->aux->x_sym.x_tagndx.l];

		  if (!h2 || h2->root.type == bfd_link_hash_undefined)
		    {
		      sec = bfd_abs_section_ptr;
		      val = 0;
		    }
		  else
		    {
		      sec = h2->root.u.def.section;
		      val = h2->root.u.def.value
			+ sec->output_section->vma + sec->output_offset;
		    }
		}
	      else
                /* This is a GNU extension.  */
		val = 0;
	    }

	  else if (! info->relocatable)
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd, input_section,
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
	    }
	}

      if (info->base_file)
	{
	  /* Emit a reloc if the backend thinks it needs it.  */
	  if (sym && pe_data (output_bfd)->in_reloc_p (output_bfd, howto))
	    {
	      /* Relocation to a symbol in a section which isn't
		 absolute.  We output the address here to a file.
		 This file is then read by dlltool when generating the
		 reloc section.  Note that the base file is not
		 portable between systems.  We write out a bfd_vma here,
		 and dlltool reads in a bfd_vma.  */
	      bfd_vma addr = (rel->r_vaddr
			   - input_section->vma
			   + input_section->output_offset
			   + input_section->output_section->vma);
	      if (coff_data (output_bfd)->pe)
		addr -= pe_data(output_bfd)->pe_opthdr.ImageBase;
	      if (fwrite (&addr, 1, sizeof (bfd_vma), (FILE *) info->base_file)
		  != sizeof (bfd_vma))
		{
		  bfd_set_error (bfd_error_system_call);
		  return FALSE;
		}
	    }
	}

      rstat = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents,
					rel->r_vaddr - input_section->vma,
					val, addend);

      switch (rstat)
	{
	default:
	  abort ();
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_outofrange:
	  (*_bfd_error_handler)
	    (_("%B: bad reloc address 0x%lx in section `%A'"),
	     input_bfd, input_section, (unsigned long) rel->r_vaddr);
	  return FALSE;
	case bfd_reloc_overflow:
	  {
	    const char *name;
	    char buf[SYMNMLEN + 1];

	    if (symndx == -1)
	      name = "*ABS*";
	    else if (h != NULL)
	      name = NULL;
	    else
	      {
		name = _bfd_coff_internal_syment_name (input_bfd, sym, buf);
		if (name == NULL)
		  return FALSE;
	      }

	    if (! ((*info->callbacks->reloc_overflow)
		   (info, (h ? &h->root : NULL), name, howto->name,
		    (bfd_vma) 0, input_bfd, input_section,
		    rel->r_vaddr - input_section->vma)))
	      return FALSE;
	  }
	}
    }
  return TRUE;
}
@


1.83
log
@ChangeLog bfd

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* coff-i386.c (bfd_target): Add section flag SEC_EXCLUDE.
	Allow BFD_COMPRESS and BFD_DECOMPRESS flags.
	* coff-x86_64.c: Likewise.
	* coffcode.h (DOT_ZDEBUG): New define.
	(sec_to_styp_flags): Check for .zdebug.
	(styp_to_sec_flags): Likewise.
	* coffgen.c (make_a_section): Handle .debug_* section
	compression/decompression flags.
	* cofflink.c (mark_relocs): Ignore relocations
	for a section, which isn't marked as used.
	(_bfd_coff_link_input_bfd): Add support of compressed
	debug sections.
	* compress.c (decompress_contents): Loop as long
	as there is input available and there is room for
	output.
	* bfd/pe-arm.c: Add .zdebug_ partial match entry.
	* pe-i386.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't clear all
	data-directories as this might destroy content.

        * coff-i386.c (_bfd_generic_find_nearest_line_discriminator):
        define as coff_find_nearest_line_discriminator.
        * libcoff-in.h (coff_find_nearest_line_discriminator): New
        * libcoff.h: Regenerated.
        * coff-x86_64.c: Likewise.
        * coffgen.c (coff_find_nearest_line_discriminator): New function.
        prototype.

ChangeLog binutils

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	* objdump.c (dump_bfd): Call dump headers after
	call of slurp_symtab.

ChangeLog ld

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* NEWS: Menition new feature.
	* scripttempl/pep.sc: Add zdebug sections.
	* scripttempl/pe.sc: L
@
text
@d608 1
a608 1
	  
d617 1
a617 1
	      
d1162 1
a1162 1
	      
@


1.82
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d1427 2
a1428 1
      if ((a->flags & SEC_RELOC) == 0 || a->reloc_count  < 1)
d2430 2
a2431 2
	  bfd_size_type x = o->rawsize ? o->rawsize : o->size;
	  if (! bfd_get_section_contents (input_bfd, o, flaginfo->contents, 0, x))
a2432 1
	  contents = flaginfo->contents;
d2450 2
a2451 1
	  if (internal_relocs == NULL)
@


1.81
log
@	PR binutils/13121
	Rename 'finfo' to 'flaginfo' to avoid conflicts with
	AIX system headers.
@
text
@d1165 1
a1165 1
	      bfd_coff_swap_reloc_out (abfd, (PTR) &incount, (PTR) excount);
@


1.80
log
@Building EFI binaries, particularly larger ones (like e.g. Xen does), on Linux
(where relocatable objects are in ELF format) so far led to all local (aka
static) symbols to be discarded, making debugging quite a bit more difficult
(like Linux, Xen builds an internal symbol lookup table from nm output
generated on the binary produced by an earlier linking pass). Therefore, this
patch arranges to insert all (relevant) local symbols from non-COFF objects
into the final executable's symbol table between those coming from COFF input
files and the global ones.

bfd/
2011-11-02  Jan Beulich  <jbeulich@@suse.com>

	* coffgen.c (coff_write_alien_symbol): Make public. Add 'struct
	internal_syment *' parameter. Extend 'dummy' to an array with two
	elements. Set n_numaux early. Handle BSF_FILE.
	(coff_write_symbols): Pass NULL as new third argument to
	coff_write_alien_symbol().
	* cofflink.c (_bfd_coff_final_link): Don't use COFF-specific
	obj_raw_syment_count() on non-COFF input BFD. Insert local symbols
	from non-COFF input BFDs.
	* libcoff-in.h (coff_write_alien_symbol): Declare.
	* libcoff.h (coff_write_alien_symbol): Re-generate.
@
text
@d654 1
a654 1
  struct coff_final_link_info finfo;
d675 15
a689 15
  finfo.info = info;
  finfo.output_bfd = abfd;
  finfo.strtab = NULL;
  finfo.section_info = NULL;
  finfo.last_file_index = -1;
  finfo.last_bf_index = -1;
  finfo.internal_syms = NULL;
  finfo.sec_ptrs = NULL;
  finfo.sym_indices = NULL;
  finfo.outsyms = NULL;
  finfo.linenos = NULL;
  finfo.contents = NULL;
  finfo.external_relocs = NULL;
  finfo.internal_relocs = NULL;
  finfo.global_to_static = FALSE;
d694 2
a695 2
  finfo.strtab = _bfd_stringtab_init ();
  if (finfo.strtab == NULL)
d698 1
a698 1
  if (! coff_debug_merge_hash_table_init (&finfo.debug_merge))
d778 1
a778 1
	  if (_bfd_stringtab_add (finfo.strtab, o->name, FALSE, FALSE)
d795 2
a796 2
      finfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);
      if (finfo.section_info == NULL)
d800 2
a801 2
	  finfo.section_info[i].relocs = NULL;
	  finfo.section_info[i].rel_hashes = NULL;
d838 1
a838 1
	  finfo.section_info[o->target_index].relocs =
d842 1
a842 1
	  finfo.section_info[o->target_index].rel_hashes =
d844 2
a845 2
	  if (finfo.section_info[o->target_index].relocs == NULL
	      || finfo.section_info[o->target_index].rel_hashes == NULL)
d876 1
a876 1
  finfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
d878 1
a878 1
  finfo.sec_ptrs = (asection **) bfd_malloc (amt);
d880 2
a881 2
  finfo.sym_indices = (long int *) bfd_malloc (amt);
  finfo.outsyms = (bfd_byte *) bfd_malloc ((max_sym_count + 1) * symesz);
d883 2
a884 2
  finfo.linenos = (bfd_byte *) bfd_malloc (amt);
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
d886 1
a886 1
  finfo.external_relocs = (bfd_byte *) bfd_malloc (amt);
d890 1
a890 1
      finfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);
d892 7
a898 7
  if ((finfo.internal_syms == NULL && max_sym_count > 0)
      || (finfo.sec_ptrs == NULL && max_sym_count > 0)
      || (finfo.sym_indices == NULL && max_sym_count > 0)
      || finfo.outsyms == NULL
      || (finfo.linenos == NULL && max_lineno_count > 0)
      || (finfo.contents == NULL && max_contents_size > 0)
      || (finfo.external_relocs == NULL && max_reloc_count > 0)
d900 1
a900 1
	  && finfo.internal_relocs == NULL
d925 1
a925 1
	      if (! bfd_coff_link_output_has_begun (sub, & finfo))
d927 1
a927 1
		  if (! _bfd_coff_link_input_bfd (&finfo, sub))
d935 1
a935 1
	      if (! _bfd_coff_reloc_link_order (abfd, &finfo, o, p))
d946 1
a946 1
  if (finfo.info->strip != strip_all && finfo.info->discard != discard_all)
d973 2
a974 2
	      if ((finfo.info->strip == strip_some
		   && (bfd_hash_lookup (finfo.info->keep_hash,
d977 1
a977 1
		  || (((finfo.info->discard == discard_sec_merge
d979 2
a980 2
			&& ! finfo.info->relocatable)
		       || finfo.info->discard == discard_l)
d997 1
a997 1
		  indx = _bfd_stringtab_add (finfo.strtab,
d1003 1
a1003 1
		  bfd_coff_swap_sym_out (abfd, &isym, finfo.outsyms);
d1009 1
a1009 1
		  if (finfo.last_file_index != -1)
d1011 4
a1014 4
		      finfo.last_file.n_value = obj_raw_syment_count (abfd);
		      bfd_coff_swap_sym_out (abfd, &finfo.last_file,
					     finfo.outsyms);
		      pos = obj_sym_filepos (abfd) + finfo.last_file_index
d1018 2
a1019 2
		  finfo.last_file_index = obj_raw_syment_count (abfd);
		  finfo.last_file = isym;
d1024 1
a1024 1
		      || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz))
d1032 1
a1032 1
  if (! bfd_coff_final_link_postscript (abfd, & finfo))
d1037 1
a1037 1
  coff_debug_merge_hash_table_free (&finfo.debug_merge);
d1040 1
a1040 1
  if (finfo.internal_syms != NULL)
d1042 2
a1043 2
      free (finfo.internal_syms);
      finfo.internal_syms = NULL;
d1045 1
a1045 1
  if (finfo.sec_ptrs != NULL)
d1047 2
a1048 2
      free (finfo.sec_ptrs);
      finfo.sec_ptrs = NULL;
d1050 1
a1050 1
  if (finfo.sym_indices != NULL)
d1052 2
a1053 2
      free (finfo.sym_indices);
      finfo.sym_indices = NULL;
d1055 1
a1055 1
  if (finfo.linenos != NULL)
d1057 2
a1058 2
      free (finfo.linenos);
      finfo.linenos = NULL;
d1060 1
a1060 1
  if (finfo.contents != NULL)
d1062 2
a1063 2
      free (finfo.contents);
      finfo.contents = NULL;
d1065 1
a1065 1
  if (finfo.external_relocs != NULL)
d1067 2
a1068 2
      free (finfo.external_relocs);
      finfo.external_relocs = NULL;
d1070 1
a1070 1
  if (finfo.internal_relocs != NULL)
d1072 2
a1073 2
      free (finfo.internal_relocs);
      finfo.internal_relocs = NULL;
d1079 2
a1080 2
  if (finfo.last_file_index != -1
      && (unsigned int) finfo.last_file.n_value != obj_raw_syment_count (abfd))
d1084 3
a1086 3
      finfo.last_file.n_value = obj_raw_syment_count (abfd);
      bfd_coff_swap_sym_out (abfd, &finfo.last_file,
			     finfo.outsyms);
d1088 1
a1088 1
      pos = obj_sym_filepos (abfd) + finfo.last_file_index * symesz;
d1090 1
a1090 1
	  || bfd_bwrite (finfo.outsyms, symesz, abfd) != symesz)
d1099 1
a1099 1
      finfo.failed = FALSE;
d1101 2
a1102 2
			       _bfd_coff_write_task_globals, &finfo);
      if (finfo.failed)
d1107 3
a1109 3
  finfo.failed = FALSE;
  bfd_hash_traverse (&info->hash->table, _bfd_coff_write_global_sym, &finfo);
  if (finfo.failed)
d1113 1
a1113 1
  if (finfo.outsyms != NULL)
d1115 2
a1116 2
      free (finfo.outsyms);
      finfo.outsyms = NULL;
d1139 1
a1139 1
	  irel = finfo.section_info[o->target_index].relocs;
d1141 1
a1141 1
	  rel_hash = finfo.section_info[o->target_index].rel_hashes;
d1182 1
a1182 1
  if (finfo.section_info != NULL)
d1188 4
a1191 4
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
d1193 2
a1194 2
      free (finfo.section_info);
      finfo.section_info = NULL;
d1215 1
a1215 1
		_bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
d1225 1
a1225 1
      if (! _bfd_stringtab_emit (abfd, finfo.strtab))
d1231 1
a1231 1
  _bfd_stringtab_free (finfo.strtab);
d1241 4
a1244 4
    coff_debug_merge_hash_table_free (&finfo.debug_merge);
  if (finfo.strtab != NULL)
    _bfd_stringtab_free (finfo.strtab);
  if (finfo.section_info != NULL)
d1250 23
a1272 23
	  if (finfo.section_info[i].relocs != NULL)
	    free (finfo.section_info[i].relocs);
	  if (finfo.section_info[i].rel_hashes != NULL)
	    free (finfo.section_info[i].rel_hashes);
	}
      free (finfo.section_info);
    }
  if (finfo.internal_syms != NULL)
    free (finfo.internal_syms);
  if (finfo.sec_ptrs != NULL)
    free (finfo.sec_ptrs);
  if (finfo.sym_indices != NULL)
    free (finfo.sym_indices);
  if (finfo.outsyms != NULL)
    free (finfo.outsyms);
  if (finfo.linenos != NULL)
    free (finfo.linenos);
  if (finfo.contents != NULL)
    free (finfo.contents);
  if (finfo.external_relocs != NULL)
    free (finfo.external_relocs);
  if (finfo.internal_relocs != NULL)
    free (finfo.internal_relocs);
d1414 1
a1414 1
mark_relocs (struct coff_final_link_info *finfo, bfd *input_bfd)
d1436 5
a1440 5
	 finfo->external_relocs,
	 finfo->info->relocatable,
	 (finfo->info->relocatable
	  ? (finfo->section_info[ a->output_section->target_index ].relocs + a->output_section->reloc_count)
	  : finfo->internal_relocs)
d1454 1
a1454 1
	finfo->sym_indices[ irel->r_symndx ] = -1;
d1462 1
a1462 1
_bfd_coff_link_input_bfd (struct coff_final_link_info *finfo, bfd *input_bfd)
d1488 1
a1488 1
  output_bfd = finfo->output_bfd;
d1497 1
a1497 1
  if (! finfo->info->keep_memory)
d1508 3
a1510 3
  isymp = finfo->internal_syms;
  secpp = finfo->sec_ptrs;
  indexp = finfo->sym_indices;
d1512 1
a1512 1
  outsym = finfo->outsyms;
d1515 1
a1515 1
      && ! process_embedded_commands (output_bfd, finfo->info, input_bfd))
d1521 3
a1523 3
  if ((   finfo->info->strip   != strip_none
       || finfo->info->discard != discard_none)
      && finfo->info->relocatable)
d1528 1
a1528 1
      mark_relocs (finfo, input_bfd);
d1568 3
a1570 3
      if ((finfo->info->strip != strip_none
	   || finfo->info->discard != discard_none)
	  && finfo->info->relocatable)
d1582 1
a1582 1
      if (finfo->info->strip == strip_all && ! dont_skip_symbol)
d1612 1
a1612 1
	      if (finfo->info->discard == discard_all && ! dont_skip_symbol)
d1637 1
a1637 1
	  && finfo->info->strip == strip_debugger
d1655 2
a1656 2
	  && (finfo->info->strip == strip_some
	      || finfo->info->discard == discard_l))
d1666 2
a1667 2
	      && ((finfo->info->strip == strip_some
		   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
d1670 1
a1670 1
		       && finfo->info->discard == discard_l
d1678 1
a1678 1
	  && (finfo->output_bfd->flags & BFD_TRADITIONAL_FORMAT) == 0
d1705 1
a1705 1
	  mh = coff_debug_merge_hash_lookup (&finfo->debug_merge, name,
d1782 1
a1782 1
		      (*epp)->tagndx = finfo->sym_indices[indx];
d1861 1
a1861 1
	      indx = _bfd_stringtab_add (finfo->strtab, name, hash, copy);
d1916 1
a1916 1
		if (! obj_pe (finfo->output_bfd))
d1931 2
a1932 2
	      if (finfo->last_file_index != -1
		  && finfo->last_file.n_value != (bfd_vma) output_index)
d1936 2
a1937 2
		  finfo->last_file.n_value = output_index;
		  if ((bfd_size_type) finfo->last_file_index >= syment_base)
d1941 3
a1943 3
					     &finfo->last_file,
					     (finfo->outsyms
					      + ((finfo->last_file_index
d1955 1
a1955 1
					     &finfo->last_file, outsym);
d1957 1
a1957 1
		      pos += finfo->last_file_index * osymesz;
d1964 2
a1965 2
	      finfo->last_file_index = output_index;
	      finfo->last_file = isym;
d1971 1
a1971 1
	  if (finfo->info->task_link && IS_EXTERNAL (input_bfd, isym))
d2017 2
a2018 2
  isymp = finfo->internal_syms;
  indexp = finfo->sym_indices;
d2020 1
a2020 1
  outsym = finfo->outsyms;
d2091 1
a2091 1
		      indx = _bfd_stringtab_add (finfo->strtab, filename,
d2116 2
a2117 2
			  while ((finfo->sym_indices[indx] < 0
				  || ((bfd_size_type) finfo->sym_indices[indx]
d2124 1
a2124 1
			    indx = finfo->sym_indices[indx];
d2134 1
a2134 1
		      symindx = finfo->sym_indices[indx];
d2154 1
a2154 1
		      if (finfo->last_bf_index != -1)
d2156 1
a2156 1
			  finfo->last_bf.x_sym.x_fcnary.x_fcn.x_endndx.l =
d2159 1
a2159 1
			  if ((bfd_size_type) finfo->last_bf_index
d2168 2
a2169 2
			      auxout = (finfo->outsyms
					+ ((finfo->last_bf_index
d2174 1
a2174 1
						     &finfo->last_bf,
d2190 1
a2190 1
						     &finfo->last_bf,
d2196 1
a2196 1
			      pos += finfo->last_bf_index * osymesz;
d2205 1
a2205 1
			finfo->last_bf_index = -1;
d2211 2
a2212 2
			  finfo->last_bf = *auxp;
			  finfo->last_bf_index = (((outsym - finfo->outsyms)
d2237 2
a2238 2
  if (finfo->info->strip == strip_none
      || finfo->info->strip == strip_some)
d2264 1
a2264 1
	      || bfd_bread (finfo->linenos, linesz * o->lineno_count,
d2269 2
a2270 2
	  eline = finfo->linenos;
	  oeline = finfo->linenos;
d2287 1
a2287 1
		  indx = finfo->sym_indices[iline.l_addr.l_symndx];
d2313 1
a2313 1
					    (finfo->outsyms
d2322 1
a2322 1
			  auxptr = (finfo->outsyms
d2331 1
a2331 1
			     + eline - finfo->linenos);
d2352 1
a2352 1
	  amt = oeline - finfo->linenos;
d2354 1
a2354 1
	      || bfd_bwrite (finfo->linenos, amt, output_bfd) != amt)
d2365 2
a2366 2
  if (finfo->last_file_index != -1
      && (bfd_size_type) finfo->last_file_index >= syment_base)
d2368 4
a2371 4
      finfo->last_file.n_value = output_index;
      bfd_coff_swap_sym_out (output_bfd, &finfo->last_file,
			     (finfo->outsyms
			      + ((finfo->last_file_index - syment_base)
d2376 1
a2376 1
  if (outsym > finfo->outsyms)
d2382 1
a2382 1
      amt = outsym - finfo->outsyms;
d2384 1
a2384 1
	  || bfd_bwrite (finfo->outsyms, amt, output_bfd) != amt)
d2388 1
a2388 1
		   + (outsym - finfo->outsyms) / osymesz)
d2430 1
a2430 1
	  if (! bfd_get_section_contents (input_bfd, o, finfo->contents, 0, x))
d2432 1
a2432 1
	  contents = finfo->contents;
d2444 4
a2447 4
			     (input_bfd, o, FALSE, finfo->external_relocs,
			      finfo->info->relocatable,
			      (finfo->info->relocatable
			       ? (finfo->section_info[target_index].relocs
d2449 1
a2449 1
			       : finfo->internal_relocs)));
d2476 1
a2476 1
		(*finfo->info->callbacks->einfo)
d2484 1
a2484 1
	  if (! bfd_coff_relocate_section (output_bfd, finfo->info,
d2488 2
a2489 2
					   finfo->internal_syms,
					   finfo->sec_ptrs))
d2492 1
a2492 1
	  if (finfo->info->relocatable)
d2501 1
a2501 1
	      rel_hash = (finfo->section_info[target_index].rel_hashes
d2518 1
a2518 1
		      if (! (*adjust_symndx) (output_bfd, finfo->info,
d2548 1
a2548 1
		      indx = finfo->sym_indices[irel->r_symndx];
d2561 1
a2561 1
			  is = finfo->internal_syms + irel->r_symndx;
d2568 2
a2569 2
			  if (! ((*finfo->info->callbacks->unattached_reloc)
				 (finfo->info, name, input_bfd, o,
d2591 1
a2591 1
		 (output_bfd, &coff_hash_table (finfo->info)->stab_info,
d2597 1
a2597 1
  if (! finfo->info->keep_memory
d2610 1
a2610 1
  struct coff_final_link_info *finfo = (struct coff_final_link_info *) data;
d2617 1
a2617 1
  output_bfd = finfo->output_bfd;
d2630 3
a2632 3
      && (finfo->info->strip == strip_all
	  || (finfo->info->strip == strip_some
	      && (bfd_hash_lookup (finfo->info->keep_hash,
d2663 1
a2663 1
	if (! obj_pe (finfo->output_bfd))
d2688 1
a2688 1
      indx = _bfd_stringtab_add (finfo->strtab, h->root.root.string, hash,
d2692 1
a2692 1
	  finfo->failed = TRUE;
d2709 1
a2709 1
  if (finfo->global_to_static)
d2720 3
a2722 3
  if (! finfo->info->shared
      && ! finfo->info->relocatable
      && IS_WEAK_EXTERNAL (finfo->output_bfd, isym))
d2727 1
a2727 1
  bfd_coff_swap_sym_out (output_bfd, &isym, finfo->outsyms);
d2734 1
a2734 1
      || bfd_bwrite (finfo->outsyms, symesz, output_bfd) != symesz)
d2736 1
a2736 1
      finfo->failed = TRUE;
d2774 1
a2774 1
		      || finfo->info->relocatable))
d2783 1
a2783 1
		      || finfo->info->relocatable))
d2800 2
a2801 2
			     finfo->outsyms);
      if (bfd_bwrite (finfo->outsyms, symesz, output_bfd) != symesz)
d2803 1
a2803 1
	  finfo->failed = TRUE;
d2819 1
a2819 1
  struct coff_final_link_info *finfo = (struct coff_final_link_info *) data;
d2832 2
a2833 2
	  save_global_to_static = finfo->global_to_static;
	  finfo->global_to_static = TRUE;
d2835 1
a2835 1
	  finfo->global_to_static = save_global_to_static;
d2848 1
a2848 1
			    struct coff_final_link_info *finfo,
d2887 2
a2888 2
	  if (! ((*finfo->info->callbacks->reloc_overflow)
		 (finfo->info, NULL,
d2911 1
a2911 1
  irel = (finfo->section_info[output_section->target_index].relocs
d2913 1
a2913 1
  rel_hash_ptr = (finfo->section_info[output_section->target_index].rel_hashes
d2936 1
a2936 1
	   bfd_wrapped_link_hash_lookup (output_bfd, finfo->info,
d2954 2
a2955 2
	  if (! ((*finfo->info->callbacks->unattached_reloc)
		 (finfo->info, link_order->u.reloc.p->u.name, (bfd *) NULL,
@


1.79
log
@	PR ld/12762
bfd/
	* bfd-in.h (struct bfd_section_already_linked): Forward declare.
	(_bfd_handle_already_linked): Declare.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Define as
	_bfd_coff_section_already_linked.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* cofflink.c (coff_link_add_symbols): Revert 2011-07-09 changes.
	* elf-bfd.h: Likewise.
	* libbfd-in.h: Likewise.
	* targets.c: Likewise.
	* linker.c (bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(_bfd_generic_section_already_linked): Likewise.  Call
	_bfd_handle_already_linked.
	(_bfd_handle_already_linked): New function, split out from..
	* elflink.c (_bfd_elf_section_already_linked): ..here.  Revert
	2011-07-09 changes.  Avoid unnecessary strcmp when matching
	already_linked_list entries.  Match plugin linkonce section.
	(section_signature): Delete.
	* coffgen.c (_bfd_coff_section_already_linked): New function.
	* libcoff-in.h (_bfd_coff_section_already_linked): Declare.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Revert 2011-07-09 changes.
	* plugin.c: Likewise.
	(asymbol_from_plugin_symbol): Create linkonce section for syms
	with comdat_key.
@
text
@d869 1
a869 1
      sz = obj_raw_syment_count (sub);
d946 86
@


1.78
log
@	PR ld/12942
bfd/
	* elflink.c (elf_link_add_object_symbols): Use elf_discarded_section
	rather than kept_section to determine whether a symbol is from
	a discarded section.
	* cofflink.c (coff_link_add_symbols): Make symbols from discarded
	sections appear undefined.

	* elf-bfd.h (_bfd_elf_section_already_linked): Replace
	"asection *" with "struct already_linked *".
	* libbfd-in.h (_bfd_nolink_section_already_linked): Likewise.
	(_bfd_generic_section_already_linked): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(struct already_linked): New.
	(struct bfd_section_already_linked): Use it.
	* elflink.c (_bfd_elf_section_already_linked): Replace.
	"asection *" with "struct already_linked *".  Replace the plugin
	dummy with the LTO output.
	* linker.c (_bfd_generic_section_already_linked): Likewise.
	* targets.c (struct already_linked): Add forward declaration.
	(bfd_target): Replace "struct bfd_section *" with
	"struct already_linked *" in _section_already_linked.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

include/
	* bfdlink.h (bfd_link_info): Add loading_lto_outputs.

ld/
	* ldlang.c (section_already_linked): Pass "struct already_linked *"
	to bfd_section_already_linked.
	(lang_process): Set link_info.loading_lto_outputs before
	loading LTO outputs.
	* plugin.c: Include "libbfd.h".
	(add_symbols): Call bfd_section_already_linked with comdat_key.
@
text
@d395 1
a395 5
	      /* Treat a symbol from a discarded section as undefined.  */
	      if (bfd_is_abs_section (section)
		  || !bfd_is_abs_section (section->output_section))
		break;
	      /* Fall thru */
@


1.77
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d395 5
a399 1
	      break;
@


1.76
log
@bfd/ChangeLog:

	PR ld/12365
	* cofflink.c (bfd_coff_link_input_bfd): Check for and warn about
	references to symbols defined in discarded sections.

ld/ChangeLog:

	PR ld/12365
	* scripttempl/pe.sc (__rt_psrelocs_start): New symbol definition.
	(__rt_psrelocs_end): Likewise.
	(__rt_psrelocs_size): Likewise difference between the above.
	(__RUNTIME_PSEUDO_RELOC_LIST_END__): Move outside .rdata section
	immediately after end of pseudo-reloc data.
	(___RUNTIME_PSEUDO_RELOC_LIST_END___): Likewise.
	(__RUNTIME_PSEUDO_RELOC_LIST__): Move outside .rdata section and
	calculate backward from list end.
	(___RUNTIME_PSEUDO_RELOC_LIST___): Likewise.
	* scripttempl/pep.sc: Likewise.

ld/testsuite/ChangeLog:

	PR ld/12365
	* ld-plugin/plugin-7.d: Allow underscore in error message.
	* ld-plugin/plugin-8.d: Likewise.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d1022 1
a1022 2
  coff_link_hash_traverse (coff_hash_table (info),
			   _bfd_coff_write_global_sym, &finfo);
d2518 1
a2518 1
/* Write out a global symbol.  Called via coff_link_hash_traverse.  */
d2521 1
a2521 1
_bfd_coff_write_global_sym (struct coff_link_hash_entry *h, void *data)
d2523 1
d2748 1
a2748 1
	  rtnval = _bfd_coff_write_global_sym (h, data);
@


1.75
log
@	* aoutx.h (aout_link_check_ar_symbols): Formatting.
	* cofflink.c (coff_link_check_ar_symbols): Likewise.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols,
	xcoff_link_check_dynamic_ar_symbols): Likewise.

	* aoutx.h (aout_link_check_archive_element): Simplify code dealing
	with add_archive_element substitute BFD.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* ecoff.c (ecoff_link_check_archive_element): Likewise.
	(ecoff_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.

	* aoutx.h (aout_link_check_archive_element): Free symbols from old
	bfd if !keep_memory.
	* cofflink.c (coff_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_archive_element): Likewise.
	* xcofflink.c (xcoff_link_check_archive_element): Likewise.
@
text
@d2368 29
@


1.74
log
@Applied patch series for LD plugin interface (six parts).

[PATCH] Add infrastructure for plugin API; functionality to follow.

    include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* plugin-api.h (LDPT_GNU_LD_VERSION): New ld_plugin_tag enum member.

    ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* configure.in: Add AC_CHECKs for file io and dlfcn headers and
	functions and AC_SEARCH for -ldl.
	(enable_plugins): New shell variable set if above tests find dlopen
	functionality.
	(ENABLE_PLUGINS): Add related automake conditional.
	* configure: Regenerate.
	* config.in: Likewise.
	* Makefile.am (PLUGIN_C): Declare plugin C source file, conditional
	on ENABLE_PLUGINS being defined.
	(PLUGIN_H): Likewise for header file.
	(PLUGIN_OBJECT): Likewise for object file.
	(PLUGIN_CFLAGS): Likewise -D flag required to compile plugin support.
	(AM_CPPFLAGS): Use PLUGIN_CFLAGS.
	(CFILES): Use PLUGIN_C.
	(HFILES): Use PLUGIN_H.
	(OFILES): Use PLUGIN_OBJECT.
	(ld_new_SOURCES): Use PLUGIN_C.
	(noinst_LTLIBRARIES)[ENABLE_PLUGINS]: Declare test plugin.
	(libldtestplug_la_SOURCES)[ENABLE_PLUGINS]: Add automake definition
	for test plugin.
	(libldtestplug_la_CFLAGS)[ENABLE_PLUGINS]: Likewise.
	(libldtestplug_la_LDFLAGS)[ENABLE_PLUGINS]: Likewise.
	* Makefile.in: Regenerate.
	* sysdep.h: Include stdarg.h, unistd.h and one of fcntl.h or
	sys/file.h where available.  Include dlfcn.h when ENABLE_PLUGINS.
	(O_RDONLY): Supply default definition likewise to bfd's sysdep.h
	(O_WRONLY): Likewise.
	(O_RDWR): Likewise.
	(O_ACCMODE): Likewise.
	(O_BINARY): Likewise.
	(SEEK_SET): Likewise.
	(SEEK_CUR): Likewise.
	(SEEK_END): Likewise.
	* ldmisc.c (vfinfo): Make non-static.  Add %p format char.
	* ldmisc.h (vfinfo): Declare extern prototype.
	* lexsup.c (enum option_values)[ENABLE_PLUGINS]: Add new entries for
	OPTION_PLUGIN and OPTION_PLUGIN_OPT.
	(ld_options[])[ENABLE_PLUGINS]: Add option data for the above two.
	(parse_args)[ENABLE_PLUGINS]: Handle them, and load all plugins once
	option parsing is complete.
	* ldmain.c (main)[ENABLE_PLUGINS]: Call plugin cleanup hooks just
	after lang_finish.
	* plugin.c: New source file.
	* plugin.h: Likewise new header.
	* testplug.c: New source file.

    ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* ld-bootstrap/bootstrap.exp: Skip static tests also if LD plugins
	are enabled.
	* lib/ld-lib.exp (proc regexp_diff): Extend verbose debug output.
	(proc set_file_contents): Write a file with the supplied content.
	(run_ld_link_tests): Add new 'ld' action to test linker output.
	(proc check_plugin_api_available): Return true if linker under test
	supports the plugin API.
	* ld-plugin/func.c: New test source file.
	* ld-plugin/main.c: Likewise.
	* ld-plugin/text.c: Likewise.
	* ld-plugin/plugin-1.d: New dump test output pattern script.
	* ld-plugin/plugin-2.d: Likewise.
	* ld-plugin/plugin-3.d: Likewise.
	* ld-plugin/plugin-4.d: Likewise.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin.exp: New test control script.
---
[PATCH] Implement claim file and all symbols read hooks and add symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ldfile.c (ldfile_try_open_bfd)[ENABLE_PLUGINS]: Don't return early
	during compat checks if they pass, instead offer any successfully
	opened and accepted file to the plugin claim file hooks chain.  Create
	a dummy bfd to accept symbols added by the plugin, if the plugin
	claims the file.
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Call plugin all symbols
	read hook chain before ldemul_after_open.
	* ldlang.h (struct lang_input_statement_struct): Add new single-bit
	'claimed' flag.
	* plugin.c (IRONLY_SUFFIX): New macro for dummy bfd file suffix.
	(IRONLY_SUFFIX_LEN): Length of the above string.
	(plugin_get_ir_dummy_bfd): New function to create the dummy bfd used
	to store symbols for ir-only files.
	(is_ir_dummy_bfd): New function to check if a bfd is ir-only.
	(asymbol_from_plugin_symbol): New function converts symbol formats.
	(add_symbols): Call it to convert plugin syms to bfd syms and add
	them to the dummy bfd.
	* plugin.h: Add missing include guards.
	(plugin_get_ir_dummy_bfd): Add prototype.
	(is_ir_dummy_bfd): Likewise.
	* testplug.c (TV_MESSAGE): New helper macro.
	(struct claim_file): New struct.
	(claim_file_t): New typedef.
	(tag_names[]): Make static and const.
	(claimfiles_list): New variable.
	(claimfiles_tail_chain_ptr): Likewise.
	(last_claimfile): Likewise.
	(record_claim_file): Record a file to claim on a singly-linked list.
	(parse_symdefstr): Parse an ASCII representation of a symbol from a
	plugin option into the fields of a struct ld_plugin_symbol.
	(record_claimed_file_symbol):  Use it to parse plugin option for
	adding a symbol.
	(parse_option): Parse claim file and add symbol options.
	(dump_tv_tag): Use TV_MESSAGE.
	(onload): Likewise.
	(onclaim_file): Make static.  Use TV_MESSAGE.  Scan list of files to
	claim and claim this file if required, adding any symbols specified.
	(onall_symbols_read): Make static and use TV_MESSAGE.
	(oncleanup): Likewise.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ld-plugin/plugin-3.d: Enable regexes for new functionality.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin-6.d: New testcase.
	* ld-plugin/plugin-7.d: Likewise.
	* ld-plugin/plugin.exp: Use 'nm' on compiled test objects to determine
	whether symbols in plugin arguments need an underscore prefix.  Add
	new plugin-6.d and plugin-7.d testcases.
---
[PATCH] Implement get symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ldmain.c (notice)[ENABLE_PLUGINS]: Call plugin_notice.
	* plugin.c (non_ironly_hash): Add new bfd hash table.
	(plugin_load_plugins): Exit early if no plugins to load.  If plugins
	do load successfully, set notice_all flag in link info.
	(get_symbols): Implement.
	(plugin_load_plugins): Exit early if no plugins to load, else after
	loading plugins successfully enable notice_all mode.
	(init_non_ironly_hash): Lazily init non_ironly_hash table.
	(plugin_notice): Record symbols referenced from non-IR files in the
	non_ironly_hash.  Suppress tracing, cref generation and nocrossrefs
	tracking for symbols from dummy IR bfds.
	* plugin.h: Fix formatting.
	(plugin_notice): Add prototype.
	* testplug.c (dumpresolutions): New global var.
	(parse_options): Accept "dumpresolutions".
	(onall_symbols_read): Get syms and dump resolutions if it was given.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ld-plugin/plugin-8.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Implement add input file, add input lib and set extra lib path callbacks.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Move invocation of
	plugin_call_all_symbols_read to before setting of gc_sym_list, and
	open any new input files that may have been added during it.
	* ldmain.c (multiple_definition)[ENABLE_PLUGINS]: Call out to
	plugin_multiple_definition and let it have first say over what to do
	with the clashing definitions.
	* plugin.c (no_more_claiming): New boolean variable.
	(plugin_cached_allow_multiple_defs): Likewise.
	(add_input_file): Implement.
	(add_input_library): Likewise.
	(set_extra_library_path): Likewise.
	(plugin_call_claim_file): Don't do anything when no_more_claiming set.
	(plugin_call_all_symbols_read): Set it.  Disable link info
	"allow_multiple_definition" flag, but cache its value.
	(plugin_multiple_definition): New function.
	* plugin.h (plugin_multiple_definition): Add prototype.
	* testplug.c (addfile_enum_t): New enumerated typedef.
	(add_file_t): New struct typedef.
	(addfiles_list): New variable.
	(addfiles_tail_chain_ptr): Likewise.
	(record_add_file): New function.
	(parse_option): Parse "add:", "lib:" and "dir:" options and call it.
	(onall_symbols_read): Iterate the list of new files, libs and dirs,
	adding them.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ld-plugin/plugin-9.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Add ELF symbol visibility support to plugin interface.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* plugin.c (asymbol_from_plugin_symbol): If the bfd is an ELF bfd,
	find the elf symbol data and set the visibility in the st_other field.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* ld-plugin/plugin-ignore.d: New dump test control script.
	* ld-plugin/plugin-vis-1.d: Likewise.
	* ld-plugin/plugin.exp: Add list of ELF-only tests and run them if
	testing on an ELF target.
---
[PATCH] Add archive support to plugin interface.

  bfd/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* aoutx.h (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* cofflink.c (coff_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(coff_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* ecoff.c (read_ext_syms_and_strs): New function holds symbol-reading
	code factored-out from ecoff_link_check_archive_element.
	(reread_ext_syms_and_strs): Clear old symbols and call it.
	(ecoff_link_check_archive_element):  Use the above.  Handle substitute
	BFD if one is set by add_archive_element callback.
	(ecoff_link_add_archive_symbols): Likewise allow bfd substitution.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it was
	set during add_archive_element callback in the above.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Handle substitute
	BFD if one is set by add_archive_element callback.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols): Take new "subsbfd"
	reference parameter and pass it when invoking add_archive_element
	callback.
	(xcoff_link_check_ar_symbols): Likewise.
	(xcoff_link_check_archive_element): Handle bfd substitution if it was
	set by callback in the above.

  include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* bfdlink.h (struct_bfd_link_callbacks): Document new argument
	to add_archive_element callback used to return a replacement bfd which
	is to be added to the hash table in place of the original element.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ldlang.c (load_symbols): Handle bfd subsitution when calling the
	add_archive_element callback.
	* ldmain.c (add_archive_element)[ENABLE_PLUGINS]: Offer the archive
	member to the plugins and if claimed set "subsbfd" output parameter to
	point to the dummy IR-only BFD.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ld-plugin/plugin-10.d: New dump test control script.
	* ld-plugin/plugin-11.d: Likewise.
	* ld-plugin/plugin.exp: Run them.
---
@
text
@d247 2
a248 2
	      if (! (*info->callbacks->add_archive_element)
					(info, abfd, name, subsbfd))
d272 2
a273 1
  bfd *subsbfd = NULL;
d275 1
a275 1
  if (! _bfd_coff_get_external_symbols (abfd))
d278 2
a279 1
  if (! coff_link_check_ar_symbols (abfd, info, pneeded, &subsbfd))
d282 16
a297 14
  /* Potentially, the add_archive_element hook may have set a
     substitute BFD for us.  */
  if (*pneeded
      && subsbfd
      && ! _bfd_coff_get_external_symbols (subsbfd))
    return FALSE;

  if (*pneeded
      && ! coff_link_add_symbols (subsbfd ? subsbfd : abfd, info))
    return FALSE;

  if ((! info->keep_memory || ! *pneeded)
      && ! _bfd_coff_free_symbols (abfd))
    return FALSE;
d299 5
@


1.74.2.1
log
@backport from mainline
@
text
@d247 2
a248 2
	      if (!(*info->callbacks
		    ->add_archive_element) (info, abfd, name, subsbfd))
d272 1
a272 2
  bfd *oldbfd;
  bfd_boolean needed;
d274 1
a274 1
  if (!_bfd_coff_get_external_symbols (abfd))
d277 1
a277 2
  oldbfd = abfd;
  if (!coff_link_check_ar_symbols (abfd, info, pneeded, &abfd))
d280 14
a293 16
  needed = *pneeded;
  if (needed)
    {
      /* Potentially, the add_archive_element hook may have set a
	 substitute BFD for us.  */
      if (abfd != oldbfd)
	{
	  if (!info->keep_memory
	      && !_bfd_coff_free_symbols (oldbfd))
	    return FALSE;
	  if (!_bfd_coff_get_external_symbols (abfd))
	    return FALSE;
	}
      if (!coff_link_add_symbols (abfd, info))
	return FALSE;
    }
a294 5
  if (!info->keep_memory || !needed)
    {
      if (!_bfd_coff_free_symbols (abfd))
	return FALSE;
    }
@


1.74.2.2
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@a2367 29
	  /* Run through the relocs looking for relocs against symbols
	     coming from discarded sections and complain about them.  */
	  irel = internal_relocs;
	  for (; irel < &internal_relocs[o->reloc_count]; irel++)
	    {
	      struct coff_link_hash_entry *h;
	      asection *ps = NULL;
	      long symndx = irel->r_symndx;
	      if (symndx < 0)
		continue;
	      h = obj_coff_sym_hashes (input_bfd)[symndx];
	      if (h == NULL)
		continue;
	      while (h->root.type == bfd_link_hash_indirect
		     || h->root.type == bfd_link_hash_warning)
		h = (struct coff_link_hash_entry *) h->root.u.i.link;
	      if (h->root.type == bfd_link_hash_defined
		  || h->root.type == bfd_link_hash_defweak)
		ps = h->root.u.def.section;
	      if (ps == NULL)
		continue;
	      /* Complain if definition comes from an excluded section.  */
	      if (ps->flags & SEC_EXCLUDE)
		(*finfo->info->callbacks->einfo)
		  (_("%X`%s' referenced in section `%A' of %B: "
		     "defined in discarded section `%A' of %B\n"),
		   h->root.root.string, o, input_bfd, ps, ps->owner);
	    }

@


1.73
log
@	* cofflink.c (_bfd_coff_link_input_bfd): Skip section symbols for
	excluded output sections.
@
text
@d200 2
a201 1
			    bfd_boolean *pneeded)
d247 2
a248 1
	      if (! (*info->callbacks->add_archive_element) (info, abfd, name))
d272 2
d277 8
a284 1
  if (! coff_link_check_ar_symbols (abfd, info, pneeded))
d288 1
a288 1
      && ! coff_link_add_symbols (abfd, info))
@


1.72
log
@	* cofflink.c (_bfd_coff_generic_relocate_section): Look for the aux
	symbol for a weak undef in the auxbfd, not the input bfd.
@
text
@d1517 1
a1517 1
	  && dont_skip_symbol == 0
d1520 4
a1523 2
          && isym.n_numaux > 0
	  && (*secpp)->output_section == bfd_abs_section_ptr)
@


1.71
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d2962 1
a2962 1
		    input_bfd->tdata.coff_obj_data->sym_hashes[
@


1.70
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d113 1
a113 1
  ret = bfd_malloc (amt);
d323 1
a323 1
  sym_hash = bfd_zalloc (abfd, amt);
d775 1
a775 1
      finfo.section_info = bfd_malloc (amt);
d818 2
a819 1
	  finfo.section_info[o->target_index].relocs = bfd_malloc (amt);
d822 2
a823 1
	  finfo.section_info[o->target_index].rel_hashes = bfd_malloc (amt);
d856 1
a856 1
  finfo.internal_syms = bfd_malloc (amt);
d858 1
a858 1
  finfo.sec_ptrs = bfd_malloc (amt);
d860 2
a861 2
  finfo.sym_indices = bfd_malloc (amt);
  finfo.outsyms = bfd_malloc ((max_sym_count + 1) * symesz);
d863 2
a864 2
  finfo.linenos = bfd_malloc (amt);
  finfo.contents = bfd_malloc (max_contents_size);
d866 1
a866 1
  finfo.external_relocs = bfd_malloc (amt);
d870 1
a870 1
      finfo.internal_relocs = bfd_malloc (amt);
d1020 1
a1020 1
      external_relocs = bfd_malloc (amt);
d1607 1
a1607 1
	  mt = bfd_alloc (input_bfd, amt);
d1634 2
a1635 1
	      *epp = bfd_alloc (input_bfd, amt);
d1645 1
a1645 1
	      name_copy = bfd_alloc (input_bfd, amt);
d2735 1
a2735 1
      buf = bfd_zmalloc (size);
@


1.69
log
@update copyright dates
@
text
@d82 1
a82 1
      ret->class = C_NULL;
d491 1
a491 1
  	      if (((*sym_hash)->class == C_NULL
d498 1
a498 1
  		  (*sym_hash)->class = sym.n_sclass;
d1608 1
a1608 1
	  mt->class = isym.n_sclass;
d1697 1
a1697 1
		  if (mtl->class != mt->class)
d2559 1
a2559 1
  isym.n_sclass = h->class;
d2945 1
a2945 1
              if (h->class == C_NT_WEAK && h->numaux == 1)
@


1.69.2.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d82 1
a82 1
      ret->symbol_class = C_NULL;
d491 1
a491 1
  	      if (((*sym_hash)->symbol_class == C_NULL
d498 1
a498 1
  		  (*sym_hash)->symbol_class = sym.n_sclass;
d1608 1
a1608 1
	  mt->type_class = isym.n_sclass;
d1697 1
a1697 1
		  if (mtl->type_class != mt->type_class)
d2559 1
a2559 1
  isym.n_sclass = h->symbol_class;
d2945 1
a2945 1
              if (h->symbol_class == C_NT_WEAK && h->numaux == 1)
@


1.69.2.2
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d113 1
a113 1
  ret = (struct coff_link_hash_table *) bfd_malloc (amt);
d323 1
a323 1
  sym_hash = (struct coff_link_hash_entry **) bfd_zalloc (abfd, amt);
d775 1
a775 1
      finfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);
d818 1
a818 2
	  finfo.section_info[o->target_index].relocs =
              (struct internal_reloc *) bfd_malloc (amt);
d821 1
a821 2
	  finfo.section_info[o->target_index].rel_hashes =
              (struct coff_link_hash_entry **) bfd_malloc (amt);
d854 1
a854 1
  finfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
d856 1
a856 1
  finfo.sec_ptrs = (asection **) bfd_malloc (amt);
d858 2
a859 2
  finfo.sym_indices = (long int *) bfd_malloc (amt);
  finfo.outsyms = (bfd_byte *) bfd_malloc ((max_sym_count + 1) * symesz);
d861 2
a862 2
  finfo.linenos = (bfd_byte *) bfd_malloc (amt);
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
d864 1
a864 1
  finfo.external_relocs = (bfd_byte *) bfd_malloc (amt);
d868 1
a868 1
      finfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);
d1018 1
a1018 1
      external_relocs = (bfd_byte *) bfd_malloc (amt);
d1605 1
a1605 1
	  mt = (struct coff_debug_merge_type *) bfd_alloc (input_bfd, amt);
d1632 1
a1632 2
	      *epp = (struct coff_debug_merge_element *)
                  bfd_alloc (input_bfd, amt);
d1642 1
a1642 1
	      name_copy = (char *) bfd_alloc (input_bfd, amt);
d2732 1
a2732 1
      buf = (bfd_byte *) bfd_zmalloc (size);
@


1.69.2.3
log
@	* cofflink.c (_bfd_coff_generic_relocate_section): Look for the aux
	symbol for a weak undef in the auxbfd, not the input bfd.
@
text
@d2962 1
a2962 1
		    h->auxbfd->tdata.coff_obj_data->sym_hashes[
@


1.68
log
@==> bfd/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* cofflink.c (process_embedded_commands):  Ignore "-aligncomm".

==> gas/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* NEWS:  Mention new feature.
	* config/obj-coff.c (obj_coff_common_parse):  New function.
	(obj_coff_comm):  Likewise.
	(coff_pseudo_table):  Override default ".comm" definition on PE.
	* doc/as.texinfo:  Document new feature.

==> gas/testsuite/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* gas/pe/:  New directory for PE format-specific tests.
	* gas/pe/aligncomm-a.d:  New test pattern file.
	* gas/pe/aligncomm-a.s:  New test source file.
	* gas/pe/aligncomm-b.d:  New test pattern file.
	* gas/pe/aligncomm-b.s:  New test source file.
	* gas/pe/aligncomm-c.d:  New test pattern file.
	* gas/pe/aligncomm-c.s:  New test source file.
	* gas/pe/aligncomm-d.d:  New test pattern file.
	* gas/pe/aligncomm-d.s:  New test source file.
	* gas/pe/pe.exp:  New test control script.
	* lib/gas-defs.exp (is_pecoff_format):  New function.

==> ld/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* NEWS:  Mention new feature.
	* deffile.h (def_file_aligncomm):  Add new struct definition.
	(def_file):  Add new def_file_aligncomm member.
	* deffilep.y (%token):  Add new ALIGNCOMM token.
	(command):  Add production rule for ALIGNCOMM.
	(def_file_free):  Free any chained def_file_aligncomm structs.
	(diropts[]):  Add entry for '-aligncomm' .drectve command.
	(def_aligncomm):  New grammar function.
	* ld.texinfo:  Document new feature.
	* pe-dll.c (process_def_file):  Rename from this ...
	(process_def_file_and_drectve):  ... to this, updating all callers,
	and process any aligncomms chained to the def file after scanning
	all .drectve sections.
	(generate_edata):  Updated to match.
	(pe_dll_build_sections):  Likewise.

==> ld/testsuite/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* ld-pe/aligncomm-1.c:  New test source file.
	* ld-pe/aligncomm-2.c:  Likewise.
	* ld-pe/aligncomm-3.c:  Likewise.
	* ld-pe/aligncomm-4.c:  Likewise.
	* ld-pe/aligncomm.d:  New test pattern file.

	* ld-pe/direct.exp:  Deleted, and content moved into ...
	* ld-pe/pe-run.exp:  ... New common file for all PE run tests.

	* ld-pe/vers-script.exp:  Deleted, and content merged into ...
	* ld-pe/pe-compile.exp:  ... New common file for PE tests needing
	a compiler, adding aligned common tests.

	* ld-pe/pe.exp:  Update header comment.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.67
log
@binutils/
2008-10-09  Kai Tietz  <kai.tietz@@onevision.com>

	* dlltool.c (PAGE_SIZE): Make sure it has bfd_vma type.
	(PAGE_MASK): Likewise.
	(sfunc): Change to address size of bfd_vma for base-file.
	(flush_page): Likewise.
	(gen_exp_file): Likewise.
bfd/
2008-10-09  Kai Tietz  <kai.tietz@@onevision.com>

	* cofflink.c (_bfd_coff_generic_relocate_section): Dump bfd_vma sized addresses instead of long sized.
@
text
@d1285 9
@


1.66
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d2988 3
a2990 3
		 portable between systems.  We write out a long here,
		 and dlltool reads in a long.  */
	      long addr = (rel->r_vaddr
d2996 2
a2997 2
	      if (fwrite (&addr, 1, sizeof (long), (FILE *) info->base_file)
		  != sizeof (long))
@


1.65
log
@2007-07-27  Michael Snyder  <msnyder@@access-company.com>

	* cofflink.c (coff_link_add_symbols): Return if count is zero.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d485 1
a485 1
	  if (info->hash->creator->flavour == bfd_get_flavour (abfd))
d577 1
a577 1
      && info->hash->creator->flavour == bfd_get_flavour (abfd)
@


1.64
log
@Switch sources over to use the GPL version 3
@
text
@d305 5
a319 2
  symcount = obj_raw_syment_count (abfd);

d324 1
a324 1
  if (sym_hash == NULL && symcount != 0)
@


1.63
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.62
log
@Fix typo in use of CONST_STRNEQ
@
text
@d3 1
a3 1
   2004, 2005, 2006 Free Software Foundation, Inc.
d24 1
a25 1
#include "sysdep.h"
@


1.61
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d586 1
a586 1
	    if (CONST_STRNEQ (".stab", stab->name)
@


1.60
log
@PR ld/2659
* cofflink.c (_bfd_coff_link_input_bfd): Fix selection of aux entry when
  multiple definitions of a symbol are encountered.
@
text
@d235 1
a235 1
	      && !strncmp (name,"__imp_", 6))
d442 1
a442 1
	      && strncmp (name, "??_", 3) == 0
d586 1
a586 1
	    if (strncmp (".stab", stab->name, 5) == 0
d1235 1
a1235 1
      if (strncmp (s, "-attr", 5) == 0)
d1275 2
a1276 2
      else if (strncmp (s,"-heap", 5) == 0)
	s = dores_com (s+5, output_bfd, 1);
d1278 2
a1279 2
      else if (strncmp (s,"-stack", 6) == 0)
	s = dores_com (s+6, output_bfd, 0);
@


1.59
log
@	* coff-or32.c (bfd_section_from_shdr): Remove unused local
	variable `ptr'.
	* cofflink.c (process_embedded_commands): Remove unused local
	variables `had_read' and `had_shared'.
	* ecofflink.c (bfd_ecoff_debug_accumulate): Remove unused local
	variable `fdr_adr'.
	* ihex.c (ihex_read_section): Remove unused local variable `addr'.
@
text
@d1924 1
d1940 1
a1940 1
	      if (h != NULL)
@


1.58
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@a1241 1
	  int had_read = 0;
a1242 1
	  int had_shared= 0;
a1255 1
		  had_read = 1;
a1257 1
		  had_shared = 1;
@


1.57
log
@bfd
	* cofflink.c (_bfd_coff_generic_relocate_section): Correct
	comment.

gas
	* config/obj-coff.c (obj_coff_weak): Set auxiliary record
	of NT weak externals to IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY.
@
text
@d3 1
a3 1
   2004, 2005 Free Software Foundation, Inc.
d97 2
a98 1
								   const char *))
d101 1
a101 1
  return _bfd_link_hash_table_init (&table->root, abfd, newfunc);
d117 2
a118 1
					_bfd_coff_link_hash_newfunc))
@


1.56
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d2940 5
a2944 3
		     characteristics IMAGE_WEAK_EXTERN_SEARCH_LIBRARY (2).
		     There are no known uses of the other two types of
		     weak externals.  */
@


1.55
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.54
log
@Update the FSF address in the copyright/GPL notice
@
text
@d696 1
a696 1
      for (p = o->link_order_head; p != NULL; p = p->next)
d891 1
a891 1
      for (p = o->link_order_head; p != NULL; p = p->next)
@


1.53
log
@include/
	* xtensa-isa-internal.h (xtensa_length_decode_fn): Warning fix.
	* xtensa-isa.h (xtensa_insnbuf_to_chars): Likewise.
	(xtensa_insnbuf_from_chars, xtensa_isa_length_from_chars): Likewise.
include/coff/
	* xcoff.h (struct xcoff_loader_info): Warning fix.
bfd/
	* bfd-in.h (bfd_elf_bfd_from_remote_memory): Warning fix.
	* coff-m68k.c (bfd_m68k_coff_create_embedded_relocs): Likewise.
	* coff-rs6000.c (xcoff_write_armap_big): Warning fixes.  Remove
	useless assignments.
	(xcoff_write_archive_contents_big): Likewise.
	(_bfd_xcoff_put_ldsymbol_name): Likewise.
	* coff64-rs6000.c (_bfd_xcoff64_put_ldsymbol_name): Likewise.
	* coffgen.c (coff_write_symbols): Make "written" a bfd_vma.
	* cofflink.c (process_embedded_commands): Warning fixes.
	* cpu-arm.c: Delete unnecessary prototypes.  Convert to C90.
	Warning fixes.
	* dwarf2.c: Warning fixes.
	* elf-bfd.h: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Delete unnecessary prototypes.  Warning fixes.
	* elf64-sh64.c: Likewise.
	* peicode.h: Likewise.
	* elf64-mmix.c: Warning fixes.
	* elfcode.h: Likewise.
	* elfxx-mips.c: Likewise.
	* libbfd-in.h: Likewise.
	* libbfd.c: Likewise.
	* mach-o.c: Likewise.
	* merge.c: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pef.c: Likewise.
	* srec.c: Likewise.
	* vms-hdr.c: Likewise.
	* vms-tir.c: Likewise.
	* xtensa-isa.c: Likewise.
	* xtensa-modules.c: Likewise.
	* xsym.c: Likewise.
	(pstrcmp): Use correct choice of string lengths.  Fix return value.
	(bfd_sym_module_name): Correct string length.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.52
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d3 1
a3 1
   2004 Free Software Foundation, Inc.
d1224 1
a1224 1
  e = copy + sec->size;
d1226 1
a1226 1
  for (s = copy;  s < e ; )
d1228 1
a1228 1
      if (s[0]!= '-')
d1233 1
a1233 1
      if (strncmp (s,"-attr", 5) == 0)
@


1.51
log
@oops - omitted fom previous delta
@
text
@a1347 3
#if 0
  unsigned int n_btmask = coff_data (input_bfd)->local_n_btmask;
#endif
@


1.50
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d1979 2
a1980 1
	      else if (isymp->n_sclass != C_STAT || isymp->n_type != T_NULL)
d2939 7
a2945 8
                   * File Format Specification_, section 5.5.3.
		   * Note that weak symbols without aux records are a GNU
		   * extension.
		   * FIXME: All weak externals are treated as having
		   * characteristics IMAGE_WEAK_EXTERN_SEARCH_LIBRARY (2).
		   * There are no known uses of the other two types of
		   * weak externals.
		   */
d2951 11
a2961 3
		  sec = h2->root.u.def.section;
		  val = h2->root.u.def.value + sec->output_section->vma
		    + sec->output_offset;
d2964 1
a2964 1
                /* This is a GNU extension. */
@


1.49
log
@PR 324
(coff_link_add_symbols): Check that the comdat pointer in the coff_section_data
structure has been initialised before using it.
@
text
@d2738 1
a2738 1
		 (finfo->info,
d3019 1
a3019 1
	      name = h->root.root.string;
d3028 3
a3030 2
		   (info, name, howto->name, (bfd_vma) 0, input_bfd,
		    input_section, rel->r_vaddr - input_section->vma)))
@


1.48
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d438 1
@


1.47
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d506 2
a507 3
  			  (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
  			   name, (*sym_hash)->type, sym.n_type,
  			   bfd_archive_filename (abfd));
d2293 3
a2295 4
	      ((*_bfd_error_handler)
	       (_("%s: relocs in section `%s', but it has no contents"),
		bfd_archive_filename (input_bfd),
		bfd_get_section_name (input_bfd, o)));
d2862 1
a2862 2
	    ("%s: illegal symbol index %ld in relocs",
	     bfd_archive_filename (input_bfd), symndx);
d3007 2
a3008 4
	    (_("%s: bad reloc address 0x%lx in section `%s'"),
	     bfd_archive_filename (input_bfd),
	     (unsigned long) rel->r_vaddr,
	     bfd_get_section_name (input_bfd, input_section));
@


1.46
log
@2004-07-04  Aaron W. LaFramboise <aaron98wiridge9@@aaronwl.com>

* bfd/cofflink.c (_bfd_coff_generic_relocate_section): Resolve PE weak
externals properly.
* src/gas/config/obj-coff.c (obj_coff_weak): New .weak syntax for PE weak
externals.
* binutils/doc/binutils.texi (nm): Clarify weak symbol description.
* gas/config/tc-i386.c (tc_gen_reloc): Use addend for weak symbols in TE_PE.
* gas/doc/as.texinfo (Weak): Document PE weak symbols.
* ld/ld.texinfo (WIN32): Document PE weak symbols.
@
text
@d438 1
a438 1
	      && section->comdat != NULL
d440 1
a440 1
	      && strcmp (name, section->comdat->name) == 0)
d447 3
a449 3
		  && (*sym_hash)->root.u.def.section->comdat != NULL
		  && strcmp ((*sym_hash)->root.u.def.section->comdat->name,
			     section->comdat->name) == 0)
@


1.45
log
@	* bfd-in.h (struct stab_info): Move from stabs.c.
	* stabs.c (struct stab_link_includes_table): Delete.
	(stab_link_includes_lookup): Delete.
	(_bfd_write_section_stabs, _bfd_write_stab_strings): Remove one
	level of indirection from sinfo parm.
	(_bfd_link_section_stabs): Likewise.  Set SEC_LINKER_CREATED on
	stabstr section.  Adjust hash table accesses.
	* coff-ppc.c (ppc_bfd_coff_final_link): Do include rawsize in contents
	alloc.  Adjust stab_info test.
	* cofflink.c (_bfd_coff_link_hash_table_init): Clear stab_info.
	(_bfd_coff_final_link): Adjust stab_info test.
	(_bfd_coff_link_input_bfd): Ignore SEC_LINKER_CREATED sections.
	* elf-bfd.h (struct elf_link_hash_table): Include struct stab_info
	in place.
	* libcoff-in.h (struct coff_link_hash_table): Likewise.
	* elf.c (_bfd_elf_link_hash_table_init): Clear stab_info.
	* elflink.c (bfd_elf_final_link): Don't attempt to link linker created
	stabstr section.  Adjust stab_info test.
	* libbfd-in.h (_bfd_link_section_stabs, _bfd_write_section_stabs)
	(_bfd_write_stab_strings): Adjust prototypes.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d2926 1
d2933 1
a2933 1
	      }
d2936 25
a2960 1
	    val = 0;
@


1.44
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d99 1
a99 1
  table->stab_info = NULL;
d1085 1
a1085 1
  if (coff_hash_table (info)->stab_info != NULL)
d2285 3
@


1.43
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d554 2
a555 2
	      if (section->_raw_size == 0)
		section->_raw_size = (*sym_hash)->aux[0].x_scn.x_scnlen;
d717 4
a720 2
	      if (sec->_raw_size > max_contents_size)
		max_contents_size = sec->_raw_size;
d1213 1
a1213 1
  char *copy;
d1218 1
a1218 5
  copy = bfd_malloc (sec->_raw_size);
  if (!copy)
    return 0;

  if (! bfd_get_section_contents (abfd, sec, copy, (bfd_vma) 0, sec->_raw_size))
d1220 2
a1221 1
      free (copy);
d1224 1
a1224 1
  e = copy + sec->_raw_size;
d2286 1
a2286 1
	  || (o->_raw_size == 0 && (o->flags & SEC_RELOC) == 0))
d2307 2
a2308 2
	  if (! bfd_get_section_contents (input_bfd, o, finfo->contents,
					  (file_ptr) 0, o->_raw_size))
a2432 2
	  bfd_size_type amt = (o->_cooked_size != 0
			       ? o->_cooked_size : o->_raw_size);
d2434 1
a2434 1
					  contents, loc, amt))
d2616 1
a2616 3
	      auxp->x_scn.x_scnlen = (sec->_cooked_size != 0
				      ? sec->_cooked_size
				      : sec->_raw_size);
@


1.43.8.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004 Free Software Foundation, Inc.
d99 1
a99 1
  memset (&table->stab_info, 0, sizeof (table->stab_info));
d438 1
a438 2
	      && coff_section_data (abfd, section) != NULL
	      && coff_section_data (abfd, section)->comdat != NULL
d440 1
a440 1
	      && strcmp (name, coff_section_data (abfd, section)->comdat->name) == 0)
d447 3
a449 3
		  && coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat != NULL
		  && strcmp (coff_section_data (abfd, (*sym_hash)->root.u.def.section)->comdat->name,
			     coff_section_data (abfd, section)->comdat->name) == 0)
d506 3
a508 2
  			  (_("Warning: type of symbol `%s' changed from %d to %d in %B"),
  			   abfd, name, (*sym_hash)->type, sym.n_type);
d554 2
a555 2
	      if (section->size == 0)
		section->size = (*sym_hash)->aux[0].x_scn.x_scnlen;
d717 2
a718 4
	      if (sec->rawsize > max_contents_size)
		max_contents_size = sec->rawsize;
	      if (sec->size > max_contents_size)
		max_contents_size = sec->size;
d1083 1
a1083 1
  if (coff_hash_table (info)->stab_info.stabstr != NULL)
d1211 1
a1211 1
  bfd_byte *copy;
d1216 5
a1220 1
  if (!bfd_malloc_and_get_section (abfd, sec, &copy))
d1222 1
a1222 2
      if (copy != NULL)
	free (copy);
d1225 1
a1225 1
  e = copy + sec->size;
a2285 3
      if ((o->flags & SEC_LINKER_CREATED) != 0)
	continue;

d2287 1
a2287 1
	  || (o->size == 0 && (o->flags & SEC_RELOC) == 0))
d2292 4
a2295 3
	      (*_bfd_error_handler)
		(_("%B: relocs in section `%A', but it has no contents"),
		 input_bfd, o);
d2308 2
a2309 2
	  bfd_size_type x = o->rawsize ? o->rawsize : o->size;
	  if (! bfd_get_section_contents (input_bfd, o, finfo->contents, 0, x))
d2434 2
d2437 1
a2437 1
					  contents, loc, o->size))
d2619 3
a2621 1
	      auxp->x_scn.x_scnlen = sec->size;
d2866 2
a2867 1
	    ("%B: illegal symbol index %ld in relocs", input_bfd, symndx);
a2927 1
	      /* Defined weak symbols are a GNU extension. */
d2934 1
a2934 1
	    }
d2937 1
a2937 25
	    {
              if (h->class == C_NT_WEAK && h->numaux == 1)
		{
		  /* See _Microsoft Portable Executable and Common Object
                   * File Format Specification_, section 5.5.3.
		   * Note that weak symbols without aux records are a GNU
		   * extension.
		   * FIXME: All weak externals are treated as having
		   * characteristics IMAGE_WEAK_EXTERN_SEARCH_LIBRARY (2).
		   * There are no known uses of the other two types of
		   * weak externals.
		   */
		  asection *sec;
		  struct coff_link_hash_entry *h2 =
		    input_bfd->tdata.coff_obj_data->sym_hashes[
		    h->aux->x_sym.x_tagndx.l];

		  sec = h2->root.u.def.section;
		  val = h2->root.u.def.value + sec->output_section->vma
		    + sec->output_offset;
		}
	      else
                /* This is a GNU extension. */
		val = 0;
	    }
d2987 4
a2990 2
	    (_("%B: bad reloc address 0x%lx in section `%A'"),
	     input_bfd, input_section, (unsigned long) rel->r_vaddr);
@


1.42
log
@2003-10-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* cofflink.c: Include "safe-ctype.h".
	(coff_link_add_symbols): Use ISDIGIT instead of isdigit.
@
text
@d2568 1
a2568 1
  /* When a weak symbol is not overriden by a strong one,
@


1.41
log
@bfd/Changelog:
	* libbfd-in.h (_bfd_link_section_stabs): Add string offset
	parameter.
	* cofflink.c (coff_link_add_symbols): Deal with split stab
	sections.
	* elflink.h (elf_link_add_object_symbols): Deal with split stab
	sections.
	* stabs.c (_bfd_link_section_stabs): Add string offset parameter.
	* libbfd.h: Regenerated.
ld/ChangeLog:
	* ldwrite.c (unsplittable_name): New.
	(clone_section): Strip existing numeric suffix. Only truncate names
	for coff targets.
	(split_sections): Use unsplittable_name.
binutils/ChangeLog:
	* objdump.c (read_section_stabs): Just read one section, return
	pointer to it. Add size parameter.
	(print_section_stabs): Add string offset parameter. Adjust.
	(struct stab_section_names): Add string offset member.
	(find_stabs_sections): Correct check for split section suffix,
	adjust read_section_stabs and print_section_stabs calls.
	(dump_stabs_section): Clear string_offset, free string table.
@
text
@d30 1
d586 1
a586 1
		    || (stab->name[5] == '.' && isdigit (stab->name[6]))))
@


1.40
log
@	* coffcode.h (coff_set_alignment_hook): With PE_COFF reloc
	overflow, set reloc start position to after the count
	reloc. Subtract one from num relocs. Give error on 0xffff relocs
	and no overflow.
	* cofflink.c (_bfd_coff_final_link): Deal with PE_COFF reloc
	overflow.
	* peXXigen.c (_bfd_XXi_swap_scnhdr_out): Do overflow if >=
	0xffff.
@
text
@d573 1
a573 1
      asection *stab, *stabstr;
d575 3
a577 2
      stab = bfd_get_section_by_name (abfd, ".stab");
      if (stab != NULL)
d579 7
a585 3
	  stabstr = bfd_get_section_by_name (abfd, ".stabstr");

	  if (stabstr != NULL)
d588 3
a590 3
	      struct coff_section_tdata *secdata;

	      secdata = coff_section_data (abfd, stab);
d604 2
a605 1
					     &secdata->stab_info))
@


1.39
log
@Do not skip section symbols that are used in relocs.
@
text
@d1031 21
a1051 4
	  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0
	      || (bfd_bwrite (external_relocs,
			     (bfd_size_type) relsz * o->reloc_count, abfd)
		  != (bfd_size_type) relsz * o->reloc_count))
@


1.38
log
@Convert to ISO C90.  Tidy up formatting.
@
text
@d1484 1
d1487 3
a1489 5
          && isym.n_numaux > 0)
        {
          if ((*secpp)->output_section == bfd_abs_section_ptr)
	    skip = TRUE;
        }
@


1.37
log
@Correct spelling of "relocatable".
@
text
@d6 1
a6 1
This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 3
a33 16
static bfd_boolean coff_link_add_object_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean coff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean coff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean coff_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static char *dores_com
  PARAMS ((char *, bfd *, int));
static char *get_name
  PARAMS ((char *, char **));
static int process_embedded_commands
  PARAMS ((bfd *, struct bfd_link_info *, bfd *));
static void mark_relocs
  PARAMS ((struct coff_final_link_info *, bfd *));
d57 3
a59 4
_bfd_coff_link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d92 5
a96 6
_bfd_coff_link_hash_table_init (table, abfd, newfunc)
     struct coff_link_hash_table *table;
     bfd *abfd;
     struct bfd_hash_entry *(*newfunc) PARAMS ((struct bfd_hash_entry *,
						struct bfd_hash_table *,
						const char *));
d105 1
a105 2
_bfd_coff_link_hash_table_create (abfd)
     bfd *abfd;
d110 1
a110 1
  ret = (struct coff_link_hash_table *) bfd_malloc (amt);
d113 1
d126 3
a128 4
_bfd_coff_debug_merge_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d158 1
a158 3
_bfd_coff_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d165 2
a166 2
      return (_bfd_generic_link_add_archive_symbols
	      (abfd, info, coff_link_check_archive_element));
d176 1
a176 3
coff_link_add_object_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d183 2
a184 20
  if (! info->keep_memory)
    {
      if (! _bfd_coff_free_symbols (abfd))
	return FALSE;
    }
  return TRUE;
}

/* Check a single archive element to see if we need to include it in
   the link.  *PNEEDED is set according to whether this element is
   needed in the link or not.  This is called via
   _bfd_generic_link_add_archive_symbols.  */

static bfd_boolean
coff_link_check_archive_element (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
{
  if (! _bfd_coff_get_external_symbols (abfd))
a186 15
  if (! coff_link_check_ar_symbols (abfd, info, pneeded))
    return FALSE;

  if (*pneeded)
    {
      if (! coff_link_add_symbols (abfd, info))
	return FALSE;
    }

  if (! info->keep_memory || ! *pneeded)
    {
      if (! _bfd_coff_free_symbols (abfd))
	return FALSE;
    }

d194 3
a196 4
coff_link_check_ar_symbols (abfd, info, pneeded)
     bfd *abfd;
     struct bfd_link_info *info;
     bfd_boolean *pneeded;
d212 1
a212 1
      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &sym);
a223 1

d229 6
a234 10
	  /* auto import */
	  if (!h && info->pei386_auto_import)
	    {
	      if (!strncmp (name,"__imp_", 6))
		{
		  h =
                    bfd_link_hash_lookup (info->hash, name + 6, FALSE, FALSE,
                                          TRUE);
		}
	    }
d256 27
d286 2
a287 3
coff_link_add_symbols (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d316 1
a316 1
  sym_hash = (struct coff_link_hash_entry **) bfd_zalloc (abfd, amt);
d331 1
a331 1
      bfd_coff_swap_sym_in (abfd, (PTR) esym, (PTR) &sym);
d534 1
a534 1
			bfd_coff_swap_aux_in (abfd, (PTR) eaux, sym.n_type,
d536 1
a536 1
					      sym.n_numaux, (PTR) iaux);
a551 1

d589 1
a589 1
		  stab->used_by_bfd = (PTR) bfd_zalloc (abfd, amt);
d617 2
a618 3
_bfd_coff_final_link (abfd, info)
     bfd *abfd;
     struct bfd_link_info *info;
d760 1
a760 1
      finfo.section_info = (struct coff_link_section_info *) bfd_malloc (amt);
d803 1
a803 2
	  finfo.section_info[o->target_index].relocs =
	    (struct internal_reloc *) bfd_malloc (amt);
d806 1
a806 2
	  finfo.section_info[o->target_index].rel_hashes =
	    (struct coff_link_hash_entry **) bfd_malloc (amt);
d839 1
a839 1
  finfo.internal_syms = (struct internal_syment *) bfd_malloc (amt);
d841 1
a841 1
  finfo.sec_ptrs = (asection **) bfd_malloc (amt);
d843 2
a844 2
  finfo.sym_indices = (long *) bfd_malloc (amt);
  finfo.outsyms = (bfd_byte *) bfd_malloc ((max_sym_count + 1) * symesz);
d846 2
a847 2
  finfo.linenos = (bfd_byte *) bfd_malloc (amt);
  finfo.contents = (bfd_byte *) bfd_malloc (max_contents_size);
d849 1
a849 1
  finfo.external_relocs = (bfd_byte *) bfd_malloc (amt);
d853 1
a853 1
      finfo.internal_relocs = (struct internal_reloc *) bfd_malloc (amt);
d962 2
a963 2
      bfd_coff_swap_sym_out (abfd, (PTR) &finfo.last_file,
			     (PTR) finfo.outsyms);
d978 1
a978 2
			       _bfd_coff_write_task_globals,
			       (PTR) &finfo);
d986 1
a986 2
			   _bfd_coff_write_global_sym,
			   (PTR) &finfo);
d1003 1
a1003 1
      external_relocs = (bfd_byte *) bfd_malloc (amt);
d1028 1
a1028 1
	      bfd_coff_swap_reloc_out (abfd, (PTR) irel, (PTR) erel);
d1032 1
a1032 1
	      || (bfd_bwrite ((PTR) external_relocs,
d1139 1
a1139 1
/* parse out a -heap <reserved>,<commit> line */
d1142 1
a1142 4
dores_com (ptr, output_bfd, heap)
     char *ptr;
     bfd *output_bfd;
     int heap;
d1147 1
d1165 2
a1166 3
static char *get_name(ptr, dst)
char *ptr;
char **dst;
d1177 1
a1177 1
/* Process any magic embedded commands in a section called .drectve */
d1180 3
a1182 4
process_embedded_commands (output_bfd, info,  abfd)
     bfd *output_bfd;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     bfd *abfd;
d1188 1
d1195 2
a1196 1
  if (! bfd_get_section_contents(abfd, sec, copy, (bfd_vma) 0, sec->_raw_size))
d1202 1
d1205 5
a1209 4
      if (s[0]!= '-') {
	s++;
	continue;
      }
a1214 1

d1220 1
d1222 23
a1244 21
	  s = get_name(s, &name);
	  s = get_name(s, &attribs);
	  while (loop) {
	    switch (*attribs++)
	      {
	      case 'W':
		had_write = 1;
		break;
	      case 'R':
		had_read = 1;
		break;
	      case 'S':
		had_shared = 1;
		break;
	      case 'X':
		had_exec = 1;
		break;
	      default:
		loop = 0;
	      }
	  }
d1246 7
a1252 6
	  if (asec) {
	    if (had_exec)
	      asec->flags |= SEC_CODE;
	    if (!had_write)
	      asec->flags |= SEC_READONLY;
	  }
d1255 2
a1256 3
	{
	  s = dores_com (s+5, output_bfd, 1);
	}
d1258 2
a1259 3
	{
	  s = dores_com (s+6, output_bfd, 0);
	}
d1270 1
a1270 2
   that symbol.
   */
d1273 1
a1273 3
mark_relocs (finfo, input_bfd)
     struct coff_final_link_info *	finfo;
     bfd * 				input_bfd;
d1311 1
a1311 2
	 skip/don't pass */

d1313 1
a1313 3
	{
	  finfo->sym_indices[ irel->r_symndx ] = -1;
	}
d1321 1
a1321 3
_bfd_coff_link_input_bfd (finfo, input_bfd)
     struct coff_final_link_info *finfo;
     bfd *input_bfd;
d1329 2
a1330 2
    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	     struct internal_reloc *, bfd_boolean *));
d1376 3
a1378 5
  if (coff_data (output_bfd)->pe)
    {
      if (! process_embedded_commands (output_bfd, finfo->info, input_bfd))
	return FALSE;
    }
d1380 3
a1382 3
  /* If we are going to perform relocations and also strip/discard some symbols
     then we must make sure that we do not strip/discard those symbols that are
     going to be involved in the relocations */
d1387 1
a1387 1
      /* mark the symbol array as 'not-used' */
d1402 1
a1402 1
      bfd_coff_swap_sym_in (input_bfd, (PTR) esym, (PTR) isymp);
d1489 1
a1489 1
            skip = TRUE;
d1575 1
a1575 1
	  mt = (struct coff_debug_merge_type *) bfd_alloc (input_bfd, amt);
d1582 1
a1582 1
	  bfd_coff_swap_aux_in (input_bfd, (PTR) (esym + isymesz),
d1584 1
a1584 1
				(PTR) &aux);
d1599 1
a1599 1
	      bfd_coff_swap_sym_in (input_bfd, (PTR) esl, (PTR) islp);
d1602 1
a1602 2
	      *epp = ((struct coff_debug_merge_element *)
		      bfd_alloc (input_bfd, amt));
d1612 1
a1612 1
	      name_copy = (char *) bfd_alloc (input_bfd, amt);
d1627 1
a1627 1
		  bfd_coff_swap_aux_in (input_bfd, (PTR) (esl + isymesz),
d1629 1
a1629 1
					islp->n_numaux, (PTR) &eleaux);
a1635 1

d1658 1
a1658 1
	    bfd_release (input_bfd, (PTR) mt);
d1694 1
a1694 1
		  bfd_release (input_bfd, (PTR) mt);
d1718 1
a1718 2
	      name = _bfd_coff_internal_syment_name (input_bfd, &isym,
						     (char *) NULL);
a1790 1

d1801 5
a1805 5
					     (PTR) &finfo->last_file,
					     (PTR) (finfo->outsyms
						    + ((finfo->last_file_index
							- syment_base)
						       * osymesz)));
d1815 1
a1815 2
					     (PTR) &finfo->last_file,
					     (PTR) outsym);
d1835 1
a1835 2

	  bfd_coff_swap_sym_out (output_bfd, (PTR) &isym, (PTR) outsym);
a1874 1

d1881 1
d1926 2
a1927 3
		  bfd_coff_swap_aux_in (input_bfd, (PTR) esym, isymp->n_type,
					isymp->n_sclass, i, isymp->n_numaux,
					(PTR) &aux);
d2020 1
a2020 1
			      PTR auxout;
d2026 5
a2030 4
			      auxout = (PTR) (finfo->outsyms
					      + ((finfo->last_bf_index
						  - syment_base)
						 * osymesz));
d2032 1
a2032 1
						     (PTR) &finfo->last_bf,
d2048 1
a2048 1
						     (PTR) &finfo->last_bf,
d2052 1
a2052 1
						     (PTR) outsym);
d2079 1
a2079 1
		  bfd_coff_swap_aux_out (output_bfd, (PTR) auxp, isymp->n_type,
d2081 1
a2081 1
					 (PTR) outsym);
d2135 1
a2135 1
	      bfd_coff_swap_lineno_in (input_bfd, (PTR) eline, (PTR) &iline);
d2171 3
a2173 4
					    (PTR) (finfo->outsyms
						   + ((indx - syment_base)
						      * osymesz)),
					    (PTR) &is);
d2178 1
a2178 1
			  PTR auxptr;
d2180 3
a2182 3
			  auxptr = (PTR) (finfo->outsyms
					  + ((indx - syment_base + 1)
					     * osymesz));
d2185 1
a2185 1
						0, is.n_numaux, (PTR) &ia);
d2190 1
a2190 1
			  bfd_coff_swap_aux_out (output_bfd, (PTR) &ia,
d2203 1
a2203 2
		  bfd_coff_swap_lineno_out (output_bfd, (PTR) &iline,
					    (PTR) oeline);
d2227 4
a2230 4
      bfd_coff_swap_sym_out (output_bfd, (PTR) &finfo->last_file,
			     (PTR) (finfo->outsyms
 				    + ((finfo->last_file_index - syment_base)
 				       * osymesz)));
d2260 2
a2261 4
	{
	  /* This section was omitted from the link.  */
	  continue;
	}
a2337 1

a2387 1

d2426 3
a2428 5
  if (! finfo->info->keep_memory)
    {
      if (! _bfd_coff_free_symbols (input_bfd))
	return FALSE;
    }
d2436 1
a2436 3
_bfd_coff_write_global_sym (h, data)
     struct coff_link_hash_entry *h;
     PTR data;
d2555 1
a2555 1
  bfd_coff_swap_sym_out (output_bfd, (PTR) &isym, (PTR) finfo->outsyms);
a2601 1

d2628 1
a2628 1
      bfd_coff_swap_aux_out (output_bfd, (PTR) auxp, isym.n_type,
d2630 1
a2630 1
			     (PTR) finfo->outsyms);
d2647 1
a2647 3
_bfd_coff_write_task_globals (h, data)
     struct coff_link_hash_entry *h;
     PTR data;
d2677 4
a2680 5
_bfd_coff_reloc_link_order (output_bfd, finfo, output_section, link_order)
     bfd *output_bfd;
     struct coff_final_link_info *finfo;
     asection *output_section;
     struct bfd_link_order *link_order;
d2702 1
a2702 1
      buf = (bfd_byte *) bfd_zmalloc (size);
d2732 1
a2732 1
      ok = bfd_set_section_contents (output_bfd, output_section, (PTR) buf,
a2740 1

a2798 1

d2808 8
a2815 11
_bfd_coff_generic_relocate_section (output_bfd, info, input_bfd,
				    input_section, contents, relocs, syms,
				    sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     struct internal_reloc *relocs;
     struct internal_syment *syms;
     asection **sections;
a2856 1

@


1.36
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d600 1
a600 1
  /* If this is a non-traditional, non-relocateable link, try to
d602 1
a602 1
  if (! info->relocateable
d742 1
a742 1
	      if (info->relocateable)
d752 1
a752 1
	  else if (info->relocateable
d785 1
a785 1
  /* If doing a relocateable link, allocate space for the pointers we
d787 1
a787 1
  if (info->relocateable)
d833 1
a833 1
	     but only when doing a relocateable link, which is not the
d835 1
a835 1
	  BFD_ASSERT (info->relocateable);
d887 1
a887 1
  if (! info->relocateable)
d899 1
a899 1
      || (! info->relocateable
d1036 1
a1036 1
  if (info->relocateable && max_output_reloc_count > 0)
d1337 2
a1338 2
	 finfo->info->relocateable,
	 (finfo->info->relocateable
d1433 1
a1433 1
      && finfo->info->relocateable)
d1480 1
a1480 1
	  && finfo->info->relocateable)
d2359 2
a2360 2
			      finfo->info->relocateable,
			      (finfo->info->relocateable
d2377 1
a2377 1
	  if (finfo->info->relocateable)
d2611 1
a2611 1
     shared or relocateable object.  */
d2613 1
a2613 1
      && ! finfo->info->relocateable
d2669 1
a2669 1
		      || finfo->info->relocateable))
d2678 1
a2678 1
		      || finfo->info->relocateable))
d2941 1
a2941 1
      /* If we are doing a relocateable link, then we can just ignore
d2943 1
a2943 1
         have the correct value.  If this is not a relocateable link,
d2947 1
a2947 1
	  if (info->relocateable)
d2990 1
a2990 1
	  else if (! info->relocateable)
@


1.35
log
@Don't mark relocations in excluded sections.
@
text
@d31 1
a31 1
static boolean coff_link_add_object_symbols
d33 10
a42 7
static boolean coff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
static boolean coff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, boolean *));
static boolean coff_link_add_symbols PARAMS ((bfd *, struct bfd_link_info *));
static char *dores_com PARAMS ((char *, bfd *, int));
static char *get_name PARAMS ((char *, char **));
d45 2
a46 1
static void mark_relocs PARAMS ((struct coff_final_link_info *, bfd *));
d48 1
a48 1
/* Return true if SYM is a weak, external symbol.  */
d53 1
a53 1
/* Return true if SYM is an external symbol.  */
d105 1
a105 1
boolean
d173 1
a173 1
boolean
d187 1
a187 1
      return false;
d193 1
a193 1
static boolean
d199 1
a199 1
    return false;
d201 1
a201 1
    return false;
d206 1
a206 1
	return false;
d208 1
a208 1
  return true;
d216 1
a216 1
static boolean
d220 1
a220 1
     boolean *pneeded;
d223 1
a223 1
    return false;
d226 1
a226 1
    return false;
d231 1
a231 1
	return false;
d237 1
a237 1
	return false;
d240 1
a240 1
  return true;
d246 1
a246 1
static boolean
d250 1
a250 1
     boolean *pneeded;
d256 1
a256 1
  *pneeded = false;
d281 2
a282 2
	    return false;
	  h = bfd_link_hash_lookup (info->hash, name, false, false, true);
d290 2
a291 2
                    bfd_link_hash_lookup (info->hash, name + 6, false, false,
                                          true);
d302 3
a304 3
		return false;
	      *pneeded = true;
	      return true;
d312 1
a312 1
  return true;
d317 1
a317 1
static boolean
d325 2
a326 2
  boolean keep_syms;
  boolean default_copy;
d337 1
a337 1
  obj_coff_keep_syms (abfd) = true;
d340 1
a340 1
    default_copy = false;
d342 1
a342 1
    default_copy = true;
d362 1
a362 1
      boolean copy;
d374 1
a374 1
	  boolean addit;
d387 1
a387 1
	    copy = true;
d422 1
a422 1
	  addit = true;
d430 1
a430 1
						 name, false, copy, false);
d441 1
a441 1
		  addit = false;
d476 1
a476 1
						   name, false, copy, false);
d482 1
a482 1
		addit = false;
d489 1
a489 1
		      (const char *) NULL, copy, false,
d641 1
a641 1
  return true;
d645 1
a645 1
  return false;
d650 1
a650 1
boolean
d657 2
a658 2
  boolean debug_merge_allocated;
  boolean long_section_names;
d691 2
a692 2
  finfo.global_to_static = false;
  debug_merge_allocated = false;
d702 1
a702 1
  debug_merge_allocated = true;
d719 1
a719 1
  long_section_names = false;
d736 1
a736 1
	      sec->linker_mark = true;
d777 2
a778 2
             we pass hash as false.  */
	  if (_bfd_stringtab_add (finfo.strtab, o->name, false, false)
d781 1
a781 1
	  long_section_names = true;
d868 1
a868 1
      sub->output_has_begun = false;
d929 1
a929 1
		  sub->output_has_begun = true;
d952 1
a952 1
  debug_merge_allocated = false;
d1005 1
a1005 1
	return false;
d1013 1
a1013 1
      finfo.failed = false;
d1022 1
a1022 1
  finfo.failed = false;
d1101 1
a1101 1
	return false;
d1111 1
a1111 1
	return false;
d1123 1
a1123 1
	return false;
d1126 1
a1126 1
	return false;
d1128 1
a1128 1
      obj_coff_strings_written (abfd) = true;
d1137 1
a1137 1
  return true;
d1175 1
a1175 1
  return false;
d1335 1
a1335 1
	(input_bfd, a, false,
d1364 1
a1364 1
boolean
d1374 3
a1376 3
  boolean (*adjust_symndx) PARAMS ((bfd *, struct bfd_link_info *, bfd *,
				    asection *, struct internal_reloc *,
				    boolean *));
d1380 1
a1380 1
  boolean copy, hash;
d1404 1
a1404 1
  copy = false;
d1406 2
a1407 2
    copy = true;
  hash = true;
d1409 1
a1409 1
    hash = false;
d1412 1
a1412 1
    return false;
d1425 1
a1425 1
	return false;
d1445 3
a1447 3
      boolean skip;
      boolean global;
      boolean dont_skip_symbol;
d1483 1
a1483 1
	dont_skip_symbol = false;
d1487 2
a1488 2
      skip = false;
      global = false;
d1493 1
a1493 1
	skip = true;
d1508 1
a1508 1
	      global = true;
d1510 1
a1510 1
		skip = true;
d1515 2
a1516 2
	      global = true;
	      skip = true;
d1523 1
a1523 1
		skip = true;
d1537 1
a1537 1
            skip = true;
d1559 1
a1559 1
	skip = true;
d1572 1
a1572 1
	    return false;
d1576 2
a1577 2
		   && (bfd_hash_lookup (finfo->info->keep_hash, name, false,
				    false) == NULL))
d1581 1
a1581 1
	    skip = true;
d1605 1
a1605 1
	    return false;
d1615 1
a1615 1
					     true, true);
d1617 1
a1617 1
	    return false;
d1625 1
a1625 1
	    return false;
d1653 1
a1653 1
		return false;
d1658 1
a1658 1
		return false;
d1663 1
a1663 1
		return false;
d1747 1
a1747 1
		  skip = true;
d1771 1
a1771 1
		return false;
d1774 1
a1774 1
		return false;
d1873 1
a1873 1
			return false;
d1906 1
a1906 1
		  return false;
d2002 1
a2002 1
			    return false;
d2008 1
a2008 1
			return false;
d2112 1
a2112 1
				return false;
d2158 1
a2158 1
	  boolean skipping;
d2178 1
a2178 1
	    return false;
d2184 1
a2184 1
	  skipping = false;
d2210 1
a2210 1
		      skipping = true;
d2250 1
a2250 1
		      skipping = false;
d2269 1
a2269 1
	    return false;
d2299 1
a2299 1
	return false;
d2332 1
a2332 1
	      return false;
d2345 1
a2345 1
	    return false;
d2358 1
a2358 1
			     (input_bfd, o, false, finfo->external_relocs,
d2365 1
a2365 1
	    return false;
d2375 1
a2375 1
	    return false;
d2391 1
a2391 1
		  boolean adjusted;
d2407 1
a2407 1
			return false;
d2453 1
a2453 1
			    return false;
d2458 1
a2458 1
			    return false;
d2475 1
a2475 1
	    return false;
d2482 1
a2482 1
	    return false;
d2489 1
a2489 1
	return false;
d2492 1
a2492 1
  return true;
d2497 1
a2497 1
boolean
d2515 1
a2515 1
	return true;
d2519 1
a2519 1
    return true;
d2525 1
a2525 1
				   h->root.root.string, false, false)
d2527 1
a2527 1
    return true;
d2535 1
a2535 1
      return false;
d2567 1
a2567 1
      return true;
d2574 1
a2574 1
      boolean hash;
d2577 1
a2577 1
      hash = true;
d2579 1
a2579 1
	hash = false;
d2581 1
a2581 1
				 false);
d2584 2
a2585 2
	  finfo->failed = true;
	  return false;
d2604 1
a2604 1
	return true;
d2628 2
a2629 2
      finfo->failed = true;
      return false;
d2698 2
a2699 2
	  finfo->failed = true;
	  return false;
d2704 1
a2704 1
  return true;
d2711 1
a2711 1
boolean
d2717 2
a2718 2
  boolean rtnval = true;
  boolean save_global_to_static;
d2730 1
a2730 1
	  finfo->global_to_static = true;
d2743 1
a2743 1
boolean
d2758 1
a2758 1
      return false;
d2766 1
a2766 1
      boolean ok;
d2772 1
a2772 1
	return false;
d2795 1
a2795 1
	      return false;
d2804 1
a2804 1
	return false;
d2837 1
a2837 1
					 false, false, true));
d2856 1
a2856 1
	    return false;
d2871 1
a2871 1
  return true;
d2877 1
a2877 1
boolean
d2918 1
a2918 1
	  return false;
d2939 1
a2939 1
	return false;
d2994 2
a2995 2
		      rel->r_vaddr - input_section->vma, true)))
		return false;
d3020 1
a3020 1
		  return false;
d3042 1
a3042 1
	  return false;
d3056 1
a3056 1
		  return false;
d3062 1
a3062 1
	      return false;
d3066 1
a3066 1
  return true;
@


1.34
log
@	* cofflink.c (_bfd_coff_final_link): On PE COFF systems, take into
	account the impact of relocation count overflow when computing
	section offsets.
	* coffcode.h (coff_write_relocs): Use obj_pe when deciding whether
	or not to apply the PE COFF reloc overflow handling.  Fix a
	fencepost error in deciding whether or not to use that technique.
@
text
@d1325 3
@


1.34.2.1
log
@Merge from mainline.
@
text
@a1324 3
      /* Don't mark relocs in excluded sections.  */
      if (a->output_section == bfd_abs_section_ptr)
	continue;
@


1.34.14.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@a1324 3
      /* Don't mark relocs in excluded sections.  */
      if (a->output_section == bfd_abs_section_ptr)
	continue;
@


1.34.14.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a29 1
#include "safe-ctype.h"
d31 12
a42 3
static bfd_boolean coff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info);
static bfd_boolean coff_link_check_archive_element (bfd *abfd, struct bfd_link_info *info, bfd_boolean *pneeded);
static bfd_boolean coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info);
d44 1
a44 1
/* Return TRUE if SYM is a weak, external symbol.  */
d49 1
a49 1
/* Return TRUE if SYM is an external symbol.  */
d66 4
a69 3
_bfd_coff_link_hash_newfunc (struct bfd_hash_entry *entry,
			     struct bfd_hash_table *table,
			     const char *string)
d101 7
a107 6
bfd_boolean
_bfd_coff_link_hash_table_init (struct coff_link_hash_table *table,
				bfd *abfd,
				struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
								   struct bfd_hash_table *,
								   const char *))
d116 2
a117 1
_bfd_coff_link_hash_table_create (bfd *abfd)
d122 1
a122 1
  ret = bfd_malloc (amt);
a124 1

d137 4
a140 3
_bfd_coff_debug_merge_hash_newfunc (struct bfd_hash_entry *entry,
				    struct bfd_hash_table *table,
				    const char *string)
d169 4
a172 2
bfd_boolean
_bfd_coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
d179 2
a180 2
      return _bfd_generic_link_add_archive_symbols
	(abfd, info, coff_link_check_archive_element);
d183 1
a183 1
      return FALSE;
d189 4
a192 2
static bfd_boolean
coff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
d195 1
a195 1
    return FALSE;
d197 26
a222 1
    return FALSE;
d224 5
a228 3
  if (! info->keep_memory
      && ! _bfd_coff_free_symbols (abfd))
    return FALSE;
d230 7
a236 1
  return TRUE;
d242 5
a246 4
static bfd_boolean
coff_link_check_ar_symbols (bfd *abfd,
			    struct bfd_link_info *info,
			    bfd_boolean *pneeded)
d252 1
a252 1
  *pneeded = FALSE;
d262 1
a262 1
      bfd_coff_swap_sym_in (abfd, esym, &sym);
d274 1
d277 2
a278 8
	    return FALSE;
	  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);

	  /* Auto import.  */
	  if (!h
	      && info->pei386_auto_import
	      && !strncmp (name,"__imp_", 6))
	    h = bfd_link_hash_lookup (info->hash, name + 6, FALSE, FALSE, TRUE);
d280 10
d298 3
a300 3
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
d308 1
a308 28
  return TRUE;
}

/* Check a single archive element to see if we need to include it in
   the link.  *PNEEDED is set according to whether this element is
   needed in the link or not.  This is called via
   _bfd_generic_link_add_archive_symbols.  */

static bfd_boolean
coff_link_check_archive_element (bfd *abfd,
				 struct bfd_link_info *info,
				 bfd_boolean *pneeded)
{
  if (! _bfd_coff_get_external_symbols (abfd))
    return FALSE;

  if (! coff_link_check_ar_symbols (abfd, info, pneeded))
    return FALSE;

  if (*pneeded
      && ! coff_link_add_symbols (abfd, info))
    return FALSE;

  if ((! info->keep_memory || ! *pneeded)
      && ! _bfd_coff_free_symbols (abfd))
    return FALSE;

  return TRUE;
d313 4
a316 3
static bfd_boolean
coff_link_add_symbols (bfd *abfd,
		       struct bfd_link_info *info)
d321 2
a322 2
  bfd_boolean keep_syms;
  bfd_boolean default_copy;
d333 1
a333 1
  obj_coff_keep_syms (abfd) = TRUE;
d336 1
a336 1
    default_copy = FALSE;
d338 1
a338 1
    default_copy = TRUE;
d345 1
a345 1
  sym_hash = bfd_zalloc (abfd, amt);
d358 1
a358 1
      bfd_boolean copy;
d360 1
a360 1
      bfd_coff_swap_sym_in (abfd, esym, &sym);
d370 1
a370 1
	  bfd_boolean addit;
d383 1
a383 1
	    copy = TRUE;
d418 1
a418 1
	  addit = TRUE;
d426 1
a426 1
						 name, FALSE, copy, FALSE);
d437 1
a437 1
		  addit = FALSE;
d472 1
a472 1
						   name, FALSE, copy, FALSE);
d478 1
a478 1
		addit = FALSE;
d485 1
a485 1
		      (const char *) NULL, copy, FALSE,
d563 1
a563 1
			bfd_coff_swap_aux_in (abfd, eaux, sym.n_type,
d565 1
a565 1
					      sym.n_numaux, iaux);
d581 1
d596 1
a596 1
  /* If this is a non-traditional, non-relocatable link, try to
d598 1
a598 1
  if (! info->relocatable
d603 1
a603 1
      asection *stabstr;
d605 4
a608 1
      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
d610 1
a610 9
      if (stabstr != NULL)
	{
	  bfd_size_type string_offset = 0;
	  asection *stab;
	  
	  for (stab = abfd->sections; stab; stab = stab->next)
	    if (strncmp (".stab", stab->name, 5) == 0
		&& (!stab->name[5]
		    || (stab->name[5] == '.' && ISDIGIT (stab->name[6]))))
d613 3
a615 3
	      struct coff_section_tdata *secdata
		= coff_section_data (abfd, stab);
	      
d619 1
a619 1
		  stab->used_by_bfd = bfd_zalloc (abfd, amt);
d629 1
a629 2
					     &secdata->stab_info,
					     &string_offset))
d637 1
a637 1
  return TRUE;
d641 1
a641 1
  return FALSE;
d646 4
a649 3
bfd_boolean
_bfd_coff_final_link (bfd *abfd,
		      struct bfd_link_info *info)
d653 2
a654 2
  bfd_boolean debug_merge_allocated;
  bfd_boolean long_section_names;
d687 2
a688 2
  finfo.global_to_static = FALSE;
  debug_merge_allocated = FALSE;
d698 1
a698 1
  debug_merge_allocated = TRUE;
d715 1
a715 1
  long_section_names = FALSE;
d732 1
a732 1
	      sec->linker_mark = TRUE;
d738 1
a738 1
	      if (info->relocatable)
d748 1
a748 1
	  else if (info->relocatable
d773 2
a774 2
             we pass hash as FALSE.  */
	  if (_bfd_stringtab_add (finfo.strtab, o->name, FALSE, FALSE)
d777 1
a777 1
	  long_section_names = TRUE;
d781 1
a781 1
  /* If doing a relocatable link, allocate space for the pointers we
d783 1
a783 1
  if (info->relocatable)
d791 1
a791 1
      finfo.section_info = bfd_malloc (amt);
d829 1
a829 1
	     but only when doing a relocatable link, which is not the
d831 1
a831 1
	  BFD_ASSERT (info->relocatable);
d834 2
a835 1
	  finfo.section_info[o->target_index].relocs = bfd_malloc (amt);
d838 2
a839 1
	  finfo.section_info[o->target_index].rel_hashes = bfd_malloc (amt);
d864 1
a864 1
      sub->output_has_begun = FALSE;
d872 1
a872 1
  finfo.internal_syms = bfd_malloc (amt);
d874 1
a874 1
  finfo.sec_ptrs = bfd_malloc (amt);
d876 2
a877 2
  finfo.sym_indices = bfd_malloc (amt);
  finfo.outsyms = bfd_malloc ((max_sym_count + 1) * symesz);
d879 2
a880 2
  finfo.linenos = bfd_malloc (amt);
  finfo.contents = bfd_malloc (max_contents_size);
d882 2
a883 2
  finfo.external_relocs = bfd_malloc (amt);
  if (! info->relocatable)
d886 1
a886 1
      finfo.internal_relocs = bfd_malloc (amt);
d895 1
a895 1
      || (! info->relocatable
d925 1
a925 1
		  sub->output_has_begun = TRUE;
d948 1
a948 1
  debug_merge_allocated = FALSE;
d995 2
a996 2
      bfd_coff_swap_sym_out (abfd, &finfo.last_file,
			     finfo.outsyms);
d1001 1
a1001 1
	return FALSE;
d1009 1
a1009 1
      finfo.failed = FALSE;
d1011 2
a1012 1
			       _bfd_coff_write_task_globals, &finfo);
d1018 1
a1018 1
  finfo.failed = FALSE;
d1020 2
a1021 1
			   _bfd_coff_write_global_sym, &finfo);
d1032 1
a1032 1
  if (info->relocatable && max_output_reloc_count > 0)
d1038 1
a1038 1
      external_relocs = bfd_malloc (amt);
d1063 1
a1063 1
	      bfd_coff_swap_reloc_out (abfd, irel, erel);
d1066 4
a1069 21
	  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0)
	    goto error_return;
	  if (obj_pe (abfd) && o->reloc_count >= 0xffff)
	    {
	      /* In PE COFF, write the count of relocs as the first
		 reloc.  The header overflow bit will be set
		 elsewhere. */
	      struct internal_reloc incount;
	      bfd_byte *excount = (bfd_byte *)bfd_malloc (relsz);
	      
	      memset (&incount, 0, sizeof (incount));
	      incount.r_vaddr = o->reloc_count + 1;
	      bfd_coff_swap_reloc_out (abfd, (PTR) &incount, (PTR) excount);
	      if (bfd_bwrite (excount, relsz, abfd) != relsz)
		/* We'll leak, but it's an error anyway. */
		goto error_return;
	      free (excount);
	    }
	  if (bfd_bwrite (external_relocs,
			  (bfd_size_type) relsz * o->reloc_count, abfd)
	      != (bfd_size_type) relsz * o->reloc_count)
d1097 1
a1097 1
	return FALSE;
d1107 1
a1107 1
	return FALSE;
d1119 1
a1119 1
	return FALSE;
d1122 1
a1122 1
	return FALSE;
d1124 1
a1124 1
      obj_coff_strings_written (abfd) = TRUE;
d1133 1
a1133 1
  return TRUE;
d1171 1
a1171 1
  return FALSE;
d1174 1
a1174 1
/* Parse out a -heap <reserved>,<commit> line.  */
d1177 4
a1180 1
dores_com (char *ptr, bfd *output_bfd, int heap)
a1184 1

d1202 3
a1204 2
static char *
get_name (char *ptr, char **dst)
d1215 1
a1215 1
/* Process any magic embedded commands in a section called .drectve.  */
d1218 4
a1221 3
process_embedded_commands (bfd *output_bfd,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   bfd *abfd)
a1226 1

d1233 1
a1233 2

  if (! bfd_get_section_contents (abfd, sec, copy, (bfd_vma) 0, sec->_raw_size))
a1238 1

d1241 4
a1244 5
      if (s[0]!= '-')
	{
	  s++;
	  continue;
	}
d1250 1
a1255 1

d1257 21
a1277 23
	  s = get_name (s, &name);
	  s = get_name (s, &attribs);

	  while (loop)
	    {
	      switch (*attribs++)
		{
		case 'W':
		  had_write = 1;
		  break;
		case 'R':
		  had_read = 1;
		  break;
		case 'S':
		  had_shared = 1;
		  break;
		case 'X':
		  had_exec = 1;
		  break;
		default:
		  loop = 0;
		}
	    }
d1279 6
a1284 7
	  if (asec)
	    {
	      if (had_exec)
		asec->flags |= SEC_CODE;
	      if (!had_write)
		asec->flags |= SEC_READONLY;
	    }
d1287 3
a1289 2
	s = dores_com (s+5, output_bfd, 1);

d1291 3
a1293 2
	s = dores_com (s+6, output_bfd, 0);

d1304 2
a1305 1
   that symbol.  */
d1308 3
a1310 1
mark_relocs (struct coff_final_link_info *finfo, bfd *input_bfd)
d1331 1
a1331 1
	(input_bfd, a, FALSE,
d1333 2
a1334 2
	 finfo->info->relocatable,
	 (finfo->info->relocatable
d1348 2
a1349 1
	 skip/don't-skip pass.  */
d1351 3
a1353 1
	finfo->sym_indices[ irel->r_symndx ] = -1;
d1360 4
a1363 2
bfd_boolean
_bfd_coff_link_input_bfd (struct coff_final_link_info *finfo, bfd *input_bfd)
d1370 3
a1372 3
  bfd_boolean (*adjust_symndx)
    (bfd *, struct bfd_link_info *, bfd *, asection *,
     struct internal_reloc *, bfd_boolean *);
d1376 1
a1376 1
  bfd_boolean copy, hash;
d1400 1
a1400 1
  copy = FALSE;
d1402 2
a1403 2
    copy = TRUE;
  hash = TRUE;
d1405 1
a1405 1
    hash = FALSE;
d1408 1
a1408 1
    return FALSE;
d1418 9
a1426 7
  if (coff_data (output_bfd)->pe
      && ! process_embedded_commands (output_bfd, finfo->info, input_bfd))
    return FALSE;

  /* If we are going to perform relocations and also strip/discard some
     symbols then we must make sure that we do not strip/discard those
     symbols that are going to be involved in the relocations.  */
d1429 1
a1429 1
      && finfo->info->relocatable)
d1431 1
a1431 1
      /* Mark the symbol array as 'not-used'.  */
d1441 3
a1443 3
      bfd_boolean skip;
      bfd_boolean global;
      bfd_boolean dont_skip_symbol;
d1446 1
a1446 1
      bfd_coff_swap_sym_in (input_bfd, esym, isymp);
d1476 1
a1476 1
	  && finfo->info->relocatable)
d1479 1
a1479 1
	dont_skip_symbol = FALSE;
d1483 2
a1484 2
      skip = FALSE;
      global = FALSE;
d1489 1
a1489 1
	skip = TRUE;
d1504 1
a1504 1
	      global = TRUE;
d1506 1
a1506 1
		skip = TRUE;
d1511 2
a1512 2
	      global = TRUE;
	      skip = TRUE;
d1519 1
a1519 1
		skip = TRUE;
a1527 1
	  && dont_skip_symbol == 0
d1530 5
a1534 3
          && isym.n_numaux > 0
	  && (*secpp)->output_section == bfd_abs_section_ptr)
	skip = TRUE;
d1555 1
a1555 1
	skip = TRUE;
d1568 1
a1568 1
	    return FALSE;
d1572 2
a1573 2
		   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
				    FALSE) == NULL))
d1577 1
a1577 1
	    skip = TRUE;
d1601 1
a1601 1
	    return FALSE;
d1611 1
a1611 1
					     TRUE, TRUE);
d1613 1
a1613 1
	    return FALSE;
d1619 1
a1619 1
	  mt = bfd_alloc (input_bfd, amt);
d1621 1
a1621 1
	    return FALSE;
d1626 1
a1626 1
	  bfd_coff_swap_aux_in (input_bfd, (esym + isymesz),
d1628 1
a1628 1
				&aux);
d1643 1
a1643 1
	      bfd_coff_swap_sym_in (input_bfd, esl, islp);
d1646 2
a1647 1
	      *epp = bfd_alloc (input_bfd, amt);
d1649 1
a1649 1
		return FALSE;
d1654 1
a1654 1
		return FALSE;
d1657 1
a1657 1
	      name_copy = bfd_alloc (input_bfd, amt);
d1659 1
a1659 1
		return FALSE;
d1672 1
a1672 1
		  bfd_coff_swap_aux_in (input_bfd, (esl + isymesz),
d1674 1
a1674 1
					islp->n_numaux, &eleaux);
d1681 1
d1704 1
a1704 1
	    bfd_release (input_bfd, mt);
d1740 1
a1740 1
		  bfd_release (input_bfd, mt);
d1743 1
a1743 1
		  skip = TRUE;
d1764 2
a1765 1
	      name = _bfd_coff_internal_syment_name (input_bfd, &isym, NULL);
d1767 1
a1767 1
		return FALSE;
d1770 1
a1770 1
		return FALSE;
d1838 1
d1849 5
a1853 5
					     &finfo->last_file,
					     (finfo->outsyms
					      + ((finfo->last_file_index
						  - syment_base)
						 * osymesz)));
d1863 2
a1864 1
					     &finfo->last_file, outsym);
d1869 1
a1869 1
			return FALSE;
d1884 2
a1885 1
	  bfd_coff_swap_sym_out (output_bfd, &isym, outsym);
d1902 1
a1902 1
		  return FALSE;
d1925 1
a1931 1

d1976 3
a1978 2
		  bfd_coff_swap_aux_in (input_bfd, esym, isymp->n_type,
					isymp->n_sclass, i, isymp->n_numaux, &aux);
d1998 1
a1998 1
			    return FALSE;
d2004 1
a2004 1
			return FALSE;
d2071 1
a2071 1
			      void *auxout;
d2077 4
a2080 5
			      auxout = (finfo->outsyms
					+ ((finfo->last_bf_index
					    - syment_base)
					   * osymesz));

d2082 1
a2082 1
						     &finfo->last_bf,
d2098 1
a2098 1
						     &finfo->last_bf,
d2102 1
a2102 1
						     outsym);
d2108 1
a2108 1
				return FALSE;
d2129 1
a2129 1
		  bfd_coff_swap_aux_out (output_bfd, auxp, isymp->n_type,
d2131 1
a2131 1
					 outsym);
d2154 1
a2154 1
	  bfd_boolean skipping;
d2174 1
a2174 1
	    return FALSE;
d2180 1
a2180 1
	  skipping = FALSE;
d2185 1
a2185 1
	      bfd_coff_swap_lineno_in (input_bfd, eline, &iline);
d2206 1
a2206 1
		      skipping = TRUE;
d2221 4
a2224 3
					    (finfo->outsyms
					     + ((indx - syment_base)
						* osymesz)), &is);
d2229 1
a2229 1
			  void *auxptr;
d2231 3
a2233 3
			  auxptr = (finfo->outsyms
				    + ((indx - syment_base + 1)
				       * osymesz));
d2236 1
a2236 1
						0, is.n_numaux, &ia);
d2241 1
a2241 1
			  bfd_coff_swap_aux_out (output_bfd, &ia,
d2246 1
a2246 1
		      skipping = FALSE;
d2254 2
a2255 1
		  bfd_coff_swap_lineno_out (output_bfd, &iline, oeline);
d2265 1
a2265 1
	    return FALSE;
d2279 4
a2282 4
      bfd_coff_swap_sym_out (output_bfd, &finfo->last_file,
			     (finfo->outsyms
			      + ((finfo->last_file_index - syment_base)
				 * osymesz)));
d2295 1
a2295 1
	return FALSE;
d2312 4
a2315 2
	/* This section was omitted from the link.  */
	continue;
d2328 1
a2328 1
	      return FALSE;
d2341 1
a2341 1
	    return FALSE;
d2354 3
a2356 3
			     (input_bfd, o, FALSE, finfo->external_relocs,
			      finfo->info->relocatable,
			      (finfo->info->relocatable
d2361 1
a2361 1
	    return FALSE;
d2371 1
a2371 1
	    return FALSE;
d2373 1
a2373 1
	  if (finfo->info->relocatable)
d2387 1
a2387 1
		  bfd_boolean adjusted;
d2392 1
d2403 1
a2403 1
			return FALSE;
d2443 1
d2449 1
a2449 1
			    return FALSE;
d2454 1
a2454 1
			    return FALSE;
d2471 1
a2471 1
	    return FALSE;
d2478 1
a2478 1
	    return FALSE;
d2482 5
a2486 3
  if (! finfo->info->keep_memory
      && ! _bfd_coff_free_symbols (input_bfd))
    return FALSE;
d2488 1
a2488 1
  return TRUE;
d2493 4
a2496 2
bfd_boolean
_bfd_coff_write_global_sym (struct coff_link_hash_entry *h, void *data)
d2511 1
a2511 1
	return TRUE;
d2515 1
a2515 1
    return TRUE;
d2521 1
a2521 1
				   h->root.root.string, FALSE, FALSE)
d2523 1
a2523 1
    return TRUE;
d2531 1
a2531 1
      return FALSE;
d2563 1
a2563 1
      return TRUE;
d2570 1
a2570 1
      bfd_boolean hash;
d2573 1
a2573 1
      hash = TRUE;
d2575 1
a2575 1
	hash = FALSE;
d2577 1
a2577 1
				 FALSE);
d2580 2
a2581 2
	  finfo->failed = TRUE;
	  return FALSE;
d2600 1
a2600 1
	return TRUE;
d2605 1
a2605 1
  /* When a weak symbol is not overridden by a strong one,
d2607 1
a2607 1
     shared or relocatable object.  */
d2609 1
a2609 1
      && ! finfo->info->relocatable
d2615 1
a2615 1
  bfd_coff_swap_sym_out (output_bfd, &isym, finfo->outsyms);
d2624 2
a2625 2
      finfo->failed = TRUE;
      return FALSE;
d2662 1
d2665 1
a2665 1
		      || finfo->info->relocatable))
d2674 1
a2674 1
		      || finfo->info->relocatable))
d2689 1
a2689 1
      bfd_coff_swap_aux_out (output_bfd, auxp, isym.n_type,
d2691 1
a2691 1
			     finfo->outsyms);
d2694 2
a2695 2
	  finfo->failed = TRUE;
	  return FALSE;
d2700 1
a2700 1
  return TRUE;
d2707 4
a2710 2
bfd_boolean
_bfd_coff_write_task_globals (struct coff_link_hash_entry *h, void *data)
d2713 2
a2714 2
  bfd_boolean rtnval = TRUE;
  bfd_boolean save_global_to_static;
d2726 1
a2726 1
	  finfo->global_to_static = TRUE;
d2739 6
a2744 5
bfd_boolean
_bfd_coff_reloc_link_order (bfd *output_bfd,
			    struct coff_final_link_info *finfo,
			    asection *output_section,
			    struct bfd_link_order *link_order)
d2754 1
a2754 1
      return FALSE;
d2762 1
a2762 1
      bfd_boolean ok;
d2766 1
a2766 1
      buf = bfd_zmalloc (size);
d2768 1
a2768 1
	return FALSE;
d2791 1
a2791 1
	      return FALSE;
d2796 1
a2796 1
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
d2800 1
a2800 1
	return FALSE;
d2805 1
d2833 1
a2833 1
					 FALSE, FALSE, TRUE));
d2852 1
a2852 1
	    return FALSE;
d2864 1
d2867 1
a2867 1
  return TRUE;
d2873 12
a2884 9
bfd_boolean
_bfd_coff_generic_relocate_section (bfd *output_bfd,
				    struct bfd_link_info *info,
				    bfd *input_bfd,
				    asection *input_section,
				    bfd_byte *contents,
				    struct internal_reloc *relocs,
				    struct internal_syment *syms,
				    asection **sections)
d2914 1
a2914 1
	  return FALSE;
d2926 1
d2935 1
a2935 1
	return FALSE;
d2937 1
a2937 1
      /* If we are doing a relocatable link, then we can just ignore
d2939 1
a2939 1
         have the correct value.  If this is not a relocatable link,
d2943 1
a2943 1
	  if (info->relocatable)
d2986 1
a2986 1
	  else if (! info->relocatable)
d2990 2
a2991 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d3016 1
a3016 1
		  return FALSE;
d3038 1
a3038 1
	  return FALSE;
d3052 1
a3052 1
		  return FALSE;
d3058 1
a3058 1
	      return FALSE;
d3062 1
a3062 1
  return TRUE;
@


1.34.12.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@a1324 3
      /* Don't mark relocs in excluded sections.  */
      if (a->output_section == bfd_abs_section_ptr)
	continue;
@


1.34.12.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d31 1
a31 1
static bfd_boolean coff_link_add_object_symbols
d33 7
a39 10
static bfd_boolean coff_link_check_archive_element
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean coff_link_check_ar_symbols
  PARAMS ((bfd *, struct bfd_link_info *, bfd_boolean *));
static bfd_boolean coff_link_add_symbols
  PARAMS ((bfd *, struct bfd_link_info *));
static char *dores_com
  PARAMS ((char *, bfd *, int));
static char *get_name
  PARAMS ((char *, char **));
d42 1
a42 2
static void mark_relocs
  PARAMS ((struct coff_final_link_info *, bfd *));
d44 1
a44 1
/* Return TRUE if SYM is a weak, external symbol.  */
d49 1
a49 1
/* Return TRUE if SYM is an external symbol.  */
d101 1
a101 1
bfd_boolean
d169 1
a169 1
bfd_boolean
d183 1
a183 1
      return FALSE;
d189 1
a189 1
static bfd_boolean
d195 1
a195 1
    return FALSE;
d197 1
a197 1
    return FALSE;
d202 1
a202 1
	return FALSE;
d204 1
a204 1
  return TRUE;
d212 1
a212 1
static bfd_boolean
d216 1
a216 1
     bfd_boolean *pneeded;
d219 1
a219 1
    return FALSE;
d222 1
a222 1
    return FALSE;
d227 1
a227 1
	return FALSE;
d233 1
a233 1
	return FALSE;
d236 1
a236 1
  return TRUE;
d242 1
a242 1
static bfd_boolean
d246 1
a246 1
     bfd_boolean *pneeded;
d252 1
a252 1
  *pneeded = FALSE;
d277 2
a278 2
	    return FALSE;
	  h = bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, TRUE);
d286 2
a287 2
                    bfd_link_hash_lookup (info->hash, name + 6, FALSE, FALSE,
                                          TRUE);
d298 3
a300 3
		return FALSE;
	      *pneeded = TRUE;
	      return TRUE;
d308 1
a308 1
  return TRUE;
d313 1
a313 1
static bfd_boolean
d321 2
a322 2
  bfd_boolean keep_syms;
  bfd_boolean default_copy;
d333 1
a333 1
  obj_coff_keep_syms (abfd) = TRUE;
d336 1
a336 1
    default_copy = FALSE;
d338 1
a338 1
    default_copy = TRUE;
d358 1
a358 1
      bfd_boolean copy;
d370 1
a370 1
	  bfd_boolean addit;
d383 1
a383 1
	    copy = TRUE;
d418 1
a418 1
	  addit = TRUE;
d426 1
a426 1
						 name, FALSE, copy, FALSE);
d437 1
a437 1
		  addit = FALSE;
d472 1
a472 1
						   name, FALSE, copy, FALSE);
d478 1
a478 1
		addit = FALSE;
d485 1
a485 1
		      (const char *) NULL, copy, FALSE,
d637 1
a637 1
  return TRUE;
d641 1
a641 1
  return FALSE;
d646 1
a646 1
bfd_boolean
d653 2
a654 2
  bfd_boolean debug_merge_allocated;
  bfd_boolean long_section_names;
d687 2
a688 2
  finfo.global_to_static = FALSE;
  debug_merge_allocated = FALSE;
d698 1
a698 1
  debug_merge_allocated = TRUE;
d715 1
a715 1
  long_section_names = FALSE;
d732 1
a732 1
	      sec->linker_mark = TRUE;
d773 2
a774 2
             we pass hash as FALSE.  */
	  if (_bfd_stringtab_add (finfo.strtab, o->name, FALSE, FALSE)
d777 1
a777 1
	  long_section_names = TRUE;
d864 1
a864 1
      sub->output_has_begun = FALSE;
d925 1
a925 1
		  sub->output_has_begun = TRUE;
d948 1
a948 1
  debug_merge_allocated = FALSE;
d1001 1
a1001 1
	return FALSE;
d1009 1
a1009 1
      finfo.failed = FALSE;
d1018 1
a1018 1
  finfo.failed = FALSE;
d1097 1
a1097 1
	return FALSE;
d1107 1
a1107 1
	return FALSE;
d1119 1
a1119 1
	return FALSE;
d1122 1
a1122 1
	return FALSE;
d1124 1
a1124 1
      obj_coff_strings_written (abfd) = TRUE;
d1133 1
a1133 1
  return TRUE;
d1171 1
a1171 1
  return FALSE;
d1331 1
a1331 1
	(input_bfd, a, FALSE,
d1360 1
a1360 1
bfd_boolean
d1370 3
a1372 3
  bfd_boolean (*adjust_symndx)
    PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *,
	     struct internal_reloc *, bfd_boolean *));
d1376 1
a1376 1
  bfd_boolean copy, hash;
d1400 1
a1400 1
  copy = FALSE;
d1402 2
a1403 2
    copy = TRUE;
  hash = TRUE;
d1405 1
a1405 1
    hash = FALSE;
d1408 1
a1408 1
    return FALSE;
d1421 1
a1421 1
	return FALSE;
d1441 3
a1443 3
      bfd_boolean skip;
      bfd_boolean global;
      bfd_boolean dont_skip_symbol;
d1479 1
a1479 1
	dont_skip_symbol = FALSE;
d1483 2
a1484 2
      skip = FALSE;
      global = FALSE;
d1489 1
a1489 1
	skip = TRUE;
d1504 1
a1504 1
	      global = TRUE;
d1506 1
a1506 1
		skip = TRUE;
d1511 2
a1512 2
	      global = TRUE;
	      skip = TRUE;
d1519 1
a1519 1
		skip = TRUE;
d1533 1
a1533 1
            skip = TRUE;
d1555 1
a1555 1
	skip = TRUE;
d1568 1
a1568 1
	    return FALSE;
d1572 2
a1573 2
		   && (bfd_hash_lookup (finfo->info->keep_hash, name, FALSE,
				    FALSE) == NULL))
d1577 1
a1577 1
	    skip = TRUE;
d1601 1
a1601 1
	    return FALSE;
d1611 1
a1611 1
					     TRUE, TRUE);
d1613 1
a1613 1
	    return FALSE;
d1621 1
a1621 1
	    return FALSE;
d1649 1
a1649 1
		return FALSE;
d1654 1
a1654 1
		return FALSE;
d1659 1
a1659 1
		return FALSE;
d1743 1
a1743 1
		  skip = TRUE;
d1767 1
a1767 1
		return FALSE;
d1770 1
a1770 1
		return FALSE;
d1869 1
a1869 1
			return FALSE;
d1902 1
a1902 1
		  return FALSE;
d1998 1
a1998 1
			    return FALSE;
d2004 1
a2004 1
			return FALSE;
d2108 1
a2108 1
				return FALSE;
d2154 1
a2154 1
	  bfd_boolean skipping;
d2174 1
a2174 1
	    return FALSE;
d2180 1
a2180 1
	  skipping = FALSE;
d2206 1
a2206 1
		      skipping = TRUE;
d2246 1
a2246 1
		      skipping = FALSE;
d2265 1
a2265 1
	    return FALSE;
d2295 1
a2295 1
	return FALSE;
d2328 1
a2328 1
	      return FALSE;
d2341 1
a2341 1
	    return FALSE;
d2354 1
a2354 1
			     (input_bfd, o, FALSE, finfo->external_relocs,
d2361 1
a2361 1
	    return FALSE;
d2371 1
a2371 1
	    return FALSE;
d2387 1
a2387 1
		  bfd_boolean adjusted;
d2403 1
a2403 1
			return FALSE;
d2449 1
a2449 1
			    return FALSE;
d2454 1
a2454 1
			    return FALSE;
d2471 1
a2471 1
	    return FALSE;
d2478 1
a2478 1
	    return FALSE;
d2485 1
a2485 1
	return FALSE;
d2488 1
a2488 1
  return TRUE;
d2493 1
a2493 1
bfd_boolean
d2511 1
a2511 1
	return TRUE;
d2515 1
a2515 1
    return TRUE;
d2521 1
a2521 1
				   h->root.root.string, FALSE, FALSE)
d2523 1
a2523 1
    return TRUE;
d2531 1
a2531 1
      return FALSE;
d2563 1
a2563 1
      return TRUE;
d2570 1
a2570 1
      bfd_boolean hash;
d2573 1
a2573 1
      hash = TRUE;
d2575 1
a2575 1
	hash = FALSE;
d2577 1
a2577 1
				 FALSE);
d2580 2
a2581 2
	  finfo->failed = TRUE;
	  return FALSE;
d2600 1
a2600 1
	return TRUE;
d2624 2
a2625 2
      finfo->failed = TRUE;
      return FALSE;
d2694 2
a2695 2
	  finfo->failed = TRUE;
	  return FALSE;
d2700 1
a2700 1
  return TRUE;
d2707 1
a2707 1
bfd_boolean
d2713 2
a2714 2
  bfd_boolean rtnval = TRUE;
  bfd_boolean save_global_to_static;
d2726 1
a2726 1
	  finfo->global_to_static = TRUE;
d2739 1
a2739 1
bfd_boolean
d2754 1
a2754 1
      return FALSE;
d2762 1
a2762 1
      bfd_boolean ok;
d2768 1
a2768 1
	return FALSE;
d2791 1
a2791 1
	      return FALSE;
d2800 1
a2800 1
	return FALSE;
d2833 1
a2833 1
					 FALSE, FALSE, TRUE));
d2852 1
a2852 1
	    return FALSE;
d2867 1
a2867 1
  return TRUE;
d2873 1
a2873 1
bfd_boolean
d2914 1
a2914 1
	  return FALSE;
d2935 1
a2935 1
	return FALSE;
d2990 2
a2991 2
		      rel->r_vaddr - input_section->vma, TRUE)))
		return FALSE;
d3016 1
a3016 1
		  return FALSE;
d3038 1
a3038 1
	  return FALSE;
d3052 1
a3052 1
		  return FALSE;
d3058 1
a3058 1
	      return FALSE;
d3062 1
a3062 1
  return TRUE;
@


1.34.12.3
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d600 1
a600 1
  /* If this is a non-traditional, non-relocatable link, try to
d602 1
a602 1
  if (! info->relocatable
d742 1
a742 1
	      if (info->relocatable)
d752 1
a752 1
	  else if (info->relocatable
d785 1
a785 1
  /* If doing a relocatable link, allocate space for the pointers we
d787 1
a787 1
  if (info->relocatable)
d833 1
a833 1
	     but only when doing a relocatable link, which is not the
d835 1
a835 1
	  BFD_ASSERT (info->relocatable);
d887 1
a887 1
  if (! info->relocatable)
d899 1
a899 1
      || (! info->relocatable
d1036 1
a1036 1
  if (info->relocatable && max_output_reloc_count > 0)
d1337 2
a1338 2
	 finfo->info->relocatable,
	 (finfo->info->relocatable
d1433 1
a1433 1
      && finfo->info->relocatable)
d1480 1
a1480 1
	  && finfo->info->relocatable)
d2359 2
a2360 2
			      finfo->info->relocatable,
			      (finfo->info->relocatable
d2377 1
a2377 1
	  if (finfo->info->relocatable)
d2611 1
a2611 1
     shared or relocatable object.  */
d2613 1
a2613 1
      && ! finfo->info->relocatable
d2669 1
a2669 1
		      || finfo->info->relocatable))
d2678 1
a2678 1
		      || finfo->info->relocatable))
d2941 1
a2941 1
      /* If we are doing a relocatable link, then we can just ignore
d2943 1
a2943 1
         have the correct value.  If this is not a relocatable link,
d2947 1
a2947 1
	  if (info->relocatable)
d2990 1
a2990 1
	  else if (! info->relocatable)
@


1.34.12.4
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d6 1
a6 1
   This file is part of BFD, the Binary File Descriptor library.
d8 13
a20 13
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d31 16
a46 3
static bfd_boolean coff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info);
static bfd_boolean coff_link_check_archive_element (bfd *abfd, struct bfd_link_info *info, bfd_boolean *pneeded);
static bfd_boolean coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info);
d70 4
a73 3
_bfd_coff_link_hash_newfunc (struct bfd_hash_entry *entry,
			     struct bfd_hash_table *table,
			     const char *string)
d106 6
a111 5
_bfd_coff_link_hash_table_init (struct coff_link_hash_table *table,
				bfd *abfd,
				struct bfd_hash_entry *(*newfunc) (struct bfd_hash_entry *,
								   struct bfd_hash_table *,
								   const char *))
d120 2
a121 1
_bfd_coff_link_hash_table_create (bfd *abfd)
d126 1
a126 1
  ret = bfd_malloc (amt);
a128 1

d141 4
a144 3
_bfd_coff_debug_merge_hash_newfunc (struct bfd_hash_entry *entry,
				    struct bfd_hash_table *table,
				    const char *string)
d174 3
a176 1
_bfd_coff_link_add_symbols (bfd *abfd, struct bfd_link_info *info)
d183 2
a184 2
      return _bfd_generic_link_add_archive_symbols
	(abfd, info, coff_link_check_archive_element);
d194 3
a196 1
coff_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
d203 20
a222 2
  if (! info->keep_memory
      && ! _bfd_coff_free_symbols (abfd))
d225 15
d247 4
a250 3
coff_link_check_ar_symbols (bfd *abfd,
			    struct bfd_link_info *info,
			    bfd_boolean *pneeded)
d266 1
a266 1
      bfd_coff_swap_sym_in (abfd, esym, &sym);
d278 1
d284 10
a293 6
	  /* Auto import.  */
	  if (!h
	      && info->pei386_auto_import
	      && !strncmp (name,"__imp_", 6))
	    h = bfd_link_hash_lookup (info->hash, name + 6, FALSE, FALSE, TRUE);

a314 27
/* Check a single archive element to see if we need to include it in
   the link.  *PNEEDED is set according to whether this element is
   needed in the link or not.  This is called via
   _bfd_generic_link_add_archive_symbols.  */

static bfd_boolean
coff_link_check_archive_element (bfd *abfd,
				 struct bfd_link_info *info,
				 bfd_boolean *pneeded)
{
  if (! _bfd_coff_get_external_symbols (abfd))
    return FALSE;

  if (! coff_link_check_ar_symbols (abfd, info, pneeded))
    return FALSE;

  if (*pneeded
      && ! coff_link_add_symbols (abfd, info))
    return FALSE;

  if ((! info->keep_memory || ! *pneeded)
      && ! _bfd_coff_free_symbols (abfd))
    return FALSE;

  return TRUE;
}

d318 3
a320 2
coff_link_add_symbols (bfd *abfd,
		       struct bfd_link_info *info)
d349 1
a349 1
  sym_hash = bfd_zalloc (abfd, amt);
d364 1
a364 1
      bfd_coff_swap_sym_in (abfd, esym, &sym);
d567 1
a567 1
			bfd_coff_swap_aux_in (abfd, eaux, sym.n_type,
d569 1
a569 1
					      sym.n_numaux, iaux);
d585 1
d623 1
a623 1
		  stab->used_by_bfd = bfd_zalloc (abfd, amt);
d651 3
a653 2
_bfd_coff_final_link (bfd *abfd,
		      struct bfd_link_info *info)
d795 1
a795 1
      finfo.section_info = bfd_malloc (amt);
d838 2
a839 1
	  finfo.section_info[o->target_index].relocs = bfd_malloc (amt);
d842 2
a843 1
	  finfo.section_info[o->target_index].rel_hashes = bfd_malloc (amt);
d876 1
a876 1
  finfo.internal_syms = bfd_malloc (amt);
d878 1
a878 1
  finfo.sec_ptrs = bfd_malloc (amt);
d880 2
a881 2
  finfo.sym_indices = bfd_malloc (amt);
  finfo.outsyms = bfd_malloc ((max_sym_count + 1) * symesz);
d883 2
a884 2
  finfo.linenos = bfd_malloc (amt);
  finfo.contents = bfd_malloc (max_contents_size);
d886 1
a886 1
  finfo.external_relocs = bfd_malloc (amt);
d890 1
a890 1
      finfo.internal_relocs = bfd_malloc (amt);
d999 2
a1000 2
      bfd_coff_swap_sym_out (abfd, &finfo.last_file,
			     finfo.outsyms);
d1015 2
a1016 1
			       _bfd_coff_write_task_globals, &finfo);
d1024 2
a1025 1
			   _bfd_coff_write_global_sym, &finfo);
d1042 1
a1042 1
      external_relocs = bfd_malloc (amt);
d1067 1
a1067 1
	      bfd_coff_swap_reloc_out (abfd, irel, erel);
d1071 1
a1071 1
	      || (bfd_bwrite (external_relocs,
d1178 1
a1178 1
/* Parse out a -heap <reserved>,<commit> line.  */
d1181 4
a1184 1
dores_com (char *ptr, bfd *output_bfd, int heap)
a1188 1

d1206 3
a1208 2
static char *
get_name (char *ptr, char **dst)
d1219 1
a1219 1
/* Process any magic embedded commands in a section called .drectve.  */
d1222 4
a1225 3
process_embedded_commands (bfd *output_bfd,
			   struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   bfd *abfd)
a1230 1

d1237 1
a1237 2

  if (! bfd_get_section_contents (abfd, sec, copy, (bfd_vma) 0, sec->_raw_size))
a1242 1

d1245 4
a1248 5
      if (s[0]!= '-')
	{
	  s++;
	  continue;
	}
d1254 1
a1259 1

d1261 21
a1281 23
	  s = get_name (s, &name);
	  s = get_name (s, &attribs);

	  while (loop)
	    {
	      switch (*attribs++)
		{
		case 'W':
		  had_write = 1;
		  break;
		case 'R':
		  had_read = 1;
		  break;
		case 'S':
		  had_shared = 1;
		  break;
		case 'X':
		  had_exec = 1;
		  break;
		default:
		  loop = 0;
		}
	    }
d1283 6
a1288 7
	  if (asec)
	    {
	      if (had_exec)
		asec->flags |= SEC_CODE;
	      if (!had_write)
		asec->flags |= SEC_READONLY;
	    }
d1291 3
a1293 2
	s = dores_com (s+5, output_bfd, 1);

d1295 3
a1297 2
	s = dores_com (s+6, output_bfd, 0);

d1308 2
a1309 1
   that symbol.  */
d1312 3
a1314 1
mark_relocs (struct coff_final_link_info *finfo, bfd *input_bfd)
d1352 2
a1353 1
	 skip/don't-skip pass.  */
d1355 3
a1357 1
	finfo->sym_indices[ irel->r_symndx ] = -1;
d1365 3
a1367 1
_bfd_coff_link_input_bfd (struct coff_final_link_info *finfo, bfd *input_bfd)
d1375 2
a1376 2
    (bfd *, struct bfd_link_info *, bfd *, asection *,
     struct internal_reloc *, bfd_boolean *);
d1422 5
a1426 3
  if (coff_data (output_bfd)->pe
      && ! process_embedded_commands (output_bfd, finfo->info, input_bfd))
    return FALSE;
d1428 3
a1430 3
  /* If we are going to perform relocations and also strip/discard some
     symbols then we must make sure that we do not strip/discard those
     symbols that are going to be involved in the relocations.  */
d1435 1
a1435 1
      /* Mark the symbol array as 'not-used'.  */
d1450 1
a1450 1
      bfd_coff_swap_sym_in (input_bfd, esym, isymp);
a1531 1
	  && dont_skip_symbol == 0
d1534 5
a1538 3
          && isym.n_numaux > 0
	  && (*secpp)->output_section == bfd_abs_section_ptr)
	skip = TRUE;
d1623 1
a1623 1
	  mt = bfd_alloc (input_bfd, amt);
d1630 1
a1630 1
	  bfd_coff_swap_aux_in (input_bfd, (esym + isymesz),
d1632 1
a1632 1
				&aux);
d1647 1
a1647 1
	      bfd_coff_swap_sym_in (input_bfd, esl, islp);
d1650 2
a1651 1
	      *epp = bfd_alloc (input_bfd, amt);
d1661 1
a1661 1
	      name_copy = bfd_alloc (input_bfd, amt);
d1676 1
a1676 1
		  bfd_coff_swap_aux_in (input_bfd, (esl + isymesz),
d1678 1
a1678 1
					islp->n_numaux, &eleaux);
d1685 1
d1708 1
a1708 1
	    bfd_release (input_bfd, mt);
d1744 1
a1744 1
		  bfd_release (input_bfd, mt);
d1768 2
a1769 1
	      name = _bfd_coff_internal_syment_name (input_bfd, &isym, NULL);
d1842 1
d1853 5
a1857 5
					     &finfo->last_file,
					     (finfo->outsyms
					      + ((finfo->last_file_index
						  - syment_base)
						 * osymesz)));
d1867 2
a1868 1
					     &finfo->last_file, outsym);
d1888 2
a1889 1
	  bfd_coff_swap_sym_out (output_bfd, &isym, outsym);
d1929 1
a1935 1

d1980 3
a1982 2
		  bfd_coff_swap_aux_in (input_bfd, esym, isymp->n_type,
					isymp->n_sclass, i, isymp->n_numaux, &aux);
d2075 1
a2075 1
			      void *auxout;
d2081 4
a2084 5
			      auxout = (finfo->outsyms
					+ ((finfo->last_bf_index
					    - syment_base)
					   * osymesz));

d2086 1
a2086 1
						     &finfo->last_bf,
d2102 1
a2102 1
						     &finfo->last_bf,
d2106 1
a2106 1
						     outsym);
d2133 1
a2133 1
		  bfd_coff_swap_aux_out (output_bfd, auxp, isymp->n_type,
d2135 1
a2135 1
					 outsym);
d2189 1
a2189 1
	      bfd_coff_swap_lineno_in (input_bfd, eline, &iline);
d2225 4
a2228 3
					    (finfo->outsyms
					     + ((indx - syment_base)
						* osymesz)), &is);
d2233 1
a2233 1
			  void *auxptr;
d2235 3
a2237 3
			  auxptr = (finfo->outsyms
				    + ((indx - syment_base + 1)
				       * osymesz));
d2240 1
a2240 1
						0, is.n_numaux, &ia);
d2245 1
a2245 1
			  bfd_coff_swap_aux_out (output_bfd, &ia,
d2258 2
a2259 1
		  bfd_coff_swap_lineno_out (output_bfd, &iline, oeline);
d2283 4
a2286 4
      bfd_coff_swap_sym_out (output_bfd, &finfo->last_file,
			     (finfo->outsyms
			      + ((finfo->last_file_index - syment_base)
				 * osymesz)));
d2316 4
a2319 2
	/* This section was omitted from the link.  */
	continue;
d2396 1
d2447 1
d2486 5
a2490 3
  if (! finfo->info->keep_memory
      && ! _bfd_coff_free_symbols (input_bfd))
    return FALSE;
d2498 3
a2500 1
_bfd_coff_write_global_sym (struct coff_link_hash_entry *h, void *data)
d2619 1
a2619 1
  bfd_coff_swap_sym_out (output_bfd, &isym, finfo->outsyms);
d2666 1
d2693 1
a2693 1
      bfd_coff_swap_aux_out (output_bfd, auxp, isym.n_type,
d2695 1
a2695 1
			     finfo->outsyms);
d2712 3
a2714 1
_bfd_coff_write_task_globals (struct coff_link_hash_entry *h, void *data)
d2744 5
a2748 4
_bfd_coff_reloc_link_order (bfd *output_bfd,
			    struct coff_final_link_info *finfo,
			    asection *output_section,
			    struct bfd_link_order *link_order)
d2770 1
a2770 1
      buf = bfd_zmalloc (size);
d2800 1
a2800 1
      ok = bfd_set_section_contents (output_bfd, output_section, buf,
d2809 1
d2868 1
d2878 11
a2888 8
_bfd_coff_generic_relocate_section (bfd *output_bfd,
				    struct bfd_link_info *info,
				    bfd *input_bfd,
				    asection *input_section,
				    bfd_byte *contents,
				    struct internal_reloc *relocs,
				    struct internal_syment *syms,
				    asection **sections)
d2930 1
@


1.34.12.5
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@a29 1
#include "safe-ctype.h"
d573 1
a573 1
      asection *stabstr;
d575 4
a578 1
      stabstr = bfd_get_section_by_name (abfd, ".stabstr");
d580 1
a580 9
      if (stabstr != NULL)
	{
	  bfd_size_type string_offset = 0;
	  asection *stab;
	  
	  for (stab = abfd->sections; stab; stab = stab->next)
	    if (strncmp (".stab", stab->name, 5) == 0
		&& (!stab->name[5]
		    || (stab->name[5] == '.' && ISDIGIT (stab->name[6]))))
d583 3
a585 3
	      struct coff_section_tdata *secdata
		= coff_section_data (abfd, stab);
	      
d599 1
a599 2
					     &secdata->stab_info,
					     &string_offset))
d1031 4
a1034 21
	  if (bfd_seek (abfd, o->rel_filepos, SEEK_SET) != 0)
	    goto error_return;
	  if (obj_pe (abfd) && o->reloc_count >= 0xffff)
	    {
	      /* In PE COFF, write the count of relocs as the first
		 reloc.  The header overflow bit will be set
		 elsewhere. */
	      struct internal_reloc incount;
	      bfd_byte *excount = (bfd_byte *)bfd_malloc (relsz);
	      
	      memset (&incount, 0, sizeof (incount));
	      incount.r_vaddr = o->reloc_count + 1;
	      bfd_coff_swap_reloc_out (abfd, (PTR) &incount, (PTR) excount);
	      if (bfd_bwrite (excount, relsz, abfd) != relsz)
		/* We'll leak, but it's an error anyway. */
		goto error_return;
	      free (excount);
	    }
	  if (bfd_bwrite (external_relocs,
			  (bfd_size_type) relsz * o->reloc_count, abfd)
	      != (bfd_size_type) relsz * o->reloc_count)
@


1.34.12.6
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d2568 1
a2568 1
  /* When a weak symbol is not overridden by a strong one,
@


1.33
log
@Replace bfd_alloc/bfd_malloc + memset with bfd_zalloc/bfd_zmalloc
@
text
@d760 4
@


1.32
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d345 1
a345 1
  sym_hash = (struct coff_link_hash_entry **) bfd_alloc (abfd, amt);
a348 2
  memset (sym_hash, 0,
	  (size_t) symcount * sizeof (struct coff_link_hash_entry *));
@


1.32.6.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d345 1
a345 1
  sym_hash = (struct coff_link_hash_entry **) bfd_zalloc (abfd, amt);
d349 2
@


1.32.6.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@a759 4
	  /* In PE COFF, if there are at least 0xffff relocations an
	     extra relocation will be written out to encode the count.  */
	  if (obj_pe (abfd) && o->reloc_count >= 0xffff)
	    rel_filepos += relsz;
@


1.32.6.3
log
@merge from mainline
@
text
@a1324 3
      /* Don't mark relocs in excluded sections.  */
      if (a->output_section == bfd_abs_section_ptr)
	continue;
@


1.32.4.1
log
@merge from trunk
@
text
@d345 1
a345 1
  sym_hash = (struct coff_link_hash_entry **) bfd_zalloc (abfd, amt);
d349 2
@


1.31
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d122 1
a122 1
  ret = (struct coff_link_hash_table *) bfd_alloc (abfd, amt);
d128 1
a128 1
      bfd_release (abfd, ret);
@


1.30
log
@	* aout-encap.c: Fix comment typos.
	* aoutx.h: Likewise.
	* archive.c: Likewise.
	* bout.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mips.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m32r.c: Likewise.
	* libcoff-in.h: Likewise.
	* libecoff.h: Likewise.
	* libxcoff.h: Likewise.
	* nlm32-i386.c: Likewise.
	* pdp11.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* som.h: Likewise.
	* bfd-in2.h: Regenerate.
	* libcoff.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d1008 2
a1009 1
      coff_link_hash_traverse (coff_hash_table (info), _bfd_coff_write_task_globals,
d1017 2
a1018 1
  coff_link_hash_traverse (coff_hash_table (info), _bfd_coff_write_global_sym,
d2502 7
d2524 1
a2556 1
    case bfd_link_hash_warning:
d2710 3
@


1.30.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1008 1
a1008 2
      coff_link_hash_traverse (coff_hash_table (info),
			       _bfd_coff_write_task_globals,
d1016 1
a1016 2
  coff_link_hash_traverse (coff_hash_table (info),
			   _bfd_coff_write_global_sym,
a2499 7
  if (h->root.type == bfd_link_hash_warning)
    {
      h = (struct coff_link_hash_entry *) h->root.u.i.link;
      if (h->root.type == bfd_link_hash_new)
	return true;
    }

a2514 1
    case bfd_link_hash_warning:
d2547 1
a2700 3

  if (h->root.type == bfd_link_hash_warning)
    h = (struct coff_link_hash_entry *) h->root.u.i.link;
@


1.29
log
@	* section.c (struct sec): Remove kept_section.
	(STD_SECTION): Remove kept_section initialisation.
	(bfd_make_section_anyway): Here too.
	* ecoff.c (bfd_debug_section): Remove kept_section initialisation.
	* cofflink.c (_bfd_coff_link_input_bfd): Don't test kept_section.
	* elflink.h (elf_link_input_bfd): Set discarded link-once section
	symbols to zero, and remove all code involved with kept_section
	and tracking section symbol values.
	* bfd-in2.h: Regenerate.
	* configure.in: Bump version number.
	* configure: Regenerate.

	* ldlang.c (section_already_linked): Remove assignment to kept_section.
@
text
@d445 1
a445 1
	     relying on the the linker comdat support to discard
@


1.28
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d1519 1
a1519 2
	 emitted, or which belong to linkonce sections that are going
	 to be discarded.  */
d1525 1
a1525 2
          if ((*secpp)->output_section == bfd_abs_section_ptr
              || (*secpp)->kept_section)
@


1.27
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d538 1
a538 1
  			   bfd_get_filename (abfd));
d2320 1
a2320 1
		bfd_get_filename (input_bfd),
d2898 1
a2898 1
	     bfd_get_filename (input_bfd), symndx);
d3020 1
a3020 1
	     bfd_get_filename (input_bfd),
@


1.26
log
@	* coffcode.h (coff_write_object_contents): Add ATTRIBUTE_UNUSED to
	silence warning.
	* coffgen.c (coff_print_symbol): Fix warnings.
	(coff_find_nearest_line): Likewise.
	* cofflink.c (_bfd_coff_link_input_bfd): Likewise.
	* coff-alpha.c (alpha_convert_external_reloc): Likewise.
	* format.c (bfd_check_format_matches): Likewise.
	(bfd_set_format): Likewise.
	* coff-ia64.c: Add missing prototypes.
	* elf64-alpha.c (struct alpha_elf_link_hash_entry): Make addend
	signed to silence warnings.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_find_reloc_at_ofs): Fix warnings.
	(elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_final_link): Likewise.
	(elf64_alpha_relax_section): Remove redundant assign to info.gotent.
	(elf64_alpha_merge_gots): Add ATTRIBUTE_UNUSED to unused args.
	(elf64_alpha_size_got_sections): Likewise.
	* elfxx-ia64.c: Add missing prototypes.
	(elfNN_ia64_relocate_section): Fix warning.
	(elfNN_ia64_unwind_entry_compare): Make params const.
@
text
@d120 1
d122 1
a122 2
  ret = ((struct coff_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct coff_link_hash_table)));
d328 1
d344 2
a345 4
  sym_hash = ((struct coff_link_hash_entry **)
	      bfd_alloc (abfd,
			 ((size_t) symcount
			  * sizeof (struct coff_link_hash_entry *))));
d566 2
a567 2
					      sym.n_sclass, i, sym.n_numaux,
					      (PTR) iaux);
d620 2
a621 3
		  stab->used_by_bfd =
		    (PTR) bfd_zalloc (abfd,
				      sizeof (struct coff_section_tdata));
d659 5
a663 5
  size_t max_sym_count;
  size_t max_lineno_count;
  size_t max_reloc_count;
  size_t max_output_reloc_count;
  size_t max_contents_size;
d671 1
d787 3
a789 4
      finfo.section_info =
	((struct coff_link_section_info *)
	 bfd_malloc ((abfd->section_count + 1)
		     * sizeof (struct coff_link_section_info)));
d830 2
d833 3
a835 2
	    ((struct internal_reloc *)
	     bfd_malloc (o->reloc_count * sizeof (struct internal_reloc)));
d837 1
a837 3
	    ((struct coff_link_hash_entry **)
	     bfd_malloc (o->reloc_count
		     * sizeof (struct coff_link_hash_entry *)));
d869 9
a877 10
  finfo.internal_syms = ((struct internal_syment *)
			 bfd_malloc (max_sym_count
				     * sizeof (struct internal_syment)));
  finfo.sec_ptrs = (asection **) bfd_malloc (max_sym_count
					     * sizeof (asection *));
  finfo.sym_indices = (long *) bfd_malloc (max_sym_count * sizeof (long));
  finfo.outsyms = ((bfd_byte *)
		   bfd_malloc ((size_t) ((max_sym_count + 1) * symesz)));
  finfo.linenos = (bfd_byte *) bfd_malloc (max_lineno_count
				       * bfd_coff_linesz (abfd));
d879 2
a880 1
  finfo.external_relocs = (bfd_byte *) bfd_malloc (max_reloc_count * relsz);
d882 4
a885 3
    finfo.internal_relocs = ((struct internal_reloc *)
			     bfd_malloc (max_reloc_count
					 * sizeof (struct internal_reloc)));
d990 2
d995 4
a998 5
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + finfo.last_file_index * symesz),
		    SEEK_SET) != 0
	  || bfd_write (finfo.outsyms, symesz, 1, abfd) != symesz)
d1033 2
a1034 2
      external_relocs = ((bfd_byte *)
			 bfd_malloc (max_output_reloc_count * relsz));
d1063 3
a1065 2
	      || bfd_write ((PTR) external_relocs, relsz, o->reloc_count,
			    abfd) != relsz * o->reloc_count)
d1099 4
a1102 4
      if (bfd_seek (abfd,
		    (obj_sym_filepos (abfd)
		     + obj_raw_syment_count (abfd) * symesz),
		    SEEK_SET) != 0)
d1106 3
a1108 3
      bfd_h_put_32 (abfd,
		    _bfd_stringtab_size (finfo.strtab) + STRING_SIZE_SIZE,
		    (bfd_byte *) strbuf);
d1110 1
a1110 1
 #error Change bfd_h_put_32
d1113 2
a1114 1
      if (bfd_write (strbuf, 1, STRING_SIZE_SIZE, abfd) != STRING_SIZE_SIZE)
d1182 1
a1182 1
	pe_data(output_bfd)->pe_opthdr.SizeOfHeapReserve =val;
d1184 1
a1184 1
	pe_data(output_bfd)->pe_opthdr.SizeOfStackReserve =val;
d1188 1
a1188 1
	  int val = strtoul (ptr+1, &ptr, 0);
d1190 1
a1190 1
	    pe_data(output_bfd)->pe_opthdr.SizeOfHeapCommit =val;
d1192 1
a1192 1
	    pe_data(output_bfd)->pe_opthdr.SizeOfStackCommit =val;
d1226 1
a1226 1
  copy = bfd_malloc ((size_t) sec->_raw_size);
d1229 1
a1229 1
  if (! bfd_get_section_contents(abfd, sec, copy, 0, sec->_raw_size))
d1592 1
d1613 2
a1614 3
	  mt = ((struct coff_debug_merge_type *)
		bfd_alloc (input_bfd,
			   sizeof (struct coff_debug_merge_type)));
d1640 1
d1642 1
a1642 2
		      bfd_alloc (input_bfd,
				 sizeof (struct coff_debug_merge_element)));
d1651 2
a1652 2
	      name_copy = (char *) bfd_alloc (input_bfd,
					      strlen (elename) + 1);
d1852 2
d1860 4
a1863 6
		      if (bfd_seek (output_bfd,
				    (obj_sym_filepos (output_bfd)
				     + finfo->last_file_index * osymesz),
				    SEEK_SET) != 0
			  || (bfd_write (outsym, osymesz, 1, output_bfd)
			      != osymesz))
d2085 2
d2098 5
a2102 6
			      if (bfd_seek (output_bfd,
					    (obj_sym_filepos (output_bfd)
					     + finfo->last_bf_index * osymesz),
					    SEEK_SET) != 0
				  || bfd_write (outsym, osymesz, 1,
						output_bfd) != osymesz)
d2150 2
d2167 1
a2167 1
	      || bfd_read (finfo->linenos, linesz, o->lineno_count,
d2255 5
a2259 7
	  if (bfd_seek (output_bfd,
			(o->output_section->line_filepos
			 + o->output_section->lineno_count * linesz),
			SEEK_SET) != 0
	      || (bfd_write (finfo->linenos, 1, oeline - finfo->linenos,
			     output_bfd)
		  != (bfd_size_type) (oeline - finfo->linenos)))
d2262 1
a2262 2
	  o->output_section->lineno_count +=
	    (oeline - finfo->linenos) / linesz;
d2283 7
a2289 6
      if (bfd_seek (output_bfd,
		    obj_sym_filepos (output_bfd) + syment_base * osymesz,
		    SEEK_SET) != 0
	  || (bfd_write (finfo->outsyms, outsym - finfo->outsyms, 1,
			output_bfd)
	      != (bfd_size_type) (outsym - finfo->outsyms)))
d2461 3
d2465 1
a2465 7
					  contents,
                                          (file_ptr)
                                          (o->output_offset *
                                           bfd_octets_per_byte (output_bfd)),
					  (o->_cooked_size != 0
					   ? o->_cooked_size
					   : o->_raw_size)))
d2498 1
d2607 4
a2610 5
  if (bfd_seek (output_bfd,
		(obj_sym_filepos (output_bfd)
		 + obj_raw_syment_count (output_bfd) * symesz),
		SEEK_SET) != 0
      || bfd_write (finfo->outsyms, symesz, 1, output_bfd) != symesz)
d2678 1
a2678 1
			     isym.n_sclass, i, isym.n_numaux,
d2680 1
a2680 1
      if (bfd_write (finfo->outsyms, symesz, 1, output_bfd) != symesz)
d2748 1
d2756 2
a2757 1
				      link_order->u.reloc.p->addend, buf);
d2780 1
d2782 1
a2782 3
				     (file_ptr)
                                     (link_order->offset *
                                      bfd_octets_per_byte (output_bfd)), size);
@


1.25
log
@2001-08-02  Paul Sokolovsky  <paul.sokolovsky@@technologist.com>
        * cofflink.c (coff_link_check_ar_symbols): also search for
        __imp__symbol as well as _symbol.
        * linker.c (_bfd_generic_link_add_archive_symbols): also
        search for __imp__symbol as well as _symbol.
@
text
@d1832 1
a1832 1
		  && finfo->last_file.n_value != (long) output_index)
@


1.24
log
@Skip section symbols from sections being discarded
@
text
@d280 10
@


1.23
log
@Update copyright notices
@
text
@d1504 15
@


1.22
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coff-arm.c: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-pmac.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* elf32.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elf-m10200.c: Likewise.
	* elf-m10300.c: Likewise.
	* elfxx-ia64.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.22.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.21
log
@2000-11-27  Kazu Hirata  <kazu@@hxi.com>

	* coff64-rs6000.c: Fix formatting.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
@
text
@a3020 1

@


1.20
log
@2000-11-27  Philip Blundell  <pb@@futuretv.com>

	* libcoff-in.h (coff_tdata): Add `strings_written' flag.
	(obj_coff_strings_written): New accessor macro for above.
	* libcoff.h: Regenerate.
	* cofflink.c (_bfd_coff_final_link): Say that we wrote the
	strings.
	* coffcode.h (coff_write_object_contents): No need to write out
	the string table if it's already been done.
@
text
@d931 1
a931 1
  
d992 1
a992 1
     static. */
d1164 1
a1164 1
  if (coff_data(output_bfd)->pe) 
d1172 1
a1172 1
      if (ptr[0] == ',') 
d1198 1
a1198 1
			
d1209 1
a1209 1
  if (!sec) 
d1211 1
a1211 1
  
d1213 1
a1213 1
  if (!copy) 
d1215 1
a1215 1
  if (! bfd_get_section_contents(abfd, sec, copy, 0, sec->_raw_size)) 
d1221 1
a1221 1
  for (s = copy;  s < e ; ) 
d1242 1
a1242 1
	    switch (*attribs++) 
d1276 1
a1276 1
      else 
d1286 1
a1286 1
   that symbol. 
d1298 1
a1298 1
  
a1304 1
      
d1317 1
a1317 1
      
d1328 1
a1328 1
      
d1411 2
a1412 2
      memset (indexp, 0, obj_raw_syment_count (input_bfd) * sizeof * indexp); 
       
d1459 1
a1459 1
      
d2407 2
a2408 2
			     loop at the top of this function. */
			  
d2432 3
a2434 3
					  contents, 
                                          (file_ptr) 
                                          (o->output_offset * 
d2574 1
a2574 1
  
d2666 1
a2666 1
   the dirty work, if the symbol we are processing needs conversion. */
d2752 1
a2752 1
				     (file_ptr) 
d2874 1
a2874 1
	{    
a2888 1

d2954 1
a2954 1
	  /* Emit a reloc if the backend thinks it needs it. */
d2963 3
a2965 3
	      long addr = (rel->r_vaddr 
			   - input_section->vma 
			   + input_section->output_offset 
d2977 1
a2977 1
  
@


1.19
log
@2000-11-22  Philip Blundell  <pb@@futuretv.com>

	* cofflink.c (_bfd_coff_generic_relocate_section): Don't object to
	weak undefined symbols.
@
text
@d1105 2
@


1.18
log
@Turn a weak symbol into	an external symbol for a non-shared, non-relocatable
link.
@
text
@d2940 3
@


1.17
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d43 9
d407 1
a407 2
	  if (sym.n_sclass == C_WEAKEXT
	      || (obj_pe (abfd) && sym.n_sclass == C_NT_WEAK))
d1844 2
a1845 6
	     static functions. */

	  if (finfo->info->task_link
	      && (isym.n_sclass == C_EXT
		  || isym.n_sclass == C_WEAKEXT
		  || (obj_pe (input_bfd) && isym.n_sclass == C_NT_WEAK)))
d2555 1
a2555 1
     output during a later pass. */
d2558 3
a2560 6
      if (isym.n_sclass != C_EXT
	  && isym.n_sclass != C_WEAKEXT
	  && (! obj_pe (output_bfd) || isym.n_sclass != C_NT_WEAK))
	{
	  return true;
	}
d2563 8
@


1.16
log
@	* bfd-in.h (bfd_family_coff): Define.
	* bfd-in2.h: Regenerate.
	* coffgen.c (coff_count_linenumbers, coff_symbol_from,
	coff_find_nearest_line): Check COFFness using bfd_family_coff()
	instead of bfd_target_coff_flavour.
	* cofflink.c (_bfd_coff_final_link): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Don't strcmp() target name to
	exclude XCOFF files.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation):
	Likewise.
	* targets.c (enum bfd_flavour): Add bfd_target_xcoff_flavour.
	* xcoff-target.h (TARGET_SYM): Use bfd_target_xcoff_flavour.
	* xcofflink.c (XCOFF_XVECP): Delete.
	(bfd_xcoff_link_record_set, bfd_xcoff_import_symbol,
	bfd_xcoff_export_symbol, bfd_xcoff_link_count_reloc,
	bfd_xcoff_record_link_assignment,
	bfd_xcoff_size_dynamic_sections): Replace XCOFF_XVECP() with
	check for bfd_target_xcoff_flavour.
@
text
@d2204 1
a2204 1
			skipping = false;
@


1.15
log
@2000-03-01  H.J. Lu  <hjl@@gnu.org>

	* aoutx.h (aout_link_input_section_std): Pass "true" to
	the undefined_symbol callback.
	(aout_link_input_section_ext): Likewise.
	* bout.c (get_value): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_conten):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_generic_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elflink.c (_bfd_elf_link_record_dynamic_symbol): Likewise.
	* elflink.h (elf_link_output_extsym): Likewise.
	* pe-mips.c (coff_pe_mips_relocate_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_conten): Likewise.
	* reloc16.c (_bfd_ppc_xcoff_relocate_section): Likewise.

	* elf-hppa.h (elf_hppa_relocate_section): Pass "false" to the
	undefined_symbol callback when building shared library with
	-Bsymbolic and undefined symbols are allowed. Otherwise, pass
	"true".
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	(elf32_mips_get_relocated_section_content): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
@
text
@d897 1
a897 2
	      && (bfd_get_flavour (p->u.indirect.section->owner)
		  == bfd_target_coff_flavour))
@


1.14
log
@Apply Tim walls octest vs bytes patch
@
text
@d2936 1
a2936 1
		      rel->r_vaddr - input_section->vma)))
@


1.13
log
@	* cofflink.c (coff_link_add_symbols): Look for special MSVC string
	constant symbols, and avoid multiple definition errors on them.
@
text
@d2428 4
a2431 1
					  contents, o->output_offset,
d2743 3
a2745 1
				     (file_ptr) link_order->offset, size);
@


1.12
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* cofflink.c (_bfd_coff_link_input_bfd): When writing out a
	symbol, switch on the class when determining whether to modify the
	value.  For PE, don't modify the value of a C_FCN symbol not named
	.bf.
@
text
@d425 40
@


1.11
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* cofflink.c (_bfd_coff_link_input_bfd): If a symbol is stripped,
	don't write out the associated line numbers.
@
text
@d1692 1
a1692 1
	  if (isym.n_scnum > 0)
d1694 62
a1755 7
	      isym.n_scnum = (*secpp)->output_section->target_index;
	      isym.n_value += (*secpp)->output_offset;
	      if (! obj_pe (input_bfd))
		isym.n_value -= (*secpp)->vma;
	      if (! obj_pe (finfo->output_bfd))
		isym.n_value += (*secpp)->output_section->vma;
	    }
a1756 11
	  /* The value of a C_FILE symbol is the symbol index of the
	     next C_FILE symbol.  The value of the last C_FILE symbol
	     is the symbol index to the first external symbol
	     (actually, coff_renumber_symbols does not get this
	     right--it just sets the value of the last C_FILE symbol
	     to zero--and nobody has ever complained about it).  We
	     try to get this right, below, just before we write the
	     symbols out, but in the general case we may have to write
	     the symbol out twice.  */
	  if (isym.n_sclass == C_FILE)
	    {
d1760 2
a1761 1
		  /* We must correct the value of the last C_FILE entry.  */
d1793 1
@


1.10
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* cofflink.c (_bfd_coff_write_global_sym): Handle section symbol
	aux entries.
@
text
@d2028 2
d2051 1
d2053 1
d2073 7
a2079 5
			 which we are stripping.  We should really
			 just discard the line numbers, but that would
			 be a pain because we have already counted
			 them.  */
		      indx = 0;
d2118 2
d2125 6
a2130 1
	      bfd_coff_swap_lineno_out (output_bfd, (PTR) &iline, (PTR) eline);
d2137 3
a2139 2
	      || bfd_write (finfo->linenos, linesz, o->lineno_count,
			    output_bfd) != linesz * o->lineno_count)
d2142 2
a2143 1
	  o->output_section->lineno_count += o->lineno_count;
@


1.9
log
@1999-09-11  Donn Terry  <donn@@interix.com>

	* cofflink.c (coff_link_add_symbols): Don't warn about symbol type
	changes when the base type is unknown.
@
text
@d2480 4
a2483 2
  /* Write out any associated aux entries.  There normally will be
     none.  If there are any, I have no idea how to modify them.  */
d2486 52
a2537 1
      bfd_coff_swap_aux_out (output_bfd, (PTR) (h->aux + i), isym.n_type,
@


1.8
log
@add comment
@
text
@a297 2
#if 0
  /* These aren't needed yet.  */
a300 1
#endif
d452 38
a489 19
	      if (((*sym_hash)->class == C_NULL
		   && (*sym_hash)->type == T_NULL)
		  || sym.n_scnum != 0
		  || (sym.n_value != 0
		      && (*sym_hash)->root.type != bfd_link_hash_defined
		      && (*sym_hash)->root.type != bfd_link_hash_defweak))
		{
		  (*sym_hash)->class = sym.n_sclass;
		  if (sym.n_type != T_NULL)
		    {
		      if ((*sym_hash)->type != T_NULL
			  && (*sym_hash)->type != sym.n_type)
			(*_bfd_error_handler)
			  (_("Warning: type of symbol `%s' changed from %d to %d in %s"),
			   name, (*sym_hash)->type, sym.n_type,
			   bfd_get_filename (abfd));
		      (*sym_hash)->type = sym.n_type;
		    }
		  (*sym_hash)->auxbfd = abfd;
@


1.7
log
@1999-08-18  Donn Terry  <donn@@interix.com>

	* cofflink.c: Move definitions of N_TMASK, et. al., out of
	_bfd_coff_link_input_bfd into top level.
@
text
@d441 5
@


1.6
log
@1999-08-18  Donn Terry  <donn@@interix.com>

	* coff-i386.c (coff_i386_reloc): Handle R_IMAGEBASE.
	(RTYPE2HOWTO): Return NULL if reloc type is out of range.
	(coff_i386_rtype_to_howto): Likewise.
	* coffcode.h (coff_slurp_symbol_table): Change a -2 to N_DEBUG.
	Completely ignore symbols which are all zero.
	(dummy_reloc16_estimate): Add return 0.
	* cofflink.c (_bfd_coff_link_input_bfd): Rename inner scope
	variable copy to name_copy to avoid shadowing outer scope
	variable.
	* libcoff-in.h (coff_data_type): Change raw_syment_count field
	from unsigned int to unsigned long.  Add timestamp field.
	* libcoff.h: Rebuild.

Also comment changes.
@
text
@d43 10
d298 6
d1275 5
a1285 2
  unsigned int n_tmask;
  unsigned int n_btshft;
a1308 7

  n_tmask = coff_data (input_bfd)->local_n_tmask;
  n_btshft = coff_data (input_bfd)->local_n_btshft;

  /* Define macros so that ISFCN, et. al., macros work correctly.  */
#define N_TMASK n_tmask
#define N_BTSHFT n_btshft
@


1.5
log
@	Based on patches from Donn Terry <donn@@interix.com>:
	* coffcode.h (enum coff_symbol_classification): Define.
	(bfd_coff_backend_data): Rename _bfd_coff_sym_is_global to
	_bfd_coff_classify_symbol.  Change return type.
	(bfd_coff_classify_symbol): Rename from bfd_coff_sym_is_global.
	(coff_slurp_symbol_table): Use coff_classify_symbol.
	(coff_classify_symbol): New static function.
	(coff_sym_is_global): Never define.
	(bfd_coff_std_swap_table): Initialize with coff_classify_symbol.
	* cofflink.c (coff_link_check_ar_symbols): Use
	bfd_coff_classify_symbol rather than bfd_coff_sym_is_global.
	(coff_link_add_symbols): Likewise.
	(_bfd_coff_link_input_bfd): Likewise.
	* coff-sh.c (bfd_coff_small_swap_table): Initialize with
	coff_classify_symbol.
	* libcoff.h: Rebuild.
@
text
@d1526 1
a1526 1
	      char *copy;
d1541 3
a1543 2
	      copy = (char *) bfd_alloc (input_bfd, strlen (elename) + 1);
	      if (copy == NULL)
d1545 1
a1545 1
	      strcpy (copy, elename);
d1547 1
a1547 1
	      (*epp)->name = copy;
@


1.4
log
@1999-07-23  Donn Terry  <donn@@interix.com>

	* libcoff-in.h (coff_link_hash_entry): Add coff_link_hash_flags
	field, and define COFF_LINK_HASH_PE_SECTION_SYMBOL.
	* cofflink.c (coff_link_add_symbols): If PE, handle section
	symbols specially.
	* libcoff.h: Rebuild.
@
text
@a227 1
  boolean (*sym_is_global) PARAMS ((bfd *, struct internal_syment *));
a233 2
  sym_is_global = coff_backend_info (abfd)->_bfd_coff_sym_is_global;

d240 1
d244 3
a246 8
      if ((sym.n_sclass == C_EXT
	   || sym.n_sclass == C_WEAKEXT
	   || (obj_pe (abfd) && sym.n_sclass == C_NT_WEAK)
#ifdef C_SYSTEM
	   || sym.n_sclass == C_SYSTEM
#endif
	   || (sym_is_global && (*sym_is_global) (abfd, &sym)))
	  && (sym.n_scnum != 0 || sym.n_value != 0))
a287 1
  boolean (*sym_is_global) PARAMS ((bfd *, struct internal_syment *));
a300 2
  sym_is_global = coff_backend_info (abfd)->_bfd_coff_sym_is_global;

d327 1
d332 2
a333 7
      if (sym.n_sclass == C_EXT
	   || sym.n_sclass == C_WEAKEXT
	   || (obj_pe (abfd) && sym.n_sclass == C_NT_WEAK)
#ifdef C_SYSTEM
	  || sym.n_sclass == C_SYSTEM
#endif
	  || (sym_is_global && (*sym_is_global) (abfd, &sym)))
d357 1
a357 14
	  if (sym.n_scnum == 0)
	    {
	      if (value == 0)
		{
		  flags = 0;
		  section = bfd_und_section_ptr;
		}
	      else
		{
		  flags = BSF_GLOBAL;
		  section = bfd_com_section_ptr;
		}
	    }
	  else
d359 4
d367 16
d477 20
a1258 1
  boolean (*sym_is_global) PARAMS ((bfd *, struct internal_syment *));
a1283 1
  sym_is_global = coff_backend_info (input_bfd)->_bfd_coff_sym_is_global;
d1338 1
d1352 2
a1353 3
      if (isym.n_scnum != 0)
	*secpp = coff_section_from_bfd_index (input_bfd, isym.n_scnum);
      else
d1355 13
a1367 4
	  if (isym.n_value == 0)
	    *secpp = bfd_und_section_ptr;
	  else
	    *secpp = bfd_com_section_ptr;
d1391 1
a1391 7
	  if (isym.n_sclass == C_EXT
	      || isym.n_sclass == C_WEAKEXT
	      || (obj_pe (input_bfd) && isym.n_sclass == C_NT_WEAK)
#ifdef C_SYSTEM
	      || isym.n_sclass == C_SYSTEM
#endif
	      || (sym_is_global && (*sym_is_global) (input_bfd, &isym)))
d1393 5
d1403 1
a1403 1
	      if (! ISFCN (isym.n_type) || isym.n_scnum == 0)
d1405 9
a1413 3
	    }
	  else
	    {
d1418 1
@


1.3
log
@1999-07-21  Philippe De Muyter  <phdm@@macqel.be>

	* cofflink.c (_bfd_coff_generic_relocate_section): Issue an error
	message	and fail if a symbol index is out of range.
@
text
@d354 1
d396 35
a430 5
	  if (! (bfd_coff_link_add_one_symbol
		 (info, abfd, name, flags, section, value,
		  (const char *) NULL, copy, false,
		  (struct bfd_link_hash_entry **) sym_hash)))
	    goto error_return;
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Use EMPTY_HOWTO as appropriate.  Fill in
	structure initializations.  Add casts.
	* reloc.c (EMPTY_HOWTO): Define.
	* bfd-in2.h: Rebuild.
	* coff-h8300.c (h8300_reloc16_extra_cases): Remove useless
	comparisons against 0.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Change
	previous_ibfd_e_flags to unsigned long.
	* vms.h (struct vms_private_data_struct): Change section_count to
	unsigned.
	* vms-gsd.c (_bfd_vms_slurp_gsd): Change psect_idx to unsigned.
	(_bfd_vms_write_gsd): Change symnum to unsigned.
	* vms-hdr.c (_bfd_vms_write_hdr): Change symnum to unsigned.
	* vms-tir.c (etir_sta): Change psect to unsigned.
	(alloc_section): Change idx to unsigned.
	(tir_sta, tir_ctl): Change psect to unsigned.
	(_bfd_vms_write_tir): Change len and before to bfd_size_type.
	* vms.c (priv_section_count): Change to unsigned.
@
text
@d2606 8
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
d1072 1
a1072 1
     struct bfd_link_info *info;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

