head	1.36;
access;
symbols
	sid-snapshot-20180601:1.36
	sid-snapshot-20180501:1.36
	sid-snapshot-20180401:1.36
	sid-snapshot-20180301:1.36
	sid-snapshot-20180201:1.36
	sid-snapshot-20180101:1.36
	sid-snapshot-20171201:1.36
	sid-snapshot-20171101:1.36
	sid-snapshot-20171001:1.36
	sid-snapshot-20170901:1.36
	sid-snapshot-20170801:1.36
	sid-snapshot-20170701:1.36
	sid-snapshot-20170601:1.36
	sid-snapshot-20170501:1.36
	sid-snapshot-20170401:1.36
	sid-snapshot-20170301:1.36
	sid-snapshot-20170201:1.36
	sid-snapshot-20170101:1.36
	sid-snapshot-20161201:1.36
	sid-snapshot-20161101:1.36
	sid-snapshot-20160901:1.36
	sid-snapshot-20160801:1.36
	sid-snapshot-20160701:1.36
	sid-snapshot-20160601:1.36
	sid-snapshot-20160501:1.36
	sid-snapshot-20160401:1.36
	sid-snapshot-20160301:1.36
	sid-snapshot-20160201:1.36
	sid-snapshot-20160101:1.36
	sid-snapshot-20151201:1.36
	sid-snapshot-20151101:1.36
	sid-snapshot-20151001:1.36
	sid-snapshot-20150901:1.36
	sid-snapshot-20150801:1.36
	sid-snapshot-20150701:1.36
	sid-snapshot-20150601:1.36
	sid-snapshot-20150501:1.36
	sid-snapshot-20150401:1.36
	sid-snapshot-20150301:1.36
	sid-snapshot-20150201:1.36
	sid-snapshot-20150101:1.36
	sid-snapshot-20141201:1.36
	sid-snapshot-20141101:1.36
	sid-snapshot-20141001:1.36
	sid-snapshot-20140901:1.36
	sid-snapshot-20140801:1.36
	sid-snapshot-20140701:1.36
	sid-snapshot-20140601:1.36
	sid-snapshot-20140501:1.36
	sid-snapshot-20140401:1.36
	sid-snapshot-20140301:1.36
	sid-snapshot-20140201:1.36
	sid-snapshot-20140101:1.36
	sid-snapshot-20131201:1.36
	sid-snapshot-20131101:1.36
	sid-snapshot-20131001:1.36
	binutils-2_24-branch:1.36.0.2
	binutils-2_24-branchpoint:1.36
	binutils-2_21_1:1.27.4.1
	sid-snapshot-20130901:1.36
	gdb_7_6_1-2013-08-30-release:1.35
	sid-snapshot-20130801:1.35
	sid-snapshot-20130701:1.35
	sid-snapshot-20130601:1.35
	sid-snapshot-20130501:1.35
	gdb_7_6-2013-04-26-release:1.35
	sid-snapshot-20130401:1.35
	binutils-2_23_2:1.33.4.1
	gdb_7_6-branch:1.35.0.2
	gdb_7_6-2013-03-12-branchpoint:1.35
	sid-snapshot-20130301:1.35
	sid-snapshot-20130201:1.35
	sid-snapshot-20130101:1.34
	sid-snapshot-20121201:1.34
	gdb_7_5_1-2012-11-29-release:1.33
	binutils-2_23_1:1.33
	sid-snapshot-20121101:1.33
	binutils-2_23:1.33
	sid-snapshot-20121001:1.33
	sid-snapshot-20120901:1.33
	gdb_7_5-2012-08-17-release:1.33
	sid-snapshot-20120801:1.33
	binutils-2_23-branch:1.33.0.4
	binutils-2_23-branchpoint:1.33
	gdb_7_5-branch:1.33.0.2
	gdb_7_5-2012-07-18-branchpoint:1.33
	sid-snapshot-20120701:1.33
	sid-snapshot-20120601:1.33
	sid-snapshot-20120501:1.33
	binutils-2_22_branch:1.29.0.6
	gdb_7_4_1-2012-04-26-release:1.29
	sid-snapshot-20120401:1.33
	sid-snapshot-20120301:1.33
	sid-snapshot-20120201:1.32
	gdb_7_4-2012-01-24-release:1.29
	sid-snapshot-20120101:1.29
	gdb_7_4-branch:1.29.0.4
	gdb_7_4-2011-12-13-branchpoint:1.29
	sid-snapshot-20111201:1.29
	binutils-2_22:1.29
	sid-snapshot-20111101:1.29
	sid-snapshot-20111001:1.29
	binutils-2_22-branch:1.29.0.2
	binutils-2_22-branchpoint:1.29
	gdb_7_3_1-2011-09-04-release:1.27
	sid-snapshot-20110901:1.29
	sid-snapshot-20110801:1.29
	gdb_7_3-2011-07-26-release:1.27
	sid-snapshot-20110701:1.29
	sid-snapshot-20110601:1.28
	sid-snapshot-20110501:1.28
	gdb_7_3-branch:1.27.0.6
	gdb_7_3-2011-04-01-branchpoint:1.27
	sid-snapshot-20110401:1.27
	sid-snapshot-20110301:1.27
	sid-snapshot-20110201:1.27
	sid-snapshot-20110101:1.27
	binutils-2_21:1.27
	sid-snapshot-20101201:1.27
	binutils-2_21-branch:1.27.0.4
	binutils-2_21-branchpoint:1.27
	sid-snapshot-20101101:1.27
	sid-snapshot-20101001:1.27
	binutils-2_20_1:1.24.2.1
	gdb_7_2-2010-09-02-release:1.27
	sid-snapshot-20100901:1.27
	sid-snapshot-20100801:1.27
	gdb_7_2-branch:1.27.0.2
	gdb_7_2-2010-07-07-branchpoint:1.27
	sid-snapshot-20100701:1.27
	sid-snapshot-20100601:1.26
	sid-snapshot-20100501:1.25
	sid-snapshot-20100401:1.25
	gdb_7_1-2010-03-18-release:1.25
	sid-snapshot-20100301:1.25
	gdb_7_1-branch:1.25.0.4
	gdb_7_1-2010-02-18-branchpoint:1.25
	sid-snapshot-20100201:1.25
	sid-snapshot-20100101:1.25
	gdb_7_0_1-2009-12-22-release:1.25
	sid-snapshot-20091201:1.25
	sid-snapshot-20091101:1.25
	binutils-2_20:1.24.2.1
	gdb_7_0-2009-10-06-release:1.25
	sid-snapshot-20091001:1.25
	gdb_7_0-branch:1.25.0.2
	gdb_7_0-2009-09-16-branchpoint:1.25
	arc-sim-20090309:1.17
	binutils-arc-20081103-branch:1.17.0.18
	binutils-arc-20081103-branchpoint:1.17
	binutils-2_20-branch:1.24.0.2
	binutils-2_20-branchpoint:1.24
	sid-snapshot-20090901:1.23
	sid-snapshot-20090801:1.23
	msnyder-checkpoint-072509-branch:1.23.0.2
	msnyder-checkpoint-072509-branchpoint:1.23
	sid-snapshot-20090701:1.22
	dje-cgen-play1-branch:1.22.0.2
	dje-cgen-play1-branchpoint:1.22
	sid-snapshot-20090601:1.21
	sid-snapshot-20090501:1.20
	sid-snapshot-20090401:1.20
	arc-20081103-branch:1.17.0.16
	arc-20081103-branchpoint:1.17
	arc-insight_6_8-branch:1.17.0.14
	arc-insight_6_8-branchpoint:1.17
	insight_6_8-branch:1.17.0.12
	insight_6_8-branchpoint:1.17
	sid-snapshot-20090301:1.20
	binutils-2_19_1:1.17
	sid-snapshot-20090201:1.19
	sid-snapshot-20090101:1.19
	reverse-20081226-branch:1.19.0.4
	reverse-20081226-branchpoint:1.19
	sid-snapshot-20081201:1.19
	multiprocess-20081120-branch:1.19.0.2
	multiprocess-20081120-branchpoint:1.19
	sid-snapshot-20081101:1.17
	binutils-2_19:1.17
	sid-snapshot-20081001:1.17
	reverse-20080930-branch:1.17.0.10
	reverse-20080930-branchpoint:1.17
	binutils-2_19-branch:1.17.0.8
	binutils-2_19-branchpoint:1.17
	sid-snapshot-20080901:1.17
	sid-snapshot-20080801:1.17
	reverse-20080717-branch:1.17.0.6
	reverse-20080717-branchpoint:1.17
	sid-snapshot-20080701:1.17
	msnyder-reverse-20080609-branch:1.17.0.4
	msnyder-reverse-20080609-branchpoint:1.17
	drow-reverse-20070409-branch:1.14.0.2
	drow-reverse-20070409-branchpoint:1.14
	sid-snapshot-20080601:1.17
	sid-snapshot-20080501:1.17
	sid-snapshot-20080403:1.17
	sid-snapshot-20080401:1.17
	gdb_6_8-2008-03-27-release:1.17
	sid-snapshot-20080301:1.17
	gdb_6_8-branch:1.17.0.2
	gdb_6_8-2008-02-26-branchpoint:1.17
	sid-snapshot-20080201:1.16
	sid-snapshot-20080101:1.16
	sid-snapshot-20071201:1.16
	sid-snapshot-20071101:1.16
	gdb_6_7_1-2007-10-29-release:1.16
	gdb_6_7-2007-10-10-release:1.16
	sid-snapshot-20071001:1.16
	gdb_6_7-branch:1.16.0.4
	gdb_6_7-2007-09-07-branchpoint:1.16
	binutils-2_18:1.16
	binutils-2_18-branch:1.16.0.2
	binutils-2_18-branchpoint:1.16
	insight_6_6-20070208-release:1.12
	binutils-csl-coldfire-4_1-32:1.12
	binutils-csl-sourcerygxx-4_1-32:1.12
	gdb_6_6-2006-12-18-release:1.12
	binutils-csl-innovasic-fido-3_4_4-33:1.12
	binutils-csl-sourcerygxx-3_4_4-32:1.9
	binutils-csl-coldfire-4_1-30:1.12
	binutils-csl-sourcerygxx-4_1-30:1.12
	binutils-csl-coldfire-4_1-28:1.12
	binutils-csl-sourcerygxx-4_1-29:1.12
	binutils-csl-sourcerygxx-4_1-28:1.12
	gdb_6_6-branch:1.12.0.26
	gdb_6_6-2006-11-15-branchpoint:1.12
	binutils-csl-arm-2006q3-27:1.12
	binutils-csl-sourcerygxx-4_1-27:1.12
	binutils-csl-arm-2006q3-26:1.12
	binutils-csl-sourcerygxx-4_1-26:1.12
	binutils-csl-sourcerygxx-4_1-25:1.12
	binutils-csl-sourcerygxx-4_1-24:1.12
	binutils-csl-sourcerygxx-4_1-23:1.12
	insight_6_5-20061003-release:1.12
	gdb-csl-symbian-6_4_50_20060226-12:1.12
	binutils-csl-sourcerygxx-4_1-21:1.12
	binutils-csl-arm-2006q3-21:1.12
	binutils-csl-sourcerygxx-4_1-22:1.12
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.12
	binutils-csl-sourcerygxx-4_1-20:1.12
	binutils-csl-arm-2006q3-19:1.12
	binutils-csl-sourcerygxx-4_1-19:1.12
	binutils-csl-sourcerygxx-4_1-18:1.12
	binutils-csl-renesas-4_1-9:1.12
	gdb-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-sourcerygxx-3_4_4-25:1.9
	nickrob-async-20060828-mergepoint:1.12
	gdb-csl-symbian-6_4_50_20060226-11:1.12
	binutils-csl-renesas-4_1-8:1.12
	binutils-csl-renesas-4_1-7:1.12
	binutils-csl-renesas-4_1-6:1.12
	gdb-csl-sourcerygxx-4_1-17:1.12
	binutils-csl-sourcerygxx-4_1-17:1.12
	gdb-csl-20060226-branch-local-2:1.12
	gdb-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-14:1.12
	binutils-csl-sourcerygxx-4_1-15:1.12
	gdb-csl-sourcerygxx-4_1-13:1.12
	binutils-csl-sourcerygxx-4_1-13:1.12
	binutils-2_17:1.12
	gdb-csl-sourcerygxx-4_1-12:1.12
	binutils-csl-sourcerygxx-4_1-12:1.12
	gdb-csl-sourcerygxx-3_4_4-21:1.12
	binutils-csl-sourcerygxx-3_4_4-21:1.12
	gdb_6_5-20060621-release:1.12
	binutils-csl-wrs-linux-3_4_4-24:1.9
	binutils-csl-wrs-linux-3_4_4-23:1.9
	gdb-csl-sourcerygxx-4_1-9:1.12
	binutils-csl-sourcerygxx-4_1-9:1.12
	gdb-csl-sourcerygxx-4_1-8:1.12
	binutils-csl-sourcerygxx-4_1-8:1.12
	gdb-csl-sourcerygxx-4_1-7:1.12
	binutils-csl-sourcerygxx-4_1-7:1.12
	gdb-csl-arm-2006q1-6:1.12
	binutils-csl-arm-2006q1-6:1.12
	gdb-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-sourcerygxx-4_1-6:1.12
	binutils-csl-wrs-linux-3_4_4-22:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.12
	gdb-csl-symbian-6_4_50_20060226-9:1.12
	gdb-csl-symbian-6_4_50_20060226-8:1.12
	gdb-csl-coldfire-4_1-11:1.12
	binutils-csl-coldfire-4_1-11:1.12
	gdb-csl-sourcerygxx-3_4_4-19:1.12
	binutils-csl-sourcerygxx-3_4_4-19:1.12
	gdb-csl-coldfire-4_1-10:1.12
	gdb_6_5-branch:1.12.0.24
	gdb_6_5-2006-05-14-branchpoint:1.12
	binutils-csl-coldfire-4_1-10:1.12
	gdb-csl-sourcerygxx-4_1-5:1.12
	binutils-csl-sourcerygxx-4_1-5:1.12
	nickrob-async-20060513-branch:1.12.0.22
	nickrob-async-20060513-branchpoint:1.12
	gdb-csl-sourcerygxx-4_1-4:1.12
	binutils-csl-sourcerygxx-4_1-4:1.12
	msnyder-reverse-20060502-branch:1.12.0.20
	msnyder-reverse-20060502-branchpoint:1.12
	binutils-csl-wrs-linux-3_4_4-21:1.9
	gdb-csl-morpho-4_1-4:1.12
	binutils-csl-morpho-4_1-4:1.12
	gdb-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-sourcerygxx-3_4_4-17:1.12
	binutils-csl-wrs-linux-3_4_4-20:1.9
	readline_5_1-import-branch:1.12.0.18
	readline_5_1-import-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.12
	binutils-2_17-branch:1.12.0.16
	binutils-2_17-branchpoint:1.12
	gdb-csl-symbian-20060226-branch:1.12.0.14
	gdb-csl-symbian-20060226-branchpoint:1.12
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.12
	msnyder-reverse-20060331-branch:1.12.0.12
	msnyder-reverse-20060331-branchpoint:1.12
	binutils-csl-2_17-branch:1.12.0.10
	binutils-csl-2_17-branchpoint:1.12
	gdb-csl-available-20060303-branch:1.12.0.8
	gdb-csl-available-20060303-branchpoint:1.12
	gdb-csl-20060226-branch:1.12.0.6
	gdb-csl-20060226-branchpoint:1.12
	gdb_6_4-20051202-release:1.11.6.1
	msnyder-fork-checkpoint-branch:1.12.0.4
	msnyder-fork-checkpoint-branchpoint:1.12
	gdb-csl-gxxpro-6_3-branch:1.12.0.2
	gdb-csl-gxxpro-6_3-branchpoint:1.12
	gdb_6_4-branch:1.11.0.6
	gdb_6_4-2005-11-01-branchpoint:1.11
	gdb-csl-arm-20051020-branch:1.11.0.4
	gdb-csl-arm-20051020-branchpoint:1.11
	binutils-csl-gxxpro-3_4-branch:1.9.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.9
	binutils-2_16_1:1.9
	msnyder-tracepoint-checkpoint-branch:1.11.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.11
	gdb-csl-arm-20050325-2005-q1b:1.9
	binutils-csl-arm-2005q1b:1.9
	binutils-2_16:1.9
	gdb-csl-arm-20050325-2005-q1a:1.9
	binutils-csl-arm-2005q1a:1.9
	csl-arm-20050325-branch:1.9.0.6
	csl-arm-20050325-branchpoint:1.9
	binutils-csl-arm-2005q1-branch:1.9.0.4
	binutils-csl-arm-2005q1-branchpoint:1.9
	binutils-2_16-branch:1.9.0.2
	binutils-2_16-branchpoint:1.9
	csl-arm-2004-q3d:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.4
	gdb_6_3-20041019-branchpoint:1.7
	csl-arm-2004-q3:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.6
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.5
	binutils-2_15:1.5
	binutils-2_15-branchpoint:1.5
	csl-arm-2004-q1a:1.6
	csl-arm-2004-q1:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.12
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.10
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.6
	drow_intercu-20040221-branchpoint:1.5
	binutils-2_15-branch:1.5.0.4
	cagney_bfdfile-20040213-branch:1.5.0.2
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	cagney_bigcore-20040122-branch:1.4.0.4
	cagney_bigcore-20040122-branchpoint:1.4
	drow-cplus-merge-20040113:1.4
	csl-arm-2003-q4:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-branch:1.4.0.2
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.1
	kettenis_sparc-20030918-branch:1.2.0.6
	kettenis_sparc-20030918-branchpoint:1.2
	carlton_dictionary-20030917-merge:1.2
	ezannoni_pie-20030916-branchpoint:1.2
	ezannoni_pie-20030916-branch:1.2.0.4
	cagney_x86i386-20030821-branch:1.2.0.2
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.1
	gdb_6_0-branch:1.1.0.38
	gdb_6_0-2003-06-23-branchpoint:1.1
	jimb-ppc64-linux-20030613-branch:1.1.0.36
	jimb-ppc64-linux-20030613-branchpoint:1.1
	binutils-2_14:1.1
	cagney_convert-20030606-branch:1.1.0.34
	cagney_convert-20030606-branchpoint:1.1
	cagney_writestrings-20030508-branch:1.1.0.32
	cagney_writestrings-20030508-branchpoint:1.1
	jimb-ppc64-linux-20030528-branch:1.1.0.30
	jimb-ppc64-linux-20030528-branchpoint:1.1
	carlton_dictionary-20030523-merge:1.1
	cagney_fileio-20030521-branch:1.1.0.28
	cagney_fileio-20030521-branchpoint:1.1
	kettenis_i386newframe-20030517-mergepoint:1.1
	jimb-ppc64-linux-20030509-branch:1.1.0.26
	jimb-ppc64-linux-20030509-branchpoint:1.1
	kettenis_i386newframe-20030504-mergepoint:1.1
	carlton_dictionary-20030430-merge:1.1
	binutils-2_14-branch:1.1.0.24
	binutils-2_14-branchpoint:1.1
	kettenis_i386newframe-20030419-branch:1.1.0.22
	kettenis_i386newframe-20030419-branchpoint:1.1
	carlton_dictionary-20030416-merge:1.1
	cagney_frameaddr-20030409-mergepoint:1.1
	kettenis_i386newframe-20030406-branch:1.1.0.20
	kettenis_i386newframe-20030406-branchpoint:1.1
	cagney_frameaddr-20030403-branchpoint:1.1
	cagney_frameaddr-20030403-branch:1.1.0.18
	cagney_framebase-20030330-mergepoint:1.1
	cagney_framebase-20030326-branch:1.1.0.16
	cagney_framebase-20030326-branchpoint:1.1
	cagney_lazyid-20030317-branch:1.1.0.14
	cagney_lazyid-20030317-branchpoint:1.1
	kettenis-i386newframe-20030316-mergepoint:1.1
	offbyone-20030313-branch:1.1.0.12
	offbyone-20030313-branchpoint:1.1
	kettenis-i386newframe-20030308-branch:1.1.0.10
	kettenis-i386newframe-20030308-branchpoint:1.1
	carlton_dictionary-20030305-merge:1.1
	cagney_offbyone-20030303-branch:1.1.0.8
	cagney_offbyone-20030303-branchpoint:1.1
	carlton_dictionary-20030207-merge:1.1
	interps-20030202-branch:1.1.0.6
	interps-20030202-branchpoint:1.1
	cagney-unwind-20030108-branch:1.1.0.4
	cagney-unwind-20030108-branchpoint:1.1
	carlton_dictionary-branch:1.1.0.2
	carlton_dictionary-20021223-merge:1.1
	binutils_latest_snapshot:1.36;
locks; strict;
comment	@ * @;


1.36
date	2013.08.23.07.54.17;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2013.01.14.13.14.08;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2012.11.07.00.55.04;	author hjl;	state Exp;
branches;
next	1.33;

1.33
date	2012.02.02.15.36.44;	author gingold;	state Exp;
branches
	1.33.4.1;
next	1.32;

1.32
date	2012.01.20.14.42.57;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.10.11.51.09;	author gingold;	state Exp;
branches;
next	1.30;

1.30
date	2012.01.06.11.43.51;	author gingold;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.27.08.40.59;	author gingold;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.28.20.36.50;	author tromey;	state Exp;
branches;
next	1.27;

1.27
date	2010.06.09.13.28.31;	author gingold;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2010.05.26.07.37.36;	author gingold;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.09.21.38.57;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.02.07.18.35;	author amodra;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2009.07.10.18.38.27;	author hjl;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.11.00.41.03;	author ppluzhnikov;	state Exp;
branches;
next	1.21;

1.21
date	2009.05.24.11.47.27;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2009.02.23.09.28.42;	author gingold;	state Exp;
branches;
next	1.19;

1.19
date	2008.11.14.09.57.33;	author gingold;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.06.14.10.45;	author tromey;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.20.17.42.35;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.03.14.26.39;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.26.14.46.55;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2006.12.14.02.59.25;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.20.02.09.56;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2005.11.03.16.06.10;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.04.15.53.01;	author nickc;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	2005.05.04.07.19.20;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.03.11.40.56;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.31.23.13.15;	author bje;	state Exp;
branches;
next	1.7;

1.7
date	2004.05.21.13.12.27;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2004.04.21.17.05.11;	author cagney;	state Exp;
branches;
next	1.5;

1.5
date	2004.02.11.23.23.20;	author cagney;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2003.11.24.18.06.39;	author kazu;	state Exp;
branches
	1.4.2.1
	1.4.4.1;
next	1.3;

1.3
date	2003.11.04.11.30.54;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.29.10.06.39;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.18.16.37.52;	author kdienes;	state Exp;
branches
	1.1.2.1;
next	;

1.33.4.1
date	2013.01.21.13.48.35;	author amodra;	state Exp;
branches;
next	;

1.27.4.1
date	2011.05.29.04.50.58;	author amodra;	state Exp;
branches;
next	;

1.24.2.1
date	2009.09.09.21.40.18;	author nickc;	state Exp;
branches;
next	;

1.11.6.1
date	2005.11.03.19.53.30;	author drow;	state Exp;
branches;
next	;

1.5.6.1
date	2004.09.16.17.00.12;	author drow;	state Exp;
branches;
next	;

1.4.2.1
date	2003.12.14.20.26.34;	author drow;	state Exp;
branches;
next	;

1.4.4.1
date	2004.01.22.17.03.42;	author cagney;	state Exp;
branches;
next	;

1.1.2.1
date	2002.12.23.19.37.23;	author carlton;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.08.05.17.12.43;	author carlton;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.11.11.23.50.07;	author carlton;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.12.15.23.59.12;	author carlton;	state Exp;
branches;
next	;


desc
@@


1.36
log
@	PR binutils/15834
	Fix typos:
---
 bfd/bfdio.c                                  |  2 +-
 bfd/elf32-spu.c                              |  2 +-
 bfd/elfnn-aarch64.c                          |  2 +-
 binutils/od-xcoff.c                          |  2 +-
 config/tcl.m4                                |  2 +-
 gas/config/tc-ia64.c                         |  2 +-
 gas/config/tc-sparc.c                        |  2 +-
 gas/config/tc-z80.c                          | 12 ++++++------
 gas/doc/c-i386.texi                          |  6 +++---
 gas/doc/c-m32r.texi                          |  2 +-
 gas/testsuite/gas/d10v/instruction_packing.d |  2 +-
 gas/testsuite/gas/z80/atend.d                |  2 +-
 gold/object.h                                |  2 +-
 include/gdb/remote-sim.h                     |  2 +-
 include/opcode/ChangeLog                     |  2 +-
 include/opcode/i960.h                        |  2 +-
 ld/testsuite/ld-mips-elf/mips16-pic-1.inc    |  2 +-
 opcodes/aarch64-asm.c                        |  2 +-
 opcodes/aarch64-dis.c                        |  2 +-
 opcodes/msp430-dis.c                         |  2 +-
@
text
@/* Low-level I/O routines for BFDs.

   Copyright 1990-2013 Free Software Foundation, Inc.

   Written by Cygnus Support.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include <limits.h>
#include "bfd.h"
#include "libbfd.h"

#ifndef S_IXUSR
#define S_IXUSR 0100    /* Execute by owner.  */
#endif
#ifndef S_IXGRP
#define S_IXGRP 0010    /* Execute by group.  */
#endif
#ifndef S_IXOTH
#define S_IXOTH 0001    /* Execute by others.  */
#endif

#ifndef FD_CLOEXEC
#define FD_CLOEXEC 1
#endif

file_ptr
real_ftell (FILE *file)
{
#if defined (HAVE_FTELLO64)
  return ftello64 (file);
#elif defined (HAVE_FTELLO)
  return ftello (file);
#else
  return ftell (file);
#endif
}

int
real_fseek (FILE *file, file_ptr offset, int whence)
{
#if defined (HAVE_FSEEKO64)
  return fseeko64 (file, offset, whence);
#elif defined (HAVE_FSEEKO)
  return fseeko (file, offset, whence);
#else
  return fseek (file, offset, whence);
#endif
}

/* Mark FILE as close-on-exec.  Return FILE.  FILE may be NULL, in
   which case nothing is done.  */
static FILE *
close_on_exec (FILE *file)
{
#if defined (HAVE_FILENO) && defined (F_GETFD)
  if (file)
    {
      int fd = fileno (file);
      int old = fcntl (fd, F_GETFD, 0);
      if (old >= 0)
	fcntl (fd, F_SETFD, old | FD_CLOEXEC);
    }
#endif
  return file;
}

FILE *
real_fopen (const char *filename, const char *modes)
{
#ifdef VMS
  char *vms_attr;

  /* On VMS, fopen allows file attributes as optional arguments.
     We need to use them but we'd better to use the common prototype.
     In fopen-vms.h, they are separated from the mode with a comma.
     Split here.  */
  vms_attr = strchr (modes, ',');
  if (vms_attr == NULL)
    {
      /* No attributes.  */
      return close_on_exec (fopen (filename, modes));
    }
  else
    {
      /* Attributes found.  Split.  */
      size_t modes_len = strlen (modes) + 1;
      char attrs[modes_len + 1];
      char *at[3];
      int i;

      memcpy (attrs, modes, modes_len);
      at[0] = attrs;
      for (i = 0; i < 2; i++)
	{
	  at[i + 1] = strchr (at[i], ',');
	  BFD_ASSERT (at[i + 1] != NULL);
	  *(at[i + 1]++) = 0; /* Replace ',' with a nul, and skip it.  */
	}
      return close_on_exec (fopen (filename, at[0], at[1], at[2]));
    }
#else /* !VMS */
#if defined (HAVE_FOPEN64)
  return close_on_exec (fopen64 (filename, modes));
#else
  return close_on_exec (fopen (filename, modes));
#endif
#endif /* !VMS */
}

/*
INTERNAL_DEFINITION
	struct bfd_iovec

DESCRIPTION

	The <<struct bfd_iovec>> contains the internal file I/O class.
	Each <<BFD>> has an instance of this class and all file I/O is
	routed through it (it is assumed that the instance implements
	all methods listed below).

.struct bfd_iovec
.{
.  {* To avoid problems with macros, a "b" rather than "f"
.     prefix is prepended to each method name.  *}
.  {* Attempt to read/write NBYTES on ABFD's IOSTREAM storing/fetching
.     bytes starting at PTR.  Return the number of bytes actually
.     transfered (a read past end-of-file returns less than NBYTES),
.     or -1 (setting <<bfd_error>>) if an error occurs.  *}
.  file_ptr (*bread) (struct bfd *abfd, void *ptr, file_ptr nbytes);
.  file_ptr (*bwrite) (struct bfd *abfd, const void *ptr,
.                      file_ptr nbytes);
.  {* Return the current IOSTREAM file offset, or -1 (setting <<bfd_error>>
.     if an error occurs.  *}
.  file_ptr (*btell) (struct bfd *abfd);
.  {* For the following, on successful completion a value of 0 is returned.
.     Otherwise, a value of -1 is returned (and  <<bfd_error>> is set).  *}
.  int (*bseek) (struct bfd *abfd, file_ptr offset, int whence);
.  int (*bclose) (struct bfd *abfd);
.  int (*bflush) (struct bfd *abfd);
.  int (*bstat) (struct bfd *abfd, struct stat *sb);
.  {* Mmap a part of the files. ADDR, LEN, PROT, FLAGS and OFFSET are the usual
.     mmap parameter, except that LEN and OFFSET do not need to be page
.     aligned.  Returns (void *)-1 on failure, mmapped address on success.
.     Also write in MAP_ADDR the address of the page aligned buffer and in
.     MAP_LEN the size mapped (a page multiple).  Use unmap with MAP_ADDR and
.     MAP_LEN to unmap.  *}
.  void *(*bmmap) (struct bfd *abfd, void *addr, bfd_size_type len,
.                  int prot, int flags, file_ptr offset,
.                  void **map_addr, bfd_size_type *map_len);
.};

.extern const struct bfd_iovec _bfd_memory_iovec;

*/


/* Return value is amount read.  */

bfd_size_type
bfd_bread (void *ptr, bfd_size_type size, bfd *abfd)
{
  size_t nread;

  /* If this is an archive element, don't read past the end of
     this element.  */
  if (abfd->arelt_data != NULL)
    {
      bfd_size_type maxbytes = arelt_size (abfd);

      if (abfd->where + size > maxbytes)
        {
          if (abfd->where >= maxbytes)
            return 0;
          size = maxbytes - abfd->where;
        }
    }

  if (abfd->iovec)
    nread = abfd->iovec->bread (abfd, ptr, size);
  else
    nread = 0;
  if (nread != (size_t) -1)
    abfd->where += nread;

  return nread;
}

bfd_size_type
bfd_bwrite (const void *ptr, bfd_size_type size, bfd *abfd)
{
  size_t nwrote;

  if (abfd->iovec)
    nwrote = abfd->iovec->bwrite (abfd, ptr, size);
  else
    nwrote = 0;

  if (nwrote != (size_t) -1)
    abfd->where += nwrote;
  if (nwrote != size)
    {
#ifdef ENOSPC
      errno = ENOSPC;
#endif
      bfd_set_error (bfd_error_system_call);
    }
  return nwrote;
}

file_ptr
bfd_tell (bfd *abfd)
{
  file_ptr ptr;

  if (abfd->iovec)
    {
      bfd *parent_bfd = abfd;
      ptr = abfd->iovec->btell (abfd);

      while (parent_bfd->my_archive != NULL)
	{
	  ptr -= parent_bfd->origin;
	  parent_bfd = parent_bfd->my_archive;
	}
    }
  else
    ptr = 0;

  abfd->where = ptr;
  return ptr;
}

int
bfd_flush (bfd *abfd)
{
  if (abfd->iovec)
    return abfd->iovec->bflush (abfd);
  return 0;
}

/* Returns 0 for success, negative value for failure (in which case
   bfd_get_error can retrieve the error code).  */
int
bfd_stat (bfd *abfd, struct stat *statbuf)
{
  int result;

  if (abfd->iovec)
    result = abfd->iovec->bstat (abfd, statbuf);
  else
    result = -1;

  if (result < 0)
    bfd_set_error (bfd_error_system_call);
  return result;
}

/* Returns 0 for success, nonzero for failure (in which case bfd_get_error
   can retrieve the error code).  */

int
bfd_seek (bfd *abfd, file_ptr position, int direction)
{
  int result;
  file_ptr file_position;
  /* For the time being, a BFD may not seek to it's end.  The problem
     is that we don't easily have a way to recognize the end of an
     element in an archive.  */

  BFD_ASSERT (direction == SEEK_SET || direction == SEEK_CUR);

  if (direction == SEEK_CUR && position == 0)
    return 0;

  if (abfd->format != bfd_archive && abfd->my_archive == 0)
    {
      if (direction == SEEK_SET && (bfd_vma) position == abfd->where)
	return 0;
    }
  else
    {
      /* We need something smarter to optimize access to archives.
	 Currently, anything inside an archive is read via the file
	 handle for the archive.  Which means that a bfd_seek on one
	 component affects the `current position' in the archive, as
	 well as in any other component.

	 It might be sufficient to put a spike through the cache
	 abstraction, and look to the archive for the file position,
	 but I think we should try for something cleaner.

	 In the meantime, no optimization for archives.  */
    }

  file_position = position;
  if (direction == SEEK_SET)
    {
      bfd *parent_bfd = abfd;

      while (parent_bfd->my_archive != NULL)
        {
          file_position += parent_bfd->origin;
          parent_bfd = parent_bfd->my_archive;
        }
    }

  if (abfd->iovec)
    result = abfd->iovec->bseek (abfd, file_position, direction);
  else
    result = -1;

  if (result != 0)
    {
      int hold_errno = errno;

      /* Force redetermination of `where' field.  */
      bfd_tell (abfd);

      /* An EINVAL error probably means that the file offset was
         absurd.  */
      if (hold_errno == EINVAL)
	bfd_set_error (bfd_error_file_truncated);
      else
	{
	  bfd_set_error (bfd_error_system_call);
	  errno = hold_errno;
	}
    }
  else
    {
      /* Adjust `where' field.  */
      if (direction == SEEK_SET)
	abfd->where = position;
      else
	abfd->where += position;
    }
  return result;
}

/*
FUNCTION
	bfd_get_mtime

SYNOPSIS
	long bfd_get_mtime (bfd *abfd);

DESCRIPTION
	Return the file modification time (as read from the file system, or
	from the archive header for archive members).

*/

long
bfd_get_mtime (bfd *abfd)
{
  struct stat buf;

  if (abfd->mtime_set)
    return abfd->mtime;

  if (abfd->iovec == NULL)
    return 0;

  if (abfd->iovec->bstat (abfd, &buf) != 0)
    return 0;

  abfd->mtime = buf.st_mtime;		/* Save value in case anyone wants it */
  return buf.st_mtime;
}

/*
FUNCTION
	bfd_get_size

SYNOPSIS
	file_ptr bfd_get_size (bfd *abfd);

DESCRIPTION
	Return the file size (as read from file system) for the file
	associated with BFD @@var{abfd}.

	The initial motivation for, and use of, this routine is not
	so we can get the exact size of the object the BFD applies to, since
	that might not be generally possible (archive members for example).
	It would be ideal if someone could eventually modify
	it so that such results were guaranteed.

	Instead, we want to ask questions like "is this NNN byte sized
	object I'm about to try read from file offset YYY reasonable?"
	As as example of where we might do this, some object formats
	use string tables for which the first <<sizeof (long)>> bytes of the
	table contain the size of the table itself, including the size bytes.
	If an application tries to read what it thinks is one of these
	string tables, without some way to validate the size, and for
	some reason the size is wrong (byte swapping error, wrong location
	for the string table, etc.), the only clue is likely to be a read
	error when it tries to read the table, or a "virtual memory
	exhausted" error when it tries to allocate 15 bazillon bytes
	of space for the 15 bazillon byte table it is about to read.
	This function at least allows us to answer the question, "is the
	size reasonable?".
*/

file_ptr
bfd_get_size (bfd *abfd)
{
  struct stat buf;

  if (abfd->iovec == NULL)
    return 0;

  if (abfd->iovec->bstat (abfd, &buf) != 0)
    return 0;

  return buf.st_size;
}


/*
FUNCTION
	bfd_mmap

SYNOPSIS
	void *bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
	                int prot, int flags, file_ptr offset,
	                void **map_addr, bfd_size_type *map_len);

DESCRIPTION
	Return mmap()ed region of the file, if possible and implemented.
        LEN and OFFSET do not need to be page aligned.  The page aligned
        address and length are written to MAP_ADDR and MAP_LEN.

*/

void *
bfd_mmap (bfd *abfd, void *addr, bfd_size_type len,
	  int prot, int flags, file_ptr offset,
          void **map_addr, bfd_size_type *map_len)
{
  void *ret = (void *)-1;

  if (abfd->iovec == NULL)
    return ret;

  return abfd->iovec->bmmap (abfd, addr, len, prot, flags, offset,
                             map_addr, map_len);
}

/* Memory file I/O operations.  */

static file_ptr
memory_bread (bfd *abfd, void *ptr, file_ptr size)
{
  struct bfd_in_memory *bim;
  bfd_size_type get;

  bim = (struct bfd_in_memory *) abfd->iostream;
  get = size;
  if (abfd->where + get > bim->size)
    {
      if (bim->size < (bfd_size_type) abfd->where)
        get = 0;
      else
        get = bim->size - abfd->where;
      bfd_set_error (bfd_error_file_truncated);
    }
  memcpy (ptr, bim->buffer + abfd->where, (size_t) get);
  return get;
}

static file_ptr
memory_bwrite (bfd *abfd, const void *ptr, file_ptr size)
{
  struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;

  if (abfd->where + size > bim->size)
    {
      bfd_size_type newsize, oldsize;

      oldsize = (bim->size + 127) & ~(bfd_size_type) 127;
      bim->size = abfd->where + size;
      /* Round up to cut down on memory fragmentation */
      newsize = (bim->size + 127) & ~(bfd_size_type) 127;
      if (newsize > oldsize)
        {
          bim->buffer = (bfd_byte *) bfd_realloc_or_free (bim->buffer, newsize);
          if (bim->buffer == NULL)
            {
              bim->size = 0;
              return 0;
            }
          if (newsize > bim->size)
            memset (bim->buffer + bim->size, 0, newsize - bim->size);
        }
    }
  memcpy (bim->buffer + abfd->where, ptr, (size_t) size);
  return size;
}

static file_ptr
memory_btell (bfd *abfd)
{
  return abfd->where;
}

static int
memory_bseek (bfd *abfd, file_ptr position, int direction)
{
  file_ptr nwhere;
  struct bfd_in_memory *bim;

  bim = (struct bfd_in_memory *) abfd->iostream;

  if (direction == SEEK_SET)
    nwhere = position;
  else
    nwhere = abfd->where + position;

  if (nwhere < 0)
    {
      abfd->where = 0;
      errno = EINVAL;
      return -1;
    }

  if ((bfd_size_type)nwhere > bim->size)
    {
      if (abfd->direction == write_direction
          || abfd->direction == both_direction)
        {
          bfd_size_type newsize, oldsize;

          oldsize = (bim->size + 127) & ~(bfd_size_type) 127;
          bim->size = nwhere;
          /* Round up to cut down on memory fragmentation */
          newsize = (bim->size + 127) & ~(bfd_size_type) 127;
          if (newsize > oldsize)
            {
              bim->buffer = (bfd_byte *) bfd_realloc_or_free (bim->buffer, newsize);
              if (bim->buffer == NULL)
                {
                  errno = EINVAL;
                  bim->size = 0;
                  return -1;
                }
              memset (bim->buffer + oldsize, 0, newsize - oldsize);
            }
        }
      else
        {
          abfd->where = bim->size;
          errno = EINVAL;
          bfd_set_error (bfd_error_file_truncated);
          return -1;
        }
    }
  return 0;
}

static int
memory_bclose (struct bfd *abfd)
{
  struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;

  if (bim->buffer != NULL)
    free (bim->buffer);
  free (bim);
  abfd->iostream = NULL;

  return 0;
}

static int
memory_bflush (bfd *abfd ATTRIBUTE_UNUSED)
{
  return 0;
}

static int
memory_bstat (bfd *abfd, struct stat *statbuf)
{
  struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;

  memset (statbuf, 0, sizeof (*statbuf));
  statbuf->st_size = bim->size;

  return 0;
}

static void *
memory_bmmap (bfd *abfd ATTRIBUTE_UNUSED, void *addr ATTRIBUTE_UNUSED,
              bfd_size_type len ATTRIBUTE_UNUSED, int prot ATTRIBUTE_UNUSED,
              int flags ATTRIBUTE_UNUSED, file_ptr offset ATTRIBUTE_UNUSED,
              void **map_addr ATTRIBUTE_UNUSED,
              bfd_size_type *map_len ATTRIBUTE_UNUSED)
{
  return (void *)-1;
}

const struct bfd_iovec _bfd_memory_iovec =
{
  &memory_bread, &memory_bwrite, &memory_btell, &memory_bseek,
  &memory_bclose, &memory_bflush, &memory_bstat, &memory_bmmap
};
@


1.35
log
@	PR binutils/14813
	* bfdio.c (struct bfd_iovec <bclose>): Revert 2012-11-06.
	(memory_bclose): Likewise.  Return 0 on success.
	* cache.c (cache_bclose): Likewise.
	* opncls.c (opncls_bclose, bfd_close): Likewise.
	* vms-lib.c (vms_lib_bclose): Likewise.
	* libbfd.h: Regenerate.
@
text
@d3 1
a3 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
   Free Software Foundation, Inc.
d90 1
a90 1
  /* On VMS, fopen allows file attributes as optionnal arguments.
@


1.34
log
@Change return type of bclose to bfd_boolean

	PR binutils/14813
	* bfdio.c (bfd_iovec): Change return type of bclose to
	bfd_boolean.
	(memory_bclose): Change return type to bfd_boolean.
	* cache.c (cache_bclose): Likewise.
	* opncls.c (opncls_bclose): Likewise.  Return TRUE on success.
	* vms-lib.c (vms_lib_bclose): Likewise.  Return TRUE.
	* libbfd.h: Regenerated.
@
text
@d157 1
a157 1
.  bfd_boolean (*bclose) (struct bfd *abfd);
d579 1
a579 1
static bfd_boolean
d589 1
a589 1
  return TRUE;
@


1.33
log
@2012-02-02  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c (real_fopen): Remove unused vms_modes variable.
@
text
@d157 1
a157 1
.  int (*bclose) (struct bfd *abfd);
d579 1
a579 1
static int
@


1.33.4.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d589 1
a589 1
  return 0;
@


1.32
log
@	PR binutils/13534
	* archive.c (_bfd_ar_sizepad): New function. Correctly install and
	pad the size field in an archive header.
	(_bfd_generic_read_ar_hdr_mag): Use the correct type and scan
	function for the archive size field.
	(bfd_generic_openr_next_archived_file): Likewise.
	(do_slurp_coff_armap): Likewise.
	(_bfd_write_archive_contents): Likewise.
	(_bfd_bsd44_write_ar_hdr): Use the new function.
	(bfd_ar_hdr_from_filesystem): Likewise.
	(_bfd_write_archive_contents): Likewise.
	(bsd_write_armap): Likewise.
	(coff_write_armap): Likewise.
	* archive64.c (bfd_elf64_archive_write_armap): Likewise.
	* bfdio.c (bfd_bread): Use correct type for archive element
	sizes.
	* ar.c (open_inarch): Likewise.
	(extract_file): Likewise.
	* libbfd-in.h (struct areltdata): Use correct types for
	parsed_size and extra_size fields.
	Prototype _bfd_ar_sizepad function.
	* libbfd.h: Regenerate.
@
text
@a89 1
  char vms_modes[4];
@


1.31
log
@2012-01-10  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c (bfd_tell): Handle nested archives.
	(bfd_seek): Ditto.
	* cache.c (bfd_cache_lookup_worker): Ditto.
	* archive.c (_bfd_get_elt_at_filepos): Remove code dealing with
	nested archives.
	(bfd_generic_openr_next_archived_file): Likewise.
@
text
@d188 2
a189 1
      size_t maxbytes = arelt_size (abfd);
@


1.30
log
@2012-01-06  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c (bfd_bread): Use arelt_size macro.
@
text
@d236 1
d239 5
a243 2
      if (abfd->my_archive)
	ptr -= abfd->origin;
d315 10
a324 2
  if (direction == SEEK_SET && abfd->my_archive != NULL)
    file_position += abfd->origin;
@


1.29
log
@2011-06-27  Tristan Gingold  <gingold@@adacore.com>

	* cache.c: Include bfd_stdint.h.
	(cache_bmmap): Change profile.  Return region start and size.
	* bfdio.c (struct bfd_iovec): Change bmmap profile.
	(bfd_mmap): Change profile and adjust.   Update comment.
	(memory_bmmap): Change profile.
	* opncls.c (opncls_bmmap): Change profile.
	* vms-lib.c (vms_lib_bmmap): Likewise.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
@
text
@d188 1
a188 1
      size_t maxbytes = ((struct areltdata *) abfd->arelt_data)->parsed_size;
@


1.28
log
@	* bfdio.c (memory_bstat): Pass correct size to memset.
@
text
@d161 6
a166 1
.  {* Just like mmap: (void*)-1 on failure, mmapped address on success.  *}
d168 2
a169 1
.                  int prot, int flags, file_ptr offset);
d432 2
a433 1
	                int prot, int flags, file_ptr offset);
d437 2
d444 2
a445 1
	  int prot, int flags, file_ptr offset)
d452 2
a453 1
  return abfd->iovec->bmmap (abfd, addr, len, prot, flags, offset);
d600 3
a602 1
              int flags ATTRIBUTE_UNUSED, file_ptr offset ATTRIBUTE_UNUSED)
@


1.27
log
@2010-06-09 Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c (bfd_bread): Fix the code to prevent reading past the
	end of archive members.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d580 1
a580 1
  memset (statbuf, 0, sizeof (statbuf));
@


1.27.4.1
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011
d580 1
a580 1
  memset (statbuf, 0, sizeof (*statbuf));
@


1.26
log
@2010-05-25  Tristan Gingold  <gingold@@adacore.com>

	* bfdio.c: Declare and define _bfd_memory_iovec.
	(bfd_bread): Move code for BFD_IN_MEMORY...
	(bfd_bwrite): ... Ditto ...
	(bfd_tell): ... Ditto ...
	(bfd_flush): ... Ditto ...
	(bfd_stat): ... Ditto ...
	(bfd_seek): ... Ditto ...
	(bfd_get_size): ... Ditto ...
	(bfd_mmap): ... Ditto ...
	(memory_bread): ... to these new functions.
	(memory_bwrite): Ditto.
	(memory_btell): Ditto.
	(memory_bseek): Ditto.
	(memory_bflush): Ditto.
	(memory_bstat): Ditto.
	(memory_bmmap): Ditto.
	(memory_bclose): New function.
	* peicode.h (pe_ILF_build_a_bfd): Use BFD_IN_MEMORY.
	* xcofflink.c (bfd_xcoff_link_generate_rtinit): Ditto.
	* opncls.c (bfd_close): Do not handle BFD_IN_MEMORY case.
	(bfd_make_writable): Use _bfd_memory_iovec.
	* elfcode.h (bfd_from_remote_memory): Use _bfd_memory_iovec.
	* coff-alpha.c (alpha_ecoff_get_elt_at_filepos): Use
	_bfd_memory_iovec.
	(alpha_ecoff_openr_next_archived_file): Use proxy_origin
	instead of origin.
	* libbfd.h: Regenerate.
@
text
@d183 6
a188 2
      if (size > maxbytes)
	size = maxbytes;
@


1.25
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d166 2
a186 20
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    {
      struct bfd_in_memory *bim;
      bfd_size_type get;

      bim = (struct bfd_in_memory *) abfd->iostream;
      get = size;
      if (abfd->where + get > bim->size)
	{
	  if (bim->size < (bfd_size_type) abfd->where)
	    get = 0;
	  else
	    get = bim->size - abfd->where;
	  bfd_set_error (bfd_error_file_truncated);
	}
      memcpy (ptr, bim->buffer + abfd->where, (size_t) get);
      abfd->where += get;
      return get;
    }

a201 31
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    {
      struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;

      size = (size_t) size;
      if (abfd->where + size > bim->size)
	{
	  bfd_size_type newsize, oldsize;

	  oldsize = (bim->size + 127) & ~(bfd_size_type) 127;
	  bim->size = abfd->where + size;
	  /* Round up to cut down on memory fragmentation */
	  newsize = (bim->size + 127) & ~(bfd_size_type) 127;
	  if (newsize > oldsize)
	    {
	      bim->buffer = (bfd_byte *) bfd_realloc_or_free (bim->buffer,
                                                              newsize);
	      if (bim->buffer == NULL)
		{
		  bim->size = 0;
		  return 0;
		}
	      if (newsize > bim->size)
		memset (bim->buffer + bim->size, 0, newsize - bim->size);
	    }
	}
      memcpy (bim->buffer + abfd->where, ptr, (size_t) size);
      abfd->where += size;
      return size;
    }

a223 3
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    return abfd->where;

a240 3
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    return 0;

a252 3
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    abort ();

a279 44
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    {
      struct bfd_in_memory *bim;

      bim = (struct bfd_in_memory *) abfd->iostream;

      if (direction == SEEK_SET)
	abfd->where = position;
      else
	abfd->where += position;

      if (abfd->where > bim->size)
	{
	  if (abfd->direction == write_direction
	      || abfd->direction == both_direction)
	    {
	      bfd_size_type newsize, oldsize;

	      oldsize = (bim->size + 127) & ~(bfd_size_type) 127;
	      bim->size = abfd->where;
	      /* Round up to cut down on memory fragmentation */
	      newsize = (bim->size + 127) & ~(bfd_size_type) 127;
	      if (newsize > oldsize)
	        {
		  bim->buffer = (bfd_byte *) bfd_realloc_or_free (bim->buffer,
                                                                  newsize);
		  if (bim->buffer == NULL)
		    {
		      bim->size = 0;
		      return -1;
		    }
		  memset (bim->buffer + oldsize, 0, newsize - oldsize);
	        }
	    }
	  else
	    {
	      abfd->where = bim->size;
	      bfd_set_error (bfd_error_file_truncated);
	      return -1;
	    }
	}
      return 0;
    }

a405 3
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    return ((struct bfd_in_memory *) abfd->iostream)->size;

a433 2
  if ((abfd->flags & BFD_IN_MEMORY) != 0)
    return ret;
d440 155
@


1.24
log
@update copyright dates
@
text
@d190 1
a190 1
      bim = abfd->iostream;
d222 1
a222 1
      struct bfd_in_memory *bim = abfd->iostream;
d235 2
a236 1
	      bim->buffer = bfd_realloc_or_free (bim->buffer, newsize);
d342 1
a342 1
      bim = abfd->iostream;
d362 2
a363 1
		  bim->buffer = bfd_realloc_or_free (bim->buffer, newsize);
@


1.24.2.1
log
@        Updated soruces in bfd/* to compile cleanly with -Wc++-compat.

        * bfd/aoutx.h: Add casts.
        * bfd/archive.c: Add casts.
        * bfd/archive64.c: Add casts.
        * bfd/archures.c: Add casts.
        * bfd/bfd-in2.h: Regenerated.
        * bfd/bfd.c: Add casts. (enum bfd_direction): Move out to top
        level.
        * bfd/bfdio.c: Add casts.
        * bfd/binary.c: Add casts.
        * bfd/cache.c (cache_bseek,cache_bread_1,cache_bwrite): Updated
        parameter to use enum value instead of int.
        * bfd/coffcode.h: Add casts.
        * bfd/coffgen.c: Add casts.
        * bfd/cofflink.c: Add casts.
        * bfd/compress.c: Add casts.
        * bfd/dwarf1.c: Add casts.
        * bfd/dwarf2.c: Add casts. (struct dwarf2_debug): Rename member
        bfd to bfd_ptr. Update code to use new name.
        * bfd/elf-attrs.c: Add casts.
        * bfd/elf-bfd.h (elf_link_virtual_table_entry): Gives name to
        anonymous struct. (union gotplt_union, struct
        elf_link_virtual_table_entry): Move to top level.
        * bfd/elf-eh-frame.c: Add casts.
        * bfd/elf-strtab.c: Add casts.
        * bfd/elf.c: Add casts. (_bfd_elm_make_Section_from_phdr): Change
        argument name from typename to type_name.
        * bfd/elf32-i386.c: Add casts.
        * bfd/elf64-x86-64.c: Add casts.
        * bfd/elfcode.h: Add casts.
        * bfd/elfcore.h: Add casts.
        * bfd/elflink.c: Add casts.
        * bfd/format.c: Add casts.
        * bfd/hash.c: Add casts.
        * bfd/ihex.c: Add casts.
        * bfd/libaout.h (enum aout_subformat, enum aout_magic): Move to
        top level.
        * bfd/libbfd.c: Add casts.
        * bfd/linker.c: Add casts.
        * bfd/merge.c: Add casts.
        * bfd/opncls.c: Add casts.
        * bfd/peXXigen.c: Add casts.
        * bfd/peicode.h: Add casts.
        * bfd/reloc.c: Add casts.
        * bfd/section.c: Add casts.
        * bfd/simple.c: Add casts.
        * bfd/srec.c: Add casts.
        * bfd/stabs.c: Add casts.
        * bfd/syms.c: Add casts.
        * bfd/targets.c: Add casts.
        * bfd/tekhex.c: Add casts.
        * bfd/verilog.c: Add casts.
        * include/bfdlink.h (struct bfd_link_hash_common_entry): Move to
        top level.
@
text
@d190 1
a190 1
      bim = (struct bfd_in_memory *) abfd->iostream;
d222 1
a222 1
      struct bfd_in_memory *bim = (struct bfd_in_memory *) abfd->iostream;
d235 1
a235 2
	      bim->buffer = (bfd_byte *) bfd_realloc_or_free (bim->buffer,
                                                              newsize);
d341 1
a341 1
      bim = (struct bfd_in_memory *) abfd->iostream;
d361 1
a361 2
		  bim->buffer = (bfd_byte *) bfd_realloc_or_free (bim->buffer,
                                                                  newsize);
@


1.23
log
@2009-07-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdio.c (bfd_iovec): Add comments for bmmap.
	* bfd-in2.h: Regenerated.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.22
log
@2009-06-10  Paul Pluzhnikov  <ppluzhnikov@@google.com>

	* bfd-in2.h: bfd_mmap prototype
	* bfdio.c (bfd_mmap): New function.
	* libbfd.h (bfd_iovec): Add bmmap.
	* cache.c (cache_bmap): New function.
	(cache_iovec): Initialize bmmap member.
	* opencls.c (opncls_bmmap): New function.
	(opncls_iovec): Initialize bmmap member.
@
text
@d161 2
a162 1
.  void* (*bmmap) (struct bfd *abfd, void *addr, bfd_size_type len,
@


1.21
log
@       * bfdio.c (bfd_seek): Formatting.  Ensure newly allocated memory
       for BFD_IN_MEMORY is cleared.
       (bfd_bwrite): Zero excess memory allocated.
@
text
@d161 2
d516 28
@


1.20
log
@2009-02-23  Tristan Gingold  <gingold@@adacore.com>

	* vms.h: Update copyright year, fix comments, reorder declarations.
	(_bfd_save_vms_section): Remove the prototype.
	(EGPS_S_V_NO_SHIFT): New constant.
	(bfd_vms_set_section_flags): New prototype.
	(EGPS_S_B_ALIGN, EGPS_S_W_FLAGS, EGPS_S_L_ALLOC, EGPS_S_B_NAMLNG): New
	constants.
	(EGSY_S_W_FLAGS): Ditto.
	(EGSY_S_V_QUAD_VAL): Ditto.
	(ESDF_S_L_VALUE, ESDF_S_L_PSINDX, ESDF_S_B_NAMLNG): Ditto.
	(EGST_S_W_FLAGS, EGST_S_Q_LP_1, EGST_S_Q_LP_2, EGST_S_L_PSINDX,
	EGST_S_B_NAMLNG): Ditto.
	(ESRF_S_B_NAMLNG): Ditto.
	(ETIR_S_C_HEADER_SIZE): Ditto.
	(EGPS_S_V_ALLOC_64BIT): Ditto.
	(DST_S_C_EPILOG): Ditto.
	(DST_S_C_SRC_SETLNUM_L, DST_S_C_SRC_SETLNUM_W) : Ditto.
	(DST_S_C_SRC_INCRLNUM_B): Ditto.
	(DST_S_B_PCLINE_UNSBYTE, DST_S_W_PCLINE_UNSWORD): Ditto.
	(DST_S_L_PCLINE_UNSLONG): Ditto.
	(DST_S_B_MODBEG_NAME, DST_S_L_RTNBEG_ADDRESS) : Ditto
	(DST_S_B_RTNBEG_NAME, DST_S_L_RTNEND_SIZE): Ditto
	(DST_S_C_SOURCE_HEADER_SIZE): Ditto.
	(DST_S_B_SRC_DF_LENGTH, DST_S_W_SRC_DF_FILEID): Ditto.
	(DST_S_B_SRC_DF_FILENAME, DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_B_SRC_UNSBYTE): Ditto.
	(DST_S_W_SRC_UNSWORD, DST_S_L_SRC_UNSLONG): Ditto.
	Add prototypes.
	(vms_section, vms_reloc): Remove types.
	(hdr_struc): Replaced by ...
	(hdr_struct): ... new type.
	(EMH_S_W_HDRTYP, EMH_S_B_STRLVL, EMH_S_L_ARCH1): New constants.
	(EMH_S_L_ARCH2, EMH_S_L_RECSIZ, EMH_S_B_NAMLNG): Ditto.
	(EMH_DATE_LENGTH): Ditto.
	(eom_struc): Replaced by ...
	(eom_struct): ... new type.
	(EEOM_S_L_TOTAL_LPS, EEOM_S_W_COMCOD, EEOM_S_B_TFRFLG): New constants.
	(EEOM_S_L_PSINDX, EEOM_S_L_TFRADR): Ditto.
	(EIHD_S_K_MAJORID, EIHD_S_K_MINORID, EIHD_S_K_EXE): Ditto.
	(EIHD_S_L_SIZE, EIHD_S_L_ISDOFF, EIHD_S_L_SYMDBGOFF): Ditto.
	(EIHD_S_Q_SYMVVA, EIHD_S_L_IMGTYPE): Ditto.
	(EISD_S_L_EISDSIZE, EISD_S_L_SECSIZE, EISD_S_Q_VIR_ADDR): Ditto.
	(EISD_S_L_FLAGS, EISD_S_L_VBN, EISD_S_R_CONTROL): Ditto.
	(EISD_S_L_IDENT, EISD_S_T_GBLNAM): Ditto.
	(EISD_S_M_GBL, EISD_S_M_CRF, EISD_S_M_DZRO, EISD_S_M_WRT): Ditto.
	(EISD_S_M_INITALCODE, EISD_S_M_BASED, EISD_S_M_FIXUPVEC): Ditto.
	(EISD_S_M_RESIDENT, EISD_S_M_VECTOR, EISD_S_M_PROTECT): Ditto.
	(EISD_S_M_LASTCLU, EISD_S_M_EXE, EISD_S_M_NONSHRADR): Ditto.
	(EISD_S_M_QUAD_LENGTH, EISD_S_M_ALLOC_64BIT): Ditto.
	(EIHS_S_L_DSTVBN, EIHS_S_L_DSTSIZE, EIHS_S_L_GSTVBN): Ditto.
	(EIHS_S_L_GSTSIZE, EIHS_S_L_DMTVBN, EIHS_S_L_DMTBYTES): Ditto.
	(DBG_S_L_DMT_MODBEG, DBG_S_L_DST_SIZE): Ditto.
	(DBG_S_W_DMT_PSECT_COUNT, DBG_S_C_DMT_HEADER_SIZE): Ditto.
	(DBG_S_L_DMT_PSECT_START, DBG_S_L_DMT_PSECT_LENGTH)
	(DBG_S_C_DMT_PSECT_SIZE): Ditto.
	(enum file_type_enum): New type.
	(struct location_struct): Removed.
	(struct fileinfo, struct srecinfo, struct lineinfo): New types.
	(struct funcinfo, struct module): Ditto.
	(struct vms_private_data_struct): Update fields.
	(struct vms_section_data_struct): New type.

	* vms.c: Update copyright year, fix comments,
	Fix includes for DECC, add prototypes.
	(vms_initialize): Use bfd_alloc instead of bfd_zalloc and remove
	some initializers.
	Use flavour to set is_vax, location_stack is removed.
	(struct pair): Declare.
	(fill_section_ptr): Initialize variables at declaration.
	Add guard to set SECTION_SYM flag, handlde und section.
	(vms_fixup_sections): Use struct pair for fill_section_ptr argument.
	(_bfd_vms_slurp_object_records): New function, replaces previous
	vms_object_p.
	(vms_slurp_module): New function.
	(vms_slurp_image): Ditto.
	(vms_object_p): Complete rewrite.
	(vms_mkobject): Use is_vax field to slect architecture.
	(free_reloc_stream): New function.
	(vms_convert_to_var): Ditto.
	(vms_convert_to_var_1): Ditto.
	(vms_convert_to_var_unix_filename): Ditto.
	(vms_close_and_cleanup): Call free_reloc_stream, convert file to
	VAR format on VMS.
	(vms_new_section_hook): Set alignment to 0, allocate private data.
	(vms_get_section_contents): Load content.
	(vms_get_symbol_info): Handle undefined section.
	(vms_find_nearest_line): Handle.
	(alloc_reloc_stream): New function.
	(vms_slurp_reloc_table): Ditto.
	(vms_get_reloc_upper_bound): Make it real.
	(vms_canonicalize_reloc): Do the real work.
	(alpha_howto_table): Add ALPHA_R_NOP, ALPHA_R_BSR, ALPHA_R_LDA,
	ALPHA_R_BOH.
	(vms_bfd_reloc_type_lookup): Handle NOP, BSR, LDA and BOH.
	(vms_set_arch_mach): Check arch.
	(vms_set_section_contents): Copy the content after allocation.
	(vms_alpha_vec): Update object flags.

	* vms-tir.c: Update copyright year, fix comments,
	add prototypes for new functions.
	(dst_define_location): New function.
	(dst_restore_location): New function.
	(dst_retrieve_location): New function.
	(dst_check_allocation): New function.
	(image_dump): Call dst_check_allocation.
	(image_write_b): Ditto.
	(image_write_w): Ditto.
	(image_write_l): Ditto.
	(image_write_q): Ditto.
	(cmd_name): Handle STA_LW, STA_QW, STO_OFF, STO_IMM, STO_IMMR, STO_LW,
	STO_QW, OPR_ADD, CTL_SETRB, STC_LP_PSB, CTL_DFLOC, CTL_STLOC,
	CTL_STKDL.
	Call error handler instead of abort if name is not known.
	(etir_sta): Add quarter_relocs argument and set it.
	Fix cast.
	(etir_sto): Ditto.
	(etir_opr): Ditto, return FALSE in case of error.
	(etir_ctl): Add quarter_relocs argument and set it, fix cast.
	Fix CTL_DFLOC, CTL_STLOC, CTL_STKDL.
	(etir_stc): Add quarter_relocs argument and set it, fix cast.
	Fix STC_LP, STC_LP_PSB, STC_GBL and STC_CGA.
	Handle STC_LP_PSB, STC_BSR_GBL, STC_LDA_GBL, STC_BOH_GBL.
	Move STC_NOP_PS, STC_BSR_PS, STC_LDA_PS, STC_BOH_PS, STC_NBH_PS.
	Return FALSE in case of error.
	(tir_sta): Change sign of psect.
	(tir_ctl): Ditto.
	(tir_cmd): Fix cast. Makes tir_table static const.
	(etir_cmd): Add quarter_relocs argument, makes etir_table const,
	add argument to explain.
	(analyze_etir): Initialize maxptr, add quarter_relocs
	declaration, move some declarations into inner scopes.
	Handle quarter_relocs and STO_IMM.
	(_bfd_vms_slurp_tir): Use constant instead of hard-coded values.
	(_bfd_vms_slurp_relocs): New function.
	(_bfd_vms_decode_relocs): New function.
	(sto_imm): Rewritten.
	(start_first_etbt_record): New function.
	(start_another_etbt_record): Ditto.
	(etir_output_check): Ditto.
	(defer_reloc_p): Ditto.
	(_bfd_vms_write_tir): Remove nextoffset, convert a while-loop to
	a for-loop.  Correctly deals with contents, deals with .vmsdebug,
	rewritte relocations handling.
	(_bfd_vms_write_tbt): Removed.
	(_bfd_vms_write_dbg): Ditto.

	* vms-misc.c: Update copyright year, Fix comments.
	(_bfd_vms_get_header_values): Use 'size' instead of 'length'.
	(maybe_adjust_record_pointer_for_object): New function.
	(_bfd_vms_get_first_record): New function, replaces ...
	(_bfd_vms_get_record): ..  removed.
	(_bfd_vms_get_object_record): New function.
	(_bfd_vms_get_object_record): New function.
	(vms_get_remaining_object_record): New function, replaces ...
	(_bfd_vms_get_next_record): ... removed.
	(add_new_contents): Removed.
	(_bfd_save_vms_section): Removed.
	(_bfd_get_vms_section): Removed.
	(_bfd_vms_output_flush): Write in VAR format.
	(new_symbol): Don't make UND section.

	* vms-hdr.c: Update copyright year, update list of record handled.
	(_bfd_vms_slurp_hdr): rec_length renamed to rec_size.
	(_bfd_vms_write_hdr): Strip vms and unix patches,
	add comments, truncate module name at 31 characters,
	use constants instead of hard-coded value,
	write BFD version instead of a fixed string.
	(_bfd_vms_slurp_ihd): New function.
	(_bfd_vms_slurp_isd): Ditto.
	(_bfd_vms_slurp_ihs): Ditto.
	(new_module): Ditto.
	(parse_module): Ditto
	(build_module_list): Ditto.
	(module_find_nearest_line): Ditto.
	(_bfd_vms_find_nearest_dst_line): Ditto.
	(vms_slurp_debug): Ditto.
	(_bfd_vms_slurp_dbg): Ditto.
	(_bfd_vms_slurp_tbt): Ditto.
	(_bfd_vms_write_dbg): Ditto.
	(_bfd_vms_write_tbt): Ditto.

	* vms-gsd.c: Update copyright year, update list of records handled.
	(EVAX_LITERALS_NAME): New macro.
	(evax_section_flags): Add an entry for EVAX_LITERALS_NAME.
	(gpsflagdesc, gsyflagdesc): Moved out of _bfd_vms_slurp_gsd.
	(register_universal_symbol): New function and prototype.
	(_bfd_vms_slurp_gsd): Fix indentations and casts,
	improve debug messages,
	use constants instead of hard-coded value,
	fix missing endianness conversion,
	handle global symbol (SYMG).
	(bfd_vms_set_section_flags): New function.
	(_bfd_vms_write_gsd): Don't write .vmsdebug section,
	handle section literals,
	fix indentation,
	handle section bfd and vms flags,
	don't output LIB$INITIALIZE symbol,
	fix handling of weak symbols,
	fix evax vs vax procedure descriptor,
	handle absolute symbols.

	* reloc.c (BFD_RELOC_ALPHA_NOP, BFD_RELOC_ALPHA_BSR,
	BFD_RELOC_ALPHA_LDA, BFD_RELOC_ALPHA_BOH): New relocations.

	* makefile.vms (DEFS): Fix flags for VMS.

	* bfdio.c (real_fopen): Handle multiple VMS fopen attributes.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
@
text
@d238 2
d347 2
a348 2
	  if ((abfd->direction == write_direction) ||
	      (abfd->direction == both_direction))
d364 1
@


1.19
log
@bfd/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* configure.com: Handle bfd_default_target_size, BFD_HOST_LONG_LONG,
	BFD_HOST_64BIT_LONG_LONG, BFD_HOSTPTR_T, bfd_file_ptr.
	Generate bfdver.h.
	* vms-hdr.c (_bfd_vms_write_hdr): Use strdup/free instead of alloca.
	* hosts/alphavms.h: Defines macros to bypass i18n.
	* makefile.vms (OBJS): Update file list.
	(DEFS): Remove VMS_DEBUG, const, add DEBUGDIR.
	(CFLAGS): Update flags.
	* bfdio.c (real_fopen): Add code specific to VMS: extract attributes
	from modes.

binutils/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* configure.com: Get version from configure.in of bfd.
	* makefile.vms-in (DEBUG_OBJS): Add dwarf.obj.
	(CFLAGS): Update flags.

include/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* fopen-vms.h (FOPEN_RB): Use a single string to match the
	standard prototype.
	(FOPEN_WB): Ditto.
	(FOPEN_AB): Ditto.
	(FOPEN_RUB): Ditto.
	(FOPEN_WUB): Ditto.
	(FOPEN_AUB): Ditto.

libiberty/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* makefile.vms (OBJS): Update objects list.
	(CFLAGS): Update.
	(libiberty.olb): Remove alloca-conf.h dependency.
	* config.h-vms: Use new macro sets, use builtin alloca.

opcodes/
2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	* makefile.vms (OBJS): Update list of objects.
	(DEFS): Update
	(CFLAGS): Update.
@
text
@d105 15
a119 7
      /* Attribute found - rebuild modes.  */
      size_t modes_len = vms_attr - modes;

      BFD_ASSERT (modes_len < sizeof (vms_modes));
      memcpy (vms_modes, modes, modes_len);
      vms_modes[modes_len] = 0;
      return close_on_exec (fopen (filename, vms_modes, vms_attr + 1));
@


1.18
log
@	* configure, config.in: Rebuild.
	* configure.in: Check for fileno.
	* bfdio.c (close_on_exec): New function.
	(real_fopen): Use it.
	(FD_CLOEXEC): New define.
@
text
@d89 25
d119 1
@


1.17
log
@PR 868
   * libbfd.c (bfd_realloc_or_free): New function.  Performs like
   bfd_realloc, but if the (re)allocation fails, the pointer is
   freed.
   * libbfd-in.h: Prototype.
   * libbfd.h: Regenerate.
   * bfdio.c (bfd_bwrite): Use the new function.
   (bfd_seek): Likewise.
   * bfdwin.c:(bfd_get_file_window): Likewise.
   * elf-strtab.c (_bfd_elf_strtab_add): Likewise.
   * elf32-ppc.c (ppc_elf_relax_section): Likewise.
   * elf32-xtensa.c (vsprintf_msg): Likewise.
   * mach-o.c (bfd_mach_o_core_fetch_environment): Likewise.
   * stabs.c (_bfd_link_seciton_stabs): Likewise.
   * vms-misc.c (_bfd_vms_get_record): Likewise.
   * vms-tir.c (check_section): Likewise.
   * vms.c (vms_new_section_hook): Likewise.
   * elf32-arm.c (elf32_arm_section_map_add): Check that the
   allocation of sec_data->map succeeded before using it.
   * elflink.c (elf_link_output_sym): Do not overwrite finfo->
   symshndxbuf until it is known that the reallocation succeeded.
@
text
@d41 4
d69 17
d90 1
a90 1
  return fopen64 (filename, modes);
d92 1
a92 1
  return fopen (filename, modes);
@


1.16
log
@Switch sources over to use the GPL version 3
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d177 2
a178 2
	      bim->buffer = bfd_realloc (bim->buffer, newsize);
	      if (bim->buffer == 0)
d301 2
a302 2
		  bim->buffer = bfd_realloc (bim->buffer, newsize);
		  if (bim->buffer == 0)
@


1.15
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
This file is part of BFD, the Binary File Descriptor library.
d11 14
a24 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.14
log
@	PR 3704
	* bfdio.c (bfd_bread): Don't read past end of archive elements.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d26 1
a26 1

a29 2
#include <limits.h>

@


1.13
log
@	* bfd-in.h (struct stat): Don't typedef.
	* bfdio.c (bfd_get_size): Return a file_ptr.
	* cisco-core.c (cisco_core_file_validate): Use bfd_size_type for nread.
	* mmo.c (mmo_scan): Use file_ptr for curpos.
	* trad-core.c (trad_unix_core): Don't cast statbuf.st_size to
	unsigned long.
	* bfd-in2.h: Regenerate.
@
text
@d4 1
a4 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005
d119 9
@


1.12
log
@	* configure.in: Check for fopen64.
	* libbfd-in.h (real_fopen): New prototype.
	* configure, config.in, libbfd.h: Regenerated.
	* bfdio.c (real_fopen): New function.
	* opncls.c (bfd_fopen, bfd_fill_in_gnu_debuglink_section): Use it.
	* cache.c (bfd_open_file): Likewise.
@
text
@d404 1
a404 1
	long bfd_get_size (bfd *abfd);
d432 1
a432 1
long
@


1.11
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d66 10
@


1.11.6.1
log
@	* configure.in: Check for fopen64.
	* libbfd-in.h (real_fopen): New prototype.
	* configure, config.in, libbfd.h: Regenerated.
	* bfdio.c (real_fopen): New function.
	* opncls.c (bfd_fopen, bfd_fill_in_gnu_debuglink_section): Use it.
	* cache.c (bfd_open_file): Likewise.
@
text
@a65 10
FILE *
real_fopen (const char *filename, const char *modes)
{
#if defined (HAVE_FOPEN64)
  return fopen64 (filename, modes);
#else
  return fopen (filename, modes);
#endif
}

@


1.10
log
@Update the FSF address in the copyright/GPL notice
@
text
@d23 1
a23 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02110-1301, USA.  */
@


1.9
log
@update copyright dates
@
text
@d23 1
a23 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.8
log
@	* aout-arm.c, aout-target.h, aoutx.h, archive.c, armnetbsd.c,
	bfd-in.h, bfdio.c, coff-alpha.c, coff-arm.c, coff-h8300.c,
	coff-i860.c, coff-mcore.c, coff-or32.c, coff-ppc.c, coff-sh.c,
	coff-sparc.c, coffcode.h, coffgen.c, cofflink.c, cpu-cris.c,
	cpu-h8500.c, cpu-ns32k.c, ecoff.c, ecofflink.c, elf.c,
	elf32-dlx.c, elf32-fr30.c, elf32-frv.c, elf32-hppa.c,
	elf32-i860.c, elf32-ip2k.c, elf32-m32r.c, elf32-sh.c,
	elf32-v850.c, elf64-mips.c, elf64-sparc.c, elflink.c,
	i386aout.c, i386msdos.c, i386os9k.c, ieee.c, mach-o.c,
	nlm32-sparc.c, oasys.c, opncls.c, pdp11.c, pe-mips.c, peXXigen.c,
	pef.c, peicode.h, reloc.c, riscix.c, section.c, simple.c, som.c,
	sparclynx.c, targets.c, vms-misc.c, vms-tir.c, xsym.c, doc/chew.c,
	hosts/delta68.h, hosts/vaxbsd.h: Remove #if 0'd code
	throughout. Similarly, collapse #if 1'd code.
@
text
@d4 2
a5 1
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.7
log
@Do not use iovec if it is NULL.
@
text
@a301 14
#if 0
      /* Explanation for this code: I'm only about 95+% sure that the above
	 conditions are sufficient and that all i/o calls are properly
	 adjusting the `where' field.  So this is sort of an `assert'
	 that the `where' field is correct.  If we can go a while without
	 tripping the abort, we can probably safely disable this code,
	 so that the real optimizations happen.  */
      file_ptr where_am_i_now;
      where_am_i_now = real_ftell (bfd_cache_lookup (abfd));
      if (abfd->my_archive)
	where_am_i_now -= abfd->origin;
      if (where_am_i_now != abfd->where)
	abort ();
#endif
@


1.6
log
@2004-04-21  Andrew Cagney  <cagney@@redhat.com>

	* opncls.c (_bfd_new_bfd_contained_in): Copy "iovec".
	(struct opncls, opncls_btell, opncls_bseek, opncls_bread)
	(opncls_bwrite, opncls_bclose, opncls_bflush)
	(opncls_bstat, opncls_iovec, bfd_openr_iovec): Implement a
	bfd iovec that uses function callbacks.
	(bfd_close): Use the iovec's bclose.
	* cache.c (cache_btell, cache_bseek, cache_bread, cache_bwrite)
	(cache_bclose, cache_bflush, cache_bstat)
	(cache_iovec): New functions and global variable, implement a
	cache "iovec", where applicable set bfd_error.
	(bfd_cache_init, bfd_cache_close): Set/test the bfd's iovec.
	* bfdio.c (struct bfd_iovec): Define.
	(real_read): Delete function.
	(bfd_bread, bfd_bread, bfd_bwrite, bfd_tell, bfd_flush, bfd_stat)
	(bfd_seek, bfd_get_mtime, bfd_get_size): Use the bfd's "iovec",
	assume that bread and bwrite set bfd_error.
	* bfd.c (struct bfd): Add "iovec", update comments.
	* bfd-in2.h, libbfd.h: Re-generate.
@
text
@d128 4
a131 1
  nread = abfd->iovec->bread (abfd, ptr, size);
d146 1
d171 5
a175 1
  nwrote = abfd->iovec->bwrite (abfd, ptr, size);
d196 9
a204 1
  ptr = abfd->iovec->btell (abfd);
a205 2
  if (abfd->my_archive)
    ptr -= abfd->origin;
d215 4
a218 1
  return abfd->iovec->bflush (abfd);
d231 5
a235 1
  result = abfd->iovec->bstat (abfd, statbuf);
d275 1
d338 5
a342 1
  result = abfd->iovec->bseek (abfd, file_position, direction);
d392 3
d442 3
@


1.5
log
@2004-02-11  Andrew Cagney  <cagney@@redhat.com>

	* bfd-in.h: Update copyright.
	(bfd_tell): Change return type to file_ptr.
	* bfd-in2.h: Re-generate.
	* cache.c: Update copyright.
	(bfd_cache_lookup_worker): Use real_fseek, do not cast offset
	parameter.
	(close_one): Use real_ftell.
	* bfdio.c: Update copyright.
	(real_ftell, real_fseek): New functions.
	(bfd_tell): Use real_fseek and real_ftell, change return type to
	file_ptr.
	(bfd_seek): Use real_ftell and real_fseek, change type of
	file_position to a file_ptr.
	* libbfd-in.h: Update copyright.
	(real_ftell, real_fseek): Declare.
	* libbfd.h: Re-generate.
@
text
@d65 3
a67 2
/* Note that archive entries don't have streams; they share their parent's.
   This allows someone to play with the iostream behind BFD's back.
d69 1
a69 3
   Also, note that the origin pointer points to the beginning of a file's
   contents (0 for non-archive elements).  For archive entries this is the
   first octet in the file, NOT the beginning of the archive header.  */
d71 26
a96 14
static size_t
real_read (void *where, size_t a, size_t b, FILE *file)
{
  /* FIXME - this looks like an optimization, but it's really to cover
     up for a feature of some OSs (not solaris - sigh) that
     ld/pe-dll.c takes advantage of (apparently) when it creates BFDs
     internally and tries to link against them.  BFD seems to be smart
     enough to realize there are no symbol records in the "file" that
     doesn't exist but attempts to read them anyway.  On Solaris,
     attempting to read zero bytes from a NULL file results in a core
     dump, but on other platforms it just returns zero bytes read.
     This makes it to something reasonable. - DJ */
  if (a == 0 || b == 0)
    return 0;
d98 1
a99 8
#if defined (__VAX) && defined (VMS)
  /* Apparently fread on Vax VMS does not keep the record length
     information.  */
  return read (fileno (file), where, a * b);
#else
  return fread (where, a, b, file);
#endif
}
d128 1
a128 1
  nread = real_read (ptr, 1, (size_t) size, bfd_cache_lookup (abfd));
a131 15
  /* Set bfd_error if we did not read as much data as we expected.

     If the read failed due to an error set the bfd_error_system_call,
     else set bfd_error_file_truncated.

     A BFD backend may wish to override bfd_error_file_truncated to
     provide something more useful (eg. no_symbols or wrong_format).  */
  if (nread != size)
    {
      if (ferror (bfd_cache_lookup (abfd)))
	bfd_set_error (bfd_error_system_call);
      else
	bfd_set_error (bfd_error_file_truncated);
    }

d167 1
a167 1
  nwrote = fwrite (ptr, 1, (size_t) size, bfd_cache_lookup (abfd));
d188 1
a188 1
  ptr = real_ftell (bfd_cache_lookup (abfd));
d201 1
a201 1
  return fflush (bfd_cache_lookup(abfd));
a208 1
  FILE *f;
d214 1
a214 7
  f = bfd_cache_lookup (abfd);
  if (f == NULL)
    {
      bfd_set_error (bfd_error_system_call);
      return -1;
    }
  result = fstat (fileno (f), statbuf);
a226 1
  FILE *f;
a311 1
  f = bfd_cache_lookup (abfd);
d316 1
a316 1
  result = real_fseek (f, file_position, direction);
a360 1
  FILE *fp;
d366 1
a366 2
  fp = bfd_cache_lookup (abfd);
  if (0 != fstat (fileno (fp), &buf))
a408 1
  FILE *fp;
d414 1
a414 2
  fp = bfd_cache_lookup (abfd);
  if (0 != fstat (fileno (fp), & buf))
@


1.5.6.1
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d65 2
a66 3
/*
INTERNAL_DEFINITION
	struct bfd_iovec
d68 3
a70 1
DESCRIPTION
d72 14
a85 26
	The <<struct bfd_iovec>> contains the internal file I/O class.
	Each <<BFD>> has an instance of this class and all file I/O is
	routed through it (it is assumed that the instance implements
	all methods listed below).

.struct bfd_iovec
.{
.  {* To avoid problems with macros, a "b" rather than "f"
.     prefix is prepended to each method name.  *}
.  {* Attempt to read/write NBYTES on ABFD's IOSTREAM storing/fetching
.     bytes starting at PTR.  Return the number of bytes actually
.     transfered (a read past end-of-file returns less than NBYTES),
.     or -1 (setting <<bfd_error>>) if an error occurs.  *}
.  file_ptr (*bread) (struct bfd *abfd, void *ptr, file_ptr nbytes);
.  file_ptr (*bwrite) (struct bfd *abfd, const void *ptr,
.                      file_ptr nbytes);
.  {* Return the current IOSTREAM file offset, or -1 (setting <<bfd_error>>
.     if an error occurs.  *}
.  file_ptr (*btell) (struct bfd *abfd);
.  {* For the following, on successful completion a value of 0 is returned.
.     Otherwise, a value of -1 is returned (and  <<bfd_error>> is set).  *}
.  int (*bseek) (struct bfd *abfd, file_ptr offset, int whence);
.  int (*bclose) (struct bfd *abfd);
.  int (*bflush) (struct bfd *abfd);
.  int (*bstat) (struct bfd *abfd, struct stat *sb);
.};
a86 1
*/
d88 8
d124 1
a124 4
  if (abfd->iovec)
    nread = abfd->iovec->bread (abfd, ptr, size);
  else
    nread = 0;
d128 15
a153 1

d178 1
a178 5
  if (abfd->iovec)
    nwrote = abfd->iovec->bwrite (abfd, ptr, size);
  else
    nwrote = 0;

d199 1
a199 9
  if (abfd->iovec)
    {
      ptr = abfd->iovec->btell (abfd);

      if (abfd->my_archive)
	ptr -= abfd->origin;
    }
  else
    ptr = 0;
d201 2
d212 1
a212 4

  if (abfd->iovec)
    return abfd->iovec->bflush (abfd);
  return 0;
d220 1
d226 7
a232 5
  if (abfd->iovec)
    result = abfd->iovec->bstat (abfd, statbuf);
  else
    result = -1;

d245 1
a272 1

d331 1
d336 1
a336 5
  if (abfd->iovec)
    result = abfd->iovec->bseek (abfd, file_position, direction);
  else
    result = -1;

d381 1
d387 2
a388 4
  if (abfd->iovec == NULL)
    return 0;

  if (abfd->iovec->bstat (abfd, &buf) != 0)
d431 1
d437 2
a438 4
  if (abfd->iovec == NULL)
    return 0;

  if (abfd->iovec->bstat (abfd, &buf) != 0)
@


1.4
log
@	* aix5ppc-core.c: Fix comment typos.
	* aout-arm.c: Likewise.
	* aout-ns32k.c: Likewise.
	* aoutx.h: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd.c: Likewise.
	* bfdio.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-z8k.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* cofflink.c: Likewise.
	* cpu-alpha.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* dwarf2.c: Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d2 4
a5 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d41 24
d191 1
a191 1
bfd_vma
d199 1
a199 1
  ptr = ftell (bfd_cache_lookup (abfd));
d246 1
a246 1
  long file_position;
d307 1
a307 1
      where_am_i_now = ftell (bfd_cache_lookup (abfd));
d336 1
a336 1
  result = fseek (f, file_position, direction);
@


1.4.4.1
log
@Index: bfd/ChangeLog
2004-01-21  Andrew Cagney  <cagney@@redhat.com>

	* bfdio.c: Update copyright.  Include "bfdio.h".
	(real_ftell, real_fseek): New functions.
	(bfd_tell): Use real_ftell, change return-type to file_ptr.
	(bfd_seek): Use real_ftell and real_fseek.  Change type of
	file_position to a file_ptr.
	* cache.c: Update copyright.  Include "bfdio.h".
	(close_one): Use real_ftell.
	(bfd_cache_lookup_worker): Use real_fseek, use ufile_ptr in cast.
	* bfd-in.h: Update copyright.
	(file_ptr, ufile_ptr): Specify type using @@BFD_FILE_PTR@@.
	(bfd_tell): Make return-type "file_ptr".
	* bfd-in2.h: Re-generate.
	* configure.in (AC_CHECK_FUNCS): Check for ftello, ftello64,
	fseeko and fseeko64.
	* config.in, configure: Re-generate.
	* libbfd-in.h: Update copyright.
	(real_ftell, real_fseek): Declare.
	* libbfd.h: Re-generate.
	* elf.c (offset_vma_page_alignment): New function.
	(assign_file_positions_for_segments): Replace broken modulo code
	with offset_vma_page_alignment.
	(assign_file_positions_except_relocs): Ditto.

Index: gdb/testsuite/ChangeLog
2004-01-22  Andrew Cagney  <cagney@@redhat.com>

	* gdb.base/bigcore.exp: New file.
	* gdb.base/bigcore.c: New file.
@
text
@d2 2
a3 4

   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.

a38 24
file_ptr
real_ftell (FILE *file)
{
#if defined (HAVE_FTELLO64)
  return ftello64 (file);
#elif defined (HAVE_FTELLO)
  return ftello (file);
#else
  return ftell (file);
#endif
}

int
real_fseek (FILE *file, file_ptr offset, int whence)
{
#if defined (HAVE_FTELLO64)
  return fseeko64 (file, offset, whence);
#elif defined (HAVE_FTELLO)
  return fseeko (file, offset, whence);
#else
  return fseek (file, offset, whence);
#endif
}

d165 1
a165 1
file_ptr
d173 1
a173 1
  ptr = real_ftell (bfd_cache_lookup (abfd));
d220 1
a220 1
  file_ptr file_position;
d281 1
a281 1
      where_am_i_now = real_ftell (bfd_cache_lookup (abfd));
d310 1
a310 1
  result = real_fseek (f, file_position, direction);
@


1.4.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.3
log
@	* aout-target.h, aoutf1.h, bfdio.c, bfdwin.c: Update copyright date.
	* coff-apollo.c, coff-sparc.c, coff-w65.c, coff-we32k.c: Ditto.
	* coff-z8k.c, coffgen.c, cpu-frv.c, cpu-h8500.c, cpu-hppa.c: Ditto.
	* cpu-ia64-opc.c, cpu-m10300.c, cpu-mips.c, cpu-msp430.c: Ditto.
	* cpu-rs6000.c, cpu-z8k.c, efi-app-ia32.c, elf32-am33lin.c: Ditto.
	* gen-aout.c, hash.c, hp300hpux.c, init.c, mach-o.c: Ditto.
	* nlm-target.h, nlm.c, som.h, stabs.c, sysdep.h, xsym.h: Ditto.
@
text
@d398 1
a398 1
	This function at least allows us to answer the quesion, "is the
@


1.2
log
@Convert to C90 and a few tweaks.
@
text
@d3 1
a3 1
   2000, 2001, 2002 Free Software Foundation, Inc.
@


1.1
log
@2002-11-16  Klee Dienes  <kdienes@@apple.com>

	* Makefile.am (BFD32_LIBS): Add bfdwin.lo, bfdio.lo.
	(BFD32_LIBS_CFILES): Add bfdwin.c, bfdio.c.
	(BFD_H_FILES): Add bfdwin.c, bfdio.c.
	(LIBBFD_H_FILES): Add bfdwin.c, bfdio.c.
	Add dependencies for bfdwin.c, bfdio.c.
	* bfd.c: Remove bfd_get_mtime, bfd_get_size.
	* libbfd.c: Remove real_read, bfd_bread, _bfd_window_internal,
	bfd_init_window, bfd_free_window, bfd_get_file_window, bfd_bwrite,
	bfd_tell, bfd_flush, bfd_stat, bfd_seek.
	* bfdio.c: New file.  Contains real_read, bfd_bread, bfd_write,
	bfd_tell, bfd_flush, bfd_stat, bfd_seek, bfd_ge_mtime,
	bfd_get_size (moved from libbfd.c and bfd.c).
	* bfdwin.c New file.  Contains _bfd_window_internal,
	bfd_init_window, bfd_free_window, bfd_get_file_window (moved from
	libbfd.c and bfd.c).
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.

2002-11-16  Klee Dienes  <kdienes@@apple.com>

	* Makefile.am (DOCFILES): Add bfdwin.texi, bfdio.texi.
	(PROTOS): Add bfdio.p, bfdwin.p.
	(SRCDOC): Add bfdio.c, bfdwin.c.
	(SRCPROT): Add bfdio.c, bfdwin.c.
	(SRCIPROT): Add bfdio.c, bfdwin.c.
	(LIBBFD_H_DEP): Add bfdio.c, bfdwin.c.
	(BFD_H_DEP): Add bfdio.c, bfdwin.c.
	Add rules for bfdio.texi, bfdwin.text.
	* bfd.texinfo: Include bfdio.texi.
@
text
@a45 1
static size_t real_read PARAMS ((PTR where, size_t a, size_t b, FILE *file));
d47 1
a47 5
real_read (where, a, b, file)
     PTR where;
     size_t a;
     size_t b;
     FILE *file;
d74 1
a74 4
bfd_bread (ptr, size, abfd)
     PTR ptr;
     bfd_size_type size;
     bfd *abfd;
d83 1
a83 1
      bim = (struct bfd_in_memory *) abfd->iostream;
d121 1
a121 4
bfd_bwrite (ptr, size, abfd)
     const PTR ptr;
     bfd_size_type size;
     bfd *abfd;
d127 1
a127 1
      struct bfd_in_memory *bim = (struct bfd_in_memory *) (abfd->iostream);
d139 1
a139 1
	      bim->buffer = (bfd_byte *) bfd_realloc (bim->buffer, newsize);
d166 1
a166 2
bfd_tell (abfd)
     bfd *abfd;
d182 1
a182 2
bfd_flush (abfd)
     bfd *abfd;
d192 1
a192 3
bfd_stat (abfd, statbuf)
     bfd *abfd;
     struct stat *statbuf;
d216 1
a216 4
bfd_seek (abfd, position, direction)
     bfd *abfd;
     file_ptr position;
     int direction;
d234 1
a234 1
      bim = (struct bfd_in_memory *) abfd->iostream;
d253 1
a253 1
		  bim->buffer = (bfd_byte *) bfd_realloc (bim->buffer, newsize);
d344 1
a344 1
	long bfd_get_mtime(bfd *abfd);
d353 1
a353 2
bfd_get_mtime (abfd)
     bfd *abfd;
d374 1
a374 1
	long bfd_get_size(bfd *abfd);
d403 1
a403 2
bfd_get_size (abfd)
     bfd *abfd;
@


1.1.2.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.1.2.2
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@d46 1
d48 5
a52 1
real_read (void *where, size_t a, size_t b, FILE *file)
d79 4
a82 1
bfd_bread (void *ptr, bfd_size_type size, bfd *abfd)
d91 1
a91 1
      bim = abfd->iostream;
d129 4
a132 1
bfd_bwrite (const void *ptr, bfd_size_type size, bfd *abfd)
d138 1
a138 1
      struct bfd_in_memory *bim = abfd->iostream;
d150 1
a150 1
	      bim->buffer = bfd_realloc (bim->buffer, newsize);
d177 2
a178 1
bfd_tell (bfd *abfd)
d194 2
a195 1
bfd_flush (bfd *abfd)
d205 3
a207 1
bfd_stat (bfd *abfd, struct stat *statbuf)
d231 4
a234 1
bfd_seek (bfd *abfd, file_ptr position, int direction)
d252 1
a252 1
      bim = abfd->iostream;
d271 1
a271 1
		  bim->buffer = bfd_realloc (bim->buffer, newsize);
d362 1
a362 1
	long bfd_get_mtime (bfd *abfd);
d371 2
a372 1
bfd_get_mtime (bfd *abfd)
d393 1
a393 1
	long bfd_get_size (bfd *abfd);
d422 2
a423 1
bfd_get_size (bfd *abfd)
@


1.1.2.3
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
@


1.1.2.4
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d398 1
a398 1
	This function at least allows us to answer the question, "is the
@


