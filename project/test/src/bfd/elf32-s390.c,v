head	1.132;
access;
symbols
	sid-snapshot-20180601:1.132
	sid-snapshot-20180501:1.132
	sid-snapshot-20180401:1.132
	sid-snapshot-20180301:1.132
	sid-snapshot-20180201:1.132
	sid-snapshot-20180101:1.132
	sid-snapshot-20171201:1.132
	sid-snapshot-20171101:1.132
	sid-snapshot-20171001:1.132
	sid-snapshot-20170901:1.132
	sid-snapshot-20170801:1.132
	sid-snapshot-20170701:1.132
	sid-snapshot-20170601:1.132
	sid-snapshot-20170501:1.132
	sid-snapshot-20170401:1.132
	sid-snapshot-20170301:1.132
	sid-snapshot-20170201:1.132
	sid-snapshot-20170101:1.132
	sid-snapshot-20161201:1.132
	sid-snapshot-20161101:1.132
	sid-snapshot-20160901:1.132
	sid-snapshot-20160801:1.132
	sid-snapshot-20160701:1.132
	sid-snapshot-20160601:1.132
	sid-snapshot-20160501:1.132
	sid-snapshot-20160401:1.132
	sid-snapshot-20160301:1.132
	sid-snapshot-20160201:1.132
	sid-snapshot-20160101:1.132
	sid-snapshot-20151201:1.132
	sid-snapshot-20151101:1.132
	sid-snapshot-20151001:1.132
	sid-snapshot-20150901:1.132
	sid-snapshot-20150801:1.132
	sid-snapshot-20150701:1.132
	sid-snapshot-20150601:1.132
	sid-snapshot-20150501:1.132
	sid-snapshot-20150401:1.132
	sid-snapshot-20150301:1.132
	sid-snapshot-20150201:1.132
	sid-snapshot-20150101:1.132
	sid-snapshot-20141201:1.132
	sid-snapshot-20141101:1.132
	sid-snapshot-20141001:1.132
	sid-snapshot-20140901:1.132
	sid-snapshot-20140801:1.132
	sid-snapshot-20140701:1.132
	sid-snapshot-20140601:1.132
	sid-snapshot-20140501:1.132
	sid-snapshot-20140401:1.132
	sid-snapshot-20140301:1.132
	sid-snapshot-20140201:1.132
	sid-snapshot-20140101:1.132
	sid-snapshot-20131201:1.132
	sid-snapshot-20131101:1.132
	sid-snapshot-20131001:1.132
	binutils-2_24-branch:1.132.0.2
	binutils-2_24-branchpoint:1.132
	binutils-2_21_1:1.107
	sid-snapshot-20130901:1.132
	gdb_7_6_1-2013-08-30-release:1.128
	sid-snapshot-20130801:1.132
	sid-snapshot-20130701:1.130
	sid-snapshot-20130601:1.130
	sid-snapshot-20130501:1.130
	gdb_7_6-2013-04-26-release:1.128
	sid-snapshot-20130401:1.130
	binutils-2_23_2:1.122.4.1
	gdb_7_6-branch:1.128.0.2
	gdb_7_6-2013-03-12-branchpoint:1.128
	sid-snapshot-20130301:1.128
	sid-snapshot-20130201:1.126
	sid-snapshot-20130101:1.125
	sid-snapshot-20121201:1.125
	gdb_7_5_1-2012-11-29-release:1.122
	binutils-2_23_1:1.122.4.1
	sid-snapshot-20121101:1.124
	binutils-2_23:1.122
	sid-snapshot-20121001:1.124
	sid-snapshot-20120901:1.122
	gdb_7_5-2012-08-17-release:1.122
	sid-snapshot-20120801:1.122
	binutils-2_23-branch:1.122.0.4
	binutils-2_23-branchpoint:1.122
	gdb_7_5-branch:1.122.0.2
	gdb_7_5-2012-07-18-branchpoint:1.122
	sid-snapshot-20120701:1.120
	sid-snapshot-20120601:1.119
	sid-snapshot-20120501:1.118
	binutils-2_22_branch:1.108.0.4
	gdb_7_4_1-2012-04-26-release:1.109
	sid-snapshot-20120401:1.116
	sid-snapshot-20120301:1.111
	sid-snapshot-20120201:1.110
	gdb_7_4-2012-01-24-release:1.109
	sid-snapshot-20120101:1.110
	gdb_7_4-branch:1.109.0.2
	gdb_7_4-2011-12-13-branchpoint:1.109
	sid-snapshot-20111201:1.109
	binutils-2_22:1.108
	sid-snapshot-20111101:1.109
	sid-snapshot-20111001:1.108
	binutils-2_22-branch:1.108.0.2
	binutils-2_22-branchpoint:1.108
	gdb_7_3_1-2011-09-04-release:1.107
	sid-snapshot-20110901:1.108
	sid-snapshot-20110801:1.108
	gdb_7_3-2011-07-26-release:1.107
	sid-snapshot-20110701:1.108
	sid-snapshot-20110601:1.107
	sid-snapshot-20110501:1.107
	gdb_7_3-branch:1.107.0.4
	gdb_7_3-2011-04-01-branchpoint:1.107
	sid-snapshot-20110401:1.107
	sid-snapshot-20110301:1.107
	sid-snapshot-20110201:1.107
	sid-snapshot-20110101:1.107
	binutils-2_21:1.107
	sid-snapshot-20101201:1.107
	binutils-2_21-branch:1.107.0.2
	binutils-2_21-branchpoint:1.107
	sid-snapshot-20101101:1.107
	sid-snapshot-20101001:1.106
	binutils-2_20_1:1.102
	gdb_7_2-2010-09-02-release:1.104
	sid-snapshot-20100901:1.106
	sid-snapshot-20100801:1.104
	gdb_7_2-branch:1.104.0.4
	gdb_7_2-2010-07-07-branchpoint:1.104
	sid-snapshot-20100701:1.104
	sid-snapshot-20100601:1.104
	sid-snapshot-20100501:1.104
	sid-snapshot-20100401:1.104
	gdb_7_1-2010-03-18-release:1.104
	sid-snapshot-20100301:1.104
	gdb_7_1-branch:1.104.0.2
	gdb_7_1-2010-02-18-branchpoint:1.104
	sid-snapshot-20100201:1.103
	sid-snapshot-20100101:1.102
	gdb_7_0_1-2009-12-22-release:1.102
	sid-snapshot-20091201:1.102
	sid-snapshot-20091101:1.102
	binutils-2_20:1.102
	gdb_7_0-2009-10-06-release:1.102
	sid-snapshot-20091001:1.102
	gdb_7_0-branch:1.102.0.4
	gdb_7_0-2009-09-16-branchpoint:1.102
	arc-sim-20090309:1.97
	binutils-arc-20081103-branch:1.97.0.20
	binutils-arc-20081103-branchpoint:1.97
	binutils-2_20-branch:1.102.0.2
	binutils-2_20-branchpoint:1.102
	sid-snapshot-20090901:1.101
	sid-snapshot-20090801:1.101
	msnyder-checkpoint-072509-branch:1.101.0.4
	msnyder-checkpoint-072509-branchpoint:1.101
	sid-snapshot-20090701:1.101
	dje-cgen-play1-branch:1.101.0.2
	dje-cgen-play1-branchpoint:1.101
	sid-snapshot-20090601:1.99
	sid-snapshot-20090501:1.99
	sid-snapshot-20090401:1.99
	arc-20081103-branch:1.97.0.18
	arc-20081103-branchpoint:1.97
	arc-insight_6_8-branch:1.97.0.16
	arc-insight_6_8-branchpoint:1.97
	insight_6_8-branch:1.97.0.14
	insight_6_8-branchpoint:1.97
	sid-snapshot-20090301:1.98
	binutils-2_19_1:1.97
	sid-snapshot-20090201:1.98
	sid-snapshot-20090101:1.98
	reverse-20081226-branch:1.98.0.2
	reverse-20081226-branchpoint:1.98
	sid-snapshot-20081201:1.98
	multiprocess-20081120-branch:1.97.0.12
	multiprocess-20081120-branchpoint:1.97
	sid-snapshot-20081101:1.97
	binutils-2_19:1.97
	sid-snapshot-20081001:1.97
	reverse-20080930-branch:1.97.0.10
	reverse-20080930-branchpoint:1.97
	binutils-2_19-branch:1.97.0.8
	binutils-2_19-branchpoint:1.97
	sid-snapshot-20080901:1.97
	sid-snapshot-20080801:1.97
	reverse-20080717-branch:1.97.0.6
	reverse-20080717-branchpoint:1.97
	sid-snapshot-20080701:1.97
	msnyder-reverse-20080609-branch:1.97.0.4
	msnyder-reverse-20080609-branchpoint:1.97
	drow-reverse-20070409-branch:1.91.0.2
	drow-reverse-20070409-branchpoint:1.91
	sid-snapshot-20080601:1.97
	sid-snapshot-20080501:1.97
	sid-snapshot-20080403:1.97
	sid-snapshot-20080401:1.97
	gdb_6_8-2008-03-27-release:1.97
	sid-snapshot-20080301:1.97
	gdb_6_8-branch:1.97.0.2
	gdb_6_8-2008-02-26-branchpoint:1.97
	sid-snapshot-20080201:1.96
	sid-snapshot-20080101:1.95
	sid-snapshot-20071201:1.95
	sid-snapshot-20071101:1.95
	gdb_6_7_1-2007-10-29-release:1.94
	gdb_6_7-2007-10-10-release:1.94
	sid-snapshot-20071001:1.95
	gdb_6_7-branch:1.94.0.4
	gdb_6_7-2007-09-07-branchpoint:1.94
	binutils-2_18:1.94
	binutils-2_18-branch:1.94.0.2
	binutils-2_18-branchpoint:1.94
	insight_6_6-20070208-release:1.89
	binutils-csl-coldfire-4_1-32:1.82
	binutils-csl-sourcerygxx-4_1-32:1.82
	gdb_6_6-2006-12-18-release:1.89
	binutils-csl-innovasic-fido-3_4_4-33:1.82
	binutils-csl-sourcerygxx-3_4_4-32:1.68
	binutils-csl-coldfire-4_1-30:1.82
	binutils-csl-sourcerygxx-4_1-30:1.82
	binutils-csl-coldfire-4_1-28:1.82
	binutils-csl-sourcerygxx-4_1-29:1.82
	binutils-csl-sourcerygxx-4_1-28:1.82
	gdb_6_6-branch:1.89.0.2
	gdb_6_6-2006-11-15-branchpoint:1.89
	binutils-csl-arm-2006q3-27:1.82
	binutils-csl-sourcerygxx-4_1-27:1.82
	binutils-csl-arm-2006q3-26:1.82
	binutils-csl-sourcerygxx-4_1-26:1.82
	binutils-csl-sourcerygxx-4_1-25:1.82
	binutils-csl-sourcerygxx-4_1-24:1.82
	binutils-csl-sourcerygxx-4_1-23:1.82
	insight_6_5-20061003-release:1.83
	gdb-csl-symbian-6_4_50_20060226-12:1.80
	binutils-csl-sourcerygxx-4_1-21:1.82
	binutils-csl-arm-2006q3-21:1.82
	binutils-csl-sourcerygxx-4_1-22:1.82
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.82
	binutils-csl-sourcerygxx-4_1-20:1.82
	binutils-csl-arm-2006q3-19:1.82
	binutils-csl-sourcerygxx-4_1-19:1.82
	binutils-csl-sourcerygxx-4_1-18:1.82
	binutils-csl-renesas-4_1-9:1.82
	gdb-csl-sourcerygxx-3_4_4-25:1.79
	binutils-csl-sourcerygxx-3_4_4-25:1.68
	nickrob-async-20060828-mergepoint:1.84
	gdb-csl-symbian-6_4_50_20060226-11:1.80
	binutils-csl-renesas-4_1-8:1.82
	binutils-csl-renesas-4_1-7:1.82
	binutils-csl-renesas-4_1-6:1.82
	gdb-csl-sourcerygxx-4_1-17:1.80
	binutils-csl-sourcerygxx-4_1-17:1.82
	gdb-csl-20060226-branch-local-2:1.80
	gdb-csl-sourcerygxx-4_1-14:1.80
	binutils-csl-sourcerygxx-4_1-14:1.82
	binutils-csl-sourcerygxx-4_1-15:1.82
	gdb-csl-sourcerygxx-4_1-13:1.80
	binutils-csl-sourcerygxx-4_1-13:1.82
	binutils-2_17:1.82
	gdb-csl-sourcerygxx-4_1-12:1.80
	binutils-csl-sourcerygxx-4_1-12:1.82
	gdb-csl-sourcerygxx-3_4_4-21:1.80
	binutils-csl-sourcerygxx-3_4_4-21:1.82
	gdb_6_5-20060621-release:1.83
	binutils-csl-wrs-linux-3_4_4-24:1.68
	binutils-csl-wrs-linux-3_4_4-23:1.68
	gdb-csl-sourcerygxx-4_1-9:1.80
	binutils-csl-sourcerygxx-4_1-9:1.82
	gdb-csl-sourcerygxx-4_1-8:1.80
	binutils-csl-sourcerygxx-4_1-8:1.82
	gdb-csl-sourcerygxx-4_1-7:1.80
	binutils-csl-sourcerygxx-4_1-7:1.82
	gdb-csl-arm-2006q1-6:1.80
	binutils-csl-arm-2006q1-6:1.82
	gdb-csl-sourcerygxx-4_1-6:1.80
	binutils-csl-sourcerygxx-4_1-6:1.82
	binutils-csl-wrs-linux-3_4_4-22:1.68
	gdb-csl-symbian-6_4_50_20060226-10:1.80
	gdb-csl-symbian-6_4_50_20060226-9:1.80
	gdb-csl-symbian-6_4_50_20060226-8:1.80
	gdb-csl-coldfire-4_1-11:1.80
	binutils-csl-coldfire-4_1-11:1.82
	gdb-csl-sourcerygxx-3_4_4-19:1.80
	binutils-csl-sourcerygxx-3_4_4-19:1.82
	gdb-csl-coldfire-4_1-10:1.80
	gdb_6_5-branch:1.83.0.4
	gdb_6_5-2006-05-14-branchpoint:1.83
	binutils-csl-coldfire-4_1-10:1.82
	gdb-csl-sourcerygxx-4_1-5:1.80
	binutils-csl-sourcerygxx-4_1-5:1.82
	nickrob-async-20060513-branch:1.83.0.2
	nickrob-async-20060513-branchpoint:1.83
	gdb-csl-sourcerygxx-4_1-4:1.80
	binutils-csl-sourcerygxx-4_1-4:1.82
	msnyder-reverse-20060502-branch:1.82.0.10
	msnyder-reverse-20060502-branchpoint:1.82
	binutils-csl-wrs-linux-3_4_4-21:1.68
	gdb-csl-morpho-4_1-4:1.80
	binutils-csl-morpho-4_1-4:1.82
	gdb-csl-sourcerygxx-3_4_4-17:1.80
	binutils-csl-sourcerygxx-3_4_4-17:1.82
	binutils-csl-wrs-linux-3_4_4-20:1.68
	readline_5_1-import-branch:1.82.0.8
	readline_5_1-import-branchpoint:1.82
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.80
	binutils-2_17-branch:1.82.0.6
	binutils-2_17-branchpoint:1.82
	gdb-csl-symbian-20060226-branch:1.80.0.4
	gdb-csl-symbian-20060226-branchpoint:1.80
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.80
	msnyder-reverse-20060331-branch:1.82.0.4
	msnyder-reverse-20060331-branchpoint:1.82
	binutils-csl-2_17-branch:1.82.0.2
	binutils-csl-2_17-branchpoint:1.82
	gdb-csl-available-20060303-branch:1.81.0.2
	gdb-csl-available-20060303-branchpoint:1.81
	gdb-csl-20060226-branch:1.80.0.2
	gdb-csl-20060226-branchpoint:1.80
	gdb_6_4-20051202-release:1.79
	msnyder-fork-checkpoint-branch:1.79.0.6
	msnyder-fork-checkpoint-branchpoint:1.79
	gdb-csl-gxxpro-6_3-branch:1.79.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.79
	gdb_6_4-branch:1.79.0.2
	gdb_6_4-2005-11-01-branchpoint:1.79
	gdb-csl-arm-20051020-branch:1.78.0.2
	gdb-csl-arm-20051020-branchpoint:1.78
	binutils-csl-gxxpro-3_4-branch:1.68.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.68
	binutils-2_16_1:1.68
	msnyder-tracepoint-checkpoint-branch:1.72.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.72
	gdb-csl-arm-20050325-2005-q1b:1.68
	binutils-csl-arm-2005q1b:1.68
	binutils-2_16:1.68
	gdb-csl-arm-20050325-2005-q1a:1.68
	binutils-csl-arm-2005q1a:1.68
	csl-arm-20050325-branch:1.68.0.6
	csl-arm-20050325-branchpoint:1.68
	binutils-csl-arm-2005q1-branch:1.68.0.4
	binutils-csl-arm-2005q1-branchpoint:1.68
	binutils-2_16-branch:1.68.0.2
	binutils-2_16-branchpoint:1.68
	csl-arm-2004-q3d:1.67
	gdb_6_3-20041109-release:1.66
	gdb_6_3-branch:1.66.0.2
	gdb_6_3-20041019-branchpoint:1.66
	csl-arm-2004-q3:1.66
	drow_intercu-merge-20040921:1.66
	drow_intercu-merge-20040915:1.64
	jimb-gdb_6_2-e500-branch:1.63.0.6
	jimb-gdb_6_2-e500-branchpoint:1.63
	gdb_6_2-20040730-release:1.63
	gdb_6_2-branch:1.63.0.2
	gdb_6_2-2004-07-10-gmt-branchpoint:1.63
	gdb_6_1_1-20040616-release:1.57
	binutils-2_15:1.56.6.2
	binutils-2_15-branchpoint:1.56
	csl-arm-2004-q1a:1.61
	csl-arm-2004-q1:1.60
	gdb_6_1-2004-04-05-release:1.57
	drow_intercu-merge-20040402:1.60
	drow_intercu-merge-20040327:1.59
	ezannoni_pie-20040323-branch:1.58.0.2
	ezannoni_pie-20040323-branchpoint:1.58
	cagney_tramp-20040321-mergepoint:1.57
	cagney_tramp-20040309-branch:1.57.0.4
	cagney_tramp-20040309-branchpoint:1.57
	gdb_6_1-branch:1.57.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.57
	drow_intercu-20040221-branch:1.56.0.8
	drow_intercu-20040221-branchpoint:1.56
	binutils-2_15-branch:1.56.0.6
	cagney_bfdfile-20040213-branch:1.56.0.4
	cagney_bfdfile-20040213-branchpoint:1.56
	drow-cplus-merge-20040208:1.56
	carlton_dictionary-20040126-merge:1.56
	cagney_bigcore-20040122-branch:1.56.0.2
	cagney_bigcore-20040122-branchpoint:1.56
	drow-cplus-merge-20040113:1.56
	csl-arm-2003-q4:1.56
	drow-cplus-merge-20031224:1.56
	drow-cplus-merge-20031220:1.56
	carlton_dictionary-20031215-merge:1.56
	drow-cplus-merge-20031214:1.56
	carlton-dictionary-20031111-merge:1.51
	gdb_6_0-2003-10-04-release:1.41
	kettenis_sparc-20030918-branch:1.48.0.6
	kettenis_sparc-20030918-branchpoint:1.48
	carlton_dictionary-20030917-merge:1.48
	ezannoni_pie-20030916-branchpoint:1.48
	ezannoni_pie-20030916-branch:1.48.0.4
	cagney_x86i386-20030821-branch:1.48.0.2
	cagney_x86i386-20030821-branchpoint:1.48
	carlton_dictionary-20030805-merge:1.45
	carlton_dictionary-20030627-merge:1.42
	gdb_6_0-branch:1.41.0.6
	gdb_6_0-2003-06-23-branchpoint:1.41
	jimb-ppc64-linux-20030613-branch:1.41.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.41
	binutils-2_14:1.37.18.1
	cagney_convert-20030606-branch:1.41.0.2
	cagney_convert-20030606-branchpoint:1.41
	cagney_writestrings-20030508-branch:1.37.0.20
	cagney_writestrings-20030508-branchpoint:1.37
	jimb-ppc64-linux-20030528-branch:1.40.0.6
	jimb-ppc64-linux-20030528-branchpoint:1.40
	carlton_dictionary-20030523-merge:1.40
	cagney_fileio-20030521-branch:1.40.0.4
	cagney_fileio-20030521-branchpoint:1.40
	kettenis_i386newframe-20030517-mergepoint:1.40
	jimb-ppc64-linux-20030509-branch:1.40.0.2
	jimb-ppc64-linux-20030509-branchpoint:1.40
	kettenis_i386newframe-20030504-mergepoint:1.37
	carlton_dictionary-20030430-merge:1.37
	binutils-2_14-branch:1.37.0.18
	binutils-2_14-branchpoint:1.37
	kettenis_i386newframe-20030419-branch:1.37.0.16
	kettenis_i386newframe-20030419-branchpoint:1.37
	carlton_dictionary-20030416-merge:1.37
	cagney_frameaddr-20030409-mergepoint:1.37
	kettenis_i386newframe-20030406-branch:1.37.0.14
	kettenis_i386newframe-20030406-branchpoint:1.37
	cagney_frameaddr-20030403-branchpoint:1.37
	cagney_frameaddr-20030403-branch:1.37.0.12
	cagney_framebase-20030330-mergepoint:1.37
	cagney_framebase-20030326-branch:1.37.0.10
	cagney_framebase-20030326-branchpoint:1.37
	cagney_lazyid-20030317-branch:1.37.0.8
	cagney_lazyid-20030317-branchpoint:1.37
	kettenis-i386newframe-20030316-mergepoint:1.37
	offbyone-20030313-branch:1.37.0.6
	offbyone-20030313-branchpoint:1.37
	kettenis-i386newframe-20030308-branch:1.37.0.4
	kettenis-i386newframe-20030308-branchpoint:1.37
	carlton_dictionary-20030305-merge:1.37
	cagney_offbyone-20030303-branch:1.37.0.2
	cagney_offbyone-20030303-branchpoint:1.37
	carlton_dictionary-20030207-merge:1.34
	interps-20030202-branch:1.34.0.2
	interps-20030202-branchpoint:1.34
	cagney-unwind-20030108-branch:1.32.0.2
	cagney-unwind-20030108-branchpoint:1.32
	binutils-2_13_2_1:1.28.2.1
	binutils-2_13_2:1.28.2.1
	carlton_dictionary-20021223-merge:1.32
	gdb_5_3-2002-12-12-release:1.30
	carlton_dictionary-20021115-merge:1.30
	binutils-2_13_1:1.28.2.1
	kseitz_interps-20021105-merge:1.30
	kseitz_interps-20021103-merge:1.30
	drow-cplus-merge-20021020:1.30
	drow-cplus-merge-20021025:1.30
	carlton_dictionary-20021025-merge:1.30
	carlton_dictionary-20021011-merge:1.30
	drow-cplus-branch:1.30.0.12
	drow-cplus-branchpoint:1.30
	kseitz_interps-20020930-merge:1.30
	carlton_dictionary-20020927-merge:1.30
	carlton_dictionary-branch:1.30.0.10
	carlton_dictionary-20020920-branchpoint:1.30
	sid-20020905-branchpoint:1.30
	sid-20020905-branch:1.30.0.8
	gdb_5_3-branch:1.30.0.6
	gdb_5_3-2002-09-04-branchpoint:1.30
	kseitz_interps-20020829-merge:1.30
	cagney_sysregs-20020825-branch:1.30.0.4
	cagney_sysregs-20020825-branchpoint:1.30
	readline_4_3-import-branch:1.30.0.2
	readline_4_3-import-branchpoint:1.30
	binutils-2_13:1.28
	gdb_5_2_1-2002-07-23-release:1.22
	binutils-2_13-branchpoint:1.28
	binutils-2_13-branch:1.28.0.2
	kseitz_interps-20020528-branch:1.25.0.4
	kseitz_interps-20020528-branchpoint:1.25
	cagney_regbuf-20020515-branch:1.25.0.2
	cagney_regbuf-20020515-branchpoint:1.25
	binutils-2_12_1:1.20.2.3
	jimb-macro-020506-branch:1.24.0.2
	jimb-macro-020506-branchpoint:1.24
	gdb_5_2-2002-04-29-release:1.22
	binutils-2_12:1.20.2.1
	gdb_5_2-branch:1.22.0.2
	gdb_5_2-2002-03-03-branchpoint:1.22
	binutils-2_12-branch:1.20.0.2
	binutils-2_12-branchpoint:1.20
	gdb_5_1_1-2002-01-24-release:1.2
	gdb_5_1_0_1-2002-01-03-release:1.2
	cygnus_cvs_20020108_pre:1.18
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	x86_64versiong3:1.1
	binutils_latest_snapshot:1.132;
locks; strict;
comment	@ * @;


1.132
date	2013.07.05.09.51.00;	author krebbel;	state Exp;
branches;
next	1.131;

1.131
date	2013.07.05.09.45.43;	author krebbel;	state Exp;
branches;
next	1.130;

1.130
date	2013.03.30.10.14.15;	author amodra;	state Exp;
branches;
next	1.129;

1.129
date	2013.03.27.13.37.51;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2013.02.21.03.02.29;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2013.02.10.04.36.32;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2013.01.10.20.03.53;	author hjl;	state Exp;
branches;
next	1.125;

1.125
date	2012.11.05.12.31.08;	author krebbel;	state Exp;
branches;
next	1.124;

1.124
date	2012.09.03.12.03.47;	author krebbel;	state Exp;
branches;
next	1.123;

1.123
date	2012.09.02.12.17.26;	author hjl;	state Exp;
branches;
next	1.122;

1.122
date	2012.07.13.15.47.23;	author krebbel;	state Exp;
branches
	1.122.4.1;
next	1.121;

1.121
date	2012.07.13.14.22.47;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2012.06.29.14.46.00;	author amodra;	state Exp;
branches;
next	1.119;

1.119
date	2012.05.07.03.27.50;	author macro;	state Exp;
branches;
next	1.118;

1.118
date	2012.04.24.05.12.34;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2012.04.20.11.45.54;	author krebbel;	state Exp;
branches;
next	1.116;

1.116
date	2012.03.30.13.38.03;	author krebbel;	state Exp;
branches;
next	1.115;

1.115
date	2012.03.30.13.37.13;	author krebbel;	state Exp;
branches;
next	1.114;

1.114
date	2012.03.30.13.36.22;	author krebbel;	state Exp;
branches;
next	1.113;

1.113
date	2012.03.30.13.35.33;	author krebbel;	state Exp;
branches;
next	1.112;

1.112
date	2012.03.13.06.04.35;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2012.02.17.08.38.06;	author krebbel;	state Exp;
branches;
next	1.110;

1.110
date	2011.12.22.15.00.42;	author sky;	state Exp;
branches;
next	1.109;

1.109
date	2011.10.19.07.17.14;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2011.06.13.00.59.11;	author amodra;	state Exp;
branches
	1.108.2.1;
next	1.107;

1.107
date	2010.10.25.15.54.14;	author drow;	state Exp;
branches;
next	1.106;

1.106
date	2010.08.25.14.53.43;	author hjl;	state Exp;
branches;
next	1.105;

1.105
date	2010.08.18.12.24.06;	author palves;	state Exp;
branches;
next	1.104;

1.104
date	2010.02.04.09.16.39;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2010.01.21.11.40.28;	author krebbel;	state Exp;
branches;
next	1.102;

1.102
date	2009.09.02.07.18.36;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2009.06.18.14.18.29;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.17.18.08.35;	author hjl;	state Exp;
branches;
next	1.99;

1.99
date	2009.03.20.12.57.15;	author krebbel;	state Exp;
branches;
next	1.98;

1.98
date	2008.11.25.13.03.55;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2008.02.12.11.32.30;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2008.01.11.09.07.03;	author gingold;	state Exp;
branches;
next	1.95;

1.95
date	2007.09.26.13.45.32;	author jbeulich;	state Exp;
branches;
next	1.94;

1.94
date	2007.07.03.14.26.41;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2007.05.15.13.55.53;	author hjl;	state Exp;
branches;
next	1.92;

1.92
date	2007.04.26.14.46.57;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2007.03.26.12.23.00;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2007.03.07.08.54.34;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2006.11.03.00.58.09;	author drow;	state Exp;
branches;
next	1.88;

1.88
date	2006.10.17.13.41.47;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2006.09.28.13.27.32;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2006.09.20.14.38.17;	author sky;	state Exp;
branches;
next	1.85;

1.85
date	2006.09.16.18.12.14;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2006.06.23.02.58.00;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.05.13.21.34;	author sky;	state Exp;
branches;
next	1.82;

1.82
date	2006.03.16.12.20.15;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2006.02.27.08.48.28;	author rsandifo;	state Exp;
branches;
next	1.80;

1.80
date	2006.02.21.01.51.58;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2005.10.25.16.19.06;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2005.10.06.19.21.14;	author drow;	state Exp;
branches;
next	1.77;

1.77
date	2005.08.25.02.32.10;	author hjl;	state Exp;
branches;
next	1.76;

1.76
date	2005.08.18.01.28.24;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2005.07.08.06.20.00;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2005.07.05.09.44.20;	author jakub;	state Exp;
branches;
next	1.73;

1.73
date	2005.06.20.18.12.07;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2005.05.05.14.33.50;	author hjl;	state Exp;
branches;
next	1.71;

1.71
date	2005.05.04.15.53.19;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2005.05.04.11.00.14;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2005.05.04.07.19.24;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2005.01.11.09.32.50;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2004.10.21.15.28.24;	author hjl;	state Exp;
branches;
next	1.66;

1.66
date	2004.09.17.07.14.28;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2004.09.16.14.52.05;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2004.08.13.03.15.57;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2004.06.29.13.46.31;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2004.06.24.04.46.21;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2004.04.22.14.45.31;	author jakub;	state Exp;
branches;
next	1.60;

1.60
date	2004.03.27.10.58.06;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2004.03.25.12.48.36;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2004.03.22.02.28.16;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2004.02.27.10.03.05;	author sky;	state Exp;
branches;
next	1.56;

1.56
date	2003.12.04.03.03.27;	author amodra;	state Exp;
branches
	1.56.6.1
	1.56.8.1;
next	1.55;

1.55
date	2003.11.27.18.49.38;	author kazu;	state Exp;
branches;
next	1.54;

1.54
date	2003.11.20.09.54.07;	author sky;	state Exp;
branches;
next	1.53;

1.53
date	2003.11.17.21.31.10;	author drow;	state Exp;
branches;
next	1.52;

1.52
date	2003.11.13.15.56.50;	author sky;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.05.13.17.09;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2003.11.04.06.16.35;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2003.11.03.15.17.39;	author drow;	state Exp;
branches;
next	1.48;

1.48
date	2003.08.20.08.37.17;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2003.08.11.14.26.10;	author jakub;	state Exp;
branches;
next	1.46;

1.46
date	2003.08.07.08.38.07;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2003.07.07.11.14.40;	author jakub;	state Exp;
branches;
next	1.44;

1.44
date	2003.07.04.13.53.37;	author jakub;	state Exp;
branches;
next	1.43;

1.43
date	2003.07.01.14.44.59;	author sky;	state Exp;
branches;
next	1.42;

1.42
date	2003.06.25.06.40.22;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2003.05.30.15.50.10;	author jakub;	state Exp;
branches;
next	1.40;

1.40
date	2003.05.09.16.41.42;	author sky;	state Exp;
branches;
next	1.39;

1.39
date	2003.05.09.15.29.46;	author sky;	state Exp;
branches;
next	1.38;

1.38
date	2003.05.09.15.17.54;	author sky;	state Exp;
branches;
next	1.37;

1.37
date	2003.02.19.14.14.16;	author amodra;	state Exp;
branches
	1.37.16.1
	1.37.18.1;
next	1.36;

1.36
date	2003.02.17.18.24.39;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2003.02.10.13.22.12;	author jakub;	state Exp;
branches;
next	1.34;

1.34
date	2003.01.24.17.12.42;	author sky;	state Exp;
branches;
next	1.33;

1.33
date	2003.01.20.11.44.48;	author sky;	state Exp;
branches;
next	1.32;

1.32
date	2002.11.30.08.39.38;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.28.11.55.40;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.22.01.27.19;	author amodra;	state Exp;
branches
	1.30.10.1
	1.30.12.1;
next	1.29;

1.29
date	2002.07.23.12.29.32;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.07.11.05.33.28;	author amodra;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2002.07.01.08.06.44;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.03.01.57.09;	author kazu;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.07.00.16.52;	author amodra;	state Exp;
branches
	1.25.2.1
	1.25.4.1;
next	1.24;

1.24
date	2002.04.04.19.53.36;	author drow;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.28.03.27.44;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2002.02.19.18.22.16;	author sky;	state Exp;
branches;
next	1.21;

1.21
date	2002.02.19.12.40.26;	author jakub;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.05.00.00.23;	author amodra;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2002.01.29.11.14.35;	author sky;	state Exp;
branches;
next	1.18;

1.18
date	2001.12.18.16.21.38;	author sky;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2001.12.07.12.23.26;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.07.11.12.18;	author jakub;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.23.12.17.16;	author jakub;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.14.18.48.26;	author sky;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.10.00.23.35;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.08.18.45.46;	author sky;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.15.07.28.45;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.29.06.21.59;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.24.01.38.31;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.20.23.30.35;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.20.10.37.35;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.18.09.57.24;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.27.08.59.07;	author aj;	state Exp;
branches;
next	1.3;

1.3
date	2001.08.21.08.40.23;	author aj;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.08.21.04.00;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.10.00.55.54;	author nickc;	state Exp;
branches;
next	;

1.122.4.1
date	2012.11.12.09.04.13;	author gingold;	state Exp;
branches;
next	;

1.108.2.1
date	2012.05.11.12.24.27;	author nickc;	state Exp;
branches;
next	;

1.56.6.1
date	2004.04.08.12.41.43;	author amodra;	state Exp;
branches;
next	1.56.6.2;

1.56.6.2
date	2004.04.09.18.28.00;	author drow;	state Exp;
branches;
next	;

1.56.8.1
date	2004.03.27.17.37.34;	author drow;	state Exp;
branches;
next	1.56.8.2;

1.56.8.2
date	2004.04.02.16.47.35;	author drow;	state Exp;
branches;
next	1.56.8.3;

1.56.8.3
date	2004.09.16.17.00.26;	author drow;	state Exp;
branches;
next	1.56.8.4;

1.56.8.4
date	2004.09.21.20.44.02;	author drow;	state Exp;
branches;
next	;

1.37.16.1
date	2003.05.18.09.43.42;	author kettenis;	state Exp;
branches;
next	;

1.37.18.1
date	2003.05.15.19.20.22;	author drow;	state Exp;
branches;
next	;

1.30.10.1
date	2002.12.23.19.37.44;	author carlton;	state Exp;
branches;
next	1.30.10.2;

1.30.10.2
date	2003.02.07.19.17.38;	author carlton;	state Exp;
branches;
next	1.30.10.3;

1.30.10.3
date	2003.03.06.00.56.15;	author carlton;	state Exp;
branches;
next	1.30.10.4;

1.30.10.4
date	2003.05.23.18.40.24;	author carlton;	state Exp;
branches;
next	1.30.10.5;

1.30.10.5
date	2003.06.27.21.49.16;	author carlton;	state Exp;
branches;
next	1.30.10.6;

1.30.10.6
date	2003.08.05.17.12.48;	author carlton;	state Exp;
branches;
next	1.30.10.7;

1.30.10.7
date	2003.09.17.21.27.52;	author carlton;	state Exp;
branches;
next	1.30.10.8;

1.30.10.8
date	2003.11.11.23.50.18;	author carlton;	state Exp;
branches;
next	1.30.10.9;

1.30.10.9
date	2003.12.15.23.59.28;	author carlton;	state Exp;
branches;
next	;

1.30.12.1
date	2003.12.14.20.26.41;	author drow;	state Exp;
branches;
next	;

1.28.2.1
date	2002.08.22.01.34.15;	author amodra;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.15.16.42.37;	author cagney;	state Exp;
branches;
next	;

1.25.4.1
date	2002.06.20.01.30.20;	author kseitz;	state Exp;
branches;
next	1.25.4.2;

1.25.4.2
date	2002.07.22.21.46.44;	author kseitz;	state Exp;
branches;
next	1.25.4.3;

1.25.4.3
date	2002.08.09.18.34.14;	author kseitz;	state Exp;
branches;
next	1.25.4.4;

1.25.4.4
date	2002.08.30.22.52.36;	author kseitz;	state Exp;
branches;
next	;

1.20.2.1
date	2002.02.19.13.10.22;	author jakub;	state Exp;
branches;
next	1.20.2.2;

1.20.2.2
date	2002.04.04.14.52.58;	author amodra;	state Exp;
branches;
next	1.20.2.3;

1.20.2.3
date	2002.05.09.11.50.26;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.132
log
@2013-07-05  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

bfd/
	* elf32-s390.c: Rewrite GOT accesses using larl if possible.
	* elf64-s390.c: Likewise.

ld/testsuite/
	* ld-s390/gotreloc-1.s: New file.
	* ld-s390/gotreloc-1.ver: New file.
	* ld-s390/gotreloc_31-1.dd: New file.
	* ld-s390/gotreloc_64-1.dd: New file.
	* ld-s390/s390.exp: Run the new tests. Run 31 bit tests also on 64
	bit.
@
text
@/* IBM S/390-specific support for 32-bit ELF
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2011, 2012 Free Software Foundation, Inc.
   Contributed by Carl B. Pedersen and Martin Schwidefsky.

   This file is part of BFD, the Binary File Descriptor library.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libbfd.h"
#include "elf-bfd.h"
#include "elf/s390.h"

static bfd_reloc_status_type
s390_tls_reloc (bfd *, arelent *, asymbol *, void *,
		asection *, bfd *, char **);
static bfd_reloc_status_type
s390_elf_ldisp_reloc (bfd *, arelent *, asymbol *, void *,
		      asection *, bfd *, char **);

/* The relocation "howto" table.  */

static reloc_howto_type elf_howto_table[] =
{
  HOWTO (R_390_NONE,		/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = 2 byte, 2 = 4 byte) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 bfd_elf_generic_reloc, /* special_function */
	 "R_390_NONE",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE),		/* pcrel_offset */

  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_8",        FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_12",       FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_16",       FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_32",       FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32",     FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT12",    FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT32",    FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32",    FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_COPY,      0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_COPY",     FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GLOB_DAT", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_JMP_SLOT", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_RELATIVE,  0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_RELATIVE", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF32", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTPC,     0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPC",    FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT16",    FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16",     FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16DBL",  FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32DBL",  FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,0xffffffff, TRUE),
  EMPTY_HOWTO (R_390_64),	/* Empty entry for R_390_64.  */
  EMPTY_HOWTO (R_390_PC64),	/* Empty entry for R_390_PC64.  */
  EMPTY_HOWTO (R_390_GOT64),	/* Empty entry for R_390_GOT64.  */
  EMPTY_HOWTO (R_390_PLT64),	/* Empty entry for R_390_PLT64.  */
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF16", FALSE, 0,0x0000ffff, FALSE),
  EMPTY_HOWTO (R_390_GOTOFF64),	/* Empty entry for R_390_GOTOFF64.  */
  HOWTO(R_390_GOTPLT12,  0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_GOTPLT12", FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOTPLT16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_GOTPLT32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT32", FALSE, 0,0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_GOTPLT64),	/* Empty entry for R_390_GOTPLT64.  */
  HOWTO(R_390_GOTPLTENT, 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLTENT",FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_PLTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PLTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF32", FALSE, 0,0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_PLTOFF64),	/* Empty entry for R_390_PLTOFF64.  */
  HOWTO(R_390_TLS_LOAD, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LOAD", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_GDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_GDCALL", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_LDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LDCALL", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_GD32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GD32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_GD64),	/* Empty entry for R_390_TLS_GD64.  */
  HOWTO(R_390_TLS_GOTIE12, 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE12", FALSE, 0, 0x00000fff, FALSE),
  HOWTO(R_390_TLS_GOTIE32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_GOTIE64),	/* Empty entry for R_390_TLS_GOTIE64.  */
  HOWTO(R_390_TLS_LDM32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDM32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDM64),	/* Empty entry for R_390_TLS_LDM64.  */
  HOWTO(R_390_TLS_IE32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IE32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_IE64),	/* Empty entry for R_390_TLS_IE64.  */
  HOWTO(R_390_TLS_IEENT, 1, 2, 32, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IEENT", FALSE, 0, 0xffffffff, TRUE),
  HOWTO(R_390_TLS_LE32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LE32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_LE64),	/* Empty entry for R_390_TLS_LE64.  */
  HOWTO(R_390_TLS_LDO32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDO32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDO64),	/* Empty entry for R_390_TLS_LDO64.  */
  HOWTO(R_390_TLS_DTPMOD, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPMOD", FALSE, 0, 0xffffffff, FALSE),
  HOWTO(R_390_TLS_DTPOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPOFF", FALSE, 0, 0xffffffff, FALSE),
  HOWTO(R_390_TLS_TPOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_TPOFF", FALSE, 0, 0xffffffff, FALSE),
  HOWTO(R_390_20,        0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_20",      FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOT20,	 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOT20",   FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOTPLT20,  0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOTPLT20", FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_TLS_GOTIE20, 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_TLS_GOTIE20", FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_IRELATIVE, 0, 2, 32, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_IRELATIVE", FALSE, 0, 0xffffffff, FALSE),
  HOWTO(R_390_PC12DBL,   1, 1, 12,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC12DBL",  FALSE, 0,0x00000fff, TRUE),
  HOWTO(R_390_PLT12DBL,	 1, 1, 12,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT12DBL", FALSE, 0,0x00000fff, TRUE),
  HOWTO(R_390_PC24DBL,   1, 2, 24,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC24DBL",  FALSE, 0,0x00ffffff, TRUE),
  HOWTO(R_390_PLT24DBL,	 1, 2, 24,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT24DBL", FALSE, 0,0x00ffffff, TRUE),
};

/* GNU extension to record C++ vtable hierarchy.  */
static reloc_howto_type elf32_s390_vtinherit_howto =
  HOWTO (R_390_GNU_VTINHERIT, 0,2,0,FALSE,0,complain_overflow_dont, NULL, "R_390_GNU_VTINHERIT", FALSE,0, 0, FALSE);
static reloc_howto_type elf32_s390_vtentry_howto =
  HOWTO (R_390_GNU_VTENTRY, 0,2,0,FALSE,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", FALSE,0,0, FALSE);

static reloc_howto_type *
elf_s390_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    bfd_reloc_code_real_type code)
{
  switch (code)
    {
    case BFD_RELOC_NONE:
      return &elf_howto_table[(int) R_390_NONE];
    case BFD_RELOC_8:
      return &elf_howto_table[(int) R_390_8];
    case BFD_RELOC_390_12:
      return &elf_howto_table[(int) R_390_12];
    case BFD_RELOC_16:
      return &elf_howto_table[(int) R_390_16];
    case BFD_RELOC_32:
      return &elf_howto_table[(int) R_390_32];
    case BFD_RELOC_CTOR:
      return &elf_howto_table[(int) R_390_32];
    case BFD_RELOC_32_PCREL:
      return &elf_howto_table[(int) R_390_PC32];
    case BFD_RELOC_390_GOT12:
      return &elf_howto_table[(int) R_390_GOT12];
    case BFD_RELOC_32_GOT_PCREL:
      return &elf_howto_table[(int) R_390_GOT32];
    case BFD_RELOC_390_PLT32:
      return &elf_howto_table[(int) R_390_PLT32];
    case BFD_RELOC_390_COPY:
      return &elf_howto_table[(int) R_390_COPY];
    case BFD_RELOC_390_GLOB_DAT:
      return &elf_howto_table[(int) R_390_GLOB_DAT];
    case BFD_RELOC_390_JMP_SLOT:
      return &elf_howto_table[(int) R_390_JMP_SLOT];
    case BFD_RELOC_390_RELATIVE:
      return &elf_howto_table[(int) R_390_RELATIVE];
    case BFD_RELOC_32_GOTOFF:
      return &elf_howto_table[(int) R_390_GOTOFF32];
    case BFD_RELOC_390_GOTPC:
      return &elf_howto_table[(int) R_390_GOTPC];
    case BFD_RELOC_390_GOT16:
      return &elf_howto_table[(int) R_390_GOT16];
    case BFD_RELOC_16_PCREL:
      return &elf_howto_table[(int) R_390_PC16];
    case BFD_RELOC_390_PC12DBL:
      return &elf_howto_table[(int) R_390_PC12DBL];
    case BFD_RELOC_390_PLT12DBL:
      return &elf_howto_table[(int) R_390_PLT12DBL];
    case BFD_RELOC_390_PC16DBL:
      return &elf_howto_table[(int) R_390_PC16DBL];
    case BFD_RELOC_390_PLT16DBL:
      return &elf_howto_table[(int) R_390_PLT16DBL];
    case BFD_RELOC_390_PC24DBL:
      return &elf_howto_table[(int) R_390_PC24DBL];
    case BFD_RELOC_390_PLT24DBL:
      return &elf_howto_table[(int) R_390_PLT24DBL];
    case BFD_RELOC_390_PC32DBL:
      return &elf_howto_table[(int) R_390_PC32DBL];
    case BFD_RELOC_390_PLT32DBL:
      return &elf_howto_table[(int) R_390_PLT32DBL];
    case BFD_RELOC_390_GOTPCDBL:
      return &elf_howto_table[(int) R_390_GOTPCDBL];
    case BFD_RELOC_390_GOTENT:
      return &elf_howto_table[(int) R_390_GOTENT];
    case BFD_RELOC_16_GOTOFF:
      return &elf_howto_table[(int) R_390_GOTOFF16];
    case BFD_RELOC_390_GOTPLT12:
      return &elf_howto_table[(int) R_390_GOTPLT12];
    case BFD_RELOC_390_GOTPLT16:
      return &elf_howto_table[(int) R_390_GOTPLT16];
    case BFD_RELOC_390_GOTPLT32:
      return &elf_howto_table[(int) R_390_GOTPLT32];
    case BFD_RELOC_390_GOTPLTENT:
      return &elf_howto_table[(int) R_390_GOTPLTENT];
    case BFD_RELOC_390_PLTOFF16:
      return &elf_howto_table[(int) R_390_PLTOFF16];
    case BFD_RELOC_390_PLTOFF32:
      return &elf_howto_table[(int) R_390_PLTOFF32];
    case BFD_RELOC_390_TLS_LOAD:
      return &elf_howto_table[(int) R_390_TLS_LOAD];
    case BFD_RELOC_390_TLS_GDCALL:
      return &elf_howto_table[(int) R_390_TLS_GDCALL];
    case BFD_RELOC_390_TLS_LDCALL:
      return &elf_howto_table[(int) R_390_TLS_LDCALL];
    case BFD_RELOC_390_TLS_GD32:
      return &elf_howto_table[(int) R_390_TLS_GD32];
    case BFD_RELOC_390_TLS_GOTIE12:
      return &elf_howto_table[(int) R_390_TLS_GOTIE12];
    case BFD_RELOC_390_TLS_GOTIE32:
      return &elf_howto_table[(int) R_390_TLS_GOTIE32];
    case BFD_RELOC_390_TLS_LDM32:
      return &elf_howto_table[(int) R_390_TLS_LDM32];
    case BFD_RELOC_390_TLS_IE32:
      return &elf_howto_table[(int) R_390_TLS_IE32];
    case BFD_RELOC_390_TLS_IEENT:
      return &elf_howto_table[(int) R_390_TLS_IEENT];
    case BFD_RELOC_390_TLS_LE32:
      return &elf_howto_table[(int) R_390_TLS_LE32];
    case BFD_RELOC_390_TLS_LDO32:
      return &elf_howto_table[(int) R_390_TLS_LDO32];
    case BFD_RELOC_390_TLS_DTPMOD:
      return &elf_howto_table[(int) R_390_TLS_DTPMOD];
    case BFD_RELOC_390_TLS_DTPOFF:
      return &elf_howto_table[(int) R_390_TLS_DTPOFF];
    case BFD_RELOC_390_TLS_TPOFF:
      return &elf_howto_table[(int) R_390_TLS_TPOFF];
    case BFD_RELOC_390_20:
      return &elf_howto_table[(int) R_390_20];
    case BFD_RELOC_390_GOT20:
      return &elf_howto_table[(int) R_390_GOT20];
    case BFD_RELOC_390_GOTPLT20:
      return &elf_howto_table[(int) R_390_GOTPLT20];
    case BFD_RELOC_390_TLS_GOTIE20:
      return &elf_howto_table[(int) R_390_TLS_GOTIE20];
    case BFD_RELOC_390_IRELATIVE:
      return &elf_howto_table[(int) R_390_IRELATIVE];
    case BFD_RELOC_VTABLE_INHERIT:
      return &elf32_s390_vtinherit_howto;
    case BFD_RELOC_VTABLE_ENTRY:
      return &elf32_s390_vtentry_howto;
    default:
      break;
    }
  return 0;
}

static reloc_howto_type *
elf_s390_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
			    const char *r_name)
{
  unsigned int i;

  for (i = 0; i < sizeof (elf_howto_table) / sizeof (elf_howto_table[0]); i++)
    if (elf_howto_table[i].name != NULL
	&& strcasecmp (elf_howto_table[i].name, r_name) == 0)
      return &elf_howto_table[i];

  if (strcasecmp (elf32_s390_vtinherit_howto.name, r_name) == 0)
    return &elf32_s390_vtinherit_howto;
  if (strcasecmp (elf32_s390_vtentry_howto.name, r_name) == 0)
    return &elf32_s390_vtentry_howto;

  return NULL;
}

/* We need to use ELF32_R_TYPE so we have our own copy of this function,
   and elf32-s390.c has its own copy.  */

static void
elf_s390_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
			arelent *cache_ptr,
			Elf_Internal_Rela *dst)
{
  unsigned int r_type = ELF32_R_TYPE(dst->r_info);
  switch (r_type)
    {
    case R_390_GNU_VTINHERIT:
      cache_ptr->howto = &elf32_s390_vtinherit_howto;
      break;

    case R_390_GNU_VTENTRY:
      cache_ptr->howto = &elf32_s390_vtentry_howto;
      break;

    default:
      if (r_type >= sizeof (elf_howto_table) / sizeof (elf_howto_table[0]))
	{
	  (*_bfd_error_handler) (_("%B: invalid relocation type %d"),
				 abfd, (int) r_type);
	  r_type = R_390_NONE;
	}
      cache_ptr->howto = &elf_howto_table[r_type];
    }
}

/* A relocation function which doesn't do anything.  */
static bfd_reloc_status_type
s390_tls_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		arelent *reloc_entry,
		asymbol *symbol ATTRIBUTE_UNUSED,
		void * data ATTRIBUTE_UNUSED,
		asection *input_section,
		bfd *output_bfd,
		char **error_message ATTRIBUTE_UNUSED)
{
  if (output_bfd)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

/* Handle the large displacement relocs.  */
static bfd_reloc_status_type
s390_elf_ldisp_reloc (bfd *abfd ATTRIBUTE_UNUSED,
		      arelent *reloc_entry,
		      asymbol *symbol,
		      void * data ATTRIBUTE_UNUSED,
		      asection *input_section,
		      bfd *output_bfd,
		      char **error_message ATTRIBUTE_UNUSED)
{
  reloc_howto_type *howto = reloc_entry->howto;
  bfd_vma relocation;
  bfd_vma insn;

  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }

  if (output_bfd != NULL)
    return bfd_reloc_continue;

  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
    return bfd_reloc_outofrange;

  relocation = (symbol->value
		+ symbol->section->output_section->vma
		+ symbol->section->output_offset);
  relocation += reloc_entry->addend;
  if (howto->pc_relative)
    {
      relocation -= (input_section->output_section->vma
		     + input_section->output_offset);
      relocation -= reloc_entry->address;
    }

  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn |= (relocation & 0xfff) << 16 | (relocation & 0xff000) >> 4;
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);

  if ((bfd_signed_vma) relocation < - 0x80000
      || (bfd_signed_vma) relocation > 0x7ffff)
    return bfd_reloc_overflow;
  else
    return bfd_reloc_ok;
}

static bfd_boolean
elf_s390_is_local_label_name (bfd *abfd, const char *name)
{
  if (name[0] == '.' && (name[1] == 'X' || name[1] == 'L'))
    return TRUE;

  return _bfd_elf_is_local_label_name (abfd, name);
}

/* Functions for the 390 ELF linker.  */

/* The name of the dynamic interpreter.  This is put in the .interp
   section.  */

#define ELF_DYNAMIC_INTERPRETER "/lib/ld.so.1"

/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

/* The size in bytes of the first entry in the procedure linkage table.  */
#define PLT_FIRST_ENTRY_SIZE 32
/* The size in bytes of an entry in the procedure linkage table.  */
#define PLT_ENTRY_SIZE 32

#define GOT_ENTRY_SIZE 4

#define RELA_ENTRY_SIZE sizeof (Elf32_External_Rela)

/* The first three entries in a procedure linkage table are reserved,
   and the initial contents are unimportant (we zero them out).
   Subsequent entries look like this.  See the SVR4 ABI 386
   supplement to see how this works.  */

/* For the s390, simple addr offset can only be 0 - 4096.
   To use the full 2 GB address space, several instructions
   are needed to load an address in a register and execute
   a branch( or just saving the address)

   Furthermore, only r 0 and 1 are free to use!!!  */

/* The first 3 words in the GOT are then reserved.
   Word 0 is the address of the dynamic table.
   Word 1 is a pointer to a structure describing the object
   Word 2 is used to point to the loader entry address.

   The code for position independent PLT entries looks like this:

   r12 holds addr of the current GOT at entry to the PLT

   The GOT holds the address in the PLT to be executed.
   The loader then gets:
   24(15) =  Pointer to the structure describing the object.
   28(15) =  Offset into rela.plt

   The loader  must  then find the module where the function is
   and insert the address in the GOT.

  Note: 390 can only address +- 64 K relative.
        We check if offset > 65536, then make a relative branch -64xxx
        back to a previous defined branch

PLT1: BASR 1,0         # 2 bytes
      L    1,22(1)     # 4 bytes  Load offset in GOT in r 1
      L    1,(1,12)    # 4 bytes  Load address from GOT in r1
      BCR  15,1        # 2 bytes  Jump to address
RET1: BASR 1,0         # 2 bytes  Return from GOT 1st time
      L    1,14(1)     # 4 bytes  Load offset in symol table in r1
      BRC  15,-x       # 4 bytes  Jump to start of PLT
      .word 0          # 2 bytes filler
      .long ?          # 4 bytes  offset in GOT
      .long ?          # 4 bytes  offset into rela.plt

  This was the general case. There are two additional, optimizes PLT
  definitions. One for GOT offsets < 4096 and one for GOT offsets < 32768.
  First the one for GOT offsets < 4096:

PLT1: L    1,<offset>(12) # 4 bytes  Load address from GOT in R1
      BCR  15,1           # 2 bytes  Jump to address
      .word 0,0,0         # 6 bytes  filler
RET1: BASR 1,0            # 2 bytes  Return from GOT 1st time
      L    1,14(1)        # 4 bytes  Load offset in rela.plt in r1
      BRC  15,-x          # 4 bytes  Jump to start of PLT
      .word 0,0,0         # 6 bytes  filler
      .long ?             # 4 bytes  offset into rela.plt

  Second the one for GOT offsets < 32768:

PLT1: LHI  1,<offset>     # 4 bytes  Load offset in GOT to r1
      L    1,(1,12)       # 4 bytes  Load address from GOT to r1
      BCR  15,1           # 2 bytes  Jump to address
      .word 0             # 2 bytes  filler
RET1: BASR 1,0            # 2 bytes  Return from GOT 1st time
      L    1,14(1)        # 4 bytes  Load offset in rela.plt in r1
      BRC  15,-x          # 4 bytes  Jump to start of PLT
      .word 0,0,0         # 6 bytes  filler
      .long ?             # 4 bytes  offset into rela.plt

Total = 32 bytes per PLT entry

   The code for static build PLT entries looks like this:

PLT1: BASR 1,0         # 2 bytes
      L    1,22(1)     # 4 bytes  Load address of GOT entry
      L    1,0(0,1)    # 4 bytes  Load address from GOT in r1
      BCR  15,1        # 2 bytes  Jump to address
RET1: BASR 1,0         # 2 bytes  Return from GOT 1st time
      L    1,14(1)     # 4 bytes  Load offset in symbol table in r1
      BRC  15,-x       # 4 bytes  Jump to start of PLT
      .word 0          # 2 bytes  filler
      .long ?          # 4 bytes  address of GOT entry
      .long ?          # 4 bytes  offset into rela.plt  */

static const bfd_byte elf_s390_plt_entry[PLT_ENTRY_SIZE] =
  {
    0x0d, 0x10,                             /* basr    %r1,%r0     */
    0x58, 0x10, 0x10, 0x16,                 /* l       %r1,22(%r1) */
    0x58, 0x10, 0x10, 0x00,                 /* l       %r1,0(%r1)  */
    0x07, 0xf1,                             /* br      %r1         */
    0x0d, 0x10,                             /* basr    %r1,%r0     */
    0x58, 0x10, 0x10, 0x0e,                 /* l       %r1,14(%r1) */
    0xa7, 0xf4, 0x00, 0x00,                 /* j       first plt   */
    0x00, 0x00,                             /* padding             */
    0x00, 0x00, 0x00, 0x00,                 /* GOT offset          */
    0x00, 0x00, 0x00, 0x00                  /* rela.plt offset     */
  };

/* Generic PLT pic entry.  */
static const bfd_byte elf_s390_plt_pic_entry[PLT_ENTRY_SIZE] =
  {
    0x0d, 0x10,                             /* basr    %r1,%r0         */
    0x58, 0x10, 0x10, 0x16,                 /* l       %r1,22(%r1)     */
    0x58, 0x11, 0xc0, 0x00,                 /* l       %r1,0(%r1,%r12) */
    0x07, 0xf1,                             /* br      %r1             */
    0x0d, 0x10,                             /* basr    %r1,%r0         */
    0x58, 0x10, 0x10, 0x0e,                 /* l       %r1,14(%r1)     */
    0xa7, 0xf4, 0x00, 0x00,                 /* j       first plt       */
    0x00, 0x00,                             /* padding                 */
    0x00, 0x00, 0x00, 0x00,                 /* GOT offset              */
    0x00, 0x00, 0x00, 0x00                  /* rela.plt offset         */
  };

/* Optimized PLT pic entry for GOT offset < 4k.  xx will be replaced
   when generating the PLT slot with the GOT offset.  */
static const bfd_byte elf_s390_plt_pic12_entry[PLT_ENTRY_SIZE] =
  {
    0x58, 0x10, 0xc0, 0x00,                 /* l       %r1,xx(%r12) */
    0x07, 0xf1,                             /* br      %r1          */
    0x00, 0x00, 0x00, 0x00,                 /* padding              */
    0x00, 0x00,
    0x0d, 0x10,                             /* basr    %r1,%r0      */
    0x58, 0x10, 0x10, 0x0e,                 /* l       %r1,14(%r1)  */
    0xa7, 0xf4, 0x00, 0x00,                 /* j       first plt    */
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00
  };

/* Optimized PLT pic entry for GOT offset < 32k.  xx will be replaced
   when generating the PLT slot with the GOT offset.  */
static const bfd_byte elf_s390_plt_pic16_entry[PLT_ENTRY_SIZE] =
  {
    0xa7, 0x18, 0x00, 0x00,                 /* lhi     %r1,xx          */
    0x58, 0x11, 0xc0, 0x00,                 /* l       %r1,0(%r1,%r12) */
    0x07, 0xf1,                             /* br      %r1             */
    0x00, 0x00,
    0x0d, 0x10,                             /* basr    %r1,%r0         */
    0x58, 0x10, 0x10, 0x0e,                 /* l       %r1,14(%r1)     */
    0xa7, 0xf4, 0x00, 0x00,                 /* j       first plt       */
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
  };

/* The first PLT entry pushes the offset into the rela.plt
   from R1 onto the stack at 8(15) and the loader object info
   at 12(15), loads the loader address in R1 and jumps to it.  */

/* The first entry in the PLT for PIC code:

PLT0:
   ST   1,28(15)  # R1 has offset into rela.plt
   L    1,4(12)   # Get loader ino(object struct address)
   ST   1,24(15)  # Store address
   L    1,8(12)   # Entry address of loader in R1
   BR   1         # Jump to loader

   The first entry in the PLT for static code:

PLT0:
   ST   1,28(15)      # R1 has offset into rela.plt
   BASR 1,0
   L    1,18(0,1)     # Get address of GOT
   MVC  24(4,15),4(1) # Move loader ino to stack
   L    1,8(1)        # Get address of loader
   BR   1             # Jump to loader
   .word 0            # filler
   .long got          # address of GOT  */

static const bfd_byte elf_s390_plt_first_entry[PLT_FIRST_ENTRY_SIZE] =
  {
    0x50, 0x10, 0xf0, 0x1c,                   /* st      %r1,28(%r15)      */
    0x0d, 0x10,                               /* basr    %r1,%r0           */
    0x58, 0x10, 0x10, 0x12,                   /* l       %r1,18(%r1)       */
    0xd2, 0x03, 0xf0, 0x18, 0x10, 0x04,       /* mvc     24(4,%r15),4(%r1) */
    0x58, 0x10, 0x10, 0x08,                   /* l       %r1,8(%r1)        */
    0x07, 0xf1,                               /* br      %r1               */
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
  };

static const bfd_byte elf_s390_plt_pic_first_entry[PLT_FIRST_ENTRY_SIZE] =
  {
    0x50, 0x10, 0xf0, 0x1c,                     /* st      %r1,28(%r15)  */
    0x58, 0x10, 0xc0, 0x04,                     /* l       %r1,4(%r12)   */
    0x50, 0x10, 0xf0, 0x18,                     /* st      %r1,24(%r15)  */
    0x58, 0x10, 0xc0, 0x08,                     /* l       %r1,8(%r12)   */
    0x07, 0xf1,                                 /* br      %r1           */
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00
  };


/* s390 ELF linker hash entry.  */

struct elf_s390_link_hash_entry
{
  struct elf_link_hash_entry elf;

  /* Track dynamic relocs copied for this symbol.  */
  struct elf_dyn_relocs *dyn_relocs;

  /* Number of GOTPLT references for a function.  */
  bfd_signed_vma gotplt_refcount;

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	3
#define GOT_TLS_IE_NLT	4
  unsigned char tls_type;

  /* For pointer equality reasons we might need to change the symbol
     type from STT_GNU_IFUNC to STT_FUNC together with its value and
     section entry.  So after alloc_dynrelocs only these values should
     be used.  In order to check whether a symbol is IFUNC use
     s390_is_ifunc_symbol_p.  */
  bfd_vma ifunc_resolver_address;
  asection *ifunc_resolver_section;
};

#define elf_s390_hash_entry(ent) \
  ((struct elf_s390_link_hash_entry *)(ent))

/* This structure represents an entry in the local PLT list needed for
   local IFUNC symbols.  */
struct plt_entry
{
  /* The section of the local symbol.
     Set in relocate_section and used in finish_dynamic_sections.  */
  asection *sec;

  union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } plt;
};

/* NOTE: Keep this structure in sync with
   the one declared in elf64-s390.c.  */
struct elf_s390_obj_tdata
{
  struct elf_obj_tdata root;

  /* A local PLT is needed for ifunc symbols.  */
  struct plt_entry *local_plt;

  /* TLS type for each local got entry.  */
  char *local_got_tls_type;
};

#define elf_s390_tdata(abfd) \
  ((struct elf_s390_obj_tdata *) (abfd)->tdata.any)

#define elf_s390_local_plt(abfd)		\
  (elf_s390_tdata (abfd)->local_plt)

#define elf_s390_local_got_tls_type(abfd) \
  (elf_s390_tdata (abfd)->local_got_tls_type)

#define is_s390_elf(bfd) \
  (bfd_get_flavour (bfd) == bfd_target_elf_flavour \
   && elf_tdata (bfd) != NULL \
   && elf_object_id (bfd) == S390_ELF_DATA)

static bfd_boolean
elf_s390_mkobject (bfd *abfd)
{
  return bfd_elf_allocate_object (abfd, sizeof (struct elf_s390_obj_tdata),
				  S390_ELF_DATA);
}

static bfd_boolean
elf_s390_object_p (bfd *abfd)
{
  /* Set the right machine number for an s390 elf32 file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_31);
}

/* s390 ELF linker hash table.  */

struct elf_s390_link_hash_table
{
  struct elf_link_hash_table elf;

  /* Short-cuts to get to dynamic linker sections.  */
  asection *sdynbss;
  asection *srelbss;
  asection *irelifunc;

  union
  {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ldm_got;

  /* Small local sym cache.  */
  struct sym_cache sym_cache;
};

/* Get the s390 ELF linker hash table from a link_info structure.  */

#define elf_s390_hash_table(p) \
  (elf_hash_table_id ((struct elf_link_hash_table *) ((p)->hash)) \
  == S390_ELF_DATA ? ((struct elf_s390_link_hash_table *) ((p)->hash)) : NULL)

#undef ELF64
#include "elf-s390-common.c"

/* Create an entry in an s390 ELF linker hash table.  */

static struct bfd_hash_entry *
link_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
{
  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (entry == NULL)
    {
      entry = bfd_hash_allocate (table,
				 sizeof (struct elf_s390_link_hash_entry));
      if (entry == NULL)
	return entry;
    }

  /* Call the allocation method of the superclass.  */
  entry = _bfd_elf_link_hash_newfunc (entry, table, string);
  if (entry != NULL)
    {
      struct elf_s390_link_hash_entry *eh;

      eh = (struct elf_s390_link_hash_entry *) entry;
      eh->dyn_relocs = NULL;
      eh->gotplt_refcount = 0;
      eh->tls_type = GOT_UNKNOWN;
      eh->ifunc_resolver_address = 0;
      eh->ifunc_resolver_section = NULL;
    }

  return entry;
}

/* Create an s390 ELF linker hash table.  */

static struct bfd_link_hash_table *
elf_s390_link_hash_table_create (bfd *abfd)
{
  struct elf_s390_link_hash_table *ret;
  bfd_size_type amt = sizeof (struct elf_s390_link_hash_table);

  ret = (struct elf_s390_link_hash_table *) bfd_zmalloc (amt);
  if (ret == NULL)
    return NULL;

  if (!_bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc,
				      sizeof (struct elf_s390_link_hash_entry),
				      S390_ELF_DATA))
    {
      free (ret);
      return NULL;
    }

  return &ret->elf.root;
}

/* Create .got, .gotplt, and .rela.got sections in DYNOBJ, and set up
   shortcuts to them in our hash table.  */

static bfd_boolean
create_got_section (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf_s390_link_hash_table *htab;

  if (! _bfd_elf_create_got_section (dynobj, info))
    return FALSE;

  htab = elf_s390_hash_table (info);
  htab->elf.sgot = bfd_get_linker_section (dynobj, ".got");
  htab->elf.sgotplt = bfd_get_linker_section (dynobj, ".got.plt");
  htab->elf.srelgot = bfd_get_linker_section (dynobj, ".rela.got");
  if (!htab->elf.sgot || !htab->elf.sgotplt || !htab->elf.srelgot)
    abort ();

  return TRUE;
}

/* Create .plt, .rela.plt, .got, .got.plt, .rela.got, .dynbss, and
   .rela.bss sections in DYNOBJ, and set up shortcuts to them in our
   hash table.  */

static bfd_boolean
elf_s390_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
{
  struct elf_s390_link_hash_table *htab;

  htab = elf_s390_hash_table (info);
  if (!htab->elf.sgot && !create_got_section (dynobj, info))
    return FALSE;

  if (!_bfd_elf_create_dynamic_sections (dynobj, info))
    return FALSE;

  htab->elf.splt = bfd_get_linker_section (dynobj, ".plt");
  htab->elf.srelplt = bfd_get_linker_section (dynobj, ".rela.plt");
  htab->sdynbss = bfd_get_linker_section (dynobj, ".dynbss");
  if (!info->shared)
    htab->srelbss = bfd_get_linker_section (dynobj, ".rela.bss");

  if (!htab->elf.splt || !htab->elf.srelplt || !htab->sdynbss
      || (!info->shared && !htab->srelbss))
    abort ();

  return TRUE;
}

/* Copy the extra info we tack onto an elf_link_hash_entry.  */

static void
elf_s390_copy_indirect_symbol (struct bfd_link_info *info,
			       struct elf_link_hash_entry *dir,
			       struct elf_link_hash_entry *ind)
{
  struct elf_s390_link_hash_entry *edir, *eind;

  edir = (struct elf_s390_link_hash_entry *) dir;
  eind = (struct elf_s390_link_hash_entry *) ind;

  if (eind->dyn_relocs != NULL)
    {
      if (edir->dyn_relocs != NULL)
	{
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  /* Add reloc counts against the indirect sym to the direct sym
	     list.  Merge any entries against the same section.  */
	  for (pp = &eind->dyn_relocs; (p = *pp) != NULL; )
	    {
	      struct elf_dyn_relocs *q;

	      for (q = edir->dyn_relocs; q != NULL; q = q->next)
		if (q->sec == p->sec)
		  {
		    q->pc_count += p->pc_count;
		    q->count += p->count;
		    *pp = p->next;
		    break;
		  }
	      if (q == NULL)
		pp = &p->next;
	    }
	  *pp = edir->dyn_relocs;
	}

      edir->dyn_relocs = eind->dyn_relocs;
      eind->dyn_relocs = NULL;
    }

  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
    }
  else
    _bfd_elf_link_hash_copy_indirect (info, dir, ind);
}

static int
elf_s390_tls_transition (struct bfd_link_info *info,
			 int r_type,
			 int is_local)
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_390_TLS_GD32:
    case R_390_TLS_IE32:
      if (is_local)
	return R_390_TLS_LE32;
      return R_390_TLS_IE32;
    case R_390_TLS_GOTIE32:
      if (is_local)
	return R_390_TLS_LE32;
      return R_390_TLS_GOTIE32;
    case R_390_TLS_LDM32:
      return R_390_TLS_LE32;
    }

  return r_type;
}

/* Look through the relocs for a section during the first phase, and
   allocate space in the global offset table or procedure linkage
   table.  */

static bfd_boolean
elf_s390_check_relocs (bfd *abfd,
		       struct bfd_link_info *info,
		       asection *sec,
		       const Elf_Internal_Rela *relocs)
{
  struct elf_s390_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  const Elf_Internal_Rela *rel;
  const Elf_Internal_Rela *rel_end;
  asection *sreloc;
  bfd_signed_vma *local_got_refcounts;
  int tls_type, old_tls_type;
  Elf_Internal_Sym *isym;

  if (info->relocatable)
    return TRUE;

  BFD_ASSERT (is_s390_elf (abfd));

  htab = elf_s390_hash_table (info);
  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  sreloc = NULL;

  rel_end = relocs + sec->reloc_count;
  for (rel = relocs; rel < rel_end; rel++)
    {
      unsigned int r_type;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;

      r_symndx = ELF32_R_SYM (rel->r_info);

      if (r_symndx >= NUM_SHDR_ENTRIES (symtab_hdr))
	{
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
				 abfd, r_symndx);
	  return FALSE;
	}

      if (r_symndx < symtab_hdr->sh_info)
	{
	  /* A local symbol.  */
	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					abfd, r_symndx);
	  if (isym == NULL)
	    return FALSE;

	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
	    {
	      struct plt_entry *plt;

	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;

	      if (!s390_elf_create_ifunc_sections (htab->elf.dynobj, info))
		return FALSE;

	      if (local_got_refcounts == NULL)
		{
		  if (!elf_s390_allocate_local_syminfo (abfd, symtab_hdr))
		    return FALSE;
		  local_got_refcounts = elf_local_got_refcounts (abfd);
		}
	      plt = elf_s390_local_plt (abfd);
	      plt[r_symndx].plt.refcount++;
	    }
	  h = NULL;
	}
      else
	{
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;

	  /* PR15323, ref flags aren't set for references in the same
	     object.  */
	  h->root.non_ir_ref = 1;
	}

      /* Create got section and local_got_refcounts array if they
	 are needed.  */
      r_type = elf_s390_tls_transition (info,
					ELF32_R_TYPE (rel->r_info),
					h == NULL);
      switch (r_type)
	{
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOTENT:
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	case R_390_TLS_GD32:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE32:
	case R_390_TLS_IEENT:
	case R_390_TLS_IE32:
	case R_390_TLS_LDM32:
	  if (h == NULL
	      && local_got_refcounts == NULL)
	    {
	      if (!elf_s390_allocate_local_syminfo (abfd, symtab_hdr))
		return FALSE;
	      local_got_refcounts = elf_local_got_refcounts (abfd);
	    }
	  /* Fall through.  */
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  if (htab->elf.sgot == NULL)
	    {
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;
	      if (!create_got_section (htab->elf.dynobj, info))
		return FALSE;
	    }
	}

      if (h != NULL)
	{
	  if (htab->elf.dynobj == NULL)
	    htab->elf.dynobj = abfd;
	  if (!s390_elf_create_ifunc_sections (htab->elf.dynobj, info))
	    return FALSE;

	  /* Make sure an IFUNC symbol defined in a non-shared object
	     always gets a PLT slot.  */
	  if (s390_is_ifunc_symbol_p (h) && h->def_regular)
	    {
	      /* The symbol is called by the dynamic loader in order
		 to resolve the relocation.  So it is in fact also
		 referenced.  */
	      h->ref_regular = 1;
	      h->needs_plt = 1;
	    }
	}
      switch (r_type)
	{
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  /* These relocs do not need a GOT slot.  They just load the
	     GOT pointer itself or address something else relative to
	     the GOT.  Since the GOT pointer has been set up above we
	     are done.  */
	  break;

	case R_390_PLT12DBL:
	case R_390_PLT16DBL:
	case R_390_PLT24DBL:
	case R_390_PLT32DBL:
	case R_390_PLT32:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	  /* This symbol requires a procedure linkage table entry.  We
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.  */

	  /* If this is a local symbol, we resolve it directly without
	     creating a procedure linkage table entry.  */
	  if (h != NULL)
	    {
	      h->needs_plt = 1;
	      h->plt.refcount += 1;
	    }
	  break;

	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  /* This symbol requires either a procedure linkage table entry
	     or an entry in the local got. We actually build the entry
	     in adjust_dynamic_symbol because whether this is really a
	     global reference can change and with it the fact if we have
	     to create a plt entry or a local got entry. To be able to
	     make a once global symbol a local one we have to keep track
	     of the number of gotplt references that exist for this
	     symbol.  */
	  if (h != NULL)
	    {
	      ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount++;
	      h->needs_plt = 1;
	      h->plt.refcount += 1;
	    }
	  else
	    local_got_refcounts[r_symndx] += 1;
	  break;

	case R_390_TLS_LDM32:
	  htab->tls_ldm_got.refcount += 1;
	  break;

	case R_390_TLS_IE32:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE32:
	case R_390_TLS_IEENT:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through.  */

	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOTENT:
	case R_390_TLS_GD32:
	  /* This symbol requires a global offset table entry.  */
	  switch (r_type)
	    {
	    default:
	    case R_390_GOT12:
	    case R_390_GOT16:
	    case R_390_GOT20:
	    case R_390_GOT32:
	    case R_390_GOTENT:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_390_TLS_GD32:
	      tls_type = GOT_TLS_GD;
	      break;
	    case R_390_TLS_IE32:
	    case R_390_TLS_GOTIE32:
	      tls_type = GOT_TLS_IE;
	      break;
	    case R_390_TLS_GOTIE12:
	    case R_390_TLS_GOTIE20:
	    case R_390_TLS_IEENT:
	      tls_type = GOT_TLS_IE_NLT;
	      break;
	    }

	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	      old_tls_type = elf_s390_hash_entry(h)->tls_type;
	    }
	  else
	    {
	      local_got_refcounts[r_symndx] += 1;
	      old_tls_type = elf_s390_local_got_tls_type (abfd) [r_symndx];
	    }
	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN)
	    {
	      if (old_tls_type == GOT_NORMAL || tls_type == GOT_NORMAL)
		{
		  (*_bfd_error_handler)
		    (_("%B: `%s' accessed both as normal and thread local symbol"),
		     abfd, h->root.root.string);
		  return FALSE;
		}
	      if (old_tls_type > tls_type)
		tls_type = old_tls_type;
	    }

	  if (old_tls_type != tls_type)
	    {
	      if (h != NULL)
		elf_s390_hash_entry (h)->tls_type = tls_type;
	      else
		elf_s390_local_got_tls_type (abfd) [r_symndx] = tls_type;
	    }

	  if (r_type != R_390_TLS_IE32)
	    break;
	  /* Fall through.  */

	case R_390_TLS_LE32:
	  if (!info->shared)
	    break;
	  info->flags |= DF_STATIC_TLS;
	  /* Fall through.  */

	case R_390_8:
	case R_390_16:
	case R_390_32:
	case R_390_PC16:
	case R_390_PC12DBL:
	case R_390_PC16DBL:
	case R_390_PC24DBL:
	case R_390_PC32DBL:
	case R_390_PC32:
	  if (h != NULL)
	    {
	      /* If this reloc is in a read-only section, we might
		 need a copy reloc.  We can't check reliably at this
		 stage whether the section is read-only, as input
		 sections have not yet been mapped to output sections.
		 Tentatively set the flag for now, and correct in
		 adjust_dynamic_symbol.  */
	      h->non_got_ref = 1;

	      if (!info->shared)
		{
		  /* We may need a .plt entry if the function this reloc
		     refers to is in a shared lib.  */
		  h->plt.refcount += 1;
		}
	    }

	  /* If we are creating a shared library, and this is a reloc
	     against a global symbol, or a non PC relative reloc
	     against a local symbol, then we need to copy the reloc
	     into the shared library.  However, if we are linking with
	     -Bsymbolic, we do not need to copy a reloc against a
	     global symbol which is defined in an object we are
	     including in the link (i.e., DEF_REGULAR is set).  At
	     this point we have not seen all the input files, so it is
	     possible that DEF_REGULAR is not set now but will be set
	     later (it is never cleared).  In case of a weak definition,
	     DEF_REGULAR may be cleared later by a strong definition in
	     a shared library. We account for that possibility below by
	     storing information in the relocs_copied field of the hash
	     table entry.  A similar situation occurs when creating
	     shared libraries and symbol visibility changes render the
	     symbol local.

	     If on the other hand, we are creating an executable, we
	     may need to keep relocations for symbols satisfied by a
	     dynamic library if we manage to avoid copy relocs for the
	     symbol.  */
	  if ((info->shared
	       && (sec->flags & SEC_ALLOC) != 0
	       && ((ELF32_R_TYPE (rel->r_info) != R_390_PC16
		    && ELF32_R_TYPE (rel->r_info) != R_390_PC12DBL
		    && ELF32_R_TYPE (rel->r_info) != R_390_PC16DBL
		    && ELF32_R_TYPE (rel->r_info) != R_390_PC24DBL
		    && ELF32_R_TYPE (rel->r_info) != R_390_PC32DBL
		    && ELF32_R_TYPE (rel->r_info) != R_390_PC32)
		   || (h != NULL
		       && (! SYMBOLIC_BIND (info, h)
			   || h->root.type == bfd_link_hash_defweak
			   || !h->def_regular))))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && (sec->flags & SEC_ALLOC) != 0
		  && h != NULL
		  && (h->root.type == bfd_link_hash_defweak
		      || !h->def_regular)))
	    {
	      struct elf_dyn_relocs *p;
	      struct elf_dyn_relocs **head;

	      /* We must copy these reloc types into the output file.
		 Create a reloc section in dynobj and make room for
		 this reloc.  */
	      if (sreloc == NULL)
		{
		  if (htab->elf.dynobj == NULL)
		    htab->elf.dynobj = abfd;

		  sreloc = _bfd_elf_make_dynamic_reloc_section
		    (sec, htab->elf.dynobj, 2, abfd, /*rela?*/ TRUE);

		  if (sreloc == NULL)
		    return FALSE;
		}

	      /* If this is a global symbol, we count the number of
		 relocations we need for this symbol.  */
	      if (h != NULL)
		{
		  head = &((struct elf_s390_link_hash_entry *) h)->dyn_relocs;
		}
	      else
		{
		  /* Track dynamic relocs needed for local syms too.
		     We really need local syms available to do this
		     easily.  Oh well.  */
		  asection *s;
		  void *vpp;

		  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
						abfd, r_symndx);
		  if (isym == NULL)
		    return FALSE;

		  s = bfd_section_from_elf_index (abfd, isym->st_shndx);
		  if (s == NULL)
		    s = sec;

		  vpp = &elf_section_data (s)->local_dynrel;
		  head = (struct elf_dyn_relocs **) vpp;
		}

	      p = *head;
	      if (p == NULL || p->sec != sec)
		{
		  bfd_size_type amt = sizeof *p;

		  p = ((struct elf_dyn_relocs *)
		       bfd_alloc (htab->elf.dynobj, amt));
		  if (p == NULL)
		    return FALSE;
		  p->next = *head;
		  *head = p;
		  p->sec = sec;
		  p->count = 0;
		  p->pc_count = 0;
		}

	      p->count += 1;
	      if (ELF32_R_TYPE (rel->r_info) == R_390_PC16
		  || ELF32_R_TYPE (rel->r_info) == R_390_PC12DBL
		  || ELF32_R_TYPE (rel->r_info) == R_390_PC16DBL
		  || ELF32_R_TYPE (rel->r_info) == R_390_PC24DBL
		  || ELF32_R_TYPE (rel->r_info) == R_390_PC32DBL
		  || ELF32_R_TYPE (rel->r_info) == R_390_PC32)
		p->pc_count += 1;
	    }
	  break;

	  /* This relocation describes the C++ object vtable hierarchy.
	     Reconstruct it for later use during GC.  */
	case R_390_GNU_VTINHERIT:
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;

	  /* This relocation describes which C++ vtable entries are actually
	     used.  Record for later use during GC.  */
	case R_390_GNU_VTENTRY:
	  BFD_ASSERT (h != NULL);
	  if (h != NULL
	      && !bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Return the section that should be marked against GC for a given
   relocation.  */

static asection *
elf_s390_gc_mark_hook (asection *sec,
		       struct bfd_link_info *info,
		       Elf_Internal_Rela *rel,
		       struct elf_link_hash_entry *h,
		       Elf_Internal_Sym *sym)
{
  if (h != NULL)
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_390_GNU_VTINHERIT:
      case R_390_GNU_VTENTRY:
	return NULL;
      }
  return _bfd_elf_gc_mark_hook (sec, info, rel, h, sym);

}

/* Update the got entry reference counts for the section being removed.  */

static bfd_boolean
elf_s390_gc_sweep_hook (bfd *abfd,
			struct bfd_link_info *info,
			asection *sec,
			const Elf_Internal_Rela *relocs)
{
  struct elf_s390_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_signed_vma *local_got_refcounts;
  const Elf_Internal_Rela *rel, *relend;

  if (info->relocatable)
    return TRUE;

  htab = elf_s390_hash_table (info);
  if (htab == NULL)
    return FALSE;

  elf_section_data (sec)->local_dynrel = NULL;

  symtab_hdr = &elf_symtab_hdr (abfd);
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);

  relend = relocs + sec->reloc_count;
  for (rel = relocs; rel < relend; rel++)
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf_s390_link_hash_entry *eh;
	  struct elf_dyn_relocs **pp;
	  struct elf_dyn_relocs *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
	  eh = (struct elf_s390_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
      else
	{
	  Elf_Internal_Sym *isym;

	  /* A local symbol.  */
	  isym = bfd_sym_from_r_symndx (&htab->sym_cache,
					abfd, r_symndx);
	  if (isym == NULL)
	    return FALSE;

	  if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
	    {
	      struct plt_entry *plt = elf_s390_local_plt (abfd);
	      if (plt[r_symndx].plt.refcount > 0)
		plt[r_symndx].plt.refcount--;
	    }
	}

      r_type = ELF32_R_TYPE (rel->r_info);
      r_type = elf_s390_tls_transition (info, r_type, h != NULL);
      switch (r_type)
	{
	case R_390_TLS_LDM32:
	  if (elf_s390_hash_table (info)->tls_ldm_got.refcount > 0)
	    elf_s390_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;

	case R_390_TLS_GD32:
	case R_390_TLS_IE32:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE32:
	case R_390_TLS_IEENT:
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	case R_390_GOTENT:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	case R_390_8:
	case R_390_12:
	case R_390_16:
	case R_390_20:
	case R_390_32:
	case R_390_PC16:
	case R_390_PC12DBL:
	case R_390_PC16DBL:
	case R_390_PC24DBL:
	case R_390_PC32DBL:
	case R_390_PC32:
	  if (info->shared)
	    break;
	  /* Fall through.  */

	case R_390_PLT12DBL:
	case R_390_PLT16DBL:
	case R_390_PLT24DBL:
	case R_390_PLT32DBL:
	case R_390_PLT32:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;

	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		{
		  ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount--;
		  h->plt.refcount -= 1;
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;

	default:
	  break;
	}
    }

  return TRUE;
}

/* Make sure we emit a GOT entry if the symbol was supposed to have a PLT
   entry but we found we will not create any.  Called when we find we will
   not have any PLT for this symbol, by for example
   elf_s390_adjust_dynamic_symbol when we're doing a proper dynamic link,
   or elf_s390_size_dynamic_sections if no dynamic sections will be
   created (we're only linking static objects).  */

static void
elf_s390_adjust_gotplt (struct elf_s390_link_hash_entry *h)
{
  if (h->elf.root.type == bfd_link_hash_warning)
    h = (struct elf_s390_link_hash_entry *) h->elf.root.u.i.link;

  if (h->gotplt_refcount <= 0)
    return;

  /* We simply add the number of gotplt references to the number
   * of got references for this symbol.  */
  h->elf.got.refcount += h->gotplt_refcount;
  h->gotplt_refcount = -1;
}

/* Adjust a symbol defined by a dynamic object and referenced by a
   regular object.  The current definition is in some section of the
   dynamic object, but we're not including those sections.  We have to
   change the definition to something the rest of the link can
   understand.  */

static bfd_boolean
elf_s390_adjust_dynamic_symbol (struct bfd_link_info *info,
				struct elf_link_hash_entry *h)
{
  struct elf_s390_link_hash_table *htab;
  asection *s;

  /* STT_GNU_IFUNC symbol must go through PLT. */
  if (s390_is_ifunc_symbol_p (h))
    return TRUE;

  /* If this is a function, put it in the procedure linkage table.  We
     will fill in the contents of the procedure linkage table later
     (although we could actually do it here).  */
  if (h->type == STT_FUNC
      || h->needs_plt)
    {
      if (h->plt.refcount <= 0
	  || SYMBOL_CALLS_LOCAL (info, h)
	  || (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	      && h->root.type != bfd_link_hash_undefweak))
	{
	  /* This case can occur if we saw a PLT32 reloc in an input
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
	     such a case, we don't actually need to build a procedure
	     linkage table, and we can just do a PC32 reloc instead.  */
	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
	}

      return TRUE;
    }
  else
    /* It's possible that we incorrectly decided a .plt reloc was
       needed for an R_390_PC32 reloc to a non-function sym in
       check_relocs.  We can't decide accurately between function and
       non-function syms in check-relocs;  Objects loaded later in
       the link may change h->type.  So fix it now.  */
    h->plt.offset = (bfd_vma) -1;

  /* If this is a weak symbol, and there is a real definition, the
     processor independent code will have arranged for us to see the
     real definition first, and we can just use the same value.  */
  if (h->u.weakdef != NULL)
    {
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->non_got_ref = h->u.weakdef->non_got_ref;
      return TRUE;
    }

  /* This is a reference to a symbol defined by a dynamic object which
     is not a function.  */

  /* If we are creating a shared library, we must presume that the
     only references to the symbol are via the global offset table.
     For such cases we need not do anything here; the relocations will
     be handled correctly by relocate_section.  */
  if (info->shared)
    return TRUE;

  /* If there are no references to this symbol that do not use the
     GOT, we don't need to generate a copy reloc.  */
  if (!h->non_got_ref)
    return TRUE;

  /* If -z nocopyreloc was given, we won't generate them either.  */
  if (info->nocopyreloc)
    {
      h->non_got_ref = 0;
      return TRUE;
    }

  if (ELIMINATE_COPY_RELOCS)
    {
      struct elf_s390_link_hash_entry * eh;
      struct elf_dyn_relocs *p;

      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->non_got_ref = 0;
	  return TRUE;
	}
    }

  /* We must allocate the symbol in our .dynbss section, which will
     become part of the .bss section of the executable.  There will be
     an entry for this symbol in the .dynsym section.  The dynamic
     object will contain position independent code, so all references
     from the dynamic object to this symbol will go through the global
     offset table.  The dynamic linker will use the .dynsym entry to
     determine the address it must put in the global offset table, so
     both the dynamic object and the regular object will refer to the
     same memory location for the variable.  */

  htab = elf_s390_hash_table (info);

  /* We must generate a R_390_COPY reloc to tell the dynamic linker to
     copy the initial value out of the dynamic object and into the
     runtime process image.  */
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0 && h->size != 0)
    {
      htab->srelbss->size += sizeof (Elf32_External_Rela);
      h->needs_copy = 1;
    }

  s = htab->sdynbss;

  return _bfd_elf_adjust_dynamic_copy (h, s);
}

/* Allocate space in .plt, .got and associated reloc sections for
   dynamic relocs.  */

static bfd_boolean
allocate_dynrelocs (struct elf_link_hash_entry *h, void * inf)
{
  struct bfd_link_info *info;
  struct elf_s390_link_hash_table *htab;
  struct elf_s390_link_hash_entry *eh = (struct elf_s390_link_hash_entry *)h;
  struct elf_dyn_relocs *p;

  if (h->root.type == bfd_link_hash_indirect)
    return TRUE;

  info = (struct bfd_link_info *) inf;
  htab = elf_s390_hash_table (info);

  /* Since STT_GNU_IFUNC symbol must go through PLT, we handle it
     here if it is defined and referenced in a non-shared object.  */
  if (s390_is_ifunc_symbol_p (h) && h->def_regular)
    return s390_elf_allocate_ifunc_dyn_relocs (info, h,
					       &eh->dyn_relocs);
  else if (htab->elf.dynamic_sections_created
	   && h->plt.refcount > 0)
    {
      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
	{
	  asection *s = htab->elf.splt;

	  /* If this is the first .plt entry, make room for the special
	     first entry.  */
	  if (s->size == 0)
	    s->size += PLT_FIRST_ENTRY_SIZE;

	  h->plt.offset = s->size;

	  /* If this symbol is not defined in a regular file, and we are
	     not generating a shared library, then set the symbol to this
	     location in the .plt.  This is required to make function
	     pointers compare as equal between the normal executable and
	     the shared library.  */
	  if (! info->shared
	      && !h->def_regular)
	    {
	      h->root.u.def.section = s;
	      h->root.u.def.value = h->plt.offset;
	    }

	  /* Make room for this entry.  */
	  s->size += PLT_ENTRY_SIZE;

	  /* We also need to make an entry in the .got.plt section, which
	     will be placed in the .got section by the linker script.  */
	  htab->elf.sgotplt->size += GOT_ENTRY_SIZE;

	  /* We also need to make an entry in the .rela.plt section.  */
	  htab->elf.srelplt->size += sizeof (Elf32_External_Rela);
	}
      else
	{
 	  h->plt.offset = (bfd_vma) -1;
	  h->needs_plt = 0;
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
	}
    }
  else
    {
      h->plt.offset = (bfd_vma) -1;
      h->needs_plt = 0;
      elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
    }

  /* If R_390_TLS_{IE32,GOTIE32,GOTIE12,IEENT} symbol is now local to
     the binary, we can optimize a bit. IE32 and GOTIE32 get converted
     to R_390_TLS_LE32 requiring no TLS entry. For GOTIE12 and IEENT
     we can save the dynamic TLS relocation.  */
  if (h->got.refcount > 0
      && !info->shared
      && h->dynindx == -1
      && elf_s390_hash_entry(h)->tls_type >= GOT_TLS_IE)
    {
      if (elf_s390_hash_entry(h)->tls_type == GOT_TLS_IE_NLT)
	/* For the GOTIE access without a literal pool entry the offset has
	   to be stored somewhere. The immediate value in the instruction
	   is not bit enough so the value is stored in the got.  */
	{
	  h->got.offset = htab->elf.sgot->size;
	  htab->elf.sgot->size += GOT_ENTRY_SIZE;
	}
      else
	h->got.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
   {
      asection *s;
      bfd_boolean dyn;
      int tls_type = elf_s390_hash_entry(h)->tls_type;

      /* Make sure this symbol is output as a dynamic symbol.
	 Undefined weak syms won't yet be marked as dynamic.  */
      if (h->dynindx == -1
	  && !h->forced_local)
	{
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
	    return FALSE;
	}

      s = htab->elf.sgot;
      h->got.offset = s->size;
      s->size += GOT_ENTRY_SIZE;
      /* R_390_TLS_GD32 needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->size += GOT_ENTRY_SIZE;
      dyn = htab->elf.dynamic_sections_created;
      /* R_390_TLS_IE32 needs one dynamic relocation,
	 R_390_TLS_GD32 needs one if local symbol and two if global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type >= GOT_TLS_IE)
	htab->elf.srelgot->size += sizeof (Elf32_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->elf.srelgot->size += 2 * sizeof (Elf32_External_Rela);
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
	htab->elf.srelgot->size += sizeof (Elf32_External_Rela);
    }
  else
    h->got.offset = (bfd_vma) -1;

  if (eh->dyn_relocs == NULL)
    return TRUE;

  /* In the shared -Bsymbolic case, discard space allocated for
     dynamic pc-relative relocs against symbols which turn out to be
     defined in regular objects.  For the normal shared case, discard
     space for pc-relative relocs that have become local due to symbol
     visibility changes.  */

  if (info->shared)
    {
      if (SYMBOL_CALLS_LOCAL (info, h))
	{
	  struct elf_dyn_relocs **pp;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; )
	    {
	      p->count -= p->pc_count;
	      p->pc_count = 0;
	      if (p->count == 0)
		*pp = p->next;
	      else
		pp = &p->next;
	    }
	}

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (eh->dyn_relocs != NULL
	  && h->root.type == bfd_link_hash_undefweak)
	{
	  if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	    eh->dyn_relocs = NULL;

	  /* Make sure undefined weak symbols are output as a dynamic
	     symbol in PIEs.  */
	  else if (h->dynindx == -1
		   && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }
	}
    }
  else if (ELIMINATE_COPY_RELOCS)
    {
      /* For the non-shared case, discard space for relocs against
	 symbols which turn out to need copy relocs or are not
	 dynamic.  */

      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
	      || (htab->elf.dynamic_sections_created
		  && (h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined))))
	{
	  /* Make sure this symbol is output as a dynamic symbol.
	     Undefined weak syms won't yet be marked as dynamic.  */
	  if (h->dynindx == -1
	      && !h->forced_local)
	    {
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
		return FALSE;
	    }

	  /* If that succeeded, we know we'll be keeping all the
	     relocs.  */
	  if (h->dynindx != -1)
	    goto keep;
	}

      eh->dyn_relocs = NULL;

    keep: ;
    }

  /* Finally, allocate space.  */
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *sreloc = elf_section_data (p->sec)->sreloc;

      sreloc->size += p->count * sizeof (Elf32_External_Rela);
    }

  return TRUE;
}

/* Find any dynamic relocs that apply to read-only sections.  */

static bfd_boolean
readonly_dynrelocs (struct elf_link_hash_entry *h, void * inf)
{
  struct elf_s390_link_hash_entry *eh;
  struct elf_dyn_relocs *p;

  eh = (struct elf_s390_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
    {
      asection *s = p->sec->output_section;

      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	{
	  struct bfd_link_info *info = (struct bfd_link_info *) inf;

	  info->flags |= DF_TEXTREL;

	  /* Not an error, just cut short the traversal.  */
	  return FALSE;
	}
    }
  return TRUE;
}

/* Set the sizes of the dynamic sections.  */

static bfd_boolean
elf_s390_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
				struct bfd_link_info *info)
{
  struct elf_s390_link_hash_table *htab;
  bfd *dynobj;
  asection *s;
  bfd_boolean relocs;
  bfd *ibfd;

  htab = elf_s390_hash_table (info);
  dynobj = htab->elf.dynobj;
  if (dynobj == NULL)
    abort ();

  if (htab->elf.dynamic_sections_created)
    {
      /* Set the contents of the .interp section to the interpreter.  */
      if (info->executable)
	{
	  s = bfd_get_linker_section (dynobj, ".interp");
	  if (s == NULL)
	    abort ();
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
	  s->contents = (unsigned char *) ELF_DYNAMIC_INTERPRETER;
	}
    }

  /* Set up .got offsets for local syms, and space for local dynamic
     relocs.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      bfd_signed_vma *local_got;
      bfd_signed_vma *end_local_got;
      char *local_tls_type;
      bfd_size_type locsymcount;
      Elf_Internal_Shdr *symtab_hdr;
      asection *srela;
      struct plt_entry *local_plt;
      unsigned int i;

      if (! is_s390_elf (ibfd))
	continue;

      for (s = ibfd->sections; s != NULL; s = s->next)
	{
	  struct elf_dyn_relocs *p;

	  for (p = elf_section_data (s)->local_dynrel; p != NULL; p = p->next)
	    {
	      if (!bfd_is_abs_section (p->sec)
		  && bfd_is_abs_section (p->sec->output_section))
		{
		  /* Input section has been discarded, either because
		     it is a copy of a linkonce section or due to
		     linker script /DISCARD/, so we'll be discarding
		     the relocs too.  */
		}
	      else if (p->count != 0)
		{
		  srela = elf_section_data (p->sec)->sreloc;
		  srela->size += p->count * sizeof (Elf32_External_Rela);
		  if ((p->sec->output_section->flags & SEC_READONLY) != 0)
		    info->flags |= DF_TEXTREL;
		}
	    }
	}

      local_got = elf_local_got_refcounts (ibfd);
      if (!local_got)
	continue;

      symtab_hdr = &elf_symtab_hdr (ibfd);
      locsymcount = symtab_hdr->sh_info;
      end_local_got = local_got + locsymcount;
      local_tls_type = elf_s390_local_got_tls_type (ibfd);
      s = htab->elf.sgot;
      srela = htab->elf.srelgot;
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
	{
	  if (*local_got > 0)
	    {
	      *local_got = s->size;
	      s->size += GOT_ENTRY_SIZE;
	      if (*local_tls_type == GOT_TLS_GD)
		s->size += GOT_ENTRY_SIZE;
	      if (info->shared)
		srela->size += sizeof (Elf32_External_Rela);
	    }
	  else
	    *local_got = (bfd_vma) -1;
	}
      local_plt = elf_s390_local_plt (ibfd);
      for (i = 0; i < symtab_hdr->sh_info; i++)
	{
	  if (local_plt[i].plt.refcount > 0)
	    {
	      local_plt[i].plt.offset = htab->elf.iplt->size;
	      htab->elf.iplt->size += PLT_ENTRY_SIZE;
	      htab->elf.igotplt->size += GOT_ENTRY_SIZE;
	      htab->elf.irelplt->size += RELA_ENTRY_SIZE;
	    }
	  else
            local_plt[i].plt.offset = (bfd_vma) -1;
	}
    }

  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_390_TLS_LDM32
	 relocs.  */
      htab->tls_ldm_got.offset = htab->elf.sgot->size;
      htab->elf.sgot->size += 2 * GOT_ENTRY_SIZE;
      htab->elf.srelgot->size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

  /* Allocate global sym .plt and .got entries, and space for global
     sym dynamic relocs.  */
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, info);

  /* We now have determined the sizes of the various dynamic sections.
     Allocate memory for them.  */
  relocs = FALSE;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      if ((s->flags & SEC_LINKER_CREATED) == 0)
	continue;

      if (s == htab->elf.splt
	  || s == htab->elf.sgot
	  || s == htab->elf.sgotplt
	  || s == htab->sdynbss
	  || s == htab->elf.iplt
	  || s == htab->elf.igotplt
	  || s == htab->irelifunc)
	{
	  /* Strip this section if we don't need it; see the
	     comment below.  */
	}
      else if (CONST_STRNEQ (bfd_get_section_name (dynobj, s), ".rela"))
	{
	  if (s->size != 0)
	    relocs = TRUE;

	  /* We use the reloc_count field as a counter if we need
	     to copy relocs into the output file.  */
	  s->reloc_count = 0;
	}
      else
	{
	  /* It's not one of our sections, so don't allocate space.  */
	  continue;
	}

      if (s->size == 0)
	{
	  /* If we don't need this section, strip it from the
	     output file.  This is to handle .rela.bss and
	     .rela.plt.  We must create it in
	     create_dynamic_sections, because it must be created
	     before the linker maps input sections to output
	     sections.  The linker does that before
	     adjust_dynamic_symbol is called, and it is that
	     function which decides whether anything needs to go
	     into these sections.  */

	  s->flags |= SEC_EXCLUDE;
	  continue;
	}

      if ((s->flags & SEC_HAS_CONTENTS) == 0)
	continue;

      /* Allocate memory for the section contents.  We use bfd_zalloc
	 here in case unused entries are not reclaimed before the
	 section's contents are written out.  This should not happen,
	 but this way if it does, we get a R_390_NONE reloc instead
	 of garbage.  */
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
      if (s->contents == NULL)
	return FALSE;
    }

  if (htab->elf.dynamic_sections_created)
    {
      /* Add some entries to the .dynamic section.  We fill in the
	 values later, in elf_s390_finish_dynamic_sections, but we
	 must add the entries now so that we get the correct size for
	 the .dynamic section.  The DT_DEBUG entry is filled in by the
	 dynamic linker and used by the debugger.  */
#define add_dynamic_entry(TAG, VAL) \
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)

      if (info->executable)
	{
	  if (!add_dynamic_entry (DT_DEBUG, 0))
	    return FALSE;
	}

      if (htab->elf.splt->size != 0)
	{
	  if (!add_dynamic_entry (DT_PLTGOT, 0)
	      || !add_dynamic_entry (DT_PLTRELSZ, 0)
	      || !add_dynamic_entry (DT_PLTREL, DT_RELA)
	      || !add_dynamic_entry (DT_JMPREL, 0))
	    return FALSE;
	}

      if (relocs)
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;

	  /* If any dynamic relocs apply to a read-only section,
	     then we need a DT_TEXTREL entry.  */
	  if ((info->flags & DF_TEXTREL) == 0)
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, info);

	  if ((info->flags & DF_TEXTREL) != 0)
	    {
	      if (!add_dynamic_entry (DT_TEXTREL, 0))
		return FALSE;
	    }
	}
    }
#undef add_dynamic_entry

  return TRUE;
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (struct bfd_link_info *info)
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (struct bfd_link_info *info, bfd_vma address)
{
  struct elf_link_hash_table *htab = elf_hash_table (info);

  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;
  return htab->tls_size + htab->tls_sec->vma - address;
}

/* Complain if TLS instruction relocation is against an invalid
   instruction.  */

static void
invalid_tls_insn (bfd *input_bfd,
		  asection *input_section,
		  Elf_Internal_Rela *rel)
{
  reloc_howto_type *howto;

  howto = elf_howto_table + ELF32_R_TYPE (rel->r_info);
  (*_bfd_error_handler)
    (_("%B(%A+0x%lx): invalid instruction for TLS relocation %s"),
     input_bfd,
     input_section,
     (long) rel->r_offset,
     howto->name);
  bfd_set_error (bfd_error_bad_value);
}

/* Relocate a 390 ELF section.  */

static bfd_boolean
elf_s390_relocate_section (bfd *output_bfd,
			   struct bfd_link_info *info,
			   bfd *input_bfd,
			   asection *input_section,
			   bfd_byte *contents,
			   Elf_Internal_Rela *relocs,
			   Elf_Internal_Sym *local_syms,
			   asection **local_sections)
{
  struct elf_s390_link_hash_table *htab;
  Elf_Internal_Shdr *symtab_hdr;
  struct elf_link_hash_entry **sym_hashes;
  bfd_vma *local_got_offsets;
  Elf_Internal_Rela *rel;
  Elf_Internal_Rela *relend;

  BFD_ASSERT (is_s390_elf (input_bfd));

  htab = elf_s390_hash_table (info);
  symtab_hdr = &elf_symtab_hdr (input_bfd);
  sym_hashes = elf_sym_hashes (input_bfd);
  local_got_offsets = elf_local_got_offsets (input_bfd);

  rel = relocs;
  relend = relocs + input_section->reloc_count;
  for (; rel < relend; rel++)
    {
      unsigned int r_type;
      reloc_howto_type *howto;
      unsigned long r_symndx;
      struct elf_link_hash_entry *h;
      Elf_Internal_Sym *sym;
      asection *sec;
      bfd_vma off;
      bfd_vma relocation;
      bfd_boolean unresolved_reloc;
      bfd_reloc_status_type r;
      int tls_type;
      asection *base_got = htab->elf.sgot;

      r_type = ELF32_R_TYPE (rel->r_info);
      if (r_type == (int) R_390_GNU_VTINHERIT
	  || r_type == (int) R_390_GNU_VTENTRY)
	continue;
      if (r_type >= (int) R_390_max)
	{
	  bfd_set_error (bfd_error_bad_value);
	  return FALSE;
	}

      howto = elf_howto_table + r_type;
      r_symndx = ELF32_R_SYM (rel->r_info);

      h = NULL;
      sym = NULL;
      sec = NULL;
      unresolved_reloc = FALSE;
      if (r_symndx < symtab_hdr->sh_info)
	{
	  sym = local_syms + r_symndx;
	  sec = local_sections[r_symndx];
	  if (ELF_ST_TYPE (sym->st_info) == STT_GNU_IFUNC)
	    {
	      struct plt_entry *local_plt = elf_s390_local_plt (input_bfd);
	      if (local_plt == NULL)
		return FALSE;

	      /* Address of the PLT slot.  */
	      relocation = (htab->elf.iplt->output_section->vma
			    + htab->elf.iplt->output_offset
			    + local_plt[r_symndx].plt.offset);

	      switch (r_type)
		{
		case R_390_PLTOFF16:
		case R_390_PLTOFF32:
		  relocation -= htab->elf.sgot->output_section->vma;
		  break;
		case R_390_GOTPLT12:
		case R_390_GOTPLT16:
		case R_390_GOTPLT20:
		case R_390_GOTPLT32:
		case R_390_GOTPLTENT:
		case R_390_GOT12:
		case R_390_GOT16:
		case R_390_GOT20:
		case R_390_GOT32:
		case R_390_GOTENT:
		  {
		    /* Write the PLT slot address into the GOT slot.  */
		    bfd_put_32 (output_bfd, relocation,
				htab->elf.sgot->contents +
				local_got_offsets[r_symndx]);
		    relocation = (local_got_offsets[r_symndx] +
				  htab->elf.sgot->output_offset);

		    if (r_type == R_390_GOTENT || r_type == R_390_GOTPLTENT)
		      relocation += htab->elf.sgot->output_section->vma;
		    break;
		  }
		default:
		  break;
		}
	      /* The output section is needed later in
		 finish_dynamic_section when creating the dynamic
		 relocation.  */
	      local_plt[r_symndx].sec = sec;
	      goto do_relocation;
	    }
	  else
	    relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
	}
      else
	{
	  bfd_boolean warned ATTRIBUTE_UNUSED;

	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
	}

      if (sec != NULL && discarded_section (sec))
	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
					 rel, 1, relend, howto, 0, contents);

      if (info->relocatable)
	continue;

      switch (r_type)
	{
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  /* There are three cases for a GOTPLT relocation. 1) The
	     relocation is against the jump slot entry of a plt that
	     will get emitted to the output file. 2) The relocation
	     is against the jump slot of a plt entry that has been
	     removed. elf_s390_adjust_gotplt has created a GOT entry
	     as replacement. 3) The relocation is against a local symbol.
	     Cases 2) and 3) are the same as the GOT relocation code
	     so we just have to test for case 1 and fall through for
	     the other two.  */
	  if (h != NULL && h->plt.offset != (bfd_vma) -1)
	    {
	      bfd_vma plt_index;

	      if (s390_is_ifunc_symbol_p (h))
		{
		  plt_index = h->plt.offset / PLT_ENTRY_SIZE;
		  relocation = (plt_index * GOT_ENTRY_SIZE +
				htab->elf.igotplt->output_offset);
		  if (r_type == R_390_GOTPLTENT)
		    relocation += htab->elf.igotplt->output_section->vma;
		}
	      else
		{
		  /* Calc. index no.
		     Current offset - size first entry / entry size.  */
		  plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) /
		    PLT_ENTRY_SIZE;

		  /* Offset in GOT is PLT index plus GOT headers(3)
		     times 4, addr & GOT addr.  */
		  relocation = (plt_index + 3) * GOT_ENTRY_SIZE;
		  if (r_type == R_390_GOTPLTENT)
		    relocation += htab->elf.sgot->output_section->vma;
		}
	      unresolved_reloc = FALSE;

	    }
	  /* Fall through.  */

	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOTENT:
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
	  if (base_got == NULL)
	    abort ();

	  if (h != NULL)
	    {
	      bfd_boolean dyn;

	      off = h->got.offset;
	      dyn = htab->elf.dynamic_sections_created;

	      if (s390_is_ifunc_symbol_p (h))
		{
		  BFD_ASSERT (h->plt.offset != (bfd_vma) -1);
		  if (off == (bfd_vma)-1)
		    {
		      /* No explicit GOT usage so redirect to the
			 got.iplt slot.  */
		      base_got = htab->elf.igotplt;
		      off = h->plt.offset / PLT_ENTRY_SIZE * GOT_ENTRY_SIZE;
		    }
		  else
		    {
		      /* Explicit GOT slots must contain the address
			 of the PLT slot. This will be handled in
			 finish_dynamic_symbol.  */
		    }
		}
	      else if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		       || (info->shared
			   && SYMBOL_REFERENCES_LOCAL (info, h))
		       || (ELF_ST_VISIBILITY (h->other)
			   && h->root.type == bfd_link_hash_undefweak))

		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 2, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rel.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
		      bfd_put_32 (output_bfd, relocation,
				  base_got->contents + off);
		      h->got.offset |= 1;
		    }

		  if ((h->def_regular
		       && info->shared
		       && SYMBOL_REFERENCES_LOCAL (info, h))
		      /* lrl rx,sym@@GOTENT -> larl rx, sym */
		      && ((r_type == R_390_GOTENT
			   && (bfd_get_16 (input_bfd,
					   contents + rel->r_offset - 2)
			       & 0xff0f) == 0xc40d)
			  /* ly rx, sym@@GOT(r12) -> larl rx, sym */
			  || (r_type == R_390_GOT20
			      && (bfd_get_32 (input_bfd,
					      contents + rel->r_offset - 2)
				  & 0xff00f000) == 0xe300c000
			      && bfd_get_8 (input_bfd,
					    contents + rel->r_offset + 3) == 0x58)))
		    {
		      unsigned short new_insn =
			(0xc000 | (bfd_get_8 (input_bfd,
					      contents + rel->r_offset - 1) & 0xf0));
		      bfd_put_16 (output_bfd, new_insn,
				  contents + rel->r_offset - 2);
		      r_type = R_390_PC32DBL;
		      rel->r_addend = 2;
		      howto = elf_howto_table + r_type;
		      relocation = h->root.u.def.value
			+ h->root.u.def.section->output_section->vma
			+ h->root.u.def.section->output_offset;
		      goto do_relocation;
		    }
		}
	      else
		unresolved_reloc = FALSE;
	    }
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];

	      /* The offset must always be a multiple of 4.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_32 (output_bfd, relocation,
			      htab->elf.sgot->contents + off);

		  if (info->shared)
		    {
		      asection *srelgot;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;

		      srelgot = htab->elf.srelgot;
		      if (srelgot == NULL)
			abort ();

		      outrel.r_offset = (htab->elf.sgot->output_section->vma
					 + htab->elf.sgot->output_offset
					 + off);
		      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
		      outrel.r_addend = relocation;
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  local_got_offsets[r_symndx] |= 1;
		}
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();

	  relocation = base_got->output_offset + off;

	  /* For @@GOTENT the relocation is against the offset between
	     the instruction and the symbols entry in the GOT and not
	     between the start of the GOT and the symbols entry. We
	     add the vma of the GOT to get the correct value.  */
	  if (   r_type == R_390_GOTENT
	      || r_type == R_390_GOTPLTENT)
	    relocation += base_got->output_section->vma;

	  break;

	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  relocation -= htab->elf.sgot->output_section->vma;
	  break;

	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  /* Use global offset table as symbol value.  */
	  relocation = htab->elf.sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_PLT12DBL:
	case R_390_PLT16DBL:
	case R_390_PLT24DBL:
	case R_390_PLT32DBL:
	case R_390_PLT32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT32 reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    break;

	  if (h->plt.offset == (bfd_vma) -1
	      || (htab->elf.splt == NULL && htab->elf.iplt == NULL))
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }

	  if (s390_is_ifunc_symbol_p (h))
	    relocation = (htab->elf.iplt->output_section->vma
                          + htab->elf.iplt->output_offset
			  + h->plt.offset);
	  else
	    relocation = (htab->elf.splt->output_section->vma
			  + htab->elf.splt->output_offset
			  + h->plt.offset);
	  unresolved_reloc = FALSE;
	  break;

	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table relative to the start of the GOT.  */

	  /* For local symbols or if we didn't make a PLT entry for
	     this symbol resolve the symbol directly.  */
	  if (h == NULL
	      || h->plt.offset == (bfd_vma) -1
	      || (htab->elf.splt == NULL && !s390_is_ifunc_symbol_p (h)))
	    {
	      relocation -= htab->elf.sgot->output_section->vma;
	      break;
	    }

	  if (s390_is_ifunc_symbol_p (h))
	    relocation = (htab->elf.iplt->output_section->vma
			  + htab->elf.iplt->output_offset
			  + h->plt.offset
			  - htab->elf.sgot->output_section->vma);
	  else
	    relocation = (htab->elf.splt->output_section->vma
			  + htab->elf.splt->output_offset
			  + h->plt.offset
			  - htab->elf.sgot->output_section->vma);
	  unresolved_reloc = FALSE;
	  break;

	case R_390_8:
	case R_390_16:
	case R_390_32:
	case R_390_PC16:
	case R_390_PC12DBL:
	case R_390_PC16DBL:
	case R_390_PC24DBL:
	case R_390_PC32DBL:
	case R_390_PC32:
	  if (h != NULL
	      && s390_is_ifunc_symbol_p (h)
	      && h->def_regular)
	    {
	      if (!info->shared || !h->non_got_ref)
		{
		  /* For a non-shared object STT_GNU_IFUNC symbol must
		     go through PLT.  */
		  relocation = (htab->elf.iplt->output_section->vma
				+ htab->elf.iplt->output_offset
				+ h ->plt.offset);
		  goto do_relocation;
		}
	      else
		{
		  /* For shared objects a runtime relocation is needed.  */

		  Elf_Internal_Rela outrel;
		  asection *sreloc;

		  /* Need a dynamic relocation to get the real function
		     address.  */
		  outrel.r_offset = _bfd_elf_section_offset (output_bfd,
							     info,
							     input_section,
							     rel->r_offset);
		  if (outrel.r_offset == (bfd_vma) -1
		      || outrel.r_offset == (bfd_vma) -2)
		    abort ();

		  outrel.r_offset += (input_section->output_section->vma
				      + input_section->output_offset);

		  if (h->dynindx == -1
		      || h->forced_local
		      || info->executable)
		    {
		      /* This symbol is resolved locally.  */
		      outrel.r_info = ELF32_R_INFO (0, R_390_IRELATIVE);
		      outrel.r_addend = (h->root.u.def.value
					 + h->root.u.def.section->output_section->vma
					 + h->root.u.def.section->output_offset);
		    }
		  else
		    {
		      outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
		      outrel.r_addend = 0;
		    }

		  sreloc = htab->elf.irelifunc;
		  elf_append_rela (output_bfd, sreloc, &outrel);

		  /* If this reloc is against an external symbol, we
		     do not want to fiddle with the addend.  Otherwise,
		     we need to include the symbol value so that it
		     becomes an addend for the dynamic reloc.  For an
		     internal symbol, we have updated addend.  */
		  continue;
		}
	    }

	  if ((input_section->flags & SEC_ALLOC) == 0)
	    break;

	  if ((info->shared
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
	       && ((r_type != R_390_PC16
		    && r_type != R_390_PC12DBL
		    && r_type != R_390_PC16DBL
		    && r_type != R_390_PC24DBL
		    && r_type != R_390_PC32DBL
		    && r_type != R_390_PC32)
		   || !SYMBOL_CALLS_LOCAL (info, h)))
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
		  && h != NULL
		  && h->dynindx != -1
		  && !h->non_got_ref
		  && ((h->def_dynamic
		       && !h->def_regular)
		      || h->root.type == bfd_link_hash_undefweak
		      || h->root.type == bfd_link_hash_undefined)))
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate;
	      asection *sreloc;
	      bfd_byte *loc;

	      /* When generating a shared object, these relocations
		 are copied into the output file to be resolved at run
		 time.  */

	      skip = FALSE;
	      relocate = FALSE;

	      outrel.r_offset =
		_bfd_elf_section_offset (output_bfd, info, input_section,
					 rel->r_offset);
	      if (outrel.r_offset == (bfd_vma) -1)
		skip = TRUE;
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = TRUE, relocate = TRUE;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);

	      if (skip)
		memset (&outrel, 0, sizeof outrel);
	      else if (h != NULL
		       && h->dynindx != -1
		       && (r_type == R_390_PC16
			   || r_type == R_390_PC12DBL
			   || r_type == R_390_PC16DBL
			   || r_type == R_390_PC24DBL
			   || r_type == R_390_PC32DBL
			   || r_type == R_390_PC32
			   || !info->shared
			   || !SYMBOLIC_BIND (info, h)
			   || !h->def_regular))
		{
		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
		  outrel.r_addend = rel->r_addend;
		}
	      else
		{
		  /* This symbol is local, or marked to become local.  */
		  outrel.r_addend = relocation + rel->r_addend;
		  if (r_type == R_390_32)
		    {
		      relocate = TRUE;
		      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
		    }
		  else
		    {
		      long sindx;

		      if (bfd_is_abs_section (sec))
			sindx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error(bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  sindx = elf_section_data (osec)->dynindx;
			  if (sindx == 0)
			    {
			      osec = htab->elf.text_index_section;
			      sindx = elf_section_data (osec)->dynindx;
			    }
			  BFD_ASSERT (sindx != 0);

			  /* We are turning this relocation into one
			     against a section symbol, so subtract out
			     the output section's address but not the
			     offset of the input section in the output
			     section.  */
			  outrel.r_addend -= osec->vma;
			}
		      outrel.r_info = ELF32_R_INFO (sindx, r_type);
		    }
		}

	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();

	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }
	  break;

	  /* Relocations for tls literal pool entries.  */
	case R_390_TLS_IE32:
	  if (info->shared)
	    {
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
	    }
	  /* Fall through.  */

	case R_390_TLS_GD32:
	case R_390_TLS_GOTIE32:
	  r_type = elf_s390_tls_transition (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type >= GOT_TLS_IE)
		r_type = R_390_TLS_LE32;
	    }
	  if (r_type == R_390_TLS_GD32 && tls_type >= GOT_TLS_IE)
	    r_type = R_390_TLS_IE32;

	  if (r_type == R_390_TLS_LE32)
	    {
	      /* This relocation gets optimized away by the local exec
		 access optimization.  */
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_32 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	      continue;
	    }

	  if (htab->elf.sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	emit_tls_relocs:

	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      int dr_type, indx;

	      if (htab->elf.srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->elf.sgot->output_section->vma
				 + htab->elf.sgot->output_offset + off);

	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_390_TLS_GD32)
		dr_type = R_390_TLS_DTPMOD;
	      else
		dr_type = R_390_TLS_TPOFF;
	      if (dr_type == R_390_TLS_TPOFF && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (indx, dr_type);
	      loc = htab->elf.srelgot->contents;
	      loc += htab->elf.srelgot->reloc_count++
		* sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_390_TLS_GD32)
		{
		  if (indx == 0)
		    {
		      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_32 (output_bfd,
				  relocation - dtpoff_base (info),
				  htab->elf.sgot->contents + off + GOT_ENTRY_SIZE);
		    }
		  else
		    {
		      outrel.r_info = ELF32_R_INFO (indx, R_390_TLS_DTPOFF);
		      outrel.r_offset += GOT_ENTRY_SIZE;
		      outrel.r_addend = 0;
		      htab->elf.srelgot->reloc_count++;
		      loc += sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();
	  if (r_type == ELF32_R_TYPE (rel->r_info))
	    {
	      relocation = htab->elf.sgot->output_offset + off;
	      if (r_type == R_390_TLS_IE32 || r_type == R_390_TLS_IEENT)
		relocation += htab->elf.sgot->output_section->vma;
	      unresolved_reloc = FALSE;
	    }
	  else
	    {
	      bfd_put_32 (output_bfd, htab->elf.sgot->output_offset + off,
			  contents + rel->r_offset);
	      continue;
	    }
	  break;

	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_IEENT:
	  if (h == NULL)
	    {
	      if (local_got_offsets == NULL)
		abort();
	      off = local_got_offsets[r_symndx];
	      if (info->shared)
		goto emit_tls_relocs;
	    }
	  else
	    {
	      off = h->got.offset;
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (info->shared || h->dynindx != -1 || tls_type < GOT_TLS_IE)
		goto emit_tls_relocs;
	    }

	  if (htab->elf.sgot == NULL)
	    abort ();

	  BFD_ASSERT (! unresolved_reloc);
	  bfd_put_32 (output_bfd, -tpoff (info, relocation),
		      htab->elf.sgot->contents + off);
	  relocation = htab->elf.sgot->output_offset + off;
	  if (r_type == R_390_TLS_IEENT)
	    relocation += htab->elf.sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_TLS_LDM32:
	  if (! info->shared)
	    /* The literal pool entry this relocation refers to gets ignored
	       by the optimized code of the local exec model. Do nothing
	       and the value will turn out zero.  */
	    continue;

	  if (htab->elf.sgot == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;

	      if (htab->elf.srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->elf.sgot->output_section->vma
				 + htab->elf.sgot->output_offset + off);

	      bfd_put_32 (output_bfd, 0,
			  htab->elf.sgot->contents + off + GOT_ENTRY_SIZE);
	      outrel.r_info = ELF32_R_INFO (0, R_390_TLS_DTPMOD);
	      outrel.r_addend = 0;
	      loc = htab->elf.srelgot->contents;
	      loc += htab->elf.srelgot->reloc_count++
		* sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }
	  relocation = htab->elf.sgot->output_offset + off;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_TLS_LE32:
	  if (info->shared)
	    {
	      /* Linking a shared library with non-fpic code requires
		 a R_390_TLS_TPOFF relocation.  */
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;
	      int indx;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      if (h != NULL && h->dynindx != -1)
		indx = h->dynindx;
	      else
		indx = 0;
	      outrel.r_info = ELF32_R_INFO (indx, R_390_TLS_TPOFF);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	    }
	  else
	    {
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_32 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	    }
	  continue;

	case R_390_TLS_LDO32:
	  if (info->shared || (input_section->flags & SEC_DEBUGGING))
	    relocation -= dtpoff_base (info);
	  else
	    /* When converting LDO to LE, we must negate.  */
	    relocation = -tpoff (info, relocation);
	  break;

	  /* Relocations for tls instructions.  */
	case R_390_TLS_LOAD:
	case R_390_TLS_GDCALL:
	case R_390_TLS_LDCALL:
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    tls_type = elf_s390_hash_entry(h)->tls_type;

	  if (tls_type == GOT_TLS_GD)
	    continue;

	  if (r_type == R_390_TLS_LOAD)
	    {
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* IE->LE transition. Four valid cases:
		     l %rx,0(0,%ry)    -> lr %rx,%ry + bcr 0,0
		     l %rx,0(%ry,0)    -> lr %rx,%ry + bcr 0,0
		     l %rx,0(%ry,%r12) -> lr %rx,%ry + bcr 0,0
		     l %rx,0(%r12,%ry) -> lr %rx,%ry + bcr 0,0 */
		  unsigned int insn, ry;

		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  ry = 0;
		  if ((insn & 0xff00f000) == 0x58000000)
		    /* l %rx,0(%ry,0) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x000f0000);
		  else if ((insn & 0xff0f0000) == 0x58000000)
		    /* l %rx,0(0,%ry) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x0000f000) << 4;
		  else if ((insn & 0xff00f000) == 0x5800c000)
		    /* l %rx,0(%ry,%r12) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x000f0000);
		  else if ((insn & 0xff0f0000) == 0x580c0000)
		    /* l %rx,0(%r12,%ry) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x0000f000) << 4;
		  else
		    invalid_tls_insn (input_bfd, input_section, rel);
		  insn = 0x18000700 | (insn & 0x00f00000) | ry;
		  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
		}
	    }
	  else if (r_type == R_390_TLS_GDCALL)
	    {
	      unsigned int insn;

	      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      if ((insn & 0xff000fff) != 0x4d000000 &&
		  (insn & 0xffff0000) != 0xc0e50000 &&
		  (insn & 0xff000000) != 0x0d000000)
		invalid_tls_insn (input_bfd, input_section, rel);
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  if ((insn & 0xff000000) == 0x0d000000)
		    {
		      /* GD->LE transition.
			 basr rx, ry -> nopr r7 */
		      insn = 0x07070000 | (insn & 0xffff);
		    }
		  else if ((insn & 0xff000000) == 0x4d000000)
		    {
		      /* GD->LE transition.
			 bas %r14,0(%rx,%r13) -> bc 0,0  */
		      insn = 0x47000000;
		    }
		  else
		    {
		      /* GD->LE transition.
			 brasl %r14,_tls_get_offset@@plt -> brcl 0,.  */
		      insn = 0xc0040000;
		      bfd_put_16 (output_bfd, 0x0000,
				  contents + rel->r_offset + 4);
		    }
		}
	      else
		{
		  /* If basr is used in the pic case to invoke
		     _tls_get_offset, something went wrong before.  */
		  if ((insn & 0xff000000) == 0x0d000000)
		    invalid_tls_insn (input_bfd, input_section, rel);

		  if ((insn & 0xff000000) == 0x4d000000)
		    {
		      /* GD->IE transition.
			 bas %r14,0(%rx,%r13) -> l %r2,0(%r2,%r12)  */
		      insn = 0x5822c000;
		    }
		  else
		    {
		      /* GD->IE transition.
			 brasl %r14,__tls_get_addr@@plt ->
			 	l %r2,0(%r2,%r12) ; bcr 0,0 */
		      insn = 0x5822c000;
		      bfd_put_16 (output_bfd, 0x0700,
				  contents + rel->r_offset + 4);
		    }
		}
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	    }
	  else if (r_type == R_390_TLS_LDCALL)
	    {
	      if (!info->shared)
		{
		  unsigned int insn;

		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  if ((insn & 0xff000fff) != 0x4d000000 &&
		      (insn & 0xffff0000) != 0xc0e50000 &&
		      (insn & 0xff000000) != 0x0d000000)
		    invalid_tls_insn (input_bfd, input_section, rel);

		  if ((insn & 0xff000000) == 0x0d000000)
		    {
		      /* LD->LE transition.
			 basr rx, ry -> nopr r7 */
		      insn = 0x07070000 | (insn & 0xffff);
		    }
		  else if ((insn & 0xff000000) == 0x4d000000)
		    {
		      /* LD->LE transition.
			 bas %r14,0(%rx,%r13) -> bc 0,0  */
		      insn = 0x47000000;
		    }
		  else
		    {
		      /* LD->LE transition.
			 brasl %r14,__tls_get_offset@@plt -> brcl 0,. */
		      insn = 0xc0040000;
		      bfd_put_16 (output_bfd, 0x0000,
				  contents + rel->r_offset + 4);
		    }
		  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
		}
	    }
	  continue;

	default:
	  break;
	}

      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
      if (unresolved_reloc
	  && !((input_section->flags & SEC_DEBUGGING) != 0
	       && h->def_dynamic)
	  && _bfd_elf_section_offset (output_bfd, info, input_section,
				      rel->r_offset) != (bfd_vma) -1)
	(*_bfd_error_handler)
	  (_("%B(%A+0x%lx): unresolvable %s relocation against symbol `%s'"),
	   input_bfd,
	   input_section,
	   (long) rel->r_offset,
	   howto->name,
	   h->root.root.string);

    do_relocation:

      /* When applying a 24 bit reloc we need to start one byte
	 earlier.  Otherwise the 32 bit get/put bfd operations might
	 access a byte after the actual section.  */
      if (r_type == R_390_PC24DBL
	  || r_type == R_390_PLT24DBL)
	rel->r_offset--;

      if (r_type == R_390_20
	  || r_type == R_390_GOT20
	  || r_type == R_390_GOTPLT20
	  || r_type == R_390_TLS_GOTIE20)
	{
	  relocation += rel->r_addend;
	  relocation = (relocation&0xfff) << 8 | (relocation&0xff000) >> 12;
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, 0);
	}
      else
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel->r_offset,
				      relocation, rel->r_addend);

      if (r != bfd_reloc_ok)
	{
	  const char *name;

	  if (h != NULL)
	    name = h->root.root.string;
	  else
	    {
	      name = bfd_elf_string_from_elf_section (input_bfd,
						      symtab_hdr->sh_link,
						      sym->st_name);
	      if (name == NULL)
		return FALSE;
	      if (*name == '\0')
		name = bfd_section_name (input_bfd, sec);
	    }

	  if (r == bfd_reloc_overflow)
	    {

	      if (! ((*info->callbacks->reloc_overflow)
		     (info, (h ? &h->root : NULL), name, howto->name,
		      (bfd_vma) 0, input_bfd, input_section,
		      rel->r_offset)))
		return FALSE;
	    }
	  else
	    {
	      (*_bfd_error_handler)
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
		 (long) rel->r_offset, name, (int) r);
	      return FALSE;
	    }
	}
    }

  return TRUE;
}

/* Generate the PLT slots together with the dynamic relocations needed
   for IFUNC symbols.  */

static void
elf_s390_finish_ifunc_symbol (bfd *output_bfd,
			      struct bfd_link_info *info,
			      struct elf_link_hash_entry *h,
			      struct elf_s390_link_hash_table *htab,
			      bfd_vma iplt_offset,
			      bfd_vma resolver_address)
{
  bfd_vma iplt_index;
  bfd_vma got_offset;
  bfd_vma igotiplt_offset;
  Elf_Internal_Rela rela;
  bfd_byte *loc;
  asection *plt, *gotplt, *relplt;
  bfd_vma relative_offset;

  if (htab->elf.iplt == NULL
      || htab->elf.igotplt == NULL
      || htab->elf.irelplt == NULL)
    abort ();

  gotplt = htab->elf.igotplt;
  relplt = htab->elf.irelplt;

  /* Index of the PLT slot within iplt section.  */
  iplt_index = iplt_offset / PLT_ENTRY_SIZE;
  plt = htab->elf.iplt;
  /* Offset into the igot.plt section.  */
  igotiplt_offset = iplt_index * GOT_ENTRY_SIZE;
  /* Offset into the got section.  */
  got_offset = igotiplt_offset + gotplt->output_offset;

  /* S390 uses halfwords for relative branch calc!  */
  relative_offset = - (plt->output_offset +
		       (PLT_ENTRY_SIZE * iplt_index) + 18) / 2;
/* If offset is > 32768, branch to a previous branch
   390 can only handle +-64 K jumps.  */
  if ( -32768 > (int) relative_offset )
    relative_offset
      = -(unsigned) (((65536 / PLT_ENTRY_SIZE - 1) * PLT_ENTRY_SIZE) / 2);

  /* Fill in the entry in the procedure linkage table.  */
  if (!info->shared)
    {
      memcpy (plt->contents + iplt_offset, elf_s390_plt_entry,
	      PLT_ENTRY_SIZE);

      /* Adjust jump to the first plt entry.  */
      bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
		  plt->contents + iplt_offset + 20);

      /* Push the GOT offset field.  */
      bfd_put_32 (output_bfd,
		  (gotplt->output_section->vma
		   + got_offset),
		  plt->contents + iplt_offset + 24);
    }
  else if (got_offset < 4096)
    {
      /* The GOT offset is small enough to be used directly as
	 displacement.  */
      memcpy (plt->contents + iplt_offset,
	      elf_s390_plt_pic12_entry,
	      PLT_ENTRY_SIZE);

      /* Put in the GOT offset as displacement value.  The 0xc000
	 value comes from the first word of the plt entry.  Look
	 at the elf_s390_plt_pic16_entry content.  */
      bfd_put_16 (output_bfd, (bfd_vma)0xc000 | got_offset,
		  plt->contents + iplt_offset + 2);

      /* Adjust the jump to the first plt entry.  */
      bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
		  plt->contents + iplt_offset + 20);
    }
  else if (got_offset < 32768)
    {
      /* The GOT offset is too big for a displacement but small
	 enough to be a signed 16 bit immediate value as it can be
	 used in an lhi instruction.  */
      memcpy (plt->contents + iplt_offset,
	      elf_s390_plt_pic16_entry,
	      PLT_ENTRY_SIZE);

      /* Put in the GOT offset for the lhi instruction.  */
      bfd_put_16 (output_bfd, (bfd_vma)got_offset,
		  plt->contents + iplt_offset + 2);

      /* Adjust the jump to the first plt entry.  */
      bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
		  plt->contents + iplt_offset + 20);
    }
  else
    {
      memcpy (plt->contents + iplt_offset,
	      elf_s390_plt_pic_entry,
	      PLT_ENTRY_SIZE);

      /* Adjust the jump to the first plt entry.  */
      bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
		  plt->contents + iplt_offset + 20);

      /* Push the GOT offset field.  */
      bfd_put_32 (output_bfd, got_offset,
		  plt->contents + iplt_offset + 24);
    }
  /* Insert offset into  reloc. table here.  */
  bfd_put_32 (output_bfd, relplt->output_offset +
	      iplt_index * RELA_ENTRY_SIZE,
	      plt->contents + iplt_offset + 28);

  /* Fill in the entry in the global offset table.
     Points to instruction after GOT offset.  */
  bfd_put_32 (output_bfd,
	      (plt->output_section->vma
	       + plt->output_offset
	       + iplt_offset
	       + 12),
	      gotplt->contents + igotiplt_offset);

  /* Fill in the entry in the .rela.plt section.  */
  rela.r_offset = gotplt->output_section->vma + got_offset;

  if (!h
      || h->dynindx == -1
      || ((info->executable
	   || ELF_ST_VISIBILITY (h->other) != STV_DEFAULT)
	  && h->def_regular))
    {
      /* The symbol can be locally resolved.  */
      rela.r_info = ELF32_R_INFO (0, R_390_IRELATIVE);
      rela.r_addend = resolver_address;
    }
  else
    {
      rela.r_info = ELF32_R_INFO (h->dynindx, R_390_JMP_SLOT);
      rela.r_addend = 0;
    }

  loc = relplt->contents + iplt_index * RELA_ENTRY_SIZE;
  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
}

/* Finish up dynamic symbol handling.  We set the contents of various
   dynamic sections here.  */

static bfd_boolean
elf_s390_finish_dynamic_symbol (bfd *output_bfd,
				struct bfd_link_info *info,
				struct elf_link_hash_entry *h,
				Elf_Internal_Sym *sym)
{
  struct elf_s390_link_hash_table *htab;
  struct elf_s390_link_hash_entry *eh = (struct elf_s390_link_hash_entry*)h;

  htab = elf_s390_hash_table (info);

  if (h->plt.offset != (bfd_vma) -1)
    {
      bfd_vma plt_index;
      bfd_vma got_offset;
      Elf_Internal_Rela rela;
      bfd_byte *loc;
      bfd_vma relative_offset;

      /* This symbol has an entry in the procedure linkage table.  Set
	 it up.  */
      if (s390_is_ifunc_symbol_p (h))
	{
	  /* If we can resolve the IFUNC symbol locally we generate an
	     IRELATIVE reloc.  */
	  elf_s390_finish_ifunc_symbol (output_bfd, info, h, htab, h->plt.offset,
					eh->ifunc_resolver_address +
					eh->ifunc_resolver_section->output_offset +
					eh->ifunc_resolver_section->output_section->vma);
	  /* Fallthrough.  Handling of explicit GOT slots of IFUNC
	     symbols is below.  */
	}
      else
	{
	  if (h->dynindx == -1
	      || htab->elf.splt == NULL
	      || htab->elf.sgotplt == NULL
	      || htab->elf.srelplt == NULL)
	    abort ();

	  /* Calc. index no.
	     Current offset - size first entry / entry size.  */
	  plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) / PLT_ENTRY_SIZE;

	  /* Offset in GOT is PLT index plus GOT headers(3) times 4,
	     addr & GOT addr.  */
	  got_offset = (plt_index + 3) * GOT_ENTRY_SIZE;

	  /* S390 uses halfwords for relative branch calc!  */
	  relative_offset = - ((PLT_FIRST_ENTRY_SIZE +
				(PLT_ENTRY_SIZE * plt_index) + 18) / 2);
	  /* If offset is > 32768, branch to a previous branch
	     390 can only handle +-64 K jumps.  */
	  if ( -32768 > (int) relative_offset )
	    relative_offset
	      = -(unsigned) (((65536 / PLT_ENTRY_SIZE - 1) * PLT_ENTRY_SIZE) / 2);

	  /* Fill in the entry in the procedure linkage table.  */
	  if (!info->shared)
	    {
	      memcpy (htab->elf.splt->contents + h->plt.offset, elf_s390_plt_entry,
		      PLT_ENTRY_SIZE);

	      /* Adjust jump to the first plt entry.  */
	      bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
			  htab->elf.splt->contents + h->plt.offset + 20);

	      /* Push the GOT offset field.  */
	      bfd_put_32 (output_bfd,
			  (htab->elf.sgotplt->output_section->vma
			   + htab->elf.sgotplt->output_offset
			   + got_offset),
			  htab->elf.splt->contents + h->plt.offset + 24);
	    }
	  else if (got_offset < 4096)
	    {
	      /* The GOT offset is small enough to be used directly as
		 displacement.  */
	      memcpy (htab->elf.splt->contents + h->plt.offset,
		      elf_s390_plt_pic12_entry,
		      PLT_ENTRY_SIZE);

	      /* Put in the GOT offset as displacement value.  The 0xc000
		 value comes from the first word of the plt entry.  Look
		 at the elf_s390_plt_pic16_entry content.  */
	      bfd_put_16 (output_bfd, (bfd_vma)0xc000 | got_offset,
			  htab->elf.splt->contents + h->plt.offset + 2);

	      /* Adjust the jump to the first plt entry.  */
	      bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
			  htab->elf.splt->contents + h->plt.offset + 20);
	    }
	  else if (got_offset < 32768)
	    {
	      /* The GOT offset is too big for a displacement but small
		 enough to be a signed 16 bit immediate value as it can be
		 used in an lhi instruction.  */
	      memcpy (htab->elf.splt->contents + h->plt.offset,
		      elf_s390_plt_pic16_entry,
		      PLT_ENTRY_SIZE);

	      /* Put in the GOT offset for the lhi instruction.  */
	      bfd_put_16 (output_bfd, (bfd_vma)got_offset,
			  htab->elf.splt->contents + h->plt.offset + 2);

	      /* Adjust the jump to the first plt entry.  */
	      bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
			  htab->elf.splt->contents + h->plt.offset + 20);
	    }
	  else
	    {
	      memcpy (htab->elf.splt->contents + h->plt.offset,
		      elf_s390_plt_pic_entry,
		      PLT_ENTRY_SIZE);

	      /* Adjust the jump to the first plt entry.  */
	      bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
			  htab->elf.splt->contents + h->plt.offset + 20);

	      /* Push the GOT offset field.  */
	      bfd_put_32 (output_bfd, got_offset,
			  htab->elf.splt->contents + h->plt.offset + 24);
	    }
	  /* Insert offset into  reloc. table here.  */
	  bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rela),
		      htab->elf.splt->contents + h->plt.offset + 28);

	  /* Fill in the entry in the global offset table.
	     Points to instruction after GOT offset.  */
	  bfd_put_32 (output_bfd,
		      (htab->elf.splt->output_section->vma
		       + htab->elf.splt->output_offset
		       + h->plt.offset
		       + 12),
		      htab->elf.sgotplt->contents + got_offset);

	  /* Fill in the entry in the .rela.plt section.  */
	  rela.r_offset = (htab->elf.sgotplt->output_section->vma
			   + htab->elf.sgotplt->output_offset
			   + got_offset);
	  rela.r_info = ELF32_R_INFO (h->dynindx, R_390_JMP_SLOT);
	  rela.r_addend = 0;
	  loc = htab->elf.srelplt->contents + plt_index * sizeof (Elf32_External_Rela);
	  bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);

	  if (!h->def_regular)
	    {
	      /* Mark the symbol as undefined, rather than as defined in
		 the .plt section.  Leave the value alone.  This is a clue
		 for the dynamic linker, to make function pointer
		 comparisons work between an application and shared
		 library.  */
	      sym->st_shndx = SHN_UNDEF;
	    }
	}
    }

  if (h->got.offset != (bfd_vma) -1
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_GD
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE_NLT)
    {
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbol has an entry in the global offset table.  Set it
	 up.  */

      if (htab->elf.sgot == NULL || htab->elf.srelgot == NULL)
	abort ();

      rela.r_offset = (htab->elf.sgot->output_section->vma
		       + htab->elf.sgot->output_offset
		       + (h->got.offset &~ (bfd_vma) 1));

      /* If this is a static link, or it is a -Bsymbolic link and the
	 symbol is defined locally or was forced to be local because
	 of a version file, we just want to emit a RELATIVE reloc.
	 The entry in the global offset table will already have been
	 initialized in the relocate_section function.  */
      if (h->def_regular && s390_is_ifunc_symbol_p (h))
	{
	  if (info->shared)
	    {
	      /* An explicit GOT slot usage needs GLOB_DAT.  If the
		 symbol references local the implicit got.iplt slot
		 will be used and the IRELATIVE reloc has been created
		 above.  */
	      goto do_glob_dat;
	    }
	  else
	    {
	      /* For non-shared objects explicit GOT slots must be
		 filled with the PLT slot address for pointer
		 equality reasons.  */
	      bfd_put_32 (output_bfd, (htab->elf.iplt->output_section->vma
				       + htab->elf.iplt->output_offset
				       + h->plt.offset),
			  htab->elf.sgot->contents + h->got.offset);
	      return TRUE;
	    }
	}
      else if (info->shared
	  && SYMBOL_REFERENCES_LOCAL (info, h))
	{
	  /* If this is a static link, or it is a -Bsymbolic link and
	     the symbol is defined locally or was forced to be local
	     because of a version file, we just want to emit a
	     RELATIVE reloc.  The entry in the global offset table
	     will already have been initialized in the
	     relocate_section function.  */
	  if (!h->def_regular)
	    return FALSE;
	  BFD_ASSERT((h->got.offset & 1) != 0);
	  rela.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
	  rela.r_addend = (h->root.u.def.value
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
      else
	{
	  BFD_ASSERT((h->got.offset & 1) == 0);
	do_glob_dat:
	  bfd_put_32 (output_bfd, (bfd_vma) 0, htab->elf.sgot->contents + h->got.offset);
	  rela.r_info = ELF32_R_INFO (h->dynindx, R_390_GLOB_DAT);
	  rela.r_addend = 0;
	}

      loc = htab->elf.srelgot->contents;
      loc += htab->elf.srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

  if (h->needs_copy)
    {
      Elf_Internal_Rela rela;
      bfd_byte *loc;

      /* This symbols needs a copy reloc.  Set it up.  */

      if (h->dynindx == -1
	  || (h->root.type != bfd_link_hash_defined
	      && h->root.type != bfd_link_hash_defweak)
	  || htab->srelbss == NULL)
	abort ();

      rela.r_offset = (h->root.u.def.value
		       + h->root.u.def.section->output_section->vma
		       + h->root.u.def.section->output_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_390_COPY);
      rela.r_addend = 0;
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
    }

  /* Mark some specially defined symbols as absolute.  */
  if (h == htab->elf.hdynamic
      || h == htab->elf.hgot
      || h == htab->elf.hplt)
    sym->st_shndx = SHN_ABS;

  return TRUE;
}

/* Used to decide how to sort relocs in an optimal manner for the
   dynamic linker, before writing them out.  */

static enum elf_reloc_type_class
elf_s390_reloc_type_class (const struct bfd_link_info *info ATTRIBUTE_UNUSED,
			   const asection *rel_sec ATTRIBUTE_UNUSED,
			   const Elf_Internal_Rela *rela)
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_390_RELATIVE:
      return reloc_class_relative;
    case R_390_JMP_SLOT:
      return reloc_class_plt;
    case R_390_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

/* Finish up the dynamic sections.  */

static bfd_boolean
elf_s390_finish_dynamic_sections (bfd *output_bfd,
				  struct bfd_link_info *info)
{
  struct elf_s390_link_hash_table *htab;
  bfd *dynobj;
  asection *sdyn;
  bfd *ibfd;
  unsigned int i;

  htab = elf_s390_hash_table (info);
  dynobj = htab->elf.dynobj;
  sdyn = bfd_get_linker_section (dynobj, ".dynamic");

  if (htab->elf.dynamic_sections_created)
    {
      Elf32_External_Dyn *dyncon, *dynconend;

      if (sdyn == NULL || htab->elf.sgot == NULL)
	abort ();

      dyncon = (Elf32_External_Dyn *) sdyn->contents;
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
      for (; dyncon < dynconend; dyncon++)
	{
	  Elf_Internal_Dyn dyn;
	  asection *s;

	  bfd_elf32_swap_dyn_in (dynobj, dyncon, &dyn);

	  switch (dyn.d_tag)
	    {
	    default:
	      continue;

	    case DT_PLTGOT:
	      dyn.d_un.d_ptr = htab->elf.sgot->output_section->vma;
	      break;

	    case DT_JMPREL:
	      dyn.d_un.d_ptr = htab->elf.srelplt->output_section->vma;
	      break;

	    case DT_PLTRELSZ:
	      s = htab->elf.srelplt->output_section;
	      dyn.d_un.d_val = s->size;
	      break;
	    }

	  bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
	}

      /* Fill in the special first entry in the procedure linkage table.  */
      if (htab->elf.splt && htab->elf.splt->size > 0)
	{
	  memset (htab->elf.splt->contents, 0, PLT_FIRST_ENTRY_SIZE);
	  if (info->shared)
	    {
	      memcpy (htab->elf.splt->contents, elf_s390_plt_pic_first_entry,
		      PLT_FIRST_ENTRY_SIZE);
	    }
	  else
	    {
	      memcpy (htab->elf.splt->contents, elf_s390_plt_first_entry,
		      PLT_FIRST_ENTRY_SIZE);
	      bfd_put_32 (output_bfd,
			  htab->elf.sgotplt->output_section->vma
			  + htab->elf.sgotplt->output_offset,
			  htab->elf.splt->contents + 24);
	   }
	  elf_section_data (htab->elf.splt->output_section)
	    ->this_hdr.sh_entsize = 4;
	}

    }

  if (htab->elf.sgotplt)
    {
      /* Fill in the first three entries in the global offset table.  */
      if (htab->elf.sgotplt->size > 0)
	{
	  bfd_put_32 (output_bfd,
		      (sdyn == NULL ? (bfd_vma) 0
		       : sdyn->output_section->vma + sdyn->output_offset),
		      htab->elf.sgotplt->contents);
	  /* One entry for shared object struct ptr.  */
	  bfd_put_32 (output_bfd, (bfd_vma) 0, htab->elf.sgotplt->contents + 4);
	  /* One entry for _dl_runtime_resolve.  */
	  bfd_put_32 (output_bfd, (bfd_vma) 0, htab->elf.sgotplt->contents + 8);
	}

      elf_section_data (htab->elf.sgotplt->output_section)
	->this_hdr.sh_entsize = 4;
    }
  /* Finish dynamic symbol for local IFUNC symbols.  */
  for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
    {
      struct plt_entry *local_plt;
      Elf_Internal_Sym *isym;
      Elf_Internal_Shdr *symtab_hdr;

      symtab_hdr = &elf_symtab_hdr (ibfd);

      local_plt = elf_s390_local_plt (ibfd);
      if (local_plt != NULL)
	for (i = 0; i < symtab_hdr->sh_info; i++)
	  {
	    if (local_plt[i].plt.offset != (bfd_vma) -1)
	      {
		asection *sec = local_plt[i].sec;
		isym = bfd_sym_from_r_symndx (&htab->sym_cache, ibfd, i);
		if (isym == NULL)
		  return FALSE;

		if (ELF_ST_TYPE (isym->st_info) == STT_GNU_IFUNC)
		  elf_s390_finish_ifunc_symbol (output_bfd, info, NULL, htab,
						local_plt[i].plt.offset,
						isym->st_value
						+ sec->output_section->vma
						+ sec->output_offset);

	      }
	  }
    }
  return TRUE;
}

static bfd_boolean
elf_s390_grok_prstatus (bfd * abfd, Elf_Internal_Note * note)
{
  int offset;
  unsigned int size;

  switch (note->descsz)
    {
      default:
	return FALSE;

      case 224:		/* S/390 Linux.  */
	/* pr_cursig */
	elf_tdata (abfd)->core->signal = bfd_get_16 (abfd, note->descdata + 12);

	/* pr_pid */
	elf_tdata (abfd)->core->lwpid = bfd_get_32 (abfd, note->descdata + 24);

	/* pr_reg */
	offset = 72;
	size = 144;
	break;
    }

  /* Make a ".reg/999" section.  */
  return _bfd_elfcore_make_pseudosection (abfd, ".reg",
					  size, note->descpos + offset);
}

/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
elf_s390_plt_sym_val (bfd_vma i, const asection *plt,
		      const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + PLT_FIRST_ENTRY_SIZE + i * PLT_ENTRY_SIZE;
}

static bfd_boolean
elf32_s390_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
{
  elf_elfheader (obfd)->e_flags |= elf_elfheader (ibfd)->e_flags;
  return TRUE;
}


#define TARGET_BIG_SYM	bfd_elf32_s390_vec
#define TARGET_BIG_NAME	"elf32-s390"
#define ELF_ARCH	bfd_arch_s390
#define ELF_TARGET_ID	S390_ELF_DATA
#define ELF_MACHINE_CODE EM_S390
#define ELF_MACHINE_ALT1 EM_S390_OLD
#define ELF_MAXPAGESIZE 0x1000

#define elf_backend_can_gc_sections	1
#define elf_backend_can_refcount	1
#define elf_backend_want_got_plt	1
#define elf_backend_plt_readonly	1
#define elf_backend_want_plt_sym	0
#define elf_backend_got_header_size	12
#define elf_backend_rela_normal		1

#define elf_info_to_howto		      elf_s390_info_to_howto

#define bfd_elf32_bfd_is_local_label_name     elf_s390_is_local_label_name
#define bfd_elf32_bfd_link_hash_table_create  elf_s390_link_hash_table_create
#define bfd_elf32_bfd_reloc_type_lookup	      elf_s390_reloc_type_lookup
#define bfd_elf32_bfd_reloc_name_lookup elf_s390_reloc_name_lookup

#define bfd_elf32_bfd_merge_private_bfd_data  elf32_s390_merge_private_bfd_data

#define elf_backend_adjust_dynamic_symbol     elf_s390_adjust_dynamic_symbol
#define elf_backend_check_relocs	      elf_s390_check_relocs
#define elf_backend_copy_indirect_symbol      elf_s390_copy_indirect_symbol
#define elf_backend_create_dynamic_sections   elf_s390_create_dynamic_sections
#define elf_backend_finish_dynamic_sections   elf_s390_finish_dynamic_sections
#define elf_backend_finish_dynamic_symbol     elf_s390_finish_dynamic_symbol
#define elf_backend_gc_mark_hook	      elf_s390_gc_mark_hook
#define elf_backend_gc_sweep_hook	      elf_s390_gc_sweep_hook
#define elf_backend_reloc_type_class	      elf_s390_reloc_type_class
#define elf_backend_relocate_section	      elf_s390_relocate_section
#define elf_backend_size_dynamic_sections     elf_s390_size_dynamic_sections
#define elf_backend_init_index_section	      _bfd_elf_init_1_index_section
#define elf_backend_grok_prstatus	      elf_s390_grok_prstatus
#define elf_backend_plt_sym_val		      elf_s390_plt_sym_val
#define elf_backend_add_symbol_hook           elf_s390_add_symbol_hook

#define bfd_elf32_mkobject		elf_s390_mkobject
#define elf_backend_object_p		elf_s390_object_p

#include "elf32-target.h"
@


1.131
log
@2013-07-05  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>
opcodes/
	    * s390-opc.c (J12_12, J24_24): New macros.
	    (INSTR_MII_UPI): Rename to INSTR_MII_UPP.
	    (MASK_MII_UPI): Rename to MASK_MII_UPP.
	    * s390-opc.txt: Rename MII_UPI to MII_UPP for bprp instruction.

include/elf/
	    * s390.h: Add new relocs R_390_PC12DBL, R_390_PLT12DBL,
	    R_390_PC24DBL, and R_390_PLT24DBL.

gas/testsuite/
	    * gas/s390/zarch-zEC12.s: Change bprp second operand and add
	    variants requiring relocations.
	    * gas/s390/zarch-zEC12.d: Likewise.

gas/
	    * config/tc-s390.c (md_gather_operands, md_apply_fix): Support new
	    relocs.
bfd/
	    * elf32-s390.c: Add new relocation definitions R_390_PC12DBL,
	    R_390_PLT12DBL, R_390_PC24DBL, and R_390_PLT24DBL.
	    (elf_s390_reloc_type_lookup, elf_s390_check_relocs)
	    (elf_s390_gc_sweep_hook, elf_s390_relocate_section): Support new
	    relocations.
	    * elf64-s390.c: See elf32-s390.c
	    * bfd-in2.h: Add new relocs to enum bfd_reloc_code_real.
	    * libbfd.h: Add new reloc strings.
@
text
@d2539 30
@


1.130
log
@	PR ld/15323
bfd/
	* elf-m10300.c (mn10300_elf_check_relocs): Set non_ir_ref for
	global symbols referenced by relocs.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	* elf32-cr16.c (cr16_elf_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-lm32.c (lm32_elf_check_relocs): Likewise.
	* elf32-m32c.c (m32c_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-metag.c (elf_metag_check_relocs): Likewise.
	* elf32-microblaze.c (microblaze_elf_check_relocs): Likewise.
	* elf32-moxie.c (moxie_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-mt.c (mt_elf_check_relocs): Likewise.
	* elf32-nios2.c (nios2_elf32_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-rl78.c (rl78_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (s3_bfd_score_elf_check_relocs): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_check_relocs): Likewise.
	* elf32-tilepro.c (tilepro_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-aarch64.c (elf64_aarch64_check_relocs): Likewise.
	* elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfnn-ia64.c (elfNN_ia64_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	* elfxx-tilegx.c (tilegx_elf_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.  Don't
	test indirect/warning links for NULL.
ld/testsuite/
	* ld-plugin/lto.exp (pr15323a.c): Compile without -flto rather
	than using -r to effectively strip out lto info.
@
text
@d43 1
a43 1
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
d164 8
d222 4
d230 4
d1126 1
d1128 1
d1263 1
d1265 1
d1310 1
d1312 1
d1389 1
d1391 1
d1558 1
d1560 1
d1567 1
d1569 1
d2619 1
d2621 1
d2684 1
d2686 1
d2758 1
d2760 1
d2801 1
d2803 1
d3281 7
@


1.129
log
@	* elf-bfd.h (enum elf_reloc_type_class): Add reloc_class_ifunc.
	(struct elf_backend_data <elf_backed_reloc_type_class>): Add
	bfd_link_info* and asection* params.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elflink.c (elf_link_sort_cmp2): Sort first on reloc class.
	(elf_link_sort_relocs): Update elf_backed_reloc_type_class call.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Return reloc_class_ifunc
	for any reliplt reloc.  Don't return reloc_class_plt for
	R_PPC_REL24 and R_PPC_ADDR24.
	* elf64-ppc.c (allocate_got): Formatting.
	(ppc64_elf_reloc_type_class): Return reloc_class_ifunc for any
	reliplt reloc.
	* elf-m10300.c, * elf32-arm.c, * elf32-bfin.c, * elf32-cr16.c,
	* elf32-cris.c, * elf32-hppa.c, * elf32-i386.c, * elf32-lm32.c,
	* elf32-m32r.c, * elf32-m68k.c, * elf32-metag.c, * elf32-nios2.c,
	* elf32-s390.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilepro.c,
	* elf32-vax.c, * elf32-xtensa.c, * elf64-aarch64.c, * elf64-alpha.c,
	* elf64-hppa.c, * elf64-ia64-vms.c, * elf64-s390.c, * elf64-sparc.c,
	* elf64-x86-64.c, * elfnn-ia64.c, * elfxx-tilegx.c, * elfxx-tilegx.h:
	Add extra params to the various reloc_type_class functions.
@
text
@d1029 4
@


1.128
log
@	* elf-bfd.h (struct core_elf_obj_tdata): New.
	(struct elf_obj_tdata): Delete core_signal, core_pid, core_lwpid,
	core_program, and core_command.  Add "core".
	* elf.c (bfd_elf_mkcorefile): Allocate "core" struct.
	Update all refs to tdata core fields.
	* elf32-am33lin.c, * elf32-arm.c, * elf32-cris.c, * elf32-frv.c,
	* elf32-hppa.c, * elf32-i386.c, * elf32-m68k.c, * elf32-mips.c,
	* elf32-nios2.c, * elf32-ppc.c, * elf32-s390.c, * elf32-score.c,
	* elf32-score7.c, * elf32-sh.c, * elf32-sparc.c, * elf32-tilegx.c,
	* elf32-tilepro.c, * elf32-xtensa.c, * elf64-aarch64.c,
	* elf64-hppa.c, * elf64-mips.c, * elf64-ppc.c, * elf64-tilegx.c,
	* elf64-x86-64.c, * elfcore.h, * elfn32-mips.c: Update all refs
	to tdata core fields.
@
text
@d3715 3
a3717 1
elf_s390_reloc_type_class (const Elf_Internal_Rela *rela)
a3944 1
#define elf_backend_reloc_type_class	      elf_s390_reloc_type_class
@


1.127
log
@	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_zmalloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf32-arm.c (elf32_arm_link_hash_table_create): Likewise.
	* elf32-avr.c (elf32_avr_link_hash_table_create): Likewise.
	* elf32-cr16.c (elf32_cr16_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-lm32.c (lm32_elf_link_hash_table_create): Likewise.
	* elf32-m32r.c (m32r_elf_link_hash_table_create): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-metag.c (elf_metag_link_hash_table_create): Likewise.
	* elf32-nios2.c (nios2_elf32_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-score.c (elf32_score_link_hash_table_create): Likewise.
	* elf32-spu.c (spu_elf_link_hash_table_create): Likewise.
	* elf32-tic6x.c (elf32_tic6x_link_hash_table_create): Likewise.
	* elf32-vax.c (elf_vax_link_hash_table_create): Likewise.
	* elf32-xgate.c (xgate_elf_bfd_link_hash_table_create): Likewise.
	* elf32-xtensa.c (elf_xtensa_link_hash_table_create): Likewise.
	* elf64-aarch64.c (elf64_aarch64_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* elflink.c (_bfd_elf_link_hash_table_create): Likewise.
	(_bfd_elf_link_hash_table_init): Assume zero fill table on entry.
@
text
@d3872 1
a3872 1
	elf_tdata (abfd)->core_signal = bfd_get_16 (abfd, note->descdata + 12);
d3875 1
a3875 1
	elf_tdata (abfd)->core_lwpid = bfd_get_32 (abfd, note->descdata + 24);
@


1.126
log
@Remove trailing white spaces in bfd

	* aout0.c: Remove trailing white spaces.
	* archive.c: Likewise.
	* archures.c: Likewise.
	* bfd-in.h: Likewise.
	* bfd-in2.h: Likewise.
	* coff-alpha.c: Likewise.
	* coff-i860.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-x86_64.c: Likewise.
	* coff-z80.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* compress.c: Likewise.
	* corefile.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-i386.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* dwarf2.c: Likewise.
	* ecofflink.c: Likewise.
	* ecoffswap.h: Likewise.
	* elf-ifunc.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf32-avr.c: Likewise.
	* elf32-avr.h: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cr16c.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i860.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-iq2000.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-msp430.c: Likewise.
	* elf32-mt.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.h: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-spu.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xc16x.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* ieee.c: Likewise.
	* libcoff.h: Likewise.
	* libpei.h: Likewise.
	* libxcoff.h: Likewise.
	* linker.c: Likewise.
	* mach-o-i386.c: Likewise.
	* mach-o-target.c: Likewise.
	* mach-o.c: Likewise.
	* mach-o.h: Likewise.
	* mmo.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c: Likewise.
	* pef-traceback.h: Likewise.
	* pei-x86_64.c: Likewise.
	* peicode.h: Likewise.
	* plugin.c: Likewise.
	* reloc.c: Likewise.
	* riscix.c: Likewise.
	* section.c: Likewise.
	* som.c: Likewise.
	* syms.c: Likewise.
	* tekhex.c: Likewise.
	* ticoff.h: Likewise.
	* vaxbsd.c: Likewise.
	* xcofflink.c: Likewise.
	* xtensa-isa.c: Likewise.
@
text
@d789 1
a789 1
  ret = (struct elf_s390_link_hash_table *) bfd_malloc (amt);
a800 10
  ret->elf.sgot = NULL;
  ret->elf.sgotplt = NULL;
  ret->elf.srelgot = NULL;
  ret->elf.splt = NULL;
  ret->elf.srelplt = NULL;
  ret->sdynbss = NULL;
  ret->srelbss = NULL;
  ret->tls_ldm_got.refcount = 0;
  ret->sym_cache.abfd = NULL;

@


1.125
log
@2012-11-05  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	PR target/14788
	* elf32-s390.c (elf_s390_relocate_section): Set elf.dynobj for
	local ifunc symbols.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@d365 1
a365 1
  
d374 1
a374 1
  
d377 1
a377 1
  
d380 1
a380 1
  
d391 1
a391 1
  
d395 1
a395 1
  
@


1.124
log
@2012-09-03  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (elf_s390_relocate_section): Handle PLTOFF for
	local and global ifunc symbols.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@d1016 3
@


1.123
log
@Add hdynamic to elf_link_hash_table for _DYNAMIC

	* elf-bfd.h (elf_link_hash_table): Add hdynamic for the
	_DYNAMIC symbol.

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Set
	hdynamic.

	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Check
	hdynamic instead of "_DYNAMIC".
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cr16.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_convert_mov_to_lea): Likewise.
	* elf32-lm32.c (lm32_elf_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_finish_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-aarch64.c elf64_aarch64_finish_dynamic_symbol(): Likewise.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-ia64-vms.c (elf64_ia64_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_convert_mov_to_lea): Likewise.
	* elfnn-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_finish_dynamic_symbol): Likewise.

	* elf32-microblaze.c (microblaze_elf_finish_dynamic_symbol): Check
	hdynamic, hgot, hplt instead of _DYNAMIC, _GLOBAL_OFFSET_TABLE_,
	_PROCEDURE_LINKAGE_TABLE_.
	* elf32-score.c (s3_bfd_score_elf_finish_dynamic_symbol): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_finish_dynamic_symbol): Likewise.
@
text
@d2352 4
d2632 1
a2632 1
	  if (   h == NULL
d2634 1
a2634 1
	      || htab->elf.splt == NULL)
@


1.122
log
@2012-07-13  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf64-s390.c: Include elf-s390-common.c.
	(R_390_IRELATIVE): New reloc.
	(elf_s390_reloc_type_lookup): Support R_390_IRELATIVE.
	(RELA_ENTRY_SIZE): New macro.
	(elf_s390_link_hash_entry): New fields ifunc_resolver_address and
	*ifunc_resolver_section.
	(struct plt_entry): New struct.
	(struct elf_s390_obj_tdata): New field local_plt.
	(elf_s390_local_plt): New macro.
	(struct elf_s390_link_hash_table): New field irelifunc.
	(ELF64): New macro.
	(link_hash_newfunc): Initialize new fields.
	(elf_s390_check_relocs): Handle IFUNC symbols.
	(elf_s390_adjust_dynamic_symbol): Don't do anything for IFUNC
	symbols.
	(allocate_dynrelocs): Call s390_elf_allocate_ifunc_dyn_relocs for
	IFUNC symbols.
	(elf_s390_size_dynamic_sections): Handle IFUNC symbols.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_finish_dynamic_symbol): Likewise.
	(elf_s390_finish_dynamic_sections): Handle local IFUNC symbols.
	(elf_s390_finish_ifunc_symbol): New function.
	(elf_s390_gc_sweep_hook): Handle local plt entries.
	(elf_backend_add_symbol_hook): Define.
	* elf32-s390.c: See elf64-s390.c changes.
	* elf-s390-common.c: New file.
	* bfd-in2.h (BFD_RELOC_390_IRELATIVE): New enum field.
	* libbfd.h (BFD_RELOC_390_IRELATIVE): New entry for
	BFD_RELOC_390_IRELATIVE.
	* reloc.c (BFD_RELOC_390_IRELATIVE): Document new relocation.

2012-07-13  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf/s390.h (START_RELOC_NUMBERS): Define R_390_IRELATIVE reloc.

2012-07-13  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* emulparams/elf_s390.sh (IREL_IN_PLT): Define.
	* emulparams/elf64_s390.sh (IREL_IN_PLT): Define.
@
text
@d3706 1
a3706 1
  if (strcmp (h->root.root.string, "_DYNAMIC") == 0
@


1.122.4.1
log
@bfd/
2012-11-05  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	PR target/14788
	* elf32-s390.c (elf_s390_relocate_section): Set elf.dynobj for
	local ifunc symbols.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@a1015 3
	      if (htab->elf.dynobj == NULL)
		htab->elf.dynobj = abfd;

@


1.121
log
@	* aix386-core.c: Remove use of PTR and PARAMS macros.
	* archive.c: Likewise.
	* cache.c: Likewise.
	* cisco-core.c: Likewise.
	* coff-alpha.c: Likewise.
	* coff-apollo.c: Likewise.
	* coff-aux.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-h8500.c: Likewise.
	* coff-i386.c: Likewise.
	* coff-i960.c: Likewise.
	* coff-ia64.c: Likewise.
	* coff-m68k.c: Likewise.
	* coff-m88k.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-mips.c: Likewise.
	* coff-or32.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-sparc.c: Likewise.
	* coff-stgo32.c: Likewise.
	* coff-tic30.c: Likewise.
	* coff-tic4x.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff-w65.c: Likewise.
	* cofflink.c: Likewise.
	* cpu-arc.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-w65.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10200.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-crx.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i960.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-rx.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* hash.c: Likewise.
	* hp300hpux.c: Likewise.
	* hppabsd-core.c: Likewise.
	* hpux-core.c: Likewise.
	* i386dynix.c: Likewise.
	* i386linux.c: Likewise.
	* i386lynx.c: Likewise.
	* i386mach3.c: Likewise.
	* i386msdos.c: Likewise.
	* i386os9k.c: Likewise.
	* irix-core.c: Likewise.
	* lynx-core.c: Likewise.
	* m68klinux.c: Likewise.
	* mach-o.h: Likewise.
	* mipsbsd.c: Likewise.
	* netbsd-core.c: Likewise.
	* nlm32-i386.c: Likewise.
	* osf-core.c: Likewise.
	* pc532-mach.c: Likewise.
	* pef.c: Likewise.
	* ppcboot.c: Likewise.
	* ptrace-core.c: Likewise.
	* reloc16.c: Likewise.
	* sco5-core.c: Likewise.
	* som.h: Likewise.
	* sparclinux.c: Likewise.
	* sparclynx.c: Likewise.
	* ticoff.h: Likewise.
	* trad-core.c: Likewise.
	* vms-lib.c: Likewise.
	* xsym.h: Likewise.
@
text
@d162 2
d276 2
d432 2
d648 8
d661 15
d682 3
d692 3
d726 1
d744 3
d774 2
d974 1
d1005 25
a1029 1
	h = NULL;
d1065 1
a1065 7
	      bfd_size_type size;

	      size = symtab_hdr->sh_info;
	      size *= (sizeof (bfd_signed_vma) + sizeof(char));
	      local_got_refcounts = ((bfd_signed_vma *)
				     bfd_zalloc (abfd, size));
	      if (local_got_refcounts == NULL)
d1067 1
a1067 3
	      elf_local_got_refcounts (abfd) = local_got_refcounts;
	      elf_s390_local_got_tls_type (abfd)
		= (char *) (local_got_refcounts + symtab_hdr->sh_info);
d1083 18
d1107 4
a1110 1
	  /* Got is created, nothing to be done.  */
d1251 1
a1251 1
	  if (h != NULL && !info->shared)
d1261 6
a1266 3
	      /* We may need a .plt entry if the function this reloc
		 refers to is in a shared lib.  */
	      h->plt.refcount += 1;
a1337 1
		  Elf_Internal_Sym *isym;
d1430 1
d1439 4
d1477 17
d1619 4
d1746 1
a1746 1
  struct elf_s390_link_hash_entry *eh;
d1755 7
a1761 2
  if (htab->elf.dynamic_sections_created
      && h->plt.refcount > 0)
a1877 1
  eh = (struct elf_s390_link_hash_entry *) h;
d2032 2
d2086 13
d2127 4
a2130 1
	  || s == htab->sdynbss)
d2316 1
d2339 46
a2384 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d2423 21
a2443 8
	      /* Calc. index no.
		 Current offset - size first entry / entry size.  */
	      plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) /
		PLT_ENTRY_SIZE;

	      /* Offset in GOT is PLT index plus GOT headers(3) times 4,
		 addr & GOT addr.  */
	      relocation = (plt_index + 3) * GOT_ENTRY_SIZE;
a2445 3
	      if (r_type == R_390_GOTPLTENT)
		relocation += htab->elf.sgot->output_section->vma;
	      break;
d2456 1
a2456 1
	  if (htab->elf.sgot == NULL)
d2465 24
a2488 5
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		  || (info->shared
		      && SYMBOL_REFERENCES_LOCAL (info, h))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
d2507 1
a2507 1
				  htab->elf.sgot->contents + off);
d2558 1
a2558 1
	  relocation = htab->elf.sgot->output_offset + off;
d2566 1
a2566 1
	    relocation += htab->elf.sgot->output_section->vma;
d2602 1
a2602 1
	      || htab->elf.splt == NULL)
d2610 8
a2617 3
	  relocation = (htab->elf.splt->output_section->vma
			+ htab->elf.splt->output_offset
			+ h->plt.offset);
d2636 10
a2645 4
	  relocation = (htab->elf.splt->output_section->vma
			+ htab->elf.splt->output_offset
			+ h->plt.offset
			- htab->elf.sgot->output_section->vma);
d2656 61
d3242 2
d3300 146
d3456 1
d3470 10
a3479 74
      if (h->dynindx == -1
	  || htab->elf.splt == NULL
	  || htab->elf.sgotplt == NULL
	  || htab->elf.srelplt == NULL)
	abort ();

      /* Calc. index no.
	 Current offset - size first entry / entry size.  */
      plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) / PLT_ENTRY_SIZE;

      /* Offset in GOT is PLT index plus GOT headers(3) times 4,
	 addr & GOT addr.  */
      got_offset = (plt_index + 3) * GOT_ENTRY_SIZE;

      /* S390 uses halfwords for relative branch calc!  */
      relative_offset = - ((PLT_FIRST_ENTRY_SIZE +
			    (PLT_ENTRY_SIZE * plt_index) + 18) / 2);
      /* If offset is > 32768, branch to a previous branch
	 390 can only handle +-64 K jumps.  */
      if ( -32768 > (int) relative_offset )
	relative_offset
	  = -(unsigned) (((65536 / PLT_ENTRY_SIZE - 1) * PLT_ENTRY_SIZE) / 2);

      /* Fill in the entry in the procedure linkage table.  */
      if (!info->shared)
	{
	  memcpy (htab->elf.splt->contents + h->plt.offset, elf_s390_plt_entry,
		  PLT_ENTRY_SIZE);

	  /* Adjust jump to the first plt entry.  */
	  bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
		      htab->elf.splt->contents + h->plt.offset + 20);

	  /* Push the GOT offset field.  */
	  bfd_put_32 (output_bfd,
		      (htab->elf.sgotplt->output_section->vma
		       + htab->elf.sgotplt->output_offset
		       + got_offset),
		      htab->elf.splt->contents + h->plt.offset + 24);
	}
      else if (got_offset < 4096)
	{
	  /* The GOT offset is small enough to be used directly as
	     displacement.  */
	  memcpy (htab->elf.splt->contents + h->plt.offset,
		  elf_s390_plt_pic12_entry,
		  PLT_ENTRY_SIZE);

	  /* Put in the GOT offset as displacement value.  The 0xc000
	     value comes from the first word of the plt entry.  Look
	     at the elf_s390_plt_pic16_entry content.  */
	  bfd_put_16 (output_bfd, (bfd_vma)0xc000 | got_offset,
		      htab->elf.splt->contents + h->plt.offset + 2);

	  /* Adjust the jump to the first plt entry.  */
	  bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
		      htab->elf.splt->contents + h->plt.offset + 20);
	}
      else if (got_offset < 32768)
	{
	  /* The GOT offset is too big for a displacement but small
	     enough to be a signed 16 bit immediate value as it can be
	     used in an lhi instruction.  */
	  memcpy (htab->elf.splt->contents + h->plt.offset,
		  elf_s390_plt_pic16_entry,
		  PLT_ENTRY_SIZE);

	  /* Put in the GOT offset for the lhi instruction.  */
	  bfd_put_16 (output_bfd, (bfd_vma)got_offset,
		      htab->elf.splt->contents + h->plt.offset + 2);

	  /* Adjust the jump to the first plt entry.  */
	  bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
		      htab->elf.splt->contents + h->plt.offset + 20);
d3483 32
a3514 15
	  memcpy (htab->elf.splt->contents + h->plt.offset,
		  elf_s390_plt_pic_entry,
		  PLT_ENTRY_SIZE);

	  /* Adjust the jump to the first plt entry.  */
	  bfd_put_32 (output_bfd, (bfd_vma) 0+(relative_offset << 16),
		      htab->elf.splt->contents + h->plt.offset + 20);

	  /* Push the GOT offset field.  */
	  bfd_put_32 (output_bfd, got_offset,
		      htab->elf.splt->contents + h->plt.offset + 24);
	}
      /* Insert offset into  reloc. table here.  */
      bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rela),
		  htab->elf.splt->contents + h->plt.offset + 28);
d3516 77
a3592 17
      /* Fill in the entry in the global offset table.
	 Points to instruction after GOT offset.  */
      bfd_put_32 (output_bfd,
		  (htab->elf.splt->output_section->vma
		   + htab->elf.splt->output_offset
		   + h->plt.offset
		   + 12),
		  htab->elf.sgotplt->contents + got_offset);

      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (htab->elf.sgotplt->output_section->vma
		       + htab->elf.sgotplt->output_offset
		       + got_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_390_JMP_SLOT);
      rela.r_addend = 0;
      loc = htab->elf.srelplt->contents + plt_index * sizeof (Elf32_External_Rela);
      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
d3594 9
a3602 8
      if (!h->def_regular)
	{
	  /* Mark the symbol as undefined, rather than as defined in
	     the .plt section.  Leave the value alone.  This is a clue
	     for the dynamic linker, to make function pointer
	     comparisons work between an application and shared
	     library.  */
	  sym->st_shndx = SHN_UNDEF;
d3629 23
a3651 1
      if (info->shared
d3654 6
d3671 1
d3742 2
d3829 30
d3949 1
@


1.120
log
@	* section.c (bfd_get_linker_section): New function.
	* elf32-arm.c: When retrieving SEC_LINKER_CREATED sections, use
	the above throughout rather than bfd_get_section_by_name.  Use
	bfd_make_section_anyway rather than bfd_make_section when creating
	them.
	* elf32-bfin.c: Likewise.
	* elf32-cr16.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-lm32.c: Likewise.
	* elf32-m32c.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-microblaze.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-rl78.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-score.c: Likewise.
	* elf32-score7.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-tic6x.c: Likewise.
	* elf32-tilepro.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ia64-vms.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfnn-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-tilegx.c: Likewise.
	* elflink.c: Likewise.
	* elf-vxworks.c: Likewise.
	* elf-m10300.c: Likewise.  Also make use of htab plt, got and
	gotplt shortcuts.
	* bfd-in2.h: Regenerate.
	* elf32-lm32.c (lm32_elf_check_relocs): Use the correct bfd when
	calling create_rofixup_section.
	* elflink.c (bfd_elf_final_link): Simplify test for .dynstr.
@
text
@d28 1
d30 6
a35 59
static reloc_howto_type *elf_s390_reloc_type_lookup
  PARAMS ((bfd *, bfd_reloc_code_real_type));
static void elf_s390_info_to_howto
  PARAMS ((bfd *, arelent *, Elf_Internal_Rela *));
static bfd_boolean elf_s390_is_local_label_name
  PARAMS ((bfd *, const char *));
static struct bfd_hash_entry *link_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static struct bfd_link_hash_table *elf_s390_link_hash_table_create
  PARAMS ((bfd *));
static bfd_boolean create_got_section
  PARAMS((bfd *, struct bfd_link_info *));
static bfd_boolean elf_s390_create_dynamic_sections
  PARAMS((bfd *, struct bfd_link_info *));
static void elf_s390_copy_indirect_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
static bfd_boolean elf_s390_check_relocs
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
struct elf_s390_link_hash_entry;
static void elf_s390_adjust_gotplt
  PARAMS ((struct elf_s390_link_hash_entry *));
static bfd_boolean elf_s390_adjust_dynamic_symbol
  PARAMS ((struct bfd_link_info *, struct elf_link_hash_entry *));
static bfd_boolean allocate_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean readonly_dynrelocs
  PARAMS ((struct elf_link_hash_entry *, PTR));
static bfd_boolean elf_s390_size_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_s390_relocate_section
  PARAMS ((bfd *, struct bfd_link_info *, bfd *, asection *, bfd_byte *,
	   Elf_Internal_Rela *, Elf_Internal_Sym *, asection **));
static bfd_boolean elf_s390_finish_dynamic_symbol
  PARAMS ((bfd *, struct bfd_link_info *, struct elf_link_hash_entry *,
	   Elf_Internal_Sym *));
static enum elf_reloc_type_class elf_s390_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
static bfd_boolean elf_s390_finish_dynamic_sections
  PARAMS ((bfd *, struct bfd_link_info *));
static bfd_boolean elf_s390_object_p
  PARAMS ((bfd *));
static bfd_boolean elf_s390_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
static int elf_s390_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));
static bfd_reloc_status_type s390_tls_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
static void invalid_tls_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *));
static bfd_reloc_status_type s390_elf_ldisp_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));

#include "elf/s390.h"
d171 2
a172 3
elf_s390_reloc_type_lookup (abfd, code)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_reloc_code_real_type code;
d307 3
a309 4
elf_s390_info_to_howto (abfd, cache_ptr, dst)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *cache_ptr;
     Elf_Internal_Rela *dst;
d335 7
a341 9
s390_tls_reloc (abfd, reloc_entry, symbol, data, input_section,
		output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d350 7
a356 9
s390_elf_ldisp_reloc (abfd, reloc_entry, symbol, data, input_section,
                      output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
d400 1
a400 3
elf_s390_is_local_label_name (abfd, name)
     bfd *abfd;
     const char *name;
d676 1
a676 2
elf_s390_object_p (abfd)
     bfd *abfd;
d692 2
a693 1
  union {
d711 3
a713 4
link_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d743 1
a743 2
elf_s390_link_hash_table_create (abfd)
     bfd *abfd;
d777 1
a777 3
create_got_section (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d799 1
a799 3
elf_s390_create_dynamic_sections (dynobj, info)
     bfd *dynobj;
     struct bfd_link_info *info;
d826 3
a828 3
elf_s390_copy_indirect_symbol (info, dir, ind)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *dir, *ind;
d890 3
a892 4
elf_s390_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
d920 4
a923 5
elf_s390_check_relocs (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
d1489 1
a1489 2
elf_s390_adjust_gotplt (h)
     struct elf_s390_link_hash_entry *h;
d1510 2
a1511 3
elf_s390_adjust_dynamic_symbol (info, h)
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
d1635 1
a1635 3
allocate_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1858 1
a1858 3
readonly_dynrelocs (h, inf)
     struct elf_link_hash_entry *h;
     PTR inf;
d1884 2
a1885 3
elf_s390_size_dynamic_sections (output_bfd, info)
     bfd *output_bfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info;
d1988 1
a1988 1
  elf_link_hash_traverse (&htab->elf, allocate_dynrelocs, (PTR) info);
d2085 1
a2085 2
	    elf_link_hash_traverse (&htab->elf, readonly_dynrelocs,
				    (PTR) info);
d2104 1
a2104 2
dtpoff_base (info)
     struct bfd_link_info *info;
d2116 1
a2116 3
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
d2130 3
a2132 4
invalid_tls_insn (input_bfd, input_section, rel)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rel;
d2149 8
a2156 10
elf_s390_relocate_section (output_bfd, info, input_bfd, input_section,
			      contents, relocs, local_syms, local_sections)
     bfd *output_bfd;
     struct bfd_link_info *info;
     bfd *input_bfd;
     asection *input_section;
     bfd_byte *contents;
     Elf_Internal_Rela *relocs;
     Elf_Internal_Sym *local_syms;
     asection **local_sections;
d3026 4
a3029 5
elf_s390_finish_dynamic_symbol (output_bfd, info, h, sym)
     bfd *output_bfd;
     struct bfd_link_info *info;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d3250 1
a3250 2
elf_s390_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
d3268 2
a3269 3
elf_s390_finish_dynamic_sections (output_bfd, info)
     bfd *output_bfd;
     struct bfd_link_info *info;
d3363 1
a3363 3
elf_s390_grok_prstatus (abfd, note)
     bfd * abfd;
     Elf_Internal_Note * note;
@


1.119
log
@	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Handle compound
	relocations.
	* elfxx-mips.c (mips_reloc_against_discarded_section): New
	function.
	(_bfd_mips_elf_relocate_section): Call it, in place of
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Update arguments
	to RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-epiphany.c (epiphany_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rl78.c (rl78_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfnn-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
@
text
@d849 3
a851 3
  htab->elf.sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->elf.sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  htab->elf.srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d876 3
a878 3
  htab->elf.splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->elf.srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
  htab->sdynbss = bfd_get_section_by_name (dynobj, ".dynbss");
d880 1
a880 1
    htab->srelbss = bfd_get_section_by_name (dynobj, ".rela.bss");
d1978 1
a1978 1
	  s = bfd_get_section_by_name (dynobj, ".interp");
d3362 1
a3362 1
  sdyn = bfd_get_section_by_name (dynobj, ".dynamic");
@


1.118
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2305 1
a2305 1
					 rel, relend, howto, contents);
@


1.117
log
@2012-04-20  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (ELF_DYNAMIC_INTERPRETER): Set to the GCC default.
	* elf64-s390.c (ELF_DYNAMIC_INTERPRETER): Set to the GCC default.
@
text
@d2303 1
a2303 1
      if (sec != NULL && elf_discarded_section (sec))
@


1.116
log
@2012-03-30  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf64-s390.c: Fix several comments regarding PLT entry
	description.
	* elf32-s390.c: Likewise.
@
text
@d473 1
a473 1
#define ELF_DYNAMIC_INTERPRETER "/usr/lib/ld.so.1"
@


1.115
log
@2012-03-30  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf64-s390.c: Use the section pointer shortcuts in
	elf_link_hash_table and remove them from the target specific
	variant.
	* elf32-s390.c: Likewise.
@
text
@d512 1
a512 1
   28(15) =  Offset in symbol table
d530 1
a530 1
      .long ?          # 4 bytes  offset into symbol table
d540 1
a540 1
      L    1,14(1)        # 4 bytes  Load offset in symbol table in r1
d543 1
a543 1
      .long ?             # 4 bytes  offset into symbol table
d552 1
a552 1
      L    1,14(1)        # 4 bytes  Load offset in symbol table in r1
d555 1
a555 1
      .long ?             # 4 bytes  offset into symbol table
d570 1
a570 1
      .long ?          # 4 bytes  offset into symbol table  */
d632 1
a632 1
/* The first PLT entry pushes the offset into the symbol table
d639 1
a639 1
   ST   1,28(15)  # R1 has offset into symbol table
d648 1
a648 1
   ST   1,28(15)      # R1 has offset into symbol table
@


1.114
log
@2012-03-30  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf64-s390.c (elf_s390x_plt_entry, elf_s390x_first_plt_entry):
	New definitions.
	(PLT_PIC_ENTRY_WORD*, PLT_PIC12_ENTRY_WORD*): Remove.
	(elf_s390_finish_dynamic_symbol): Use memcpy instead of bfd_put_32.
	(elf_s390_finish_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_plt_entry, elf_s390_plt_pic_entry)
	(elf_s390_plt_pic12_entry, elf_s390_plt_pic16_entry)
	(elf_s390_plt_first_entry, elf_s390_plt_pic_first_entry): New definitions.
	(PLT_PIC16_ENTRY_WORD*, PLT_ENTRY_WORD*)
	(PLT_PIC_FIRST_ENTRY_WORD*, PLT_FIRST_ENTRY_WORD*): Remove.
@
text
@a749 5
  asection *sgot;
  asection *sgotplt;
  asection *srelgot;
  asection *splt;
  asection *srelplt;
d822 5
a826 5
  ret->sgot = NULL;
  ret->sgotplt = NULL;
  ret->srelgot = NULL;
  ret->splt = NULL;
  ret->srelplt = NULL;
d849 4
a852 4
  htab->sgot = bfd_get_section_by_name (dynobj, ".got");
  htab->sgotplt = bfd_get_section_by_name (dynobj, ".got.plt");
  htab->srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
  if (!htab->sgot || !htab->sgotplt || !htab->srelgot)
d870 1
a870 1
  if (!htab->sgot && !create_got_section (dynobj, info))
d876 2
a877 2
  htab->splt = bfd_get_section_by_name (dynobj, ".plt");
  htab->srelplt = bfd_get_section_by_name (dynobj, ".rela.plt");
d882 1
a882 1
  if (!htab->splt || !htab->srelplt || !htab->sdynbss
d1084 1
a1084 1
	  if (htab->sgot == NULL)
d1735 1
a1735 1
	  asection *s = htab->splt;
d1761 1
a1761 1
	  htab->sgotplt->size += GOT_ENTRY_SIZE;
d1764 1
a1764 1
	  htab->srelplt->size += sizeof (Elf32_External_Rela);
d1794 2
a1795 2
	  h->got.offset = htab->sgot->size;
	  htab->sgot->size += GOT_ENTRY_SIZE;
d1815 1
a1815 1
      s = htab->sgot;
d1826 1
a1826 1
	htab->srelgot->size += sizeof (Elf32_External_Rela);
d1828 1
a1828 1
	htab->srelgot->size += 2 * sizeof (Elf32_External_Rela);
d1833 1
a1833 1
	htab->srelgot->size += sizeof (Elf32_External_Rela);
d2032 2
a2033 2
      s = htab->sgot;
      srela = htab->srelgot;
d2054 3
a2056 3
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->size += sizeof (Elf32_External_Rela);
d2073 3
a2075 3
      if (s == htab->splt
	  || s == htab->sgot
	  || s == htab->sgotplt
d2141 1
a2141 1
      if (htab->splt->size != 0)
d2341 1
a2341 1
		relocation += htab->sgot->output_section->vma;
d2353 1
a2353 1
	  if (htab->sgot == NULL)
d2385 1
a2385 1
				  htab->sgot->contents + off);
d2407 1
a2407 1
			      htab->sgot->contents + off);
d2415 1
a2415 1
		      srelgot = htab->srelgot;
d2419 2
a2420 2
		      outrel.r_offset = (htab->sgot->output_section->vma
					 + htab->sgot->output_offset
d2436 1
a2436 1
	  relocation = htab->sgot->output_offset + off;
d2444 1
a2444 1
	    relocation += htab->sgot->output_section->vma;
d2458 1
a2458 1
	  relocation -= htab->sgot->output_section->vma;
d2464 1
a2464 1
	  relocation = htab->sgot->output_section->vma;
d2480 1
a2480 1
	      || htab->splt == NULL)
d2488 2
a2489 2
	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
d2503 1
a2503 1
	      || htab->splt == NULL)
d2505 1
a2505 1
	      relocation -= htab->sgot->output_section->vma;
d2509 2
a2510 2
	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
d2512 1
a2512 1
			- htab->sgot->output_section->vma);
d2689 1
a2689 1
	  if (htab->sgot == NULL)
d2712 1
a2712 1
	      if (htab->srelgot == NULL)
d2715 2
a2716 2
	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);
d2728 2
a2729 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
d2740 1
a2740 1
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
d2747 1
a2747 1
		      htab->srelgot->reloc_count++;
d2763 1
a2763 1
	      relocation = htab->sgot->output_offset + off;
d2765 1
a2765 1
		relocation += htab->sgot->output_section->vma;
d2770 1
a2770 1
	      bfd_put_32 (output_bfd, htab->sgot->output_offset + off,
d2795 1
a2795 1
	  if (htab->sgot == NULL)
d2800 2
a2801 2
		      htab->sgot->contents + off);
	  relocation = htab->sgot->output_offset + off;
d2803 1
a2803 1
	    relocation += htab->sgot->output_section->vma;
d2814 1
a2814 1
	  if (htab->sgot == NULL)
d2825 1
a2825 1
	      if (htab->srelgot == NULL)
d2828 2
a2829 2
	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);
d2832 1
a2832 1
			  htab->sgot->contents + off + GOT_ENTRY_SIZE);
d2835 2
a2836 2
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
d2841 1
a2841 1
	  relocation = htab->sgot->output_offset + off;
d3129 3
a3131 3
	  || htab->splt == NULL
	  || htab->sgotplt == NULL
	  || htab->srelplt == NULL)
d3154 1
a3154 1
	  memcpy (htab->splt->contents + h->plt.offset, elf_s390_plt_entry,
d3159 1
a3159 1
		      htab->splt->contents + h->plt.offset + 20);
d3163 2
a3164 2
		      (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d3166 1
a3166 1
		      htab->splt->contents + h->plt.offset + 24);
d3172 1
a3172 1
	  memcpy (htab->splt->contents + h->plt.offset,
d3180 1
a3180 1
		      htab->splt->contents + h->plt.offset + 2);
d3184 1
a3184 1
		      htab->splt->contents + h->plt.offset + 20);
d3191 1
a3191 1
	  memcpy (htab->splt->contents + h->plt.offset,
d3197 1
a3197 1
		      htab->splt->contents + h->plt.offset + 2);
d3201 1
a3201 1
		      htab->splt->contents + h->plt.offset + 20);
d3205 1
a3205 1
	  memcpy (htab->splt->contents + h->plt.offset,
d3211 1
a3211 1
		      htab->splt->contents + h->plt.offset + 20);
d3215 1
a3215 1
		      htab->splt->contents + h->plt.offset + 24);
d3219 1
a3219 1
		  htab->splt->contents + h->plt.offset + 28);
d3224 2
a3225 2
		  (htab->splt->output_section->vma
		   + htab->splt->output_offset
d3228 1
a3228 1
		  htab->sgotplt->contents + got_offset);
d3231 2
a3232 2
      rela.r_offset = (htab->sgotplt->output_section->vma
		       + htab->sgotplt->output_offset
d3236 1
a3236 1
      loc = htab->srelplt->contents + plt_index * sizeof (Elf32_External_Rela);
d3261 1
a3261 1
      if (htab->sgot == NULL || htab->srelgot == NULL)
d3264 2
a3265 2
      rela.r_offset = (htab->sgot->output_section->vma
		       + htab->sgot->output_offset
d3287 1
a3287 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0, htab->sgot->contents + h->got.offset);
d3292 2
a3293 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
d3368 1
a3368 1
      if (sdyn == NULL || htab->sgot == NULL)
d3386 1
a3386 1
	      dyn.d_un.d_ptr = htab->sgot->output_section->vma;
d3390 1
a3390 1
	      dyn.d_un.d_ptr = htab->srelplt->output_section->vma;
d3394 1
a3394 1
	      s = htab->srelplt->output_section;
d3403 1
a3403 1
      if (htab->splt && htab->splt->size > 0)
d3405 1
a3405 1
	  memset (htab->splt->contents, 0, PLT_FIRST_ENTRY_SIZE);
d3408 1
a3408 1
	      memcpy (htab->splt->contents, elf_s390_plt_pic_first_entry,
d3413 1
a3413 1
	      memcpy (htab->splt->contents, elf_s390_plt_first_entry,
d3416 3
a3418 3
			  htab->sgotplt->output_section->vma
			  + htab->sgotplt->output_offset,
			  htab->splt->contents + 24);
d3420 1
a3420 1
	  elf_section_data (htab->splt->output_section)
d3426 1
a3426 1
  if (htab->sgotplt)
d3429 1
a3429 1
      if (htab->sgotplt->size > 0)
d3434 1
a3434 1
		      htab->sgotplt->contents);
d3436 1
a3436 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents + 4);
d3438 1
a3438 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0, htab->sgotplt->contents + 8);
d3441 1
a3441 1
      elf_section_data (htab->sgotplt->output_section)
@


1.113
log
@2012-03-30  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (struct elf_s390_dyn_relocs): Remove.
	Rename all occurrences in the file to elf_dyn_relocs.
	* elf64-s390.c: Likewise.
@
text
@d572 59
a630 23
#define PLT_PIC_ENTRY_WORD0 0x0d105810
#define PLT_PIC_ENTRY_WORD1 0x10165811
#define PLT_PIC_ENTRY_WORD2 0xc00007f1
#define PLT_PIC_ENTRY_WORD3 0x0d105810
#define PLT_PIC_ENTRY_WORD4 0x100ea7f4

#define PLT_PIC12_ENTRY_WORD0 0x5810c000
#define PLT_PIC12_ENTRY_WORD1 0x07f10000
#define PLT_PIC12_ENTRY_WORD2 0x00000000
#define PLT_PIC12_ENTRY_WORD3 0x0d105810
#define PLT_PIC12_ENTRY_WORD4 0x100ea7f4

#define PLT_PIC16_ENTRY_WORD0 0xa7180000
#define PLT_PIC16_ENTRY_WORD1 0x5811c000
#define PLT_PIC16_ENTRY_WORD2 0x07f10000
#define PLT_PIC16_ENTRY_WORD3 0x0d105810
#define PLT_PIC16_ENTRY_WORD4 0x100ea7f4

#define PLT_ENTRY_WORD0     0x0d105810
#define PLT_ENTRY_WORD1     0x10165810
#define PLT_ENTRY_WORD2     0x100007f1
#define PLT_ENTRY_WORD3     0x0d105810
#define PLT_ENTRY_WORD4     0x100ea7f4
d657 25
a681 12
#define PLT_PIC_FIRST_ENTRY_WORD0 0x5010f01c
#define PLT_PIC_FIRST_ENTRY_WORD1 0x5810c004
#define PLT_PIC_FIRST_ENTRY_WORD2 0x5010f018
#define PLT_PIC_FIRST_ENTRY_WORD3 0x5810c008
#define PLT_PIC_FIRST_ENTRY_WORD4 0x07f10000

#define PLT_FIRST_ENTRY_WORD0     0x5010f01c
#define PLT_FIRST_ENTRY_WORD1     0x0d105810
#define PLT_FIRST_ENTRY_WORD2     0x1012D203
#define PLT_FIRST_ENTRY_WORD3     0xf0181004
#define PLT_FIRST_ENTRY_WORD4     0x58101008
#define PLT_FIRST_ENTRY_WORD5     0x07f10000
d3159 4
a3162 10
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD0,
		      htab->splt->contents + h->plt.offset);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD1,
		      htab->splt->contents + h->plt.offset + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD2,
		      htab->splt->contents + h->plt.offset + 8);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD3,
		      htab->splt->contents + h->plt.offset + 12);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD4,
		      htab->splt->contents + h->plt.offset + 16);
d3165 2
d3175 13
a3187 10
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD0 + got_offset,
		      htab->splt->contents + h->plt.offset);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD1,
		      htab->splt->contents + h->plt.offset + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD2,
		      htab->splt->contents + h->plt.offset + 8);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD3,
		      htab->splt->contents + h->plt.offset + 12);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD4,
		      htab->splt->contents + h->plt.offset + 16);
a3189 2
	  bfd_put_32 (output_bfd, (bfd_vma) 0,
		      htab->splt->contents + h->plt.offset + 24);
d3193 12
a3204 10
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD0 + got_offset,
		      htab->splt->contents + h->plt.offset);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD1,
		      htab->splt->contents + h->plt.offset + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD2,
		      htab->splt->contents + h->plt.offset + 8);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD3,
		      htab->splt->contents + h->plt.offset + 12);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD4,
		      htab->splt->contents + h->plt.offset + 16);
a3206 2
	  bfd_put_32 (output_bfd, (bfd_vma) 0,
		      htab->splt->contents + h->plt.offset + 24);
d3210 5
a3214 10
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD0,
		      htab->splt->contents + h->plt.offset);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD1,
		      htab->splt->contents + h->plt.offset + 4);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD2,
		      htab->splt->contents + h->plt.offset + 8);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD3,
		      htab->splt->contents + h->plt.offset + 12);
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD4,
		      htab->splt->contents + h->plt.offset + 16);
d3217 2
d3413 3
a3415 11
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_FIRST_ENTRY_WORD0,
			  htab->splt->contents );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_FIRST_ENTRY_WORD1,
			  htab->splt->contents +4 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_FIRST_ENTRY_WORD2,
			  htab->splt->contents +8 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_FIRST_ENTRY_WORD3,
			  htab->splt->contents +12 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_FIRST_ENTRY_WORD4,
			  htab->splt->contents +16 );
	   }
d3417 3
a3419 13
	   {
	      bfd_put_32 (output_bfd, (bfd_vma)PLT_FIRST_ENTRY_WORD0,
			  htab->splt->contents );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD1,
			  htab->splt->contents +4 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD2,
			  htab->splt->contents +8 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD3,
			  htab->splt->contents +12 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD4,
			  htab->splt->contents +16 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD5,
			  htab->splt->contents +20 );
@


1.112
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Don't error
	on zero size dynbss symbol.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cr16.c (_bfd_cr16_elf_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-lm32.c (lm32_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-tic6x.c (elf32_tic6x_adjust_dynamic_symbol): Likewise.
	* elf32-tilepro.c (tilepro_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
	* elfxx-tilegx.c (tilegx_elf_adjust_dynamic_symbol): Likewise.
@
text
@a633 19
/* The s390 linker needs to keep track of the number of relocs that it
   decides to copy as dynamic relocs in check_relocs for each symbol.
   This is so that it can later discard them if they are found to be
   unnecessary.  We store the information in a field extending the
   regular ELF linker hash table.  */

struct elf_s390_dyn_relocs
{
  struct elf_s390_dyn_relocs *next;

  /* The input section of the reloc.  */
  asection *sec;

  /* Total number of relocs copied for the input section.  */
  bfd_size_type count;

  /* Number of pc-relative relocs copied for the input section.  */
  bfd_size_type pc_count;
};
d642 1
a642 1
  struct elf_s390_dyn_relocs *dyn_relocs;
d861 2
a862 2
	  struct elf_s390_dyn_relocs **pp;
	  struct elf_s390_dyn_relocs *p;
d868 1
a868 1
	      struct elf_s390_dyn_relocs *q;
d1249 2
a1250 2
	      struct elf_s390_dyn_relocs *p;
	      struct elf_s390_dyn_relocs **head;
d1292 1
a1292 1
		  head = (struct elf_s390_dyn_relocs **) vpp;
d1300 1
a1300 1
		  p = ((struct elf_s390_dyn_relocs *)
d1398 2
a1399 2
	  struct elf_s390_dyn_relocs **pp;
	  struct elf_s390_dyn_relocs *p;
d1612 1
a1612 1
      struct elf_s390_dyn_relocs *p;
d1668 1
a1668 1
  struct elf_s390_dyn_relocs *p;
d1808 1
a1808 1
	  struct elf_s390_dyn_relocs **pp;
d1891 1
a1891 1
  struct elf_s390_dyn_relocs *p;
d1958 1
a1958 1
	  struct elf_s390_dyn_relocs *p;
@


1.111
log
@2012-02-17  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (elf_s390_relocate_section): Support basr in the
	GD->LE and LD->LE optimizations.
@
text
@d3 1
a3 1
   2011 Free Software Foundation, Inc.
a1649 7
  if (h->size == 0)
    {
      (*_bfd_error_handler) (_("dynamic variable `%s' is zero size"),
			     h->root.root.string);
      return TRUE;
    }

d1665 1
a1665 1
  if ((h->root.u.def.section->flags & SEC_ALLOC) != 0)
@


1.110
log
@2011-12-22  Martin Schwidefsky  <schwidefsky@@de.ibm.com>

	* elf32-s390.c (elf_s390_relocate_section): Add check for debugging
	section in LD to LE linker relaxation for R_390_TLS_LDO32.
	* elf64-s390.c (elf_s390_relocate_section): Likewise for
	R_390_TLS_LDO64.
@
text
@d2922 2
a2923 1
		  (insn & 0xffff0000) != 0xc0e50000)
d2927 7
a2933 1
		  if ((insn & 0xff000000) == 0x4d000000)
d2942 1
a2942 1
			 brasl %r14,_tls_get_addr@@plt -> brcl 0,.  */
d2950 5
d2981 2
a2982 1
		      (insn & 0xffff0000) != 0xc0e50000)
d2984 8
a2991 1
		  if ((insn & 0xff000000) == 0x4d000000)
d3000 1
a3000 1
			 brasl %r14,__tls_get_addr@@plt -> brcl 0,. */
@


1.109
log
@	PR ld/13177
bfd/
	* elflink.c (_bfd_elf_gc_mark_rsec): Set symbol "mark".
	(elf_gc_sweep_symbol): Don't test plt/got refcounts, instead test
	"mark".  Hide undefweak too.  Clear def_regular and ref_regular.
	* elf-m10300.c (mn10300_elf_relocate_section): Ignore unresolved
	reloc errors from garbage-collected code.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tilepro.c (tilepro_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
	* elfxx-tilegx.c (tilegx_elf_relocate_section): Likewise.
ld/testsuite/
	* ld-elf/elf.exp: Move test for shared lib support..
	* lib/ld-lib.exp (check_shared_lib_support): ..to here. Add m68hc1*,
	and s/ms1/mt/.
	(check_gc_sections_available): Match hppa*64 not hppa64.  Comment.
	* ld-gc/libpersonality.s: New.
	* ld-gc/personality.s, * ld-gc/personality.d: New.
	* ld-gc/gc.exp: Run personality test.
@
text
@d2865 1
a2865 1
	  if (info->shared)
@


1.108
log
@	* linker.c (bfd_link_hash_traverse): Follow warning symbol link.
	(_bfd_generic_link_write_global_symbol, fix_syms): Don't handle
	warning symbols here.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.c (allocate_dynrelocs_for_symbol,
	elf32_arm_readonly_dynrelocs): Likewise.
	* elf32-bfin.c (bfin_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): Likewise.
	* elf32-hppa.c (allocate_plt_static, allocate_dynrelocs,
	clobber_millicode_symbols, readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-i386.c (elf_i386_allocate_dynrelocs,
	elf_i386_readonly_dynrelocs): Likewise.
	* elf32-lm32.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m32c.c (m32c_relax_plt_check, m32c_relax_plt_realloc): Likewise.
	* elf32-m32r.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-microblaze.c (allocate_dynrelocs): Likewise.
	* elf32-ppc.c (allocate_dynrelocs, maybe_set_textrel): Likewise.
	* elf32-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-score.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-score7.c (score_elf_sort_hash_table_f): Likewise.
	* elf32-sh.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf32-tic6x.c (elf32_tic6x_allocate_dynrelocs,
	elf32_tic6x_readonly_dynrelocs): Likewise.
	* elf32-vax.c (elf_vax_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check,
	xstormy16_relax_plt_realloc): Likewise.
	* elf32-xtensa.c (elf_xtensa_allocate_dynrelocs): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym,
	elf64_alpha_calc_got_offsets_for_symbol,
	elf64_alpha_calc_dynrel_sizes, elf64_alpha_size_rela_got_1): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions,
	allocate_global_data_opd, elf64_hppa_mark_milli_and_exported_functions,
	elf_hppa_unmark_useless_dynamic_symbols,
	elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_dynamic_ref, func_desc_adjust,
	adjust_opd_syms, adjust_toc_syms, allocate_dynrelocs,
	readonly_dynrelocs, merge_global_got, reallocate_got,
	undo_symbol_twiddle): Likewise.
	* elf64-s390.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (elf_x86_64_allocate_dynrelocs,
	elf_x86_64_readonly_dynrelocs): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms,
	elf_link_renumber_local_hash_table_dynsyms, _bfd_elf_export_symbol,
	_bfd_elf_link_find_version_dependencies,
	_bfd_elf_link_assign_sym_version, _bfd_elf_adjust_dynamic_symbol,
	_bfd_elf_link_sec_merge_syms, elf_adjust_dynstr_offsets,
	elf_collect_hash_codes, elf_collect_gnu_hash_codes,
	elf_renumber_gnu_hash_syms, elf_gc_sweep_symbol,
	elf_gc_propagate_vtable_entries_used,
	elf_gc_smash_unused_vtentry_relocs, bfd_elf_gc_mark_dynamic_ref_symbol,
	elf_gc_allocate_got_offsets): Likewise.
	* elfnn-ia64.c (elfNN_ia64_global_dyn_info_free,
	elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* elfxx-mips.c (mips_elf_check_symbols, mips_elf_output_extsym,
	mips_elf_sort_hash_table_f, allocate_dynrelocs): Likewise.
	* elfxx-sparc.c (allocate_dynrelocs, readonly_dynrelocs): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_post_gc_symbol): Likewise.

	* elflink.c (elf_link_output_extsym): Make it a bfd_hash_traverse
	function.  Update all callers.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_global_sym): Likewise.
	* ecoff.c (ecoff_link_write_external): Likewise.
	* xcofflink.c (xcoff_write_global_symbol): Likewise.
	* vms-alpha.c (alpha_vms_link_output_symbol): Likewise.  Handle
	warning symbols.
	* ecoff.c (ecoff_link_hash_traverse): Delete.
	* coff-ppc.c (ppc_bfd_coff_final_link): Use bfd_hash_traverse for
	_bfd_coff_write_global_sym.
	* libcoff-in.h (_bfd_coff_write_global_sym): Update prototype.
	* libcoff.h: Regenerate.
@
text
@d2999 3
a3001 1
	       && h->def_dynamic))
@


1.108.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d2285 1
a2285 1
      if (sec != NULL && discarded_section (sec))
@


1.107
log
@	bfd/
	* elf-bfd.h (RELOC_AGAINST_DISCARDED_SECTION): Always call
	_bfd_clear_contents.  Pass it the input section.
	* libbfd-in.h (_bfd_clear_contents): Add input_section argument.
	* libbfd.h: Regenerate.
	* reloc.c (_bfd_clear_contents): Take input_section argument.
	Use non-zero for .debug_ranges.
	(bfd_generic_get_relocated_section_conten): Update _bfd_clear_contents
	call.

	* elf32-arm.c (elf32_arm_relocate_section): Use
	RELOC_AGAINST_DISCARDED_SECTION.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfin_relocate_section): Likewise.
	(bfinfdpic_relocate_section): Likewise.
	* elf32-cr16.c (elf32_cr16_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-lm32.c (lm32_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-moxie.c (moxie_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-rx.c (rx_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (s3_bfd_score_elf_relocate_section): Likewise.
	* elf32-score7.c (s7_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-tic6x.c (elf32_tic6x_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-hppa.c (elf64_hppa_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	ld/testsuite/
	* ld-discard/zero-range.d, ld-discard/zero-range.s: New files.
@
text
@d2 2
a3 2
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
a1698 6
  if (h->root.type == bfd_link_hash_warning)
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a1918 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

@


1.106
log
@Add target_id to elf_backend_data.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11944
	* elf-bfd.h (elf_backend_data): Add target_id.
	(bfd_elf_make_generic_object): Renamed to ...
	(bfd_elf_make_object): This.

	* elf.c (bfd_elf_make_generic_object): Removed.
	(bfd_elf_make_object): New.
	(bfd_elf_mkcorefile): Really treat it as an object file.

	* elf-m10300.c (ELF_TARGET_ID): New.
	* elf32-arm.c (ELF_TARGET_ID): Likewise.
	* elf32-bfin.c (ELF_TARGET_ID): Likewise.
	* elf32-cris.c (ELF_TARGET_ID): Likewise.
	* elf32-frv.c (ELF_TARGET_ID): Likewise.
	* elf32-i386.c (ELF_TARGET_ID): Likewise.
	* elf32-lm32.c (ELF_TARGET_ID): Likewise.
	* elf32-m32r.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc11.c (ELF_TARGET_ID): Likewise.
	* elf32-m68hc12.c (ELF_TARGET_ID): Likewise.
	* elf32-m68k.c (ELF_TARGET_ID): Likewise.
	* elf32-microblaze.c (ELF_TARGET_ID): Likewise.
	* elf32-ppc.c (ELF_TARGET_ID): Likewise.
	* elf32-s390.c (ELF_TARGET_ID): Likewise.
	* elf32-sh.c (ELF_TARGET_ID): Likewise.
	* elf32-sparc.c (ELF_TARGET_ID): Likewise.
	* elf32-spu.c (ELF_TARGET_ID): Likewise.
	* elf32-tic6x.c (ELF_TARGET_ID): Likewise.
	* elf32-xtensa.c (ELF_TARGET_ID): Likewise.
	* elf64-alpha.c (ELF_TARGET_ID): Likewise.
	* elf64-hppa.c (ELF_TARGET_ID): Likewise.
	* elf64-ppc.c (ELF_TARGET_ID): Likewise.
	* elf64-s390.c (ELF_TARGET_ID): Likewise.
	* elf64-x86-64.c (ELF_TARGET_ID): Likewise.
	* elfxx-ia64.c (ELF_TARGET_ID): Likewise.

	* elf32-hppa.c (elf32_hppa_mkobject): Removed.
	(bfd_elf32_mkobject): Likewise.
	(ELF_TARGET_ID): New.

	* elf32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elf64-mips.c (ELF_TARGET_ID): New.
	(bfd_elf64_mkobject): Removed.

	* elfn32-mips.c (ELF_TARGET_ID): New.
	(bfd_elf32_mkobject): Removed.

	* elfxx-mips.c (_bfd_mips_elf_mkobject): Removed.
	* elfxx-mips.h (_bfd_mips_elf_mkobject): Likewise.

	* elfxx-target.h (bfd_elfNN_mkobject): Default to
	bfd_elf_make_object.
	(ELF_TARGET_ID): New.  Default to GENERIC_ELF_DATA.
	(elfNN_bed): Initialize target_id.
@
text
@d2295 2
a2296 9
	{
	  /* For relocs against symbols from removed linkonce sections,
	     or sections discarded by a linker script, we just want the
	     section contents zeroed.  Avoid any special processing.  */
	  _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	  rel->r_info = 0;
	  rel->r_addend = 0;
	  continue;
	}
@


1.105
log
@2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	bfd/
	* bfd-in2.h: Regenerate.
	* corefile.c (bfd_core_file_pid): New.

	* targets.c (BFD_JUMP_TABLE_CORE): Add NAME##_core_file_pid.
	(struct bfd_target) <_core_file_pid>: New.

	* libbfd-in.h (_bfd_nocore_core_file_pid): Declare.
	* libbfd.c (_bfd_nocore_core_file_pid): New.

	* elf-bfd.h (bfd_elf32_core_file_pid, bfd_elf64_core_file_pid):
	Declare.
	* elfcode.h (elf_core_file_pid): New define.
	* elfcore.h (elf_core_file_pid): New function.

	* elf.c (elfcore_make_pid): Rewrite.
	(elfcore_grok_prstatus): Only set core_pid if not set yet.
	(elfcore_grok_prstatus) [!HAVE_PRSTATUS_T_PR_WHO]: Fallback to
	getting the lwpid from prstat.pr_pid.

	* elf64-x86-64.c (elf64_x86_64_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf64_x86_64_grok_psinfo): Extract the the main process's PID,
	and store it in elf_tdata's core_pid field.
	* elf32-i386.c (elf_i386_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	(elf_i386_grok_psinfo): Extract the the main process's PID, and
	store it in elf_tdata's core_pid field.

	* elf32-am33lin.c (elf32_am33lin_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-arm.c (elf32_arm_nabi_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-cris.c (cris_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-frv.c (elf32_frv_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-hppa.c (elf32_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-ppc.c (ppc_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-s390.c (elf_s390_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score.c (s3_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-score7.c (s7_bfd_score_elf_grok_prstatus): Write the LWPID
	to elf_tdata's core_lwpid instead of to core_pid.
	* elf32-sh.c (elf32_shlin_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf32-xtensa.c (elf_xtensa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-hppa.c (elf64_hppa_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-mips.c (elf64_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elf64-ppc.c (ppc64_elf_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.
	* elfn32-mips.c (elf32_mips_grok_prstatus): Write the LWPID to
	elf_tdata's core_lwpid instead of to core_pid.

	* plugin.c (bfd_plugin_core_file_pid): New function.
	* aout-target.h (MY_core_file_pid): Define.
	* aout-tic30.c (MY_core_file_pid, MY_core_file_p): New defines.
	* coff-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff_vec, pmac_xcoff_vec): Use BFD_JUMP_TABLE_CORE.
	* coff64-rs6000.c (coff_core_file_pid): New define.
	(rs6000coff64_vec): Use BFD_JUMP_TABLE_CORE.
	(xcoff64_core_file_pid): New define.
	(aix5coff64_vec): Use BFD_JUMP_TABLE_CORE.
	* mach-o-target.c (bfd_mach_o_core_file_pid): New define.
	* aix386-core.c (aix386_core_file_pid): New define.
	* hppabsd-core.c (hppabsd_core_core_file_pid): New define.
	* hpux-core.c (hpux_core_core_file_pid): New define.
	* irix-core.c (irix_core_core_file_pid): New define.
	* lynx-core.c (lynx_core_file_pid): New define.
	* osf-core.c (osf_core_core_file_pid): New define.
	* ptrace-core.c (ptrace_unix_core_file_pid): New define.
	* sco5-core.c (sco5_core_file_pid): New define.
	* xcoff-target.h (coff_core_file_pid): New define.
	* netbsd-core.c (netbsd_core_core_file_pid): New define.

gdb/
2010-08-18  Pedro Alves  <pedro@@codesourcery.com>

	PR corefile/8210

	gdb/
	* corelow.c (add_to_thread_list): Don't use
	gdbarch_core_reg_section_encodes_pid.  Use bfd_core_file_pid.
	(get_core_register_section): Don't use
	gdbarch_core_reg_section_encodes_pid.

	* gdbarch.sh (core_reg_section_encodes_pid): Delete.
	* gdbarch.h, gdbarch.c: Regenerate.
	* amd64-sol2-tdep.c (amd64_sol2_init_abi): Don't set
	gdbarch_core_reg_section_encodes_pid.
	* i386-sol2-tdep.c (i386_sol2_init_abi): Ditto.
	* sparc-sol2-tdep.c (sparc32_sol2_init_abi): Ditto.
	* sparc64-sol2-tdep.c (sparc64_sol2_init_abi): Ditto.
@
text
@d3499 1
@


1.104
log
@        * elf-bfd.h (emum elf_object_id): Rename to elf_target_id.  Add
        entries for other architectures.
        (struct elf_link_hash_table): Add hash_table_id field.
        (elf_hash_table_id): New accessor macro.
        * elflink.c (_bfd_elf_link_hash_table_init): Add target_id
        parameter.
        * elf-m10300.c (elf32_mn10300_hash_table): Check table id before
        returning cast pointer.
        (elf32_mn10300_link_hash_table_create): Identify new table as
        containing MN10300 extensions.
        (mn10300_elf_relax_section): Check pointer returned by
        elf32_mn10300_hash_table.
        * elf32-arm.c: Likewise, except using ARM extensions.
        * elf32-avr.c: Likewise, except using AVR extensions.
        * elf32-bfin.c: Likewise, except using BFIN extensions.
        * elf32-cris.c: Likewise, except using CRIS extensions.
        * elf32-frv.c: Likewise, except using FRV extensions.
        * elf32-hppa.c: Likewise, except using HPPA32 extensions.
        * elf32-i386.c: Likewise, except using I386 extensions.
        * elf32-lm32.c: Likewise, except using LM32 extensions.
        * elf32-m32r.c: Likewise, except using M32RM extensions.
        * elf32-m68hc11.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.c: Likewise, except using M68HC11 extensions.
        * elf32-m68hc1x.h: Likewise, except using M68HC11 extensions.
        * elf32-m68k.c: Likewise, except using M68K extensions.
        * elf32-microblaze.c: Likewise, except using MICROBLAZE extensions.
        * elf32-ppc.c: Likewise, except using PPC32 extensions.
        * elf32-s390.c: Likewise, except using S390 extensions.
        * elf32-sh.c: Likewise, except using SH extensions.
        * elf32-spu.c: Likewise, except using SPU extensions.
        * elf32-xtensa.c: Likewise, except using XTENSA extensions.
        * elf64-alpha.c: Likewise, except using ALPHA extensions.
        * elf64-hppa.c: Likewise, except using HPPA64 extensions.
        * elf64-ppc.c: Likewise, except using PPC64 extensions.
        * elf64-s390.c: Likewise, except using S390 extensions.
        * elf64-x86-64.c: Likewise, except using X86_64 extensions.
        * elfxx-ia64.c: Likewise, except using IA64 extensions.
        * elfxx-mips.c: Likewise, except using MIPS extensions.
        * elfxx-sparc.c: Likewise, except using SPARC extensions.
        * elfxx-sparc.h: Likewise, except using SPARC extensions.
        * elf32-cr16.c (struct elf32_cr16_link_hash_table): Delete
        redundant structure.
        (elf32_cr16_hash_table): Delete unused macro.
        (elf32_cr16_link_hash_traverse): Delete unused macro.
        * elf32-score.c: Likewise.
        * elf32-score7.c: Likewise.
        * elf32-vax.c: Likewise.
        * elf64-sh64.c: Likewise.

        * emultempl/alphaelf.em: Update value expected from elf_object_id.
        * emultempl/hppaelf.em: Likewise.
        * emultempl/mipself.em: Likewise.
        * emultempl/ppc32elf.em: Likewise.
        * emultempl/ppc64elf.em: Likewise.
@
text
@d3465 1
a3465 1
	elf_tdata (abfd)->core_pid = bfd_get_32 (abfd, note->descdata + 24);
@


1.103
log
@2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* readelf.c (get_machine_flags): Handle EF_S390_HIGH_GPRS.

2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390.h (EF_S390_HIGH_GPRS): Added macro definition.

2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (s390_elf_final_processing): New function.
	* config/tc-s390.h (elf_tc_final_processing): New macro definition.
	(s390_elf_final_processing): Added prototype.

2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (elf32_s390_merge_private_bfd_data): New function.
	(bfd_elf32_bfd_merge_private_bfd_data): New macro definition.
@
text
@d696 1
a696 1
   && elf_object_id (bfd) == S390_ELF_TDATA)
d702 1
a702 1
				  S390_ELF_TDATA);
d740 2
a741 1
  ((struct elf_s390_link_hash_table *) ((p)->hash))
d790 2
a791 1
				      sizeof (struct elf_s390_link_hash_entry)))
@


1.102
log
@update copyright dates
@
text
@d3486 7
d3516 2
@


1.101
log
@	* elf-bfd.h (struct sym_sec_cache): Delete.
	(struct sym_cache): New.
	(bfd_section_from_r_symndx): Delete prototype.
	(bfd_sym_from_r_symndx): Define prototype.
	* elf.c (bfd_section_from_r_symndx): Delete, replace with..
	(bfd_sym_from_r_symndx): ..new function.
	* elf32-arm.c: Update all uses of struct sym_sec_cache and
	bfd_section_from_r_symndx to new struct and function.
	* elf32-bfin.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68hc1x.h: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* elfxx-sparc.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.100
log
@2009-06-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf32-arm.c (create_got_section): Get existing .rela.got
	section.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	* elf32-lm32.c (create_got_section): Likewise.
	* elf32-m32r.c (create_got_section): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.

	* elflink.c (_bfd_elf_create_got_section): Properly initialize
	the GOT size.
@
text
@d733 2
a734 2
  /* Small local sym to section mapping cache.  */
  struct sym_sec_cache sym_sec;
d803 1
a803 1
  ret->sym_sec.abfd = NULL;
d1297 1
d1299 6
a1304 2
		  s = bfd_section_from_r_symndx (abfd, &htab->sym_sec,
						 sec, r_symndx);
d1306 1
a1306 1
		    return FALSE;
@


1.99
log
@2009-03-20  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	    Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (elf_s390_check_relocs): Use the SYMBOL_*
        macros for visibilty and locality checks.
	(elf_s390_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_adjust_dynamic_symbol): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_finish_dynamic_symbol): Likewise.
@
text
@d824 2
a825 1
  if (!htab->sgot || !htab->sgotplt)
a827 9
  htab->srelgot = bfd_make_section_with_flags (dynobj, ".rela.got",
					       (SEC_ALLOC | SEC_LOAD
						| SEC_HAS_CONTENTS
						| SEC_IN_MEMORY
						| SEC_LINKER_CREATED
						| SEC_READONLY));
  if (htab->srelgot == NULL
      || ! bfd_set_section_alignment (dynobj, htab->srelgot, 2))
    return FALSE;
@


1.98
log
@        * elflink.c (is_reloc_section): New function.  Returns true if the
        given name matches the name of the reloc-containing section
        associated with the given section.
        (get_dynamic_reloc_section_name): New function.  Computes the name
        of the section that contains the dynamic relocs associated with
        the given section.
        (_bfd_elf_get_dynamic_reloc_section): New function.  Returns a
        pointer to the section containing the dynamic relocs associated
        with the given section.
        (_bfd_elf_make_dynamic_reloc_section): New function.  Creates a
        section to contain the dynamic relocs associated with a given
        section.
        * elf-bfd.h: Prototype the new functions.
        * elf-m10300.c (mn10300_elf_check_relocs): Use new functions.
        (mn10300_elf_final_link_relocs): Likewise.
        * elf32-arm.c (reloc_section_p): Delete - replaced by new
        functions.
        (elf32_arm_final_link_relocate): Use new functions.
        (elf32_arm_check_relocs): Likewise.
        * elf32-cris.c (cris_elf_relocate_section): Likewise.
        (elf_cris_check_relocs): Likewise.
        * elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
        * elf32-i370.c (i370_elf_check_relocs): Likewise.
        (i370_elf_relocate_section): Likewise.
        * elf32-i386.c (elf_i386_check_relocs): Likewise.
        * elf32-m32r.c (m32r_elf_relocate_section): Likewise.
        (m32r_elf_check_relocs): Likewise.
        * elf32-m68k.c (elf_m68k_check_relocs): Likewise.
        * elf32_ppc.c (ppc_elf_check_relocs): Likewise.
        (ppc_elf_relocate_section): Likewise.
        * elf32-s390.c (elf_s390_check_relocs): Likewise.
        * elf32-sh.c (sh_elf_relocate_section): Likewise.
        (sh_elf_check_relocs): Likewise.
        * elf32-vax.c (elf_vax_check_relocs): Likewise.
        (elf_vax_relocate_section): Likewise.
        * elf64-alpha.c (elf64_alpha_check_relocs): Likewise.
        * elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
        * elf64-s390.c (elf_s390_check_relocs): Likewise.
        * elf64-sh64.c (sh_elf64_relocate_section): Likewise.
        * elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
        * elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
        * elf32-bfin.c (bfin_check_relocs): Remove redundant local
        variable 'sreloc'.
        (bfin_relocate_section): Likewise.
        * elf32-v850.c (v850_elf_check_relocs): Likewise.
@
text
@d1264 1
a1264 1
		       && (! info->symbolic
d1569 3
a1571 5
	  || (! info->shared
	      && !h->def_dynamic
	      && !h->ref_dynamic
	      && h->root.type != bfd_link_hash_undefweak
	      && h->root.type != bfd_link_hash_undefined))
d1710 1
a1710 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1839 1
a1839 1
      if (SYMBOL_REFERENCES_LOCAL (info, h))
d2363 1
a2363 4
		      && (info->symbolic
			  || h->dynindx == -1
			  || h->forced_local)
		      && h->def_regular)
d2533 1
a2533 2
		   || (h != NULL
		       && !SYMBOL_REFERENCES_LOCAL (info, h))))
d2575 1
a2575 1
			   || !info->symbolic
d3257 1
a3257 4
	  && (info->symbolic
	      || h->dynindx == -1
	      || h->forced_local)
	  && h->def_regular)
d3259 2
@


1.97
log
@PR ld/5692
   * elf-bfd.h (enum elf_object_id): New enum, used to identify
   target specific extensions to the elf_obj_tdata structure.
   (struct elf_obj_tdata): New field 'object_id'.
   (elf_object_id, elf_program_header_size, elf_symtab_hdr): New
   macros for accessing fields in the elf_obj_tdata structure.
   (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object.
   (bfd_elf_allocate_object): New function.
   * elf.c (bfd_elf_mkobject): Rename to bfd_elf_make_generic_object
   and implement by calling bfd_elf_allocate_object.
   (bfd_elf_allocate_object): New function: Allocates an
   elf_obj_tdata structure, possibly with a target specific
   extension.
   * elfxx-target.h (bfd_elfNN_mkobject): Use
   bfd_elf_make_generic_object as the default value.
   * elf32-arm.c (elf32_arm_obj_tdata): Rename to elf_arm_obj_tdata
   for consistency with other, similar structures.
   (is_arm_elf): New macro.  Checks a BFD to make sure that is an ARM
   ELF bfd.
   (elf32_arm_mkobject): Call bfd_elf_allocate_object.
   (bfd_elf32_arm_vfp11_erratum_scan): Use is_arm_elf macro to check
   the bfd being processed.
   (bfd_elf32_arm_vfp11_fix_veneer_locations): Likewise.
   (bfd_elf32_arm_set_target_relocs): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_copy_private_bfd_data): Likewise.
   (bfd_elf32_arm_merge_eabi_attributes): Likewise.
   (bfd_elf32_arm_merge_private_bfd_data): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_gc_mark_extra_sections): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   (bfd_elf32_arm_process_before_allocation): Use elf_symtab_hdr.
   (bfd_elf32_arm_init_maps): Likewise.
   (bfd_elf32_arm_final_link_relocate): Likewise.
   (bfd_elf32_arm_relocate_section): Likewise.
   (bfd_elf32_arm_gc_sweep_hook): Likewise.
   (bfd_elf32_arm_check_relocs): Likewise.
   (bfd_elf32_arm_size_dynamic_sections): Likewise.
   * elf32-i386.c (elf_i386_mkobject): Call bfd_elf_allocate_object.
   (is_i386_elf): New macro.  Checks a BFD to make sure that is an x86
   ELF bfd.
   (elf_i386_check_relocs): Use is_i386_elf macro to check    the bfd
   being processed.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   (elf_i386_check_relocs): Use elf_symtab_hdr.
   (elf_i386_gc_sweep_hook): Likewise.
   (elf_i386_size_dynamic_sections): Likewise.
   (elf_i386_relocate_section): Likewise.
   * elf32-ppc.c (ppc_elf_mkobject): Call bfd_elf_allocate_object.
   (elf_create_pointer_linker_section): Use is_ppc_elf_target to
   verify that the bfd before accessing target specific fields.
   (ppc_elf_check_relocs): Likewise.
   (elf_finish_pointer_linker_section): Likewise.
   (elf_create_pointer_linker_section): Use elf_symtab_hdr.
   (ppc_elf_check_relocs): Likewise.
   (ppc_elf_gc_sweep_hook): Likewise.
   (ppc_elf_tls_optimize): Likewise.
   (ppc_elf_size_dynamic_sections): Likewise.
   (ppc_elf_relax_section): Likewise.
   (ppc_elf_relocate_section): Likewise.
   * elf32-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf64-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf32-sh.c (sh_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sh_elf): New macro.  Checks a BFD to make sure that is an SH
   ELF bfd.
   (sh_elf_size_dynamic_sections): Use is_sh_elf macro to check the
   bfd being processed.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_check_relocs): Likewise.
   (sh_elf_copy_private_data): Likewise.
   (sh_elf_relax_section): Use elf_symtab_hdr.
   (sh_elf_size_dynamic_sections): Likewise.
   (sh_elf_relocate_section): Likewise.
   (sh_elf_get_relocated_section_contents): Likewise.
   (sh_elf_gc_sweep_hook): Likewise.
   (sh_elf_check_relocs): Likewise.
   * elf64-alpha.c (elf64_alpha_mkobject): Call bfd_elf_allocate_object.
   (is_alpha_elf): New macro.  Checks a BFD to make sure that is an
   Alpha ELF bfd.
   (elf64_alpha_create_got_section): Use is_alpha_elf macro to check
   the bfd being processed.
   (elf64_alpha_create_dynamic_section): Likewise.
   (elf64_alpha_check_relocs): Likewise.
   (elf64_alpha_size_got_sections): Likewise.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   (elf64_alpha_final_link): Likewise.
   (elf64_alpha_check_relocs): Use elf_symtab_hdr.
   (elf64_alpha_relax_section): Likewise.
   (elf64_alpha_relocate_section_r): Likewise.
   (elf64_alpha_relocate_section): Likewise.
   * elf64-ppc.c (ppc64_elf_mkobject): Call bfd_elf_allocate_object.
   (ppc64_elf_check_relocs): Use is_ppc64_elf_target to check the bfd
   being processed.
   (opd_entry_value): Likewise.
   (allocate_dynrelocs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   (ppc64_elf_check_relocs): Use elf_symtab_hdr.
   (opd_entry_value): Likewise.
   (ppc64_elf_gc_sweep_hook): Likewise.
   (get_sym_h): Likewise.
   (ppc64_elf_edit_opd): Likewise.
   (ppc64_elf_tls_optimize): Likewise.
   (ppc64_elf_edit_toc): Likewise.
   (ppc64_elf_size_dynamic_sections): Likewise.
   (toc_adjusting_stub_needed): Likewise.
   (ppc64_elf_size_stubs): Likewise.
   (ppc64_elf_relocate_section): Likewise.
   * elf64-s390.c (struct elf_s390_obj_tdata): Add a comment
   reminding programmers to keep this structure in sync with the one
   defined in elf32-s390.c.
   (elf_s390_mkobject): Call bfd_elf_allocate_object.
   (is_s390_elf): New macro.  Checks a BFD to make sure that is an s390
   ELF bfd.
   (elf_s390_check_relocs): Use is_s390_elf macro to check    the bfd
   being processed.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   (elf_s390_check_relocs): Use elf_symtab_hdr.
   (elf_s390_gc_sweep_hook): Likewise.
   (elf_s390_size_dynamic_sections): Likewise.
   (elf_s390_relocate_section): Likewise.
   * elf64-x86_64.c (elf64_x86_64_mkobject): Call bfd_elf_allocate_object.
   (is_x86_64_elf): New macro.  Checks a BFD to make sure that is an
   x86_64 ELF bfd.
   (elf64_x86_64_check_relocs): Use is_x86_64_elf macro to check the bfd
   being processed.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   (elf64_x86_64_check_relocs): Use elf_symtab_hdr.
   (elf64_x86_64_gc_sweep_hook): Likewise.
   (elf64_x86_64_size_dynamic_sections): Likewise.
   (elf64_x86_64_relocate_section): Likewise.
   * elfxx-sparc.c (_bfd_sparc_elf_mkobject): Call bfd_elf_allocate_object.
   (is_sparc_elf): New macro.  Checks a BFD to make sure that is a Sparc
   ELF bfd.
   (_bfd_sparc_elf_check_relocs): Use is_sparc_elf macro to check the
   bfd being processed.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_check_relocs): Use elf_symtab_hdr.
   (_bfd_sparc_elf_gc_sweep_hook): Likewise.
   (_bfd_sparc_elf_size_dynamic_sections): Likewise.
   (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@a1281 19
		  const char *name;
		  bfd *dynobj;

		  name = (bfd_elf_string_from_elf_section
			  (abfd,
			   elf_elfheader (abfd)->e_shstrndx,
			   elf_section_data (sec)->rel_hdr.sh_name));
		  if (name == NULL)
		    return FALSE;

		  if (! CONST_STRNEQ (name, ".rela")
		      || strcmp (bfd_get_section_name (abfd, sec),
				 name + 5) != 0)
		    {
		      (*_bfd_error_handler)
			(_("%B: bad relocation section name `%s\'"),
			 abfd, name);
		    }

d1285 3
a1287 2
		  dynobj = htab->elf.dynobj;
		  sreloc = bfd_get_section_by_name (dynobj, name);
d1289 1
a1289 15
		    {
		      flagword flags;

		      flags = (SEC_HAS_CONTENTS | SEC_READONLY
			       | SEC_IN_MEMORY | SEC_LINKER_CREATED);
		      if ((sec->flags & SEC_ALLOC) != 0)
			flags |= SEC_ALLOC | SEC_LOAD;
		      sreloc = bfd_make_section_with_flags (dynobj,
							    name,
							    flags);
		      if (sreloc == NULL
			  || ! bfd_set_section_alignment (dynobj, sreloc, 2))
			return FALSE;
		    }
		  elf_section_data (sec)->sreloc = sreloc;
@


1.96
log
@2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Exit early if generating a
	relocatable.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_sweep_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_sweep_hook): Likewise.
	* elflink.c (bfd_elf_gc_sections): Do not punt on relocatable output
	or executable output with relocations.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d677 2
d683 1
a683 1
  /* tls_type for each local got entry.  */
d693 5
d701 2
a702 8
  if (abfd->tdata.any == NULL)
    {
      bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
      abfd->tdata.any = bfd_zalloc (abfd, amt);
      if (abfd->tdata.any == NULL)
	return FALSE;
    }
  return bfd_elf_mkobject (abfd);
d986 2
d989 1
a989 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d1435 1
a1435 1
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
d2025 1
a2025 1
      if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
d2056 1
a2056 1
      symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
d2275 2
d2278 1
a2278 1
  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
@


1.95
log
@bfd/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* elf32-i386.c (elf_i386_check_relocs): Revert NULL pointer
	check for R_386_GNU_VTINHERIT.
	* elf-m10300.c (mn10300_elf_check_relocs): Check for NULL
	pointer for R_xxx_GNU_VTENTRY.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-bfin.c (bfin_check_relocs): Likewise.
	(bfinfdpic_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-score.c (_bfd_score_elf_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d1427 3
@


1.94
log
@Switch sources over to use the GPL version 3
@
text
@d1379 3
a1381 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
@


1.93
log
@2007-05-15  H.J. Lu  <hongjiu.lu@@intel.com>
	    Alan Modra  <amodra@@bigpond.net.au>

	PR ld/4504
	* elf-bfd.h (_bfd_elf_adjust_dynamic_copy): New.
	* elflink.c (_bfd_elf_adjust_dynamic_copy): New.

	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Call
	_bfd_elf_adjust_dynamic_copy to adjust for the copy in dynamic
	bss section.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_vxworks_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.92
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@a1584 1
  unsigned int power_of_two;
a1704 7
  /* We need to figure out the alignment required for this symbol.  I
     have no idea how ELF linkers handle this.  */
  power_of_two = bfd_log2 (h->size);
  if (power_of_two > 3)
    power_of_two = 3;

  /* Apply the required alignment.  */
a1705 6
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (htab->elf.dynobj, s))
    {
      if (! bfd_set_section_alignment (htab->elf.dynobj, s, power_of_two))
	return FALSE;
    }
d1707 1
a1707 8
  /* Define the symbol as being at this point in the section.  */
  h->root.u.def.section = s;
  h->root.u.def.value = s->size;

  /* Increment the section size to make room for the symbol.  */
  s->size += h->size;

  return TRUE;
@


1.91
log
@	* aout-adobe.c (aout_32_bfd_reloc_name_lookup): Define.
	* aout-arm.c (MY_bfd_reloc_name_lookup): Define.
	(MY (bfd_reloc_name_lookup)): New function.
	* aout-ns32k.c (MY (bfd_reloc_name_lookup)): New function.
	* aout-target.h (NAME (aout, reloc_name_lookup)): Declare.
	(MY_bfd_reloc_name_lookup): Define.
	* aout-tic30.c (tic30_aout_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* aoutx.h (NAME (aout, reloc_type_lookup)): Don't declare.
	(NAME (aout, reloc_name_lookup)): New function.
	* bout.c (b_out_bfd_reloc_name_lookup): New function.
	* coff-alpha.c (alpha_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-arm.c (coff_arm_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i386.c (coff_bfd_reloc_name_lookup): Define.
	(coff_i386_reloc_name_lookup): New function.
	* coff-i860.c (coff_i860_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-i960.c (coff_i960_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-m68k.c (m68k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-maxq.c (maxq_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mcore.c (mcore_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-mips.c (mips_bfd_reloc_name_lookup): New function.
	(_bfd_ecoff_bfd_reloc_name_lookup): Define.
	* coff-ppc.c (ppc_coff_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(_bfd_xcoff_reloc_name_lookup): New function.
	(rs6000coff_vec, pmac_xcoff_vec): Init new field.
	* coff-sh.c (coff_bfd_reloc_name_lookup): Define.
	(sh_coff_reloc_name_lookup): New function.
	* coff-sparc.c (coff_sparc_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-tic30.c (coff_bfd_reloc_name_lookup): Define.
	(tic30_coff_reloc_name_lookup): New function.
	* coff-tic4x.c (coff_bfd_reloc_name_lookup): Define.
	(tic4x_coff_reloc_name_lookup): New function.
	* coff-tic54x.c (coff_bfd_reloc_name_lookup): Define.
	(tic54x_coff_reloc_name_lookup): New function.
	* coff-x86_64.c (coff_bfd_reloc_name_lookup): Define.
	(coff_amd64_reloc_name_lookup): New function.
	* coff-z80.c (coff_z80_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff-z8k.c (coff_z8k_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* coff64-rs6000.c (coff_bfd_reloc_name_lookup): Define.
	(xcoff64_reloc_name_lookup): New function.
	(rs6000coff64_vec, aix5coff64_vec): Init new field.
	* coffcode.h (coff_bfd_reloc_name_lookup): Define.
	* elf-hppa.h (elf_hppa_reloc_name_lookup): New function.
	* elf-m10200.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf-m10300.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arc.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-arm.c (elf32_arm_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-avr.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-bfin.c (bfin_bfd_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cr16c.c (elf_cr16c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-cris.c (cris_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-crx.c (elf_crx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-d10v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-d30v.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-dlx.c (elf32_dlx_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-fr30.c (fr30_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-frv.c (frv_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-gen.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-h8300.c (elf32_h8_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-hppa.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i370.c (i370_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i386.c (elf_i386_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i860.c (elf32_i860_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-i960.c (elf32_i960_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ip2k.c (ip2k_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-iq2000.c (iq2000_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32c.c (m32c_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m32r.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc11.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68hc12.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-m68k.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-m88k.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mcore.c (mcore_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mep.c (mep_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-msp430.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-mt.c (mt_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-openrisc.c (openrisc_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-or32.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elf32-pj.c (pj_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-ppc.c (ppc_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-score.c (elf32_score_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sh.c (sh_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-sparc.c (bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-spu.c (spu_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-v850.c (v850_elf_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-vax.c (reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xc16x.c (xc16x_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xstormy16.c (xstormy16_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf32-xtensa.c (elf_xtensa_reloc_name_lookup): New function.
	(bfd_elf32_bfd_reloc_name_lookup): Define.
	* elf64-alpha.c (elf64_alpha_bfd_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-gen.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-hppa.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-mips.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-mmix.c (bfd_elf64_bfd_reloc_name_lookup): New function.
	* elf64-ppc.c (ppc64_elf_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-s390.c (elf_s390_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sh64.c (sh_elf64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-sparc.c (bfd_elf64_bfd_reloc_name_lookup): Define.
	* elf64-x86-64.c (elf64_x86_64_reloc_name_lookup): New function.
	(bfd_elf64_bfd_reloc_name_lookup): Define.
	* elfn32-mips.c (bfd_elf32_bfd_reloc_name_lookup): New function.
	* elfxx-ia64.c (elfNN_ia64_reloc_name_lookup): New function.
	(bfd_elfNN_bfd_reloc_name_lookup): Define.
	* elfxx-sparc.c (_bfd_sparc_elf_reloc_name_lookup): New function.
	* elfxx-sparc.h (_bfd_sparc_elf_reloc_name_lookup): Declare.
	* i386msdos.c (msdos_bfd_reloc_name_lookup): Define.
	* i386os9k.c (aout_32_bfd_reloc_name_lookup): Define.
	* ieee.c (ieee_bfd_reloc_name_lookup): Define.
	* libaout.h (NAME (aout, reloc_name_lookup)): Declare.
	* libbfd-in.h (_bfd_norelocs_bfd_reloc_name_lookup): Declare.
	* mipsbsd.c (MY_bfd_reloc_name_lookup): Define.
	(MY(reloc_type_lookup)): Rename from MY(reloc_howto_type_lookup).
	(MY(reloc_name_lookup)): New function.
	* nlm-target.h (nlm_bfd_reloc_name_lookup): Define.
	* oasys.c (oasys_bfd_reloc_name_lookup): Define.
	* pdp11.c (NAME (aout, reloc_name_lookup)): New function.
	* pe-mips.c (coff_mips_reloc_name_lookup): New function.
	(coff_bfd_reloc_name_lookup): Define.
	* reloc.c (bfd_reloc_name_lookup): New function.
	* riscix.c (riscix_reloc_name_lookup): New function.
	(MY_bfd_reloc_name_lookup): Define.
	* som.c (som_bfd_reloc_name_lookup): New function.
	* targets.c (struct bfd_target): Add reloc_name_lookup.
	(BFD_JUMP_TABLE_RELOCS): Add NAME##_bfd_reloc_name_lookup.
	* versados.c (versados_bfd_reloc_name_lookup): Define.
	* vms.c (vms_bfd_reloc_name_lookup): New function.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.90
log
@	PR 3958
bfd/
	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): No error on relocatable link.
	(elf_discarded_section): Move..
	* bfd-in.h: ..to here.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_input_bfd): Don't zap relocs against symbols
	from discarded sections before relocate_section has done its job.
	* reloc.c (bfd_generic_get_relocated_section_contents): Handle
	relocs against symbols from discarded sections.
	* elf-hppa.h (elf_hppa_howto_table): Set size.  Set dst_mask on
	SECREL32.
	(elf_hppa_relocate_section): Handle relocatable link after setting
	sec, sym, h etc. for final link.  Squash error messages for
	relocatable link.  Clear section contents for relocs against
	symbols in discarded sections, and zero reloc.  Remove existing
	zero r_symndx code.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-bfin.c (bfinfdpic_relocate_section): Likewise.
	(bfin_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32c.c (m32c_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-mep.c (mep_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-mt.c (mt_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-score.c (_bfd_score_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-spu.c (spu_elf_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xc16x.c (elf32_xc16x_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section_r): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elf32-arm.c (elf32_arm_relocate_section): Always adjust section
	symbols for relocatable link.  Don't use always-zero st_value.
	(elf_backend_rela_normal): Don't define.
	* elf32-bfin.c (bfinfdpic_relocate_section): Use
	RELOC_FOR_GLOBAL_SYMBOL.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Combine SEC_MERGE
	section symbol adjustments with same for relocatable link.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_get_relocation_value): Move..
	(elf32_m68hc11_check_relocs): ..to here.
	* elf32-score.c (score_elf_final_link_relocate): Remove zero
	r_symndx code.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.

ld/testsuite/
	* ld-elf/linkonce1.d: New.
	* ld-elf/linkonce1a.s: New.
	* ld-elf/linkonce1b.s: New.
	* ld-elf/linkonce2.d: New.
	* ld-i386/pcrel16abs.d: New.
	* ld-i386/pcrel16abs.s: New.
	* ld-i386/i386.exp: Run it.
@
text
@d337 19
d3562 1
@


1.89
log
@bfd/
	* libbfd-in.h (_bfd_clear_contents): New prototype.
	* reloc.c (_bfd_clear_contents): New.
	* libbfd.h: Regenerated.

	* elf32-arm.c (elf32_arm_final_link_relocate): Use
	_bfd_clear_contents.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Set value to
	zero for discarded symbols.
	* elfxx-mips.c (mips_elf_calculate_relocation): Likewise.
ld/testsuite/
	* ld-discard/zero-rel.d, ld-discard/zero-rel.s: New files.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005, 2006
a2268 3
  if (info->relocatable)
    return TRUE;

a2302 1
      /* This is a final link.  */
d2323 14
a2552 9
	  /* r_symndx will be zero only for relocs against symbols
	     from removed linkonce sections, or sections discarded by
	     a linker script.  */
	  if (r_symndx == 0)
	    {
	      _bfd_clear_contents (howto, input_bfd, contents + rel->r_offset);
	      break;
	    }

@


1.88
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d2546 7
a2552 2
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
@


1.87
log
@	* elflink.c (_bfd_elf_gc_mark_hook): New function.
	* elf-bfd.h (_bfd_elf_gc_mark_hook): Declare.
	* elfxx-target.h (elf_backend_gc_mark_hook): Default to above.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	* elf32-arm.c (elf32_arm_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-score.c (_bfd_score_elf_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_gc_mark_hook): Likewise.
	* elf32-bfin.c (bfin_gc_mark_hook): Likewise.
	(bfinfdpic_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define for elf32-bfinfdpic.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_d10v_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(fr30_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(elf32_frv_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-iq2000.c (iq2000_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(iq2000_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(openrisc_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-v850.c (v850_elf_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(v850_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Use
	_bfd_elf_gc_mark_hook.
	(xstormy16_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Use _bfd_elf_gc_mark_hook.
	(sh_elf64_gc_sweep_hook): Delete.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Delete.
	(elf32_avr_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-cr16c.c (elf32_cr16c_gc_mark_hook): Delete.
	(elf32_cr16c_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-crx.c (elf32_crx_gc_mark_hook): Delete.
	(elf32_crx_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-h8300.c (elf32_h8_gc_mark_hook): Delete.
	(elf32_h8_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-ip2k.c (ip2k_elf_gc_mark_hook): Delete.
	(ip2k_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m32c.c (m32c_elf_gc_mark_hook, m32c_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-m68hc11.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc12.c (elf_backend_gc_mark_hook): Don't define.
	(elf_backend_gc_sweep_hook): Don't define.
	* elf32-m68hc1x.c (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-m68hc1x.h (elf32_m68hc11_gc_mark_hook): Delete.
	(elf32_m68hc11_gc_sweep_hook): Delete.
	* elf32-msp430.c (elf32_msp430_gc_mark_hook): Delete.
	(elf32_msp430_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
	* elf32-mt.c (mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook): Delete.
	(elf_backend_gc_mark_hook, elf_backend_gc_mark_hook): Don't define.
@
text
@d2633 6
a2638 1
			  BFD_ASSERT (sindx > 0);
a2644 1

d3549 1
@


1.86
log
@	* elf32-s390.c (elf_s390_relocate_section): Remove check for code
	section in LD to LE linker relaxation for R_390_TLS_LDO32.
	* elf64-s390.c (elf_s390_relocate_section): Likewise for
	R_390_TLS_LDO64.
@
text
@a48 6
static asection *elf_s390_gc_mark_hook
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
	   struct elf_link_hash_entry *, Elf_Internal_Sym *));
static bfd_boolean elf_s390_gc_sweep_hook
  PARAMS ((bfd *, struct bfd_link_info *, asection *,
	   const Elf_Internal_Rela *));
d1376 5
a1380 6
elf_s390_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     Elf_Internal_Rela *rel;
     struct elf_link_hash_entry *h;
     Elf_Internal_Sym *sym;
d1383 7
a1389 13
    {
      switch (ELF32_R_TYPE (rel->r_info))
	{
	case R_390_GNU_VTINHERIT:
	case R_390_GNU_VTENTRY:
	  break;

	default:
	  switch (h->root.type)
	    {
	    case bfd_link_hash_defined:
	    case bfd_link_hash_defweak:
	      return h->root.u.def.section;
a1390 12
	    case bfd_link_hash_common:
	      return h->root.u.c.p->section;

	    default:
	      break;
	    }
	}
    }
  else
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);

  return NULL;
d1396 4
a1399 5
elf_s390_gc_sweep_hook (abfd, info, sec, relocs)
     bfd *abfd;
     struct bfd_link_info *info;
     asection *sec;
     const Elf_Internal_Rela *relocs;
@


1.85
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d2930 1
a2930 1
	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
@


1.84
log
@	PR ld/2754
	* elf.c (bfd_elf_mkobject): Don't alloc if already done.  Set
	program_header_size to -1.
	(_bfd_elf_map_sections_to_segments): Adjust program_header_size check.
	(assign_file_positions_for_load_sections ): Likewise.
	(_bfd_elf_sizeof_headers): Use saved program_header_size if
	available.
	* elf32-arm.c (elf32_arm_mkobject): Call bfd_elf_mkobject, don't
	alloc if already done.
	* elf32-i386.c (elf_i386_mkobject): Likewise.
	* elf32-ppc.c (ppc_elf_mkobject): Likewise.
	* elf32-s390.c (elf_s390_mkobject): Likewise.
	* elf32-sh.c (sh_elf_mkobject): Likewise.
	* elf64-alpha.c (elf64_alpha_mkobject): Likewise.
	* elf64-ppc.c (ppc64_elf_mkobject): Likewise.
	* elf64-s390.c (elf_s390_mkobject): Likewise.
	* elf64-x86-64.c (elf64_x86_64_mkobject): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_mkobject): Likewise.
@
text
@d1276 1
a1276 1
		  if (strncmp (name, ".rela", 5) != 0
d2129 1
a2129 1
      else if (strncmp (bfd_get_section_name (dynobj, s), ".rela", 5) == 0)
@


1.83
log
@	* elf32-s390.c (invalid_tls_insn): Call bfd_set_error.
	(elf_s390_relocate_section): Add code to do the GD->LE and
	LD->LE TLS linker optimizations if a brasl instruction is used
	for the __tls_get_offset function call.
	* elf64-s390.c (invalid_tls_insn): Call bfd_set_error.
@
text
@a75 2
static bfd_boolean elf_s390_mkobject
  PARAMS ((bfd *));
d679 1
a679 2
elf_s390_mkobject (abfd)
     bfd *abfd;
a680 2
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
d682 7
a688 2
    return FALSE;
  return TRUE;
@


1.82
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d2271 1
d2986 2
a2987 1
	      if ((insn & 0xff000fff) != 0x4d000000)
d2990 16
a3005 3
		/* GD->LE transition.
		   bas %r14,0(%rx,%r13) -> bc 0,0  */
		insn = 0x47000000;
d3007 17
a3023 3
		/* GD->IE transition.
		   bas %r14,0(%rx,%r13) -> l %r2,0(%r2,%r12)  */
		insn = 0x5822c000;
d3033 2
a3034 1
		  if ((insn & 0xff000fff) != 0x4d000000)
d3036 14
a3049 3
		  /* LD->LE transition.
		     bas %r14,0(%rx,%r13) -> bc 0,0  */
		  insn = 0x47000000;
@


1.81
log
@	* elf-m10300.c (_bfd_mn10300_elf_finish_dynamic_symbol): Use the
	cached hgot entry to check for _GLOBAL_OFFSET_TABLE_.
	* elf32-arm.c (elf32_arm_finish_dynamic_symbol): Likewise.
	* elf32-bfin.c (bfin_finish_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_finish_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_finish_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_finish_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_finish_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_finish_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_finish_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_finish_dynamic_symbol): Likewise.
	* elf32-xtensa.c (elf_xtensa_finish_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_finish_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_symbol): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_finish_dynamic_symbol): Likewise.  Also use
	the cached hplt entry to check for _PROCEDURE_LINKAGE_TABLE_.
	* elf64-alpha.c (elf64_alpha_finish_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_finish_dynamic_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_finish_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_finish_dynamic_symbol): Likewise.
@
text
@d774 2
a775 1
  if (! _bfd_elf_link_hash_table_init (&ret->elf, abfd, link_hash_newfunc))
@


1.80
log
@	PR ld/2218
	* elf32-arm.c (allocate_dynrelocs): Ensure undef weak sym in pie
	is dynamic.
	* elf32-hppa.c (allocate_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	* elf32-sh.c (allocate_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	* elf32-m32r.c (allocate_dynrelocs): Likewise.  Discard relocs
	on undef weak with non-default visibility too.
	* elfxx-sparc.c (allocate_dynrelocs): Ditto.
@
text
@d3312 2
a3313 2
      || strcmp (h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0
      || strcmp (h->root.root.string, "_PROCEDURE_LINKAGE_TABLE_") == 0)
@


1.79
log
@	PR ld/1540
	* elf-bfd.h (elf_backend_copy_indirect_symbol): Replace pointer to
	elf_backend_data with pointer to bfd_link_info.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Handle
	direct and indirect symbols both having dynamic link info.
	* elf32-arm.c (elf32_arm_copy_indirect_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
	* elflink.c: Adjust all calls to bed->elf_backend_copy_indirect_symbol.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Update prototype.
	* elfxx-sparc.h (_bfd_sparc_elf_copy_indirect_symbol): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004, 2005
d1911 1
a1911 1
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
d1913 13
a1925 1
	eh->dyn_relocs = NULL;
@


1.78
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Avoid aliasing warnings from
	GCC.
	(elf32_arm_size_dynamic_sections): Likewise.
	* ecofflink.c (bfd_ecoff_debug_one_external): Likewise.
	* elf32-hppa.c (elf32_hppa_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs, dec_dynrel_count)
	(ppc64_elf_size_dynamic_sections): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_finish_dynamic_sections): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
	(_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* ieee.c (ieee_slurp_section_data): Likewise.
	* oasys.c (oasys_slurp_section_data): Likewise.
opcodes/
	* ppc-dis.c (struct dis_private): Remove.
	(powerpc_dialect): Avoid aliasing warnings.
	(print_insn_big_powerpc, print_insn_little_powerpc): Likewise.
@
text
@d44 1
a44 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d858 2
a859 2
elf_s390_copy_indirect_symbol (bed, dir, ind)
     const struct elf_backend_data *bed;
d874 1
a874 4
	  if (ind->root.type == bfd_link_hash_indirect)
	    abort ();

	  /* Add reloc counts against the weak sym to the strong sym
d918 1
a918 1
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.77
log
@2005-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1208
	* elf-hppa.h (elf_hppa_relocate_section): Print out the name
	of unresolvable relocation.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.c (elf32_arm_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_relocate_section): Likewise.
@
text
@d1322 1
d1329 2
a1330 2
		  head = ((struct elf_s390_dyn_relocs **)
			  &elf_section_data (s)->local_dynrel);
d2042 1
a2042 4
	  for (p = *((struct elf_s390_dyn_relocs **)
		     &elf_section_data (s)->local_dynrel);
	       p != NULL;
	       p = p->next)
@


1.76
log
@	* elf-m10300.c (_bfd_mn10300_elf_adjust_dynamic_symbol): Warn on
	zero size dynamic variables.
	* elf32-arm.c (elf32_arm_adjust_dynamic_symbol): Likewise.
	* elf32-cris.c (elf_cris_adjust_dynamic_symbol): Likewise.
	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf32-m32r.c (m32r_elf_adjust_dynamic_symbol): Likewise.
	* elf32-m68k.c (elf_m68k_adjust_dynamic_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf32-sh.c (sh_elf_adjust_dynamic_symbol): Likewise.
	* elf32-vax.c (elf_vax_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-sh64.c (sh64_elf64_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_adjust_dynamic_symbol): Likewise.
@
text
@d3017 1
a3017 1
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
d3021 1
@


1.75
log
@	* elf-hppa.h (elf_hppa_final_link): Use gp val of zero when none
	of the usual sections are found.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Tidy.
	Strip .dynbss if it is zero size.
	* elf32-arm.c (elf32_arm_size_dynamic_sections): Likewise.
	* elf32-cris.c (elf_cris_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise, and
	.dynsbss.
	(i370_elf_finish_dynamic_sections): Don't attempt to write .got
	when it is zero size.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Correct handling
	of .dynbss and zero size sections.
	* elf32-m32r.c (m32r_elf_size_dynamic_sections): Strip .dynbss if
	it is zero size.
	* elf32-m68k.c (elf_m68k_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise, .dynsbss
	too.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf32-vax.c (elf_vax_size_dynamic_sections): Likewise.
	* elf32-xtensa.c (elf_xtensa_size_dynamic_sections): Tidy.  Strip
	.plt.* and .got.plt.* if zero size.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections): Tidy.  Strip
	.got* and .dynbss if zero size.
	* elf64-hppa.c (elf64_hppa_size_dynamic_sections): Tidy.  Strip
	* elf64-ppc.c (create_linkage_sections): Create branch lookup table
	in .data.rel.ro.brlt or .rodata.brlt, and similarly for associated
	reloc section.
	(create_got_section): Always create new .got and .rela.got sections.
	(ppc64_elf_size_dynamic_sections): Tidy.  Strip .dynbss if zero size.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Handle
	dynamic bss sections correctly.
	* elfxx-mips.c (_bfd_mips_elf_size_dynamic_sections): Tidy.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Tidy.  Strip
	.dynbss if zero size.
@
text
@d1686 7
@


1.74
log
@	* libbfd-in.h (bfd_malloc2, bfd_realloc2, bfd_zmalloc2, bfd_alloc2,
	bfd_zalloc2): New prototypes.
	* bfd-in.h (HALF_BFD_SIZE_TYPE): Define.
	* libbfd.c (bfd_malloc2, bfd_realloc2, bfd_zmalloc2): New functions.
	* opncls.c (bfd_alloc2, bfd_zalloc2): New functions.
	* elf.c (bfd_elf_get_elf_syms, setup_group, assign_section_numbers,
	elf_map_symbols, map_sections_to_segments,
	assign_file_positions_for_segments, copy_private_bfd_data,
	swap_out_syms, _bfd_elf_slurp_version_tables): Use bfd_*alloc2
	where appropriate.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.

	* elf.c (_bfd_elf_print_private_bfd_data): Don't crash on bogus
	verdef or verneed section.
	(_bfd_elf_slurp_version_tables): Handle corrupt verdef and/or
	verneed sections gracefully.
	* elfxx-sparc.c (_bfd_sparc_elf_info_to_howto_ptr): Don't crash on
	bogus relocation values.
	* elf64-ppc.c (ppc64_elf_info_to_howto): Likewise.
	* elf64-s390.c (elf_s390_info_to_howto): Likewise.
	* elf32-s390.c (elf_s390_info_to_howto): Likewise.
	* elf64-x86-64.c (elf64_x86_64_info_to_howto): Likewise.
	* elfxx-ia64.c (lookup_howto): Likewise.
@
text
@d2108 2
a2109 1
	  || s == htab->sgotplt)
d2145 3
@


1.73
log
@2005-06-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 1025
	* elf-m10300.c (mn10300_elf_check_relocs): Handle indirect
	symbol.
	* elf32-arm.c (elf32_arm_check_relocs): Likewise.
	* elf32-avr.c (elf32_avr_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-d10v.c (elf32_d10v_check_relocs): Likewise.
	* elf32-dlx.c (elf32_dlx_check_relocs): Likewise.
	* elf32-fr30.c (fr30_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_check_relocs): Likewise.
	* elf32-iq2000.c (iq2000_elf_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_check_relocs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-mcore.c (mcore_elf_check_relocs): Likewise.
	* elf32-ms1.c (ms1_elf_check_relocs): Likewise.
	* elf32-msp430.c (elf32_msp430_check_relocs): Likewise.
	* elf32-openrisc.c (openrisc_elf_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (elf_s390_check_relocs): Likewise.
	* elf32-sh.c (sh_elf_check_relocs): Likewise.
	* elf32-v850.c (v850_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf64-mmix.c (mmix_elf_check_relocs): Likewise.
	* elf64-ppc.c (ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_check_relocs): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_check_relocs): Likewise.
@
text
@d354 2
a355 1
  switch (ELF32_R_TYPE(dst->r_info))
d366 7
a372 2
      BFD_ASSERT (ELF32_R_TYPE(dst->r_info) < (unsigned int) R_390_max);
      cache_ptr->howto = &elf_howto_table[ELF32_R_TYPE(dst->r_info)];
@


1.72
log
@2005-05-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* section.c (bfd_make_section_anyway_with_flags): New.
	(bfd_make_section_anyway): Call bfd_make_section_anyway_with_flags,
	(bfd_make_section_with_flags): New.
	(bfd_make_section): Call bfd_make_section_with_flags.

	* elf-m10300.c (_bfd_mn10300_elf_create_got_section): Call
	bfd_make_section_with_flags/bfd_make_section_anyway_with_flags
	instead of bfd_make_section/bfd_make_section and don't call
	bfd_set_section_flags.
	(mn10300_elf_check_relocs): Likewise.
	(_bfd_mn10300_elf_create_dynamic_sections): Likewise.
	* elf32-arm.c (create_got_section): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Likewise.
	(elf32_arm_check_relocs): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Likewise.
	* elf32-frv.c (elf32_frv_add_symbol_hook): Likewise.
	(_frv_create_got_section): Likewise.
	(elf32_frvfdpic_create_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_create_dynamic_sections): Likewise.
	(elf32_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_create_dynamic_sections): Likewise.
	(i370_elf_check_relocs): Likewise.
	* elf32-i386.c (create_got_section): Likewise.
	(elf_i386_check_relocs): Likewise.
	* elf32-m32r.c (m32r_elf_add_symbol_hook): Likewise.
	(create_got_section): Likewise.
	(m32r_elf_create_dynamic_sections): Likewise.
	(m32r_elf_check_relocs): Likewise.
	* elf32-m68k.c (elf_m68k_check_relocs): Likewise.
	* elf32-ppc.c (ppc_elf_create_got): Likewise.
	(ppc_elf_create_dynamic_sections): Likewise.
	(ppc_elf_add_symbol_hook): Likewise.
	(ppc_elf_check_relocs): Likewise.
	* elf32-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf32-sh.c (create_got_section): Likewise.
	(sh_elf_create_dynamic_sections): Likewise.
	(sh_elf_check_relocs): Likewise.
	* elf32-vax.c (elf_vax_check_relocs): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_check_relocs): Likewise.
	* elf32-xtensa.c (elf_xtensa_create_dynamic_sections): Likewise.
	(add_extra_plt_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_add_symbol_hook): Likewise.
	(elf64_alpha_create_got_section): Likewise.
	(elf64_alpha_create_dynamic_sections): Likewise.
	(elf64_alpha_check_relocs): Likewise.
	* elf64-hppa.c (get_reloc_section): Likewise.
	(get_opd): Likewise.
	(get_plt): Likewise.
	(get_dlt): Likewise.
	(get_stub): Likewise.
	(elf64_hppa_create_dynamic_sectionso): Likewise.
	* elf64-mmix.c (mmix_elf_check_common_relocs): Likewise.
	* elf64-ppc.c (create_linkage_sections): Likewise.
	(ppc64_elf_check_relocs): Likewise.
	* elf64-s390.c (create_got_section): Likewise.
	(elf_s390_check_relocs): Likewise.
	* elf64-sh64.c (sh_elf64_check_relocs): Likewise.
	(sh64_elf64_create_dynamic_sections): Likewise.
	* elf64-x86-64.c (create_got_section): Likewise.
	(elf64_x86_64_check_relocs): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(elf_link_add_object_symbols): Likewise.
	* elfxx-ia64.c (elfNN_ia64_add_symbol_hook): Likewise.
	(elfNN_ia64_create_dynamic_sections): Likewise.
	(get_fptr): Likewise.
	(get_pltoff): Likewise.
	(get_reloc_section): Likewise.
	(elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (mips_elf_rel_dyn_section): Likewise.
	(mips_elf_create_compact_rel_section): Likewise.
	(mips_elf_create_got_section): Likewise.
	(_bfd_mips_elf_create_dynamic_sections): Likewise.
	* elfxx-sparc.c (create_got_section): Likewise.
	(_bfd_sparc_elf_check_relocs): Likewise.

	* elf.c (_bfd_elf_new_section_hook): Call _bfd_elf_get_sec_type_attr
	on linker created sections.
@
text
@d994 6
a999 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
@


1.71
log
@Update the address and phone number of the FSF organization in the GPL notices
@
text
@d806 6
a811 1
  htab->srelgot = bfd_make_section (dynobj, ".rela.got");
a812 4
      || ! bfd_set_section_flags (dynobj, htab->srelgot,
				  (SEC_ALLOC | SEC_LOAD | SEC_HAS_CONTENTS
				   | SEC_IN_MEMORY | SEC_LINKER_CREATED
				   | SEC_READONLY))
a1284 1
		      sreloc = bfd_make_section (dynobj, name);
d1289 3
a1292 1
			  || ! bfd_set_section_flags (dynobj, sreloc, flags)
@


1.70
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
@


1.69
log
@Update the FSF address in the copyright/GPL notice
@
text
@d2127 1
a2127 1
	  _bfd_strip_section_from_output (info, s);
@


1.68
log
@	* elf64-ppc.c (ppc64_elf_gc_sweep_hook): Follow indirect and warning
	symbols.
	* elf32-arm.c (elf32_arm_gc_sweep_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_sweep_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_sweep_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_sweep_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_sweep_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_sweep_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_sweep_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
@
text
@d21 1
a21 1
   02111-1307, USA.  */
@


1.67
log
@bfd/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* aoutx.h (aout_link_input_section_std): Pass proper hash entry
	to linker reloc_overflow callback.
	(aout_link_input_section_ext): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* coff-a29k.c (coff_a29k_relocate_section): Likewise.
	* coff-alpha.c (alpha_ecoff_get_relocated_section_contents):
	Likewise.
	(alpha_relocate_section): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-h8300.c (h8300_reloc16_extra_cases): Likewise.
	* coff-h8500.c (extra_case): Likewise.
	* coff-i960.c (coff_i960_relocate_section): Likewise.
	* coff-mcore.c (coff_mcore_relocate_section): Likewise.
	* coff-mips.c (mips_relocate_section): Likewise.
	* coff-or32.c (coff_or32_relocate_section): Likewise.
	* coff-ppc.c (coff_ppc_relocate_section): Likewise.
	* coff-rs6000.c (xcoff_ppc_relocate_section): Likewise.
	* coff-sh.c (sh_relocate_section): Likewise.
	* coff-tic80.c (coff_tic80_relocate_section): Likewise.
	* coff-w65.c (w65_reloc16_extra_cases): Likewise.
	* coff-z8k.c (extra_case): Likewise.
	* coff64-rs6000.c (xcoff64_ppc_relocate_section): Likewise.
	* cofflink.c (_bfd_coff_reloc_link_order): Likewise.
	(_bfd_coff_generic_relocate_section): Likewise.
	* ecoff.c (ecoff_reloc_link_order): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cr16c.c (elf32_cr16c_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-crx.c (elf32_crx_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-iq2000.c (iq2000_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elflink.c (elf_reloc_link_order): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_relocate_section): Likewise.
	(_bfd_elf_mips_get_relocated_section_contents): Likewise.
	* linker.c (_bfd_generic_reloc_link_order): Likewise.
	* pdp11.c (pdp11_aout_link_input_section): Likewise.
	(aout_link_reloc_link_order): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents):
	Likewise.
	* xcofflink.c (xcoff_reloc_link_order): Likewise.
	* simple.c (simple_dummy_reloc_overflow): Updated.

include/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* bfdlink.h (bfd_link_callbacks): Add a pointer to struct
	bfd_link_hash_entry to reloc_overflow.

ld/

2004-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 463
	* ldmain.c (reloc_overflow): Accept a pointer to struct
	bfd_link_hash_entry. Report symbol location for relocation
	overflow.
@
text
@d2 2
a3 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1441 3
@


1.66
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d3032 3
a3034 2
		     (info, name, howto->name, (bfd_vma) 0,
		      input_bfd, input_section, rel->r_offset)))
@


1.65
log
@	* elf-bfd.h (struct elf_link_hash_entry): Replace elf_link_hash_flags
	with bitfields.  Make "type" and "other" bitfields too.
	(ELF_LINK_HASH_REF_REGULAR, ELF_LINK_HASH_DEF_REGULAR,
	ELF_LINK_HASH_REF_DYNAMIC, ELF_LINK_HASH_DEF_DYNAMIC,
	ELF_LINK_HASH_REF_REGULAR_NONWEAK, ELF_LINK_HASH_DYNAMIC_ADJUSTED,
	ELF_LINK_HASH_NEEDS_COPY, ELF_LINK_HASH_NEEDS_PLT, ELF_LINK_NON_ELF,
	ELF_LINK_HIDDEN, ELF_LINK_FORCED_LOCAL, ELF_LINK_HASH_MARK,
	ELF_LINK_NON_GOT_REF, ELF_LINK_DYNAMIC_DEF, ELF_LINK_DYNAMIC_WEAK,
	ELF_LINK_POINTER_EQUALITY_NEEDED): Delete.
	(ELF_COMMON_DEF_P, WILL_CALL_FINISH_DYNAMIC_SYMBOL): Update.
	* elf-hppa.h: Update all uses of elf_link_hash_flags.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh-symbian.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* configure.in (AM_INIT_AUTOMAKE): Set version to 2.15.92.
	* configure: Regenerate.
	* aclocal.m4: Regenerate.
@
text
@d1614 1
a1614 1
  if (h->weakdef != NULL)
d1616 4
a1619 4
      BFD_ASSERT (h->weakdef->root.type == bfd_link_hash_defined
		  || h->weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->weakdef->root.u.def.section;
      h->root.u.def.value = h->weakdef->root.u.def.value;
d1621 1
a1621 1
	h->non_got_ref = h->weakdef->non_got_ref;
@


1.64
log
@bfd/
	* bfd.c (_bfd_default_error_handler): Handle %A and %B.
	(bfd_archive_filename, bfd_get_section_ident): Delete.
	* ecofflink.c (bfd_ecoff_debug_accumulate_other): Don't call
	bfd_archive_filename.
	* elflink.c (elf_link_input_bfd): Don't use callbacks->error_handler
	to warn about symbols in discarded sections.  Use _bfd_error_handler.
	* aout-adobe.c (aout_adobe_callback): See below.
	* aout-cris.c (swap_ext_reloc_in): ..
	* coff-arm.c (find_thumb_glue, find_arm_glue,
	coff_arm_relocate_section, bfd_arm_process_before_allocation,
	coff_arm_merge_private_bfd_data, _bfd_coff_arm_set_private_flags,
	coff_arm_copy_private_bfd_data): ..
	* coff-i860.c (i860_reloc_processing): ..
	* coff-mcore.c (mcore_coff_unsupported_reloc,
	coff_mcore_relocate_section): ..
	* coff-ppc.c (coff_ppc_relocate_section): ..
	* coff-rs6000.c (xcoff_create_csect_from_smclas
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_swap_insns, sh_relocate_section): ..
	* coff-tic54x.c (tic54x_reloc_processing): ..
	* coff-tic80.c (coff_tic80_relocate_section): ..
	* coff64-rs6000.c (xcoff64_create_csect_from_smclas): ..
	* coffcode.h (styp_to_sec_flags, coff_slurp_line_table,
	coff_slurp_symbol_table, coff_classify_symbol,
	coff_slurp_reloc_table): ..
	* coffgen.c (_bfd_coff_read_string_table): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_link_input_bfd,
	_bfd_coff_generic_relocate_section): ..
	* cpu-arm.c (bfd_arm_merge_machines): ..
	* cpu-sh.c (sh_merge_bfd_arch): ..
	* elf-hppa.h (elf_hppa_relocate_section): ..
	* elf.c (bfd_elf_string_from_elf_section, setup_group,
	_bfd_elf_setup_group_pointers, bfd_section_from_shdr,
	assign_section_numbers, _bfd_elf_symbol_from_bfd_symbol,
	copy_private_bfd_data, _bfd_elf_validate_reloc): ..
	* elf32-arm.h (find_thumb_glue, find_arm_glue,
	bfd_elf32_arm_process_before_allocation, elf32_thumb_to_arm_stub,
	elf32_arm_to_thumb_stub, elf32_arm_final_link_relocate,
	elf32_arm_relocate_section, elf32_arm_set_private_flags,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_private_bfd_data): ..
	* elf32-cris.c (cris_elf_relocate_section, cris_elf_check_relocs,
	cris_elf_merge_private_bfd_data
	* elf32-frv.c (elf32_frv_relocate_section, elf32_frv_check_relocs): ..
	* elf32-gen.c (elf32_generic_link_add_symbols): ..
	* elf32-hppa.c (hppa_add_stub, hppa_build_one_stub,
	elf32_hppa_check_relocs, get_local_syms, final_link_relocate,
	elf32_hppa_relocate_section): ..
	* elf32-i370.c (i370_elf_merge_private_bfd_data,
	i370_elf_check_relocs, i370_elf_relocate_section): ..
	* elf32-i386.c (elf_i386_info_to_howto_rel, elf_i386_check_relocs,
	elf_i386_relocate_section): ..
	* elf32-m32r.c (m32r_elf_relocate_section,
	m32r_elf_merge_private_bfd_data): ..
	* elf32-m68hc1x.c (m68hc12_add_stub,
	_bfd_m68hc11_elf_merge_private_bfd_data): ..
	* elf32-m68k.c (elf_m68k_relocate_section): ..
	* elf32-mcore.c (mcore_elf_unsupported_reloc,
	mcore_elf_relocate_section): ..
	* elf32-ppc.c (ppc_elf_merge_private_bfd_data, bad_shared_reloc,
	ppc_elf_check_relocs, ppc_elf_relocate_section,
	ppc_elf_begin_write_processing): ..
	* elf32-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf32-sh-symbian.c (sh_symbian_import_as,
	sh_symbian_process_embedded_commands,
	sh_symbian_relocate_section): ..
	* elf32-sh.c (sh_elf_relax_section, sh_elf_relax_delete_bytes,
	sh_elf_swap_insns, sh_elf_relocate_section, sh_elf_check_relocs,
	sh_elf_merge_private_data): ..
	* elf32-sparc.c (elf32_sparc_check_relocs,
	elf32_sparc_relocate_section,
	elf32_sparc_merge_private_bfd_data): ..
	* elf32-v850.c (v850_elf_check_relocs,
	v850_elf_merge_private_bfd_data): ..
	* elf32-xtensa.c (elf_xtensa_check_relocs,
	elf_xtensa_relocate_section, elf_xtensa_merge_private_bfd_data): ..
	* elf64-alpha.c (elf64_alpha_relax_with_lituse,
	elf64_alpha_relax_got_load, elf64_alpha_size_got_sections,
	elf64_alpha_relocate_section_r, elf64_alpha_relocate_section): ..
	* elf64-gen.c (elf64_generic_link_add_symbols): ..
	* elf64-ppc.c (ppc64_elf_merge_private_bfd_data, ppc_add_stub,
	ppc64_elf_check_relocs, ppc64_elf_edit_opd,
	ppc64_elf_relocate_section): ..
	* elf64-s390.c (elf_s390_check_relocs, invalid_tls_insn,
	elf_s390_relocate_section): ..
	* elf64-sh64.c (sh_elf64_relocate_section): ..
	* elf64-sparc.c (sparc64_elf_check_relocs,
	sparc64_elf_add_symbol_hook, sparc64_elf_relocate_section,
	sparc64_elf_merge_private_bfd_data): ..
	* elf64-x86-64.c (elf64_x86_64_check_relocs,
	elf64_x86_64_relocate_section): ..
	* elflink.c (_bfd_elf_add_default_symbol,
	_bfd_elf_link_assign_sym_version, elf_link_read_relocs_from_section,
	_bfd_elf_link_output_relocs, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_output_extsym,
	elf_get_linked_section_vma, elf_fixup_link_order,
	bfd_elf_final_link, bfd_elf_gc_record_vtinherit,
	bfd_elf_gc_record_vtinherit, _bfd_elf_section_already_linked): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section,
	elfNN_ia64_relocate_section, elfNN_ia64_merge_private_bfd_data): ..
	* elfxx-mips.c (mips_elf_perform_relocation,
	_bfd_mips_elf_check_relocs,
	_bfd_mips_elf_merge_private_bfd_data): ..
	* ieee.c (ieee_slurp_external_symbols): ..
	* ihex.c (ihex_bad_byte, ihex_scan, ihex_read_section): ..
	* libbfd.c (_bfd_generic_verify_endian_match): ..
	* linker.c (_bfd_generic_link_add_one_symbol,
	_bfd_generic_section_already_linked): ..
	* pdp11.c (translate_to_native_sym_flags): ..
	* pe-mips.c (coff_pe_mips_relocate_section): ..
	* peicode.h (pe_ILF_build_a_bfd): ..
	* srec.c (srec_bad_byte): ..
	* stabs.c (_bfd_link_section_stabs): ..
	* xcofflink.c (xcoff_link_add_symbols, xcoff_link_input_bfd): ..
	Replace all uses of bfd_archive_filename and bfd_get_section_ident
	with corresponding %B and %A in _bfd_error_handler format string.
	Replace occurrences of "fprintf (stderr," with _bfd_error_handler
	calls to use %A and %B.  Fix "against symbol .. from section" and
	similar error messages.  Combine multiple _bfd_error_handler calls
	where they were separated due to bfd_archive_filename deficiencies.
	* bfd-in2.h: Regenerate.
include/
	* bfdlink.h (struct bfd_link_callbacks): Remove "error_handler".
	(LD_DEFINITION_IN_DISCARDED_SECTION): Delete.
ld/
	* ldmain.c (link_callbacks): Remove "error_handler".
	* ldmisc.c: Include elf-bfd.h.
	(vfinfo): Sort comment.  Handle %A.  Use %A instead of
	bfd_get_section_indent.
	(error_handler): Delete.
	* ldmisc.h (error_handler): Delete declaration.
@
text
@d902 10
a911 9
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d1072 1
a1072 1
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d1093 1
a1093 1
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
d1202 1
a1202 1
	      h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d1239 1
a1239 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1245 1
a1245 2
		      || (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)))
d1582 1
a1582 1
      || (h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT) != 0)
d1586 2
a1587 2
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0
d1597 1
a1597 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1621 1
a1621 3
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1637 1
a1637 1
  if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0)
d1643 1
a1643 1
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d1664 1
a1664 1
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
d1687 1
a1687 1
      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_COPY;
d1748 1
a1748 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d1772 1
a1772 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1791 1
a1791 1
	  h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1798 1
a1798 1
      h->elf_link_hash_flags &= ~ELF_LINK_HASH_NEEDS_PLT;
d1831 1
a1831 1
	  && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d1899 3
a1901 3
      if ((h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
	  && (((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d1909 1
a1909 1
	      && (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)
d2372 2
a2373 2
			  || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d2553 3
a2555 5
		  && (h->elf_link_hash_flags & ELF_LINK_NON_GOT_REF) == 0
		  && (((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		       && (h->elf_link_hash_flags
			   & ELF_LINK_HASH_DEF_REGULAR) == 0)
d2591 1
a2591 2
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))
d2987 1
a2987 1
	       && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) != 0))
d3191 1
a3191 1
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
d3228 2
a3229 2
	      || (h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL))
	  && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
d3250 1
a3250 1
  if ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_COPY) != 0)
@


1.63
log
@	* bfd-in.h (bfd_get_section_limit): Define.
	* reloc.c (bfd_perform_relocation, bfd_install_relocation)
	(_bfd_final_link_relocate): Use bfd_get_section_limit.
	* aout-tic30.c (tic30_aout_final_link_relocate): Likewise.
	* coff-arm.c (coff_arm_relocate_section): Likewise.
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): Likewise.
	* cpu-ns32k.c (do_ns32k_reloc): Likewise.
	(bfd_ns32k_final_link_relocate): Likewise.
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): Likwise.
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): Likewise.
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc)
	(i860_howto_highadj_reloc, i860_howto_splitn_reloc): Likewise.
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc)
	(m32r_elf_generic_reloc, m32r_elf_relocate_section): Likewise.
	* elf32-m68hc1x.c (m68hc11_elf_special_reloc): Likewise.
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elf32-or32.c (or32_elf_consth_reloc): Likewise.
	* elf32-ppc.c (ppc_elf_addr16_ha_reloc): Likewise.
	* elf32-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf32-sh.c (sh_elf_reloc_loop): Likewise.
	* elf32-sparc.c (sparc_elf_wdisp16_reloc): Likewise.
	(sparc_elf_hix22_reloc, sparc_elf_lox10_reloc): Likwise.
	* elf32-v850.c (v850_elf_reloc): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_24_reloc): Likewise.
	* elf32-xtensa.c (bfd_elf_xtensa_reloc): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp): Likewise.
	* elf64-mips.c (mips_elf64_gprel32_reloc)
	(mips16_gprel_reloc): Likewise.
	* elf64-mmix.c (mmix_elf_reloc): Likewise.
	* elf64-s390.c (s390_elf_ldisp_reloc): Likewise.
	* elf64-sparc.c (init_insn_reloc): Likewise.
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gprel16_with_gp)
	(_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_lo16_reloc)
	(_bfd_mips_elf_generic_reloc): Likewise.
	* bfd-in2.h: Regenerate.
@
text
@d983 2
a984 3
	  (*_bfd_error_handler) (_("%s: bad symbol index: %d"),
				 bfd_archive_filename (abfd),
				 r_symndx);
d1160 2
a1161 2
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
d1271 2
a1272 2
			(_("%s: bad relocation section name `%s\'"),
			 bfd_archive_filename (abfd), name);
d2233 3
a2235 3
    (_("%s(%s+0x%lx): invalid instruction for TLS relocation %s"),
     bfd_archive_filename (input_bfd),
     bfd_get_section_name (input_bfd, input_section),
d2995 3
a2997 3
	  (_("%s(%s+0x%lx): unresolvable relocation against symbol `%s'"),
	   bfd_archive_filename (input_bfd),
	   bfd_get_section_name (input_bfd, input_section),
d3045 2
a3046 3
		(_("%s(%s+0x%lx): reloc against `%s': error %d"),
		 bfd_archive_filename (input_bfd),
		 bfd_get_section_name (input_bfd, input_section),
@


1.62
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@a400 1
  bfd_size_type sz;
d414 1
a414 2
  sz = input_section->rawsize ? input_section->rawsize : input_section->size;
  if (reloc_entry->address > sz)
@


1.61
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d401 1
d415 2
a416 1
  if (reloc_entry->address > input_section->_cooked_size)
d1692 1
a1692 1
      htab->srelbss->_raw_size += sizeof (Elf32_External_Rela);
d1704 1
a1704 1
  s->_raw_size = BFD_ALIGN (s->_raw_size, (bfd_size_type) (1 << power_of_two));
d1713 1
a1713 1
  h->root.u.def.value = s->_raw_size;
d1716 1
a1716 1
  s->_raw_size += h->size;
d1767 2
a1768 2
	  if (s->_raw_size == 0)
	    s->_raw_size += PLT_FIRST_ENTRY_SIZE;
d1770 1
a1770 1
	  h->plt.offset = s->_raw_size;
d1785 1
a1785 1
	  s->_raw_size += PLT_ENTRY_SIZE;
d1789 1
a1789 1
	  htab->sgotplt->_raw_size += GOT_ENTRY_SIZE;
d1792 1
a1792 1
	  htab->srelplt->_raw_size += sizeof (Elf32_External_Rela);
d1822 2
a1823 2
	  h->got.offset = htab->sgot->_raw_size;
	  htab->sgot->_raw_size += GOT_ENTRY_SIZE;
d1844 2
a1845 2
      h->got.offset = s->_raw_size;
      s->_raw_size += GOT_ENTRY_SIZE;
d1848 1
a1848 1
	s->_raw_size += GOT_ENTRY_SIZE;
d1854 1
a1854 1
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d1856 1
a1856 1
	htab->srelgot->_raw_size += 2 * sizeof (Elf32_External_Rela);
d1861 1
a1861 1
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d1937 1
a1937 1
      sreloc->_raw_size += p->count * sizeof (Elf32_External_Rela);
d2000 1
a2000 1
	  s->_raw_size = sizeof ELF_DYNAMIC_INTERPRETER;
d2039 1
a2039 1
		  srela->_raw_size += p->count * sizeof (Elf32_External_Rela);
d2060 2
a2061 2
	      *local_got = s->_raw_size;
	      s->_raw_size += GOT_ENTRY_SIZE;
d2063 1
a2063 1
		s->_raw_size += GOT_ENTRY_SIZE;
d2065 1
a2065 1
		srela->_raw_size += sizeof (Elf32_External_Rela);
d2076 3
a2078 3
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
d2104 1
a2104 1
	  if (s->_raw_size != 0)
d2117 1
a2117 1
      if (s->_raw_size == 0)
d2138 1
a2138 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->_raw_size);
d2159 1
a2159 1
      if (htab->splt->_raw_size != 0)
d3335 1
a3335 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->_raw_size);
d3358 1
a3358 4
	      if (s->_cooked_size != 0)
		dyn.d_un.d_val = s->_cooked_size;
	      else
		dyn.d_un.d_val = s->_raw_size;
d3366 1
a3366 1
      if (htab->splt && htab->splt->_raw_size > 0)
d3410 1
a3410 1
      if (htab->sgotplt->_raw_size > 0)
d3434 1
a3434 1
  unsigned int raw_size;
d3450 1
a3450 1
	raw_size = 144;
d3456 1
a3456 1
					  raw_size, note->descpos + offset);
@


1.60
log
@	* Makefile.am: Remove all mention of elflink.h.
	* Makefile.in: Regenerate.
	* bfd-in.h (bfd_elf_discard_info): Declare.
	(bfd_elf32_discard_info, bfd_elf64_discard_info): Delete.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (bfd_elf32_print_symbol, bfd_elf64_print_symbol,
	bfd_elf32_link_record_dynamic_symbol,
	bfd_elf64_link_record_dynamic_symbol,
	_bfd_elf_link_record_dynamic_symbol, bfd_elf32_bfd_final_link,
	bfd_elf64_bfd_final_link, elf_link_record_local_dynamic_symbol,
	_bfd_elf32_link_record_local_dynamic_symbol,
	_bfd_elf64_link_record_local_dynamic_symbol,
	_bfd_elf32_gc_sections, _bfd_elf32_gc_common_finalize_got_offsets,
	_bfd_elf32_gc_common_final_link, _bfd_elf64_gc_common_final_link,
	_bfd_elf32_gc_record_vtinherit, _bfd_elf32_gc_record_vtentry,
	_bfd_elf64_gc_sections, _bfd_elf64_gc_common_finalize_got_offsets,
	_bfd_elf64_gc_record_vtinherit, _bfd_elf64_gc_record_vtentry,
	_bfd_elf32_reloc_symbol_deleted_p,
	_bfd_elf64_reloc_symbol_deleted_p): Delete.
	(bfd_elf_link_record_dynamic_symbol,
	bfd_elf_link_record_local_dynamic_symbol,
	bfd_elf_final_link, bfd_elf_gc_sections,
	bfd_elf_gc_record_vtinherit, bfd_elf_gc_record_vtentry,
	bfd_elf_gc_common_finalize_got_offsets, bfd_elf_gc_common_final_link,
	bfd_elf_reloc_symbol_deleted_p): Declare.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
	* elf32-arm.h: Update for changed function names.  Remove local
	WILL_CALL_FINISH_DYNAMIC_SECTION define.
	* elf-hppa.h, elf-m10300.c, elf32-cris.c, elf32-d10v.c, elf32-dlx.c,
	* elf32-fr30.c, elf32-frv.c, elf32-h8300.c, elf32-hppa.c, elf32-i386.c,
	* elf32-iq2000.c, elf32-m32r.c, elf32-m68hc1x.c, elf32-m68k.c,
	* elf32-mcore.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	* elf32-sh.c, elf32-sparc.c, elf32-v850.c, elf32-vax.c,
	* elf32-xstormy16.c, elf32-xtensa.c, elf64-alpha.c, elf64-hppa.c,
	* elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c, elf64-sparc.c,
	* elf64-x86-64.c, elfxx-ia64.c, elfxx-mips.c, elfxx-target.h: Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_final_link): Define.
	(bfd_elfNN_print_symbol): Define.
	* elfcode.h: Don't include elflink.h.
	(elf_bfd_discard_info, elf_reloc_symbol_deleted_p,
	elf_link_record_dynamic_symbol, elf_bfd_final_link, elf_gc_sections,
	elf_gc_common_finalize_got_offsets, elf_gc_common_final_link,
	elf_gc_record_vtinherit, elf_gc_record_vtentry,
	elf_link_record_local_dynamic_symbol): Don't define.
	* elflink.c: Update for changed function names.  Move elflink.h
	code here.
	* elflink.h: Delete file.
	* po/SRC-POTFILES.in: Regenerate.
	* po/bfd.pot: Regenerate.
doc/
	* bfdint.texi: Remove all mention of elflink.h.
@
text
@d3460 11
d3505 1
@


1.59
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d1348 1
a1348 1
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d1355 1
a1355 1
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
a1718 11
/* This is the condition under which elf_s390_finish_dynamic_symbol
   will be called from elflink.h.  If elflink.h doesn't call our
   finish_dynamic_symbol routine, we'll need to do something about
   initializing any .plt and .got entries in elf_s390_relocate_section.  */
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
  ((DYN)								\
   && ((SHARED)								\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) == 0)	\
   && ((H)->dynindx != -1						\
       || ((H)->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0))

d1754 1
a1754 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d1837 1
a1837 1
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
d1915 1
a1915 1
	      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
@


1.58
log
@	* elf-bfd.h (RELOC_FOR_GLOBAL_SYMBOL): Add input_bfd, input_section
	and rel args.  Group input and output args.  Wrap to 80 columns.
	* elf-m10200.c, elf-m10300.c, elf32-arm.h, elf32-avr.c,
	elf32-cris.c, elf32-d10v.c, elf32-fr30.c, elf32-h8300.c,
	elf32-hppa.c, elf32-i386.c, elf32-i860.c, elf32-ip2k.c,
	elf32-iq2000.c, elf32-m68hc1x.c, elf32-m68k.c, elf32-mcore.c,
	elf32-msp430.c, elf32-openrisc.c, elf32-ppc.c, elf32-s390.c,
	elf32-sparc.c, elf32-v850.c, elf32-vax.c, elf32-xstormy16.c,
	elf32-xtensa.c, elf64-alpha.c, elf64-mmix.c, elf64-ppc.c,
	elf64-s390.c, elf64-sparc.c, elf64-x86-64.c, elfxx-ia64.c: Update
	RELOC_FOR_GLOBAL_SYMBOL invocation.
@
text
@d2160 1
a2160 1
  bfd_elf32_add_dynamic_entry (info, (bfd_vma) (TAG), (bfd_vma) (VAL))
@


1.57
log
@	* elf32-s390.c (allocate_dynrelocs): Use SYMBOL_REFERENCES_LOCAL
	for pc relative relocs.
	(elf_s390_relocate_section): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Use SYMBOL_REFERENCES_LOCAL
	for pc relative relocs.
	(elf_s390_relocate_section): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d2325 4
a2328 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.56
log
@	* elf32-i386.c (elf_i386_object_p): Delete.
	(elf_backend_object_p): Don't define.
	* elf32-s390.c (elf_s390_object_p): No need to alloc tdata here.
	* elf32-sh.c (sh_elf_object_p): Likewise.
	* elf32-sparc.c (elf32_sparc_object_p): Likewise.
	* elf64-alpha.c (elf64_alpha_object_p): Likewise.
	* elf64-s390.c (elf_s390_object_p): Likewise.
	* elf64-x86-64.c (elf64_x86_64_elf_object_p): Likewise.
@
text
@d1887 1
a1887 3
      if ((h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
	  && ((h->elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	      || info->symbolic))
d2563 1
a2563 4
		       && h->dynindx != -1
		       && (! info->symbolic
			   || (h->elf_link_hash_flags
			       & ELF_LINK_HASH_DEF_REGULAR) == 0))))
@


1.56.6.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1348 1
a1348 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d1355 1
a1355 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1719 11
d1765 1
a1765 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1848 1
a1848 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1928 1
a1928 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
d2162 1
a2162 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2327 4
a2330 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
@


1.56.6.2
log
@Merge to 2.15 branch.
@
text
@d1876 3
a1878 1
      if (SYMBOL_REFERENCES_LOCAL (info, h))
d2554 4
a2557 1
		       && !SYMBOL_REFERENCES_LOCAL (info, h))))
@


1.56.8.1
log
@Merge mainline to intercu branch.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d1887 3
a1889 1
      if (SYMBOL_REFERENCES_LOCAL (info, h))
d2162 1
a2162 1
  _bfd_elf_add_dynamic_entry (info, TAG, VAL)
d2327 4
a2330 4
	  RELOC_FOR_GLOBAL_SYMBOL (info, input_bfd, input_section, rel,
				   r_symndx, symtab_hdr, sym_hashes,
				   h, sec, relocation,
				   unresolved_reloc, warned);
d2565 4
a2568 1
		       && !SYMBOL_REFERENCES_LOCAL (info, h))))
@


1.56.8.2
log
@Merge GDB mainline of 20040402 to intercu branch.
@
text
@d1348 1
a1348 1
	  if (!bfd_elf_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
d1355 1
a1355 1
	  if (!bfd_elf_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d1719 11
d1765 1
a1765 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1848 1
a1848 1
	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
d1926 1
a1926 1
	      if (! bfd_elf_link_record_dynamic_symbol (info, h))
@


1.56.8.3
log
@Merge mainline to intercu branch - 2004-09-15
@
text
@d414 1
a414 1
  if (reloc_entry->address > bfd_get_section_limit (abfd, input_section))
d983 3
a985 2
	  (*_bfd_error_handler) (_("%B: bad symbol index: %d"),
				 abfd, r_symndx);
d1161 2
a1162 2
		    (_("%B: `%s' accessed both as normal and thread local symbol"),
		     abfd, h->root.root.string);
d1272 2
a1273 2
			(_("%B: bad relocation section name `%s\'"),
			 abfd, name);
d1690 1
a1690 1
      htab->srelbss->size += sizeof (Elf32_External_Rela);
d1702 1
a1702 1
  s->size = BFD_ALIGN (s->size, (bfd_size_type) (1 << power_of_two));
d1711 1
a1711 1
  h->root.u.def.value = s->size;
d1714 1
a1714 1
  s->size += h->size;
d1765 2
a1766 2
	  if (s->size == 0)
	    s->size += PLT_FIRST_ENTRY_SIZE;
d1768 1
a1768 1
	  h->plt.offset = s->size;
d1783 1
a1783 1
	  s->size += PLT_ENTRY_SIZE;
d1787 1
a1787 1
	  htab->sgotplt->size += GOT_ENTRY_SIZE;
d1790 1
a1790 1
	  htab->srelplt->size += sizeof (Elf32_External_Rela);
d1820 2
a1821 2
	  h->got.offset = htab->sgot->size;
	  htab->sgot->size += GOT_ENTRY_SIZE;
d1842 2
a1843 2
      h->got.offset = s->size;
      s->size += GOT_ENTRY_SIZE;
d1846 1
a1846 1
	s->size += GOT_ENTRY_SIZE;
d1852 1
a1852 1
	htab->srelgot->size += sizeof (Elf32_External_Rela);
d1854 1
a1854 1
	htab->srelgot->size += 2 * sizeof (Elf32_External_Rela);
d1859 1
a1859 1
	htab->srelgot->size += sizeof (Elf32_External_Rela);
d1935 1
a1935 1
      sreloc->size += p->count * sizeof (Elf32_External_Rela);
d1998 1
a1998 1
	  s->size = sizeof ELF_DYNAMIC_INTERPRETER;
d2037 1
a2037 1
		  srela->size += p->count * sizeof (Elf32_External_Rela);
d2058 2
a2059 2
	      *local_got = s->size;
	      s->size += GOT_ENTRY_SIZE;
d2061 1
a2061 1
		s->size += GOT_ENTRY_SIZE;
d2063 1
a2063 1
		srela->size += sizeof (Elf32_External_Rela);
d2074 3
a2076 3
      htab->tls_ldm_got.offset = htab->sgot->size;
      htab->sgot->size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->size += sizeof (Elf32_External_Rela);
d2102 1
a2102 1
	  if (s->size != 0)
d2115 1
a2115 1
      if (s->size == 0)
d2136 1
a2136 1
      s->contents = (bfd_byte *) bfd_zalloc (dynobj, s->size);
d2157 1
a2157 1
      if (htab->splt->size != 0)
d2234 3
a2236 3
    (_("%B(%A+0x%lx): invalid instruction for TLS relocation %s"),
     input_bfd,
     input_section,
d2996 3
a2998 3
	  (_("%B(%A+0x%lx): unresolvable relocation against symbol `%s'"),
	   input_bfd,
	   input_section,
d3046 3
a3048 2
		(_("%B(%A+0x%lx): reloc against `%s': error %d"),
		 input_bfd, input_section,
d3333 1
a3333 1
      dynconend = (Elf32_External_Dyn *) (sdyn->contents + sdyn->size);
d3356 4
a3359 1
	      dyn.d_un.d_val = s->size;
d3367 1
a3367 1
      if (htab->splt && htab->splt->size > 0)
d3411 1
a3411 1
      if (htab->sgotplt->size > 0)
d3435 1
a3435 1
  unsigned int size;
d3451 1
a3451 1
	size = 144;
d3457 1
a3457 1
					  size, note->descpos + offset);
a3459 11
/* Return address for Ith PLT stub in section PLT, for relocation REL
   or (bfd_vma) -1 if it should not be included.  */

static bfd_vma
elf_s390_plt_sym_val (bfd_vma i, const asection *plt,
		      const arelent *rel ATTRIBUTE_UNUSED)
{
  return plt->vma + PLT_FIRST_ENTRY_SIZE + i * PLT_ENTRY_SIZE;
}


a3493 1
#define elf_backend_plt_sym_val		      elf_s390_plt_sym_val
@


1.56.8.4
log
@Merge from mainline.
@
text
@d902 9
a910 10
      && dir->dynamic_adjusted)
    {
      /* If called to transfer flags for a weakdef during processing
	 of elf_adjust_dynamic_symbol, don't copy non_got_ref.
	 We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
      dir->ref_dynamic |= ind->ref_dynamic;
      dir->ref_regular |= ind->ref_regular;
      dir->ref_regular_nonweak |= ind->ref_regular_nonweak;
      dir->needs_plt |= ind->needs_plt;
    }
d1071 1
a1071 1
	      h->needs_plt = 1;
d1092 1
a1092 1
	      h->needs_plt = 1;
d1201 1
a1201 1
	      h->non_got_ref = 1;
d1238 2
a1239 1
			   || !h->def_regular))))
d1245 2
a1246 1
		      || !h->def_regular)))
d1583 1
a1583 1
      || h->needs_plt)
d1587 2
a1588 2
	      && !h->def_dynamic
	      && !h->ref_dynamic
d1598 1
a1598 1
	  h->needs_plt = 0;
d1615 1
a1615 1
  if (h->u.weakdef != NULL)
d1617 4
a1620 4
      BFD_ASSERT (h->u.weakdef->root.type == bfd_link_hash_defined
		  || h->u.weakdef->root.type == bfd_link_hash_defweak);
      h->root.u.def.section = h->u.weakdef->root.u.def.section;
      h->root.u.def.value = h->u.weakdef->root.u.def.value;
d1622 3
a1624 1
	h->non_got_ref = h->u.weakdef->non_got_ref;
d1640 1
a1640 1
  if (!h->non_got_ref)
d1646 1
a1646 1
      h->non_got_ref = 0;
d1667 1
a1667 1
	  h->non_got_ref = 0;
d1690 1
a1690 1
      h->needs_copy = 1;
d1751 1
a1751 1
	  && !h->forced_local)
d1775 1
a1775 1
	      && !h->def_regular)
d1794 1
a1794 1
	  h->needs_plt = 0;
d1801 1
a1801 1
      h->needs_plt = 0;
d1834 1
a1834 1
	  && !h->forced_local)
d1902 3
a1904 3
      if (!h->non_got_ref
	  && ((h->def_dynamic
	       && !h->def_regular)
d1912 1
a1912 1
	      && !h->forced_local)
d2375 2
a2376 2
			  || h->forced_local)
		      && h->def_regular)
d2556 5
a2560 3
		  && !h->non_got_ref
		  && ((h->def_dynamic
		       && !h->def_regular)
d2596 2
a2597 1
			   || !h->def_regular))
d2993 1
a2993 1
	       && h->def_dynamic))
d3197 1
a3197 1
      if (!h->def_regular)
d3234 2
a3235 2
	      || h->forced_local)
	  && h->def_regular)
d3256 1
a3256 1
  if (h->needs_copy)
@


1.55
log
@	* elf32-arm.h: Fix comment typos.
	* elf32-d30v.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68hc11.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfn32-mips.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
@
text
@a687 8
  /* Allocate our special target data.  */
  struct elf_s390_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return FALSE;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
@


1.54
log
@	* elf32-s390.c (elf_s390_relocate_section): Don't recalculate symbol
	section for reloc output and subtract the output section's address
	from the addend when converting a relocation into one against a
	section symbol.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@d487 1
a487 1
   The code for position independand PLT entries looks like this:
@


1.53
log
@	* elf.c (_bfd_elf_link_hash_copy_indirect): Copy
	ELF_LINK_HASH_NEEDS_PLT.  Fix formatting.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf32-sh.c (sh_elf_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elf32-xtensa.c (elf_xtensa_copy_indirect_symbol): Remove.
	(elf_backend_copy_indirect_symbol): Don't define.
@
text
@d2630 1
a2634 1
		      outrel.r_addend = relocation + rel->r_addend;
d2640 1
a2640 10
		      if (h == NULL)
			sec = local_sections[r_symndx];
		      else
			{
			  BFD_ASSERT (h->root.type == bfd_link_hash_defined
				      || (h->root.type
					  == bfd_link_hash_defweak));
			  sec = h->root.u.def.section;
			}
		      if (sec != NULL && bfd_is_abs_section (sec))
d2654 8
a2663 1
		      outrel.r_addend = relocation + rel->r_addend;
@


1.52
log
@	* elf32-s390.c (elf_s390_relocate_section): Only convert R_390_32
	to R_390_RELAVITE. Convert the other relocations against local
	symbols to relocations against the start of the section.
	* elf64-s390.c (elf_s390_relocate_section): Only convert R_390_64
	to R_390_RELAVITE. Convert the other relocations against local
	symbols to relocations against the start of the section.
@
text
@d917 2
a918 1
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
@


1.51
log
@	* elf.c (_bfd_elf_rela_local_sym): Accept asection **, and return
	updated section in case of merged section.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Update declaration.
	* elf-hppa.h (elf_hppa_relocate_section): Adjust call.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-msp430.c (elf32_msp430_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section) Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf32-xtensa.c (elf_xtensa_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.

	* elf32-cris.c (cris_elf_relocate_section): Don't recalculate symbol
	section for reloc output.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.

	* elf32-ppc.c (ppc_elf_relocate_section): Don't recalculate everything
	for R_PPC_RELAX32 reloc.  Don't bother checking ppc_elf_install_value
	return value.
	* elf64-ppc.c (ppc64_elf_relocate_section <R_PPC64_TOC>): Sanity check
	sec->id.
@
text
@d2629 37
a2665 3
		  relocate = TRUE;
		  outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
		  outrel.r_addend = relocation + rel->r_addend;
@


1.50
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d2328 1
a2328 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, sec, rel);
@


1.49
log
@	* elf-bfd.h (struct elf_backend_data): Remove plt_header_size.
	* elf-m10300.c (elf_backend_plt_header_size): Don't define.
	* elf32-arm.h (elf_backend_plt_header_size): Don't define.
	* elf32-cris.c (elf_backend_plt_header_size): Don't define.
	* elf32-i386.c (elf_backend_plt_header_size): Don't define.
	* elf32-mips.c (elf_backend_plt_header_size): Don't define.
	* elf32-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf32-s390.c (elf_backend_plt_header_size): Don't define.
	* elf32-sh.c (elf_backend_plt_header_size): Don't define.
	* elf32-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-alpha.c (elf_backend_plt_header_size): Don't define.
	* elf64-hppa.c (elf_backend_plt_header_size): Don't define.
	* elf64-mips.c (elf_backend_plt_header_size): Don't define.
	* elf64-ppc.c (elf_backend_plt_header_size): Don't define.
	* elf64-s390.c (elf_backend_plt_header_size): Don't define.
	* elf64-sh64.c (elf_backend_plt_header_size): Don't define.
	* elf64-sparc.c (elf_backend_plt_header_size): Don't define.
	* elf64-x86-64.c (elf_backend_plt_header_size): Don't define.
	* elfn32-mips.c (elf_backend_plt_header_size): Don't define.
	* elfxx-ia64.c (elf_backend_plt_header_size): Don't define.
	* elfxx-target.h (elf_backend_plt_header_size): Don't define
	or include in target initializer.
@
text
@d2219 2
a2220 2
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
d2222 1
a2222 1
  return elf_hash_table (info)->tls_segment->start;
d2233 1
a2233 2
  struct elf_link_tls_segment *tls_segment
    = elf_hash_table (info)->tls_segment;
d2235 2
a2236 2
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (tls_segment == NULL)
d2238 1
a2238 2
  return (align_power (tls_segment->size, tls_segment->align)
	  + tls_segment->start - address);
@


1.48
log
@Better handking for unresolved symbols
@
text
@a3465 1
#define elf_backend_plt_header_size	PLT_ENTRY_SIZE
@


1.47
log
@	* elf32-i386.c (elf_i386_relocate_section): Make undefined symbols
	fatal if -pie.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	(ppc_elf_relocate_section) <case R_PPC_RELAX32>: Issue fatal error
	on undefined symbols if -pie.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
@
text
@d2334 1
a2334 4
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  while (h->root.type == bfd_link_hash_indirect
		 || h->root.type == bfd_link_hash_warning)
	    h = (struct elf_link_hash_entry *) h->root.u.i.link;
d2336 4
a2339 34
	  if (h->root.type == bfd_link_hash_defined
	      || h->root.type == bfd_link_hash_defweak)
	    {
	      sec = h->root.u.def.section;
	      if (sec->output_section == NULL)
		{
		  /* Set a flag that will be cleared later if we find a
		     relocation value for this symbol.  output_section
		     is typically NULL for symbols satisfied by a shared
		     library.  */
		  unresolved_reloc = TRUE;
		  relocation = 0;
		}
	      else
		relocation = (h->root.u.def.value
			      + sec->output_section->vma
			      + sec->output_offset);
	    }
	  else if (h->root.type == bfd_link_hash_undefweak)
	    relocation = 0;
	  else if (!info->executable
		   && !info->no_undefined
		   && ELF_ST_VISIBILITY (h->other) == STV_DEFAULT)
	    relocation = 0;
	  else
	    {
	      if (! ((*info->callbacks->undefined_symbol)
		     (info, h->root.root.string, input_bfd,
		      input_section, rel->r_offset,
		      (info->executable || info->no_undefined
		       || ELF_ST_VISIBILITY (h->other)))))
		return FALSE;
	      relocation = 0;
	    }
@


1.46
log
@	* elfxx-target.h: Remove PTR cast.
	* targets.c (bfd_target): Make backend_data const void *.
	* elf-bfd.h: Constify all occurrences of struct elf_backend_data.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-mips.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfcode.h: Likewise.
	* elfcore.h: Likewise.
	* elflink.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-mips.h: Likewise.
	* elf.c (prep_headers): Remove useless check for null backend_data.
	* bfd-in2.h: Regenerate.
@
text
@d2368 1
a2368 1
		      (!info->shared || info->no_undefined
@


1.45
log
@	* elf32-s390.c (elf_howto_table): Change R_390_GOT12 to
	complain_overflow_bitfield.
	* elf64-s390.c (elf_howto_table): Change R_390_GOT12 to
	complain_overflow_bitfield.
@
text
@d43 1
a43 1
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
d859 1
a859 1
     struct elf_backend_data *bed;
@


1.44
log
@bfd/
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add rel_fptr_sec.
	(elfNN_ia64_dynamic_symbol_p): Change info->shared into
	!info->executable.
	(get_fptr): For -pie create .opd as writable section and create
	.rela.opd as well.
	(elfNN_ia64_check_relocs): Change info->shared into
	!info->executable.
	(allocate_fptr): Likewise.
	(allocate_dynrel_entries): Account for a relative reloc for -pie
	@@fptr().  Don't account for a relative reloc if -pie want_ltoff_fptr
	for undefweak symbol.  Account for an IPLT reloc in .rela.opd
	section if -pie.
	(set_got_entry): Don't create a relative reloc if -pie
	want_ltoff_fptr for undefweak symbol.
	(set_fptr_entry): Emit an IPLT reloc in .rela.opd for -pie.
	(elfNN_ia64_relocate_section): Emit a relative reloc for -pie
	@@fptr().

	* elfxx-ia64.c (elfNN_ia64_relocate_section): Issue undefined_symbol
	even if -pie.
	* elf32-i386.c (elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
ld/
	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Don't include
	.opd if -pie.
	(OTHER_READWRITE_SECTIONS): Include .opd if -pie.
	* scripttempl/elf.sc: Use SHLIB_DATA_ADDR instead of DATA_ADDR
	if -pie.
@
text
@d124 1
a124 1
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont,
@


1.43
log
@        * elf32-s390.c (s390_elf_ldisp_reloc): New prototype.
        (s390_tls_reloc): New function.
        (elf_howto_table): Add long displacement relocations R_390_20,
        R_390_GOT20, R_390_GOTPLT20 and R_390_TLS_GOTIE20.
        (elf_s390_reloc_type_lookup): Likewise.
        (elf_s390_check_relocs): Likewise.
        (elf_s390_gc_sweep_hook): Likewise.
        (elf_s390_relocate_section): Likewise.
        * elf64-s390.c: Same changes as for elf32-s390.c.
        * reloc.c: Add long displacement relocations BFD_RELOC_390_20,
        BFD_RELOC_390_GOT20, BFD_RELOC_390_GOTPLT20 and
        BFD_RELOC_390_TLS_GOTIE20.
        * bfd-in2.h: Regenerate.
        * libbfd.h: Likewise.
@
text
@d2359 1
a2359 1
	  else if (info->shared
@


1.42
log
@Correct spelling of "relocatable".
@
text
@d91 2
d213 8
d326 8
d386 53
d1010 1
d1015 1
d1020 1
d1086 1
d1113 1
d1122 1
d1132 1
d1145 1
d1472 1
d1477 1
d1499 1
d1523 1
d2379 1
d2413 1
d2820 1
d3028 15
a3042 3
      r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				    contents, rel->r_offset,
				    relocation, rel->r_addend);
@


1.41
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d898 1
a898 1
  if (info->relocateable)
d2201 1
a2201 1
  if (info->relocateable)
@


1.40
log
@	* elf32-s390.c (allocate_dynrelocs, elf_s390_relocate_section):
	Fix WILL_CALL_FINISH_DYNAMIC_SYMBOL call.
	(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead of INFO.
	* elf64-s390.c: Likewise.
@
text
@d1930 1
a1930 1
      if (! info->shared)
d2088 1
a2088 1
      if (! info->shared)
@


1.39
log
@	* elf32-s390.c (ELIMINATE_COPY_RELOCS): Define as one.
	(elf_s390_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	(elf_s390_copy_indirect_symbol): Test whether the weakdef sym has
	already been adjusted before treating it specially.
	* el64-s390.c: Likwise.
@
text
@d1647 1
a1647 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, INFO, H) \
d1649 1
a1649 1
   && ((INFO)->shared							\
d1694 1
a1694 1
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d2342 1
a2342 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
@


1.38
log
@        * elf32-s390.c (allocate_dynrelocs): For undef weak syms with
	non-default visibility, a) don't make them dynamic, b) discard
	space for dynamic relocs.
	(elf_s390_relocate_section): Initialize the GOT entries and skip
	R_390_{8,16,32}/R_390_PC{16,16DBL,32DBL,32} for weak undefined
	symbols with non-default visibility.
	* elf64-s390.c: Likewise.
@
text
@d386 6
d837 12
a848 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1169 2
a1170 1
	      || (!info->shared
a1500 2
  struct elf_s390_link_hash_entry * eh;
  struct elf_s390_dyn_relocs *p;
d1546 4
d1575 1
a1575 2
  eh = (struct elf_s390_link_hash_entry *) h;
  for (p = eh->dyn_relocs; p != NULL; p = p->next)
d1577 10
a1586 4
      s = p->sec->output_section;
      if (s != NULL && (s->flags & SEC_READONLY) != 0)
	break;
    }
d1588 7
a1594 6
  /* If we didn't find any dynamic relocs in read-only sections, then
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
  if (p == NULL)
    {
      h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
      return TRUE;
d1834 1
a1834 1
  else
d2526 2
a2527 1
	      || (!info->shared
@


1.37
log
@	* elf32-hppa.c (elf32_hppa_gc_sweep_hook): Simplify dynamic reloc
	removal.  Localize vars.  Remove unnecessary dynobj test.
	* elf32-i386 (WILL_CALL_FINISH_DYNAMIC_SYMBOL): Pass SHARED instead
	of INFO.
	(allocate_dynrelocs): Adjust WILL_CALL_FINISH_DYNAMIC_SYMBOL uses,
	and optimize.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_gc_sweep_hook): Simplify dyn reloc removal.  Localize vars.
	* elf32-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_sweep_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_sweep_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_sweep_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_sweep_hook): Likewise.  Remove
	local_dynrel for section too.  Don't touch HIPLT22, LOPLT10, PCPLT32
	or PCPLT10 relocs.  Don't subtract twice on PLT32 relocs.
	Formatting.
@
text
@d1654 3
a1656 1
      && h->plt.refcount > 0)
d1667 2
a1668 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, info, h))
d1764 4
a1767 1
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d1801 6
d2321 3
a2323 1
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
d2488 3
@


1.37.16.1
log
@2003-05-18  Mark Kettenis  <kettenis@@gnu.org>

	Merge from mainline.
	* i386-tdep.h (I386_SIZEOF_GREGS, I386_SIZEOF_FREGS,
	I386_SIZEOF_XREGS): Remove defenitions.
	(IS_FP_REGNUM, IS_SSE_REGNUM): Remove definitions.
	* i386-tdep.c (i386_gdbarch_init): Don't set register_bytes,
	register_size, call_dummy_words and sizeof_call_dummy.
	* i386-linux-tdep.c (i386_linux_init_abi): Don't set register_bytes.
	* x86-64-tdep.c (x86_64_init_abi): Don't set register_bytes and
	register_size.
	(x86_64_register_bytes): Remove variable.
	(_initialize_x86_64_tdep): Remove function.

	* i386-linux-tdep.c (i386_linux_sigcontext_addr): Call read_memory
	with correct arguments.
	* config/i386/x86-64linux.mt (TDEPFILES): Add i386-linux-tdep.o.
@
text
@a385 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d831 1
a831 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1152 1
a1152 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1483 2
a1529 4
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1555 2
a1556 1
  if (ELIMINATE_COPY_RELOCS)
d1558 4
a1561 2
      struct elf_s390_link_hash_entry * eh;
      struct elf_s390_dyn_relocs *p;
d1563 6
a1568 15
      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1621 1
a1621 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d1623 1
a1623 1
   && ((SHARED)								\
d1654 1
a1654 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1665 1
a1665 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d1761 1
a1761 4
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
a1794 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1796 1
a1796 1
  else if (ELIMINATE_COPY_RELOCS)
d2304 1
a2304 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d2309 1
a2309 3
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
a2473 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d2483 1
a2483 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
@


1.37.18.1
log
@	Merge from mainline:

	2003-05-09  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* elf32-s390.c (ELIMINATE_COPY_RELOCS): Define as one.
	(elf_s390_adjust_dynamic_symbol): For weak symbols, copy
	ELF_LINK_NON_GOT_REF from weakdef.
	(elf_s390_copy_indirect_symbol): Test whether the weakdef sym has
	already been adjusted before treating it specially.
	* el64-s390.c: Likwise.

	2003-05-08  H.J. Lu <hongjiu.lu@@intel.com>
	* elflink.h (elf_add_default_symbol): After skipping the
	unversioned symbol, go to non-default one.

	2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>
	* elflink.h (elf_link_check_versioned_symbol): Also handle the
	case that a DSO references a hidden symbol which may be
	satisfied by a versioned symbol in another DSO.
	(elf_link_output_extsym): Check versioned definition for hidden
	symbol referenced by a DSO.

	2003-05-06  Alexandre Oliva  <aoliva@@redhat.com>
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Improve
	error message for mixing different-endian files.  Check for ABI
	compatibility of input files with the selected emulation.
@
text
@a385 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d831 1
a831 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1152 1
a1152 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1483 2
a1529 4
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1555 2
a1556 1
  if (ELIMINATE_COPY_RELOCS)
d1558 4
a1561 2
      struct elf_s390_link_hash_entry * eh;
      struct elf_s390_dyn_relocs *p;
d1563 6
a1568 15
      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1796 1
a1796 1
  else if (ELIMINATE_COPY_RELOCS)
d2483 1
a2483 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
@


1.36
log
@Fix the behaviour of --allow-shlib-undefined, so that it does what it claims
to do.  Add an inverse switch.  Update the documentation.
@
text
@d354 1
a354 1
                      output_bfd, error_message)
d938 1
a938 1
	      
d972 2
a973 2
        case R_390_PLT16DBL:
        case R_390_PLT32DBL:
d978 5
a982 5
             actually build the entry in adjust_dynamic_symbol,
             because this might be a case of linking PIC code which is
             never referenced by a dynamic object, in which case we
             don't need to generate a procedure linkage table entry
             after all.  */
d985 1
a985 1
             creating a procedure linkage table entry.  */
d1028 1
a1028 1
        case R_390_GOT16:
d1098 2
a1099 2
        case R_390_8:
        case R_390_16:
d1101 2
a1102 2
        case R_390_PC16:
        case R_390_PC16DBL:
d1257 4
a1260 4
        case R_390_GNU_VTINHERIT:
          if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
            return FALSE;
          break;
d1264 4
a1267 4
        case R_390_GNU_VTENTRY:
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
            return FALSE;
          break;
a1329 3
  unsigned long r_symndx;
  int r_type;
  struct elf_link_hash_entry *h;
d1340 4
d1345 8
d1354 8
a1361 4
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d1363 2
a1364 3
      r_type = elf_s390_tls_transition (info,
					ELF32_R_TYPE (rel->r_info),
					r_symndx >= symtab_hdr->sh_info);
d1395 1
a1395 8
	  if (r_type != R_390_TLS_IE32)
	    break;
	  /* Fall through.  */
	  
	case R_390_TLS_LE32:
	  if (!info->shared)
	    break;
	  /* Fall through.  */
d1405 4
a1408 27
	  if (h != NULL)
	    {
	      struct elf_s390_link_hash_entry *eh;
	      struct elf_s390_dyn_relocs **pp;
	      struct elf_s390_dyn_relocs *p;
	      
	      if (!info->shared && h->plt.refcount > 0)
		h->plt.refcount -= 1;
	      
	      eh = (struct elf_s390_link_hash_entry *) h;
	      
	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    if (ELF32_R_TYPE (rel->r_info) == R_390_PC16
			|| ELF32_R_TYPE (rel->r_info) == R_390_PC16DBL
			|| ELF32_R_TYPE (rel->r_info) == R_390_PC32DBL
			|| ELF32_R_TYPE (rel->r_info) == R_390_PC32)
		      p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;
	  
d1502 2
a1503 2
             file, but the symbol was never referred to by a dynamic
             object, or if all references were garbage collected.  In
d2066 4
a2069 4
        {
          if (!add_dynamic_entry (DT_RELA, 0)
              || !add_dynamic_entry (DT_RELASZ, 0)
              || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
d2189 2
a2190 2
          || r_type == (int) R_390_GNU_VTENTRY)
        continue;
d2246 1
a2246 1
          	      input_section, rel->r_offset,
d2277 1
a2277 1
	      
d2289 3
a2291 3
        case R_390_GOT12:
        case R_390_GOT16:
        case R_390_GOT32:
d2293 2
a2294 2
          /* Relocation is to the entry for this symbol in the global
             offset table.  */
d2298 2
a2299 2
          if (h != NULL)
            {
d2302 1
a2302 1
              off = h->got.offset;
d2304 3
a2306 3
              if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
                  || (info->shared
                      && (info->symbolic
d2309 18
a2326 18
                      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
                {
                  /* This is actually a static link, or it is a
                     -Bsymbolic link and the symbol is defined
                     locally, or the symbol was forced to be local
                     because of a version file.  We must initialize
                     this entry in the global offset table.  Since the
                     offset must always be a multiple of 2, we use the
                     least significant bit to record whether we have
                     initialized it already.

                     When doing a dynamic link, we create a .rel.got
                     relocation entry to initialize the value.  This
                     is done in the finish_dynamic_symbol routine.  */
                  if ((off & 1) != 0)
                    off &= ~1;
                  else
                    {
d2329 3
a2331 3
                      h->got.offset |= 1;
                    }
                }
d2334 3
a2336 3
            }
          else
            {
d2340 1
a2340 1
              off = local_got_offsets[r_symndx];
d2342 8
a2349 8
              /* The offset must always be a multiple of 4.  We use
                 the least significant bit to record whether we have
                 already generated the necessary reloc.  */
              if ((off & 1) != 0)
                off &= ~1;
              else
                {
                  bfd_put_32 (output_bfd, relocation,
d2352 4
a2355 4
                  if (info->shared)
                    {
                      asection *srelgot;
                      Elf_Internal_Rela outrel;
d2358 1
a2358 1
                      srelgot = htab->srelgot;
d2362 4
a2365 4
                      outrel.r_offset = (htab->sgot->output_section->vma
                                         + htab->sgot->output_offset
                                         + off);
                      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
d2369 2
a2370 2
                      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
                    }
d2372 3
a2374 3
                  local_got_offsets[r_symndx] |= 1;
                }
            }
d2389 1
a2389 1
          break;
d2392 11
a2402 11
        case R_390_GOTOFF32:
          /* Relocation is relative to the start of the global offset
             table.  */

          /* Note that sgot->output_offset is not involved in this
             calculation.  We always want the start of .got.  If we
             defined _GLOBAL_OFFSET_TABLE in a different way, as is
             permitted by the ABI, we might have to change this
             calculation.  */
          relocation -= htab->sgot->output_section->vma;
          break;
d2404 1
a2404 1
        case R_390_GOTPC:
d2406 2
a2407 2
          /* Use global offset table as symbol value.  */
          relocation = htab->sgot->output_section->vma;
d2409 1
a2409 1
          break;
d2411 10
a2420 10
        case R_390_PLT16DBL:
        case R_390_PLT32DBL:
        case R_390_PLT32:
          /* Relocation is to the entry for this symbol in the
             procedure linkage table.  */

          /* Resolve a PLT32 reloc against a local symbol directly,
             without using the procedure linkage table.  */
          if (h == NULL)
            break;
d2422 1
a2422 1
          if (h->plt.offset == (bfd_vma) -1
d2424 10
a2433 10
            {
              /* We didn't make a PLT entry for this symbol.  This
                 happens when statically linking PIC code, or when
                 using -Bsymbolic.  */
              break;
            }

          relocation = (htab->splt->output_section->vma
                        + htab->splt->output_offset
                        + h->plt.offset);
d2435 1
a2435 1
          break;
d2439 2
a2440 2
          /* Relocation is to the entry for this symbol in the
             procedure linkage table relative to the start of the GOT.  */
d2444 1
a2444 1
          if (   h == NULL
d2452 3
a2454 3
          relocation = (htab->splt->output_section->vma
                        + htab->splt->output_offset
                        + h->plt.offset
d2457 1
a2457 1
          break;
d2459 7
a2465 7
        case R_390_8:
        case R_390_16:
        case R_390_32:
        case R_390_PC16:
        case R_390_PC16DBL:
        case R_390_PC32DBL:
        case R_390_PC32:
d2469 2
a2470 2
          if (r_symndx == 0
              || (input_section->flags & SEC_ALLOC) == 0)
d2473 1
a2473 1
          if ((info->shared
d2493 3
a2495 3
            {
              Elf_Internal_Rela outrel;
              bfd_boolean skip, relocate;
d2503 2
a2504 2
              skip = FALSE;
              relocate = FALSE;
d2513 2
a2514 2
              outrel.r_offset += (input_section->output_section->vma
                                  + input_section->output_offset);
d2516 1
a2516 1
              if (skip)
d2518 1
a2518 1
              else if (h != NULL
d2528 2
a2529 2
                {
                  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
d2531 3
a2533 3
                }
              else
                {
d2538 1
a2538 1
                }
d2548 7
a2554 7
              /* If this reloc is against an external symbol, we do
                 not want to fiddle with the addend.  Otherwise, we
                 need to include the symbol value so that it becomes
                 an addend for the dynamic reloc.  */
              if (! relocate)
                continue;
            }
d2620 1
a2620 1
          else
d2651 1
a2651 1
	    	      BFD_ASSERT (! unresolved_reloc);
d2755 1
a2755 1
	  unresolved_reloc = FALSE;	  
d2965 1
a2965 1
         it up.  */
d2973 1
a2973 1
         Current offset - size first entry / entry size.  */
d2977 1
a2977 1
         addr & GOT addr.  */
d2982 1
a2982 1
                           (PLT_ENTRY_SIZE * plt_index) + 18) / 2);
d2984 1
a2984 1
         390 can only handle +-64 K jumps.  */
d2986 2
a2987 2
          relative_offset =
	    -(unsigned) (((65536 / PLT_ENTRY_SIZE - 1) * PLT_ENTRY_SIZE) / 2);
d2992 1
a2992 1
          bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD0,
d3063 1
a3063 1
                  htab->splt->contents + h->plt.offset + 28);
d3066 1
a3066 1
         Points to instruction after GOT offset.  */
d3103 1
a3103 1
         up.  */
d3126 3
a3128 3
                           + h->root.u.def.section->output_section->vma
                           + h->root.u.def.section->output_offset);
        }
d3134 2
a3135 2
          rela.r_addend = 0;
        }
d3253 2
a3254 2
          memset (htab->splt->contents, 0, PLT_FIRST_ENTRY_SIZE);
          if (info->shared)
d3257 1
a3257 1
		          htab->splt->contents );
d3259 1
a3259 1
		          htab->splt->contents +4 );
d3261 1
a3261 1
		          htab->splt->contents +8 );
d3263 1
a3263 1
		          htab->splt->contents +12 );
d3265 18
a3282 18
		          htab->splt->contents +16 );
           }
          else
           {
              bfd_put_32 (output_bfd, (bfd_vma)PLT_FIRST_ENTRY_WORD0,
                          htab->splt->contents );
              bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD1,
                          htab->splt->contents +4 );
              bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD2,
                          htab->splt->contents +8 );
              bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD3,
                          htab->splt->contents +12 );
              bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD4,
                          htab->splt->contents +16 );
              bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD5,
                          htab->splt->contents +20 );
              bfd_put_32 (output_bfd,
                          htab->sgotplt->output_section->vma
d3284 2
a3285 2
                          htab->splt->contents + 24);
           }
d3360 1
a3360 1
#define elf_info_to_howto                     elf_s390_info_to_howto
d3367 1
a3367 1
#define elf_backend_check_relocs              elf_s390_check_relocs
d3372 2
a3373 2
#define elf_backend_gc_mark_hook              elf_s390_gc_mark_hook
#define elf_backend_gc_sweep_hook             elf_s390_gc_sweep_hook
d3375 1
a3375 1
#define elf_backend_relocate_section          elf_s390_relocate_section
d3381 1
a3381 1
#define elf_backend_object_p            elf_s390_object_p
@


1.35
log
@	* elf32-s390.c (elf_s390_size_dynamic_sections): Set relocs to TRUE
	even if there is just non-empty .rela.plt.
@
text
@d1025 1
a1025 1
	  /* Fall through */
d1090 1
a1090 1
	  /* Fall through */
d1096 1
a1096 1
	  /* Fall through */	    
d1219 1
a1220 1
		  asection *s;
d1234 1
d1385 1
a1385 1
	  /* Fall through */
d1390 1
a1390 1
	  /* Fall through */
d1851 1
a2256 1
		   && (!info->symbolic || info->allow_shlib_undefined)
d2399 4
a2402 6
	  /*
	   * For @@GOTENT the relocation is against the offset between
	   * the instruction and the symbols entry in the GOT and not
	   * between the start of the GOT and the symbols entry. We
	   * add the vma of the GOT to get the correct value.
	   */
d2594 1
a2594 1
	  /* Fall through */
a2983 1

@


1.34
log
@	* bfd-in2.h: Regenerate.
	* elf32-s390.c (elf_s390_mkobject, elf_s390_tls_transition,
	s390_tls_reloc, dtpoff_base, tpoff, invalid_tls_insn): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_s390_reloc_type_lookup): Likewise.
	(elf_s390_link_hash_entry): Add tls_type.
	(elf_s390_hash_entry, elf_s390_obj_tdata, elf_s390_local_got_tls_type):
	New macros.
	(elf_s390_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Initialize tls_type.
	(elf_s390_link_hash_table_create): Initialize refcount of tls_ldm_got.
	(elf_s390_copy_indirect_symbol): Copy tls_type information.
	(elf_s390_check_relocs): Support TLS relocs.
	(elf_s390_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_s390_size_dynamic_sections): Likewise.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject): Define for TLS.
	* elf64-s390.c: Same changes as for elf32-s390.c.
	* libbfd.h: Regenerate.
	* reloc.c: Add s390 TLS relocations.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d2017 1
a2017 1
	  if (s->_raw_size != 0 && s != htab->srelplt)
@


1.33
log
@	* bfd-in2.h: Regenerate.
	* elf32-s390.c (elf_s390_adjust_gotplt): New prototype.
	(elf_howto_table): Rename R_390_GOTOFF to R_390_GOTOFF32. Add
	R_390_GOTOFF16, R_390_GOTOFF64, R_390_GOTPLT12, R_390_GOTPLT16,
	R_390_GOTPLT32, R_390_GOTPLT64, R_390_GOTPLTENT, R_390_PLTOFF16,
	R_390_PLTOFF32 and R_390_PLTOFF64.
	(elf_s390_reloc_type_lookup): Likewise.
	(struct elf_s390_link_hash_entry): Add gotplt_refcount to keep track
	of GOTPLT references to a function.
	(link_hash_newfunc): Initialize gotplt_refcount.
	(elf_s390_check_relocs): Move allocation of local_got_refcounts array
	and creation of the got section out of the main switch. Add support
	for the gotoff, gotplt and pltoff relocations.
	(elf_s390_gc_sweep_hook): Add reference counting for gotoff, gotplt
	and pltoff.
	(elf_s390_adjust_gotplt): New function.
	(elf_s390_adjust_dynamic_symbol): Adjust gotplt refcount for removed
	plt entries.
	(allocate_dynrelocs): Add comment.
	(elf_s390_relocate_section): Change r_type to unsigned. Add support
	for gotoff, gotplt and pltoff relocations.
	* elf64-s390.c: Same changes as for elf32-s390.c.
	* libbfd.h: Regenerate.
	* reloc.c: Add BFD_RELOC_390_GOTOFF64, BFD_RELOC_390_GOTPLT12,
	BFD_RELOC_390_GOTPLT16, BFD_RELOC_390_GOTPLT32, BFD_RELOC_390_GOTPLT64,
	BFD_RELOC_390_GOTPLTENT, BFD_RELOC_390_PLTOFF16, BFD_RELOC_390_PLTOFF32
	and BFD_RELOC_390_PLTOFF64.
@
text
@d75 2
d81 10
d177 34
d288 28
d351 17
d570 7
d579 44
d638 5
d679 1
d711 1
d824 7
d834 27
d879 1
d894 1
d915 4
a918 1
      switch (ELF32_R_TYPE (rel->r_info))
d928 6
d940 1
a940 1
	      size *= sizeof (bfd_signed_vma);
d946 2
d963 1
a963 1
      switch (ELF32_R_TYPE (rel->r_info))
a964 11
	case R_390_GOT12:
        case R_390_GOT16:
	case R_390_GOT32:
	case R_390_GOTENT:
	  /* This symbol requires a global offset table entry.  */
	  if (h != NULL)
	    h->got.refcount += 1;
	  else
	    local_got_refcounts[r_symndx] += 1;
	  break;

d1015 83
d1330 1
d1349 4
a1352 1
      switch (ELF32_R_TYPE (rel->r_info))
d1354 10
d1382 3
a1384 1
	  break;
d1386 4
a1389 30
	case R_390_PLT16DBL:
	case R_390_PLT32DBL:
	case R_390_PLT32:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;

	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		{
		  ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount--;
		  h->plt.refcount -= 1;
		}
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d1426 31
d1729 22
a1750 2
  if (h->got.refcount > 0)
    {
d1753 1
d1767 3
d1771 8
a1778 1
      if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
d1924 1
d1966 1
d1969 1
a1969 1
      for (; local_got < end_local_got; ++local_got)
d1975 2
d1985 11
d2106 52
d2201 1
d2576 324
d3114 4
a3117 1
  if (h->got.offset != (bfd_vma) -1)
a3333 7
elf_s390_object_p (abfd)
     bfd *abfd;
{
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_31);
}

static bfd_boolean
d3400 1
@


1.32
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d54 3
d100 65
a164 22
  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_8",       FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_12",      FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_16",      FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_32",      FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32",    FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_GOT12",   FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT32",   FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32",   FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_COPY,      0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_COPY",    FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GLOB_DAT",FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_JMP_SLOT",FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_RELATIVE,  0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_RELATIVE",FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTOFF,    0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTOFF",  FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTPC,     0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPC",   FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT16",   FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16",    FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16DBL", FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32DBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,0xffffffff,  TRUE),
d209 1
a209 1
      return &elf_howto_table[(int) R_390_GOTOFF];
d228 14
d476 3
d531 1
d695 1
d703 1
d728 2
d733 1
a733 1
        case R_390_GOT16:
d736 6
a741 2
	  /* This symbol requires a global offset table entry.  */
	  if (h != NULL)
d743 6
a748 8
	      h->got.refcount += 1;
	    }
	  else
	    {
	      bfd_signed_vma *local_got_refcounts;

     	      /* This is a global offset table entry for a local symbol.  */
	      local_got_refcounts = elf_local_got_refcounts (abfd);
d750 2
a751 12
		{
		  bfd_size_type size;

		  size = symtab_hdr->sh_info;
		  size *= sizeof (bfd_signed_vma);
		  local_got_refcounts = ((bfd_signed_vma *)
					 bfd_zalloc (abfd, size));
		  if (local_got_refcounts == NULL)
		    return FALSE;
		  elf_local_got_refcounts (abfd) = local_got_refcounts;
		}
	      local_got_refcounts[r_symndx] += 1;
d753 3
a755 3
	  /* Fall through */

	case R_390_GOTOFF:
d765 20
d790 2
d801 6
a806 2
	  if (h == NULL)
	    continue;
d808 20
a827 2
	  h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	  h->plt.refcount += 1;
d1072 2
a1073 22
    switch (ELF32_R_TYPE (rel->r_info))
      {
      case R_390_GOT12:
      case R_390_GOT16:
      case R_390_GOT32:
      case R_390_GOTOFF:
      case R_390_GOTPC:
      case R_390_GOTPCDBL:
      case R_390_GOTENT:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->got.refcount > 0)
	      h->got.refcount -= 1;
	  }
	else if (local_got_refcounts != NULL)
	  {
	    if (local_got_refcounts[r_symndx] > 0)
	      local_got_refcounts[r_symndx] -= 1;
	  }
	break;
d1075 4
a1078 16
      case R_390_8:
      case R_390_12:
      case R_390_16:
      case R_390_32:
      case R_390_PC16:
      case R_390_PC16DBL:
      case R_390_PC32DBL:
      case R_390_PC32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    struct elf_s390_link_hash_entry *eh;
	    struct elf_s390_dyn_relocs **pp;
	    struct elf_s390_dyn_relocs *p;

	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d1080 33
a1112 2
	    if (!info->shared && h->plt.refcount > 0)
	      h->plt.refcount -= 1;
d1114 7
a1120 4
	    eh = (struct elf_s390_link_hash_entry *) h;

	    for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	      if (p->sec == sec)
d1122 2
a1123 9
		  if (ELF32_R_TYPE (rel->r_info) == R_390_PC16
		      || ELF32_R_TYPE (rel->r_info) == R_390_PC16DBL
		      || ELF32_R_TYPE (rel->r_info) == R_390_PC32DBL
		      || ELF32_R_TYPE (rel->r_info) == R_390_PC32)
		    p->pc_count -= 1;
		  p->count -= 1;
		  if (p->count == 0)
		    *pp = p->next;
		  break;
d1125 57
a1181 2
	  }
	break;
d1183 6
a1188 11
      case R_390_PLT16DBL:
      case R_390_PLT32DBL:
      case R_390_PLT32:
	r_symndx = ELF32_R_SYM (rel->r_info);
	if (r_symndx >= symtab_hdr->sh_info)
	  {
	    h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	    if (h->plt.refcount > 0)
	      h->plt.refcount -= 1;
	  }
	break;
d1190 2
a1191 3
      default:
	break;
      }
d1193 4
a1196 1
  return TRUE;
d1236 1
d1373 3
d1430 1
d1437 1
d1804 1
a1804 1
      int r_type;
d1819 1
a1819 1
      if (r_type < 0 || r_type >= (int) R_390_max)
d1827 2
d1885 33
d2016 2
a2017 1
	  if (r_type == R_390_GOTENT)
d2022 2
a2023 1
        case R_390_GOTOFF:
d2065 22
@


1.31
log
@include/elf/ChangeLog
	* internal.h (elf32_internal_ehdr, Elf32_Internal_Ehdr,
	elf64_internal_ehdr, Elf64_Internal_Ehdr, elf32_internal_phdr,
	Elf32_Internal_Phdr, elf64_internal_phdr, Elf64_Internal_Phdr,
	elf32_internal_shdr, Elf32_Internal_Shdr, elf64_internal_shdr,
	Elf64_Internal_Shdr, elf32_internal_sym, elf64_internal_sym,
	Elf32_Internal_Sym, Elf64_Internal_Sym, Elf32_Internal_Note,
	elf32_internal_note, elf32_internal_rel, Elf32_Internal_Rel,
	elf64_internal_rel, Elf64_Internal_Rel, elf32_internal_rela,
	elf64_internal_rela, Elf32_Internal_Rela, Elf64_Internal_Rela,
	elf32_internal_dyn, elf64_internal_dyn, Elf32_Internal_Dyn,
	Elf64_Internal_Dyn, elf32_internal_verdef, elf64_internal_verdef,
	elf32_internal_verdaux, elf64_internal_verdaux, elf32_internal_verneed,
	elf64_internal_verneed, elf32_internal_vernaux, elf64_internal_vernaux,
	elf32_internal_versym, elf64_internal_versym, Elf32_Internal_Verdef,
	Elf64_Internal_Verdef, Elf32_Internal_Verdaux, Elf64_Internal_Verdaux,
	Elf32_Internal_Verneed, Elf64_Internal_Verneed, Elf32_Internal_Vernaux,
	Elf64_Internal_Vernaux, Elf32_Internal_Versym, Elf64_Internal_Versym,
	Elf32_Internal_Syminfo, Elf64_Internal_Syminfo): Delete.
	(Elf_Internal_Rel): Delete.

bfd/ChangeLog
	* elf-bfd.h: Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.  Replace Elf_Internal_Rel
	with Elf_Internal_Rela.
	* elf-hppa.h, elf-m10200.c, elf-m10300.c, elf32-arc.c, elf32-arm.h,
	elf32-avr.c, elf32-cris.c, elf32-d10v.c, elf32-d30v.c, elf32-dlx.c,
	elf32-fr30.c, elf32-frv.c, elf32-gen.c, elf32-h8300.c, elf32-hppa.c,
	elf32-i370.c, elf32-i386.c, elf32-i860.c, elf32-i960.c, elf32-ip2k.c,
	elf32-m32r.c, elf32-m68hc11.c, elf32-m68hc12.c, elf32-m68k.c,
	elf32-mcore.c, elf32-mips.c, elf32-openrisc.c, elf32-or32.c,
	elf32-ppc.c, elf32-s390.c, elf32-sh.c, elf32-v850.c, elf32-vax.c,
	elf32-xstormy16.c, elf64-alpha.c, elf64-gen.c, elf64-hppa.c,
	elf64-mips.c, elf64-mmix.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c, elfarm-nabi.c, elfarm-oabi.c,
	elfcode.h, elflink.h, elfn32-mips.c, elfxx-ia64.c, elfxx-mips.c: Ditto.
	* elf-hppa.h (elf_hppa_internal_shdr): Delete.  Use Elf_Internal_Shdr
	throughout instead.
	* elf.c (_bfd_elf_no_info_to_howto_rel): Delete.
	* elfcode.h (elf_swap_reloca_in): Pass source operand as a bfd_byte *.
	Remove INLINE keyword.
	(elf_swap_reloc_in): Likewise.  Also clear r_addend.
	(elf_swap_reloc_out, elf_swap_reloca_out): Pass destination operand
	as a bfd_byte *.
	(elf_write_relocs): Consolidate REL and RELA code.
	(elf_slurp_reloc_table_from_section): Simplify REL code.
	(NAME(_bfd_elf,size_info)): Populate reloc swap entries.
	* elf-bfd.h (MAX_INT_RELS_PER_EXT_REL): Define.
	* elflink.h (elf_link_read_relocs_from_section): Consolidate REL and
	RELA code.
	(elf_link_adjust_relocs): Likewise.  Don't malloc space for temp
	reloc array, use a fixed size of MAX_INT_RELS_PER_EXT_REL.
	(elf_link_output_relocs): Likewise.
	(elf_reloc_link_order): Likewise.
	(elf_finish_pointer_linker_section): Likewise.
	(struct elf_link_sort_rela): Remove union.
	(elf_link_sort_cmp1): Update to suit.
	(elf_link_sort_cmp2): Here too.
	(elf_link_sort_relocs): Consolidate REL and RELA code.  Fix memory
	over-allocation for int_rels_per_ext_rel != 1 case.
	* elf32-arm.h: Update all bfd_elf32_swap_reloc_out calls.
	* elf32-i386.c: Likewise.
	* elf32-cris.c: Likewise for bfd_elf32_swap_reloca_out.
	* elf32-hppa.c, elf32-i370.c, elf32-m68k.c, elf32-ppc.c, elf32-s390.c,
	elf32-sh.c, elf32-vax.c, elfxx-mips.c: Likewise.
	* elf64-alpha.c: Likewise for bfd_elf64_swap_reloca_out.
	* elf64-hppa.c, elf64-mips.c, elf64-ppc.c, elf64-s390.c, elf64-sh64.c,
	elf64-sparc.c, elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise for bfd_elfNN_swap_reloca_out.
	* elfxx-mips.c (sort_dynamic_relocs): Likewise for
	bfd_elf32_swap_reloc_in.

	* elf32-arm.h: Update elf32_arm_info_to_howto calls.
	* elf32-mips.c: Likewise for mips_info_to_howto_rel.
	(mips_elf64_swap_reloc_in): Zero r_addend.
	(mips_elf64_be_swap_reloc_in): Likewise.
	(mips_elf64_slurp_one_reloc_table): Simplify.

	* elf64-alpha.c (alpha_elf_size_info): Populate reloc swap entries.
	* elf64-hppa.c (hppa64_elf_size_info): Likewise.
	* elf64-sparc.c (sparc64_elf_size_info): Likewise.
@
text
@d32 1
a32 1
static boolean elf_s390_is_local_label_name
d38 1
a38 1
static boolean create_got_section
d40 1
a40 1
static boolean elf_s390_create_dynamic_sections
d45 1
a45 1
static boolean elf_s390_check_relocs
d51 1
a51 1
static boolean elf_s390_gc_sweep_hook
d54 1
a54 1
static boolean elf_s390_adjust_dynamic_symbol
d56 1
a56 1
static boolean allocate_dynrelocs
d58 1
a58 1
static boolean readonly_dynrelocs
d60 1
a60 1
static boolean elf_s390_size_dynamic_sections
d62 1
a62 1
static boolean elf_s390_relocate_section
d65 1
a65 1
static boolean elf_s390_finish_dynamic_symbol
d70 1
a70 1
static boolean elf_s390_finish_dynamic_sections
d72 4
a75 2
static boolean elf_s390_object_p PARAMS ((bfd *));
static boolean elf_s390_grok_prstatus PARAMS ((bfd *, Elf_Internal_Note *));
d87 1
a87 1
	 false,			/* pc_relative */
d92 1
a92 1
	 false,			/* partial_inplace */
d95 1
a95 1
	 false),		/* pcrel_offset */
d97 22
a118 22
  HOWTO(R_390_8,         0, 0,  8, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_8",       false, 0,0x000000ff, false),
  HOWTO(R_390_12,        0, 1, 12, false, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_12",      false, 0,0x00000fff, false),
  HOWTO(R_390_16,        0, 1, 16, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_16",      false, 0,0x0000ffff, false),
  HOWTO(R_390_32,        0, 2, 32, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_32",      false, 0,0xffffffff, false),
  HOWTO(R_390_PC32,	 0, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32",    false, 0,0xffffffff,  true),
  HOWTO(R_390_GOT12,	 0, 1, 12, false, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_GOT12",   false, 0,0x00000fff, false),
  HOWTO(R_390_GOT32,	 0, 2, 32, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT32",   false, 0,0xffffffff, false),
  HOWTO(R_390_PLT32,	 0, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32",   false, 0,0xffffffff,  true),
  HOWTO(R_390_COPY,      0, 2, 32, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_COPY",    false, 0,0xffffffff, false),
  HOWTO(R_390_GLOB_DAT,  0, 2, 32, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GLOB_DAT",false, 0,0xffffffff, false),
  HOWTO(R_390_JMP_SLOT,  0, 2, 32, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_JMP_SLOT",false, 0,0xffffffff, false),
  HOWTO(R_390_RELATIVE,  0, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_RELATIVE",false, 0,0xffffffff, false),
  HOWTO(R_390_GOTOFF,    0, 2, 32, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTOFF",  false, 0,0xffffffff, false),
  HOWTO(R_390_GOTPC,     0, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPC",   false, 0,0xffffffff,  true),
  HOWTO(R_390_GOT16,     0, 1, 16, false, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT16",   false, 0,0x0000ffff, false),
  HOWTO(R_390_PC16,      0, 1, 16,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16",    false, 0,0x0000ffff,  true),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16DBL", false, 0,0x0000ffff,  true),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT16DBL", false, 0,0x0000ffff,  true),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32DBL", false, 0,0xffffffff,  true),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32DBL", false, 0,0xffffffff,  true),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPCDBL", false, 0,0xffffffff,  true),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTENT",   false, 0,0xffffffff,  true),
d123 1
a123 1
  HOWTO (R_390_GNU_VTINHERIT, 0,2,0,false,0,complain_overflow_dont, NULL, "R_390_GNU_VTINHERIT", false,0, 0, false);
d125 1
a125 1
  HOWTO (R_390_GNU_VTENTRY, 0,2,0,false,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", false,0,0, false);
d217 1
a217 1
static boolean
d223 1
a223 1
    return true;
d507 1
a507 1
static boolean
d515 1
a515 1
    return false;
d530 2
a531 2
    return false;
  return true;
d538 1
a538 1
static boolean
d547 1
a547 1
    return false;
d550 1
a550 1
    return false;
d562 1
a562 1
  return true;
d618 1
a618 1
static boolean
d633 1
a633 1
    return true;
d654 1
a654 1
	  return false;
d688 1
a688 1
		    return false;
d703 1
a703 1
		return false;
d803 1
a803 1
		    return false;
d831 1
a831 1
			return false;
d852 1
a852 1
		    return false;
d865 1
a865 1
		    return false;
d886 1
a886 1
            return false;
d893 1
a893 1
            return false;
d901 1
a901 1
  return true;
d946 1
a946 1
static boolean
d1045 1
a1045 1
  return true;
d1054 1
a1054 1
static boolean
d1087 1
a1087 1
      return true;
d1106 1
a1106 1
      return true;
d1117 1
a1117 1
    return true;
d1122 1
a1122 1
    return true;
d1128 1
a1128 1
      return true;
d1144 1
a1144 1
      return true;
d1180 1
a1180 1
	return false;
d1190 1
a1190 1
  return true;
d1207 1
a1207 1
static boolean
d1218 1
a1218 1
    return true;
d1235 1
a1235 1
	    return false;
d1286 1
a1286 1
      boolean dyn;
d1294 1
a1294 1
	    return false;
d1309 1
a1309 1
    return true;
d1355 1
a1355 1
		return false;
d1376 1
a1376 1
  return true;
d1381 1
a1381 1
static boolean
d1404 1
a1404 1
	  return false;
d1407 1
a1407 1
  return true;
d1412 1
a1412 1
static boolean
d1420 1
a1420 1
  boolean relocs;
d1510 1
a1510 1
  relocs = false;
d1526 1
a1526 1
	    relocs = true;
d1561 1
a1561 1
	return false;
d1577 1
a1577 1
	    return false;
d1586 1
a1586 1
	    return false;
d1594 1
a1594 1
	    return false;
d1605 1
a1605 1
		return false;
d1611 1
a1611 1
  return true;
d1616 1
a1616 1
static boolean
d1636 1
a1636 1
    return true;
d1655 1
a1655 1
      boolean unresolved_reloc;
d1665 1
a1665 1
	  return false;
d1673 1
a1673 1
      unresolved_reloc = false;
d1697 1
a1697 1
		  unresolved_reloc = true;
d1719 1
a1719 1
		return false;
d1737 1
a1737 1
	      boolean dyn;
d1770 1
a1770 1
		unresolved_reloc = false;
d1845 1
a1845 1
	  unresolved_reloc = false;
d1871 1
a1871 1
	  unresolved_reloc = false;
d1910 1
a1910 1
              boolean skip, relocate;
d1918 2
a1919 2
              skip = false;
              relocate = false;
d1925 1
a1925 1
		skip = true;
d1927 1
a1927 1
		skip = true, relocate = true;
d1950 1
a1950 1
		  relocate = true;
d2005 1
a2005 1
		return false;
d2016 1
a2016 1
		return false;
d2025 1
a2025 1
	      return false;
d2030 1
a2030 1
  return true;
d2036 1
a2036 1
static boolean
d2260 1
a2260 1
  return true;
d2285 1
a2285 1
static boolean
d2399 1
a2399 1
  return true;
d2402 1
a2402 1
static boolean
d2409 1
a2409 1
static boolean
d2420 1
a2420 1
	return false;
@


1.30
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d1791 1
a1791 1
		      Elf32_External_Rela *loc;
d1802 2
a1803 2
		      loc = (Elf32_External_Rela *) srelgot->contents;
		      loc += srelgot->reloc_count++;
d1910 1
a1910 1
	      Elf32_External_Rela *loc;
d1957 2
a1958 2
	      loc = (Elf32_External_Rela *) sreloc->contents;
	      loc += sreloc->reloc_count++;
d2050 1
a2050 1
      Elf32_External_Rela *loc;
d2170 1
a2170 1
      loc = (Elf32_External_Rela *) htab->srelplt->contents + plt_index;
d2187 1
a2187 1
      Elf32_External_Rela *loc;
d2224 2
a2225 2
      loc = (Elf32_External_Rela *) htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++;
d2232 1
a2232 1
      Elf32_External_Rela *loc;
d2247 2
a2248 2
      loc = (Elf32_External_Rela *) htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++;
@


1.30.12.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d32 1
a32 1
static bfd_boolean elf_s390_is_local_label_name
d38 1
a38 1
static bfd_boolean create_got_section
d40 1
a40 1
static bfd_boolean elf_s390_create_dynamic_sections
d43 1
a43 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d45 1
a45 1
static bfd_boolean elf_s390_check_relocs
d51 1
a51 1
static bfd_boolean elf_s390_gc_sweep_hook
d54 1
a54 4
struct elf_s390_link_hash_entry;
static void elf_s390_adjust_gotplt
  PARAMS ((struct elf_s390_link_hash_entry *));
static bfd_boolean elf_s390_adjust_dynamic_symbol
d56 1
a56 1
static bfd_boolean allocate_dynrelocs
d58 1
a58 1
static bfd_boolean readonly_dynrelocs
d60 1
a60 1
static bfd_boolean elf_s390_size_dynamic_sections
d62 1
a62 1
static bfd_boolean elf_s390_relocate_section
d65 1
a65 1
static bfd_boolean elf_s390_finish_dynamic_symbol
d70 1
a70 1
static bfd_boolean elf_s390_finish_dynamic_sections
d72 2
a73 18
static bfd_boolean elf_s390_mkobject
  PARAMS ((bfd *));
static bfd_boolean elf_s390_object_p
  PARAMS ((bfd *));
static bfd_boolean elf_s390_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
static int elf_s390_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));
static bfd_reloc_status_type s390_tls_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
static void invalid_tls_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *));
static bfd_reloc_status_type s390_elf_ldisp_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d85 1
a85 1
	 FALSE,			/* pc_relative */
d90 1
a90 1
	 FALSE,			/* partial_inplace */
d93 1
a93 1
	 FALSE),		/* pcrel_offset */
d95 22
a116 107
  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_8",        FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_12",       FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_16",       FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_32",       FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32",     FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT12",    FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT32",    FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32",    FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_COPY,      0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_COPY",     FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GLOB_DAT", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_JMP_SLOT", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_RELATIVE,  0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_RELATIVE", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF32", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTPC,     0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPC",    FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT16",    FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16",     FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16DBL",  FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32DBL",  FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,0xffffffff, TRUE),
  EMPTY_HOWTO (R_390_64),	/* Empty entry for R_390_64.  */
  EMPTY_HOWTO (R_390_PC64),	/* Empty entry for R_390_PC64.  */
  EMPTY_HOWTO (R_390_GOT64),	/* Empty entry for R_390_GOT64.  */
  EMPTY_HOWTO (R_390_PLT64),	/* Empty entry for R_390_PLT64.  */
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF16", FALSE, 0,0x0000ffff, FALSE),
  EMPTY_HOWTO (R_390_GOTOFF64),	/* Empty entry for R_390_GOTOFF64.  */
  HOWTO(R_390_GOTPLT12,  0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_GOTPLT12", FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOTPLT16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_GOTPLT32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT32", FALSE, 0,0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_GOTPLT64),	/* Empty entry for R_390_GOTPLT64.  */
  HOWTO(R_390_GOTPLTENT, 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLTENT",FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_PLTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PLTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF32", FALSE, 0,0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_PLTOFF64),	/* Empty entry for R_390_PLTOFF64.  */
  HOWTO(R_390_TLS_LOAD, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LOAD", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_GDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_GDCALL", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_LDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LDCALL", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_GD32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GD32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_GD64),	/* Empty entry for R_390_TLS_GD64.  */
  HOWTO(R_390_TLS_GOTIE12, 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE12", FALSE, 0, 0x00000fff, FALSE),
  HOWTO(R_390_TLS_GOTIE32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_GOTIE64),	/* Empty entry for R_390_TLS_GOTIE64.  */
  HOWTO(R_390_TLS_LDM32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDM32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDM64),	/* Empty entry for R_390_TLS_LDM64.  */
  HOWTO(R_390_TLS_IE32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IE32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_IE64),	/* Empty entry for R_390_TLS_IE64.  */
  HOWTO(R_390_TLS_IEENT, 1, 2, 32, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IEENT", FALSE, 0, 0xffffffff, TRUE),
  HOWTO(R_390_TLS_LE32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LE32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_LE64),	/* Empty entry for R_390_TLS_LE64.  */
  HOWTO(R_390_TLS_LDO32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDO32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDO64),	/* Empty entry for R_390_TLS_LDO64.  */
  HOWTO(R_390_TLS_DTPMOD, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPMOD", FALSE, 0, 0xffffffff, FALSE),
  HOWTO(R_390_TLS_DTPOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPOFF", FALSE, 0, 0xffffffff, FALSE),
  HOWTO(R_390_TLS_TPOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_TPOFF", FALSE, 0, 0xffffffff, FALSE),
  HOWTO(R_390_20,        0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_20",      FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOT20,	 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOT20",   FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOTPLT20,  0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOTPLT20", FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_TLS_GOTIE20, 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_TLS_GOTIE20", FALSE, 0,0x0fffff00, FALSE),
d121 1
a121 1
  HOWTO (R_390_GNU_VTINHERIT, 0,2,0,FALSE,0,complain_overflow_dont, NULL, "R_390_GNU_VTINHERIT", FALSE,0, 0, FALSE);
d123 1
a123 1
  HOWTO (R_390_GNU_VTENTRY, 0,2,0,FALSE,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", FALSE,0,0, FALSE);
d161 1
a161 1
      return &elf_howto_table[(int) R_390_GOTOFF32];
a179 50
    case BFD_RELOC_16_GOTOFF:
      return &elf_howto_table[(int) R_390_GOTOFF16];
    case BFD_RELOC_390_GOTPLT12:
      return &elf_howto_table[(int) R_390_GOTPLT12];
    case BFD_RELOC_390_GOTPLT16:
      return &elf_howto_table[(int) R_390_GOTPLT16];
    case BFD_RELOC_390_GOTPLT32:
      return &elf_howto_table[(int) R_390_GOTPLT32];
    case BFD_RELOC_390_GOTPLTENT:
      return &elf_howto_table[(int) R_390_GOTPLTENT];
    case BFD_RELOC_390_PLTOFF16:
      return &elf_howto_table[(int) R_390_PLTOFF16];
    case BFD_RELOC_390_PLTOFF32:
      return &elf_howto_table[(int) R_390_PLTOFF32];
    case BFD_RELOC_390_TLS_LOAD:
      return &elf_howto_table[(int) R_390_TLS_LOAD];
    case BFD_RELOC_390_TLS_GDCALL:
      return &elf_howto_table[(int) R_390_TLS_GDCALL];
    case BFD_RELOC_390_TLS_LDCALL:
      return &elf_howto_table[(int) R_390_TLS_LDCALL];
    case BFD_RELOC_390_TLS_GD32:
      return &elf_howto_table[(int) R_390_TLS_GD32];
    case BFD_RELOC_390_TLS_GOTIE12:
      return &elf_howto_table[(int) R_390_TLS_GOTIE12];
    case BFD_RELOC_390_TLS_GOTIE32:
      return &elf_howto_table[(int) R_390_TLS_GOTIE32];
    case BFD_RELOC_390_TLS_LDM32:
      return &elf_howto_table[(int) R_390_TLS_LDM32];
    case BFD_RELOC_390_TLS_IE32:
      return &elf_howto_table[(int) R_390_TLS_IE32];
    case BFD_RELOC_390_TLS_IEENT:
      return &elf_howto_table[(int) R_390_TLS_IEENT];
    case BFD_RELOC_390_TLS_LE32:
      return &elf_howto_table[(int) R_390_TLS_LE32];
    case BFD_RELOC_390_TLS_LDO32:
      return &elf_howto_table[(int) R_390_TLS_LDO32];
    case BFD_RELOC_390_TLS_DTPMOD:
      return &elf_howto_table[(int) R_390_TLS_DTPMOD];
    case BFD_RELOC_390_TLS_DTPOFF:
      return &elf_howto_table[(int) R_390_TLS_DTPOFF];
    case BFD_RELOC_390_TLS_TPOFF:
      return &elf_howto_table[(int) R_390_TLS_TPOFF];
    case BFD_RELOC_390_20:
      return &elf_howto_table[(int) R_390_20];
    case BFD_RELOC_390_GOT20:
      return &elf_howto_table[(int) R_390_GOT20];
    case BFD_RELOC_390_GOTPLT20:
      return &elf_howto_table[(int) R_390_GOTPLT20];
    case BFD_RELOC_390_TLS_GOTIE20:
      return &elf_howto_table[(int) R_390_TLS_GOTIE20];
d215 1
a215 71
/* A relocation function which doesn't do anything.  */
static bfd_reloc_status_type
s390_tls_reloc (abfd, reloc_entry, symbol, data, input_section,
		output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

/* Handle the large displacement relocs.  */
static bfd_reloc_status_type
s390_elf_ldisp_reloc (abfd, reloc_entry, symbol, data, input_section,
                      output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  reloc_howto_type *howto = reloc_entry->howto;
  bfd_vma relocation;
  bfd_vma insn;
  
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
  
  if (output_bfd != NULL)
    return bfd_reloc_continue;
  
  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;
  
  relocation = (symbol->value
		+ symbol->section->output_section->vma
		+ symbol->section->output_offset);
  relocation += reloc_entry->addend;
  if (howto->pc_relative)
    {
      relocation -= (input_section->output_section->vma
		     + input_section->output_offset);
      relocation -= reloc_entry->address;
    }
  
  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn |= (relocation & 0xfff) << 16 | (relocation & 0xff000) >> 4;
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
  
  if ((bfd_signed_vma) relocation < - 0x80000
      || (bfd_signed_vma) relocation > 0x7ffff)
    return bfd_reloc_overflow;
  else
    return bfd_reloc_ok;
}

static bfd_boolean
d221 1
a221 1
    return TRUE;
a232 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d257 1
a257 1
   The code for position independent PLT entries looks like this:
a413 21

  /* Number of GOTPLT references for a function.  */
  bfd_signed_vma gotplt_refcount;

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	3
#define GOT_TLS_IE_NLT	4
  unsigned char tls_type;
};

#define elf_s390_hash_entry(ent) \
  ((struct elf_s390_link_hash_entry *)(ent))

struct elf_s390_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
a415 25
#define elf_s390_tdata(abfd) \
  ((struct elf_s390_obj_tdata *) (abfd)->tdata.any)

#define elf_s390_local_got_tls_type(abfd) \
  (elf_s390_tdata (abfd)->local_got_tls_type)

static bfd_boolean
elf_s390_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

static bfd_boolean
elf_s390_object_p (abfd)
     bfd *abfd;
{
  /* Set the right machine number for an s390 elf32 file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_31);
}

a430 5
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ldm_got;

a465 2
      eh->gotplt_refcount = 0;
      eh->tls_type = GOT_UNKNOWN;
a496 1
  ret->tls_ldm_got.refcount = 0;
d505 1
a505 1
static bfd_boolean
d513 1
a513 1
    return FALSE;
d528 2
a529 2
    return FALSE;
  return TRUE;
d536 1
a536 1
static bfd_boolean
d545 1
a545 1
    return FALSE;
d548 1
a548 1
    return FALSE;
d560 1
a560 1
  return TRUE;
d567 1
a567 1
     const struct elf_backend_data *bed;
d609 1
a609 47
  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
}

static int
elf_s390_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_390_TLS_GD32:
    case R_390_TLS_IE32:
      if (is_local)
	return R_390_TLS_LE32;
      return R_390_TLS_IE32;
    case R_390_TLS_GOTIE32:
      if (is_local)
	return R_390_TLS_LE32;
      return R_390_TLS_GOTIE32;
    case R_390_TLS_LDM32:
      return R_390_TLS_LE32;
    }

  return r_type;
d616 1
a616 1
static bfd_boolean
a628 2
  bfd_signed_vma *local_got_refcounts;
  int tls_type, old_tls_type;
d630 2
a631 2
  if (info->relocatable)
    return TRUE;
a635 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
a641 1
      unsigned int r_type;
d652 1
a652 1
	  return FALSE;
d660 1
a660 6
      /* Create got section and local_got_refcounts array if they
	 are needed.  */
      r_type = elf_s390_tls_transition (info,
					ELF32_R_TYPE (rel->r_info),
					h == NULL);
      switch (r_type)
d663 1
a663 2
	case R_390_GOT16:
	case R_390_GOT20:
d666 6
a671 14
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	case R_390_TLS_GD32:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE32:
	case R_390_TLS_IEENT:
	case R_390_TLS_IE32:
	case R_390_TLS_LDM32:
	  if (h == NULL
	      && local_got_refcounts == NULL)
d673 1
a673 1
	      bfd_size_type size;
d675 2
a676 4
	      size = symtab_hdr->sh_info;
	      size *= (sizeof (bfd_signed_vma) + sizeof(char));
	      local_got_refcounts = ((bfd_signed_vma *)
				     bfd_zalloc (abfd, size));
d678 12
a689 4
		return FALSE;
	      elf_local_got_refcounts (abfd) = local_got_refcounts;
	      elf_s390_local_got_tls_type (abfd)
		= (char *) (local_got_refcounts + symtab_hdr->sh_info);
d691 3
a693 3
	  /* Fall through.  */
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
d701 1
a701 1
		return FALSE;
a702 9
	}

      switch (r_type)
	{
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  /* Got is created, nothing to be done.  */
d705 2
a706 2
	case R_390_PLT16DBL:
	case R_390_PLT32DBL:
a707 2
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
d709 5
a713 5
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.  */
d716 3
a718 30
	     creating a procedure linkage table entry.  */
	  if (h != NULL)
	    {
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount += 1;
	    }
	  break;

	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  /* This symbol requires either a procedure linkage table entry
	     or an entry in the local got. We actually build the entry
	     in adjust_dynamic_symbol because whether this is really a
	     global reference can change and with it the fact if we have
	     to create a plt entry or a local got entry. To be able to
	     make a once global symbol a local one we have to keep track
	     of the number of gotplt references that exist for this
	     symbol.  */
	  if (h != NULL)
	    {
	      ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount++;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount += 1;
	    }
	  else
	    local_got_refcounts[r_symndx] += 1;
	  break;
d720 2
a721 2
	case R_390_TLS_LDM32:
	  htab->tls_ldm_got.refcount += 1;
d724 2
a725 85
	case R_390_TLS_IE32:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE32:
	case R_390_TLS_IEENT:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through.  */

	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOTENT:
	case R_390_TLS_GD32:
	  /* This symbol requires a global offset table entry.  */
	  switch (r_type)
	    {
	    default:
	    case R_390_GOT12:
	    case R_390_GOT16:
	    case R_390_GOT20:
	    case R_390_GOT32:
	    case R_390_GOTENT:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_390_TLS_GD32:
	      tls_type = GOT_TLS_GD;
	      break;
	    case R_390_TLS_IE32:
	    case R_390_TLS_GOTIE32:
	      tls_type = GOT_TLS_IE;
	      break;
	    case R_390_TLS_GOTIE12:
	    case R_390_TLS_GOTIE20:
	    case R_390_TLS_IEENT:
	      tls_type = GOT_TLS_IE_NLT;
	      break;
	    }

	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	      old_tls_type = elf_s390_hash_entry(h)->tls_type;
	    }
	  else
	    {
	      local_got_refcounts[r_symndx] += 1;
	      old_tls_type = elf_s390_local_got_tls_type (abfd) [r_symndx];
	    }
	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN)
	    {
	      if (old_tls_type == GOT_NORMAL || tls_type == GOT_NORMAL)
		{
		  (*_bfd_error_handler)
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
		  return FALSE;
		}
	      if (old_tls_type > tls_type)
		tls_type = old_tls_type;
	    }

	  if (old_tls_type != tls_type)
	    {
	      if (h != NULL)
		elf_s390_hash_entry (h)->tls_type = tls_type;
	      else
		elf_s390_local_got_tls_type (abfd) [r_symndx] = tls_type;
	    }

	  if (r_type != R_390_TLS_IE32)
	    break;
	  /* Fall through.  */

	case R_390_TLS_LE32:
	  if (!info->shared)
	    break;
	  info->flags |= DF_STATIC_TLS;
	  /* Fall through.  */

	case R_390_8:
	case R_390_16:
d727 2
a728 2
	case R_390_PC16:
	case R_390_PC16DBL:
d778 1
a778 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d801 1
a801 1
		    return FALSE;
d829 1
a829 1
			return FALSE;
d845 1
a846 1

d850 1
a850 1
		    return FALSE;
a859 1

d863 1
a863 1
		    return FALSE;
d882 4
a885 4
	case R_390_GNU_VTINHERIT:
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;
d889 4
a892 4
	case R_390_GNU_VTENTRY:
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;
d899 1
a899 1
  return TRUE;
d944 1
a944 1
static bfd_boolean
d955 2
d966 22
a987 23
    {
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;

      r_symndx = ELF32_R_SYM (rel->r_info);
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf_s390_link_hash_entry *eh;
	  struct elf_s390_dyn_relocs **pp;
	  struct elf_s390_dyn_relocs *p;

	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf_s390_link_hash_entry *) h;

	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}
d989 16
a1004 35
      r_type = ELF32_R_TYPE (rel->r_info);
      r_type = elf_s390_tls_transition (info, r_type, h != NULL);
      switch (r_type)
	{
	case R_390_TLS_LDM32:
	  if (elf_s390_hash_table (info)->tls_ldm_got.refcount > 0)
	    elf_s390_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;

	case R_390_TLS_GD32:
	case R_390_TLS_IE32:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_GOTIE32:
	case R_390_TLS_IEENT:
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	case R_390_GOTENT:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d1006 2
a1007 12
	case R_390_8:
	case R_390_12:
	case R_390_16:
	case R_390_20:
	case R_390_32:
	case R_390_PC16:
	case R_390_PC16DBL:
	case R_390_PC32DBL:
	case R_390_PC32:
	  if (info->shared)
	    break;
	  /* Fall through.  */
d1009 1
a1009 11
	case R_390_PLT16DBL:
	case R_390_PLT32DBL:
	case R_390_PLT32:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d1011 2
a1012 8
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
d1014 9
a1022 2
		  ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount--;
		  h->plt.refcount -= 1;
d1024 2
a1025 7
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d1027 11
a1037 4
	default:
	  break;
	}
    }
d1039 3
a1041 9
  return TRUE;
}

/* Make sure we emit a GOT entry if the symbol was supposed to have a PLT
   entry but we found we will not create any.  Called when we find we will
   not have any PLT for this symbol, by for example
   elf_s390_adjust_dynamic_symbol when we're doing a proper dynamic link,
   or elf_s390_size_dynamic_sections if no dynamic sections will be
   created (we're only linking static objects).  */
d1043 1
a1043 14
static void
elf_s390_adjust_gotplt (h)
     struct elf_s390_link_hash_entry *h;
{
  if (h->elf.root.type == bfd_link_hash_warning)
    h = (struct elf_s390_link_hash_entry *) h->elf.root.u.i.link;

  if (h->gotplt_refcount <= 0)
    return;

  /* We simply add the number of gotplt references to the number
   * of got references for this symbol.  */
  h->elf.got.refcount += h->gotplt_refcount;
  h->gotplt_refcount = -1;
d1052 1
a1052 1
static bfd_boolean
d1058 2
d1077 2
a1078 2
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
a1082 1
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
d1085 1
a1085 1
      return TRUE;
d1104 1
a1104 5
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
      return TRUE;
d1115 1
a1115 1
    return TRUE;
d1120 1
a1120 1
    return TRUE;
d1126 1
a1126 1
      return TRUE;
d1129 2
a1130 1
  if (ELIMINATE_COPY_RELOCS)
d1132 4
a1135 2
      struct elf_s390_link_hash_entry * eh;
      struct elf_s390_dyn_relocs *p;
d1137 6
a1142 15
      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1178 1
a1178 1
	return FALSE;
d1188 1
a1188 1
  return TRUE;
d1195 1
a1195 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d1197 1
a1197 1
   && ((SHARED)								\
d1205 1
a1205 1
static bfd_boolean
d1216 1
a1216 1
    return TRUE;
a1218 3
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
d1225 1
a1225 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1233 1
a1233 1
	    return FALSE;
d1236 1
a1236 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
a1272 1
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
a1278 1
      elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
d1281 2
a1282 22
  /* If R_390_TLS_{IE32,GOTIE32,GOTIE12,IEENT} symbol is now local to
     the binary, we can optimize a bit. IE32 and GOTIE32 get converted
     to R_390_TLS_LE32 requiring no TLS entry. For GOTIE12 and IEENT
     we can save the dynamic TLS relocation.  */
  if (h->got.refcount > 0
      && !info->shared
      && h->dynindx == -1
      && elf_s390_hash_entry(h)->tls_type >= GOT_TLS_IE)
    {
      if (elf_s390_hash_entry(h)->tls_type == GOT_TLS_IE_NLT)
	/* For the GOTIE access without a literal pool entry the offset has
	   to be stored somewhere. The immediate value in the instruction
	   is not bit enough so the value is stored in the got.  */
	{
	  h->got.offset = htab->sgot->_raw_size;
	  htab->sgot->_raw_size += GOT_ENTRY_SIZE;
	}
      else
	h->got.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
   {
d1284 1
a1284 2
      bfd_boolean dyn;
      int tls_type = elf_s390_hash_entry(h)->tls_type;
d1292 1
a1292 1
	    return FALSE;
a1297 3
      /* R_390_TLS_GD32 needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->_raw_size += GOT_ENTRY_SIZE;
d1299 1
a1299 11
      /* R_390_TLS_IE32 needs one dynamic relocation,
	 R_390_TLS_GD32 needs one if local symbol and two if global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type >= GOT_TLS_IE)
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->_raw_size += 2 * sizeof (Elf32_External_Rela);
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
d1307 1
a1307 1
    return TRUE;
a1332 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1334 1
a1334 1
  else if (ELIMINATE_COPY_RELOCS)
d1353 1
a1353 1
		return FALSE;
a1370 1

d1374 1
a1374 1
  return TRUE;
d1379 1
a1379 1
static bfd_boolean
d1402 1
a1402 1
	  return FALSE;
d1405 1
a1405 1
  return TRUE;
d1410 1
a1410 1
static bfd_boolean
d1418 1
a1418 1
  bfd_boolean relocs;
d1429 1
a1429 1
      if (info->executable)
a1444 1
      char *local_tls_type;
a1485 1
      local_tls_type = elf_s390_local_got_tls_type (ibfd);
d1488 1
a1488 1
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
a1493 2
	      if (*local_tls_type == GOT_TLS_GD)
		s->_raw_size += GOT_ENTRY_SIZE;
a1501 11
  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_390_TLS_LDM32
	 relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

d1508 1
a1508 1
  relocs = FALSE;
d1523 2
a1524 2
	  if (s->_raw_size != 0)
	    relocs = TRUE;
d1559 1
a1559 1
	return FALSE;
d1572 1
a1572 1
      if (info->executable)
d1575 1
a1575 1
	    return FALSE;
d1584 1
a1584 1
	    return FALSE;
d1588 5
a1592 5
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
	    return FALSE;
d1603 1
a1603 1
		return FALSE;
d1609 1
a1609 51
  return TRUE;
}

/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
    return 0;
  return elf_hash_table (info)->tls_sec->vma;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
{
  struct elf_link_hash_table *htab = elf_hash_table (info);

  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
    return 0;
  return htab->tls_size + htab->tls_sec->vma - address;
}

/* Complain if TLS instruction relocation is against an invalid
   instruction.  */

static void
invalid_tls_insn (input_bfd, input_section, rel)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rel;
{
  reloc_howto_type *howto;

  howto = elf_howto_table + ELF32_R_TYPE (rel->r_info);
  (*_bfd_error_handler)
    (_("%s(%s+0x%lx): invalid instruction for TLS relocation %s"),
     bfd_archive_filename (input_bfd),
     bfd_get_section_name (input_bfd, input_section),
     (long) rel->r_offset,
     howto->name);
d1614 1
a1614 1
static bfd_boolean
d1633 2
a1634 2
  if (info->relocatable)
    return TRUE;
d1645 1
a1645 1
      unsigned int r_type;
d1653 1
a1653 1
      bfd_boolean unresolved_reloc;
a1654 1
      int tls_type;
d1658 3
a1660 3
	  || r_type == (int) R_390_GNU_VTENTRY)
	continue;
      if (r_type >= (int) R_390_max)
d1663 1
a1663 1
	  return FALSE;
a1667 2

      /* This is a final link.  */
d1671 1
a1671 1
      unresolved_reloc = FALSE;
d1676 1
a1676 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d1680 4
a1683 1
	  bfd_boolean warned ATTRIBUTE_UNUSED;
d1685 35
a1719 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
d1724 3
a1726 38
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT20:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  /* There are three cases for a GOTPLT relocation. 1) The
	     relocation is against the jump slot entry of a plt that
	     will get emitted to the output file. 2) The relocation
	     is against the jump slot of a plt entry that has been
	     removed. elf_s390_adjust_gotplt has created a GOT entry
	     as replacement. 3) The relocation is against a local symbol.
	     Cases 2) and 3) are the same as the GOT relocation code
	     so we just have to test for case 1 and fall through for
	     the other two.  */
	  if (h != NULL && h->plt.offset != (bfd_vma) -1)
	    {
	      bfd_vma plt_index;

	      /* Calc. index no.
		 Current offset - size first entry / entry size.  */
	      plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) /
		PLT_ENTRY_SIZE;

	      /* Offset in GOT is PLT index plus GOT headers(3) times 4,
		 addr & GOT addr.  */
	      relocation = (plt_index + 3) * GOT_ENTRY_SIZE;
	      unresolved_reloc = FALSE;

	      if (r_type == R_390_GOTPLTENT)
		relocation += htab->sgot->output_section->vma;
	      break;
	    }
	  /* Fall through.  */

	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT20:
	case R_390_GOT32:
d1728 2
a1729 2
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
d1733 3
a1735 3
	  if (h != NULL)
	    {
	      bfd_boolean dyn;
d1737 1
a1737 1
	      off = h->got.offset;
d1739 3
a1741 3
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
		  || (info->shared
		      && (info->symbolic
d1744 18
a1761 20
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 2, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rel.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
d1764 3
a1766 3
		      h->got.offset |= 1;
		    }
		}
d1768 4
a1771 4
		unresolved_reloc = FALSE;
	    }
	  else
	    {
d1775 1
a1775 1
	      off = local_got_offsets[r_symndx];
d1777 8
a1784 8
	      /* The offset must always be a multiple of 4.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_32 (output_bfd, relocation,
d1787 5
a1791 5
		  if (info->shared)
		    {
		      asection *srelgot;
		      Elf_Internal_Rela outrel;
		      bfd_byte *loc;
d1793 1
a1793 1
		      srelgot = htab->srelgot;
d1797 4
a1800 4
		      outrel.r_offset = (htab->sgot->output_section->vma
					 + htab->sgot->output_offset
					 + off);
		      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
d1802 8
a1809 8
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }

		  local_got_offsets[r_symndx] |= 1;
		}
	    }
d1816 7
a1822 6
	  /* For @@GOTENT the relocation is against the offset between
	     the instruction and the symbols entry in the GOT and not
	     between the start of the GOT and the symbols entry. We
	     add the vma of the GOT to get the correct value.  */
	  if (   r_type == R_390_GOTENT
	      || r_type == R_390_GOTPLTENT)
d1825 1
a1825 1
	  break;
d1827 11
a1837 12
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  relocation -= htab->sgot->output_section->vma;
	  break;
d1839 1
a1839 1
	case R_390_GOTPC:
d1841 15
a1855 10
	  /* Use global offset table as symbol value.  */
	  relocation = htab->sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_PLT16DBL:
	case R_390_PLT32DBL:
	case R_390_PLT32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */
d1857 1
a1857 6
	  /* Resolve a PLT32 reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    break;

	  if (h->plt.offset == (bfd_vma) -1
d1859 20
a1878 42
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }

	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset);
	  unresolved_reloc = FALSE;
	  break;

	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table relative to the start of the GOT.  */

	  /* For local symbols or if we didn't make a PLT entry for
	     this symbol resolve the symbol directly.  */
	  if (   h == NULL
	      || h->plt.offset == (bfd_vma) -1
	      || htab->splt == NULL)
	    {
	      relocation -= htab->sgot->output_section->vma;
	      break;
	    }

	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset
			- htab->sgot->output_section->vma);
	  unresolved_reloc = FALSE;
	  break;

	case R_390_8:
	case R_390_16:
	case R_390_32:
	case R_390_PC16:
	case R_390_PC16DBL:
	case R_390_PC32DBL:
	case R_390_PC32:
d1882 2
a1883 2
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
d1886 1
a1886 4
	  if ((info->shared
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d1896 1
a1896 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1906 3
a1908 3
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate;
d1910 1
a1910 1
	      bfd_byte *loc;
d1916 2
a1917 2
	      skip = FALSE;
	      relocate = FALSE;
d1923 1
a1923 1
		skip = TRUE;
d1925 3
a1927 3
		skip = TRUE, relocate = TRUE;
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);
d1929 1
a1929 1
	      if (skip)
d1931 1
a1931 1
	      else if (h != NULL
d1941 2
a1942 2
		{
		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
d1944 3
a1946 3
		}
	      else
		{
d1948 2
d1951 1
a1951 35
		  if (r_type == R_390_32)
		    {
		      relocate = TRUE;
		      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
		    }
		  else
		    {
		      long sindx;

		      if (bfd_is_abs_section (sec))
			sindx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error(bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  sindx = elf_section_data (osec)->dynindx;
			  BFD_ASSERT (sindx > 0);

			  /* We are turning this relocation into one
			     against a section symbol, so subtract out
			     the output section's address but not the
			     offset of the input section in the output
			     section.  */

			  outrel.r_addend -= osec->vma;
			}
		      outrel.r_info = ELF32_R_INFO (sindx, r_type);
		    }
		}
d1957 2
a1958 101
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }
	  break;

	  /* Relocations for tls literal pool entries.  */
	case R_390_TLS_IE32:
	  if (info->shared)
	    {
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
	    }
	  /* Fall through.  */

	case R_390_TLS_GD32:
	case R_390_TLS_GOTIE32:
	  r_type = elf_s390_tls_transition (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type >= GOT_TLS_IE)
		r_type = R_390_TLS_LE32;
	    }
	  if (r_type == R_390_TLS_GD32 && tls_type >= GOT_TLS_IE)
	    r_type = R_390_TLS_IE32;

	  if (r_type == R_390_TLS_LE32)
	    {
	      /* This relocation gets optimized away by the local exec
		 access optimization.  */
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_32 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	      continue;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	emit_tls_relocs:

	  if ((off & 1) != 0)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      int dr_type, indx;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_390_TLS_GD32)
		dr_type = R_390_TLS_DTPMOD;
	      else
		dr_type = R_390_TLS_TPOFF;
	      if (dr_type == R_390_TLS_TPOFF && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (indx, dr_type);
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
		* sizeof (Elf32_External_Rela);
d1961 7
a1967 72
	      if (r_type == R_390_TLS_GD32)
		{
		  if (indx == 0)
		    {
		      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_32 (output_bfd,
				  relocation - dtpoff_base (info),
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
		    }
		  else
		    {
		      outrel.r_info = ELF32_R_INFO (indx, R_390_TLS_DTPOFF);
		      outrel.r_offset += GOT_ENTRY_SIZE;
		      outrel.r_addend = 0;
		      htab->srelgot->reloc_count++;
		      loc += sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();
	  if (r_type == ELF32_R_TYPE (rel->r_info))
	    {
	      relocation = htab->sgot->output_offset + off;
	      if (r_type == R_390_TLS_IE32 || r_type == R_390_TLS_IEENT)
		relocation += htab->sgot->output_section->vma;
	      unresolved_reloc = FALSE;
	    }
	  else
	    {
	      bfd_put_32 (output_bfd, htab->sgot->output_offset + off,
			  contents + rel->r_offset);
	      continue;
	    }
	  break;

	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE20:
	case R_390_TLS_IEENT:
	  if (h == NULL)
	    {
	      if (local_got_offsets == NULL)
		abort();
	      off = local_got_offsets[r_symndx];
	      if (info->shared)
		goto emit_tls_relocs;
	    }
	  else
	    {
	      off = h->got.offset;
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (info->shared || h->dynindx != -1 || tls_type < GOT_TLS_IE)
		goto emit_tls_relocs;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  BFD_ASSERT (! unresolved_reloc);
	  bfd_put_32 (output_bfd, -tpoff (info, relocation),
		      htab->sgot->contents + off);
	  relocation = htab->sgot->output_offset + off;
	  if (r_type == R_390_TLS_IEENT)
	    relocation += htab->sgot->output_section->vma;
	  unresolved_reloc = FALSE;
a1969 161
	case R_390_TLS_LDM32:
	  if (! info->shared)
	    /* The literal pool entry this relocation refers to gets ignored
	       by the optimized code of the local exec model. Do nothing
	       and the value will turn out zero.  */
	    continue;

	  if (htab->sgot == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      bfd_put_32 (output_bfd, 0,
			  htab->sgot->contents + off + GOT_ENTRY_SIZE);
	      outrel.r_info = ELF32_R_INFO (0, R_390_TLS_DTPMOD);
	      outrel.r_addend = 0;
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
		* sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }
	  relocation = htab->sgot->output_offset + off;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_TLS_LE32:
	  if (info->shared)
	    {
	      /* Linking a shared library with non-fpic code requires
		 a R_390_TLS_TPOFF relocation.  */
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;
	      int indx;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      if (h != NULL && h->dynindx != -1)
		indx = h->dynindx;
	      else
		indx = 0;
	      outrel.r_info = ELF32_R_INFO (indx, R_390_TLS_TPOFF);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	    }
	  else
	    {
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_32 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	    }
	  continue;

	case R_390_TLS_LDO32:
	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
	    relocation -= dtpoff_base (info);
	  else
	    /* When converting LDO to LE, we must negate.  */
	    relocation = -tpoff (info, relocation);
	  break;

	  /* Relocations for tls instructions.  */
	case R_390_TLS_LOAD:
	case R_390_TLS_GDCALL:
	case R_390_TLS_LDCALL:
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    tls_type = elf_s390_hash_entry(h)->tls_type;

	  if (tls_type == GOT_TLS_GD)
	    continue;

	  if (r_type == R_390_TLS_LOAD)
	    {
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* IE->LE transition. Four valid cases:
		     l %rx,0(0,%ry)    -> lr %rx,%ry + bcr 0,0
		     l %rx,0(%ry,0)    -> lr %rx,%ry + bcr 0,0
		     l %rx,0(%ry,%r12) -> lr %rx,%ry + bcr 0,0
		     l %rx,0(%r12,%ry) -> lr %rx,%ry + bcr 0,0 */
		  unsigned int insn, ry;

		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  ry = 0;
		  if ((insn & 0xff00f000) == 0x58000000)
		    /* l %rx,0(%ry,0) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x000f0000);
		  else if ((insn & 0xff0f0000) == 0x58000000)
		    /* l %rx,0(0,%ry) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x0000f000) << 4;
		  else if ((insn & 0xff00f000) == 0x5800c000)
		    /* l %rx,0(%ry,%r12) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x000f0000);
		  else if ((insn & 0xff0f0000) == 0x580c0000)
		    /* l %rx,0(%r12,%ry) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x0000f000) << 4;
		  else
		    invalid_tls_insn (input_bfd, input_section, rel);
		  insn = 0x18000700 | (insn & 0x00f00000) | ry;
		  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
		}
	    }
	  else if (r_type == R_390_TLS_GDCALL)
	    {
	      unsigned int insn;

	      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      if ((insn & 0xff000fff) != 0x4d000000)
		invalid_tls_insn (input_bfd, input_section, rel);
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		/* GD->LE transition.
		   bas %r14,0(%rx,%r13) -> bc 0,0  */
		insn = 0x47000000;
	      else
		/* GD->IE transition.
		   bas %r14,0(%rx,%r13) -> l %r2,0(%r2,%r12)  */
		insn = 0x5822c000;
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	    }
	  else if (r_type == R_390_TLS_LDCALL)
	    {
	      if (!info->shared)
		{
		  unsigned int insn;

		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  if ((insn & 0xff000fff) != 0x4d000000)
		    invalid_tls_insn (input_bfd, input_section, rel);
		  /* LD->LE transition.
		     bas %r14,0(%rx,%r13) -> bc 0,0  */
		  insn = 0x47000000;
		  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
		}
	    }
	  continue;

d1987 3
a1989 15
      if (r_type == R_390_20
	  || r_type == R_390_GOT20
	  || r_type == R_390_GOTPLT20
	  || r_type == R_390_TLS_GOTIE20)
	{
	  relocation += rel->r_addend;
	  relocation = (relocation&0xfff) << 8 | (relocation&0xff000) >> 12;
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, 0);
	}
      else
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel->r_offset,
				      relocation, rel->r_addend);
d2003 1
a2003 1
		return FALSE;
d2014 1
a2014 1
		return FALSE;
d2023 1
a2023 1
	      return FALSE;
d2028 1
a2028 1
  return TRUE;
d2034 1
a2034 1
static bfd_boolean
d2050 1
a2050 1
      bfd_byte *loc;
d2054 2
a2055 1
	 it up.  */
d2063 1
a2063 1
	 Current offset - size first entry / entry size.  */
d2067 1
a2067 1
	 addr & GOT addr.  */
d2072 1
a2072 1
			    (PLT_ENTRY_SIZE * plt_index) + 18) / 2);
d2074 1
a2074 1
	 390 can only handle +-64 K jumps.  */
d2076 2
a2077 2
	relative_offset
	  = -(unsigned) (((65536 / PLT_ENTRY_SIZE - 1) * PLT_ENTRY_SIZE) / 2);
d2082 1
a2082 1
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD0,
d2153 1
a2153 1
		  htab->splt->contents + h->plt.offset + 28);
d2156 1
a2156 1
	 Points to instruction after GOT offset.  */
d2170 1
a2170 1
      loc = htab->srelplt->contents + plt_index * sizeof (Elf32_External_Rela);
d2184 1
a2184 4
  if (h->got.offset != (bfd_vma) -1
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_GD
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE_NLT)
d2187 1
a2187 1
      bfd_byte *loc;
d2190 1
a2190 1
	 up.  */
d2213 3
a2215 3
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
d2221 2
a2222 2
	  rela.r_addend = 0;
	}
d2224 2
a2225 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
d2232 1
a2232 1
      bfd_byte *loc;
d2247 2
a2248 2
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf32_External_Rela);
d2258 1
a2258 1
  return TRUE;
d2283 1
a2283 1
static bfd_boolean
d2340 2
a2341 2
	  memset (htab->splt->contents, 0, PLT_FIRST_ENTRY_SIZE);
	  if (info->shared)
d2344 1
a2344 1
			  htab->splt->contents );
d2346 1
a2346 1
			  htab->splt->contents +4 );
d2348 1
a2348 1
			  htab->splt->contents +8 );
d2350 1
a2350 1
			  htab->splt->contents +12 );
d2352 18
a2369 18
			  htab->splt->contents +16 );
	   }
	  else
	   {
	      bfd_put_32 (output_bfd, (bfd_vma)PLT_FIRST_ENTRY_WORD0,
			  htab->splt->contents );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD1,
			  htab->splt->contents +4 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD2,
			  htab->splt->contents +8 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD3,
			  htab->splt->contents +12 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD4,
			  htab->splt->contents +16 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD5,
			  htab->splt->contents +20 );
	      bfd_put_32 (output_bfd,
			  htab->sgotplt->output_section->vma
d2371 2
a2372 2
			  htab->splt->contents + 24);
	   }
d2397 8
a2404 1
  return TRUE;
d2407 1
a2407 1
static bfd_boolean
d2418 1
a2418 1
	return FALSE;
d2451 1
d2454 1
a2454 1
#define elf_info_to_howto		      elf_s390_info_to_howto
d2461 1
a2461 1
#define elf_backend_check_relocs	      elf_s390_check_relocs
d2466 2
a2467 2
#define elf_backend_gc_mark_hook	      elf_s390_gc_mark_hook
#define elf_backend_gc_sweep_hook	      elf_s390_gc_sweep_hook
d2469 1
a2469 1
#define elf_backend_relocate_section	      elf_s390_relocate_section
d2474 1
a2474 2
#define bfd_elf32_mkobject		elf_s390_mkobject
#define elf_backend_object_p		elf_s390_object_p
@


1.30.10.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d32 1
a32 1
static bfd_boolean elf_s390_is_local_label_name
d38 1
a38 1
static bfd_boolean create_got_section
d40 1
a40 1
static bfd_boolean elf_s390_create_dynamic_sections
d45 1
a45 1
static bfd_boolean elf_s390_check_relocs
d51 1
a51 1
static bfd_boolean elf_s390_gc_sweep_hook
d54 1
a54 1
static bfd_boolean elf_s390_adjust_dynamic_symbol
d56 1
a56 1
static bfd_boolean allocate_dynrelocs
d58 1
a58 1
static bfd_boolean readonly_dynrelocs
d60 1
a60 1
static bfd_boolean elf_s390_size_dynamic_sections
d62 1
a62 1
static bfd_boolean elf_s390_relocate_section
d65 1
a65 1
static bfd_boolean elf_s390_finish_dynamic_symbol
d70 1
a70 1
static bfd_boolean elf_s390_finish_dynamic_sections
d72 2
a73 4
static bfd_boolean elf_s390_object_p
  PARAMS ((bfd *));
static bfd_boolean elf_s390_grok_prstatus
  PARAMS ((bfd *, Elf_Internal_Note *));
d85 1
a85 1
	 FALSE,			/* pc_relative */
d90 1
a90 1
	 FALSE,			/* partial_inplace */
d93 1
a93 1
	 FALSE),		/* pcrel_offset */
d95 22
a116 22
  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_8",       FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_12",      FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_16",      FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_32",      FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32",    FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont, bfd_elf_generic_reloc, "R_390_GOT12",   FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT32",   FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32",   FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_COPY,      0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_COPY",    FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GLOB_DAT",FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_JMP_SLOT",FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_RELATIVE,  0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_RELATIVE",FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTOFF,    0, 2, 32, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTOFF",  FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTPC,     0, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPC",   FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOT16",   FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16",    FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC16DBL", FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff,  TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32DBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,0xffffffff,  TRUE),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,0xffffffff,  TRUE),
d121 1
a121 1
  HOWTO (R_390_GNU_VTINHERIT, 0,2,0,FALSE,0,complain_overflow_dont, NULL, "R_390_GNU_VTINHERIT", FALSE,0, 0, FALSE);
d123 1
a123 1
  HOWTO (R_390_GNU_VTENTRY, 0,2,0,FALSE,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", FALSE,0,0, FALSE);
d215 1
a215 1
static bfd_boolean
d221 1
a221 1
    return TRUE;
d505 1
a505 1
static bfd_boolean
d513 1
a513 1
    return FALSE;
d528 2
a529 2
    return FALSE;
  return TRUE;
d536 1
a536 1
static bfd_boolean
d545 1
a545 1
    return FALSE;
d548 1
a548 1
    return FALSE;
d560 1
a560 1
  return TRUE;
d616 1
a616 1
static bfd_boolean
d631 1
a631 1
    return TRUE;
d652 1
a652 1
	  return FALSE;
d686 1
a686 1
		    return FALSE;
d701 1
a701 1
		return FALSE;
d801 1
a801 1
		    return FALSE;
d829 1
a829 1
			return FALSE;
d850 1
a850 1
		    return FALSE;
d863 1
a863 1
		    return FALSE;
d884 1
a884 1
            return FALSE;
d891 1
a891 1
            return FALSE;
d899 1
a899 1
  return TRUE;
d944 1
a944 1
static bfd_boolean
d1043 1
a1043 1
  return TRUE;
d1052 1
a1052 1
static bfd_boolean
d1085 1
a1085 1
      return TRUE;
d1104 1
a1104 1
      return TRUE;
d1115 1
a1115 1
    return TRUE;
d1120 1
a1120 1
    return TRUE;
d1126 1
a1126 1
      return TRUE;
d1142 1
a1142 1
      return TRUE;
d1178 1
a1178 1
	return FALSE;
d1188 1
a1188 1
  return TRUE;
d1205 1
a1205 1
static bfd_boolean
d1216 1
a1216 1
    return TRUE;
d1233 1
a1233 1
	    return FALSE;
d1284 1
a1284 1
      bfd_boolean dyn;
d1292 1
a1292 1
	    return FALSE;
d1307 1
a1307 1
    return TRUE;
d1353 1
a1353 1
		return FALSE;
d1374 1
a1374 1
  return TRUE;
d1379 1
a1379 1
static bfd_boolean
d1402 1
a1402 1
	  return FALSE;
d1405 1
a1405 1
  return TRUE;
d1410 1
a1410 1
static bfd_boolean
d1418 1
a1418 1
  bfd_boolean relocs;
d1508 1
a1508 1
  relocs = FALSE;
d1524 1
a1524 1
	    relocs = TRUE;
d1559 1
a1559 1
	return FALSE;
d1575 1
a1575 1
	    return FALSE;
d1584 1
a1584 1
	    return FALSE;
d1592 1
a1592 1
	    return FALSE;
d1603 1
a1603 1
		return FALSE;
d1609 1
a1609 1
  return TRUE;
d1614 1
a1614 1
static bfd_boolean
d1634 1
a1634 1
    return TRUE;
d1653 1
a1653 1
      bfd_boolean unresolved_reloc;
d1663 1
a1663 1
	  return FALSE;
d1671 1
a1671 1
      unresolved_reloc = FALSE;
d1695 1
a1695 1
		  unresolved_reloc = TRUE;
d1717 1
a1717 1
		return FALSE;
d1735 1
a1735 1
	      bfd_boolean dyn;
d1768 1
a1768 1
		unresolved_reloc = FALSE;
d1791 1
a1791 1
		      bfd_byte *loc;
d1802 2
a1803 2
		      loc = srelgot->contents;
		      loc += srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
d1843 1
a1843 1
	  unresolved_reloc = FALSE;
d1869 1
a1869 1
	  unresolved_reloc = FALSE;
d1908 1
a1908 1
              bfd_boolean skip, relocate;
d1910 1
a1910 1
	      bfd_byte *loc;
d1916 2
a1917 2
              skip = FALSE;
              relocate = FALSE;
d1923 1
a1923 1
		skip = TRUE;
d1925 1
a1925 1
		skip = TRUE, relocate = TRUE;
d1948 1
a1948 1
		  relocate = TRUE;
d1957 2
a1958 2
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
d2003 1
a2003 1
		return FALSE;
d2014 1
a2014 1
		return FALSE;
d2023 1
a2023 1
	      return FALSE;
d2028 1
a2028 1
  return TRUE;
d2034 1
a2034 1
static bfd_boolean
d2050 1
a2050 1
      bfd_byte *loc;
d2170 1
a2170 1
      loc = htab->srelplt->contents + plt_index * sizeof (Elf32_External_Rela);
d2187 1
a2187 1
      bfd_byte *loc;
d2224 2
a2225 2
      loc = htab->srelgot->contents;
      loc += htab->srelgot->reloc_count++ * sizeof (Elf32_External_Rela);
d2232 1
a2232 1
      bfd_byte *loc;
d2247 2
a2248 2
      loc = htab->srelbss->contents;
      loc += htab->srelbss->reloc_count++ * sizeof (Elf32_External_Rela);
d2258 1
a2258 1
  return TRUE;
d2283 1
a2283 1
static bfd_boolean
d2397 1
a2397 1
  return TRUE;
d2400 1
a2400 1
static bfd_boolean
d2407 1
a2407 1
static bfd_boolean
d2418 1
a2418 1
	return FALSE;
@


1.30.10.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a53 3
struct elf_s390_link_hash_entry;
static void elf_s390_adjust_gotplt
  PARAMS ((struct elf_s390_link_hash_entry *));
a71 2
static bfd_boolean elf_s390_mkobject
  PARAMS ((bfd *));
a75 10
static int elf_s390_tls_transition
  PARAMS ((struct bfd_link_info *, int, int));
static bfd_reloc_status_type s390_tls_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
static bfd_vma dtpoff_base
  PARAMS ((struct bfd_link_info *));
static bfd_vma tpoff
  PARAMS ((struct bfd_link_info *, bfd_vma));
static void invalid_tls_insn
  PARAMS ((bfd *, asection *, Elf_Internal_Rela *));
d97 22
a118 99
  HOWTO(R_390_8,         0, 0,  8, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_8",        FALSE, 0,0x000000ff, FALSE),
  HOWTO(R_390_12,        0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_12",       FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_16,        0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_16",       FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_32,        0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_32",       FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PC32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32",     FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_GOT12",    FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOT32,	 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT32",    FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_PLT32,	 0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32",    FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_COPY,      0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_COPY",     FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GLOB_DAT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GLOB_DAT", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_JMP_SLOT,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_JMP_SLOT", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_RELATIVE,  0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_RELATIVE", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF32", FALSE, 0,0xffffffff, FALSE),
  HOWTO(R_390_GOTPC,     0, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPC",    FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOT16,     0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOT16",    FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PC16,      0, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16",     FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC16DBL,   1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC16DBL",  FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PLT16DBL,  1, 1, 16,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT16DBL", FALSE, 0,0x0000ffff, TRUE),
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PC32DBL",  FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLT32DBL", FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPCDBL", FALSE, 0,0xffffffff, TRUE),
  EMPTY_HOWTO (R_390_64),	/* Empty entry for R_390_64.  */
  EMPTY_HOWTO (R_390_PC64),	/* Empty entry for R_390_PC64.  */
  EMPTY_HOWTO (R_390_GOT64),	/* Empty entry for R_390_GOT64.  */
  EMPTY_HOWTO (R_390_PLT64),	/* Empty entry for R_390_PLT64.  */
  HOWTO(R_390_GOTENT,	 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTENT",   FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_GOTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTOFF16", FALSE, 0,0x0000ffff, FALSE),
  EMPTY_HOWTO (R_390_GOTOFF64),	/* Empty entry for R_390_GOTOFF64.  */
  HOWTO(R_390_GOTPLT12,  0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_GOTPLT12", FALSE, 0,0x00000fff, FALSE),
  HOWTO(R_390_GOTPLT16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_GOTPLT32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLT32", FALSE, 0,0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_GOTPLT64),	/* Empty entry for R_390_GOTPLT64.  */
  HOWTO(R_390_GOTPLTENT, 1, 2, 32,  TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_GOTPLTENT",FALSE, 0,0xffffffff, TRUE),
  HOWTO(R_390_PLTOFF16,  0, 1, 16, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF16", FALSE, 0,0x0000ffff, FALSE),
  HOWTO(R_390_PLTOFF32,  0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_PLTOFF32", FALSE, 0,0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_PLTOFF64),	/* Empty entry for R_390_PLTOFF64.  */
  HOWTO(R_390_TLS_LOAD, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LOAD", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_GDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_GDCALL", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_LDCALL, 0, 0, 0, FALSE, 0, complain_overflow_dont,
	s390_tls_reloc, "R_390_TLS_LDCALL", FALSE, 0, 0, FALSE),
  HOWTO(R_390_TLS_GD32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GD32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_GD64),	/* Empty entry for R_390_TLS_GD64.  */
  HOWTO(R_390_TLS_GOTIE12, 0, 1, 12, FALSE, 0, complain_overflow_dont,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE12", FALSE, 0, 0x00000fff, FALSE),
  HOWTO(R_390_TLS_GOTIE32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_GOTIE32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_GOTIE64),	/* Empty entry for R_390_TLS_GOTIE64.  */
  HOWTO(R_390_TLS_LDM32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDM32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDM64),	/* Empty entry for R_390_TLS_LDM64.  */
  HOWTO(R_390_TLS_IE32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IE32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_IE64),	/* Empty entry for R_390_TLS_IE64.  */
  HOWTO(R_390_TLS_IEENT, 1, 2, 32, TRUE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_IEENT", FALSE, 0, 0xffffffff, TRUE),
  HOWTO(R_390_TLS_LE32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LE32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_LE64),	/* Empty entry for R_390_TLS_LE64.  */
  HOWTO(R_390_TLS_LDO32, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_LDO32", FALSE, 0, 0xffffffff, FALSE),
  EMPTY_HOWTO (R_390_TLS_LDO64),	/* Empty entry for R_390_TLS_LDO64.  */
  HOWTO(R_390_TLS_DTPMOD, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPMOD", FALSE, 0, 0xffffffff, FALSE),
  HOWTO(R_390_TLS_DTPOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_DTPOFF", FALSE, 0, 0xffffffff, FALSE),
  HOWTO(R_390_TLS_TPOFF, 0, 2, 32, FALSE, 0, complain_overflow_bitfield,
	bfd_elf_generic_reloc, "R_390_TLS_TPOFF", FALSE, 0, 0xffffffff, FALSE),
d163 1
a163 1
      return &elf_howto_table[(int) R_390_GOTOFF32];
a181 42
    case BFD_RELOC_16_GOTOFF:
      return &elf_howto_table[(int) R_390_GOTOFF16];
    case BFD_RELOC_390_GOTPLT12:
      return &elf_howto_table[(int) R_390_GOTPLT12];
    case BFD_RELOC_390_GOTPLT16:
      return &elf_howto_table[(int) R_390_GOTPLT16];
    case BFD_RELOC_390_GOTPLT32:
      return &elf_howto_table[(int) R_390_GOTPLT32];
    case BFD_RELOC_390_GOTPLTENT:
      return &elf_howto_table[(int) R_390_GOTPLTENT];
    case BFD_RELOC_390_PLTOFF16:
      return &elf_howto_table[(int) R_390_PLTOFF16];
    case BFD_RELOC_390_PLTOFF32:
      return &elf_howto_table[(int) R_390_PLTOFF32];
    case BFD_RELOC_390_TLS_LOAD:
      return &elf_howto_table[(int) R_390_TLS_LOAD];
    case BFD_RELOC_390_TLS_GDCALL:
      return &elf_howto_table[(int) R_390_TLS_GDCALL];
    case BFD_RELOC_390_TLS_LDCALL:
      return &elf_howto_table[(int) R_390_TLS_LDCALL];
    case BFD_RELOC_390_TLS_GD32:
      return &elf_howto_table[(int) R_390_TLS_GD32];
    case BFD_RELOC_390_TLS_GOTIE12:
      return &elf_howto_table[(int) R_390_TLS_GOTIE12];
    case BFD_RELOC_390_TLS_GOTIE32:
      return &elf_howto_table[(int) R_390_TLS_GOTIE32];
    case BFD_RELOC_390_TLS_LDM32:
      return &elf_howto_table[(int) R_390_TLS_LDM32];
    case BFD_RELOC_390_TLS_IE32:
      return &elf_howto_table[(int) R_390_TLS_IE32];
    case BFD_RELOC_390_TLS_IEENT:
      return &elf_howto_table[(int) R_390_TLS_IEENT];
    case BFD_RELOC_390_TLS_LE32:
      return &elf_howto_table[(int) R_390_TLS_LE32];
    case BFD_RELOC_390_TLS_LDO32:
      return &elf_howto_table[(int) R_390_TLS_LDO32];
    case BFD_RELOC_390_TLS_DTPMOD:
      return &elf_howto_table[(int) R_390_TLS_DTPMOD];
    case BFD_RELOC_390_TLS_DTPOFF:
      return &elf_howto_table[(int) R_390_TLS_DTPOFF];
    case BFD_RELOC_390_TLS_TPOFF:
      return &elf_howto_table[(int) R_390_TLS_TPOFF];
a216 17
/* A relocation function which doesn't do anything.  */
static bfd_reloc_status_type
s390_tls_reloc (abfd, reloc_entry, symbol, data, input_section,
                      output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  if (output_bfd)
    reloc_entry->address += input_section->output_offset;
  return bfd_reloc_ok;
}

a415 21

  /* Number of GOTPLT references for a function.  */
  bfd_signed_vma gotplt_refcount;

#define GOT_UNKNOWN	0
#define GOT_NORMAL	1
#define GOT_TLS_GD	2
#define GOT_TLS_IE	3
#define GOT_TLS_IE_NLT	4
  unsigned char tls_type;
};

#define elf_s390_hash_entry(ent) \
  ((struct elf_s390_link_hash_entry *)(ent))

struct elf_s390_obj_tdata
{
  struct elf_obj_tdata root;

  /* tls_type for each local got entry.  */
  char *local_got_tls_type;
a417 33
#define elf_s390_tdata(abfd) \
  ((struct elf_s390_obj_tdata *) (abfd)->tdata.any)

#define elf_s390_local_got_tls_type(abfd) \
  (elf_s390_tdata (abfd)->local_got_tls_type)

static bfd_boolean
elf_s390_mkobject (abfd)
     bfd *abfd;
{
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  abfd->tdata.any = bfd_zalloc (abfd, amt);
  if (abfd->tdata.any == NULL)
    return FALSE;
  return TRUE;
}

static bfd_boolean
elf_s390_object_p (abfd)
     bfd *abfd;
{
  /* Allocate our special target data.  */
  struct elf_s390_obj_tdata *new_tdata;
  bfd_size_type amt = sizeof (struct elf_s390_obj_tdata);
  new_tdata = bfd_zalloc (abfd, amt);
  if (new_tdata == NULL)
    return FALSE;
  new_tdata->root = *abfd->tdata.elf_obj_data;
  abfd->tdata.any = new_tdata;
  /* Set the right machine number for an s390 elf32 file.  */
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_31);
}

a432 5
  union {
    bfd_signed_vma refcount;
    bfd_vma offset;
  } tls_ldm_got;

a467 2
      eh->gotplt_refcount = 0;
      eh->tls_type = GOT_UNKNOWN;
a498 1
  ret->tls_ldm_got.refcount = 0;
a610 7
  if (ind->root.type == bfd_link_hash_indirect
      && dir->got.refcount <= 0)
    {
      edir->tls_type = eind->tls_type;
      eind->tls_type = GOT_UNKNOWN;
    }

a613 27
static int
elf_s390_tls_transition (info, r_type, is_local)
     struct bfd_link_info *info;
     int r_type;
     int is_local;
{
  if (info->shared)
    return r_type;

  switch (r_type)
    {
    case R_390_TLS_GD32:
    case R_390_TLS_IE32:
      if (is_local)
	return R_390_TLS_LE32;
      return R_390_TLS_IE32;
    case R_390_TLS_GOTIE32:
      if (is_local)
	return R_390_TLS_LE32;
      return R_390_TLS_GOTIE32;
    case R_390_TLS_LDM32:
      return R_390_TLS_LE32;
    }

  return r_type;
}

a630 2
  bfd_signed_vma *local_got_refcounts;
  int tls_type, old_tls_type;
a637 1
  local_got_refcounts = elf_local_got_refcounts (abfd);
a643 1
      unsigned int r_type;
d662 1
a662 6
      /* Create got section and local_got_refcounts array if they
	 are needed.  */
      r_type = elf_s390_tls_transition (info,
					ELF32_R_TYPE (rel->r_info),
					h == NULL);
      switch (r_type)
d665 1
a665 1
	case R_390_GOT16:
d668 6
a673 12
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	case R_390_TLS_GD32:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE32:
	case R_390_TLS_IEENT:
	case R_390_TLS_IE32:
	case R_390_TLS_LDM32:
	  if (h == NULL
	      && local_got_refcounts == NULL)
d675 4
a678 6
	      bfd_size_type size;
	      
	      size = symtab_hdr->sh_info;
	      size *= (sizeof (bfd_signed_vma) + sizeof(char));
	      local_got_refcounts = ((bfd_signed_vma *)
				     bfd_zalloc (abfd, size));
d680 12
a691 4
		return FALSE;
	      elf_local_got_refcounts (abfd) = local_got_refcounts;
	      elf_s390_local_got_tls_type (abfd)
		= (char *) (local_got_refcounts + symtab_hdr->sh_info);
d693 3
a695 3
	  /* Fall through.  */
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
a704 9
	}

      switch (r_type)
	{
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	  /* Got is created, nothing to be done.  */
a709 2
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
d719 2
a720 6
	  if (h != NULL)
	    {
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount += 1;
	    }
	  break;
d722 2
a723 20
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  /* This symbol requires either a procedure linkage table entry
	     or an entry in the local got. We actually build the entry
	     in adjust_dynamic_symbol because whether this is really a
	     global reference can change and with it the fact if we have
	     to create a plt entry or a local got entry. To be able to
	     make a once global symbol a local one we have to keep track
	     of the number of gotplt references that exist for this
	     symbol.  */
	  if (h != NULL)
	    {
	      ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount++;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	      h->plt.refcount += 1;
	    }
	  else
	    local_got_refcounts[r_symndx] += 1;
a725 83
	case R_390_TLS_LDM32:
	  htab->tls_ldm_got.refcount += 1;
	  break;

	case R_390_TLS_IE32:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE32:
	case R_390_TLS_IEENT:
	  if (info->shared)
	    info->flags |= DF_STATIC_TLS;
	  /* Fall through */

	case R_390_GOT12:
        case R_390_GOT16:
	case R_390_GOT32:
	case R_390_GOTENT:
	case R_390_TLS_GD32:
	  /* This symbol requires a global offset table entry.  */
	  switch (r_type)
	    {
	    default:
	    case R_390_GOT12:
	    case R_390_GOT16:
	    case R_390_GOT32:
	    case R_390_GOTENT:
	      tls_type = GOT_NORMAL;
	      break;
	    case R_390_TLS_GD32:
	      tls_type = GOT_TLS_GD;
	      break;
	    case R_390_TLS_IE32:
	    case R_390_TLS_GOTIE32:
	      tls_type = GOT_TLS_IE;
	      break;
	    case R_390_TLS_GOTIE12:
	    case R_390_TLS_IEENT:
	      tls_type = GOT_TLS_IE_NLT;
	      break;
	    }

	  if (h != NULL)
	    {
	      h->got.refcount += 1;
	      old_tls_type = elf_s390_hash_entry(h)->tls_type;
	    }
	  else
	    {
	      local_got_refcounts[r_symndx] += 1;
	      old_tls_type = elf_s390_local_got_tls_type (abfd) [r_symndx];
	    }
	  /* If a TLS symbol is accessed using IE at least once,
	     there is no point to use dynamic model for it.  */
	  if (old_tls_type != tls_type && old_tls_type != GOT_UNKNOWN)
	    {
	      if (old_tls_type == GOT_NORMAL || tls_type == GOT_NORMAL)
		{
		  (*_bfd_error_handler)
		    (_("%s: `%s' accessed both as normal and thread local symbol"),
		     bfd_archive_filename (abfd), h->root.root.string);
		  return FALSE;
		}
	      if (old_tls_type > tls_type)
		tls_type = old_tls_type;
	    }

	  if (old_tls_type != tls_type)
	    {
	      if (h != NULL)
		elf_s390_hash_entry (h)->tls_type = tls_type;
	      else
		elf_s390_local_got_tls_type (abfd) [r_symndx] = tls_type;
	    }

	  if (r_type != R_390_TLS_IE32)
	    break;
	  /* Fall through */

	case R_390_TLS_LE32:
	  if (!info->shared)
	    break;
	  info->flags |= DF_STATIC_TLS;
	  /* Fall through */	    

a957 1
  int r_type;
d968 22
a989 2
    {
      r_symndx = ELF32_R_SYM (rel->r_info);
d991 16
a1006 4
      if (r_symndx < symtab_hdr->sh_info)
	h = NULL;
      else
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];
d1008 2
a1009 9
      r_type = elf_s390_tls_transition (info,
					ELF32_R_TYPE (rel->r_info),
					r_symndx >= symtab_hdr->sh_info);
      switch (r_type)
	{
	case R_390_TLS_LDM32:
	  if (elf_s390_hash_table (info)->tls_ldm_got.refcount > 0)
	    elf_s390_hash_table (info)->tls_ldm_got.refcount -= 1;
	  break;
d1011 1
a1011 78
	case R_390_TLS_GD32:
	case R_390_TLS_IE32:
	case R_390_TLS_GOTIE12:
	case R_390_TLS_GOTIE32:
	case R_390_TLS_IEENT:
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT32:
	case R_390_GOTOFF16:
	case R_390_GOTOFF32:
	case R_390_GOTPC:
	case R_390_GOTPCDBL:
	case R_390_GOTENT:
	  if (h != NULL)
	    {
	      if (h->got.refcount > 0)
		h->got.refcount -= 1;
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  if (r_type != R_390_TLS_IE32)
	    break;
	  /* Fall through */
	  
	case R_390_TLS_LE32:
	  if (!info->shared)
	    break;
	  /* Fall through */

	case R_390_8:
	case R_390_12:
	case R_390_16:
	case R_390_32:
	case R_390_PC16:
	case R_390_PC16DBL:
	case R_390_PC32DBL:
	case R_390_PC32:
	  if (h != NULL)
	    {
	      struct elf_s390_link_hash_entry *eh;
	      struct elf_s390_dyn_relocs **pp;
	      struct elf_s390_dyn_relocs *p;
	      
	      if (!info->shared && h->plt.refcount > 0)
		h->plt.refcount -= 1;
	      
	      eh = (struct elf_s390_link_hash_entry *) h;
	      
	      for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
		if (p->sec == sec)
		  {
		    if (ELF32_R_TYPE (rel->r_info) == R_390_PC16
			|| ELF32_R_TYPE (rel->r_info) == R_390_PC16DBL
			|| ELF32_R_TYPE (rel->r_info) == R_390_PC32DBL
			|| ELF32_R_TYPE (rel->r_info) == R_390_PC32)
		      p->pc_count -= 1;
		    p->count -= 1;
		    if (p->count == 0)
		      *pp = p->next;
		    break;
		  }
	    }
	  break;
	  
	case R_390_PLT16DBL:
	case R_390_PLT32DBL:
	case R_390_PLT32:
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
		h->plt.refcount -= 1;
	    }
	  break;
d1013 2
a1014 7
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  if (h != NULL)
	    {
	      if (h->plt.refcount > 0)
d1016 9
a1024 2
		  ((struct elf_s390_link_hash_entry *) h)->gotplt_refcount--;
		  h->plt.refcount -= 1;
d1026 14
a1039 7
	    }
	  else if (local_got_refcounts != NULL)
	    {
	      if (local_got_refcounts[r_symndx] > 0)
		local_got_refcounts[r_symndx] -= 1;
	    }
	  break;
d1041 3
a1043 4
	default:
	  break;
	}
    }
a1047 23
/* Make sure we emit a GOT entry if the symbol was supposed to have a PLT
   entry but we found we will not create any.  Called when we find we will
   not have any PLT for this symbol, by for example
   elf_s390_adjust_dynamic_symbol when we're doing a proper dynamic link,
   or elf_s390_size_dynamic_sections if no dynamic sections will be
   created (we're only linking static objects).  */

static void
elf_s390_adjust_gotplt (h)
     struct elf_s390_link_hash_entry *h;
{
  if (h->elf.root.type == bfd_link_hash_warning)
    h = (struct elf_s390_link_hash_entry *) h->elf.root.u.i.link;

  if (h->gotplt_refcount <= 0)
    return;

  /* We simply add the number of gotplt references to the number
   * of got references for this symbol.  */
  h->elf.got.refcount += h->gotplt_refcount;
  h->gotplt_refcount = -1;
}

a1084 1
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
a1220 3
    /* When warning symbols are created, they **replace** the "real"
       entry in the hash table, thus we never get to see the real
       symbol in a hash traversal.  So look at it now.  */
a1274 1
	  elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
a1280 1
      elf_s390_adjust_gotplt((struct elf_s390_link_hash_entry *) h);
d1283 2
a1284 22
  /* If R_390_TLS_{IE32,GOTIE32,GOTIE12,IEENT} symbol is now local to
     the binary, we can optimize a bit. IE32 and GOTIE32 get converted
     to R_390_TLS_LE32 requiring no TLS entry. For GOTIE12 and IEENT
     we can save the dynamic TLS relocation.  */
  if (h->got.refcount > 0
      && !info->shared
      && h->dynindx == -1
      && elf_s390_hash_entry(h)->tls_type >= GOT_TLS_IE)
    {
      if (elf_s390_hash_entry(h)->tls_type == GOT_TLS_IE_NLT)
	/* For the GOTIE access without a literal pool entry the offset has
	   to be stored somewhere. The immediate value in the instruction
	   is not bit enough so the value is stored in the got.  */
	{
	  h->got.offset = htab->sgot->_raw_size;
	  htab->sgot->_raw_size += GOT_ENTRY_SIZE;
	}
      else
	h->got.offset = (bfd_vma) -1;
    }
  else if (h->got.refcount > 0)
   {
a1286 1
      int tls_type = elf_s390_hash_entry(h)->tls_type;
a1299 3
      /* R_390_TLS_GD32 needs 2 consecutive GOT slots.  */
      if (tls_type == GOT_TLS_GD)
	s->_raw_size += GOT_ENTRY_SIZE;
d1301 1
a1301 8
      /* R_390_TLS_IE32 needs one dynamic relocation,
	 R_390_TLS_GD32 needs one if local symbol and two if global.  */
      if ((tls_type == GOT_TLS_GD && h->dynindx == -1)
	  || tls_type >= GOT_TLS_IE)
	htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
      else if (tls_type == GOT_TLS_GD)
	htab->srelgot->_raw_size += 2 * sizeof (Elf32_External_Rela);
      else if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h))
a1446 1
      char *local_tls_type;
a1487 1
      local_tls_type = elf_s390_local_got_tls_type (ibfd);
d1490 1
a1490 1
      for (; local_got < end_local_got; ++local_got, ++local_tls_type)
a1495 2
	      if (*local_tls_type == GOT_TLS_GD)
		s->_raw_size += GOT_ENTRY_SIZE;
a1503 11
  if (htab->tls_ldm_got.refcount > 0)
    {
      /* Allocate 2 got entries and 1 dynamic reloc for R_390_TLS_LDM32
	 relocs.  */
      htab->tls_ldm_got.offset = htab->sgot->_raw_size;
      htab->sgot->_raw_size += 2 * GOT_ENTRY_SIZE;
      htab->srelgot->_raw_size += sizeof (Elf32_External_Rela);
    }
  else
    htab->tls_ldm_got.offset = -1;

a1613 52
/* Return the base VMA address which should be subtracted from real addresses
   when resolving @@dtpoff relocation.
   This is PT_TLS segment p_vaddr.  */

static bfd_vma
dtpoff_base (info)
     struct bfd_link_info *info;
{
  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_segment == NULL)
    return 0;
  return elf_hash_table (info)->tls_segment->start;
}

/* Return the relocation value for @@tpoff relocation
   if STT_TLS virtual address is ADDRESS.  */

static bfd_vma
tpoff (info, address)
     struct bfd_link_info *info;
     bfd_vma address;
{
  struct elf_link_tls_segment *tls_segment
    = elf_hash_table (info)->tls_segment;

  /* If tls_segment is NULL, we should have signalled an error already.  */
  if (tls_segment == NULL)
    return 0;
  return (align_power (tls_segment->size, tls_segment->align)
	  + tls_segment->start - address);
}

/* Complain if TLS instruction relocation is against an invalid
   instruction.  */

static void
invalid_tls_insn (input_bfd, input_section, rel)
     bfd *input_bfd;
     asection *input_section;
     Elf_Internal_Rela *rel;
{
  reloc_howto_type *howto;

  howto = elf_howto_table + ELF32_R_TYPE (rel->r_info);
  (*_bfd_error_handler)
    (_("%s(%s+0x%lx): invalid instruction for TLS relocation %s"),
     bfd_archive_filename (input_bfd),
     bfd_get_section_name (input_bfd, input_section),
     (long) rel->r_offset,
     howto->name);
}

d1647 1
a1647 1
      unsigned int r_type;
a1656 1
      int tls_type;
d1662 1
a1662 1
      if (r_type >= (int) R_390_max)
a1669 2

      /* This is a final link.  */
a1725 33
	case R_390_GOTPLT12:
	case R_390_GOTPLT16:
	case R_390_GOTPLT32:
	case R_390_GOTPLTENT:
	  /* There are three cases for a GOTPLT relocation. 1) The
	     relocation is against the jump slot entry of a plt that
	     will get emitted to the output file. 2) The relocation
	     is against the jump slot of a plt entry that has been
	     removed. elf_s390_adjust_gotplt has created a GOT entry
	     as replacement. 3) The relocation is against a local symbol.
	     Cases 2) and 3) are the same as the GOT relocation code
	     so we just have to test for case 1 and fall through for
	     the other two.  */
	  if (h != NULL && h->plt.offset != (bfd_vma) -1)
	    {
	      bfd_vma plt_index;

	      /* Calc. index no.
		 Current offset - size first entry / entry size.  */
	      plt_index = (h->plt.offset - PLT_FIRST_ENTRY_SIZE) /
		PLT_ENTRY_SIZE;
	      
	      /* Offset in GOT is PLT index plus GOT headers(3) times 4,
		 addr & GOT addr.  */
	      relocation = (plt_index + 3) * GOT_ENTRY_SIZE;
	      unresolved_reloc = FALSE;

	      if (r_type == R_390_GOTPLTENT)
		relocation += htab->sgot->output_section->vma;
	      break;
	    }
	  /* Fall through.  */

d1824 1
a1824 2
	  if (   r_type == R_390_GOTENT
	      || r_type == R_390_GOTPLTENT)
d1829 1
a1829 2
	case R_390_GOTOFF16:
        case R_390_GOTOFF32:
a1873 22
	case R_390_PLTOFF16:
	case R_390_PLTOFF32:
          /* Relocation is to the entry for this symbol in the
             procedure linkage table relative to the start of the GOT.  */

	  /* For local symbols or if we didn't make a PLT entry for
	     this symbol resolve the symbol directly.  */
          if (   h == NULL
	      || h->plt.offset == (bfd_vma) -1
	      || htab->splt == NULL)
	    {
	      relocation -= htab->sgot->output_section->vma;
	      break;
	    }

          relocation = (htab->splt->output_section->vma
                        + htab->splt->output_offset
                        + h->plt.offset
			- htab->sgot->output_section->vma);
	  unresolved_reloc = FALSE;
          break;

a1971 324
	  /* Relocations for tls literal pool entries.  */
	case R_390_TLS_IE32:
	  if (info->shared)
	    {
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloc_out (output_bfd, &outrel, loc);
	    }
	  /* Fall through */

	case R_390_TLS_GD32:
	case R_390_TLS_GOTIE32:
	  r_type = elf_s390_tls_transition (info, r_type, h == NULL);
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    {
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (!info->shared && h->dynindx == -1 && tls_type >= GOT_TLS_IE)
		r_type = R_390_TLS_LE32;
	    }
	  if (r_type == R_390_TLS_GD32 && tls_type >= GOT_TLS_IE)
	    r_type = R_390_TLS_IE32;

	  if (r_type == R_390_TLS_LE32)
	    {
	      /* This relocation gets optimized away by the local exec
		 access optimization.  */
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_32 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	      continue;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  if (h != NULL)
	    off = h->got.offset;
	  else
	    {
	      if (local_got_offsets == NULL)
		abort ();

	      off = local_got_offsets[r_symndx];
	    }

	emit_tls_relocs:

	  if ((off & 1) != 0)
	    off &= ~1;
          else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;
	      int dr_type, indx;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      indx = h && h->dynindx != -1 ? h->dynindx : 0;
	      if (r_type == R_390_TLS_GD32)
		dr_type = R_390_TLS_DTPMOD;
	      else
		dr_type = R_390_TLS_TPOFF;
	      if (dr_type == R_390_TLS_TPOFF && indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      outrel.r_info = ELF32_R_INFO (indx, dr_type);
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
		* sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);

	      if (r_type == R_390_TLS_GD32)
		{
		  if (indx == 0)
		    {
	    	      BFD_ASSERT (! unresolved_reloc);
		      bfd_put_32 (output_bfd,
				  relocation - dtpoff_base (info),
				  htab->sgot->contents + off + GOT_ENTRY_SIZE);
		    }
		  else
		    {
		      outrel.r_info = ELF32_R_INFO (indx, R_390_TLS_DTPOFF);
		      outrel.r_offset += GOT_ENTRY_SIZE;
		      outrel.r_addend = 0;
		      htab->srelgot->reloc_count++;
		      loc += sizeof (Elf32_External_Rela);
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }
		}

	      if (h != NULL)
		h->got.offset |= 1;
	      else
		local_got_offsets[r_symndx] |= 1;
	    }

	  if (off >= (bfd_vma) -2)
	    abort ();
	  if (r_type == ELF32_R_TYPE (rel->r_info))
	    {
	      relocation = htab->sgot->output_offset + off;
	      if (r_type == R_390_TLS_IE32 || r_type == R_390_TLS_IEENT)
		relocation += htab->sgot->output_section->vma;
	      unresolved_reloc = FALSE;
	    }
	  else
	    {
	      bfd_put_32 (output_bfd, htab->sgot->output_offset + off,
			  contents + rel->r_offset);
	      continue;
	    }
	  break;

	case R_390_TLS_GOTIE12:
	case R_390_TLS_IEENT:
	  if (h == NULL)
	    {
	      if (local_got_offsets == NULL)
		abort();
	      off = local_got_offsets[r_symndx];
	      if (info->shared)
		goto emit_tls_relocs;
	    }
	  else
	    {
	      off = h->got.offset;
	      tls_type = elf_s390_hash_entry(h)->tls_type;
	      if (info->shared || h->dynindx != -1 || tls_type < GOT_TLS_IE)
		goto emit_tls_relocs;
	    }

	  if (htab->sgot == NULL)
	    abort ();

	  BFD_ASSERT (! unresolved_reloc);
	  bfd_put_32 (output_bfd, -tpoff (info, relocation),
		      htab->sgot->contents + off);
	  relocation = htab->sgot->output_offset + off;
	  if (r_type == R_390_TLS_IEENT)
	    relocation += htab->sgot->output_section->vma;
	  unresolved_reloc = FALSE;
	  break;

	case R_390_TLS_LDM32:
	  if (! info->shared)
	    /* The literal pool entry this relocation refers to gets ignored
	       by the optimized code of the local exec model. Do nothing
	       and the value will turn out zero.  */
	    continue;

	  if (htab->sgot == NULL)
	    abort ();

	  off = htab->tls_ldm_got.offset;
	  if (off & 1)
	    off &= ~1;
	  else
	    {
	      Elf_Internal_Rela outrel;
	      bfd_byte *loc;

	      if (htab->srelgot == NULL)
		abort ();

	      outrel.r_offset = (htab->sgot->output_section->vma
				 + htab->sgot->output_offset + off);

	      bfd_put_32 (output_bfd, 0,
			  htab->sgot->contents + off + GOT_ENTRY_SIZE);
	      outrel.r_info = ELF32_R_INFO (0, R_390_TLS_DTPMOD);
	      outrel.r_addend = 0;
	      loc = htab->srelgot->contents;
	      loc += htab->srelgot->reloc_count++
		* sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	      htab->tls_ldm_got.offset |= 1;
	    }
	  relocation = htab->sgot->output_offset + off;
	  unresolved_reloc = FALSE;	  
	  break;

	case R_390_TLS_LE32:
	  if (info->shared)
	    {
	      /* Linking a shared library with non-fpic code requires
		 a R_390_TLS_TPOFF relocation.  */
	      Elf_Internal_Rela outrel;
	      asection *sreloc;
	      bfd_byte *loc;
	      int indx;

	      outrel.r_offset = rel->r_offset
				+ input_section->output_section->vma
				+ input_section->output_offset;
	      if (h != NULL && h->dynindx != -1)
		indx = h->dynindx;
	      else
		indx = 0;
	      outrel.r_info = ELF32_R_INFO (indx, R_390_TLS_TPOFF);
	      if (indx == 0)
		outrel.r_addend = relocation - dtpoff_base (info);
	      else
		outrel.r_addend = 0;
	      sreloc = elf_section_data (input_section)->sreloc;
	      if (sreloc == NULL)
		abort ();
	      loc = sreloc->contents;
	      loc += sreloc->reloc_count++ * sizeof (Elf32_External_Rela);
	      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
	    }
	  else
	    {
	      BFD_ASSERT (! unresolved_reloc);
	      bfd_put_32 (output_bfd, -tpoff (info, relocation),
			  contents + rel->r_offset);
	    }
	  continue;

	case R_390_TLS_LDO32:
	  if (info->shared || (input_section->flags & SEC_CODE) == 0)
	    relocation -= dtpoff_base (info);
	  else
	    /* When converting LDO to LE, we must negate.  */
	    relocation = -tpoff (info, relocation);
	  break;

	  /* Relocations for tls instructions.  */
	case R_390_TLS_LOAD:
	case R_390_TLS_GDCALL:
	case R_390_TLS_LDCALL:
	  tls_type = GOT_UNKNOWN;
	  if (h == NULL && local_got_offsets)
	    tls_type = elf_s390_local_got_tls_type (input_bfd) [r_symndx];
	  else if (h != NULL)
	    tls_type = elf_s390_hash_entry(h)->tls_type;

	  if (tls_type == GOT_TLS_GD)
	    continue;

	  if (r_type == R_390_TLS_LOAD)
	    {
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		{
		  /* IE->LE transition. Four valid cases:
		     l %rx,0(0,%ry)    -> lr %rx,%ry + bcr 0,0
		     l %rx,0(%ry,0)    -> lr %rx,%ry + bcr 0,0
		     l %rx,0(%ry,%r12) -> lr %rx,%ry + bcr 0,0
		     l %rx,0(%r12,%ry) -> lr %rx,%ry + bcr 0,0 */
		  unsigned int insn, ry;

		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  ry = 0;
		  if ((insn & 0xff00f000) == 0x58000000)
		    /* l %rx,0(%ry,0) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x000f0000);
		  else if ((insn & 0xff0f0000) == 0x58000000)
		    /* l %rx,0(0,%ry) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x0000f000) << 4;
		  else if ((insn & 0xff00f000) == 0x5800c000)
		    /* l %rx,0(%ry,%r12) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x000f0000);
		  else if ((insn & 0xff0f0000) == 0x580c0000)
		    /* l %rx,0(%r12,%ry) -> lr %rx,%ry + bcr 0,0  */
		    ry = (insn & 0x0000f000) << 4;
		  else
		    invalid_tls_insn (input_bfd, input_section, rel);
		  insn = 0x18000700 | (insn & 0x00f00000) | ry;
		  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
		}
	    }
	  else if (r_type == R_390_TLS_GDCALL)
	    {
	      unsigned int insn;

	      insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
	      if ((insn & 0xff000fff) != 0x4d000000)
		invalid_tls_insn (input_bfd, input_section, rel);
	      if (!info->shared && (h == NULL || h->dynindx == -1))
		/* GD->LE transition.
		   bas %r14,0(%rx,%r13) -> bc 0,0  */
		insn = 0x47000000;
	      else
		/* GD->IE transition.
		   bas %r14,0(%rx,%r13) -> l %r2,0(%r2,%r12)  */
		insn = 0x5822c000;
	      bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
	    }
	  else if (r_type == R_390_TLS_LDCALL)
	    {
	      if (!info->shared)
		{
		  unsigned int insn;

		  insn = bfd_get_32 (input_bfd, contents + rel->r_offset);
		  if ((insn & 0xff000fff) != 0x4d000000)
		    invalid_tls_insn (input_bfd, input_section, rel);
		  /* LD->LE transition.
		     bas %r14,0(%rx,%r13) -> bc 0,0  */
		  insn = 0x47000000;
		  bfd_put_32 (output_bfd, insn, contents + rel->r_offset);
		}
	    }
	  continue;

d2186 1
a2186 4
  if (h->got.offset != (bfd_vma) -1
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_GD
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE
      && elf_s390_hash_entry(h)->tls_type != GOT_TLS_IE_NLT)
d2403 7
a2475 1
#define bfd_elf32_mkobject		elf_s390_mkobject
@


1.30.10.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d354 1
a354 1
		output_bfd, error_message)
d938 1
a938 1

d972 2
a973 2
	case R_390_PLT16DBL:
	case R_390_PLT32DBL:
d978 5
a982 5
	     actually build the entry in adjust_dynamic_symbol,
	     because this might be a case of linking PIC code which is
	     never referenced by a dynamic object, in which case we
	     don't need to generate a procedure linkage table entry
	     after all.  */
d985 1
a985 1
	     creating a procedure linkage table entry.  */
d1025 1
a1025 1
	  /* Fall through.  */
d1028 1
a1028 1
	case R_390_GOT16:
d1090 1
a1090 1
	  /* Fall through.  */
d1096 1
a1096 1
	  /* Fall through.  */
d1098 2
a1099 2
	case R_390_8:
	case R_390_16:
d1101 2
a1102 2
	case R_390_PC16:
	case R_390_PC16DBL:
d1219 1
a1220 1

a1233 1

d1256 4
a1259 4
	case R_390_GNU_VTINHERIT:
	  if (!_bfd_elf32_gc_record_vtinherit (abfd, sec, h, rel->r_offset))
	    return FALSE;
	  break;
d1263 4
a1266 4
	case R_390_GNU_VTENTRY:
	  if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
	    return FALSE;
	  break;
d1329 3
a1341 4
      unsigned long r_symndx;
      unsigned int r_type;
      struct elf_link_hash_entry *h = NULL;

a1342 5
      if (r_symndx >= symtab_hdr->sh_info)
	{
	  struct elf_s390_link_hash_entry *eh;
	  struct elf_s390_dyn_relocs **pp;
	  struct elf_s390_dyn_relocs *p;
d1344 4
a1347 2
	  h = sym_hashes[r_symndx - symtab_hdr->sh_info];
	  eh = (struct elf_s390_link_hash_entry *) h;
d1349 3
a1351 11
	  for (pp = &eh->dyn_relocs; (p = *pp) != NULL; pp = &p->next)
	    if (p->sec == sec)
	      {
		/* Everything must go for SEC.  */
		*pp = p->next;
		break;
	      }
	}

      r_type = ELF32_R_TYPE (rel->r_info);
      r_type = elf_s390_tls_transition (info, r_type, h != NULL);
d1382 8
a1389 1
	  break;
d1399 27
a1425 4
	  if (info->shared)
	    break;
	  /* Fall through.  */

d1519 2
a1520 2
	     file, but the symbol was never referred to by a dynamic
	     object, or if all references were garbage collected.  In
a1849 1

d2017 1
a2017 1
	  if (s->_raw_size != 0)
d2082 4
a2085 4
	{
	  if (!add_dynamic_entry (DT_RELA, 0)
	      || !add_dynamic_entry (DT_RELASZ, 0)
	      || !add_dynamic_entry (DT_RELAENT, sizeof (Elf32_External_Rela)))
d2205 2
a2206 2
	  || r_type == (int) R_390_GNU_VTENTRY)
	continue;
d2255 1
d2263 1
a2263 1
		      input_section, rel->r_offset,
d2294 1
a2294 1

d2306 3
a2308 3
	case R_390_GOT12:
	case R_390_GOT16:
	case R_390_GOT32:
d2310 2
a2311 2
	  /* Relocation is to the entry for this symbol in the global
	     offset table.  */
d2315 2
a2316 2
	  if (h != NULL)
	    {
d2319 1
a2319 1
	      off = h->got.offset;
d2321 3
a2323 3
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info, h)
		  || (info->shared
		      && (info->symbolic
d2326 18
a2343 18
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
		{
		  /* This is actually a static link, or it is a
		     -Bsymbolic link and the symbol is defined
		     locally, or the symbol was forced to be local
		     because of a version file.  We must initialize
		     this entry in the global offset table.  Since the
		     offset must always be a multiple of 2, we use the
		     least significant bit to record whether we have
		     initialized it already.

		     When doing a dynamic link, we create a .rel.got
		     relocation entry to initialize the value.  This
		     is done in the finish_dynamic_symbol routine.  */
		  if ((off & 1) != 0)
		    off &= ~1;
		  else
		    {
d2346 3
a2348 3
		      h->got.offset |= 1;
		    }
		}
d2351 3
a2353 3
	    }
	  else
	    {
d2357 1
a2357 1
	      off = local_got_offsets[r_symndx];
d2359 8
a2366 8
	      /* The offset must always be a multiple of 4.  We use
		 the least significant bit to record whether we have
		 already generated the necessary reloc.  */
	      if ((off & 1) != 0)
		off &= ~1;
	      else
		{
		  bfd_put_32 (output_bfd, relocation,
d2369 4
a2372 4
		  if (info->shared)
		    {
		      asection *srelgot;
		      Elf_Internal_Rela outrel;
d2375 1
a2375 1
		      srelgot = htab->srelgot;
d2379 4
a2382 4
		      outrel.r_offset = (htab->sgot->output_section->vma
					 + htab->sgot->output_offset
					 + off);
		      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
d2386 2
a2387 2
		      bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
		    }
d2389 3
a2391 3
		  local_got_offsets[r_symndx] |= 1;
		}
	    }
d2398 6
a2403 4
	  /* For @@GOTENT the relocation is against the offset between
	     the instruction and the symbols entry in the GOT and not
	     between the start of the GOT and the symbols entry. We
	     add the vma of the GOT to get the correct value.  */
d2408 1
a2408 1
	  break;
d2411 11
a2421 11
	case R_390_GOTOFF32:
	  /* Relocation is relative to the start of the global offset
	     table.  */

	  /* Note that sgot->output_offset is not involved in this
	     calculation.  We always want the start of .got.  If we
	     defined _GLOBAL_OFFSET_TABLE in a different way, as is
	     permitted by the ABI, we might have to change this
	     calculation.  */
	  relocation -= htab->sgot->output_section->vma;
	  break;
d2423 1
a2423 1
	case R_390_GOTPC:
d2425 2
a2426 2
	  /* Use global offset table as symbol value.  */
	  relocation = htab->sgot->output_section->vma;
d2428 1
a2428 1
	  break;
d2430 10
a2439 10
	case R_390_PLT16DBL:
	case R_390_PLT32DBL:
	case R_390_PLT32:
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table.  */

	  /* Resolve a PLT32 reloc against a local symbol directly,
	     without using the procedure linkage table.  */
	  if (h == NULL)
	    break;
d2441 1
a2441 1
	  if (h->plt.offset == (bfd_vma) -1
d2443 10
a2452 10
	    {
	      /* We didn't make a PLT entry for this symbol.  This
		 happens when statically linking PIC code, or when
		 using -Bsymbolic.  */
	      break;
	    }

	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset);
d2454 1
a2454 1
	  break;
d2458 2
a2459 2
	  /* Relocation is to the entry for this symbol in the
	     procedure linkage table relative to the start of the GOT.  */
d2463 1
a2463 1
	  if (   h == NULL
d2471 3
a2473 3
	  relocation = (htab->splt->output_section->vma
			+ htab->splt->output_offset
			+ h->plt.offset
d2476 1
a2476 1
	  break;
d2478 7
a2484 7
	case R_390_8:
	case R_390_16:
	case R_390_32:
	case R_390_PC16:
	case R_390_PC16DBL:
	case R_390_PC32DBL:
	case R_390_PC32:
d2488 2
a2489 2
	  if (r_symndx == 0
	      || (input_section->flags & SEC_ALLOC) == 0)
d2492 1
a2492 1
	  if ((info->shared
d2512 3
a2514 3
	    {
	      Elf_Internal_Rela outrel;
	      bfd_boolean skip, relocate;
d2522 2
a2523 2
	      skip = FALSE;
	      relocate = FALSE;
d2532 2
a2533 2
	      outrel.r_offset += (input_section->output_section->vma
				  + input_section->output_offset);
d2535 1
a2535 1
	      if (skip)
d2537 1
a2537 1
	      else if (h != NULL
d2547 2
a2548 2
		{
		  outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
d2550 3
a2552 3
		}
	      else
		{
d2557 1
a2557 1
		}
d2567 7
a2573 7
	      /* If this reloc is against an external symbol, we do
		 not want to fiddle with the addend.  Otherwise, we
		 need to include the symbol value so that it becomes
		 an addend for the dynamic reloc.  */
	      if (! relocate)
		continue;
	    }
d2595 1
a2595 1
	  /* Fall through.  */
d2639 1
a2639 1
	  else
d2670 1
a2670 1
		      BFD_ASSERT (! unresolved_reloc);
d2774 1
a2774 1
	  unresolved_reloc = FALSE;
d2984 2
a2985 1
	 it up.  */
d2993 1
a2993 1
	 Current offset - size first entry / entry size.  */
d2997 1
a2997 1
	 addr & GOT addr.  */
d3002 1
a3002 1
			    (PLT_ENTRY_SIZE * plt_index) + 18) / 2);
d3004 1
a3004 1
	 390 can only handle +-64 K jumps.  */
d3006 2
a3007 2
	relative_offset
	  = -(unsigned) (((65536 / PLT_ENTRY_SIZE - 1) * PLT_ENTRY_SIZE) / 2);
d3012 1
a3012 1
	  bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD0,
d3083 1
a3083 1
		  htab->splt->contents + h->plt.offset + 28);
d3086 1
a3086 1
	 Points to instruction after GOT offset.  */
d3123 1
a3123 1
	 up.  */
d3146 3
a3148 3
			   + h->root.u.def.section->output_section->vma
			   + h->root.u.def.section->output_offset);
	}
d3154 2
a3155 2
	  rela.r_addend = 0;
	}
d3273 2
a3274 2
	  memset (htab->splt->contents, 0, PLT_FIRST_ENTRY_SIZE);
	  if (info->shared)
d3277 1
a3277 1
			  htab->splt->contents );
d3279 1
a3279 1
			  htab->splt->contents +4 );
d3281 1
a3281 1
			  htab->splt->contents +8 );
d3283 1
a3283 1
			  htab->splt->contents +12 );
d3285 18
a3302 18
			  htab->splt->contents +16 );
	   }
	  else
	   {
	      bfd_put_32 (output_bfd, (bfd_vma)PLT_FIRST_ENTRY_WORD0,
			  htab->splt->contents );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD1,
			  htab->splt->contents +4 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD2,
			  htab->splt->contents +8 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD3,
			  htab->splt->contents +12 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD4,
			  htab->splt->contents +16 );
	      bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD5,
			  htab->splt->contents +20 );
	      bfd_put_32 (output_bfd,
			  htab->sgotplt->output_section->vma
d3304 2
a3305 2
			  htab->splt->contents + 24);
	   }
d3380 1
a3380 1
#define elf_info_to_howto		      elf_s390_info_to_howto
d3387 1
a3387 1
#define elf_backend_check_relocs	      elf_s390_check_relocs
d3392 2
a3393 2
#define elf_backend_gc_mark_hook	      elf_s390_gc_mark_hook
#define elf_backend_gc_sweep_hook	      elf_s390_gc_sweep_hook
d3395 1
a3395 1
#define elf_backend_relocate_section	      elf_s390_relocate_section
d3401 1
a3401 1
#define elf_backend_object_p		elf_s390_object_p
@


1.30.10.4
log
@2003-05-23  David Carlton  <carlton@@bactrian.org>

	* Merge with mainline; tag is carlton_dictionary-20030523-merge.
@
text
@a385 6
/* If ELIMINATE_COPY_RELOCS is non-zero, the linker will try to avoid
   copying dynamic variables from a shared lib into an app's dynbss
   section, and instead use a dynamic relocation to point into the
   shared lib.  */
#define ELIMINATE_COPY_RELOCS 1

d831 1
a831 12
  if (ELIMINATE_COPY_RELOCS
      && ind->root.type != bfd_link_hash_indirect
      && (dir->elf_link_hash_flags & ELF_LINK_HASH_DYNAMIC_ADJUSTED) != 0)
    /* If called to transfer flags for a weakdef during processing
       of elf_adjust_dynamic_symbol, don't copy ELF_LINK_NON_GOT_REF.
       We clear it ourselves for ELIMINATE_COPY_RELOCS.  */
    dir->elf_link_hash_flags |=
      (ind->elf_link_hash_flags & (ELF_LINK_HASH_REF_DYNAMIC
				   | ELF_LINK_HASH_REF_REGULAR
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK));
  else
    _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
d1152 1
a1152 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
d1483 2
a1529 4
      if (ELIMINATE_COPY_RELOCS || info->nocopyreloc)
	h->elf_link_hash_flags
	  = ((h->elf_link_hash_flags & ~ELF_LINK_NON_GOT_REF)
	     | (h->weakdef->elf_link_hash_flags & ELF_LINK_NON_GOT_REF));
d1555 2
a1556 1
  if (ELIMINATE_COPY_RELOCS)
d1558 4
a1561 2
      struct elf_s390_link_hash_entry * eh;
      struct elf_s390_dyn_relocs *p;
d1563 6
a1568 15
      eh = (struct elf_s390_link_hash_entry *) h;
      for (p = eh->dyn_relocs; p != NULL; p = p->next)
	{
	  s = p->sec->output_section;
	  if (s != NULL && (s->flags & SEC_READONLY) != 0)
	    break;
	}

      /* If we didn't find any dynamic relocs in read-only sections, then
	 we'll be keeping the dynamic relocs and avoiding the copy reloc.  */
      if (p == NULL)
	{
	  h->elf_link_hash_flags &= ~ELF_LINK_NON_GOT_REF;
	  return TRUE;
	}
d1621 1
a1621 1
#define WILL_CALL_FINISH_DYNAMIC_SYMBOL(DYN, SHARED, H) \
d1623 1
a1623 1
   && ((SHARED)								\
d1654 1
a1654 3
      && h->plt.refcount > 0
      && (ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
	  || h->root.type != bfd_link_hash_undefweak))
d1665 1
a1665 2
      if (info->shared
	  || WILL_CALL_FINISH_DYNAMIC_SYMBOL (1, 0, h))
d1761 1
a1761 4
      else if ((ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		|| h->root.type != bfd_link_hash_undefweak)
	       && (info->shared
		   || WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, 0, h)))
a1794 6

      /* Also discard relocs on undefined weak syms with non-default
	 visibility.  */
      if (ELF_ST_VISIBILITY (h->other) != STV_DEFAULT
	  && h->root.type == bfd_link_hash_undefweak)
	eh->dyn_relocs = NULL;
d1796 1
a1796 1
  else if (ELIMINATE_COPY_RELOCS)
d2304 1
a2304 1
	      if (! WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
d2309 1
a2309 3
		      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR))
		  || (ELF_ST_VISIBILITY (h->other)
		      && h->root.type == bfd_link_hash_undefweak))
a2473 3
	       && (h == NULL
		   || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
		   || h->root.type != bfd_link_hash_undefweak)
d2483 1
a2483 2
	      || (ELIMINATE_COPY_RELOCS
		  && !info->shared
@


1.30.10.5
log
@2003-06-27  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030627-merge.
@
text
@d898 1
a898 1
  if (info->relocatable)
d1930 1
a1930 1
      if (info->executable)
d2088 1
a2088 1
      if (info->executable)
d2201 1
a2201 1
  if (info->relocatable)
@


1.30.10.6
log
@2003-08-05  David Carlton  <carlton@@kealia.com>

	* configure.in (build_warnings): Delete -Wformat-nonliteral.
	* configure (build_warnings): Ditto.

	* Merge with mainline; tag is carlton_dictionary-20030805-merge.
@
text
@a90 2
static bfd_reloc_status_type s390_elf_ldisp_reloc
  PARAMS ((bfd *, arelent *, asymbol *, PTR, asection *, bfd *, char **));
d122 1
a122 1
  HOWTO(R_390_GOT12,	 0, 1, 12, FALSE, 0, complain_overflow_bitfield,
a210 8
  HOWTO(R_390_20,        0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_20",      FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOT20,	 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOT20",   FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_GOTPLT20,  0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_GOTPLT20", FALSE, 0,0x0fffff00, FALSE),
  HOWTO(R_390_TLS_GOTIE20, 0, 2, 20, FALSE, 8, complain_overflow_dont,
	s390_elf_ldisp_reloc, "R_390_TLS_GOTIE20", FALSE, 0,0x0fffff00, FALSE),
a315 8
    case BFD_RELOC_390_20:
      return &elf_howto_table[(int) R_390_20];
    case BFD_RELOC_390_GOT20:
      return &elf_howto_table[(int) R_390_GOT20];
    case BFD_RELOC_390_GOTPLT20:
      return &elf_howto_table[(int) R_390_GOTPLT20];
    case BFD_RELOC_390_TLS_GOTIE20:
      return &elf_howto_table[(int) R_390_TLS_GOTIE20];
a367 53
/* Handle the large displacement relocs.  */
static bfd_reloc_status_type
s390_elf_ldisp_reloc (abfd, reloc_entry, symbol, data, input_section,
                      output_bfd, error_message)
     bfd *abfd ATTRIBUTE_UNUSED;
     arelent *reloc_entry;
     asymbol *symbol;
     PTR data ATTRIBUTE_UNUSED;
     asection *input_section;
     bfd *output_bfd;
     char **error_message ATTRIBUTE_UNUSED;
{
  reloc_howto_type *howto = reloc_entry->howto;
  bfd_vma relocation;
  bfd_vma insn;
  
  if (output_bfd != (bfd *) NULL
      && (symbol->flags & BSF_SECTION_SYM) == 0
      && (! howto->partial_inplace
	  || reloc_entry->addend == 0))
    {
      reloc_entry->address += input_section->output_offset;
      return bfd_reloc_ok;
    }
  
  if (output_bfd != NULL)
    return bfd_reloc_continue;
  
  if (reloc_entry->address > input_section->_cooked_size)
    return bfd_reloc_outofrange;
  
  relocation = (symbol->value
		+ symbol->section->output_section->vma
		+ symbol->section->output_offset);
  relocation += reloc_entry->addend;
  if (howto->pc_relative)
    {
      relocation -= (input_section->output_section->vma
		     + input_section->output_offset);
      relocation -= reloc_entry->address;
    }
  
  insn = bfd_get_32 (abfd, (bfd_byte *) data + reloc_entry->address);
  insn |= (relocation & 0xfff) << 16 | (relocation & 0xff000) >> 4;
  bfd_put_32 (abfd, insn, (bfd_byte *) data + reloc_entry->address);
  
  if ((bfd_signed_vma) relocation < - 0x80000
      || (bfd_signed_vma) relocation > 0x7ffff)
    return bfd_reloc_overflow;
  else
    return bfd_reloc_ok;
}

a938 1
	case R_390_GOT20:
a942 1
	case R_390_GOTPLT20:
a946 1
	case R_390_TLS_GOTIE20:
a1011 1
	case R_390_GOTPLT20:
a1037 1
	case R_390_TLS_GOTIE20:
a1045 1
	case R_390_GOT20:
a1054 1
	    case R_390_GOT20:
a1066 1
	    case R_390_TLS_GOTIE20:
a1392 1
	case R_390_TLS_GOTIE20:
a1396 1
	case R_390_GOT20:
a1417 1
	case R_390_20:
a1440 1
	case R_390_GOTPLT20:
d2276 1
a2276 1
	  else if (!info->executable
a2295 1
	case R_390_GOTPLT20:
a2328 1
	case R_390_GOT20:
a2734 1
	case R_390_TLS_GOTIE20:
d2942 3
a2944 15
      if (r_type == R_390_20
	  || r_type == R_390_GOT20
	  || r_type == R_390_GOTPLT20
	  || r_type == R_390_TLS_GOTIE20)
	{
	  relocation += rel->r_addend;
	  relocation = (relocation&0xfff) << 8 | (relocation&0xff000) >> 12;
	  r = _bfd_final_link_relocate (howto, input_bfd, input_section,
					contents, rel->r_offset,
					relocation, 0);
	}
      else
	r = _bfd_final_link_relocate (howto, input_bfd, input_section,
				      contents, rel->r_offset,
				      relocation, rel->r_addend);
@


1.30.10.7
log
@2003-09-17  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20030917-merge.
@
text
@d43 1
a43 1
  PARAMS ((const struct elf_backend_data *, struct elf_link_hash_entry *,
d859 1
a859 1
     const struct elf_backend_data *bed;
d2334 4
a2337 1
	  bfd_boolean warned ATTRIBUTE_UNUSED;
d2339 34
a2372 4
	  RELOC_FOR_GLOBAL_SYMBOL (h, sym_hashes, r_symndx,
				   symtab_hdr, relocation, sec,
				   unresolved_reloc, info,
				   warned);
@


1.30.10.8
log
@2003-11-11  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton-dictionary-20031111-merge.
@
text
@d2219 2
a2220 2
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (elf_hash_table (info)->tls_sec == NULL)
d2222 1
a2222 1
  return elf_hash_table (info)->tls_sec->vma;
d2233 2
a2234 1
  struct elf_link_hash_table *htab = elf_hash_table (info);
d2236 2
a2237 2
  /* If tls_sec is NULL, we should have signalled an error already.  */
  if (htab->tls_sec == NULL)
d2239 2
a2240 1
  return htab->tls_size + htab->tls_sec->vma - address;
d2330 1
a2330 1
	  relocation = _bfd_elf_rela_local_sym (output_bfd, sym, &sec, rel);
d3466 1
@


1.30.10.9
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d487 1
a487 1
   The code for position independent PLT entries looks like this:
d688 8
d917 1
a917 2
				   | ELF_LINK_HASH_REF_REGULAR_NONWEAK
				   | ELF_LINK_HASH_NEEDS_PLT));
d2629 2
a2631 34
		  if (r_type == R_390_32)
		    {
		      relocate = TRUE;
		      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
		    }
		  else
		    {
		      long sindx;

		      if (bfd_is_abs_section (sec))
			sindx = 0;
		      else if (sec == NULL || sec->owner == NULL)
			{
			  bfd_set_error(bfd_error_bad_value);
			  return FALSE;
			}
		      else
			{
			  asection *osec;

			  osec = sec->output_section;
			  sindx = elf_section_data (osec)->dynindx;
			  BFD_ASSERT (sindx > 0);

			  /* We are turning this relocation into one
			     against a section symbol, so subtract out
			     the output section's address but not the
			     offset of the input section in the output
			     section.  */

			  outrel.r_addend -= osec->vma;
			}
		      outrel.r_info = ELF32_R_INFO (sindx, r_type);
		    }
@


1.29
log
@	* elf-hppa.h (elf_hppa_relocate_section): If relocatable, return
	immediately.  Remove code handling relocatable linking.
	* elf32-avr.c (elf32_avr_relocate_section): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf32-vax.c (elf_vax_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf32-avr.c (elf_backend_rela_normal): Define.
	* elf32-cris.c: Likewise.
	* elf32-fr30.c: Likewise.
	* elf32-h8300.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf32-fr30.c (elf32_frv_relocate_section): Edit comment.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-ip2k.c (ip2k_elf_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf-m10200.c (USE_RELA): Don't define.
	* elf-m10300.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-ip2k.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-avr.c (USE_REL): Don't undef.
	* elf32-ip2k.c: Likewise.
@
text
@d43 2
a44 1
  PARAMS ((struct elf_link_hash_entry *, struct elf_link_hash_entry *));
d566 2
a567 1
elf_s390_copy_indirect_symbol (dir, ind)
d609 1
a609 1
  _bfd_elf_link_hash_copy_indirect (dir, ind);
@


1.28
log
@	* elf32-i386.c (elf_i386_relocate_section): Don't complain about
	unresolved debugging relocs in dynamic applications.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
@
text
@a73 2
#define USE_RELA 1		/* We want RELA relocations, not REL.  */

@


1.28.2.1
log
@	* elf-bfd.h (struct elf_backend_data): Add struct elf_backend_data
	param to elf_backend_copy_indirect_symbol.
	(_bfd_elf_link_hash_copy_indirect): Likewise.
	* elflink.h (elf_add_default_symbol, elf_fix_symbol_flags): Adjust
	calls to copy_indirect_symbol.
	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Likewise.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf32-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
	* elf64-s390.c (elf_s390_copy_indirect_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_copy_indirect_symbol): Likewise.
	* elfxx-ia64.c (elfNN_ia64_hash_copy_indirect): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_copy_indirect_symbol): Likewise.
	* elf.c (_bfd_elf_link_hash_copy_indirect): Likewise.  Properly
	test refcounts for "used" values.
@
text
@d43 1
a43 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d567 1
a567 2
elf_s390_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d609 1
a609 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.27
log
@	* elflink.h (elf_gc_mark): Pass in the section whose relocs we are
	examining to gc_mark_hook, rather than the bfd.
	(elf_gc_sections): Adjust.
	* elf-bfd.h (struct elf_backend_data <gc_mark_hook>): Likewise.
	* elf-m10300.c (mn10300_elf_gc_mark_hook): Likewise.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-vax.c (elf_vax_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-sh64.c (sh_elf64_gc_mark_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elfxx-mips.h (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.
	* elf32-frv.c (elf32_frv_gc_mark_hook): Likewise.  Also remove
	redundant local sym tests.
	* elf64-ppc.c (struct ppc_link_hash_entry): Add is_entry.
	(link_hash_newfunc): Init is_entry.
	(ppc64_elf_copy_indirect_symbol): Copy is_entry.
	(ppc64_elf_link_hash_table_create): Init all_local_syms.
	(create_linkage_sections): Use bfd_make_section_anyway rather than
	bfd_make_section.
	(ppc64_elf_mark_entry_syms): New function.
	(ppc64_elf_check_relocs): Don't bother testing elf_bad_symtab.  Set
	up opd entry to function section map.
	(ppc64_elf_gc_mark_hook): Special case opd section relocs, and
	relocs that reference the opd section.
	(edit_opd): New function.
	(ppc64_elf_size_dynamic_sections): Call get_local_syms and edit_opd.
	(ppc64_elf_setup_section_lists): Don't calculate htab->bfd_count here.
	(get_local_syms): Do so here.  Exit if we already have local syms.
	Remove bogus comment imported from elf32-hppa.c.  Don't attempt to
	read local syms on non-ELF input.
	(ppc64_elf_size_stubs): Call _bfd_elf64_link_read_relocs rather
	than duplicating it's function here.  Adjust free of internal
	relocs to suit.
	(ppc64_elf_relocate_section): Adjust local syms in opd section.
	* elf64-ppc.h (ppc64_elf_mark_entry_syms): Declare.
	* elf32-hppa.c (elf32_hppa_size_stubs): Call
	_bfd_elf32_link_read_relocs rather than duplicating it's function
	here.  Adjust free of internal relocs to suit.
@
text
@d1974 3
d1978 1
a1978 2
	  && !(info->shared
	       && (input_section->flags & SEC_DEBUGGING) != 0
@


1.26
log
@	* elf32-arc.c: Fix formatting.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-dlx.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-i386qnx.c: Likewise.
	* elf32-or32.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
@
text
@d48 1
a48 1
  PARAMS ((bfd *, struct bfd_link_info *, Elf_Internal_Rela *,
d906 2
a907 2
elf_s390_gc_mark_hook (abfd, info, rel, h, sym)
     bfd *abfd;
d937 1
a937 3
    {
      return bfd_section_from_elf_index (abfd, sym->st_shndx);
    }
@


1.25
log
@	* elf-bfd.h (struct elf_backend_data): Add rela_normal.
	* elfxx-target.h (elf_backend_rela_normal): Define.
	(elfNN_bed): Init rela_normal.
	* elflink.h (elf_link_input_bfd <emit_relocs>): Handle adjustment
	for section symbols here if rela_normal.  Simplify abs section test.
	* elf-m10200.c (mn10200_elf_relocate_section): If relocatable,
	return immediately.  Remove code handling relocatable linking.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elf32-fr30.c (fr30_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise #ifndef USE_REL.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf-m10200.c (elf_backend_rela_normal): Define.
	* elf-m10300.c (elf_backend_rela_normal): Define.
	* elf32-fr30.c (elf_backend_rela_normal): Define.
	* elf32-i370.c (elf_backend_rela_normal): Define.
	* elf32-i860.c (elf_backend_rela_normal): Define.
	* elf32-m68k.c (elf_backend_rela_normal): Define.
	* elf32-mcore.c (elf_backend_rela_normal): Define.
	* elf32-openrisc.c (elf_backend_rela_normal): Define.
	* elf32-ppc.c (elf_backend_rela_normal): Define.
	* elf32-s390.c (elf_backend_rela_normal): Define.
	* elf32-xstormy16.c (elf_backend_rela_normal): Define.
	* elf64-ppc.c (elf_backend_rela_normal): Define.
	* elf64-s390.c (elf_backend_rela_normal): Define.
	* elf64-x86-64.c (elf_backend_rela_normal): Define.
	* elfxx-ia64.c (elf_backend_rela_normal): Define.
	* elf32-arm.h (elf_backend_rela_normal): Define #ifndef USE_REL.
	* elf32-m32r.c (elf_backend_rela_normal): Likewise.
@
text
@d1067 1
a1067 1
     (although we could actually do it here). */
@


1.25.4.1
log
@Merge with mainline, kseitz_interps-20020619-merge.
@
text
@d1067 1
a1067 1
     (although we could actually do it here).  */
@


1.25.4.2
log
@Merge w/trunk (kseitz_interps-20020722-merge).
@
text
@d48 1
a48 1
  PARAMS ((asection *, struct bfd_link_info *, Elf_Internal_Rela *,
d906 2
a907 2
elf_s390_gc_mark_hook (sec, info, rel, h, sym)
     asection *sec;
d937 3
a939 1
    return bfd_section_from_elf_index (sec->owner, sym->st_shndx);
a1975 3
      /* Dynamic relocs are not propagated for SEC_DEBUGGING sections
	 because such sections are not SEC_ALLOC and thus ld.so will
	 not process them.  */
d1977 2
a1978 1
	  && !((input_section->flags & SEC_DEBUGGING) != 0
@


1.25.4.3
log
@Merge with kseitz_interps-20020809-merge of CVS head.
@
text
@d74 2
@


1.25.4.4
log
@Merge with kseitz_interps-20020829-merge tag from trunk.
@
text
@d43 1
a43 2
  PARAMS ((struct elf_backend_data *, struct elf_link_hash_entry *,
	   struct elf_link_hash_entry *));
d565 1
a565 2
elf_s390_copy_indirect_symbol (bed, dir, ind)
     struct elf_backend_data *bed;
d607 1
a607 1
  _bfd_elf_link_hash_copy_indirect (bed, dir, ind);
@


1.25.2.1
log
@merge from trunk
@
text
@d1067 1
a1067 1
     (although we could actually do it here).  */
@


1.24
log
@2002-04-04  Daniel Jacobowitz  <drow@@mvista.com>

	* aout-adobe.c (aout_32_bfd_link_hash_table_free): Define.
	* aout-target.h (MY_bfd_link_hash_table_free): Conditionally
	define.
	* aout-tic30.c (MY_bfd_link_hash_table_free): Likewise.
	* bfd.c (bfd_link_hash_table_free): Define.
	* binary.c (binary_bfd_link_hash_table_free): Define.
	* bout.c (b_out_bfd_link_hash_table_free): Define.
	* coff-rs6000.c (rs6000coff_vec): Include
	_bfd_generic_link_hash_table_free.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_link_hash_table_free): Conditionally define.
	* elf-m10300.c (elf32_mn10300_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elf32-hppa.c (elf32_hppa_link_hash_table_free): New function.
	(bfd_elf32_bfd_link_hash_table_free): Define.
	* elfxx-target.h (bfd_elfNN_bfd_link_hash_table_free): Conditionally
	define.
	* i386msdos.c (msdos_bfd_link_hash_table_free): Define.
	* i386os9k.c (os9k_bfd_link_hash_table_free): Define.
	* ieee.c (ieee_bfd_link_hash_table_free): Define.
	* ihex.c (ihex_bfd_link_hash_table_free): Define.
	* libbfd-in.h (_bfd_nolink_bfd_link_hash_table_free): Define.
	(_bfd_generic_link_hash_table_free): Add prototype.
	* libcoff-in.h (_bfd_xcoff_bfd_link_hash_table_free): Add prototype.
	* libecoff.h (_bfd_ecoff_bfd_link_hash_table_free): Define.
	* linker.c (_bfd_generic_link_hash_table_free): New function.
	* mmo.c (mmo_bfd_link_hash_table_free): Define.
	* nlm-target.h (nlm_bfd_link_hash_table_free): Define.
	* oasys.c (oasys_bfd_link_hash_table_free): Define.
	* ppcboot.c (ppcboot_bfd_link_hash_table_free): Define.
	* som.c (som_bfd_link_hash_table_free): Define.
	* srec.c (srec_bfd_link_hash_table_free): Define.
	* tekhex.c (tekhex_bfd_link_hash_table_free): Define.
	* versados.c (versados_bfd_link_hash_table_free): Define.
	* vms.c (vms_bfd_link_hash_table_free): New function.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_free): New function.

	* coff-arm.c (coff_arm_link_hash_table_create): Use bfd_malloc
	instead of bfd_alloc.
	* coff-h8300.c (h8300_coff_link_hash_table_create): Likewise.
	* coff-mcore.c (coff_mcore_link_hash_table_create): Likewise.
	* coff-ppc.c (ppc_coff_link_hash_table_create): Likewise.
	* cofflink.c (_bfd_coff_link_hash_table_create): Likewise.
	* ecoff.c (_bfd_ecoff_bfd_link_hash_table_create): Likewise.
	* elf-m10300.c (elf32_mn10300_link_hash_table_create): Likewise.
	* elf.c (_bfd_elf_link_hash_table_create): Likewise.
	* elf32-arm.h (elf32_arm_link_hash_table_create): Likewise.
	* elf32-cris.c (elf_cris_link_hash_table_create): Likewise.
	* elf32-hppa.c (elf32_hppa_link_hash_table_create): Likewise.
	* elf32-i386.c (elf_i386_link_hash_table_create): Likewise.
	* elf32-m68k.c (elf_m68k_link_hash_table_create): Likewise.
	* elf32-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf32-sh.c (sh_elf_link_hash_table_create): Likewise.
	* elf64-alpha.c (elf64_alpha_bfd_link_hash_table_create): Likewise.
	* elf64-ppc.c (ppc64_elf_link_hash_table_create): Likewise.
	* elf64-s390.c (elf_s390_link_hash_table_create): Likewise.
	* elf64-sh64.c (sh64_elf64_link_hash_table_create): Likewise.
	* elf64-sparc.c (sparc64_elf_bfd_link_hash_table_create): Likewise.
	* elf64-x86-64.c (elf64_x86_64_link_hash_table_create): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* linker.c (_bfd_generic_link_hash_table_create): Likewise.
	* m68klinux.c (linux_link_hash_table_create): Likewise.
	* sparclinux.c (linux_link_hash_table_create): Likewise.
	* sunos.c (sunos_link_hash_table_create): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_link_hash_table_create): Likewise.

	* targets.c: Add _bfd_link_hash_table_free to xvec.

	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
@
text
@d1635 3
d1667 1
a1668 1

a1669 21

      if (info->relocateable)
	{
	  /* This is a relocateable link.  We don't have to change
	     anything, unless the reloc is against a section symbol,
	     in which case we have to adjust according to where the
	     section symbol winds up in the output section.  */
	  if (r_symndx < symtab_hdr->sh_info)
	    {
	      sym = local_syms + r_symndx;
	      if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
		{
		  sec = local_sections[r_symndx];
		  rel->r_addend += sec->output_offset + sym->st_value;
		}
	    }

	  continue;
	}

      /* This is a final link.  */
d2452 1
@


1.23
log
@	* linker.c (link_action): Ignore duplicate warning syms.
	(_bfd_generic_link_write_global_symbol): Follow warning symbol link.
	* elflink.h (elf_adjust_dynstr_offsets): Likewise.
	(elf_adjust_dynamic_symbol): Likewise.
	(elf_export_symbol): Likewise.
	(elf_link_find_version_dependencies): Likewise.
	(elf_link_assign_sym_version): Likewise.
	(elf_link_sec_merge_syms): Likewise.
	(elf_link_output_extsym): Likewise.
	(elf_gc_sweep_symbol): Likewise.
	(elf_gc_propagate_vtable_entries_used): Likewise.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(elf_gc_allocate_got_offsets): Likewise.
	(elf_collect_hash_codes): Likewise.
	* elflink.c (elf_link_renumber_hash_table_dynsyms): Likewise.
	* elf-hppa.h (elf_hppa_unmark_useless_dynamic_symbols): Likewise.
	(elf_hppa_remark_useless_dynamic_symbols): Likewise.
	* elf-m10300.c (elf32_mn10300_finish_hash_table_entry): Likewise.
	* elf32-arm.h (elf32_arm_discard_copies): Likewise.
	* elf32-cris.c (elf_cris_adjust_gotplt_to_got): Likewise.
	(elf_cris_discard_excess_dso_dynamics): Likewise.
	* elf32-hppa.c (clobber_millicode_symbols): Likewise.
	(mark_PIC_calls): Likewise.
	(allocate_plt_static): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i386.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-i370.c (i370_elf_adjust_dynindx): Likewise.
	* elf32-m68k.c (elf_m68k_discard_copies): Likewise.
	* elf32-mips.c (mips_elf_output_extsym): Likewise.
	(mips_elf_sort_hash_table_f): Likewise.
	(mips_elf_check_mips16_stubs): Likewise.
	* elf32-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf32-sh.c (sh_elf_discard_copies): Likewise.
	* elf32-xstormy16.c (xstormy16_relax_plt_check): Likewise.
	(xstormy16_relax_plt_realloc): Likewise.
	* elf64-alpha.c (elf64_alpha_calc_got_offsets_for_symbol): Likewise.
	(elf64_alpha_output_extsym): Likewise.
	* elf64-hppa.c (elf64_hppa_mark_exported_functions): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table_f): Likewise.
	(mips_elf64_check_mips16_stubs): Likewise.
	(mips_elf64_output_extsym): Likewise.
	* elf64-ppc.c (func_desc_adjust): Likewise.
	(allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-s390.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elf64-sh64.c (sh64_elf64_discard_copies): Likewise.
	* elf64-x86-64.c (allocate_dynrelocs): Likewise.
	(readonly_dynrelocs): Likewise.
	* elfxx-ia64.c (elfNN_ia64_global_dyn_sym_thunk): Likewise.
	* aoutx.h (aout_link_write_other_symbol): Likewise.
	* cofflink.c (_bfd_coff_write_task_globals): Likewise.
	(_bfd_coff_write_global_sym): Likewise.
	* i386linux.c (linux_tally_symbols): Likewise.
	* m68klinux.c (linux_tally_symbols): Likewise.
	* sparclinux.c (linux_tally_symbols): Likewise.
	* pdp11.c (aout_link_write_other_symbol): Likewise.
	* sunos.c (sunos_scan_dynamic_symbol): Likewise.
	* xcofflink.c (xcoff_build_ldsyms): Likewise.
	(xcoff_write_global_symbol): Likewise.

	* cofflink.c (_bfd_coff_final_link): Formatting.
	* cpu-mips.c (mips_compatible): Make static, prototype.
	* elf32-i386.c (elf_i386_check_relocs): Formatting.
	* elf32-sh.c (sh_elf_size_dynamic_sections): Likewise.
	* elf64-alpha.c (elf64_alpha_output_extsym): Likewise.
	* elf64-mips.c (mips_elf64_sort_hash_table): Likewise.
	(mips_elf64_final_link): Likewise.
	* elflink.h (elf_link_find_version_dependencies): Remove duplicate
	prototype.
@
text
@d481 1
a481 1
  ret = (struct elf_s390_link_hash_table *) bfd_alloc (abfd, amt);
d487 1
a487 1
      bfd_release (abfd, ret);
@


1.22
log
@2002-02-19  Martin Schwidefsky  <schwidefsky@@de.ibm.com>

	* archures.c (bfd_mach_s390_esa): Rename to bfd_mach_s390_31.
	(bfd_mach_s390_esame): Rename to bfd_mach_s390_64.
	* bfd-in2.h: Regenerate.
	* cpu-s390.c (arch_info_struct): Use renamed architecture defines.
	Replace architecture name "s390" with "s390:31-bit" and "s390:esame"
	with "s390:64-bit".
	* elf32-s390.c (elf_howto_table): Add 32 bit pc relative relocations.
	(elf_s390_reloc_type_lookup): Likewise.
	(elf_s390_check_relocs): Likewise.
	(elf_s390_gc_sweep_hook): Likewise.
	(elf_s390_relocate_section): Likewise.
	(elf_s390_object_p): Use renamed architecture define.
	* elf64-s390.c (elf_s390_object_p): Use renamed architecture define.
@
text
@d2 1
a2 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d1217 1
a1217 2
  if (h->root.type == bfd_link_hash_indirect
      || h->root.type == bfd_link_hash_warning)
d1220 3
d1388 3
@


1.21
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@d114 4
d173 8
d665 1
d695 1
d706 1
d729 1
d771 1
d874 1
d975 2
d997 1
d1018 1
d1030 1
d1742 1
d1830 10
d1855 1
d1862 1
d1892 1
d1904 1
d1950 1
d2417 1
a2417 1
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_esa);
@


1.20
log
@	* elf64-ppc.c (ppc64_elf_size_dynamic_sections): Check for relocs
	against section syms in readonly sections.  Don't do the global
	sym check if we find one.
	* elf64-s390.c (elf_s390_size_dynamic_sections): Likewise.
	* elf32-hppa.c (elf32_hppa_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections): Likewise.
	(elf_s390_grok_prstatus): Add missing prototype.
@
text
@d1894 1
d1901 2
d1907 1
a1907 4
                {
                  memset (&outrel, 0, sizeof outrel);
                  relocate = false;
                }
a1917 1
		  relocate = false;
@


1.20.2.1
log
@	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Enable
	absptr -> pcrel optimization for shared libs.
	Only create minimal .eh_frame_hdr if absptr FDE encoding in shared
	library cannot be converted to pcrel.
	(_bfd_elf_eh_frame_section_offset): Return -2 if making absptr
	relative.
	* elf32-i386.c (elf_i386_relocate_section): If
	_bfd_elf_section_offset returned -2, skip, but make sure the
	relocation is installed.
	* elf32-arm.h (elf32_arm_final_link_relocate): Likewise.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sh64.c (sh_elf64_relocate_section): Likewise.
	* elf64-sparc.c	(sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Handle
	_bfd_elf_section_offset returning -2 the same way as -1.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Add FIXME
	and BFD_ASSERT.
	* elf64-mips.c (mips_elf64_create_dynamic_relocation): Likewise.
@
text
@a1893 1
              relocate = false;
a1899 2
	      else if (outrel.r_offset == (bfd_vma) -2)
		skip = true, relocate = true;
d1904 4
a1907 1
		memset (&outrel, 0, sizeof outrel);
d1918 1
@


1.20.2.2
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
a113 4
  HOWTO(R_390_PC32DBL,	 1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PC32DBL", false, 0,0xffffffff,  true),
  HOWTO(R_390_PLT32DBL,	 1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_PLT32DBL", false, 0,0xffffffff,  true),
  HOWTO(R_390_GOTPCDBL,  1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTPCDBL", false, 0,0xffffffff,  true),
  HOWTO(R_390_GOTENT,	 1, 2, 32,  true, 0, complain_overflow_bitfield, bfd_elf_generic_reloc, "R_390_GOTENT",   false, 0,0xffffffff,  true),
a168 8
    case BFD_RELOC_390_PC32DBL:
      return &elf_howto_table[(int) R_390_PC32DBL];
    case BFD_RELOC_390_PLT32DBL:
      return &elf_howto_table[(int) R_390_PLT32DBL];
    case BFD_RELOC_390_GOTPCDBL:
      return &elf_howto_table[(int) R_390_GOTPCDBL];
    case BFD_RELOC_390_GOTENT:
      return &elf_howto_table[(int) R_390_GOTENT];
a652 1
	case R_390_GOTENT:
a681 1
	case R_390_GOTPCDBL:
a691 1
        case R_390_PLT32DBL:
a713 1
	case R_390_PC32DBL:
a754 1
		    && ELF32_R_TYPE (rel->r_info) != R_390_PC32DBL
a856 1
		  || ELF32_R_TYPE (rel->r_info) == R_390_PC32DBL
a956 2
      case R_390_GOTPCDBL:
      case R_390_GOTENT:
a976 1
      case R_390_PC32DBL:
a996 1
		      || ELF32_R_TYPE (rel->r_info) == R_390_PC32DBL
a1007 1
      case R_390_PLT32DBL:
d1194 2
a1195 1
  if (h->root.type == bfd_link_hash_indirect)
a1197 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a1363 3
  if (h->root.type == bfd_link_hash_warning)
    h = (struct elf_link_hash_entry *) h->root.u.i.link;

a1718 1
	case R_390_GOTENT:
a1805 10

	  /*
	   * For @@GOTENT the relocation is against the offset between
	   * the instruction and the symbols entry in the GOT and not
	   * between the start of the GOT and the symbols entry. We
	   * add the vma of the GOT to get the correct value.
	   */
	  if (r_type == R_390_GOTENT)
	    relocation += htab->sgot->output_section->vma;

a1820 1
	case R_390_GOTPCDBL:
a1826 1
        case R_390_PLT32DBL:
a1855 1
        case R_390_PC32DBL:
a1866 1
		    && r_type != R_390_PC32DBL
a1911 1
			   || r_type == R_390_PC32DBL
d2378 1
a2378 1
  return bfd_default_set_arch_mach (abfd, bfd_arch_s390, bfd_mach_s390_31);
@


1.20.2.3
log
@Merge from mainline
@
text
@a1634 3
  if (info->relocateable)
    return true;

d1664 1
a1665 1
      howto = elf_howto_table + r_type;
d1667 21
a2469 1
#define elf_backend_rela_normal		1
@


1.19
log
@	* elf32-i386 (elf_i386_adjust_dynamic_symbol): Do not replace PLT32
	relocations with PC32 relocations for undefined or weak symbols.
	* elf32-s390 (elf_i386_adjust_dynamic_symbol): Likewise.
	* elf64-s390x (elf_i386_adjust_dynamic_symbol): Likewise.
@
text
@d72 1
d1443 1
a1443 1
	      else
d1447 2
d1570 3
a1572 1
	  elf_link_hash_traverse (&htab->elf, readonly_dynrelocs, (PTR) info);
@


1.18
log
@        * elf32-s390 (elf_s390_check_relocs): Pass addend to
        gc_record_vtentry.
        * elf64-s390 (elf_s390_check_relocs): Likewise.
        Fix by Andreas Jaeger <aj@@suse.de>.
@
text
@d1050 3
a1052 1
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0))
@


1.17
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d871 1
a871 1
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_offset))
@


1.16
log
@Allow GDB to read general-purpose registers from Linux S/390 core files.
@
text
@d919 1
a919 7
      if (!(elf_bad_symtab (abfd)
	    && ELF_ST_BIND (sym->st_info) != STB_LOCAL)
	  && ! ((sym->st_shndx <= 0 || sym->st_shndx >= SHN_LORESERVE)
		&& sym->st_shndx != SHN_COMMON))
	{
	  return bfd_section_from_elf_index (abfd, sym->st_shndx);
	}
@


1.15
log
@	* elf.c (_bfd_elf_rela_local_sym): Only call
	_bfd_merged_section_offset if merge_info is non-NULL.
	(_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New.
	* elf-bfd.h (_bfd_elf_rel_local_sym, _bfd_elf_section_offset): New
	prototypes.
	* elf32-arm.h (elf32_arm_final_link_relocate): Use
	_bfd_elf_section_offset.
	(elf32_arm_relocate_section): Use _bfd_elf_rel_local_sym.
	* elf32-i386.c (elf_i386_relocate_section): Use
	_bfd_elf_section_offset and _bfd_elf_rel_local_sym.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Use
	_bfd_elf_section_offset.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_create_dynamic_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_install_dyn_reloc): Likewise.
@
text
@d2381 31
d2445 1
@


1.14
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d1894 5
a1898 13
              if (elf_section_data (input_section)->stab_info == NULL)
                outrel.r_offset = rel->r_offset;
              else
                {
                  off = (_bfd_stab_section_offset
                         (output_bfd, htab->elf.stab_info, input_section,
                          &elf_section_data (input_section)->stab_info,
                          rel->r_offset));
                  if (off == (bfd_vma) -1)
                    skip = true;
                  outrel.r_offset = off;
                }

@


1.13
log
@	* elf32-s390.c (elf_s390_relocate_section): Use the "unresolved_reloc"
	scheme to get rid of an ugly complicated test.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
@
text
@d1667 1
a1667 3
	  relocation = (sec->output_section->vma
			+ sec->output_offset
			+ sym->st_value);
@


1.12
log
@	* elf32-arm.h (elf32_arm_final_link_relocate): Don't copy STN_UNDEF
	relocs into shared libs.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mips.c (mips_elf_calculate_relocation): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf.c (bfd_section_from_r_symndx): New function.
	* elf-bfd.h (LOCAL_SYM_CACHE_SIZE): Define.
	(struct sym_sec_cache): New.
	(bfd_section_from_r_symndx): Declare.
	(struct bfd_elf_section_data): Change local_dynrel type to PTR.
	* elflink.h (elf_link_input_bfd): Don't test for removed linkonce
	relocs when relocatable.  Don't	zero entire reloc, just zero the
	addend and sym.
	* elf32-i386.c (struct elf_i386_link_hash_table): Add sym_sec.
	(elf_i386_link_hash_table_create): Init it.
	(elf_i386_check_relocs): Track dynamic relocs needed for local
	syms on a per-section basis as we do for globals.
	(elf_i386_gc_sweep_hook): Update for local_dynrel change.
	Remove dead code.
	(allocate_dynrelocs): Warning fix.
	(elf_i386_size_dynamic_sections): Don't allocate relocs when
	section has been discarded.
	(elf_i386_relocate_section): Don't copy STN_UNDEF relocs
	into shared libs.
	* elf32-hppa.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
@
text
@d1682 1
a1682 38
	      if (r_type == R_390_GOTPC
		  || ((r_type == R_390_PLT16DBL
                       || r_type == R_390_PLT32)
		      && htab->splt != NULL
		      && h->plt.offset != (bfd_vma) -1)
		  || ((r_type == R_390_GOT12
                       || r_type == R_390_GOT16
                       || r_type == R_390_GOT32)
		      && elf_hash_table (info)->dynamic_sections_created
		      && (! info->shared
			  || (! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))
		  || (info->shared
		      && ((! info->symbolic && h->dynindx != -1)
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0)
		      && (r_type == R_390_8
			  || r_type == R_390_16
                          || r_type == R_390_32
                          || r_type == R_390_PC16
                          || r_type == R_390_PC16DBL
                          || r_type == R_390_PC32)
                      && ((input_section->flags & SEC_ALLOC) != 0
                          /* DWARF will emit R_390_32 relocations in its
                             sections against symbols defined externally
                             in shared libraries.  We can't do anything
                             with them here.  */
                          || ((input_section->flags & SEC_DEBUGGING) != 0
			      && (h->elf_link_hash_flags
				  & ELF_LINK_HASH_DEF_DYNAMIC) != 0))))
		{
		  /* In these cases, we don't need the relocation
                     value.  We check specially because in some
                     obscure cases sec->output_section will be NULL.  */
		  relocation = 0;
		}
	      else if (sec->output_section == NULL)
d1929 1
a1929 1
		  outrel.r_addend = relocation + rel->r_addend;
@


1.11
log
@* elf32-s390: Major rework that introduces all recent changes to
the s390 backends.  Get a closer match to elf32-i386.
(elf_s390_relocate_section): Make use of dynamic section short-cuts.
Localise vars, and delay setting.  Better error reporting, replace
BFD_ASSERT with abort.  Check ELF_LINK_HASH_DEF_DYNAMIC to see if a
symbol is not defined in the regular object file and tread the weak
definition as the normal one.  Don't discard relocs for undefweak or
undefined symbols and check !DEF_REGULAR as well as DEF_DYNAMIC in
test for avoided copy relocs.  Reinstate fudge for unresolved relocs
in debugging sections.
(elf32_s390_adjust_dynamic_symbol): Handle nocopyreloc.  Don't do copy
reloc processing for weakdefs.  Remove redundant casts and aborts.
Delay setting of vars until needed.  Move creation of dynamic symbols
and allocation of .plt and .rela.plt to allocate_dynrelocs.  Replace
BFD_ASSERT with abort.  Discard .plt entries for everything with
plt.refcount <= 0.
(elf_s390_check_relocs):  Don't allocate space for dynamic relocs,
.got or .relgot here but do it in allocate_dynrelocs.  Reference count
possible .plt and .got entries.  Don't test input section SEC_READONLY
here to try to avoid copy relocs, and keep dyn_relocs regardless of
ELF_LINK_NON_GOT_REF.  Don't set DF_TEXTREL here.  Delay setting of
variables until needed.  Remove separate switch stmt for creating .got
section.  Initialise local_got_refcounts to 0.  Cache pointer to
"sreloc" section in elf_section_data. Tweak condition under which .got
created.  Report files with bad relocation section names.
(elf_s390_finish_dynamic_symbol): Don't copy relocs for symbols that
have been forced local.  Use same test to decide if we can use a
relative reloc for got as elf_s390_relocate_section.  Expand SHN_UNDEF
comment.  Move expressions out of function calls.  Replace BFD_ASSERT
with abort.
(elf_s390_finish_dynamic_sections): Migrate common code out of switch
statement.  Replace BFD_ASSERT with abort.
(elf_s390_size_dynamic_sections): Call readonly_dynrelocs. Rename "i"
to "ibfd".  Allocate space for local dyn relocs.  Use DF_TEXTREL flag
instead of looking up section names for DT_TEXTREL.  Replace
BFD_ASSERT with abort.  Zero out the dynamic allocated content space.
Add a comment to remind us that one day this ought to be fixed.
(struct elf_s390_link_hash_entry): Rename "root" to "elf".
(struct elf_s390_link_hash_table): Likewise.
(elf_s390_link_hash_newfunc): Rename to link_hash_newfunc and get
rid of unnecessary casts.
(struct elf_s390_dyn_relocs): Add "sec", and "pc_count" fields.
Remove "section" field.
(elf_s390_gc_sweep_hook): Sweep dyn_relocs and local_dynrel.
Reference count possible .plt entries.  Don't deallocate .got and
.relgot space here.
(struct elf_s390_pcrel_relocs_copied): Rename to elf_s390_dyn_relocs.
Update comment.
(struct elf_s390_link_hash_entry): Rename pcrel_relocs_copied to
dyn_relocs.
(elf_s390_discard_copies):  Delete.
(elf_s390_link_hash_traverse): Delete.
(bfd_elf32_bfd_final_link): Delete.  (ie. use regular final link
rather than gc variety).
(struct elf_s390_link_hash_table): Add sgot, sgotplt, srelgot, splt,
srelplt, sdynbss, srelbss fields.
(elf_s390_link_hash_table_create): Init them.
(WILL_CALL_FINISH_DYNAMIC_SYMBOL): Define.
(allocate_dynrelocs): New function.
(create_got_section): New function.
(elf_backend_can_refcount): Define.
(elf_backend_copy_indirect_symbol): Define.
(elf_s390_copy_indirect_symbol): New function.
(elf_s390_create_dynamic_sections): New function.
(readonly_dynrelocs): New function.
* elf64-s390x: Likewise.
@
text
@d126 1
a126 1
  switch (code) 
d418 3
d445 1
a445 1
  
d451 1
a451 1
      
d485 1
d723 1
a723 1
	
d752 1
a752 1
	       && ((ELF32_R_TYPE (rel->r_info) != R_390_PC16 
d767 3
d777 1
a777 1
		
d820 13
a832 2
		  struct elf_s390_link_hash_entry *eh;
		  struct elf_s390_dyn_relocs *p;
d834 3
a836 2
		  eh = (struct elf_s390_link_hash_entry *) h;
		  p = eh->dyn_relocs;
d838 2
a839 21
		  if (p == NULL || p->sec != sec)
		    {
		      bfd_size_type amt = sizeof *p;
		      p = ((struct elf_s390_dyn_relocs *)
			   bfd_alloc (htab->elf.dynobj, amt));
		      if (p == NULL)
			return false;
		      p->next = eh->dyn_relocs;
		      eh->dyn_relocs = p;
		      p->sec = sec;
		      p->count = 0;
		      p->pc_count = 0;
		    }
		  
		  p->count += 1;
		  if (ELF32_R_TYPE (rel->r_info) == R_390_PC16
		      || ELF32_R_TYPE (rel->r_info) == R_390_PC16DBL
		      || ELF32_R_TYPE (rel->r_info) == R_390_PC32)
		    p->pc_count += 1;
		}
	      else
d841 10
a850 2
		  /* Track dynamic relocs needed for local syms too.  */
		  elf_section_data (sec)->local_dynrel += 1;
d852 6
d860 1
a860 1
	
d867 1
a867 1
	
d874 1
a874 1
	
a945 3
  bfd *dynobj;

  elf_section_data (sec)->local_dynrel = 0;
d947 1
a947 3
  dynobj = elf_hash_table (info)->dynobj;
  if (dynobj == NULL)
    return true;
d1120 1
a1120 1
     we'll be keeping the dynamic relocs and avoiding the copy reloc.  */ 
d1238 1
a1238 1
	  
d1241 1
a1241 1
	  
d1254 1
a1254 1
    } 
d1259 2
a1260 2
    }      
  
d1344 1
a1344 1
    keep:
d1431 1
a1431 1
	  bfd_size_type count = elf_section_data (s)->local_dynrel;
d1433 4
a1436 1
	  if (count != 0)
d1438 13
a1450 2
	      srela = elf_section_data (s)->sreloc;
	      srela->_raw_size += count * sizeof (Elf32_External_Rela);
d1500 1
a1500 1
	  
d1536 1
a1536 1
  
d1546 1
a1546 1
      
d1552 1
a1552 1
      
d1561 1
a1561 1
      
d1572 1
a1572 1
	  
d1581 1
a1581 1
  
d1625 1
a1625 1
      
d1636 1
a1636 1
      
d1638 1
a1638 1
      
d1654 1
a1654 1
	  
d1657 1
a1657 1
      
d1677 1
a1677 1
	  
d1751 1
a1751 1
      
d1761 1
a1761 1
	  
d1765 1
a1765 1
	      
d1895 7
a1902 1
	       && (input_section->flags & SEC_ALLOC) != 0
a1911 1
		  && (input_section->flags & SEC_ALLOC) != 0
d1926 1
a1926 1
	      
d1930 1
a1930 1
	      
d1932 1
a1932 1
	      
d1945 1
a1945 1
	      
d1948 1
a1948 1
	      
d1975 1
a1975 1
	      
d1979 1
a1979 1
	      
d1983 1
a1983 1
	      
a1990 1
	  
d1992 1
a1992 1
	  
d1996 1
a1996 1
      
d2007 1
a2007 1
      
d2011 1
a2011 1
      
d2015 1
a2015 1
	  
d2028 1
a2028 1
	  
d2031 1
a2031 1
	      
d2048 1
a2048 1
  
d2063 1
a2063 1
  
d2065 1
a2065 1
  
d2073 1
a2073 1
      
d2076 1
a2076 1
      
d2193 1
a2193 1
  
d2200 1
a2200 1
	     library.  */  
d2204 1
a2204 1
  
d2330 1
a2330 1
	
d2332 1
a2332 1
	
d2337 1
a2337 1
	
d2341 1
a2341 1
	
@


1.10
log
@	* elf32-hppa.c (elf32_hppa_copy_indirect_symbol): Merge dyn_reloc
	counts for aliases instead of aborting.
	* elf32-i386.c (elf_i386_copy_indirect_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.

	* elf32-hppa.c (elf32_hppa_adjust_dynamic_symbol): Set plt.offset
	to -1 for non-function symbols.
	* elf32-ppc.c (ppc_elf_adjust_dynamic_symbol): Likewise.
	* elf32-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-ppc.c (ppc64_elf_adjust_dynamic_symbol): Likewise.
	* elf64-s390.c (elf_s390_adjust_dynamic_symbol): Likewise.
	* elf64-x86-64.c (elf64_x86_64_adjust_dynamic_symbol): Likewise.
	* elf32-i386.c (elf_i386_adjust_dynamic_symbol): Refer to
	plt.offset instead of plt.refcount when setting to -1.
@
text
@d32 3
a34 2
static boolean elf_s390_is_local_label_name PARAMS ((bfd *, const char *));
static struct bfd_hash_entry *elf_s390_link_hash_newfunc
d38 6
d49 1
a49 1
	   struct elf_link_hash_entry *, Elf_Internal_Sym *sym));
d55 4
d67 2
a71 2
static enum elf_reloc_type_class elf_s390_reloc_type_class
  PARAMS ((const Elf_Internal_Rela *));
d126 49
a174 48
  switch (code) {
  case BFD_RELOC_NONE:
    return &elf_howto_table[(int) R_390_NONE];
  case BFD_RELOC_8:
    return &elf_howto_table[(int) R_390_8];
  case BFD_RELOC_390_12:
    return &elf_howto_table[(int) R_390_12];
  case BFD_RELOC_16:
    return &elf_howto_table[(int) R_390_16];
  case BFD_RELOC_32:
    return &elf_howto_table[(int) R_390_32];
  case BFD_RELOC_CTOR:
    return &elf_howto_table[(int) R_390_32];
  case BFD_RELOC_32_PCREL:
    return &elf_howto_table[(int) R_390_PC32];
  case BFD_RELOC_390_GOT12:
    return &elf_howto_table[(int) R_390_GOT12];
  case BFD_RELOC_32_GOT_PCREL:
    return &elf_howto_table[(int) R_390_GOT32];
  case BFD_RELOC_390_PLT32:
    return &elf_howto_table[(int) R_390_PLT32];
  case BFD_RELOC_390_COPY:
    return &elf_howto_table[(int) R_390_COPY];
  case BFD_RELOC_390_GLOB_DAT:
    return &elf_howto_table[(int) R_390_GLOB_DAT];
  case BFD_RELOC_390_JMP_SLOT:
    return &elf_howto_table[(int) R_390_JMP_SLOT];
  case BFD_RELOC_390_RELATIVE:
    return &elf_howto_table[(int) R_390_RELATIVE];
  case BFD_RELOC_32_GOTOFF:
    return &elf_howto_table[(int) R_390_GOTOFF];
  case BFD_RELOC_390_GOTPC:
    return &elf_howto_table[(int) R_390_GOTPC];
  case BFD_RELOC_390_GOT16:
    return &elf_howto_table[(int) R_390_GOT16];
  case BFD_RELOC_16_PCREL:
    return &elf_howto_table[(int) R_390_PC16];
  case BFD_RELOC_390_PC16DBL:
    return &elf_howto_table[(int) R_390_PC16DBL];
  case BFD_RELOC_390_PLT16DBL:
    return &elf_howto_table[(int) R_390_PLT16DBL];
  case BFD_RELOC_VTABLE_INHERIT:
    return &elf32_s390_vtinherit_howto;
  case BFD_RELOC_VTABLE_ENTRY:
    return &elf32_s390_vtentry_howto;
  default:
    break;
  }
a220 5
/* The nop opcode we use.  */

#define s390_NOP 0x07070707


d375 13
a387 15
   decides to copy in check_relocs for each symbol.  This is so that
   it can discard PC relative relocs if it doesn't need them when
   linking with -Bsymbolic.  We store the information in a field
   extending the regular ELF linker hash table.  */

/* This structure keeps track of the number of PC relative relocs we
   have copied for a given symbol.  */

struct elf_s390_pcrel_relocs_copied
{
  /* Next section.  */
  struct elf_s390_pcrel_relocs_copied *next;
  /* A section in dynobj.  */
  asection *section;
  /* Number of relocs copied in this section.  */
d389 3
d398 1
a398 1
  struct elf_link_hash_entry root;
d400 2
a401 2
  /* Number of PC relative relocs copied for this symbol.  */
  struct elf_s390_pcrel_relocs_copied *pcrel_relocs_copied;
d408 10
a417 1
  struct elf_link_hash_table root;
a419 13
/* Declare this now that the above structures are defined.  */

static boolean elf_s390_discard_copies
  PARAMS ((struct elf_s390_link_hash_entry *, PTR));

/* Traverse an s390 ELF linker hash table.  */

#define elf_s390_link_hash_traverse(table, func, info)			\
  (elf_link_hash_traverse						\
   (&(table)->root,							\
    (boolean (*) PARAMS ((struct elf_link_hash_entry *, PTR))) (func),	\
    (info)))

d428 1
a428 1
elf_s390_link_hash_newfunc (entry, table, string)
a432 3
  struct elf_s390_link_hash_entry *ret =
    (struct elf_s390_link_hash_entry *) entry;

d435 8
a442 7
  if (ret == (struct elf_s390_link_hash_entry *) NULL)
    ret = ((struct elf_s390_link_hash_entry *)
	   bfd_hash_allocate (table,
			      sizeof (struct elf_s390_link_hash_entry)));
  if (ret == (struct elf_s390_link_hash_entry *) NULL)
    return (struct bfd_hash_entry *) ret;

d444 2
a445 4
  ret = ((struct elf_s390_link_hash_entry *)
	 _bfd_elf_link_hash_newfunc ((struct bfd_hash_entry *) ret,
				     table, string));
  if (ret != (struct elf_s390_link_hash_entry *) NULL)
d447 4
a450 1
      ret->pcrel_relocs_copied = NULL;
d453 1
a453 1
  return (struct bfd_hash_entry *) ret;
d466 1
a466 1
  if (ret == (struct elf_s390_link_hash_table *) NULL)
d469 1
a469 2
  if (! _bfd_elf_link_hash_table_init (&ret->root, abfd,
				       elf_s390_link_hash_newfunc))
d475 70
a544 1
  return &ret->root.root;
d547 47
d606 1
a606 1
  bfd *dynobj;
a608 1
  bfd_signed_vma *local_got_refcounts;
a610 2
  asection *sgot;
  asection *srelgot;
d616 1
a616 1
  dynobj = elf_hash_table (info)->dynobj;
a618 1
  local_got_refcounts = elf_local_got_offsets (abfd);
a619 2
  sgot = NULL;
  srelgot = NULL;
d630 8
a642 21
      /* Some relocs require a global offset table.  */
      if (dynobj == NULL)
	{
	  switch (ELF32_R_TYPE (rel->r_info))
	    {
	    case R_390_GOT12:
            case R_390_GOT16:
	    case R_390_GOT32:
	    case R_390_GOTOFF:
	    case R_390_GOTPC:
	      elf_hash_table (info)->dynobj = dynobj = abfd;
	      if (! _bfd_elf_create_got_section (dynobj, info))
		return false;
	      break;

	    default:
	      break;
	    }
	}


a648 28

	  if (sgot == NULL)
	    {
	      sgot = bfd_get_section_by_name (dynobj, ".got");
	      BFD_ASSERT (sgot != NULL);
	    }


	  if (srelgot == NULL
	      && (h != NULL || info->shared))
	    {
	      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
	      if (srelgot == NULL)
		{
		  srelgot = bfd_make_section (dynobj, ".rela.got");
		  if (srelgot == NULL
		      || ! bfd_set_section_flags (dynobj, srelgot,
						  (SEC_ALLOC
						   | SEC_LOAD
						   | SEC_HAS_CONTENTS
						   | SEC_IN_MEMORY
						   | SEC_LINKER_CREATED
						   | SEC_READONLY))
		      || ! bfd_set_section_alignment (dynobj, srelgot, 2))
		    return false;
		}
	    }

a650 12
	      if (h->got.refcount == 0)
		{
		  /* Make sure this symbol is output as a dynamic symbol.  */
		  if (h->dynindx == -1)
		    {
		      if (! bfd_elf32_link_record_dynamic_symbol (info, h))
			return false;
		    }

		  sgot->_raw_size += 4;
		  srelgot->_raw_size += sizeof (Elf32_External_Rela);
		}
d655 2
d658 1
d665 2
a666 2
		  local_got_refcounts = (bfd_signed_vma *)
		                         bfd_zalloc (abfd, size);
a670 11
	      if (local_got_refcounts[r_symndx] == 0)
		{
		  sgot->_raw_size += 4;
		  if (info->shared)
		    {
		      /* If we are generating a shared object, we need to
			 output a R_390_RELATIVE reloc so that the dynamic
			 linker can adjust this GOT entry.  */
		      srelgot->_raw_size += sizeof (Elf32_External_Rela);
		    }
		}
d673 11
d710 14
a723 2
	  if (h != NULL)
	    h->elf_link_hash_flags |= ELF_LINK_NON_GOT_REF;
d726 36
a761 20
             against a global symbol, or a non PC relative reloc
             against a local symbol, then we need to copy the reloc
             into the shared library.  However, if we are linking with
             -Bsymbolic, we do not need to copy a reloc against a
             global symbol which is defined in an object we are
             including in the link (i.e., DEF_REGULAR is set).  At
             this point we have not seen all the input files, so it is
             possible that DEF_REGULAR is not set now but will be set
             later (it is never cleared).  We account for that
             possibility below by storing information in the
             pcrel_relocs_copied field of the hash table entry.  */
	  if (info->shared
              && (sec->flags & SEC_ALLOC) != 0
	      && ((ELF32_R_TYPE (rel->r_info) != R_390_PC16 &&
                   ELF32_R_TYPE (rel->r_info) != R_390_PC16DBL &&
                   ELF32_R_TYPE (rel->r_info) != R_390_PC32)
		  || (h != NULL
		      && (! info->symbolic
			  || (h->elf_link_hash_flags
			      & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d763 3
a765 3
	      /* When creating a shared object, we must copy these
                 reloc types into the output file.  We create a reloc
                 section in dynobj and make room for this reloc.  */
d769 2
a770 1

d778 11
a788 3
		  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
			      && strcmp (bfd_get_section_name (abfd, sec),
					 name + 5) == 0);
d790 1
d806 1
a806 2
		  if (sec->flags & SEC_READONLY)
		    info->flags |= DF_TEXTREL;
d809 3
a811 14
	      sreloc->_raw_size += sizeof (Elf32_External_Rela);

	      /* If we are linking with -Bsymbolic, and this is a
                 global symbol, we count the number of PC relative
                 relocations we have entered for this symbol, so that
                 we can discard them again if the symbol is later
                 defined by a regular object.  Note that this function
                 is only called if we are using an elf_s390 linker
                 hash table, which means that h is really a pointer to
                 an elf_s390_link_hash_entry.  */
	      if (h != NULL
		  && (ELF32_R_TYPE (rel->r_info) == R_390_PC16 ||
                      ELF32_R_TYPE (rel->r_info) == R_390_PC16DBL ||
                      ELF32_R_TYPE (rel->r_info) == R_390_PC32))
d814 1
a814 1
		  struct elf_s390_pcrel_relocs_copied *p;
d817 1
d819 1
a819 5
		  for (p = eh->pcrel_relocs_copied; p != NULL; p = p->next)
		    if (p->section == sreloc)
		      break;

		  if (p == NULL)
d821 3
a823 2
		      p = ((struct elf_s390_pcrel_relocs_copied *)
			   bfd_alloc (dynobj, (bfd_size_type) sizeof *p));
d826 3
a828 3
		      p->next = eh->pcrel_relocs_copied;
		      eh->pcrel_relocs_copied = p;
		      p->section = sreloc;
d830 1
d832 11
a842 2

		  ++p->count;
a844 1

d846 1
a846 1

d853 1
a853 1

d857 1
a857 1
          if (!_bfd_elf32_gc_record_vtentry (abfd, sec, h, rel->r_addend))
d860 1
a860 1

d921 4
a924 4
     bfd *abfd ATTRIBUTE_UNUSED;
     struct bfd_link_info *info ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     const Elf_Internal_Rela *relocs ATTRIBUTE_UNUSED;
a932 2
  asection *sgot;
  asection *srelgot;
d934 1
a934 3
  symtab_hdr = &elf_tdata (abfd)->symtab_hdr;
  sym_hashes = elf_sym_hashes (abfd);
  local_got_refcounts = elf_local_got_refcounts (abfd);
d940 3
a942 2
  sgot = bfd_get_section_by_name (dynobj, ".got");
  srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
d958 1
a958 8
	      {
		h->got.refcount -= 1;
		if (h->got.refcount == 0)
		  {
		    sgot->_raw_size -= 4;
		    srelgot->_raw_size -= sizeof (Elf32_External_Rela);
		  }
	      }
d963 37
a999 9
	      {
		local_got_refcounts[r_symndx] -= 1;
		if (local_got_refcounts[r_symndx] == 0)
		  {
		    sgot->_raw_size -= 4;
		    if (info->shared)
		      srelgot->_raw_size -= sizeof (Elf32_External_Rela);
		  }
	      }
d1032 3
a1034 1
  bfd *dynobj;
a1037 13
  dynobj = elf_hash_table (info)->dynobj;

  /* Make sure we know what is going on here.  */
  BFD_ASSERT (dynobj != NULL
	      && ((h->elf_link_hash_flags & ELF_LINK_HASH_NEEDS_PLT)
		  || h->weakdef != NULL
		  || ((h->elf_link_hash_flags
		       & ELF_LINK_HASH_DEF_DYNAMIC) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_REF_REGULAR) != 0
		      && (h->elf_link_hash_flags
			  & ELF_LINK_HASH_DEF_REGULAR) == 0)));

d1044 4
a1047 4
      if ((! info->shared
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_DYNAMIC) == 0
	   && (h->elf_link_hash_flags & ELF_LINK_HASH_REF_DYNAMIC) == 0)
	  || (info->shared && h->plt.refcount <= 0))
a1055 1
	  return true;
a1057 42
      /* Make sure this symbol is output as a dynamic symbol.  */
      if (h->dynindx == -1)
	{
	  if (! bfd_elf32_link_record_dynamic_symbol (info, h))
	    return false;
	}

      s = bfd_get_section_by_name (dynobj, ".plt");
      BFD_ASSERT (s != NULL);

      /* The first entry in .plt is reserved.  */
      if (s->_raw_size == 0)
	s->_raw_size = PLT_FIRST_ENTRY_SIZE;

     /* If this symbol is not defined in a regular file, and we are
       not generating a shared library, then set the symbol to this
       location in the .plt.  This is required to make function
       pointers compare as equal between the normal executable and
       the shared library.  */
     if (! info->shared
	&& (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) == 0)
      {
	h->root.u.def.section = s;
	h->root.u.def.value = s->_raw_size;
      }

      h->plt.offset = s->_raw_size;

      /* Make room for this entry.  */
      s->_raw_size += PLT_ENTRY_SIZE;

      /* We also need to make an entry in the .got.plt section, which
	 will be placed in the .got section by the linker script.  */
      s = bfd_get_section_by_name (dynobj, ".got.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += GOT_ENTRY_SIZE;

      /* We also need to make an entry in the .rela.plt section.  */
      s = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (s != NULL);
      s->_raw_size += sizeof (Elf32_External_Rela);

d1061 5
d1095 23
d1128 1
a1128 2
  s = bfd_get_section_by_name (dynobj, ".dynbss");
  BFD_ASSERT (s != NULL);
d1130 3
a1132 4
  /* We must generate a R_390_COPY reloc to tell the dynamic linker
     to copy the initial value out of the dynamic object and into the
     runtime process image.  We need to remember the offset into the
     .rel.bss section we are going to use.  */
d1135 1
a1135 5
      asection *srel;

      srel = bfd_get_section_by_name (dynobj, ".rela.bss");
      BFD_ASSERT (srel != NULL);
      srel->_raw_size += sizeof (Elf32_External_Rela);
d1146 3
a1148 3
  s->_raw_size = BFD_ALIGN (s->_raw_size,
			    (bfd_size_type) (1 << power_of_two));
  if (power_of_two > bfd_get_section_alignment (dynobj, s))
d1150 1
a1150 1
      if (! bfd_set_section_alignment (dynobj, s, power_of_two))
d1164 212
d1383 1
d1387 1
a1387 1
  boolean plt;
d1389 4
a1392 2
  dynobj = elf_hash_table (info)->dynobj;
  BFD_ASSERT (dynobj != NULL);
d1394 1
a1394 1
  if (elf_hash_table (info)->dynamic_sections_created)
d1400 2
a1401 1
	  BFD_ASSERT (s != NULL);
a1405 11
  else
    {
      /* We may have created entries in the .rela.got section.
         However, if we are not creating the dynamic sections, we will
         not actually use these entries.  Reset the size of .rela.got,
         which will cause it to get stripped from the output file
         below.  */
      s = bfd_get_section_by_name (dynobj, ".rela.got");
      if (s != NULL)
	s->_raw_size = 0;
    }
d1407 9
a1415 18
  /* If this is a -Bsymbolic shared link, then we need to discard all
     PC relative relocs against symbols defined in a regular object.
     We allocated space for them in the check_relocs routine, but we
     will not fill them in in the relocate_section routine.  */
  if (info->shared)
    elf_s390_link_hash_traverse (elf_s390_hash_table (info),
				 elf_s390_discard_copies,
				 (PTR) info);

  /* The check_relocs and adjust_dynamic_symbol entry points have
     determined the sizes of the various dynamic sections.  Allocate
     memory for them.  */
  plt = false;
  relocs = false;
  for (s = dynobj->sections; s != NULL; s = s->next)
    {
      const char *name;
      boolean strip;
d1417 1
a1417 1
      if ((s->flags & SEC_LINKER_CREATED) == 0)
d1420 3
a1422 3
      /* It's OK to base decisions on the section name, because none
	 of the dynobj section names depend upon the input files.  */
      name = bfd_get_section_name (dynobj, s);
d1424 1
a1424 11
      strip = false;

      if (strcmp (name, ".plt") == 0)
	{
	  if (s->_raw_size == 0)
	    {
	      /* Strip this section if we don't need it; see the
                 comment below.  */
	      strip = true;
	    }
	  else
d1426 2
a1427 2
	      /* Remember whether there is a PLT.  */
	      plt = true;
d1430 11
a1440 1
      else if (strncmp (name, ".rela", 5) == 0)
d1442 1
a1442 1
	  if (s->_raw_size == 0)
d1444 4
a1447 10
	      /* If we don't need this section, strip it from the
		 output file.  This is to handle .rela.bss and
		 .rel.plt.  We must create it in
		 create_dynamic_sections, because it must be created
		 before the linker maps input sections to output
		 sections.  The linker does that before
		 adjust_dynamic_symbol is called, and it is that
		 function which decides whether anything needs to go
		 into these sections.  */
	      strip = true;
d1450 31
a1480 10
	    {
	      /* Remember whether there are any reloc sections other
                 than .rela.plt.  */
	      if (strcmp (name, ".rela.plt") != 0)
		relocs = true;

	      /* We use the reloc_count field as a counter if we need
		 to copy relocs into the output file.  */
	      s->reloc_count = 0;
	    }
d1482 1
a1482 1
      else if (strncmp (name, ".got", 4) != 0)
d1488 1
a1488 1
      if (strip)
d1490 10
d1504 7
a1510 3
      /* Allocate memory for the section contents.  */
      s->contents = (bfd_byte *) bfd_alloc (dynobj, s->_raw_size);
      if (s->contents == NULL && s->_raw_size != 0)
d1513 2
a1514 2

  if (elf_hash_table (info)->dynamic_sections_created)
d1523 1
a1523 1

d1529 2
a1530 2

      if (plt)
d1538 1
a1538 1

a1544 1
         }
d1546 9
a1554 5
      if ((info->flags & DF_TEXTREL) != 0)
	{
	  if (!add_dynamic_entry (DT_TEXTREL, 0))
	    return false;
	  info->flags |= DF_TEXTREL;
d1558 1
a1558 1

a1561 28
/* This function is called via elf_s390_link_hash_traverse if we are
   creating a shared object with -Bsymbolic.  It discards the space
   allocated to copy PC relative relocs against symbols which are
   defined in regular objects.  We allocated space for them in the
   check_relocs routine, but we won't fill them in in the
   relocate_section routine.  */

/*ARGSUSED*/
static boolean
elf_s390_discard_copies (h, inf)
     struct elf_s390_link_hash_entry *h;
     PTR inf;
{
  struct elf_s390_pcrel_relocs_copied *s;
  struct bfd_link_info *info = (struct bfd_link_info *) inf;

  /* If a symbol has been forced local or we have found a regular
     definition for the symbolic link case, then we won't be needing
     any relocs.  */
  if ((h->root.elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR) != 0
      && ((h->root.elf_link_hash_flags & ELF_LINK_FORCED_LOCAL) != 0
	  || info->symbolic))
    {
      for (s = h->pcrel_relocs_copied; s != NULL; s = s->next)
	s->section->_raw_size -= s->count * sizeof (Elf32_External_Rela);
    }
  return true;
}
d1576 1
a1576 1
  bfd *dynobj;
a1579 3
  asection *sgot;
  asection *splt;
  asection *sreloc;
d1583 1
a1583 1
  dynobj = elf_hash_table (info)->dynobj;
a1587 9
  sgot = NULL;
  splt = NULL;
  sreloc = NULL;
  if (dynobj != NULL)
    {
      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got");
    }

d1598 1
d1600 1
d1602 1
a1602 1

d1613 1
a1613 1

d1615 1
a1615 1

d1631 1
a1631 1

d1634 1
a1634 1

d1639 1
d1654 1
d1660 3
a1662 3
		  || ((r_type == R_390_PLT16DBL ||
                       r_type == R_390_PLT32)
		      && splt != NULL
d1664 3
a1666 3
		  || ((r_type == R_390_GOT12 ||
                       r_type == R_390_GOT16 ||
                       r_type == R_390_GOT32)
d1676 6
a1681 6
		      && ( r_type == R_390_8 ||
			   r_type == R_390_16 ||
                           r_type == R_390_32 ||
                           r_type == R_390_PC16 ||
                           r_type == R_390_PC16DBL ||
                           r_type == R_390_PC32)
d1683 1
a1683 1
                          /* DWARF will emit R_386_32 relocations in its
d1698 5
a1702 4
		  (*_bfd_error_handler)
		    (_("%s: warning: unresolvable relocation against symbol `%s' from %s section"),
		     bfd_archive_filename (input_bfd), h->root.root.string,
		     bfd_get_section_name (input_bfd, input_section));
d1722 2
a1723 2
	 	     (!info->shared || info->no_undefined
		      || ELF_ST_VISIBILITY (h->other)))))
d1728 1
a1728 1

d1736 3
a1738 2
	  BFD_ASSERT (sgot != NULL);

d1741 2
a1742 2
              bfd_vma off;

d1744 2
a1745 3
              BFD_ASSERT (off != (bfd_vma) -1);

              if (! elf_hash_table (info)->dynamic_sections_created
d1747 3
a1749 1
                      && (info->symbolic || h->dynindx == -1)
d1769 1
a1769 1
				  sgot->contents + off);
d1773 2
a1774 1
	      relocation = sgot->output_offset + off;
d1778 2
a1779 4
              bfd_vma off;

              BFD_ASSERT (local_got_offsets != NULL
                          && local_got_offsets[r_symndx] != (bfd_vma) -1);
d1790 2
a1791 1
                  bfd_put_32 (output_bfd, relocation, sgot->contents + off);
d1797 1
d1799 3
a1801 2
                      srelgot = bfd_get_section_by_name (dynobj, ".rela.got");
                      BFD_ASSERT (srelgot != NULL);
d1803 2
a1804 2
                      outrel.r_offset = (sgot->output_section->vma
                                         + sgot->output_offset
d1808 3
a1810 5
                      bfd_elf32_swap_reloca_out (output_bfd, &outrel,
                                                (((Elf32_External_Rela *)
                                                  srelgot->contents)
                                                 + srelgot->reloc_count));
                      ++srelgot->reloc_count;
a1814 2

	      relocation = sgot->output_offset + off;
d1817 2
d1820 1
a1826 6
          if (sgot == NULL)
            {
              sgot = bfd_get_section_by_name (dynobj, ".got");
              BFD_ASSERT (sgot != NULL);
            }

d1832 1
a1832 2
          relocation -= sgot->output_section->vma;

d1837 2
a1838 9

          if (sgot == NULL)
            {
              sgot = bfd_get_section_by_name (dynobj, ".got");
              BFD_ASSERT (sgot != NULL);
            }

          relocation = sgot->output_section->vma;

d1851 2
a1852 1
          if (h->plt.offset == (bfd_vma) -1 || splt == NULL)
d1860 2
a1861 2
          relocation = (splt->output_section->vma
                        + splt->output_offset
d1863 1
a1863 1

d1872 21
a1892 10
          if (info->shared
              && (input_section->flags & SEC_ALLOC) != 0
              && ((r_type != R_390_PC16 &&
                   r_type != R_390_PC16DBL &&
                   r_type != R_390_PC32)
                  || (h != NULL
                      && h->dynindx != -1
                      && (! info->symbolic
                          || (h->elf_link_hash_flags
                              & ELF_LINK_HASH_DEF_REGULAR) == 0))))
d1896 7
a1902 25

              /* When generating a shared object, these relocations
                 are copied into the output file to be resolved at run
                 time.  */

              if (sreloc == NULL)
                {
                  const char *name;

                  name = (bfd_elf_string_from_elf_section
                          (input_bfd,
                           elf_elfheader (input_bfd)->e_shstrndx,
                           elf_section_data (input_section)->rel_hdr.sh_name));
                  if (name == NULL)
                    return false;

                  BFD_ASSERT (strncmp (name, ".rela", 5) == 0
                              && strcmp (bfd_get_section_name (input_bfd,
                                                               input_section),
                                         name + 5) == 0);

                  sreloc = bfd_get_section_by_name (dynobj, name);
                  BFD_ASSERT (sreloc != NULL);
                }

d1904 1
a1904 1

a1908 2
                  bfd_vma off;

d1910 1
a1910 2
                         (output_bfd, &elf_hash_table (info)->stab_info,
                          input_section,
d1917 1
a1917 1

d1920 1
a1920 1

d1926 9
a1934 3
              else if (r_type == R_390_PC16 ||
                       r_type == R_390_PC16DBL ||
                       r_type == R_390_PC32)
a1935 1
                  BFD_ASSERT (h != NULL && h->dynindx != -1);
d1942 4
a1945 18
                  /* h->dynindx may be -1 if this symbol was marked to
                     become local.  */
                  if (h == NULL
                      || ((info->symbolic || h->dynindx == -1)
                          && (h->elf_link_hash_flags
                              & ELF_LINK_HASH_DEF_REGULAR) != 0))
                    {
                      relocate = true;
                      outrel.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
		      outrel.r_addend = relocation + rel->r_addend;
                    }
		  else
		    {
		      BFD_ASSERT (h->dynindx != -1);
		      relocate = false;
		      outrel.r_info = ELF32_R_INFO (h->dynindx, R_390_32);
		      outrel.r_addend = relocation + rel->r_addend;
		    }
d1947 9
a1955 7

              bfd_elf32_swap_reloca_out (output_bfd, &outrel,
                                        (((Elf32_External_Rela *)
                                          sreloc->contents)
                                         + sreloc->reloc_count));
              ++sreloc->reloc_count;

d1963 18
a1980 7

          break;

        default:
          break;
        }

d1982 3
a1984 3
				      contents, rel->r_offset,
				      relocation, rel->r_addend);

d1987 24
a2010 1
	  switch (r)
d2012 6
a2017 25
	    default:
	    case bfd_reloc_outofrange:
	      abort ();
	    case bfd_reloc_overflow:
	      {
		const char *name;

		if (h != NULL)
		  name = h->root.root.string;
		else
		  {
		    name = bfd_elf_string_from_elf_section (input_bfd,
							    symtab_hdr->sh_link,
							    sym->st_name);
		    if (name == NULL)
		      return false;
		    if (*name == '\0')
		      name = bfd_section_name (input_bfd, sec);
		  }
		if (! ((*info->callbacks->reloc_overflow)
		       (info, name, howto->name, (bfd_vma) 0,
			input_bfd, input_section, rel->r_offset)))
		  return false;
	      }
	      break;
d2021 1
a2021 1

d2035 4
a2038 4
  bfd *dynobj;

  dynobj = elf_hash_table (info)->dynobj;

d2041 2
a2042 2
      asection *splt;
      asection *srela;
d2044 1
d2046 1
a2046 4
      bfd_vma got_offset;
      bfd_vma plt_index;
      asection *sgot;

d2049 6
a2054 7

      BFD_ASSERT (h->dynindx != -1);

      splt = bfd_get_section_by_name (dynobj, ".plt");
      sgot = bfd_get_section_by_name (dynobj, ".got.plt");
      srela = bfd_get_section_by_name (dynobj, ".rela.plt");
      BFD_ASSERT (splt != NULL && sgot != NULL && srela != NULL);
d2075 19
a2093 19
       {
        bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD0,
                    splt->contents + h->plt.offset);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD1,
                    splt->contents + h->plt.offset + 4);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD2,
                    splt->contents + h->plt.offset + 8);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD3,
                    splt->contents + h->plt.offset + 12);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_ENTRY_WORD4,
                    splt->contents + h->plt.offset + 16);
        bfd_put_32 (output_bfd, (bfd_vma) 0 + (relative_offset << 16),
                    splt->contents + h->plt.offset + 20);
        bfd_put_32 (output_bfd,
                    (sgot->output_section->vma
		     + sgot->output_offset
		     + got_offset),
                     splt->contents + h->plt.offset + 24);
       }
d2095 16
a2110 16
       {
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD0 + got_offset,
                    splt->contents + h->plt.offset);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD1,
                    splt->contents + h->plt.offset + 4);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD2,
                    splt->contents + h->plt.offset + 8);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD3,
                    splt->contents + h->plt.offset + 12);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC12_ENTRY_WORD4,
                    splt->contents + h->plt.offset + 16);
        bfd_put_32 (output_bfd, (bfd_vma) 0 + (relative_offset << 16),
                    splt->contents + h->plt.offset + 20);
        bfd_put_32 (output_bfd, (bfd_vma) 0,
                    splt->contents + h->plt.offset + 24);
       }
d2112 16
a2127 16
       {
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD0 + got_offset,
                    splt->contents + h->plt.offset);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD1,
                    splt->contents + h->plt.offset + 4);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD2,
                    splt->contents + h->plt.offset + 8);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD3,
                    splt->contents + h->plt.offset + 12);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC16_ENTRY_WORD4,
                    splt->contents + h->plt.offset + 16);
        bfd_put_32 (output_bfd, (bfd_vma) 0 + (relative_offset << 16),
                    splt->contents + h->plt.offset + 20);
        bfd_put_32 (output_bfd, (bfd_vma) 0,
                    splt->contents + h->plt.offset + 24);
       }
d2129 16
a2144 16
       {
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD0,
		    splt->contents + h->plt.offset);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD1,
		    splt->contents + h->plt.offset + 4);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD2,
		    splt->contents + h->plt.offset + 8);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD3,
		    splt->contents + h->plt.offset + 12);
        bfd_put_32 (output_bfd, (bfd_vma) PLT_PIC_ENTRY_WORD4,
		    splt->contents + h->plt.offset + 16);
        bfd_put_32 (output_bfd, (bfd_vma) 0 + (relative_offset << 16),
		    splt->contents + h->plt.offset + 20);
        bfd_put_32 (output_bfd, got_offset,
		    splt->contents + h->plt.offset + 24);
       }
d2147 1
a2147 10
                  splt->contents + h->plt.offset + 28);
      /* Fill in the entry in the .rela.plt section.  */
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
		       + got_offset);
      rela.r_info = ELF32_R_INFO (h->dynindx, R_390_JMP_SLOT);
      rela.r_addend = 0;
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) srela->contents
				  + plt_index ));
d2152 2
a2153 2
		  (splt->output_section->vma
		   + splt->output_offset
d2156 1
a2156 2
		  sgot->contents + got_offset);

d2158 9
d2170 4
a2173 1
	     the .plt section.  Leave the value alone.  */
d2177 1
a2177 1

a2179 2
      asection *sgot;
      asection *srela;
d2181 1
d2186 2
a2187 3
      sgot = bfd_get_section_by_name (dynobj, ".got");
      srela = bfd_get_section_by_name (dynobj, ".rela.got");
      BFD_ASSERT (sgot != NULL && srela != NULL);
d2189 2
a2190 2
      rela.r_offset = (sgot->output_section->vma
		       + sgot->output_offset
d2198 9
a2206 7
      if (! elf_hash_table (info)->dynamic_sections_created
	  || (info->shared
	      && (info->symbolic || h->dynindx == -1)
	      && (h->elf_link_hash_flags & ELF_LINK_HASH_DEF_REGULAR)))
        {
          rela.r_info = ELF32_R_INFO (0, R_390_RELATIVE);
          rela.r_addend = (h->root.u.def.value
d2213 1
a2213 1
	  bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + h->got.offset);
d2218 3
a2220 4
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) srela->contents
				  + srela->reloc_count));
      ++srela->reloc_count;
a2224 1
      asection *s;
d2226 1
d2230 5
a2234 8
      BFD_ASSERT (h->dynindx != -1
		  && (h->root.type == bfd_link_hash_defined
		      || h->root.type == bfd_link_hash_defweak));


      s = bfd_get_section_by_name (h->root.u.def.section->owner,
				   ".rela.bss");
      BFD_ASSERT (s != NULL);
d2241 3
a2243 4
      bfd_elf32_swap_reloca_out (output_bfd, &rela,
				 ((Elf32_External_Rela *) s->contents
				  + s->reloc_count));
      ++s->reloc_count;
d2255 20
d2282 1
a2284 3
  asection *sgot;

  dynobj = elf_hash_table (info)->dynobj;
d2286 2
a2287 2
  sgot = bfd_get_section_by_name (dynobj, ".got.plt");
  BFD_ASSERT (sgot != NULL);
d2290 1
a2290 1
  if (elf_hash_table (info)->dynamic_sections_created)
a2291 1
      asection *splt;
d2294 2
a2295 1
      BFD_ASSERT (sdyn != NULL);
a2301 1
	  const char *name;
d2303 1
a2303 1

d2305 1
a2305 1

d2309 4
d2314 1
a2314 4

	    case DT_PLTGOT:
	      name = ".got";
	      goto get_vma;
d2316 1
a2316 6
	      name = ".rela.plt";
	    get_vma:
	      s = bfd_get_section_by_name(output_bfd, name);
	      BFD_ASSERT (s != NULL);
	      dyn.d_un.d_ptr = s->vma;
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d2320 1
a2320 2
	      s = bfd_get_section_by_name (output_bfd, ".rela.plt");
	      BFD_ASSERT (s != NULL);
a2324 1
	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
d2327 2
d2332 1
a2332 2
      splt = bfd_get_section_by_name (dynobj, ".plt");
      if (splt && splt->_raw_size > 0)
d2334 1
a2334 1
          memset (splt->contents, 0, PLT_FIRST_ENTRY_SIZE);
d2336 1
a2336 1
           {
d2338 1
a2338 1
		          splt->contents );
d2340 1
a2340 1
		          splt->contents + 4 );
d2342 1
a2342 1
		          splt->contents + 8 );
d2344 1
a2344 1
		          splt->contents + 12 );
d2346 1
a2346 1
		          splt->contents + 16 );
d2350 2
a2351 2
              bfd_put_32 (output_bfd, (bfd_vma) PLT_FIRST_ENTRY_WORD0,
                          splt->contents );
d2353 1
a2353 1
                          splt->contents + 4 );
d2355 1
a2355 1
                          splt->contents + 8 );
d2357 1
a2357 1
                          splt->contents + 12 );
d2359 1
a2359 1
                          splt->contents + 16 );
d2361 1
a2361 1
                          splt->contents + 20 );
d2363 3
a2365 2
                          sgot->output_section->vma + sgot->output_offset,
                          splt->contents + 24);
d2367 2
a2368 1
	  elf_section_data (splt->output_section)->this_hdr.sh_entsize = 4;
d2373 1
a2373 3
  /* Set the first entry in the global offset table to the address of
     the dynamic section.  */
  if (sgot->_raw_size > 0)
d2375 12
a2386 6
      if (sdyn == NULL)
	bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents);
      else
	bfd_put_32 (output_bfd,
		    sdyn->output_section->vma + sdyn->output_offset,
		    sgot->contents);
d2388 2
a2389 4
      /* One entry for shared object struct ptr.  */
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 4);
      /* One entry for _dl_runtime_resolve.  */
      bfd_put_32 (output_bfd, (bfd_vma) 0, sgot->contents + 8);
a2390 3

  elf_section_data (sgot->output_section)->this_hdr.sh_entsize = 4;

a2400 17
static enum elf_reloc_type_class
elf_s390_reloc_type_class (rela)
     const Elf_Internal_Rela *rela;
{
  switch ((int) ELF32_R_TYPE (rela->r_info))
    {
    case R_390_RELATIVE:
      return reloc_class_relative;
    case R_390_JMP_SLOT:
      return reloc_class_plt;
    case R_390_COPY:
      return reloc_class_copy;
    default:
      return reloc_class_normal;
    }
}

a2417 1
#define bfd_elf32_bfd_final_link	      _bfd_elf32_gc_common_final_link
d2424 2
a2425 1
#define elf_backend_create_dynamic_sections   _bfd_elf_create_dynamic_sections
d2430 1
@


1.9
log
@	* elf-bfd.h (struct elf_link_local_dynamic_entry): Add init_refcount.
	(struct elf_backend_data): Add can_refcount.
	* elf.c (_bfd_elf_link_hash_newfunc): Get rid of a few casts.  Set
	got.refcount and plt.refcount from init_refcount.
	(_bfd_elf_link_hash_table_init): Set up init_refcount.
	(_bfd_elf_link_hash_copy_indirect): Reference got/plt.refcount
	rather than got/plt.offset, and test for <= 0 rather than -1.
	* elflink.h (size_dynamic_sections): Set init_refcount to -1.
	* elfxx-target.h (elf_backend_can_refcount): Define.
	(elfNN_bed): Init can_refcount.
	* linker.c (_bfd_link_hash_newfunc): Get rid of a few casts.
	(_bfd_generic_link_hash_newfunc): Likewise.
	* elf32-cris.c (cris_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-hppa.c (elf32_hppa_check_relocs): Modify for refcounts
	starting from zero.
	(elf32_hppa_copy_indirect_symbol): Make static to agree with
	prototype.
	(elf_backend_can_refcount): Define.
	* elf32-i386.c (elf_i386_check_relocs): Modify for refcounts
	starting from zero.
	(allocate_dynrelocs): Set plt/got.offset rather than *.refcount.
	(elf_i386_finish_dynamic_symbol): Expand SHN_UNDEF comment.
	(elf_i386_finish_dynamic_sections): Use local var so line < 80 chars.
	(elf_backend_can_refcount): Define.
	(elf_i386_copy_indirect_symbol): Make static to agree with
	prototype.  Formatting fix.
	* elf32-m68k.c (elf_m68k_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-ppc.c (ppc_elf_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf32-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-s390.c (elf_s390_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Modify for refcounts
	starting from zero.
	(elf_backend_can_refcount): Define.
@
text
@d1001 2
@


1.8
log
@	* elf-bfd.h (elf_backend_reloc_type_class): Pass in the entire
	reloc rather than just the type.
	(_bfd_elf_reloc_type_class): Likewise.
	* elf.c (_bfd_elf_reloc_type_class): Likewise.
	* elf32-arm.h (elf32_arm_reloc_type_class): Likewise.
	* elf32-cris.c (elf_cris_reloc_type_class): Likewise.
	* elf32-i386.c (elf_i386_reloc_type_class): Likewise.
	* elf32-m68k.c (elf32_m68k_reloc_type_class): Likewise.
	* elf32-ppc.c (ppc_elf_reloc_type_class): Likewise.
	* elf32-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf32-sh.c (sh_elf_reloc_type_class): Likewise.
	* elf32-sparc.c (elf32_sparc_reloc_type_class): Likewise.
	* elf64-alpha.c (elf64_alpha_reloc_type_class): Likewise.
	* elf64-s390.c (elf_s390_reloc_type_class): Likewise.
	* elf64-sparc.c (sparc64_elf_reloc_type_class): Likewise.
	* elf64-x86-64.c (elf64_x86_64_reloc_type_class): Likewise.
	* elfxx-ia64.c (elfNN_ia64_reloc_type_class): Likewise.
	* elflink.h: Formatting fixes.
	(elf_link_sort_relocs): Make "count" and "size" bfd_size_type.
	Call bfd_zmalloc rather than calloc.  Remove unnecessary cast of
	o->contents to PTR.  Update call to elf_backend_reloc_type_class.
@
text
@d580 1
a580 1
	      if (h->got.refcount == -1)
a581 2
		  h->got.refcount = 1;

d592 1
a592 2
	      else
		h->got.refcount += 1;
d604 1
a604 1
		                         bfd_alloc (abfd, size);
a607 1
		  memset (local_got_refcounts, -1, (size_t) size);
d609 1
a609 1
	      if (local_got_refcounts[r_symndx] == -1)
a610 2
		  local_got_refcounts[r_symndx] = 1;

d620 1
a620 2
	      else
		local_got_refcounts[r_symndx] += 1;
d638 2
a639 7
	  if (h->plt.refcount == -1)
	    {
	      h->plt.refcount = 1;
	      h->elf_link_hash_flags |= ELF_LINK_HASH_NEEDS_PLT;
	    }
	  else
	    h->plt.refcount += 1;
d2155 1
@


1.7
log
@	* bfd.c (bfd_archive_filename): New function.
	* bfd-in2.h: Regenerate.
	* aout-adobe.c: Replace bfd_get_filename with bfd_archive_filename
	in error messages where the bfd is an input bfd.
	* aout-cris.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-mcore.c: Likewise.
	* coff-ppc.c: Likewise.
	* coff-rs6000.c: Likewise.
	* coff-sh.c: Likewise.
	* coff-tic54x.c: Likewise.
	* coff-tic80.c: Likewise.
	* coff64-rs6000.c: Likewise.
	* coffcode.h: Likewise.
	* coffgen.c: Likewise.
	* cofflink.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-hppa.h: Likewise.
	* elf.c: Likewise.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-gen.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-gen.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.h: Likewise.
	* elfxx-ia64.c: Likewise.
	* ieee.c: Likewise.
	* ihex.c: Likewise.
	* libbfd.c: Likewise.
	* pdp11.c: Likewise.
	* pe-mips.c: Likewise.
	* peicode.h: Likewise.
	* srec.c: Likewise.
	* xcofflink.c: Likewise.

	* elf32-arm.h: Make _bfd_error_handler calls K&R compatible.

	* elflink.c (_bfd_elf_create_linker_section): Better grammar for
	error message.

	* coff-mcore.c (coff_mcore_relocate_section): Internalionalise
	error message.

	* elf64-sparc.c (sparc64_elf_add_symbol_hook): Constify stt_types.
	Consolidate error messages, and split long messages to two lines.
@
text
@d59 2
a60 1
static enum elf_reloc_type_class elf_s390_reloc_type_class PARAMS ((int));
d2143 2
a2144 2
elf_s390_reloc_type_class (type)
     int type;
d2146 1
a2146 1
  switch (type)
@


1.6
log
@coordinate info->symbolic and info->allow_shlib_undefined
@
text
@d1436 1
a1436 1
		     bfd_get_filename (input_bfd), h->root.root.string,
@


1.5
log
@Touches most files in bfd/, so likely will be blamed for everything..

o  bfd_read and bfd_write lose an unnecessary param and become
   bfd_bread and bfd_bwrite.

o  bfd_*alloc now all take a bfd_size_type arg, and will error if
   size_t is too small.  eg. 32 bit host, 64 bit bfd, verrry big files
   or bugs in linker scripts etc.

o  file_ptr becomes a bfd_signed_vma.  Besides matching sizes with
   various other types involved in handling sections, this should make
   it easier for bfd to support a 64 bit off_t on 32 bit hosts that
   provide it.

o  I've made the H_GET_* and H_PUT_* macros (which invoke bfd_h_{get,put}_*)
   generally available.  They now cast their args to bfd_vma and
   bfd_byte * as appropriate, which removes a swag of casts from the
   source.

o  Bug fixes to bfd_get8, aix386_core_vec, elf32_h8_relax_section, and
   aout-encap.c.

o  Zillions of formatting and -Wconversion fixes.
@
text
@d1447 2
a1448 1
	  else if (info->shared && !info->symbolic
@


1.4
log
@	* elf64-s390.c (elf_s390_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf_s390_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_s390_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.

	* elf32-s390.c (elf_s390_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf_s390_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_s390_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.

	* elf32-ppc.c (ppc_elf_check_relocs): Set DF_TEXTREL if the reloc
	is against read-only section.
	(ppc_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(ppc_elf_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
@
text
@d107 1
a107 1
  HOWTO (R_390_GNU_VTENTRY, 0,2,0,false,0,complain_overflow_dont, _bfd_elf_rel_vtable_reloc_fn,"R_390_GNU_VTENTRY", false,0,0, false); 
d160 1
a160 1
    break;                                         
d187 1
a187 1
    }     
d216 1
a216 1
#define PLT_ENTRY_SIZE 32 
d230 1
a230 1
   Furthermore, only r 0 and 1 are free to use!!!  */ 
d244 1
a244 1
   28(15) =  Offset in symbol table                                             
d337 1
a337 1
   ST   1,24(15)  # Store address 
d459 1
d461 1
a461 2
  ret = ((struct elf_s390_link_hash_table *)
	 bfd_alloc (abfd, sizeof (struct elf_s390_link_hash_table)));
d520 1
a520 1
	h = sym_hashes[r_symndx - symtab_hdr->sh_info];      
d601 1
a601 1
		  size_t size;
d603 2
a604 1
		  size = symtab_hdr->sh_info * sizeof (bfd_signed_vma);
d610 1
a610 1
		  memset (local_got_refcounts, -1, size);
d748 1
a748 1
			   bfd_alloc (dynobj, sizeof *p));
d776 1
a776 1
                   
d1224 3
d1229 1
a1229 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_DEBUG, 0))
d1235 4
a1238 4
	  if (! bfd_elf32_add_dynamic_entry (info, DT_PLTGOT, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTRELSZ, 0)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_PLTREL, DT_RELA)
	      || ! bfd_elf32_add_dynamic_entry (info, DT_JMPREL, 0))
d1244 3
a1246 4
          if (! bfd_elf32_add_dynamic_entry (info, DT_RELA, 0)
              || ! bfd_elf32_add_dynamic_entry (info, DT_RELASZ, 0)
              || ! bfd_elf32_add_dynamic_entry (info, DT_RELAENT,
					    sizeof (Elf32_External_Rela)))
d1252 1
a1252 1
	  if (! bfd_elf32_add_dynamic_entry (info, DT_TEXTREL, 0))
d1257 1
d1553 1
a1553 1
 
d1805 1
a1805 1
      /* Calc. index no. 
d1814 2
a1815 2
      relative_offset = - ((PLT_FIRST_ENTRY_SIZE + 
                           (PLT_ENTRY_SIZE * plt_index) + 18)/2);
d1818 3
a1820 2
      if ( -32768 > (int)relative_offset )
          relative_offset = -(((65536/PLT_ENTRY_SIZE-1)*PLT_ENTRY_SIZE)/2);
d1825 1
a1825 1
        bfd_put_32 (output_bfd, PLT_ENTRY_WORD0,
d1827 1
a1827 1
        bfd_put_32 (output_bfd, PLT_ENTRY_WORD1,
d1829 1
a1829 1
        bfd_put_32 (output_bfd, PLT_ENTRY_WORD2,
d1831 1
a1831 1
        bfd_put_32 (output_bfd, PLT_ENTRY_WORD3,
d1833 1
a1833 1
        bfd_put_32 (output_bfd, PLT_ENTRY_WORD4,
d1835 1
a1835 1
        bfd_put_32 (output_bfd, 0+(relative_offset << 16),
d1838 3
a1840 3
                    (sgot->output_section->vma +
                     sgot->output_offset +
                     got_offset),
d1845 1
a1845 1
        bfd_put_32 (output_bfd, PLT_PIC12_ENTRY_WORD0 + got_offset,
d1847 1
a1847 1
        bfd_put_32 (output_bfd, PLT_PIC12_ENTRY_WORD1,
d1849 1
a1849 1
        bfd_put_32 (output_bfd, PLT_PIC12_ENTRY_WORD2,
d1851 1
a1851 1
        bfd_put_32 (output_bfd, PLT_PIC12_ENTRY_WORD3,
d1853 1
a1853 1
        bfd_put_32 (output_bfd, PLT_PIC12_ENTRY_WORD4,
d1855 1
a1855 1
        bfd_put_32 (output_bfd, 0+(relative_offset << 16),
d1857 1
a1857 1
        bfd_put_32 (output_bfd, 0,
d1862 1
a1862 1
        bfd_put_32 (output_bfd, PLT_PIC16_ENTRY_WORD0 + got_offset,
d1864 1
a1864 1
        bfd_put_32 (output_bfd, PLT_PIC16_ENTRY_WORD1,
d1866 1
a1866 1
        bfd_put_32 (output_bfd, PLT_PIC16_ENTRY_WORD2,
d1868 1
a1868 1
        bfd_put_32 (output_bfd, PLT_PIC16_ENTRY_WORD3,
d1870 1
a1870 1
        bfd_put_32 (output_bfd, PLT_PIC16_ENTRY_WORD4,
d1872 1
a1872 1
        bfd_put_32 (output_bfd, 0+(relative_offset << 16),
d1874 1
a1874 1
        bfd_put_32 (output_bfd, 0,
d1879 1
a1879 1
        bfd_put_32 (output_bfd, PLT_PIC_ENTRY_WORD0,
d1881 1
a1881 1
        bfd_put_32 (output_bfd, PLT_PIC_ENTRY_WORD1,
d1883 1
a1883 1
        bfd_put_32 (output_bfd, PLT_PIC_ENTRY_WORD2,
d1885 1
a1885 1
        bfd_put_32 (output_bfd, PLT_PIC_ENTRY_WORD3, 
d1887 1
a1887 1
        bfd_put_32 (output_bfd, PLT_PIC_ENTRY_WORD4,
d1889 1
a1889 1
        bfd_put_32 (output_bfd, 0+(relative_offset << 16),
d1940 1
a1940 1
		       + (h->got.offset &~ 1));
d2077 1
a2077 1
	      bfd_put_32 (output_bfd, PLT_PIC_FIRST_ENTRY_WORD0,
d2079 8
a2086 8
	      bfd_put_32 (output_bfd, PLT_PIC_FIRST_ENTRY_WORD1,
		          splt->contents +4 );
	      bfd_put_32 (output_bfd, PLT_PIC_FIRST_ENTRY_WORD2,
		          splt->contents +8 );
	      bfd_put_32 (output_bfd, PLT_PIC_FIRST_ENTRY_WORD3,
		          splt->contents +12 );
	      bfd_put_32 (output_bfd, PLT_PIC_FIRST_ENTRY_WORD4,
		          splt->contents +16 );
d2090 1
a2090 1
              bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD0,
d2092 10
a2101 10
              bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD1,
                          splt->contents +4 );
              bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD2,
                          splt->contents +8 );
              bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD3,
                          splt->contents +12 );
              bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD4,
                          splt->contents +16 );
              bfd_put_32 (output_bfd, PLT_FIRST_ENTRY_WORD5,
                          splt->contents +20 );
@


1.3
log
@	* coff-sparc.c: Add missing prototypes.
	* elf32-s390.c: Likewise.
	* elf32-i960.c: Likewise.
	* aout-target.h: Likewise.
@
text
@d59 1
d716 2
d1095 1
a1095 1
     bfd *output_bfd;
a1099 1
  boolean reltext;
a1141 1
  reltext = false;
a1187 2
	      asection *target;

d1191 1
a1191 18
		{
		  const char *outname;

		  relocs = true;

		  /* If this relocation section applies to a read only
		     section, then we probably need a DT_TEXTREL
		     entry.  The entries in the .rela.plt section
		     really apply to the .got section, which we
		     created ourselves and so know is not readonly.  */
		  outname = bfd_get_section_name (output_bfd,
						  s->output_section);
		  target = bfd_get_section_by_name (output_bfd, outname + 5);
		  if (target != NULL
		      && (target->flags & SEC_READONLY) != 0
		      && (target->flags & SEC_ALLOC) != 0)
		    reltext = true;
		}
d1247 1
a1247 1
      if (reltext)
d2135 17
d2182 1
@


1.2
log
@Update copyright notices
@
text
@d40 6
d58 1
@


1.1
log
@Add s390 support
@
text
@d2 1
a2 1
   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
@

