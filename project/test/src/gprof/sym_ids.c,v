head	1.20;
access;
symbols
	binutils-2_24-branch:1.20.0.10
	binutils-2_24-branchpoint:1.20
	binutils-2_21_1:1.20
	binutils-2_23_2:1.20
	binutils-2_23_1:1.20
	binutils-2_23:1.20
	binutils-2_23-branch:1.20.0.8
	binutils-2_23-branchpoint:1.20
	binutils-2_22_branch:1.20.0.6
	binutils-2_22:1.20
	binutils-2_22-branch:1.20.0.4
	binutils-2_22-branchpoint:1.20
	binutils-2_21:1.20
	binutils-2_21-branch:1.20.0.2
	binutils-2_21-branchpoint:1.20
	binutils-2_20_1:1.19.8.1
	binutils-2_20:1.19.8.1
	binutils-arc-20081103-branch:1.19.0.10
	binutils-arc-20081103-branchpoint:1.19
	binutils-2_20-branch:1.19.0.8
	binutils-2_20-branchpoint:1.19
	dje-cgen-play1-branch:1.19.0.6
	dje-cgen-play1-branchpoint:1.19
	arc-20081103-branch:1.19.0.4
	arc-20081103-branchpoint:1.19
	binutils-2_19_1:1.19
	binutils-2_19:1.19
	binutils-2_19-branch:1.19.0.2
	binutils-2_19-branchpoint:1.19
	binutils-2_18:1.18
	binutils-2_18-branch:1.18.0.2
	binutils-2_18-branchpoint:1.18
	binutils-csl-coldfire-4_1-32:1.16
	binutils-csl-sourcerygxx-4_1-32:1.16
	binutils-csl-innovasic-fido-3_4_4-33:1.16
	binutils-csl-sourcerygxx-3_4_4-32:1.14
	binutils-csl-coldfire-4_1-30:1.16
	binutils-csl-sourcerygxx-4_1-30:1.16
	binutils-csl-coldfire-4_1-28:1.16
	binutils-csl-sourcerygxx-4_1-29:1.16
	binutils-csl-sourcerygxx-4_1-28:1.16
	binutils-csl-arm-2006q3-27:1.16
	binutils-csl-sourcerygxx-4_1-27:1.16
	binutils-csl-arm-2006q3-26:1.16
	binutils-csl-sourcerygxx-4_1-26:1.16
	binutils-csl-sourcerygxx-4_1-25:1.16
	binutils-csl-sourcerygxx-4_1-24:1.16
	binutils-csl-sourcerygxx-4_1-23:1.16
	binutils-csl-sourcerygxx-4_1-21:1.16
	binutils-csl-arm-2006q3-21:1.16
	binutils-csl-sourcerygxx-4_1-22:1.16
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.16
	binutils-csl-sourcerygxx-4_1-20:1.16
	binutils-csl-arm-2006q3-19:1.16
	binutils-csl-sourcerygxx-4_1-19:1.16
	binutils-csl-sourcerygxx-4_1-18:1.16
	binutils-csl-renesas-4_1-9:1.16
	binutils-csl-sourcerygxx-3_4_4-25:1.14
	binutils-csl-renesas-4_1-8:1.16
	binutils-csl-renesas-4_1-7:1.16
	binutils-csl-renesas-4_1-6:1.16
	binutils-csl-sourcerygxx-4_1-17:1.16
	binutils-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-15:1.16
	binutils-csl-sourcerygxx-4_1-13:1.16
	binutils-2_17:1.16
	binutils-csl-sourcerygxx-4_1-12:1.16
	binutils-csl-sourcerygxx-3_4_4-21:1.16
	binutils-csl-wrs-linux-3_4_4-24:1.14
	binutils-csl-wrs-linux-3_4_4-23:1.14
	binutils-csl-sourcerygxx-4_1-9:1.16
	binutils-csl-sourcerygxx-4_1-8:1.16
	binutils-csl-sourcerygxx-4_1-7:1.16
	binutils-csl-arm-2006q1-6:1.16
	binutils-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-wrs-linux-3_4_4-22:1.14
	binutils-csl-coldfire-4_1-11:1.16
	binutils-csl-sourcerygxx-3_4_4-19:1.16
	binutils-csl-coldfire-4_1-10:1.16
	binutils-csl-sourcerygxx-4_1-5:1.16
	binutils-csl-sourcerygxx-4_1-4:1.16
	binutils-csl-wrs-linux-3_4_4-21:1.14
	binutils-csl-morpho-4_1-4:1.16
	binutils-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-wrs-linux-3_4_4-20:1.14
	binutils-2_17-branch:1.16.0.4
	binutils-2_17-branchpoint:1.16
	binutils-csl-2_17-branch:1.16.0.2
	binutils-csl-2_17-branchpoint:1.16
	binutils-csl-gxxpro-3_4-branch:1.14.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.14
	binutils-2_16_1:1.14
	binutils-csl-arm-2005q1b:1.14
	binutils-2_16:1.14
	binutils-csl-arm-2005q1a:1.14
	binutils-csl-arm-2005q1-branch:1.14.0.4
	binutils-csl-arm-2005q1-branchpoint:1.14
	binutils-2_16-branch:1.14.0.2
	binutils-2_16-branchpoint:1.14
	csl-arm-2004-q3d:1.13
	csl-arm-2004-q3:1.13
	gprof-pre-ansify-2004-05-26:1.12
	gprof-post-ansify-2004-05-26:1.13
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	binutils-2_15-branch:1.12.0.8
	cagney_bfdfile-20040213-branch:1.12.0.6
	cagney_bfdfile-20040213-branchpoint:1.12
	cagney_bigcore-20040122-branch:1.12.0.4
	cagney_bigcore-20040122-branchpoint:1.12
	csl-arm-2003-q4:1.12
	binutils-2_14:1.12
	binutils-2_14-branch:1.12.0.2
	binutils-2_14-branchpoint:1.12
	binutils-2_13_2_1:1.11
	binutils-2_13_2:1.11
	binutils-2_13_1:1.11
	binutils-2_13:1.11
	binutils-2_13-branchpoint:1.11
	binutils-2_13-branch:1.11.0.4
	binutils-2_12_1:1.11
	binutils-2_12:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	cygnus_cvs_20020108_pre:1.8
	binutils-2_11_2:1.5.2.2
	binutils-2_11_1:1.5.2.2
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	binutils-2_10_1:1.3.2.1
	binutils-2_10:1.3.2.1
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.20
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2009.09.11.15.27.34;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.19.16.30.29;	author schwab;	state Exp;
branches
	1.19.8.1;
next	1.18;

1.18
date	2007.07.06.10.40.34;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.19.10.46.56;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.09.06.55.25;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.23.17.13.31;	author bje;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.03.12.05.12;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.26.04.55.55;	author bje;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.01.08.24.16;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.01.01.18.06;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.31.12.56.07;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.19.05.33.31;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.14.03.14.56;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.21.07.30;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.24.20.59.03;	author nickc;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.05.26.13.11.56;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	99.07.11.20.06.47;	author ian;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.06.30.22.38.24;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.19.8.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.16.28;	author amodra;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.06.11.10.05.03;	author amodra;	state Exp;
branches;
next	;

1.3.2.1
date	2000.05.28.10.57.51;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches;
next	;


desc
@@


1.20
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@/* sym_ids.c

   Copyright 1999, 2000, 2001, 2002, 2004, 2007 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "gprof.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "cg_arcs.h"
#include "sym_ids.h"
#include "corefile.h"

struct match
  {
    int prev_index;	/* Index of prev match.  */
    Sym *prev_match;	/* Previous match.  */
    Sym *first_match;	/* Chain of all matches.  */
    Sym sym;
  };

struct sym_id
  {
    struct sym_id *next;
    char *spec;			/* Parsing modifies this.  */
    Table_Id which_table;
    bfd_boolean has_right;

    struct match left, right;
  };

static struct sym_id  *id_list;

static void parse_spec
  (char *, Sym *);
static void parse_id
  (struct sym_id *);
static bfd_boolean match
  (Sym *, Sym *);
static void extend_match
  (struct match *, Sym *, Sym_Table *, bfd_boolean);


Sym_Table syms[NUM_TABLES];

#ifdef DEBUG
static const char *table_name[] =
{
  "INCL_GRAPH", "EXCL_GRAPH",
  "INCL_ARCS", "EXCL_ARCS",
  "INCL_FLAT", "EXCL_FLAT",
  "INCL_TIME", "EXCL_TIME",
  "INCL_ANNO", "EXCL_ANNO",
  "INCL_EXEC", "EXCL_EXEC"
};
#endif /* DEBUG */

/* This is the table in which we keep all the syms that match
   the right half of an arc id.  It is NOT sorted according
   to the addresses, because it is accessed only through
   the left half's CHILDREN pointers (so it's crucial not
   to reorder this table once pointers into it exist).  */
static Sym_Table right_ids;

static Source_File non_existent_file =
{
  0, "<non-existent-file>", 0, 0, 0, NULL
};


void
sym_id_add (const char *spec, Table_Id which_table)
{
  struct sym_id *id;
  int len = strlen (spec);

  id = (struct sym_id *) xmalloc (sizeof (*id) + len + 1);
  memset (id, 0, sizeof (*id));

  id->spec = (char *) id + sizeof (*id);
  strcpy (id->spec, spec);
  id->which_table = which_table;

  id->next = id_list;
  id_list = id;
}


/* A spec has the syntax FILENAME:(FUNCNAME|LINENUM).  As a convenience
   to the user, a spec without a colon is interpreted as:

	(i)   a FILENAME if it contains a dot
	(ii)  a FUNCNAME if it starts with a non-digit character
	(iii) a LINENUM if it starts with a digit

   A FUNCNAME containing a dot can be specified by :FUNCNAME, a
   FILENAME not containing a dot can be specified by FILENAME.  */

static void
parse_spec (char *spec, Sym *sym)
{
  char *colon;

  sym_init (sym);
  colon = strrchr (spec, ':');

  if (colon)
    {
      *colon = '\0';

      if (colon > spec)
	{
	  sym->file = source_file_lookup_name (spec);

	  if (!sym->file)
	    sym->file = &non_existent_file;
	}

      spec = colon + 1;

      if (strlen (spec))
	{
	  if (ISDIGIT (spec[0]))
	    sym->line_num = atoi (spec);
	  else
	    sym->name = spec;
	}
    }
  else if (strlen (spec))
    {
      /* No colon: spec is a filename if it contains a dot.  */
      if (strchr (spec, '.'))
	{
	  sym->file = source_file_lookup_name (spec);

	  if (!sym->file)
	    sym->file = &non_existent_file;
	}
      else if (ISDIGIT (*spec))
	{
	  sym->line_num = atoi (spec);
	}
      else if (strlen (spec))
	{
	  sym->name = spec;
	}
    }
}


/* A symbol id has the syntax SPEC[/SPEC], where SPEC is is defined
   by parse_spec().  */

static void
parse_id (struct sym_id *id)
{
  char *slash;

  DBG (IDDEBUG, printf ("[parse_id] %s -> ", id->spec));

  slash = strchr (id->spec, '/');
  if (slash)
    {
      parse_spec (slash + 1, &id->right.sym);
      *slash = '\0';
      id->has_right = TRUE;
    }
  parse_spec (id->spec, &id->left.sym);

#ifdef DEBUG
  if (debug_level & IDDEBUG)
    {
      printf ("%s:", id->left.sym.file ? id->left.sym.file->name : "*");

      if (id->left.sym.name)
	printf ("%s", id->left.sym.name);
      else if (id->left.sym.line_num)
	printf ("%d", id->left.sym.line_num);
      else
	printf ("*");

      if (id->has_right)
	{
	  printf ("/%s:",
		  id->right.sym.file ? id->right.sym.file->name : "*");

	  if (id->right.sym.name)
	    printf ("%s", id->right.sym.name);
	  else if (id->right.sym.line_num)
	    printf ("%d", id->right.sym.line_num);
	  else
	    printf ("*");
	}

      printf ("\n");
    }
#endif
}


/* Return TRUE iff PATTERN matches SYM.  */

static bfd_boolean
match (Sym *pattern, Sym *sym)
{
  if (pattern->file && pattern->file != sym->file)
    return FALSE;
  if (pattern->line_num && pattern->line_num != sym->line_num)
    return FALSE;
  if (pattern->name)
    {
      const char *sym_name = sym->name;
      if (*sym_name && bfd_get_symbol_leading_char (core_bfd) == *sym_name)
	sym_name++;
      if (strcmp (pattern->name, sym_name) != 0)
	return FALSE;
    }
  return TRUE;
}


static void
extend_match (struct match *m, Sym *sym, Sym_Table *tab, bfd_boolean second_pass)
{
  if (m->prev_match != sym - 1)
    {
      /* Discontinuity: add new match to table.  */
      if (second_pass)
	{
	  tab->base[tab->len] = *sym;
	  m->prev_index = tab->len;

	  /* Link match into match's chain.  */
	  tab->base[tab->len].next = m->first_match;
	  m->first_match = &tab->base[tab->len];
	}

      ++tab->len;
    }

  /* Extend match to include this symbol.  */
  if (second_pass)
    tab->base[m->prev_index].end_addr = sym->end_addr;

  m->prev_match = sym;
}


/* Go through sym_id list produced by option processing and fill
   in the various symbol tables indicating what symbols should
   be displayed or suppressed for the various kinds of outputs.

   This can potentially produce huge tables and in particulars
   tons of arcs, but this happens only if the user makes silly
   requests---you get what you ask for!  */

void
sym_id_parse ()
{
  Sym *sym, *left, *right;
  struct sym_id *id;
  Sym_Table *tab;

  /* Convert symbol ids into Syms, so we can deal with them more easily.  */
  for (id = id_list; id; id = id->next)
    parse_id (id);

  /* First determine size of each table.  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      for (id = id_list; id; id = id->next)
	{
	  if (match (&id->left.sym, sym))
	    extend_match (&id->left, sym, &syms[id->which_table], FALSE);

	  if (id->has_right && match (&id->right.sym, sym))
	    extend_match (&id->right, sym, &right_ids, FALSE);
	}
    }

  /* Create tables of appropriate size and reset lengths.  */
  for (tab = syms; tab < &syms[NUM_TABLES]; ++tab)
    {
      if (tab->len)
	{
	  tab->base = (Sym *) xmalloc (tab->len * sizeof (Sym));
	  tab->limit = tab->base + tab->len;
	  tab->len = 0;
	}
    }

  if (right_ids.len)
    {
      right_ids.base = (Sym *) xmalloc (right_ids.len * sizeof (Sym));
      right_ids.limit = right_ids.base + right_ids.len;
      right_ids.len = 0;
    }

  /* Make a second pass through symtab, creating syms as necessary.  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      for (id = id_list; id; id = id->next)
	{
	  if (match (&id->left.sym, sym))
	    extend_match (&id->left, sym, &syms[id->which_table], TRUE);

	  if (id->has_right && match (&id->right.sym, sym))
	    extend_match (&id->right, sym, &right_ids, TRUE);
	}
    }

  /* Go through ids creating arcs as needed.  */
  for (id = id_list; id; id = id->next)
    {
      if (id->has_right)
	{
	  for (left = id->left.first_match; left; left = left->next)
	    {
	      for (right = id->right.first_match; right; right = right->next)
		{
		  DBG (IDDEBUG,
		       printf (
				"[sym_id_parse]: arc %s:%s(%lx-%lx) -> %s:%s(%lx-%lx) to %s\n",
				left->file ? left->file->name : "*",
				left->name ? left->name : "*",
				(unsigned long) left->addr,
				(unsigned long) left->end_addr,
				right->file ? right->file->name : "*",
				right->name ? right->name : "*",
				(unsigned long) right->addr,
				(unsigned long) right->end_addr,
				table_name[id->which_table]));

		  arc_add (left, right, (unsigned long) 0);
		}
	    }
	}
    }

  /* Finally, we can sort the tables and we're done.  */
  for (tab = &syms[0]; tab < &syms[NUM_TABLES]; ++tab)
    {
      DBG (IDDEBUG, printf ("[sym_id_parse] syms[%s]:\n",
			    table_name[tab - &syms[0]]));
      symtab_finalize (tab);
    }
}


/* Symbol tables storing the FROM symbols of arcs do not necessarily
   have distinct address ranges.  For example, somebody might request
   -k /_mcount to suppress any arcs into _mcount, while at the same
   time requesting -k a/b.  Fortunately, those symbol tables don't get
   very big (the user has to type them!), so a linear search is probably
   tolerable.  */
bfd_boolean
sym_id_arc_is_present (Sym_Table *sym_tab, Sym *from, Sym *to)
{
  Sym *sym;

  for (sym = sym_tab->base; sym < sym_tab->limit; ++sym)
    {
      if (from->addr >= sym->addr && from->addr <= sym->end_addr
	  && arc_lookup (sym, to))
	return TRUE;
    }

  return FALSE;
}
@


1.19
log
@* basic_blocks.c: Always include "gprof.h" first.
* cg_arcs.c: Likewise.
* cg_dfn.c: Likewise.
* cg_print.c: Likewise.
* corefile.c: Likewise.
* gprof.c: Likewise.
* hist.c: Likewise.
* search_list.c: Likewise.
* sym_ids.c: Likewise.
* utils.c: Likewise.
@
text
@d32 9
a40 1
static struct sym_id
d47 4
a50 10
    struct match
      {
	int prev_index;		/* Index of prev match.  */
	Sym *prev_match;	/* Previous match.  */
	Sym *first_match;	/* Chain of all matches.  */
	Sym sym;
      }
    left, right;
  }
 *id_list;
@


1.19.8.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d32 1
a32 9
struct match
  {
    int prev_index;	/* Index of prev match.  */
    Sym *prev_match;	/* Previous match.  */
    Sym *first_match;	/* Chain of all matches.  */
    Sym sym;
  };

struct sym_id
d39 10
a48 4
    struct match left, right;
  };

static struct sym_id  *id_list;
@


1.18
log
@CHange FSF sources over to GPLv3
@
text
@d22 1
a24 1
#include "gprof.h"
@


1.17
log
@	* corefile.c (core_create_function_syms, core_create_line_syms): Don't
	set discard_underscores.
	* gprof.c (discard_underscores): Delete.
	* gprof.h (discard_underscores): Delete.
	* sym_ids.c (match): Use bfd_get_symbol_leading_char to check for
	leading underscores.
	* utils.c (print_name_only): Call bfd_demangle rather than
	cplus_demangle.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2004 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
@


1.16
log
@Update the address of the FSF
@
text
@d30 1
d222 13
a234 6
  return (pattern->file ? pattern->file == sym->file : TRUE)
    && (pattern->line_num ? pattern->line_num == sym->line_num : TRUE)
    && (pattern->name
	? strcmp (pattern->name,
		  sym->name+(discard_underscores && sym->name[0] == '_')) == 0
	: TRUE);
@


1.15
log
@	* corefile.c (core_num_syms): Make static.
	(core_syms): Likewise.
	(min_insn_size): Likewise.
	* gprof.c (abfd): Remove unused variable.
	* hist.c (hist_dimension): Make static.
	(hist_dimension_abbrev): Likewise.
	* sym_ids.c (id_list): Likewise.
	(table_name): Likewise.
@
text
@d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.14
log
@update copyright dates
@
text
@d31 1
a31 1
struct sym_id
d62 1
a62 1
const char *table_name[] =
@


1.13
log
@	* alpha.c, basic_blocks.c, basic_blocks.h, bb_exit_func.c,
	call_graph.c, call_graph.h, cg_arcs.c, cg_arcs.h, cg_dfn.c,
	cg_dfn.h, cg_print.c, cg_print.h, corefile.c, corefile.h,
	gmon_io.c, gmon_io.h, gprof.c, gprof.h, hertz.h, hist.c, hist.h,
	i386.c, mips.c, search_list.c, search_list.h, source.c, source.h,
	sparc.c, sym_ids.c, sym_ids.h, symtab.c, symtab.h, tahoe.c,
	utils.c, utils.h, vax.c, gen-c-prog.awk: Convert K&R C to ANSI C.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
@


1.12
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d50 1
a50 1
  PARAMS ((char *, Sym *));
d52 1
a52 1
  PARAMS ((struct sym_id *));
d54 1
a54 1
  PARAMS ((Sym *, Sym *));
d56 1
a56 1
  PARAMS ((struct match *, Sym *, Sym_Table *, bfd_boolean));
d87 1
a87 3
sym_id_add (spec, which_table)
     const char *spec;
     Table_Id which_table;
d115 1
a115 3
parse_spec (spec, sym)
     char *spec;
     Sym *sym;
d170 1
a170 2
parse_id (id)
     struct sym_id *id;
d219 1
a219 3
match (pattern, sym)
     Sym *pattern;
     Sym *sym;
d231 1
a231 5
extend_match (m, sym, tab, second_pass)
     struct match *m;
     Sym *sym;
     Sym_Table *tab;
     bfd_boolean second_pass;
d365 1
a365 4
sym_id_arc_is_present (sym_tab, from, to)
     Sym_Table *sym_tab;
     Sym *from;
     Sym *to;
@


1.11
log
@	* alpha.c (alpha_find_call): Warning fixes.
	* mips.c (mips_find_call): Likewise.
	* sparc.c (sparc_find_call): Likewise.
	* basic_blocks.c: Warning fixes.  Eliminate DEFUN.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.cp: Likewise.
	* gprof.c: Likewise.
	* gprof.h: Likewise.
	* hist.c: Likewise.
	* search_list.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* symtab.h: Likewise.
	* utils.c: Likewise.
	* cg_print.c: Likewise.
	(struct function_map, symbol_map, symbol_map_count): Move
	declaration to..
	* corefile: ..here.
	* corefile.c: Warning fixes.  Eliminate DEFUN.
	(struct function_map): Remove declaration.
	* gmon_io.c: Warning fixes.  Eliminate DEFUN.
	(gmon_io_read_64): Make static.
	(gmon_io_write_64): Likewise.
	(gmon_read_raw_arc): Likewise.
	(gmon_write_raw_arc): Likewise.
	(gmon_io_write_8): Don't pass char, pass int param.
	* gmon_io.h (gmon_io_write_8): Likewise.

and a few copyright dates that should have been done previously.
@
text
@d36 1
a36 1
    boolean has_right;
d49 8
a56 4
static void parse_spec PARAMS ((char *, Sym *));
static void parse_id PARAMS ((struct sym_id *));
static boolean match PARAMS ((Sym *, Sym *));
static void extend_match PARAMS ((struct match *, Sym *, Sym_Table *, boolean));
d186 1
a186 1
      id->has_right = true;
d223 1
a223 1
static boolean
d228 2
a229 2
  return (pattern->file ? pattern->file == sym->file : true)
    && (pattern->line_num ? pattern->line_num == sym->line_num : true)
d233 1
a233 1
	: true);
d242 1
a242 1
     boolean second_pass;
d293 1
a293 1
	    extend_match (&id->left, sym, &syms[id->which_table], false);
d296 1
a296 1
	    extend_match (&id->right, sym, &right_ids, false);
d324 1
a324 1
	    extend_match (&id->left, sym, &syms[id->which_table], true);
d327 1
a327 1
	    extend_match (&id->right, sym, &right_ids, true);
d375 1
a375 1
boolean
d387 1
a387 1
	return true;
d390 1
a390 1
  return false;
@


1.10
log
@	* basic_blocks.c: Replace bool with boolean, TRUE with true and
	FALSE with false throughout.
	* basic_blocks.h: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hist.c: Likewise.
	* mips.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* tahoe.c: Likewise.
	* vax.c: Likewise.
	* gprof.h: Likewise.
	(TRUE): Don't define.
	(FALSE): Don't define.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d49 6
d83 3
a85 2
DEFUN (sym_id_add, (spec, which_table),
       const char *spec AND Table_Id which_table)
d113 3
a115 1
DEFUN (parse_spec, (spec, sym), char *spec AND Sym * sym)
d170 2
a171 1
DEFUN (parse_id, (id), struct sym_id *id)
d220 3
a222 1
DEFUN (match, (pattern, sym), Sym * pattern AND Sym * sym)
d234 5
a238 2
DEFUN (extend_match, (m, sym, tab, second_pass),
     struct match *m AND Sym * sym AND Sym_Table * tab AND boolean second_pass)
d273 1
a273 1
DEFUN_VOID (sym_id_parse)
d372 4
a375 2
DEFUN (sym_id_arc_is_present, (symtab, from, to),
       Sym_Table * symtab AND Sym * from AND Sym * to)
d379 1
a379 1
  for (sym = symtab->base; sym < symtab->limit; ++sym)
@


1.9
log
@	* alpha.c (alpha_Instruction): Don't use.
	(alpha_find_call): Avoid use of bitfields and casts between
	pointers and integers of different sizes.  Avoid endian problems
	when cross-compiling.
	* vax.c (vax_find_call): Likewise.
	(struct modebyte): Don't use.
	(vax_operandmode): Pass in an unsigned char *.
	(vax_operandlength): Likewise.
	(vax_reladdr): Rename to vax_offset and return relative offset
	rather than address.
	* i386.c (i386_find_call): Avoid casts between pointers and
	integers of different sizes.
	* sparc.c (sparc_find_call): Likewise.  Avoid endian problems.
	* tahoe.c (tahoe_find_call): Likewise.
	(tahoe_reladdr): Rename to tahoe_offset and return relative offset
	rather than address.

	* basic_blocks.h: Don't include headers here.
	* call_graph.h: Likewise.
	* cg_arcs.h: Likewise.
	* cg_print.h: Likewise.
	* corefile.h: Likewise.
	* gmon_io.h: Likewise.
	* gmon_out.h: Likewise.
	* hertz.h: Likewise.
	* hist.h: Likewise.
	* source.h: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* gprof.h: Don't include ansidecl.h, do include bfd.h.
	(bool): Don't typedef.
	* alpha.c: Adjust #include's for above header changes.
	* basic_blocks.c: Likewise.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hertz.c: Likewise.
	* hist.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise.
	* sparc.c: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* tahoe.c: Likewise.
	* utils.c: Likewise.
	* vax.c: Likewise.

	* po/POTFILES.in: Regenerate.
@
text
@d36 1
a36 1
    bool has_right;
d172 1
a172 1
      id->has_right = TRUE;
d209 1
a209 1
static bool
d212 2
a213 2
  return (pattern->file ? pattern->file == sym->file : TRUE)
    && (pattern->line_num ? pattern->line_num == sym->line_num : TRUE)
d217 1
a217 1
	: TRUE);
d223 1
a223 1
     struct match *m AND Sym * sym AND Sym_Table * tab AND bool second_pass)
d274 1
a274 1
	    extend_match (&id->left, sym, &syms[id->which_table], FALSE);
d277 1
a277 1
	    extend_match (&id->right, sym, &right_ids, FALSE);
d305 1
a305 1
	    extend_match (&id->left, sym, &syms[id->which_table], TRUE);
d308 1
a308 1
	    extend_match (&id->right, sym, &right_ids, TRUE);
d356 1
a356 1
bool
d366 1
a366 1
	return TRUE;
d369 1
a369 1
  return FALSE;
@


1.8
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d24 4
@


1.7
log
@David Mosberger's fixes for cross compiling gprof.
@
text
@a21 2
#include <ctype.h>

d23 1
d125 1
a125 1
	  if (isdigit ((unsigned char) spec[0]))
d141 1
a141 1
      else if (isdigit ((unsigned char) *spec))
@


1.6
log
@Fix typos in ChangeLog; fix dates in copyright notices
@
text
@d3 1
a3 1
   Copyright 2000 Free Software Foundation, Inc.
d34 1
a34 1
    
d94 5
a98 5
  
        (i)   a FILENAME if it contains a dot
        (ii)  a FUNCNAME if it starts with a non-digit character
        (iii) a LINENUM if it starts with a digit
  
d109 1
a109 1
  
d113 1
a113 1
      
d117 1
a117 1
	  
d121 1
a121 1
      
d123 1
a123 1
      
d138 1
a138 1
	  
d177 1
a177 1
      
d184 1
a184 1
      
d189 1
a189 1
	  
d197 1
a197 1
      
d234 1
a234 1
      
d249 1
a249 1
  
d288 1
a288 1
  
d330 1
a330 1
		  
d365 1
a365 1
  
@


1.5
log
@Add GPL copyright notices to uncopyrighted files.
Add copy of GPL.
@
text
@d3 1
a3 1
   Copyright (C) 2000  Free Software Foundation, Inc.
@


1.5.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
@


1.5.2.2
log
@Merge from mainline.
@
text
@d34 1
a34 1

d94 5
a98 5

	(i)   a FILENAME if it contains a dot
	(ii)  a FUNCNAME if it starts with a non-digit character
	(iii) a LINENUM if it starts with a digit

d109 1
a109 1

d113 1
a113 1

d117 1
a117 1

d121 1
a121 1

d123 1
a123 1

d138 1
a138 1

d177 1
a177 1

d184 1
a184 1

d189 1
a189 1

d197 1
a197 1

d234 1
a234 1

d249 1
a249 1

d288 1
a288 1

d330 1
a330 1

d365 1
a365 1

@


1.4
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d1 21
d31 1
a31 1
    char *spec;			/* parsing modifies this */
d34 1
d37 3
a39 3
	int prev_index;		/* index of prev match */
	Sym *prev_match;	/* previous match */
	Sym *first_match;	/* chain of all matches */
d60 5
a64 7
/*
 * This is the table in which we keep all the syms that match
 * the right half of an arc id.  It is NOT sorted according
 * to the addresses, because it is accessed only through
 * the left half's CHILDREN pointers (so it's crucial not
 * to reorder this table once pointers into it exist).
 */
d92 10
a101 11
/*
 * A spec has the syntax FILENAME:(FUNCNAME|LINENUM).  As a convenience
 * to the user, a spec without a colon is interpreted as:
 *
 *      (i)   a FILENAME if it contains a dot
 *      (ii)  a FUNCNAME if it starts with a non-digit character
 *      (iii) a LINENUM if it starts with a digit
 *
 * A FUNCNAME containing a dot can be specified by :FUNCNAME, a
 * FILENAME not containing a dot can be specified by FILENAME:.
 */
d109 1
d113 1
d117 1
d119 1
a119 3
	    {
	      sym->file = &non_existent_file;
	    }
d121 1
d123 1
d127 1
a127 3
	    {
	      sym->line_num = atoi (spec);
	    }
d129 1
a129 3
	    {
	      sym->name = spec;
	    }
d134 1
a134 1
      /* no colon: spec is a filename if it contains a dot: */
d138 1
d140 1
a140 3
	    {
	      sym->file = &non_existent_file;
	    }
d154 3
a156 4
/*
 * A symbol id has the syntax SPEC[/SPEC], where SPEC is is defined
 * by parse_spec().
 */
d177 1
d179 1
a179 3
	{
	  printf ("%s", id->left.sym.name);
	}
d181 1
a181 3
	{
	  printf ("%d", id->left.sym.line_num);
	}
d183 2
a184 3
	{
	  printf ("*");
	}
d189 1
d191 1
a191 3
	    {
	      printf ("%s", id->right.sym.name);
	    }
d193 1
a193 3
	    {
	      printf ("%d", id->right.sym.line_num);
	    }
d195 1
a195 3
	    {
	      printf ("*");
	    }
d197 1
d204 2
a205 3
/*
 * Return TRUE iff PATTERN matches SYM.
 */
d224 1
a224 1
      /* discontinuity: add new match to table: */
d230 1
a230 1
	  /* link match into match's chain: */
d234 1
d238 1
a238 1
  /* extend match to include this symbol: */
d240 2
a241 3
    {
      tab->base[m->prev_index].end_addr = sym->end_addr;
    }
d246 8
a253 9
/*
 * Go through sym_id list produced by option processing and fill
 * in the various symbol tables indicating what symbols should
 * be displayed or suppressed for the various kinds of outputs.
 *
 * This can potentially produce huge tables and in particulars
 * tons of arcs, but this happens only if the user makes silly
 * requests---you get what you ask for!
 */
d261 1
a261 3
  /*
   * Convert symbol ids into Syms, so we can deal with them more easily:
   */
d263 1
a263 5
    {
      parse_id (id);
    }

  /* first determine size of each table: */
d265 1
d271 2
a272 3
	    {
	      extend_match (&id->left, sym, &syms[id->which_table], FALSE);
	    }
d274 1
a274 3
	    {
	      extend_match (&id->right, sym, &right_ids, FALSE);
	    }
d278 1
a278 2
  /* create tables of appropriate size and reset lengths: */

d288 1
d296 1
a296 2
  /* make a second pass through symtab, creating syms as necessary: */

d302 2
a303 3
	    {
	      extend_match (&id->left, sym, &syms[id->which_table], TRUE);
	    }
d305 1
a305 3
	    {
	      extend_match (&id->right, sym, &right_ids, TRUE);
	    }
d309 1
a309 2
  /* go through ids creating arcs as needed: */

d330 1
d337 1
a337 2
  /* finally, we can sort the tables and we're done: */

d347 6
a352 8
/*
 * Symbol tables storing the FROM symbols of arcs do not necessarily
 * have distinct address ranges.  For example, somebody might request
 * -k /_mcount to suppress any arcs into _mcount, while at the same
 * time requesting -k a/b.  Fortunately, those symbol tables don't get
 * very big (the user has to type them!), so a linear search is probably
 * tolerable.
 */
d363 1
a363 3
	{
	  return TRUE;
	}
d365 1
@


1.3
log
@	* corefile.c (core_create_function_syms): Add ATTRIBUTED_UNUSED.
	* sym-ids.c (non_existent_file): Fully initialize structure.
@
text
@d204 4
a207 1
    && (pattern->name ? strcmp (pattern->name, sym->name) == 0 : TRUE);
@


1.3.2.1
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d204 1
a204 4
    && (pattern->name
	? strcmp (pattern->name,
		  sym->name+(discard_underscores && sym->name[0] == '_')) == 0
	: TRUE);
@


1.2
log
@	* Many files: Add casts in many print statements to cast bfd_vma
	values to unsigned long when calling printf.
	* Makefile.am ($(OBJECTS)): Add gmon.h.
	* Makefile.in: Rebuild.
@
text
@d49 1
a49 1
  0, "<non-existent-file>"
@


1.1
log
@Initial revision
@
text
@d326 3
a328 2
				left->name ? left->name : "*", left->addr,
				left->end_addr,
d330 3
a332 2
				right->name ? right->name : "*", right->addr,
				right->end_addr,
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

