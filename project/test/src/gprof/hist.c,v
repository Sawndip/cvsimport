head	1.27;
access;
symbols
	binutils-2_24-branch:1.27.0.4
	binutils-2_24-branchpoint:1.27
	binutils-2_21_1:1.24
	binutils-2_23_2:1.27
	binutils-2_23_1:1.27
	binutils-2_23:1.27
	binutils-2_23-branch:1.27.0.2
	binutils-2_23-branchpoint:1.27
	binutils-2_22_branch:1.24.0.6
	binutils-2_22:1.24
	binutils-2_22-branch:1.24.0.4
	binutils-2_22-branchpoint:1.24
	binutils-2_21:1.24
	binutils-2_21-branch:1.24.0.2
	binutils-2_21-branchpoint:1.24
	binutils-2_20_1:1.21.8.1
	binutils-2_20:1.21.8.1
	binutils-arc-20081103-branch:1.21.0.10
	binutils-arc-20081103-branchpoint:1.21
	binutils-2_20-branch:1.21.0.8
	binutils-2_20-branchpoint:1.21
	dje-cgen-play1-branch:1.21.0.6
	dje-cgen-play1-branchpoint:1.21
	arc-20081103-branch:1.21.0.4
	arc-20081103-branchpoint:1.21
	binutils-2_19_1:1.21
	binutils-2_19:1.21
	binutils-2_19-branch:1.21.0.2
	binutils-2_19-branchpoint:1.21
	binutils-2_18:1.20
	binutils-2_18-branch:1.20.0.2
	binutils-2_18-branchpoint:1.20
	binutils-csl-coldfire-4_1-32:1.15.2.1
	binutils-csl-sourcerygxx-4_1-32:1.15.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.15.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.13
	binutils-csl-coldfire-4_1-30:1.15.2.1
	binutils-csl-sourcerygxx-4_1-30:1.15.2.1
	binutils-csl-coldfire-4_1-28:1.15.2.1
	binutils-csl-sourcerygxx-4_1-29:1.15.2.1
	binutils-csl-sourcerygxx-4_1-28:1.15.2.1
	binutils-csl-arm-2006q3-27:1.15.2.1
	binutils-csl-sourcerygxx-4_1-27:1.15.2.1
	binutils-csl-arm-2006q3-26:1.15.2.1
	binutils-csl-sourcerygxx-4_1-26:1.15.2.1
	binutils-csl-sourcerygxx-4_1-25:1.15
	binutils-csl-sourcerygxx-4_1-24:1.15
	binutils-csl-sourcerygxx-4_1-23:1.15
	binutils-csl-sourcerygxx-4_1-21:1.15
	binutils-csl-arm-2006q3-21:1.15
	binutils-csl-sourcerygxx-4_1-22:1.15
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.15
	binutils-csl-sourcerygxx-4_1-20:1.15
	binutils-csl-arm-2006q3-19:1.15
	binutils-csl-sourcerygxx-4_1-19:1.15
	binutils-csl-sourcerygxx-4_1-18:1.15
	binutils-csl-renesas-4_1-9:1.15
	binutils-csl-sourcerygxx-3_4_4-25:1.13
	binutils-csl-renesas-4_1-8:1.15
	binutils-csl-renesas-4_1-7:1.15
	binutils-csl-renesas-4_1-6:1.15
	binutils-csl-sourcerygxx-4_1-17:1.15
	binutils-csl-sourcerygxx-4_1-14:1.15
	binutils-csl-sourcerygxx-4_1-15:1.15
	binutils-csl-sourcerygxx-4_1-13:1.15
	binutils-2_17:1.15
	binutils-csl-sourcerygxx-4_1-12:1.15
	binutils-csl-sourcerygxx-3_4_4-21:1.15
	binutils-csl-wrs-linux-3_4_4-24:1.13
	binutils-csl-wrs-linux-3_4_4-23:1.13
	binutils-csl-sourcerygxx-4_1-9:1.15
	binutils-csl-sourcerygxx-4_1-8:1.15
	binutils-csl-sourcerygxx-4_1-7:1.15
	binutils-csl-arm-2006q1-6:1.15
	binutils-csl-sourcerygxx-4_1-6:1.15
	binutils-csl-wrs-linux-3_4_4-22:1.13
	binutils-csl-coldfire-4_1-11:1.15
	binutils-csl-sourcerygxx-3_4_4-19:1.15
	binutils-csl-coldfire-4_1-10:1.15
	binutils-csl-sourcerygxx-4_1-5:1.15
	binutils-csl-sourcerygxx-4_1-4:1.15
	binutils-csl-wrs-linux-3_4_4-21:1.13
	binutils-csl-morpho-4_1-4:1.15
	binutils-csl-sourcerygxx-3_4_4-17:1.15
	binutils-csl-wrs-linux-3_4_4-20:1.13
	binutils-2_17-branch:1.15.0.4
	binutils-2_17-branchpoint:1.15
	binutils-csl-2_17-branch:1.15.0.2
	binutils-csl-2_17-branchpoint:1.15
	binutils-csl-gxxpro-3_4-branch:1.13.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.13
	binutils-2_16_1:1.13
	binutils-csl-arm-2005q1b:1.13
	binutils-2_16:1.13
	binutils-csl-arm-2005q1a:1.13
	binutils-csl-arm-2005q1-branch:1.13.0.4
	binutils-csl-arm-2005q1-branchpoint:1.13
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.11
	csl-arm-2004-q3:1.11
	gprof-pre-ansify-2004-05-26:1.10
	gprof-post-ansify-2004-05-26:1.11
	binutils-2_15:1.10
	binutils-2_15-branchpoint:1.10
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.10
	binutils-2_15-branch:1.10.0.8
	cagney_bfdfile-20040213-branch:1.10.0.6
	cagney_bfdfile-20040213-branchpoint:1.10
	cagney_bigcore-20040122-branch:1.10.0.4
	cagney_bigcore-20040122-branchpoint:1.10
	csl-arm-2003-q4:1.10
	binutils-2_14:1.10
	binutils-2_14-branch:1.10.0.2
	binutils-2_14-branchpoint:1.10
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	binutils-2_13_1:1.9
	binutils-2_13:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.2
	binutils-2_12_1:1.8
	binutils-2_12:1.8
	binutils-2_12-branch:1.8.0.2
	binutils-2_12-branchpoint:1.8
	cygnus_cvs_20020108_pre:1.5
	binutils-2_11_2:1.3.2.2
	binutils-2_11_1:1.3.2.2
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.27
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2011.10.26.09.51.57;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2011.10.25.16.46.46;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2011.10.25.08.38.49;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.11.13.42.13;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.25.09.57.49;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.11.15.27.34;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.19.16.30.29;	author schwab;	state Exp;
branches
	1.21.8.1;
next	1.20;

1.20
date	2007.07.12.07.16.41;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.06.10.40.34;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.14.23.16.45;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.10.08.47.50;	author vprus;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.10.07.57.31;	author vprus;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.09.06.55.25;	author nickc;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2005.04.23.17.13.31;	author bje;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.03.12.05.12;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2005.02.22.12.59.21;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.26.04.55.55;	author bje;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.19.18.29.08;	author fche;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.01.08.24.16;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2002.02.01.01.18.06;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.31.12.56.07;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.14.03.14.56;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.21.07.29;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.24.20.59.03;	author nickc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.06.30.22.38.21;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.21.8.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.15.2.1
date	2006.10.30.19.46.10;	author kazu;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.16.27;	author amodra;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.06.11.10.05.03;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches;
next	;


desc
@@


1.27
log
@	* hist.c (hist_assign_samples_1): Update comment.
@
text
@/* hist.c  -  Histogram related operations.

   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2009
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "gprof.h"
#include "libiberty.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "corefile.h"
#include "gmon_io.h"
#include "gmon_out.h"
#include "hist.h"
#include "sym_ids.h"
#include "utils.h"
#include "math.h"
#include "stdio.h"
#include "stdlib.h"

#define UNITS_TO_CODE (offset_to_code / sizeof(UNIT))

static void scale_and_align_entries (void);
static void print_header (int);
static void print_line (Sym *, double);
static int cmp_time (const PTR, const PTR);

/* Declarations of automatically generated functions to output blurbs.  */
extern void flat_blurb (FILE * fp);

static histogram *find_histogram (bfd_vma lowpc, bfd_vma highpc);
static histogram *find_histogram_for_pc (bfd_vma pc);

histogram * histograms;
unsigned num_histograms;
double hist_scale;
static char hist_dimension[16] = "seconds";
static char hist_dimension_abbrev = 's';

static double accum_time;	/* Accumulated time so far for print_line(). */
static double total_time;	/* Total time for all routines.  */

/* Table of SI prefixes for powers of 10 (used to automatically
   scale some of the values in the flat profile).  */
const struct
  {
    char prefix;
    double scale;
  }
SItab[] =
{
  { 'T', 1e-12 },				/* tera */
  { 'G', 1e-09 },				/* giga */
  { 'M', 1e-06 },				/* mega */
  { 'K', 1e-03 },				/* kilo */
  { ' ', 1e-00 },
  { 'm', 1e+03 },				/* milli */
  { 'u', 1e+06 },				/* micro */
  { 'n', 1e+09 },				/* nano */
  { 'p', 1e+12 },				/* pico */
  { 'f', 1e+15 },				/* femto */
  { 'a', 1e+18 }				/* ato */
};

/* Reads just the header part of histogram record into
   *RECORD from IFP.  FILENAME is the name of IFP and
   is provided for formatting error messages only.  

   If FIRST is non-zero, sets global variables HZ, HIST_DIMENSION,
   HIST_DIMENSION_ABBREV, HIST_SCALE.  If FIRST is zero, checks
   that the new histogram is compatible with already-set values
   of those variables and emits an error if that's not so.  */
static void
read_histogram_header (histogram *record, 
		       FILE *ifp, const char *filename,
		       int first)
{
  unsigned int profrate;
  char n_hist_dimension[15];
  char n_hist_dimension_abbrev;
  double n_hist_scale;

  if (gmon_io_read_vma (ifp, &record->lowpc)
      || gmon_io_read_vma (ifp, &record->highpc)
      || gmon_io_read_32 (ifp, &record->num_bins)
      || gmon_io_read_32 (ifp, &profrate)
      || gmon_io_read (ifp, n_hist_dimension, 15)
      || gmon_io_read (ifp, &n_hist_dimension_abbrev, 1))
    {
      fprintf (stderr, _("%s: %s: unexpected end of file\n"),
	       whoami, filename);

      done (1);
    }

  n_hist_scale = (double)((record->highpc - record->lowpc) / sizeof (UNIT)) 
    / record->num_bins;

  if (first)
    {
      /* We don't try to veryfy profrate is the same for all histogram
	 records.  If we have two histogram records for the same
	 address range and profiling samples is done as often
	 as possible as opposed on timer, then the actual profrate will
	 be slightly different.  Most of the time the difference does not
	 matter and insisting that profiling rate is exactly the same
	 will only create inconvenient.  */
      hz = profrate;
      memcpy (hist_dimension, n_hist_dimension, 15);
      hist_dimension_abbrev = n_hist_dimension_abbrev;
      hist_scale = n_hist_scale;      
    }
  else
    {
      if (strncmp (n_hist_dimension, hist_dimension, 15) != 0)
	{
	  fprintf (stderr, 
		   _("%s: dimension unit changed between histogram records\n"
		     "%s: from '%s'\n"
		     "%s: to '%s'\n"),
		   whoami, whoami, hist_dimension, whoami, n_hist_dimension);
	  done (1);
	}

      if (n_hist_dimension_abbrev != hist_dimension_abbrev)
	{
	  fprintf (stderr, 
		   _("%s: dimension abbreviation changed between histogram records\n"
		     "%s: from '%c'\n"
		     "%s: to '%c'\n"),
		   whoami, whoami, hist_dimension_abbrev, whoami, n_hist_dimension_abbrev);
	  done (1);	  
	}

      /* The only reason we require the same scale for histograms is that
	 there's code (notably printing code), that prints units,
	 and it would be very confusing to have one unit mean different
	 things for different functions.  */
      if (fabs (hist_scale - n_hist_scale) > 0.000001)
	{
	  fprintf (stderr, 
		   _("%s: different scales in histogram records"),
		   whoami);
	  done (1);      
	}
    }
}

/* Read the histogram from file IFP.  FILENAME is the name of IFP and
   is provided for formatting error messages only.  */

void
hist_read_rec (FILE * ifp, const char *filename)
{
  bfd_vma lowpc, highpc;
  histogram n_record;
  histogram *record, *existing_record;
  unsigned i;

  /* 1. Read the header and see if there's existing record for the
     same address range and that there are no overlapping records.  */
  read_histogram_header (&n_record, ifp, filename, num_histograms == 0);

  existing_record = find_histogram (n_record.lowpc, n_record.highpc);
  if (existing_record)
    {
      record = existing_record;
    }
  else
    {
      /* If this record overlaps, but does not completely match an existing
	 record, it's an error.  */
      lowpc = n_record.lowpc;
      highpc = n_record.highpc;
      hist_clip_symbol_address (&lowpc, &highpc);
      if (lowpc != highpc)
	{
	  fprintf (stderr, 
		   _("%s: overlapping histogram records\n"),
		   whoami);
	  done (1);      
	}

      /* This is new record.  Add it to global array and allocate space for
	 the samples.  */
      histograms = (struct histogram *)
          xrealloc (histograms, sizeof (histogram) * (num_histograms + 1));
      memcpy (histograms + num_histograms,
	      &n_record, sizeof (histogram));
      record = &histograms[num_histograms];      
      ++num_histograms;

      record->sample = (int *) xmalloc (record->num_bins 
					* sizeof (record->sample[0]));
      memset (record->sample, 0, record->num_bins * sizeof (record->sample[0]));
    }

  /* 2. We have either a new record (with zeroed histogram data), or an existing
     record with some data in the histogram already.  Read new data into the
     record, adding hit counts.  */

  DBG (SAMPLEDEBUG,
       printf ("[hist_read_rec] n_lowpc 0x%lx n_highpc 0x%lx ncnt %u\n",
	       (unsigned long) record->lowpc, (unsigned long) record->highpc, 
               record->num_bins));
           
  for (i = 0; i < record->num_bins; ++i)
    {
      UNIT count;
      if (fread (&count[0], sizeof (count), 1, ifp) != 1)
	{
	  fprintf (stderr,
		  _("%s: %s: unexpected EOF after reading %u of %u samples\n"),
		   whoami, filename, i, record->num_bins);
	  done (1);
	}
      record->sample[i] += bfd_get_16 (core_bfd, (bfd_byte *) & count[0]);
      DBG (SAMPLEDEBUG,
	   printf ("[hist_read_rec] 0x%lx: %u\n",
		   (unsigned long) (record->lowpc 
                                    + i * (record->highpc - record->lowpc) 
                                    / record->num_bins),
		   record->sample[i]));
    }
}


/* Write all execution histograms file OFP.  FILENAME is the name
   of OFP and is provided for formatting error-messages only.  */

void
hist_write_hist (FILE * ofp, const char *filename)
{
  UNIT count;
  unsigned int i, r;

  for (r = 0; r < num_histograms; ++r)
    {
      histogram *record = &histograms[r];

      /* Write header.  */
      
      if (gmon_io_write_8 (ofp, GMON_TAG_TIME_HIST)
	  || gmon_io_write_vma (ofp, record->lowpc)
	  || gmon_io_write_vma (ofp, record->highpc)
	  || gmon_io_write_32 (ofp, record->num_bins)
	  || gmon_io_write_32 (ofp, hz)
	  || gmon_io_write (ofp, hist_dimension, 15)
	  || gmon_io_write (ofp, &hist_dimension_abbrev, 1))
	{
	  perror (filename);
	  done (1);
	}
      
      for (i = 0; i < record->num_bins; ++i)
	{
	  bfd_put_16 (core_bfd, (bfd_vma) record->sample[i], (bfd_byte *) &count[0]);
	  
	  if (fwrite (&count[0], sizeof (count), 1, ofp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
	}
    }
}

/* Calculate scaled entry point addresses (to save time in
   hist_assign_samples), and, on architectures that have procedure
   entry masks at the start of a function, possibly push the scaled
   entry points over the procedure entry mask, if it turns out that
   the entry point is in one bin and the code for a routine is in the
   next bin.  */

static void
scale_and_align_entries ()
{
  Sym *sym;
  bfd_vma bin_of_entry;
  bfd_vma bin_of_code;

  for (sym = symtab.base; sym < symtab.limit; sym++)
    {
      histogram *r = find_histogram_for_pc (sym->addr);

      sym->hist.scaled_addr = sym->addr / sizeof (UNIT);

      if (r)
	{
	  bin_of_entry = (sym->hist.scaled_addr - r->lowpc) / hist_scale;
	  bin_of_code = ((sym->hist.scaled_addr + UNITS_TO_CODE - r->lowpc)
		     / hist_scale);
	  if (bin_of_entry < bin_of_code)
	    {
	      DBG (SAMPLEDEBUG,
		   printf ("[scale_and_align_entries] pushing 0x%lx to 0x%lx\n",
			   (unsigned long) sym->hist.scaled_addr,
			   (unsigned long) (sym->hist.scaled_addr
					    + UNITS_TO_CODE)));
	      sym->hist.scaled_addr += UNITS_TO_CODE;
	    }
	}
    }
}


/* Assign samples to the symbol to which they belong.

   Histogram bin I covers some address range [BIN_LOWPC,BIN_HIGH_PC)
   which may overlap one more symbol address ranges.  If a symbol
   overlaps with the bin's address range by O percent, then O percent
   of the bin's count is credited to that symbol.

   There are three cases as to where BIN_LOW_PC and BIN_HIGH_PC can be
   with respect to the symbol's address range [SYM_LOW_PC,
   SYM_HIGH_PC) as shown in the following diagram.  OVERLAP computes
   the distance (in UNITs) between the arrows, the fraction of the
   sample that is to be credited to the symbol which starts at
   SYM_LOW_PC.

	  sym_low_pc                                      sym_high_pc
	       |                                               |
	       v                                               v

	       +-----------------------------------------------+
	       |                                               |
	  |  ->|    |<-         ->|         |<-         ->|    |<-  |
	  |         |             |         |             |         |
	  +---------+             +---------+             +---------+

	  ^         ^             ^         ^             ^         ^
	  |         |             |         |             |         |
     bin_low_pc bin_high_pc  bin_low_pc bin_high_pc  bin_low_pc bin_high_pc

   For the VAX we assert that samples will never fall in the first two
   bytes of any routine, since that is the entry mask, thus we call
   scale_and_align_entries() to adjust the entry points if the entry
   mask falls in one bin but the code for the routine doesn't start
   until the next bin.  In conjunction with the alignment of routine
   addresses, this should allow us to have only one sample for every
   four bytes of text space and never have any overlap (the two end
   cases, above).  */

static void
hist_assign_samples_1 (histogram *r)
{
  bfd_vma bin_low_pc, bin_high_pc;
  bfd_vma sym_low_pc, sym_high_pc;
  bfd_vma overlap, addr;
  unsigned int bin_count;
  unsigned int i, j, k;
  double count_time, credit;

  bfd_vma lowpc = r->lowpc / sizeof (UNIT);

  /* Iterate over all sample bins.  */
  for (i = 0, k = 1; i < r->num_bins; ++i)
    {
      bin_count = r->sample[i];
      if (! bin_count)
	continue;

      bin_low_pc = lowpc + (bfd_vma) (hist_scale * i);
      bin_high_pc = lowpc + (bfd_vma) (hist_scale * (i + 1));
      count_time = bin_count;

      DBG (SAMPLEDEBUG,
	   printf (
      "[assign_samples] bin_low_pc=0x%lx, bin_high_pc=0x%lx, bin_count=%u\n",
		    (unsigned long) (sizeof (UNIT) * bin_low_pc),
		    (unsigned long) (sizeof (UNIT) * bin_high_pc),
		    bin_count));
      total_time += count_time;

      /* Credit all symbols that are covered by bin I.

         PR gprof/13325: Make sure that K does not get decremented
	 and J will never be less than 0.  */
      for (j = k - 1; j < symtab.len; k = ++j)
	{
	  sym_low_pc = symtab.base[j].hist.scaled_addr;
	  sym_high_pc = symtab.base[j + 1].hist.scaled_addr;

	  /* If high end of bin is below entry address,
	     go for next bin.  */
	  if (bin_high_pc < sym_low_pc)
	    break;

	  /* If low end of bin is above high end of symbol,
	     go for next symbol.  */
	  if (bin_low_pc >= sym_high_pc)
	    continue;

	  overlap =
	    MIN (bin_high_pc, sym_high_pc) - MAX (bin_low_pc, sym_low_pc);
	  if (overlap > 0)
	    {
	      DBG (SAMPLEDEBUG,
		   printf (
	       "[assign_samples] [0x%lx,0x%lx) %s gets %f ticks %ld overlap\n",
			   (unsigned long) symtab.base[j].addr,
			   (unsigned long) (sizeof (UNIT) * sym_high_pc),
			   symtab.base[j].name, overlap * count_time / hist_scale,
			   (long) overlap));

	      addr = symtab.base[j].addr;
	      credit = overlap * count_time / hist_scale;

	      /* Credit symbol if it appears in INCL_FLAT or that
		 table is empty and it does not appear it in
		 EXCL_FLAT.  */
	      if (sym_lookup (&syms[INCL_FLAT], addr)
		  || (syms[INCL_FLAT].len == 0
		      && !sym_lookup (&syms[EXCL_FLAT], addr)))
		{
		  symtab.base[j].hist.time += credit;
		}
	      else
		{
		  total_time -= credit;
		}
	    }
	}
    }

  DBG (SAMPLEDEBUG, printf ("[assign_samples] total_time %f\n",
			    total_time));
}

/* Calls 'hist_assign_sampes_1' for all histogram records read so far. */
void
hist_assign_samples ()
{
  unsigned i;

  scale_and_align_entries ();

  for (i = 0; i < num_histograms; ++i)
    hist_assign_samples_1 (&histograms[i]);
  
}

/* Print header for flag histogram profile.  */

static void
print_header (int prefix)
{
  char unit[64];

  sprintf (unit, _("%c%c/call"), prefix, hist_dimension_abbrev);

  if (bsd_style_output)
    {
      printf (_("\ngranularity: each sample hit covers %ld byte(s)"),
	      (long) hist_scale * (long) sizeof (UNIT));
      if (total_time > 0.0)
	{
	  printf (_(" for %.2f%% of %.2f %s\n\n"),
		  100.0 / total_time, total_time / hz, hist_dimension);
	}
    }
  else
    {
      printf (_("\nEach sample counts as %g %s.\n"), 1.0 / hz, hist_dimension);
    }

  if (total_time <= 0.0)
    {
      printf (_(" no time accumulated\n\n"));

      /* This doesn't hurt since all the numerators will be zero.  */
      total_time = 1.0;
    }

  printf ("%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
	  "%  ", _("cumulative"), _("self  "), "", _("self  "), _("total "),
	  "");
  printf ("%5.5s %9.9s  %8.8s %8.8s %8.8s %8.8s  %-8.8s\n",
	  _("time"), hist_dimension, hist_dimension, _("calls"), unit, unit,
	  _("name"));
}


static void
print_line (Sym *sym, double scale)
{
  if (ignore_zeros && sym->ncalls == 0 && sym->hist.time == 0)
    return;

  accum_time += sym->hist.time;

  if (bsd_style_output)
    printf ("%5.1f %10.2f %8.2f",
	    total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	    accum_time / hz, sym->hist.time / hz);
  else
    printf ("%6.2f %9.2f %8.2f",
	    total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	    accum_time / hz, sym->hist.time / hz);

  if (sym->ncalls != 0)
    printf (" %8lu %8.2f %8.2f  ",
	    sym->ncalls, scale * sym->hist.time / hz / sym->ncalls,
	    scale * (sym->hist.time + sym->cg.child_time) / hz / sym->ncalls);
  else
    printf (" %8.8s %8.8s %8.8s  ", "", "", "");

  if (bsd_style_output)
    print_name (sym);
  else
    print_name_only (sym);

  printf ("\n");
}


/* Compare LP and RP.  The primary comparison key is execution time,
   the secondary is number of invocation, and the tertiary is the
   lexicographic order of the function names.  */

static int
cmp_time (const PTR lp, const PTR rp)
{
  const Sym *left = *(const Sym **) lp;
  const Sym *right = *(const Sym **) rp;
  double time_diff;

  time_diff = right->hist.time - left->hist.time;

  if (time_diff > 0.0)
    return 1;

  if (time_diff < 0.0)
    return -1;

  if (right->ncalls > left->ncalls)
    return 1;

  if (right->ncalls < left->ncalls)
    return -1;

  return strcmp (left->name, right->name);
}


/* Print the flat histogram profile.  */

void
hist_print ()
{
  Sym **time_sorted_syms, *top_dog, *sym;
  unsigned int sym_index;
  unsigned log_scale;
  double top_time;
  bfd_vma addr;

  if (first_output)
    first_output = FALSE;
  else
    printf ("\f\n");

  accum_time = 0.0;

  if (bsd_style_output)
    {
      if (print_descriptions)
	{
	  printf (_("\n\n\nflat profile:\n"));
	  flat_blurb (stdout);
	}
    }
  else
    {
      printf (_("Flat profile:\n"));
    }

  /* Sort the symbol table by time (call-count and name as secondary
     and tertiary keys).  */
  time_sorted_syms = (Sym **) xmalloc (symtab.len * sizeof (Sym *));

  for (sym_index = 0; sym_index < symtab.len; ++sym_index)
    time_sorted_syms[sym_index] = &symtab.base[sym_index];

  qsort (time_sorted_syms, symtab.len, sizeof (Sym *), cmp_time);

  if (bsd_style_output)
    {
      log_scale = 5;		/* Milli-seconds is BSD-default.  */
    }
  else
    {
      /* Search for symbol with highest per-call
	 execution time and scale accordingly.  */
      log_scale = 0;
      top_dog = 0;
      top_time = 0.0;

      for (sym_index = 0; sym_index < symtab.len; ++sym_index)
	{
	  sym = time_sorted_syms[sym_index];

	  if (sym->ncalls != 0)
	    {
	      double call_time;

	      call_time = (sym->hist.time + sym->cg.child_time) / sym->ncalls;

	      if (call_time > top_time)
		{
		  top_dog = sym;
		  top_time = call_time;
		}
	    }
	}

      if (top_dog && top_dog->ncalls != 0 && top_time > 0.0)
	{
	  top_time /= hz;

	  for (log_scale = 0; log_scale < ARRAY_SIZE (SItab); log_scale ++)
	    {
	      double scaled_value = SItab[log_scale].scale * top_time;

	      if (scaled_value >= 1.0 && scaled_value < 1000.0) 
		break;
	    }
	}
    }

  /* For now, the dimension is always seconds.  In the future, we
     may also want to support other (pseudo-)dimensions (such as
     I-cache misses etc.).  */
  print_header (SItab[log_scale].prefix);

  for (sym_index = 0; sym_index < symtab.len; ++sym_index)
    {
      addr = time_sorted_syms[sym_index]->addr;

      /* Print symbol if its in INCL_FLAT table or that table
	is empty and the symbol is not in EXCL_FLAT.  */
      if (sym_lookup (&syms[INCL_FLAT], addr)
	  || (syms[INCL_FLAT].len == 0
	      && !sym_lookup (&syms[EXCL_FLAT], addr)))
	print_line (time_sorted_syms[sym_index], SItab[log_scale].scale);
    }

  free (time_sorted_syms);

  if (print_descriptions && !bsd_style_output)
    flat_blurb (stdout);
}

int
hist_check_address (unsigned address)
{
  unsigned i;

  for (i = 0; i < num_histograms; ++i)
    if (histograms[i].lowpc <= address && address < histograms[i].highpc)
      return 1;

  return 0;        
}

#if ! defined(min)
#define min(a,b) (((a)<(b)) ? (a) : (b))
#endif
#if ! defined(max)
#define max(a,b) (((a)>(b)) ? (a) : (b))
#endif

void
hist_clip_symbol_address (bfd_vma *p_lowpc, bfd_vma *p_highpc)
{
  unsigned i;
  int found = 0;

  if (num_histograms == 0)
    {
      *p_highpc = *p_lowpc;
      return;
    }

  for (i = 0; i < num_histograms; ++i)
    {
      bfd_vma common_low, common_high;
      common_low = max (histograms[i].lowpc, *p_lowpc);
      common_high = min (histograms[i].highpc, *p_highpc);

      if (common_low < common_high)
	{
	  if (found)
	    {
	      fprintf (stderr,
		       _("%s: found a symbol that covers "
			 "several histogram records"),
			 whoami);
	      done (1);
	    }

	  found = 1;
	  *p_lowpc = common_low;
	  *p_highpc = common_high;
	}
    }

  if (!found)
    *p_highpc = *p_lowpc;
}

/* Find and return exising histogram record having the same lowpc and
   highpc as passed via the parameters.  Return NULL if nothing is found.
   The return value is valid until any new histogram is read.  */
static histogram *
find_histogram (bfd_vma lowpc, bfd_vma highpc)
{
  unsigned i;
  for (i = 0; i < num_histograms; ++i)
    {
      if (histograms[i].lowpc == lowpc && histograms[i].highpc == highpc)
	return &histograms[i];
    }
  return 0;
}

/* Given a PC, return histogram record which address range include this PC.
   Return NULL if there's no such record.  */
static histogram *
find_histogram_for_pc (bfd_vma pc)
{
  unsigned i;
  for (i = 0; i < num_histograms; ++i)
    {
      if (histograms[i].lowpc <= pc && pc < histograms[i].highpc)
	return &histograms[i];
    }
  return 0;  
}
@


1.26
log
@Oops - apply correct patch for previous delta.
@
text
@d392 4
a395 2
      /* Credit all symbols that are covered by bin I.  */
      /* PR gprof/13325: Make sure that J does not go below I.  */
@


1.25
log
@	PR gprof/13325
	* hist.c (hist_assign_samples_1): Make sure that inner loop
	iterator remains valid.
@
text
@d368 1
a368 1
  unsigned int i, j;
d374 1
a374 1
  for (i = 0, j = 1; i < r->num_bins; ++i)
d393 2
a394 1
      for (j = j - 1; j < symtab.len; ++j)
d402 1
a402 6
	    {
	      /* PR gprof/13325: Make sure that j does not go below 1.  */
	      if (j < 1)
		j = 1;
	      break;
	    }
@


1.24
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d401 6
a406 1
	    break;
@


1.23
log
@        PR 10656
        * readelf.c: Remove duplicate declaration of variable do_wide.
        * dwarf.h: Add export of do_wide.

        * hist.h: Move declaration of histograms and num_histograms
        variables from here to...
        * hist.c: ...here.
@
text
@d369 1
a369 1
  double time, credit;
d382 1
a382 1
      time = bin_count;
d390 1
a390 1
      total_time += time;
d417 1
a417 1
			   symtab.base[j].name, overlap * time / hist_scale,
d421 1
a421 1
	      credit = overlap * time / hist_scale;
d566 1
a566 1
  unsigned int index;
d568 1
a568 1
  double top_time, time;
d595 2
a596 2
  for (index = 0; index < symtab.len; ++index)
    time_sorted_syms[index] = &symtab.base[index];
d612 1
a612 1
      for (index = 0; index < symtab.len; ++index)
d614 1
a614 1
	  sym = time_sorted_syms[index];
d618 1
a618 1
	      time = (sym->hist.time + sym->cg.child_time) / sym->ncalls;
d620 3
a622 1
	      if (time > top_time)
d625 1
a625 1
		  top_time = time;
d649 1
a649 1
  for (index = 0; index < symtab.len; ++index)
d651 1
a651 1
      addr = time_sorted_syms[index]->addr;
d658 1
a658 1
	print_line (time_sorted_syms[index], SItab[log_scale].scale);
@


1.22
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2007
d51 2
@


1.21
log
@* basic_blocks.c: Always include "gprof.h" first.
* cg_arcs.c: Likewise.
* cg_dfn.c: Likewise.
* cg_print.c: Likewise.
* corefile.c: Likewise.
* gprof.c: Likewise.
* hist.c: Likewise.
* search_list.c: Likewise.
* sym_ids.c: Likewise.
* utils.c: Likewise.
@
text
@d201 2
a202 2
      histograms = xrealloc (histograms,
			     sizeof (histogram) * (num_histograms + 1));
@


1.21.8.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d201 2
a202 2
      histograms = (struct histogram *)
          xrealloc (histograms, sizeof (histogram) * (num_histograms + 1));
@


1.20
log
@Add support for building on a 64-bit Windows host.
@
text
@d23 1
a24 1
#include "gprof.h"
@


1.19
log
@CHange FSF sources over to GPLv3
@
text
@d467 1
a467 1
	      (long) hist_scale * sizeof (UNIT));
@


1.18
log
@2007-05-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* hist.c (scale_and_align_entries): Avoid C99 feature.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005
d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.17
log
@Fix typo in the previous commit
@
text
@d299 2
a302 2
      histogram *r = find_histogram_for_pc (sym->addr);

@


1.16
log
@	* hist.h (struct histogram)
	(histograms, num_histograms): New.
	* hist.c (find_histogram, find_histogram_for_pc)
	(read_histogram_header): New.
	(s_lowpc, s_highpc, lowpc, highpc, hist_num_bins)
	(hist_sample): Remove.
	(hist_read_rec): Use the above, and handle multiple
	histogram records with disjoint address ranges.
	(hist_write_hist): Support several histogram records.
	(scale_and_align_entries): Adjust for multiple histograms.
	(hist_assign_samples_1): New.
	(hist_assign_samples): Use the above.
	(hist_clip_symbol_address): New.
	* hist.h (hist_check_address)
	(hist_clip_symbol_address): Declare.
	* gmon_io.c (gmon_out_read, gmon_out_write): Adjust handling
	of legacy format for multiple histogram changes.
	* corefile.c (find_call): Check for core_text_space and
	clip symbol address range here.
	* vax.c	(vax_find_call): Don't check for
	core_text_space, or clip the symbol's address range here.
	Use hist_check_address to check call's target address.
	* sparc.c: Likewise.
	* tahoe.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise. Also use core_text_sect->vma as the base
	address for code accesses, just like other machine-specific
	routines do.
	* gprof.texi: Adjust for the new logic.
@
text
@d706 1
a706 1
			 "several histogram records")
@


1.15
log
@Update the address of the FSF
@
text
@d34 3
d48 3
a50 5
bfd_vma s_lowpc;		/* Lowest address in .text.  */
bfd_vma s_highpc = 0;		/* Highest address in .text.  */
bfd_vma lowpc, highpc;		/* Same, but expressed in UNITs.  */
unsigned int hist_num_bins = 0;	/* Number of histogram samples.  */
int *hist_sample = 0;		/* Histogram samples (shorts in the file!).  */
d80 12
a91 6

/* Read the histogram from file IFP.  FILENAME is the name of IFP and
   is provided for formatting error messages only.  */

void
hist_read_rec (FILE * ifp, const char *filename)
d93 8
a100 7
  bfd_vma n_lowpc, n_highpc;
  unsigned int i, ncnt, profrate;
  UNIT count;

  if (gmon_io_read_vma (ifp, &n_lowpc)
      || gmon_io_read_vma (ifp, &n_highpc)
      || gmon_io_read_32 (ifp, &ncnt)
d102 2
a103 2
      || gmon_io_read (ifp, hist_dimension, 15)
      || gmon_io_read (ifp, &hist_dimension_abbrev, 1))
d111 4
a114 1
  if (!s_highpc)
d116 7
a122 6
      /* This is the first histogram record.  */
      s_lowpc = n_lowpc;
      s_highpc = n_highpc;
      lowpc = (bfd_vma) n_lowpc / sizeof (UNIT);
      highpc = (bfd_vma) n_highpc / sizeof (UNIT);
      hist_num_bins = ncnt;
d124 3
d128 11
d140 9
a148 8
  DBG (SAMPLEDEBUG,
       printf ("[hist_read_rec] n_lowpc 0x%lx n_highpc 0x%lx ncnt %u\n",
	       (unsigned long) n_lowpc, (unsigned long) n_highpc, ncnt);
       printf ("[hist_read_rec] s_lowpc 0x%lx s_highpc 0x%lx nsamples %u\n",
	       (unsigned long) s_lowpc, (unsigned long) s_highpc,
	       hist_num_bins);
       printf ("[hist_read_rec]   lowpc 0x%lx   highpc 0x%lx\n",
	       (unsigned long) lowpc, (unsigned long) highpc));
d150 11
a160 6
  if (n_lowpc != s_lowpc || n_highpc != s_highpc
      || ncnt != hist_num_bins || hz != (int) profrate)
    {
      fprintf (stderr, _("%s: `%s' is incompatible with first gmon file\n"),
	       whoami, filename);
      done (1);
d162 1
d164 17
a180 1
  if (!hist_sample)
d182 1
a182 2
      hist_sample = (int *) xmalloc (hist_num_bins * sizeof (hist_sample[0]));
      memset (hist_sample, 0, hist_num_bins * sizeof (hist_sample[0]));
d184 32
d217 6
a222 1
  for (i = 0; i < hist_num_bins; ++i)
d224 1
d229 1
a229 1
		   whoami, filename, i, hist_num_bins);
d232 1
a232 1
      hist_sample[i] += bfd_get_16 (core_bfd, (bfd_byte *) & count[0]);
d235 4
a238 2
		   (unsigned long) (n_lowpc + i * (n_highpc - n_lowpc) / ncnt),
		   hist_sample[i]));
d243 1
a243 1
/* Write execution histogram to file OFP.  FILENAME is the name
d250 1
a250 15
  unsigned int i;

  /* Write header.  */

  if (gmon_io_write_8 (ofp, GMON_TAG_TIME_HIST)
      || gmon_io_write_vma (ofp, s_lowpc)
      || gmon_io_write_vma (ofp, s_highpc)
      || gmon_io_write_32 (ofp, hist_num_bins)
      || gmon_io_write_32 (ofp, hz)
      || gmon_io_write (ofp, hist_dimension, 15)
      || gmon_io_write (ofp, &hist_dimension_abbrev, 1))
    {
      perror (filename);
      done (1);
    }
d252 1
a252 1
  for (i = 0; i < hist_num_bins; ++i)
d254 1
a254 1
      bfd_put_16 (core_bfd, (bfd_vma) hist_sample[i], (bfd_byte *) &count[0]);
d256 9
a264 1
      if (fwrite (&count[0], sizeof (count), 1, ofp) != 1)
d269 11
a282 1

d300 7
a306 2
      bin_of_entry = (sym->hist.scaled_addr - lowpc) / hist_scale;
      bin_of_code = ((sym->hist.scaled_addr + UNITS_TO_CODE - lowpc)
d308 9
a316 8
      if (bin_of_entry < bin_of_code)
	{
	  DBG (SAMPLEDEBUG,
	       printf ("[scale_and_align_entries] pushing 0x%lx to 0x%lx\n",
		       (unsigned long) sym->hist.scaled_addr,
		       (unsigned long) (sym->hist.scaled_addr
					+ UNITS_TO_CODE)));
	  sym->hist.scaled_addr += UNITS_TO_CODE;
d359 2
a360 2
void
hist_assign_samples ()
d369 1
a369 4
  /* Read samples and assign to symbols.  */
  hist_scale = highpc - lowpc;
  hist_scale /= hist_num_bins;
  scale_and_align_entries ();
d372 1
a372 1
  for (i = 0, j = 1; i < hist_num_bins; ++i)
d374 1
a374 1
      bin_count = hist_sample[i];
d442 12
d662 87
@


1.15.2.1
log
@	Merge fido bits:
	2006-10-25  Kazu Hirata  <kazu@@codesourcery.com>

	gprof/
	* hist.c, hist.h: Fix formatting.

	gprof/
	* Makefile.in (corefile.o): Depend on hist.h.
	* corefile.c: Include hist.h.

	2006-10-06  Vladimir Prus  <vladimir@@codesourcery.com>

	* hist.h (struct histogram)
	(histograms, num_histograms): New.
	* hist.c (find_histogram, find_histogram_for_pc)
	(read_histogram_header): New.
	(s_lowpc, s_highpc, lowpc, highpc, hist_num_bins)
	(hist_sample): Remove.
	(hist_read_rec): Use the above, and handle multiple
	histogram records with disjoint address ranges.
	(hist_write_hist): Support several histogram records.
	(scale_and_align_entries): Adjust for multiple histograms.
	(hist_assign_samples_1): New.
	(hist_assign_samples): Use the above.
	(hist_clip_symbol_address): New.
	* hist.h (hist_check_address)
	(hist_clip_symbol_address): Declare.
	* gmon_io.c (gmon_out_read, gmon_out_write): Adjust handling
	of legacy format for multiple histogram changes.
	* corefile.c (find_call): Check for core_text_space and
	clip symbol address range here.
	* vax.c	(vax_find_call): Don't check for
	core_text_space, or clip the symbol's address range here.
	Use hist_check_address to check call's target address.
	* sparc.c: Likewise.
	* tahoe.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise. Also use core_text_sect->vma as the base
	address for code accesses, just like other machine-specific
	routines do.

	2006-08-03  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add -mfido as an alias for
	-mfido_a.

	2006-06-23  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (cpu_of_arch): Replace fido with
	fido_a.
	(archs): Likewise.
	(m68k_ip): Likewise.
	(select_control_regs): Likewise.
	(md_show_usage): Replace -mfido with -mfidoa.
	* include/opcode/m68k.h (fido): Rename to fido_a.
	* opcodes/m68k-opc.c (m68k_opcodes): Replace fido with fido_a.

	2006-06-22  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Replace fido with fido.
	* bfd/config.bfd: Likewise
	* gas/configure.tgt: Likewise.
	* gas/config/m68k-parse.h: Likewise.
	* gas/config/tc-m68k.c: Likewise.
	* gas/testsuite/gas/m68k/all.exp: Likewise.
	* gas/testsuite/gas/m68k/fido.d: Rename to fido.d.
	* gas/testsuite/gas/m68k/fido.s: Rename to fido.s.
	* include/opcode/m68k.h: Replace fido with fido.
	* ld/configure.tgt: Likewise.
	* opcodes/m68k-dis.c: Likewise.
	* opcodes/m68k-opc.c: Likewise.

	2005-08-01  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/m68k-parse.h (m68k_register): Add CAC and MBB.
	* gas/config/tc-m68k.c (fido_control_regs): New.
	(cpu_of_arch): Add fido.
	(archs): Add an entry for fido.
	(m68k_ip): Add warnings for uses of tbl[su]{n,}[bwl] on
	fido.  Recognize CAC and MBB.
	(init_tabl): Add CAC and MBB.
	(select_control_regs): Choose fido as the current chip
	when the current architecture is fido or when -mfido
	is given explicitly.
	* gas/testsuite/gas/m68k/all.exp: Disable operands, cas, and
	bitfield on fido-*-*.  Run fido on fido-*-*.
	* gas/testsuite/gas/m68k/fido.d: New.
	* gas/testsuite/gas/m68k/fido.s: Likewise.
	* include/opcode/m68k.h: Document new control registers CAC
	and MBB.
	* opcodes/m68k-dis.c (print_insn_arg): Add cac and mbb.
	* opcodes/m68k-opc.c (m68k_opcodes): Add sleep and trapx.

	2005-07-22  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add fido as an OR of
	cpu32 and fido.
	(md_show_usage): Add -mfido.
	* include/opcode/m68k.h (fido): New.

	2005-07-11  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Recognize fido and fido-*.
	* bfd/config.bfd: Likewise.
	* gas/configure.tgt: Likewise.
	* ld/configure.tgt: Likewise.
@
text
@a33 3
#include "math.h"
#include "stdio.h"
#include "stdlib.h"
d45 5
a49 3
static histogram *find_histogram (bfd_vma lowpc, bfd_vma highpc);
static histogram *find_histogram_for_pc (bfd_vma pc);

d79 6
a84 12
/* Reads just the header part of histogram record into
   *RECORD from IFP.  FILENAME is the name of IFP and
   is provided for formatting error messages only.  

   If FIRST is non-zero, sets global variables HZ, HIST_DIMENSION,
   HIST_DIMENSION_ABBREV, HIST_SCALE.  If FIRST is zero, checks
   that the new histogram is compatible with already-set values
   of those variables and emits an error if that's not so.  */
static void
read_histogram_header (histogram *record, 
		       FILE *ifp, const char *filename,
		       int first)
d86 7
a92 8
  unsigned int profrate;
  char n_hist_dimension[15];
  char n_hist_dimension_abbrev;
  double n_hist_scale;

  if (gmon_io_read_vma (ifp, &record->lowpc)
      || gmon_io_read_vma (ifp, &record->highpc)
      || gmon_io_read_32 (ifp, &record->num_bins)
d94 2
a95 2
      || gmon_io_read (ifp, n_hist_dimension, 15)
      || gmon_io_read (ifp, &n_hist_dimension_abbrev, 1))
d103 1
a103 4
  n_hist_scale = (double)((record->highpc - record->lowpc) / sizeof (UNIT)) 
    / record->num_bins;

  if (first)
d105 6
a110 4
      /* We could try to verify it's the same for all records,
	 but it isn't practical, since when profiling is done
	 no by a timer but with a loop running in a stub, polling PC
	 from the target as fast as possible, the rate is not fixed.  */
a111 3
      memcpy (hist_dimension, n_hist_dimension, 15);
      hist_dimension_abbrev = n_hist_dimension_abbrev;
      hist_scale = n_hist_scale;      
a112 11
  else
    {
      if (strncmp (n_hist_dimension, hist_dimension, 15) != 0)
	{
	  fprintf (stderr, 
		   _("%s: dimension unit changed between histogram records\n"
		     "%s: from '%s'\n"
		     "%s: to '%s'\n"),
		   whoami, whoami, hist_dimension, whoami, n_hist_dimension);
	  done (1);
	}
d114 8
a121 9
      if (n_hist_dimension_abbrev != hist_dimension_abbrev)
	{
	  fprintf (stderr, 
		   _("%s: dimension abbreviation changed between histogram records\n"
		     "%s: from '%c'\n"
		     "%s: to '%c'\n"),
		   whoami, whoami, hist_dimension_abbrev, whoami, n_hist_dimension_abbrev);
	  done (1);	  
	}
d123 6
a128 11
      /* The only reason we require the same scale for histograms is that
	 there's code (notably printing code), that prints units,
	 and it would be very confusing to have one unit mean different
	 things for different functions.  */
      if (fabs (hist_scale - n_hist_scale) > 0.000001)
	{
	  fprintf (stderr, 
		   _("%s: different scales in histogram records"),
		   whoami);
	  done (1);      
	}
a129 1
}
d131 1
a131 17
/* Read the histogram from file IFP.  FILENAME is the name of IFP and
   is provided for formatting error messages only.  */

void
hist_read_rec (FILE * ifp, const char *filename)
{
  bfd_vma lowpc, highpc;
  histogram n_record;
  histogram *record, *existing_record;
  unsigned i;

  /* 1. Read the header and see if there's existing record for the
     same address range and that there are no overlapping records.  */
  read_histogram_header (&n_record, ifp, filename, num_histograms == 0);

  existing_record = find_histogram (n_record.lowpc, n_record.highpc);
  if (existing_record)
d133 2
a134 1
      record = existing_record;
a135 33
  else
    {
      /* If this record overlaps, but does not completely match an existing
	 record, it's an error.  */
      lowpc = n_record.lowpc;
      highpc = n_record.highpc;
      hist_clip_symbol_address (&lowpc, &highpc);
      if (lowpc != highpc)
	{
	  fprintf (stderr, 
		   _("%s: overlapping histogram records\n"),
		   whoami);
	  done (1);      
	}

      /* This is new record.  Add it to global array and allocate space for
	 the samples.  */
      histograms = (histogram *)realloc (histograms,
					 sizeof (histogram)
					 * (num_histograms + 1));
      memcpy (histograms + num_histograms,
	      &n_record, sizeof (histogram));
      record = &histograms[num_histograms];      
      ++num_histograms;

      record->sample = (int *) xmalloc (record->num_bins 
					* sizeof (record->sample[0]));
      memset (record->sample, 0, record->num_bins * sizeof (record->sample[0]));
    }

  /* 2. We have either a new record (with zeroed histogram data), or an existing
     record with some data in the histogram already.  Read new data into the
     record, adding hit counts.  */
d137 1
a137 6
  DBG (SAMPLEDEBUG,
       printf ("[hist_read_rec] n_lowpc 0x%lx n_highpc 0x%lx ncnt %u\n",
	       (unsigned long) record->lowpc, (unsigned long) record->highpc, 
               record->num_bins));
           
  for (i = 0; i < record->num_bins; ++i)
a138 1
      UNIT count;
d143 1
a143 1
		   whoami, filename, i, record->num_bins);
d146 1
a146 1
      record->sample[i] += bfd_get_16 (core_bfd, (bfd_byte *) & count[0]);
d149 2
a150 4
		   (unsigned long) (record->lowpc 
                                    + i * (record->highpc - record->lowpc) 
                                    / record->num_bins),
		   record->sample[i]));
d155 1
a155 1
/* Write all execution histograms file OFP.  FILENAME is the name
d162 15
a176 1
  unsigned int i, r;
d178 1
a178 1
  for (r = 0; r < num_histograms; ++r)
d180 1
a180 1
      histogram *record = &histograms[r];
d182 1
a182 9
      /* Write header.  */
      
      if (gmon_io_write_8 (ofp, GMON_TAG_TIME_HIST)
	  || gmon_io_write_vma (ofp, record->lowpc)
	  || gmon_io_write_vma (ofp, record->highpc)
	  || gmon_io_write_32 (ofp, record->num_bins)
	  || gmon_io_write_32 (ofp, hz)
	  || gmon_io_write (ofp, hist_dimension, 15)
	  || gmon_io_write (ofp, &hist_dimension_abbrev, 1))
a186 11
      
      for (i = 0; i < record->num_bins; ++i)
	{
	  bfd_put_16 (core_bfd, (bfd_vma) record->sample[i], (bfd_byte *) &count[0]);
	  
	  if (fwrite (&count[0], sizeof (count), 1, ofp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
	}
d190 1
d208 4
a211 4

      histogram *r = find_histogram_for_pc (sym->addr);

      if (r)
d213 6
a218 12
	  bin_of_entry = (sym->hist.scaled_addr - r->lowpc) / hist_scale;
	  bin_of_code = ((sym->hist.scaled_addr + UNITS_TO_CODE - r->lowpc)
		     / hist_scale);
	  if (bin_of_entry < bin_of_code)
	    {
	      DBG (SAMPLEDEBUG,
		   printf ("[scale_and_align_entries] pushing 0x%lx to 0x%lx\n",
			   (unsigned long) sym->hist.scaled_addr,
			   (unsigned long) (sym->hist.scaled_addr
					    + UNITS_TO_CODE)));
	      sym->hist.scaled_addr += UNITS_TO_CODE;
	    }
d261 2
a262 2
static void
hist_assign_samples_1 (histogram *r)
d271 4
a274 1
  bfd_vma lowpc = r->lowpc / sizeof (UNIT);
d277 1
a277 1
  for (i = 0, j = 1; i < r->num_bins; ++i)
d279 1
a279 1
      bin_count = r->sample[i];
a346 12
/* Calls 'hist_assign_sampes_1' for all histogram records read so far. */
void
hist_assign_samples ()
{
  unsigned i;

  scale_and_align_entries ();

  for (i = 0; i < num_histograms; ++i)
    hist_assign_samples_1 (&histograms[i]);
  
}
a554 85

int
hist_check_address (unsigned address)
{
  unsigned i;

  for (i = 0; i < num_histograms; ++i)
    if (histograms[i].lowpc <= address && address < histograms[i].highpc)
      return 1;

  return 0;        
}

#if ! defined(min)
#define min(a,b) (((a)<(b)) ? (a) : (b))
#endif
#if ! defined(max)
#define max(a,b) (((a)>(b)) ? (a) : (b))
#endif

void
hist_clip_symbol_address (bfd_vma *p_lowpc, bfd_vma *p_highpc)
{
  unsigned i;
  int found = 0;

  if (num_histograms == 0)
    {
      *p_highpc = *p_lowpc;
      return;
    }

  for (i = 0; i < num_histograms; ++i)
    {
      bfd_vma common_low, common_high;
      common_low = max (histograms[i].lowpc, *p_lowpc);
      common_high = min (histograms[i].highpc, *p_highpc);

      if (common_low < common_high)
	{
	  if (found)
	    {
	      // FIXME: some proper diagnostics.
	      // like: "a symbol covers more than one histogram record"
	      abort ();
	    }

	  found = 1;
	  *p_lowpc = common_low;
	  *p_highpc = common_high;
	}
    }

  if (!found)
    *p_highpc = *p_lowpc;
}

/* Find and return exising histogram record having the same lowpc and
   highpc as passed via the parameters.  Return NULL if nothing is found.
   The return value is valid until any new histogram is read.  */
static histogram *
find_histogram (bfd_vma lowpc, bfd_vma highpc)
{
  unsigned i;
  for (i = 0; i < num_histograms; ++i)
    {
      if (histograms[i].lowpc == lowpc && histograms[i].highpc == highpc)
	return &histograms[i];
    }
  return 0;
}

/* Given a PC, return histogram record which address range include this PC.
   Return NULL if there's no such record.  */
static histogram *
find_histogram_for_pc (bfd_vma pc)
{
  unsigned i;
  for (i = 0; i < num_histograms; ++i)
    {
      if (histograms[i].lowpc <= pc && pc < histograms[i].highpc)
	return &histograms[i];
    }
  return 0;  
}
@


1.14
log
@	* corefile.c (core_num_syms): Make static.
	(core_syms): Likewise.
	(min_insn_size): Likewise.
	* gprof.c (abfd): Remove unused variable.
	* hist.c (hist_dimension): Make static.
	(hist_dimension_abbrev): Likewise.
	* sym_ids.c (id_list): Likewise.
	(table_name): Likewise.
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.13
log
@update copyright dates
@
text
@d51 2
a52 2
char hist_dimension[16] = "seconds";
char hist_dimension_abbrev = 's';
@


1.12
log
@	* basic_blocks.c: Warning fixes.
	* gmon_io.c: Likewise.
	* hist.c: Likewise.
	* hist.h: Likewise.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
@


1.11
log
@	* alpha.c, basic_blocks.c, basic_blocks.h, bb_exit_func.c,
	call_graph.c, call_graph.h, cg_arcs.c, cg_arcs.h, cg_dfn.c,
	cg_dfn.h, cg_print.c, cg_print.h, corefile.c, corefile.h,
	gmon_io.c, gmon_io.h, gprof.c, gprof.h, hertz.h, hist.c, hist.h,
	i386.c, mips.c, search_list.c, search_list.h, source.c, source.h,
	sparc.c, sym_ids.c, sym_ids.h, symtab.c, symtab.h, tahoe.c,
	utils.c, utils.h, vax.c, gen-c-prog.awk: Convert K&R C to ANSI C.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d47 1
a47 1
int hist_num_bins = 0;		/* Number of histogram samples.  */
d86 1
a86 1
  int i, ncnt, profrate;
d114 1
a114 1
       printf ("[hist_read_rec] n_lowpc 0x%lx n_highpc 0x%lx ncnt %d\n",
d116 1
a116 1
       printf ("[hist_read_rec] s_lowpc 0x%lx s_highpc 0x%lx nsamples %d\n",
d123 1
a123 1
      || ncnt != hist_num_bins || hz != profrate)
d141 1
a141 1
		  _("%s: %s: unexpected EOF after reading %d of %d samples\n"),
d161 1
a161 1
  int i;
d266 2
a267 2
  int bin_count, i;
  unsigned int j;
d288 1
a288 1
      "[assign_samples] bin_low_pc=0x%lx, bin_high_pc=0x%lx, bin_count=%d\n",
@


1.10
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d36 4
a39 4
static void scale_and_align_entries PARAMS ((void));
static void print_header PARAMS ((int));
static void print_line PARAMS ((Sym *, double));
static int cmp_time PARAMS ((const PTR, const PTR));
d42 1
a42 1
extern void flat_blurb PARAMS ((FILE * fp));
d83 1
a83 3
hist_read_rec (ifp, filename)
     FILE * ifp;
     const char *filename;
d158 1
a158 3
hist_write_hist (ofp, filename)
     FILE * ofp;
     const char *filename;
d350 1
a350 2
print_header (prefix)
     int prefix;
d389 1
a389 3
print_line (sym, scale)
     Sym *sym;
     double scale;
d426 1
a426 3
cmp_time (lp, rp)
     const PTR lp;
     const PTR rp;
@


1.9
log
@2002-02-19  Frank Ch. Eigler  <fche@@redhat.com>

	* hist.c (hist_print): Rewrite log_scale calculation loop.
@
text
@d471 1
a471 1
    first_output = false;
@


1.8
log
@	* alpha.c (alpha_find_call): Warning fixes.
	* mips.c (mips_find_call): Likewise.
	* sparc.c (sparc_find_call): Likewise.
	* basic_blocks.c: Warning fixes.  Eliminate DEFUN.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.cp: Likewise.
	* gprof.c: Likewise.
	* gprof.h: Likewise.
	* hist.c: Likewise.
	* search_list.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* symtab.h: Likewise.
	* utils.c: Likewise.
	* cg_print.c: Likewise.
	(struct function_map, symbol_map, symbol_map_count): Move
	declaration to..
	* corefile: ..here.
	* corefile.c: Warning fixes.  Eliminate DEFUN.
	(struct function_map): Remove declaration.
	* gmon_io.c: Warning fixes.  Eliminate DEFUN.
	(gmon_io_read_64): Make static.
	(gmon_io_write_64): Likewise.
	(gmon_read_raw_arc): Likewise.
	(gmon_write_raw_arc): Likewise.
	(gmon_io_write_8): Don't pass char, pass int param.
	* gmon_io.h (gmon_io_write_8): Likewise.

and a few copyright dates that should have been done previously.
@
text
@d466 1
a466 1
  int log_scale;
d531 1
a531 3
	  while (SItab[log_scale].scale * top_time < 1000.0
		 && ((size_t) log_scale
		     < sizeof (SItab) / sizeof (SItab[0]) - 1))
d533 4
a536 1
	      ++log_scale;
@


1.7
log
@	* basic_blocks.c: Replace bool with boolean, TRUE with true and
	FALSE with false throughout.
	* basic_blocks.h: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hist.c: Likewise.
	* mips.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* tahoe.c: Likewise.
	* vax.c: Likewise.
	* gprof.h: Likewise.
	(TRUE): Don't define.
	(FALSE): Don't define.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d37 3
d83 3
a85 1
DEFUN (hist_read_rec, (ifp, filename), FILE * ifp AND const char *filename)
d160 3
a162 1
DEFUN (hist_write_hist, (ofp, filename), FILE * ofp AND const char *filename)
d183 1
a183 1
      bfd_put_16 (core_bfd, hist_sample[i], (bfd_byte *) & count[0]);
d265 1
a265 1
DEFUN_VOID (hist_assign_samples)
d354 2
a355 1
DEFUN (print_header, (prefix), const char prefix)
d394 3
a396 1
DEFUN (print_line, (sym, scale), Sym * sym AND double scale)
d433 3
a435 1
DEFUN (cmp_time, (lp, rp), const PTR lp AND const PTR rp)
d462 1
a462 1
DEFUN_VOID (hist_print)
@


1.6
log
@	* alpha.c (alpha_Instruction): Don't use.
	(alpha_find_call): Avoid use of bitfields and casts between
	pointers and integers of different sizes.  Avoid endian problems
	when cross-compiling.
	* vax.c (vax_find_call): Likewise.
	(struct modebyte): Don't use.
	(vax_operandmode): Pass in an unsigned char *.
	(vax_operandlength): Likewise.
	(vax_reladdr): Rename to vax_offset and return relative offset
	rather than address.
	* i386.c (i386_find_call): Avoid casts between pointers and
	integers of different sizes.
	* sparc.c (sparc_find_call): Likewise.  Avoid endian problems.
	* tahoe.c (tahoe_find_call): Likewise.
	(tahoe_reladdr): Rename to tahoe_offset and return relative offset
	rather than address.

	* basic_blocks.h: Don't include headers here.
	* call_graph.h: Likewise.
	* cg_arcs.h: Likewise.
	* cg_print.h: Likewise.
	* corefile.h: Likewise.
	* gmon_io.h: Likewise.
	* gmon_out.h: Likewise.
	* hertz.h: Likewise.
	* hist.h: Likewise.
	* source.h: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* gprof.h: Don't include ansidecl.h, do include bfd.h.
	(bool): Don't typedef.
	* alpha.c: Adjust #include's for above header changes.
	* basic_blocks.c: Likewise.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hertz.c: Likewise.
	* hist.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise.
	* sparc.c: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* tahoe.c: Likewise.
	* utils.c: Likewise.
	* vax.c: Likewise.

	* po/POTFILES.in: Regenerate.
@
text
@d459 1
a459 1
    first_output = FALSE;
@


1.5
log
@David Mosberger's fixes for cross compiling gprof.
@
text
@a21 1
#include <stdio.h>
d24 3
a30 1
#include "symtab.h"
@


1.4
log
@Fix typos in ChangeLog; fix dates in copyright notices
@
text
@d3 1
a3 1
   Copyright 2000 Free Software Foundation, Inc.
d46 1
a46 2
char hist_dimension[sizeof (((struct gmon_hist_hdr *) 0)->dimen) + 1] =
  "seconds";
d49 1
a49 1
static double accum_time;	/* Accumulated time so far for print_line().  */
d61 11
a71 44
  {
    'T', 1e-12
  }
  ,				/* tera */
  {
    'G', 1e-09
  }
  ,				/* giga */
  {
    'M', 1e-06
  }
  ,				/* mega */
  {
    'K', 1e-03
  }
  ,				/* kilo */
  {
    ' ', 1e-00
  }
  ,
  {
    'm', 1e+03
  }
  ,				/* milli */
  {
    'u', 1e+06
  }
  ,				/* micro */
  {
    'n', 1e+09
  }
  ,				/* nano */
  {
    'p', 1e+12
  }
  ,				/* pico */
  {
    'f', 1e+15
  }
  ,				/* femto */
  {
    'a', 1e+18
  }
  ,				/* ato */
a80 1
  struct gmon_hist_hdr hdr;
d85 6
a90 1
  if (fread (&hdr, sizeof (hdr), 1, ifp) != 1)
d94 1
a97 8
  n_lowpc = (bfd_vma) get_vma (core_bfd, (bfd_byte *) hdr.low_pc);
  n_highpc = (bfd_vma) get_vma (core_bfd, (bfd_byte *) hdr.high_pc);
  ncnt = bfd_get_32 (core_bfd, (bfd_byte *) hdr.hist_size);
  profrate = bfd_get_32 (core_bfd, (bfd_byte *) hdr.prof_rate);
  strncpy (hist_dimension, hdr.dimen, sizeof (hdr.dimen));
  hist_dimension[sizeof (hdr.dimen)] = '\0';
  hist_dimension_abbrev = hdr.dimen_abbrev;

d137 1
a137 1
		   _("%s: %s: unexpected EOF after reading %d of %d samples\n"),
d142 4
a155 2
  struct gmon_hist_hdr hdr;
  unsigned char tag;
d161 7
a167 10
  tag = GMON_TAG_TIME_HIST;
  put_vma (core_bfd, s_lowpc, (bfd_byte *) hdr.low_pc);
  put_vma (core_bfd, s_highpc, (bfd_byte *) hdr.high_pc);
  bfd_put_32 (core_bfd, hist_num_bins, (bfd_byte *) hdr.hist_size);
  bfd_put_32 (core_bfd, hz, (bfd_byte *) hdr.prof_rate);
  strncpy (hdr.dimen, hist_dimension, sizeof (hdr.dimen));
  hdr.dimen_abbrev = hist_dimension_abbrev;

  if (fwrite (&tag, sizeof (tag), 1, ofp) != 1
      || fwrite (&hdr, sizeof (hdr), 1, ofp) != 1)
d176 1
a176 1
      
d204 2
a205 1
      bin_of_code = (sym->hist.scaled_addr + UNITS_TO_CODE - lowpc) / hist_scale;
d220 1
a220 1
  
d225 1
a225 1
  
d232 13
a244 13
  
          sym_low_pc                                      sym_high_pc
               |                                               |
               v                                               v
  
               +-----------------------------------------------+
               |                                               |
          |  ->|    |<-         ->|         |<-         ->|    |<-  |
          |         |             |         |             |         |
          +---------+             +---------+             +---------+
  
          ^         ^             ^         ^             ^         ^
          |         |             |         |             |         |
d246 1
a246 1
  
d281 1
a281 1
      
d295 1
a295 1
	  
d312 6
a317 6
			    "[assign_samples] [0x%lx,0x%lx) %s gets %f ticks %ld overlap\n",
			    (unsigned long) symtab.base[j].addr,
			    (unsigned long) (sizeof (UNIT) * sym_high_pc),
			    symtab.base[j].name, overlap * time / hist_scale,
			    (long) overlap));
	      
d320 1
a320 1
	      
d322 2
a323 2
	         table is empty and it does not appear it in
	         EXCL_FLAT.  */
d337 1
a337 1
  
d370 1
a370 1
      
d376 2
a377 1
	  "%  ", _("cumulative"), _("self  "), "", _("self  "), _("total "), "");
d391 1
a391 1
  
d400 1
a400 1
  
d407 1
a407 1
  
d429 1
a429 1
  
d432 1
a432 1
  
d463 1
a463 1
  
d476 1
a476 1
  
d480 1
a480 1
  
d497 1
a497 1
      
d501 1
a501 1
	  
d505 1
a505 1
	      
d513 1
a513 1
      
d517 1
a517 1
	  
d531 1
a531 1
  
d535 1
a535 1
      
d537 1
a537 1
        is empty and the symbol is not in EXCL_FLAT.  */
d543 1
a543 1
  
@


1.3
log
@Add GPL copyright notices to uncopyrighted files.
Add copy of GPL.
@
text
@d3 1
a3 1
   Copyright (C) 2000  Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
@


1.3.2.2
log
@Merge from mainline.
@
text
@d46 2
a47 1
char hist_dimension[16] = "seconds";
d50 1
a50 1
static double accum_time;	/* Accumulated time so far for print_line(). */
d62 44
a105 11
  { 'T', 1e-12 },				/* tera */
  { 'G', 1e-09 },				/* giga */
  { 'M', 1e-06 },				/* mega */
  { 'K', 1e-03 },				/* kilo */
  { ' ', 1e-00 },
  { 'm', 1e+03 },				/* milli */
  { 'u', 1e+06 },				/* micro */
  { 'n', 1e+09 },				/* nano */
  { 'p', 1e+12 },				/* pico */
  { 'f', 1e+15 },				/* femto */
  { 'a', 1e+18 }				/* ato */
d115 1
d120 1
a120 6
  if (gmon_io_read_vma (ifp, &n_lowpc)
      || gmon_io_read_vma (ifp, &n_highpc)
      || gmon_io_read_32 (ifp, &ncnt)
      || gmon_io_read_32 (ifp, &profrate)
      || gmon_io_read (ifp, hist_dimension, 15)
      || gmon_io_read (ifp, &hist_dimension_abbrev, 1))
a123 1

d127 8
d174 1
a174 1
		  _("%s: %s: unexpected EOF after reading %d of %d samples\n"),
a178 4
      DBG (SAMPLEDEBUG,
	   printf ("[hist_read_rec] 0x%lx: %u\n",
		   (unsigned long) (n_lowpc + i * (n_highpc - n_lowpc) / ncnt),
		   hist_sample[i]));
d189 2
d196 10
a205 7
  if (gmon_io_write_8 (ofp, GMON_TAG_TIME_HIST)
      || gmon_io_write_vma (ofp, s_lowpc)
      || gmon_io_write_vma (ofp, s_highpc)
      || gmon_io_write_32 (ofp, hist_num_bins)
      || gmon_io_write_32 (ofp, hz)
      || gmon_io_write (ofp, hist_dimension, 15)
      || gmon_io_write (ofp, &hist_dimension_abbrev, 1))
d214 1
a214 1

d242 1
a242 2
      bin_of_code = ((sym->hist.scaled_addr + UNITS_TO_CODE - lowpc)
		     / hist_scale);
d257 1
a257 1

d262 1
a262 1

d269 13
a281 13

	  sym_low_pc                                      sym_high_pc
	       |                                               |
	       v                                               v

	       +-----------------------------------------------+
	       |                                               |
	  |  ->|    |<-         ->|         |<-         ->|    |<-  |
	  |         |             |         |             |         |
	  +---------+             +---------+             +---------+

	  ^         ^             ^         ^             ^         ^
	  |         |             |         |             |         |
d283 1
a283 1

d318 1
a318 1

d332 1
a332 1

d349 6
a354 6
	       "[assign_samples] [0x%lx,0x%lx) %s gets %f ticks %ld overlap\n",
			   (unsigned long) symtab.base[j].addr,
			   (unsigned long) (sizeof (UNIT) * sym_high_pc),
			   symtab.base[j].name, overlap * time / hist_scale,
			   (long) overlap));

d357 1
a357 1

d359 2
a360 2
		 table is empty and it does not appear it in
		 EXCL_FLAT.  */
d374 1
a374 1

d407 1
a407 1

d413 1
a413 2
	  "%  ", _("cumulative"), _("self  "), "", _("self  "), _("total "),
	  "");
d427 1
a427 1

d436 1
a436 1

d443 1
a443 1

d465 1
a465 1

d468 1
a468 1

d499 1
a499 1

d512 1
a512 1

d516 1
a516 1

d533 1
a533 1

d537 1
a537 1

d541 1
a541 1

d549 1
a549 1

d553 1
a553 1

d567 1
a567 1

d571 1
a571 1

d573 1
a573 1
	is empty and the symbol is not in EXCL_FLAT.  */
d579 1
a579 1

@


1.2
log
@	* Many files: Add casts in many print statements to cast bfd_vma
	values to unsigned long when calling printf.
	* Makefile.am ($(OBJECTS)): Add gmon.h.
	* Makefile.in: Rebuild.
@
text
@d1 21
a21 3
/*
 * Histogram related operations.
 */
d37 1
a37 1
/* declarations of automatically generated functions to output blurbs: */
d40 5
a44 5
bfd_vma s_lowpc;		/* lowest address in .text */
bfd_vma s_highpc = 0;		/* highest address in .text */
bfd_vma lowpc, highpc;		/* same, but expressed in UNITs */
int hist_num_bins = 0;		/* number of histogram samples */
int *hist_sample = 0;		/* histogram samples (shorts in the file!) */
d50 5
a54 6
static double accum_time;	/* accumulated time so far for print_line() */
static double total_time;	/* total time for all routines */
/*
 * Table of SI prefixes for powers of 10 (used to automatically
 * scale some of the values in the flat profile).
 */
d108 4
a111 4
/*
 * Read the histogram from file IFP.  FILENAME is the name of IFP and
 * is provided for formatting error messages only.
 */
d137 1
a137 3

      /* this is the first histogram record: */

d183 3
a185 4
/*
 * Write execution histogram to file OFP.  FILENAME is the name
 * of OFP and is provided for formatting error-messages only.
 */
d194 1
a194 1
  /* write header: */
d214 1
d224 7
a230 8
/*
 * Calculate scaled entry point addresses (to save time in
 * hist_assign_samples), and, on architectures that have procedure
 * entry masks at the start of a function, possibly push the scaled
 * entry points over the procedure entry mask, if it turns out that
 * the entry point is in one bin and the code for a routine is in the
 * next bin.
 */
d256 37
a292 38
/*
 * Assign samples to the symbol to which they belong.
 *
 * Histogram bin I covers some address range [BIN_LOWPC,BIN_HIGH_PC)
 * which may overlap one more symbol address ranges.  If a symbol
 * overlaps with the bin's address range by O percent, then O percent
 * of the bin's count is credited to that symbol.
 *
 * There are three cases as to where BIN_LOW_PC and BIN_HIGH_PC can be
 * with respect to the symbol's address range [SYM_LOW_PC,
 * SYM_HIGH_PC) as shown in the following diagram.  OVERLAP computes
 * the distance (in UNITs) between the arrows, the fraction of the
 * sample that is to be credited to the symbol which starts at
 * SYM_LOW_PC.
 *
 *        sym_low_pc                                      sym_high_pc
 *             |                                               |
 *             v                                               v
 *
 *             +-----------------------------------------------+
 *             |                                               |
 *        |  ->|    |<-         ->|         |<-         ->|    |<-  |
 *        |         |             |         |             |         |
 *        +---------+             +---------+             +---------+
 *
 *        ^         ^             ^         ^             ^         ^
 *        |         |             |         |             |         |
 *   bin_low_pc bin_high_pc  bin_low_pc bin_high_pc  bin_low_pc bin_high_pc
 *
 * For the VAX we assert that samples will never fall in the first two
 * bytes of any routine, since that is the entry mask, thus we call
 * scale_and_align_entries() to adjust the entry points if the entry
 * mask falls in one bin but the code for the routine doesn't start
 * until the next bin.  In conjunction with the alignment of routine
 * addresses, this should allow us to have only one sample for every
 * four bytes of text space and never have any overlap (the two end
 * cases, above).
 */
d303 1
a303 1
  /* read samples and assign to symbols: */
d308 1
a308 2
  /* iterate over all sample bins: */

d312 3
a314 4
      if (!bin_count)
	{
	  continue;
	}
d318 1
d327 1
a327 2
      /* credit all symbols that are covered by bin I: */

d332 3
a334 4
	  /*
	   * If high end of bin is below entry address, go for next
	   * bin:
	   */
d336 4
a339 7
	    {
	      break;
	    }
	  /*
	   * If low end of bin is above high end of symbol, go for
	   * next symbol.
	   */
d341 2
a342 3
	    {
	      continue;
	    }
d354 1
d357 4
a360 5
	      /*
	       * Credit symbol if it appears in INCL_FLAT or that
	       * table is empty and it does not appear it in
	       * EXCL_FLAT.
	       */
d374 1
d380 2
a381 3
/*
 * Print header for flag histogram profile:
 */
d407 2
a408 1
      /* this doesn't hurt since all the numerators will be zero: */
d424 1
a424 3
    {
      return;
    }
d427 1
d429 3
a431 5
    {
      printf ("%5.1f %10.2f %8.2f",
	      total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	      accum_time / hz, sym->hist.time / hz);
    }
d433 4
a436 5
    {
      printf ("%6.2f %9.2f %8.2f",
	      total_time > 0.0 ? 100 * sym->hist.time / total_time : 0.0,
	      accum_time / hz, sym->hist.time / hz);
    }
d438 3
a440 5
    {
      printf (" %8lu %8.2f %8.2f  ",
	      sym->ncalls, scale * sym->hist.time / hz / sym->ncalls,
	  scale * (sym->hist.time + sym->cg.child_time) / hz / sym->ncalls);
    }
d442 2
a443 3
    {
      printf (" %8.8s %8.8s %8.8s  ", "", "", "");
    }
d445 1
a445 3
    {
      print_name (sym);
    }
d447 2
a448 3
    {
      print_name_only (sym);
    }
d453 4
a456 5
/*
 * Compare LP and RP.  The primary comparison key is execution time,
 * the secondary is number of invocation, and the tertiary is the
 * lexicographic order of the function names.
 */
d465 1
d467 2
a468 3
    {
      return 1;
    }
d470 1
a470 3
    {
      return -1;
    }
d473 2
a474 3
    {
      return 1;
    }
d476 1
a476 3
    {
      return -1;
    }
d482 2
a483 3
/*
 * Print the flat histogram profile.
 */
d494 1
a494 3
    {
      first_output = FALSE;
    }
d496 1
a496 3
    {
      printf ("\f\n");
    }
d499 1
d512 3
a514 4
  /*
   * Sort the symbol table by time (call-count and name as secondary
   * and tertiary keys):
   */
d516 1
d518 2
a519 3
    {
      time_sorted_syms[index] = &symtab.base[index];
    }
d524 1
a524 1
      log_scale = 5;		/* milli-seconds is BSD-default */
d528 2
a529 4
      /*
       * Search for symbol with highest per-call execution time and
       * scale accordingly:
       */
d533 1
d537 1
d541 1
d549 1
d553 1
d563 3
a565 5
  /*
   * For now, the dimension is always seconds.  In the future, we
   * may also want to support other (pseudo-)dimensions (such as
   * I-cache misses etc.).
   */
d567 1
d571 3
a573 4
      /*
       * Print symbol if its in INCL_FLAT table or that table
       * is empty and the symbol is not in EXCL_FLAT.
       */
d577 1
a577 3
	{
	  print_line (time_sorted_syms[index], SItab[log_scale].scale);
	}
d579 1
d583 1
a583 3
    {
      flat_blurb (stdout);
    }
@


1.1
log
@Initial revision
@
text
@d133 1
a133 1
	       n_lowpc, n_highpc, ncnt);
d135 2
a136 1
	       s_lowpc, s_highpc, hist_num_bins);
d138 1
a138 1
	       lowpc, highpc));
d233 3
a235 2
		       sym->hist.scaled_addr,
		       sym->hist.scaled_addr + UNITS_TO_CODE));
d310 2
a311 1
		    sizeof (UNIT) * bin_low_pc, sizeof (UNIT) * bin_high_pc,
d344 2
a345 1
			    symtab.base[j].addr, sizeof (UNIT) * sym_high_pc,
d347 1
a347 1
			    overlap));
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

