head	1.19;
access;
symbols
	binutils-2_24-branch:1.19.0.8
	binutils-2_24-branchpoint:1.19
	binutils-2_21_1:1.18
	binutils-2_23_2:1.19
	binutils-2_23_1:1.19
	binutils-2_23:1.19
	binutils-2_23-branch:1.19.0.6
	binutils-2_23-branchpoint:1.19
	binutils-2_22_branch:1.19.0.4
	binutils-2_22:1.19
	binutils-2_22-branch:1.19.0.2
	binutils-2_22-branchpoint:1.19
	binutils-2_21:1.18
	binutils-2_21-branch:1.18.0.2
	binutils-2_21-branchpoint:1.18
	binutils-2_20_1:1.17.8.1
	binutils-2_20:1.17.8.1
	binutils-arc-20081103-branch:1.17.0.10
	binutils-arc-20081103-branchpoint:1.17
	binutils-2_20-branch:1.17.0.8
	binutils-2_20-branchpoint:1.17
	dje-cgen-play1-branch:1.17.0.6
	dje-cgen-play1-branchpoint:1.17
	arc-20081103-branch:1.17.0.4
	arc-20081103-branchpoint:1.17
	binutils-2_19_1:1.17
	binutils-2_19:1.17
	binutils-2_19-branch:1.17.0.2
	binutils-2_19-branchpoint:1.17
	binutils-2_18:1.16
	binutils-2_18-branch:1.16.0.2
	binutils-2_18-branchpoint:1.16
	binutils-csl-coldfire-4_1-32:1.15
	binutils-csl-sourcerygxx-4_1-32:1.15
	binutils-csl-innovasic-fido-3_4_4-33:1.15
	binutils-csl-sourcerygxx-3_4_4-32:1.13.2.1
	binutils-csl-coldfire-4_1-30:1.15
	binutils-csl-sourcerygxx-4_1-30:1.15
	binutils-csl-coldfire-4_1-28:1.15
	binutils-csl-sourcerygxx-4_1-29:1.15
	binutils-csl-sourcerygxx-4_1-28:1.15
	binutils-csl-arm-2006q3-27:1.15
	binutils-csl-sourcerygxx-4_1-27:1.15
	binutils-csl-arm-2006q3-26:1.15
	binutils-csl-sourcerygxx-4_1-26:1.15
	binutils-csl-sourcerygxx-4_1-25:1.15
	binutils-csl-sourcerygxx-4_1-24:1.15
	binutils-csl-sourcerygxx-4_1-23:1.15
	binutils-csl-sourcerygxx-4_1-21:1.15
	binutils-csl-arm-2006q3-21:1.15
	binutils-csl-sourcerygxx-4_1-22:1.15
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.15
	binutils-csl-sourcerygxx-4_1-20:1.15
	binutils-csl-arm-2006q3-19:1.15
	binutils-csl-sourcerygxx-4_1-19:1.15
	binutils-csl-sourcerygxx-4_1-18:1.15
	binutils-csl-renesas-4_1-9:1.15
	binutils-csl-sourcerygxx-3_4_4-25:1.13.2.1
	binutils-csl-renesas-4_1-8:1.15
	binutils-csl-renesas-4_1-7:1.15
	binutils-csl-renesas-4_1-6:1.15
	binutils-csl-sourcerygxx-4_1-17:1.15
	binutils-csl-sourcerygxx-4_1-14:1.15
	binutils-csl-sourcerygxx-4_1-15:1.15
	binutils-csl-sourcerygxx-4_1-13:1.15
	binutils-2_17:1.15
	binutils-csl-sourcerygxx-4_1-12:1.15
	binutils-csl-sourcerygxx-3_4_4-21:1.15
	binutils-csl-wrs-linux-3_4_4-24:1.13.2.1
	binutils-csl-wrs-linux-3_4_4-23:1.13.2.1
	binutils-csl-sourcerygxx-4_1-9:1.15
	binutils-csl-sourcerygxx-4_1-8:1.15
	binutils-csl-sourcerygxx-4_1-7:1.15
	binutils-csl-arm-2006q1-6:1.15
	binutils-csl-sourcerygxx-4_1-6:1.15
	binutils-csl-wrs-linux-3_4_4-22:1.13.2.1
	binutils-csl-coldfire-4_1-11:1.15
	binutils-csl-sourcerygxx-3_4_4-19:1.15
	binutils-csl-coldfire-4_1-10:1.15
	binutils-csl-sourcerygxx-4_1-5:1.15
	binutils-csl-sourcerygxx-4_1-4:1.15
	binutils-csl-wrs-linux-3_4_4-21:1.13.2.1
	binutils-csl-morpho-4_1-4:1.15
	binutils-csl-sourcerygxx-3_4_4-17:1.15
	binutils-csl-wrs-linux-3_4_4-20:1.13.2.1
	binutils-2_17-branch:1.15.0.4
	binutils-2_17-branchpoint:1.15
	binutils-csl-2_17-branch:1.15.0.2
	binutils-csl-2_17-branchpoint:1.15
	binutils-csl-gxxpro-3_4-branch:1.13.2.1.0.4
	binutils-csl-gxxpro-3_4-branchpoint:1.13.2.1
	binutils-2_16_1:1.13.2.1
	binutils-csl-arm-2005q1b:1.13.2.1
	binutils-2_16:1.13.2.1
	binutils-csl-arm-2005q1a:1.13.2.1
	binutils-csl-arm-2005q1-branch:1.13.2.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.13.2.1
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.11
	csl-arm-2004-q3:1.11
	gprof-pre-ansify-2004-05-26:1.10
	gprof-post-ansify-2004-05-26:1.11
	binutils-2_15:1.10
	binutils-2_15-branchpoint:1.10
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.10
	binutils-2_15-branch:1.10.0.8
	cagney_bfdfile-20040213-branch:1.10.0.6
	cagney_bfdfile-20040213-branchpoint:1.10
	cagney_bigcore-20040122-branch:1.10.0.4
	cagney_bigcore-20040122-branchpoint:1.10
	csl-arm-2003-q4:1.10
	binutils-2_14:1.10
	binutils-2_14-branch:1.10.0.2
	binutils-2_14-branchpoint:1.10
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	binutils-2_13_1:1.9
	binutils-2_13:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.4
	binutils-2_12_1:1.9
	binutils-2_12:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	cygnus_cvs_20020108_pre:1.6
	binutils-2_11_2:1.3.2.3
	binutils-2_11_1:1.3.2.3
	binutils-2_11:1.3.2.1
	x86_64versiong3:1.4
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.19
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2011.02.28.18.36.14;	author ktietz;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.11.15.27.34;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.19.16.30.29;	author schwab;	state Exp;
branches
	1.17.8.1;
next	1.16;

1.16
date	2007.07.06.10.40.34;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.09.06.55.24;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.15.16.20.42;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.03.12.05.12;	author amodra;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2005.02.22.12.59.21;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2004.05.26.04.55.55;	author bje;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.02.01.08.24.15;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.01.01.18.06;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.31.12.56.06;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.14.03.14.56;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.13.21.07.29;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.27.19.54.49;	author msokolov;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.24.20.59.03;	author nickc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.06.30.22.38.17;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.17.8.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.13.2.1
date	2005.03.15.16.21.40;	author nickc;	state Exp;
branches;
next	;

1.3.2.1
date	2001.01.27.21.16.09;	author msokolov;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.06.07.03.16.26;	author amodra;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2001.06.11.10.05.03;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches;
next	;


desc
@@


1.19
log
@2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* basic_blocks.c (cmp_bb): Use filename_(n)cmp.
	* cg_print.c (order_and_dump_functions_by_arcs): Likewise.
	(cg_print_file_ordering): Likewise.
	* corefile.c (read_function_mappings): Likewise.
	(core_create_line_syms): Likewise.
@
text
@/* basic_blocks.c  -  Basic-block level related code: reading/writing
   of basic-block info to/from gmon.out; computing and formatting of
   basic-block related statistics.

   Copyright 1999, 2000, 2001, 2002, 2004, 2005, 2007
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "gprof.h"
#include "libiberty.h"
#include "filenames.h"
#include "basic_blocks.h"
#include "corefile.h"
#include "gmon_io.h"
#include "gmon_out.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "sym_ids.h"

static int cmp_bb (const PTR, const PTR);
static int cmp_ncalls (const PTR, const PTR);
static void fskip_string (FILE *);
static void annotate_with_count (char *, unsigned int, int, PTR);

/* Default option values:  */
bfd_boolean bb_annotate_all_lines = FALSE;
unsigned long bb_min_calls = 1;
int bb_table_length = 10;

/* Variables used to compute annotated source listing stats:  */
static long num_executable_lines;
static long num_lines_executed;


/* Helper for sorting.  Compares two symbols and returns result
   such that sorting will be increasing according to filename, line
   number, and address (in that order).  */

static int
cmp_bb (const PTR lp, const PTR rp)
{
  int r;
  const Sym *left = *(const Sym **) lp;
  const Sym *right = *(const Sym **) rp;

  if (left->file && right->file)
    {
      r = filename_cmp (left->file->name, right->file->name);

      if (r)
	return r;

      if (left->line_num != right->line_num)
	return left->line_num - right->line_num;
    }

  if (left->addr < right->addr)
    return -1;
  else if (left->addr > right->addr)
    return 1;
  else
    return 0;
}


/* Helper for sorting.  Order basic blocks in decreasing number of
   calls, ties are broken in increasing order of line numbers.  */
static int
cmp_ncalls (const PTR lp, const PTR rp)
{
  const Sym *left = *(const Sym **) lp;
  const Sym *right = *(const Sym **) rp;

  if (!left)
    return 1;
  else if (!right)
    return -1;

  if (left->ncalls < right->ncalls)
    return 1;
  else if (left->ncalls > right->ncalls)
    return -1;

  return left->line_num - right->line_num;
}

/* Skip over variable length string.  */
static void
fskip_string (FILE *fp)
{
  int ch;

  while ((ch = fgetc (fp)) != EOF)
    {
      if (ch == '\0')
	break;
    }
}

/* Read a basic-block record from file IFP.  FILENAME is the name
   of file IFP and is provided for formatting error-messages only.  */

void
bb_read_rec (FILE *ifp, const char *filename)
{
  unsigned int nblocks, b;
  bfd_vma addr, ncalls;
  Sym *sym;

  if (gmon_io_read_32 (ifp, &nblocks))
    {
      fprintf (stderr, _("%s: %s: unexpected end of file\n"),
	       whoami, filename);
      done (1);
    }

  nblocks = bfd_get_32 (core_bfd, (bfd_byte *) & nblocks);
  if (gmon_file_version == 0)
    fskip_string (ifp);

  for (b = 0; b < nblocks; ++b)
    {
      if (gmon_file_version == 0)
	{
	  int line_num;

	  /* Version 0 had lots of extra stuff that we don't
	     care about anymore.  */
	  if ((fread (&ncalls, sizeof (ncalls), 1, ifp) != 1)
	      || (fread (&addr, sizeof (addr), 1, ifp) != 1)
	      || (fskip_string (ifp), FALSE)
	      || (fskip_string (ifp), FALSE)
	      || (fread (&line_num, sizeof (line_num), 1, ifp) != 1))
	    {
	      perror (filename);
	      done (1);
	    }
	}
      else if (gmon_io_read_vma (ifp, &addr)
	       || gmon_io_read_vma (ifp, &ncalls))
	{
	  perror (filename);
	  done (1);
	}

      /* Basic-block execution counts are meaningful only if we're
	 profiling at the line-by-line level:  */
      if (line_granularity)
	{
	  sym = sym_lookup (&symtab, addr);

	  if (sym)
	    {
	      int i;

	      DBG (BBDEBUG,
		   printf ("[bb_read_rec] 0x%lx->0x%lx (%s:%d) cnt=%lu\n",
			   (unsigned long) addr, (unsigned long) sym->addr,
			   sym->name, sym->line_num, (unsigned long) ncalls));

	      for (i = 0; i < NBBS; i++)
		{
		  if (! sym->bb_addr[i] || sym->bb_addr[i] == addr)
		    {
		      sym->bb_addr[i] = addr;
		      sym->bb_calls[i] += ncalls;
		      break;
		    }
		}
	    }
	}
      else
	{
	  static bfd_boolean user_warned = FALSE;

	  if (!user_warned)
	    {
	      user_warned = TRUE;
	      fprintf (stderr,
  _("%s: warning: ignoring basic-block exec counts (use -l or --line)\n"),
		       whoami);
	    }
	}
    }
  return;
}

/* Write all basic-blocks with non-zero counts to file OFP.  FILENAME
   is the name of OFP and is provided for producing error-messages
   only.  */
void
bb_write_blocks (FILE *ofp, const char *filename)
{
  unsigned int nblocks = 0;
  Sym *sym;
  int i;

  /* Count how many non-zero blocks with have:  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      for (i = 0; i < NBBS && sym->bb_addr[i]; i++)
	;
      nblocks += i;
    }

  /* Write header:  */
  if (gmon_io_write_8 (ofp, GMON_TAG_BB_COUNT)
      || gmon_io_write_32 (ofp, nblocks))
    {
      perror (filename);
      done (1);
    }

  /* Write counts:  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      for (i = 0; i < NBBS && sym->bb_addr[i]; i++)
	{
	  if (gmon_io_write_vma (ofp, sym->bb_addr[i])
	      || gmon_io_write_vma (ofp, (bfd_vma) sym->bb_calls[i]))
	    {
	      perror (filename);
	      done (1);
	    }
	}
    }
}

/* Output basic-block statistics in a format that is easily parseable.
   Current the format is:

	<filename>:<line-number>: (<function-name>:<bb-addr): <ncalls>  */

void
print_exec_counts ()
{
  Sym **sorted_bbs, *sym;
  unsigned int i, j, len;

  if (first_output)
    first_output = FALSE;
  else
    printf ("\f\n");

  /* Sort basic-blocks according to function name and line number:  */
  sorted_bbs = (Sym **) xmalloc (symtab.len * sizeof (sorted_bbs[0]));
  len = 0;

  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      /* Accept symbol if it's in the INCL_EXEC table
	 or there is no INCL_EXEC table
	 and it does not appear in the EXCL_EXEC table.  */
      if (sym_lookup (&syms[INCL_EXEC], sym->addr)
	  || (syms[INCL_EXEC].len == 0
	      && !sym_lookup (&syms[EXCL_EXEC], sym->addr)))
	{
	  sorted_bbs[len++] = sym;
	}
    }

  qsort (sorted_bbs, len, sizeof (sorted_bbs[0]), cmp_bb);

  /* Output basic-blocks:  */

  for (i = 0; i < len; ++i)
    {
      sym = sorted_bbs [i];
      
      if (sym->ncalls > 0 || ! ignore_zeros)
	{
	  /* FIXME: This only works if bfd_vma is unsigned long.  */
	  printf (_("%s:%d: (%s:0x%lx) %lu executions\n"),
		  sym->file ? sym->file->name : _("<unknown>"), sym->line_num,
		  sym->name, (unsigned long) sym->addr, sym->ncalls);
	}

      for (j = 0; j < NBBS && sym->bb_addr[j]; j ++)
	{
	  if (sym->bb_calls[j] > 0 || ! ignore_zeros)
	    {
	      /* FIXME: This only works if bfd_vma is unsigned long.  */
	      printf (_("%s:%d: (%s:0x%lx) %lu executions\n"),
		      sym->file ? sym->file->name : _("<unknown>"), sym->line_num,
		      sym->name, (unsigned long) sym->bb_addr[j],
		      sym->bb_calls[j]);
	    }
	}
    }
  free (sorted_bbs);
}

/* Helper for bb_annotated_source: format annotation containing
   number of line executions.  Depends on being called on each
   line of a file in sequential order.

   Global variable bb_annotate_all_lines enables execution count
   compression (counts are supressed if identical to the last one)
   and prints counts on all executed lines.  Otherwise, print
   all basic-block execution counts exactly once on the line
   that starts the basic-block.  */

static void
annotate_with_count (char *buf, unsigned int width, int line_num, PTR arg)
{
  Source_File *sf = (Source_File *) arg;
  Sym *b;
  unsigned int i;
  static unsigned long last_count;
  unsigned long last_print = (unsigned long) -1;

  b = NULL;

  if (line_num <= sf->num_lines)
    b = (Sym *) sf->line[line_num - 1];

  if (!b)
    {
      for (i = 0; i < width; i++)
	buf[i] = ' ';
      buf[width] = '\0';
    }
  else
    {
      char tmpbuf[NBBS * 30];
      char *p;
      unsigned long ncalls;
      int ncalls_set;
      unsigned int len;

      ++num_executable_lines;

      p = tmpbuf;
      *p = '\0';

      ncalls = 0;
      ncalls_set = 0;

      /* If this is a function entry point, label the line no matter what.
	 Otherwise, we're in the middle of a function, so check to see
	 if the first basic-block address is larger than the starting
	 address of the line.  If so, then this line begins with a
	 a portion of the previous basic-block, so print that prior
	 execution count (if bb_annotate_all_lines is set).  */
      if (b->is_func)
	{
	  sprintf (p, "%lu", b->ncalls);
	  p += strlen (p);
	  last_count = b->ncalls;
	  last_print = last_count;
	  ncalls = b->ncalls;
	  ncalls_set = 1;
	}
      else if (bb_annotate_all_lines
	       && b->bb_addr[0] && b->bb_addr[0] > b->addr)
	{
	  sprintf (p, "%lu", last_count);
	  p += strlen (p);
	  last_print = last_count;
	  ncalls = last_count;
	  ncalls_set = 1;
	}

      /* Loop through all of this line's basic-blocks.  For each one,
	 update last_count, then compress sequential identical counts
	 (if bb_annotate_all_lines) and print the execution count.  */

      for (i = 0; i < NBBS && b->bb_addr[i]; i++)
	{
	  last_count = b->bb_calls[i];
	  if (! ncalls_set)
	    {
	      ncalls = 0;
	      ncalls_set = 1;
	    }
	  ncalls += last_count;

	  if (bb_annotate_all_lines && last_count == last_print)
	    continue;

	  if (p > tmpbuf)
	    *p++ = ',';
	  sprintf (p, "%lu", last_count);
	  p += strlen (p);

	  last_print = last_count;
	}

      /* We're done.  If nothing has been printed on this line,
	 print the last execution count (bb_annotate_all_lines),
	 which could be from either a previous line (if there were
	 no BBs on this line), or from this line (if all our BB
	 counts were compressed out because they were identical).  */

      if (bb_annotate_all_lines && p == tmpbuf)
	{
	  sprintf (p, "%lu", last_count);
	  p += strlen (p);
	  ncalls = last_count;
	  ncalls_set = 1;
	}

      if (! ncalls_set)
	{
	  unsigned int c;

	  for (c = 0; c < width; c++)
	    buf[c] = ' ';
	  buf[width] = '\0';
	  return;
	}

      ++num_lines_executed;

      if (ncalls < bb_min_calls)
	{
	  strcpy (tmpbuf, "#####");
	  p = tmpbuf + 5;
	}

      strcpy (p, " -> ");
      p += 4;

      len = p - tmpbuf;
      if (len >= width)
	{
	  strncpy (buf, tmpbuf, width);
	  buf[width] = '\0';
	}
      else
	{
	  unsigned int c;

	  strcpy (buf + width - len, tmpbuf);
	  for (c = 0; c < width - len; ++c)
	    buf[c] = ' ';
	}
    }
}

/* Annotate the files named in SOURCE_FILES with basic-block statistics
   (execution counts).  After each source files, a few statistics
   regarding that source file are printed.  */

void
print_annotated_source ()
{
  Sym *sym, *line_stats, *new_line;
  Source_File *sf;
  int i, table_len;
  FILE *ofp;

  /* Find maximum line number for each source file that user is
     interested in:  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      /* Accept symbol if it's file is known, its line number is
	 bigger than anything we have seen for that file so far and
	 if it's in the INCL_ANNO table or there is no INCL_ANNO
	 table and it does not appear in the EXCL_ANNO table.  */
      if (sym->file && sym->line_num > sym->file->num_lines
	  && (sym_lookup (&syms[INCL_ANNO], sym->addr)
	      || (syms[INCL_ANNO].len == 0
		  && !sym_lookup (&syms[EXCL_ANNO], sym->addr))))
	{
	  sym->file->num_lines = sym->line_num;
	}
    }

  /* Allocate line descriptors:  */
  for (sf = first_src_file; sf; sf = sf->next)
    {
      if (sf->num_lines > 0)
	{
	  sf->line = (void **) xmalloc (sf->num_lines * sizeof (sf->line[0]));
	  memset (sf->line, 0, sf->num_lines * sizeof (sf->line[0]));
	}
    }

  /* Count executions per line:  */
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      if (sym->file && sym->file->num_lines
	  && (sym_lookup (&syms[INCL_ANNO], sym->addr)
	      || (syms[INCL_ANNO].len == 0
		  && !sym_lookup (&syms[EXCL_ANNO], sym->addr))))
	{
	  sym->file->ncalls += sym->ncalls;
	  line_stats = (Sym *) sym->file->line[sym->line_num - 1];

	  if (!line_stats)
	    {
	      /* Common case has at most one basic-block per source line:  */
	      sym->file->line[sym->line_num - 1] = sym;
	    }
	  else if (!line_stats->addr)
	    {
	      /* sym is the 3rd .. nth basic block for this line:  */
	      line_stats->ncalls += sym->ncalls;
	    }
	  else
	    {
	      /* sym is the second basic block for this line.  */
	      new_line = (Sym *) xmalloc (sizeof (*new_line));
	      *new_line = *line_stats;
	      new_line->addr = 0;
	      new_line->ncalls += sym->ncalls;
	      sym->file->line[sym->line_num - 1] = new_line;
	    }
	}
    }

  /* Plod over source files, annotating them:  */
  for (sf = first_src_file; sf; sf = sf->next)
    {
      if (!sf->num_lines || (ignore_zeros && sf->ncalls == 0))
	continue;

      num_executable_lines = num_lines_executed = 0;

      ofp = annotate_source (sf, 16, annotate_with_count, sf);
      if (!ofp)
	continue;

      if (bb_table_length > 0)
	{
	  fprintf (ofp, _("\n\nTop %d Lines:\n\n     Line      Count\n\n"),
		   bb_table_length);

	  /* Abuse line arrays---it's not needed anymore:  */
	  qsort (sf->line, sf->num_lines, sizeof (sf->line[0]), cmp_ncalls);
	  table_len = bb_table_length;

	  if (table_len > sf->num_lines)
	    table_len = sf->num_lines;

	  for (i = 0; i < table_len; ++i)
	    {
	      sym = (Sym *) sf->line[i];

	      if (!sym || sym->ncalls == 0)
		  break;

	      fprintf (ofp, "%9d %10lu\n", sym->line_num, sym->ncalls);
	    }
	}

      free (sf->line);
      sf->line = 0;

      fprintf (ofp, _("\nExecution Summary:\n\n"));
      fprintf (ofp, _("%9ld   Executable lines in this file\n"),
	       num_executable_lines);
      fprintf (ofp, _("%9ld   Lines executed\n"), num_lines_executed);
      fprintf (ofp, _("%9.2f   Percent of the file executed\n"),
	       num_executable_lines
	       ? 100.0 * num_lines_executed / (double) num_executable_lines
	       : 100.0);
      fprintf (ofp, _("\n%9lu   Total number of line executions\n"),
	       sf->ncalls);
      fprintf (ofp, _("%9.2f   Average executions per line\n"),
	       num_executable_lines
	       ? (double) sf->ncalls / (double) num_executable_lines
	       : 0.0);

      if (ofp != stdout)
	fclose (ofp);
    }
}
@


1.18
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d27 1
d65 1
a65 1
      r = strcmp (left->file->name, right->file->name);
@


1.17
log
@* basic_blocks.c: Always include "gprof.h" first.
* cg_arcs.c: Likewise.
* cg_dfn.c: Likewise.
* cg_print.c: Likewise.
* corefile.c: Likewise.
* gprof.c: Likewise.
* hist.c: Likewise.
* search_list.c: Likewise.
* sym_ids.c: Likewise.
* utils.c: Likewise.
@
text
@d322 1
a322 1
  Source_File *sf = arg;
d331 1
a331 1
    b = sf->line[line_num - 1];
d491 1
a491 1
	  sf->line = (void *) xmalloc (sf->num_lines * sizeof (sf->line[0]));
d505 1
a505 1
	  line_stats = sym->file->line[sym->line_num - 1];
d555 1
a555 1
	      sym = sf->line[i];
@


1.17.8.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d322 1
a322 1
  Source_File *sf = (Source_File *) arg;
d331 1
a331 1
    b = (Sym *) sf->line[line_num - 1];
d491 1
a491 1
	  sf->line = (void **) xmalloc (sf->num_lines * sizeof (sf->line[0]));
d505 1
a505 1
	  line_stats = (Sym *) sym->file->line[sym->line_num - 1];
d555 1
a555 1
	      sym = (Sym *) sf->line[i];
@


1.16
log
@CHange FSF sources over to GPLv3
@
text
@d25 1
a26 1
#include "gprof.h"
@


1.15
log
@Update the address of the FSF
@
text
@d5 1
a5 1
   Copyright 1999, 2000, 2001, 2002, 2004, 2005
d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
@


1.14
log
@Step through the sorted array of basic blocks.
@
text
@d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.13
log
@update copyright dates
@
text
@d284 2
@


1.13.2.1
log
@Step through the sorted array of basic blocks.
@
text
@a283 2
      sym = sorted_bbs [i];
      
@


1.12
log
@	* basic_blocks.c: Warning fixes.
	* gmon_io.c: Likewise.
	* hist.c: Likewise.
	* hist.h: Likewise.
@
text
@d5 2
a6 1
   Copyright 2000, 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
@


1.11
log
@	* alpha.c, basic_blocks.c, basic_blocks.h, bb_exit_func.c,
	call_graph.c, call_graph.h, cg_arcs.c, cg_arcs.h, cg_dfn.c,
	cg_dfn.h, cg_print.c, cg_print.h, corefile.c, corefile.h,
	gmon_io.c, gmon_io.h, gprof.c, gprof.h, hertz.h, hist.c, hist.h,
	i386.c, mips.c, search_list.c, search_list.h, source.c, source.h,
	sparc.c, sym_ids.c, sym_ids.h, symtab.c, symtab.h, tahoe.c,
	utils.c, utils.h, vax.c, gen-c-prog.awk: Convert K&R C to ANSI C.
@
text
@d5 1
a5 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d121 1
a121 1
  int nblocks, b;
@


1.10
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d35 4
a38 4
static int cmp_bb PARAMS ((const PTR, const PTR));
static int cmp_ncalls PARAMS ((const PTR, const PTR));
static void fskip_string PARAMS ((FILE *));
static void annotate_with_count PARAMS ((char *, unsigned int, int, PTR));
d55 1
a55 3
cmp_bb (lp, rp)
     const PTR lp;
     const PTR rp;
d84 1
a84 3
cmp_ncalls (lp, rp)
     const PTR lp;
     const PTR rp;
d104 1
a104 2
fskip_string (fp)
     FILE *fp;
d119 1
a119 3
bb_read_rec (ifp, filename)
     FILE *ifp;
     const char *filename;
d207 1
a207 3
bb_write_blocks (ofp, filename)
     FILE *ofp;
     const char *filename;
d317 1
a317 5
annotate_with_count (buf, width, line_num, arg)
     char *buf;
     unsigned int width;
     int line_num;
     PTR arg;
@


1.9
log
@	* alpha.c (alpha_find_call): Warning fixes.
	* mips.c (mips_find_call): Likewise.
	* sparc.c (sparc_find_call): Likewise.
	* basic_blocks.c: Warning fixes.  Eliminate DEFUN.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.cp: Likewise.
	* gprof.c: Likewise.
	* gprof.h: Likewise.
	* hist.c: Likewise.
	* search_list.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* symtab.h: Likewise.
	* utils.c: Likewise.
	* cg_print.c: Likewise.
	(struct function_map, symbol_map, symbol_map_count): Move
	declaration to..
	* corefile: ..here.
	* corefile.c: Warning fixes.  Eliminate DEFUN.
	(struct function_map): Remove declaration.
	* gmon_io.c: Warning fixes.  Eliminate DEFUN.
	(gmon_io_read_64): Make static.
	(gmon_io_write_64): Likewise.
	(gmon_read_raw_arc): Likewise.
	(gmon_write_raw_arc): Likewise.
	(gmon_io_write_8): Don't pass char, pass int param.
	* gmon_io.h (gmon_io_write_8): Likewise.

and a few copyright dates that should have been done previously.
@
text
@d41 1
a41 1
boolean bb_annotate_all_lines = false;
d153 2
a154 2
	      || (fskip_string (ifp), false)
	      || (fskip_string (ifp), false)
d196 1
a196 1
	  static boolean user_warned = false;
d200 1
a200 1
	      user_warned = true;
d265 1
a265 1
    first_output = false;
@


1.8
log
@	* basic_blocks.c: Replace bool with boolean, TRUE with true and
	FALSE with false throughout.
	* basic_blocks.h: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hist.c: Likewise.
	* mips.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* tahoe.c: Likewise.
	* vax.c: Likewise.
	* gprof.h: Likewise.
	(TRUE): Don't define.
	(FALSE): Don't define.
@
text
@d5 1
a5 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d35 5
d55 3
a57 1
DEFUN (cmp_bb, (lp, rp), const void *lp AND const void *rp)
d86 3
a88 1
DEFUN (cmp_ncalls, (lp, rp), const void *lp AND const void *rp)
d108 2
a109 1
DEFUN (fskip_string, (fp), FILE * fp)
d124 3
a126 1
DEFUN (bb_read_rec, (ifp, filename), FILE * ifp AND const char *filename)
d214 3
a216 1
DEFUN (bb_write_blocks, (ofp, filename), FILE * ofp AND const char *filename)
d218 1
a218 1
  int nblocks = 0;
d244 1
a244 1
	      || gmon_io_write_vma (ofp, sym->bb_calls[i]))
d259 1
a259 1
DEFUN_VOID (print_exec_counts)
d262 1
a262 1
  int i, j, len;
d326 5
a330 2
DEFUN (annotate_with_count, (buf, width, line_num, arg),
       char *buf AND int width AND int line_num AND void *arg)
d334 1
a334 1
  int i;
d355 1
a355 1
      int len;
d431 1
a431 1
	  int c;
d458 1
a458 1
	  int c;
d472 1
a472 1
DEFUN_VOID (print_annotated_source)
@


1.7
log
@	* alpha.c (alpha_Instruction): Don't use.
	(alpha_find_call): Avoid use of bitfields and casts between
	pointers and integers of different sizes.  Avoid endian problems
	when cross-compiling.
	* vax.c (vax_find_call): Likewise.
	(struct modebyte): Don't use.
	(vax_operandmode): Pass in an unsigned char *.
	(vax_operandlength): Likewise.
	(vax_reladdr): Rename to vax_offset and return relative offset
	rather than address.
	* i386.c (i386_find_call): Avoid casts between pointers and
	integers of different sizes.
	* sparc.c (sparc_find_call): Likewise.  Avoid endian problems.
	* tahoe.c (tahoe_find_call): Likewise.
	(tahoe_reladdr): Rename to tahoe_offset and return relative offset
	rather than address.

	* basic_blocks.h: Don't include headers here.
	* call_graph.h: Likewise.
	* cg_arcs.h: Likewise.
	* cg_print.h: Likewise.
	* corefile.h: Likewise.
	* gmon_io.h: Likewise.
	* gmon_out.h: Likewise.
	* hertz.h: Likewise.
	* hist.h: Likewise.
	* source.h: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* gprof.h: Don't include ansidecl.h, do include bfd.h.
	(bool): Don't typedef.
	* alpha.c: Adjust #include's for above header changes.
	* basic_blocks.c: Likewise.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hertz.c: Likewise.
	* hist.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise.
	* sparc.c: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* tahoe.c: Likewise.
	* utils.c: Likewise.
	* vax.c: Likewise.

	* po/POTFILES.in: Regenerate.
@
text
@d36 1
a36 1
bool bb_annotate_all_lines = FALSE;
d141 2
a142 2
	      || (fskip_string (ifp), FALSE)
	      || (fskip_string (ifp), FALSE)
d184 1
a184 1
	  static bool user_warned = FALSE;
d188 1
a188 1
	      user_warned = TRUE;
d251 1
a251 1
    first_output = FALSE;
@


1.6
log
@David Mosberger's fixes for cross compiling gprof.
@
text
@d24 2
a25 1
#include <stdio.h>
d30 1
a30 2
#include "gprof.h"
#include "libiberty.h"
d32 1
a33 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
@


1.5
log
@Fix typos in ChangeLog; fix dates in copyright notices
@
text
@d61 1
a61 1
      
d119 1
a119 2
  bfd_vma addr;
  unsigned long ncalls;
d122 1
a122 1
  if (fread (&nblocks, sizeof (nblocks), 1, ifp) != 1)
d124 2
a125 1
      fprintf (stderr, _("%s: %s: unexpected end of file\n"), whoami, filename);
a129 1
  
d138 1
a138 1
	  
d151 2
a152 1
      else
d154 2
a155 6
	  if (fread (&addr, sizeof (addr), 1, ifp) != 1
	      || fread (&ncalls, sizeof (ncalls), 1, ifp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
d159 1
a159 1
         profiling at the line-by-line level:  */
a161 4
	  /* Convert from target to host endianness:  */
	  addr = get_vma (core_bfd, (bfd_byte *) & addr);
	  ncalls = bfd_get_32 (core_bfd, (bfd_byte *) &ncalls);

d171 1
a171 1
			   sym->name, sym->line_num, ncalls));
a205 1
  const unsigned char tag = GMON_TAG_BB_COUNT;
a206 2
  bfd_vma addr;
  unsigned long ncalls;
d219 2
a220 3
  bfd_put_32 (core_bfd, nblocks, (bfd_byte *) & nblocks);
  if (fwrite (&tag, sizeof (tag), 1, ofp) != 1
      || fwrite (&nblocks, sizeof (nblocks), 1, ofp) != 1)
d231 2
a232 5
	  put_vma (core_bfd, sym->bb_addr[i], (bfd_byte *) & addr);
	  bfd_put_32 (core_bfd, sym->bb_calls[i], (bfd_byte *) & ncalls);

	  if (fwrite (&addr, sizeof (addr), 1, ofp) != 1
	      || fwrite (&ncalls, sizeof (ncalls), 1, ofp) != 1)
d243 2
a244 2
  
        <filename>:<line-number>: (<function-name>:<bb-addr): <ncalls>  */
d260 1
a260 1
  
d264 2
a265 2
         or there is no INCL_EXEC table
         and it does not appear in the EXCL_EXEC table.  */
d273 1
a273 1
  
d287 1
a287 1
      
d306 1
a306 1
  
d324 1
a324 1
  
d351 5
a355 5
         Otherwise, we're in the middle of a function, so check to see
         if the first basic-block address is larger than the starting
         address of the line.  If so, then this line begins with a
         a portion of the previous basic-block, so print that prior
         execution count (if bb_annotate_all_lines is set).  */
d376 2
a377 2
         update last_count, then compress sequential identical counts
         (if bb_annotate_all_lines) and print the execution count.  */
d401 4
a404 4
         print the last execution count (bb_annotate_all_lines),
         which could be from either a previous line (if there were
         no BBs on this line), or from this line (if all our BB
         counts were compressed out because they were identical).  */
d469 3
a471 3
         bigger than anything we have seen for that file so far and
         if it's in the INCL_ANNO table or there is no INCL_ANNO
         table and it does not appear in the EXCL_ANNO table.  */
d501 1
a501 1
	  
d531 1
a531 1
      
d544 1
a544 1
	  
d547 1
a547 1
	  
d551 1
a551 1
	      
d576 1
a576 1
      
@


1.4
log
@	* basic_blocks.c: #include <unistd.h> only if it exists.
@
text
@d5 1
a5 1
   Copyright (C) 2000  Free Software Foundation, Inc.
@


1.3
log
@Add GPL copyright notices to uncopyrighted files.
Add copy of GPL.
@
text
@a24 1
#include <unistd.h>
d33 3
@


1.3.2.1
log
@	* basic_blocks.c: #include <unistd.h> only if it exists.
@
text
@d25 1
a33 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
@


1.3.2.2
log
@Update copyright notices.
@
text
@d5 1
a5 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
@


1.3.2.3
log
@Merge from mainline.
@
text
@d61 1
a61 1

d119 2
a120 1
  bfd_vma addr, ncalls;
d123 1
a123 1
  if (gmon_io_read_32 (ifp, &nblocks))
d125 1
a125 2
      fprintf (stderr, _("%s: %s: unexpected end of file\n"),
	       whoami, filename);
d130 1
d139 1
a139 1

d152 1
a152 2
      else if (gmon_io_read_vma (ifp, &addr)
	       || gmon_io_read_vma (ifp, &ncalls))
d154 6
a159 2
	  perror (filename);
	  done (1);
d163 1
a163 1
	 profiling at the line-by-line level:  */
d166 4
d179 1
a179 1
			   sym->name, sym->line_num, (unsigned long) ncalls));
d214 1
d216 2
d230 3
a232 2
  if (gmon_io_write_8 (ofp, GMON_TAG_BB_COUNT)
      || gmon_io_write_32 (ofp, nblocks))
d243 5
a247 2
	  if (gmon_io_write_vma (ofp, sym->bb_addr[i])
	      || gmon_io_write_vma (ofp, sym->bb_calls[i]))
d258 2
a259 2

	<filename>:<line-number>: (<function-name>:<bb-addr): <ncalls>  */
d275 1
a275 1

d279 2
a280 2
	 or there is no INCL_EXEC table
	 and it does not appear in the EXCL_EXEC table.  */
d288 1
a288 1

d302 1
a302 1

d321 1
a321 1

d339 1
a339 1

d366 5
a370 5
	 Otherwise, we're in the middle of a function, so check to see
	 if the first basic-block address is larger than the starting
	 address of the line.  If so, then this line begins with a
	 a portion of the previous basic-block, so print that prior
	 execution count (if bb_annotate_all_lines is set).  */
d391 2
a392 2
	 update last_count, then compress sequential identical counts
	 (if bb_annotate_all_lines) and print the execution count.  */
d416 4
a419 4
	 print the last execution count (bb_annotate_all_lines),
	 which could be from either a previous line (if there were
	 no BBs on this line), or from this line (if all our BB
	 counts were compressed out because they were identical).  */
d484 3
a486 3
	 bigger than anything we have seen for that file so far and
	 if it's in the INCL_ANNO table or there is no INCL_ANNO
	 table and it does not appear in the EXCL_ANNO table.  */
d516 1
a516 1

d546 1
a546 1

d559 1
a559 1

d562 1
a562 1

d566 1
a566 1

d591 1
a591 1

@


1.2
log
@	* Many files: Add casts in many print statements to cast bfd_vma
	values to unsigned long when calling printf.
	* Makefile.am ($(OBJECTS)): Add gmon.h.
	* Makefile.in: Rebuild.
@
text
@d1 23
a23 5
/*
 * Basic-block level related code: reading/writing of basic-block info
 * to/from gmon.out; computing and formatting of basic-block related
 * statistics.
 */
d35 1
a35 4

/*
 * Default option values:
 */
d40 1
a40 3
/*
 * Variables used to compute annotated source listing stats:
 */
d45 3
a47 5
/*
 * Helper for sorting.  Compares two symbols and returns result
 * such that sorting will be increasing according to filename, line
 * number, and address (in that order).
 */
d59 1
d61 1
a61 3
	{
	  return r;
	}
d64 1
a64 3
	{
	  return left->line_num - right->line_num;
	}
d68 1
a68 3
    {
      return -1;
    }
d70 1
a70 3
    {
      return 1;
    }
d72 1
a72 3
    {
      return 0;
    }
d76 2
a77 4
/*
 * Helper for sorting.  Order basic blocks in decreasing number of
 * calls, ties are broken in increasing order of line numbers.
 */
d85 1
a85 3
    {
      return 1;
    }
d87 1
a87 3
    {
      return -1;
    }
d97 1
a97 4

/*
 * Skip over variable length string.
 */
d106 1
a106 3
	{
	  break;
	}
d110 2
a112 4
/*
 * Read a basic-block record from file IFP.  FILENAME is the name
 * of file IFP and is provided for formatting error-messages only.
 */
d128 1
d130 1
a130 3
    {
      fskip_string (ifp);
    }
d137 3
a139 4
	  /*
	   * Version 0 had lots of extra stuff that we don't
	   * care about anymore.
	   */
d160 2
a161 4
      /*
       * Basic-block execution counts are meaningful only if we're
       * profiling at the line-by-line level:
       */
d164 1
a164 3

	  /* convert from target to host endianness: */

d198 1
a198 1
		       _("%s: warning: ignoring basic-block exec counts (use -l or --line)\n"),
d206 3
a208 6

/*
 * Write all basic-blocks with non-zero counts to file OFP.  FILENAME
 * is the name of OFP and is provided for producing error-messages
 * only.
 */
d219 1
a219 2
  /* count how many non-zero blocks with have: */

d227 1
a227 1
  /* write header: */
d236 1
a236 1
  /* write counts: */
d254 4
a258 6
/*
 * Output basic-block statistics in a format that is easily parseable.
 * Current the format is:
 *
 *      <filename>:<line-number>: (<function-name>:<bb-addr): <ncalls>
 */
d266 1
a266 3
    {
      first_output = FALSE;
    }
d268 1
a268 5
    {
      printf ("\f\n");
    }

  /* sort basic-blocks according to function name and line number: */
d270 1
d273 1
d276 3
a278 5
      /*
       * Accept symbol if it's in the INCL_EXEC table
       * or there is no INCL_EXEC table
       *    and it does not appear in the EXCL_EXEC table.
       */
d286 1
d289 1
a289 1
  /* output basic-blocks: */
d300 1
d316 9
a324 11
/*
 * Helper for bb_annotated_source: format annotation containing
 * number of line executions.  Depends on being called on each
 * line of a file in sequential order.
 *
 * Global variable bb_annotate_all_lines enables execution count
 * compression (counts are supressed if identical to the last one)
 * and prints counts on all executed lines.  Otherwise, print
 * all basic-block execution counts exactly once on the line
 * that starts the basic-block.
 */
d337 1
d339 2
a340 3
    {
      b = sf->line[line_num - 1];
    }
d364 5
a368 7
       * Otherwise, we're in the middle of a function, so check to see
       * if the first basic-block address is larger than the starting
       * address of the line.  If so, then this line begins with a
       * a portion of the previous basic-block, so print that prior
       * execution count (if bb_annotate_all_lines is set).
       */

d389 2
a390 3
       * update last_count, then compress sequential identical counts
       * (if bb_annotate_all_lines) and print the execution count.
       */
d403 1
a403 3
	    {
	      continue;
	    }
d414 4
a417 5
       * print the last execution count (bb_annotate_all_lines),
       * which could be from either a previous line (if there were
       * no BBs on this line), or from this line (if all our BB
       * counts were compressed out because they were identical).
       */
d465 4
a468 5
/*
 * Annotate the files named in SOURCE_FILES with basic-block statistics
 * (execution counts).  After each source files, a few statistics
 * regarding that source file are printed.
 */
d477 2
a478 4
  /*
   * Find maximum line number for each source file that user is
   * interested in:
   */
d481 4
a484 6
      /*
       * Accept symbol if it's file is known, its line number is
       * bigger than anything we have seen for that file so far and
       * if it's in the INCL_ANNO table or there is no INCL_ANNO
       * table and it does not appear in the EXCL_ANNO table.
       */
d494 1
a494 2
  /* allocate line descriptors: */

d504 1
a504 2
  /* count executions per line: */

d514 1
d517 1
a517 1
	      /* common case has at most one basic-block per source line: */
d522 1
a522 1
	      /* sym is the 3rd .. nth basic block for this line: */
d527 1
a527 1
	      /* sym is the second basic block for this line */
d537 1
a537 2
  /* plod over source files, annotating them: */

d541 1
a541 3
	{
	  continue;
	}
d544 1
d547 1
a547 3
	{
	  continue;
	}
d554 1
a554 1
	  /* abuse line arrays---it's not needed anymore: */
d557 1
d559 2
a560 3
	    {
	      table_len = sf->num_lines;
	    }
d564 1
a565 1
		{
d567 1
a567 1
		}
d589 1
d591 1
a591 3
	{
	  fclose (ofp);
	}
@


1.1
log
@Initial revision
@
text
@d193 2
a194 1
			   addr, sym->addr, sym->name, sym->line_num, ncalls));
d323 1
d326 1
a326 1
		  sym->name, sym->addr, sym->ncalls);
d332 1
d335 2
a336 1
		      sym->name, sym->bb_addr[j], sym->bb_calls[j]);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

