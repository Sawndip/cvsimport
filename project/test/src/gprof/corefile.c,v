head	1.47;
access;
symbols
	binutils-2_24-branch:1.46.0.2
	binutils-2_24-branchpoint:1.46
	binutils-2_21_1:1.40.2.1
	binutils-2_23_2:1.44
	binutils-2_23_1:1.44
	binutils-2_23:1.44
	binutils-2_23-branch:1.44.0.2
	binutils-2_23-branchpoint:1.44
	binutils-2_22_branch:1.43.0.4
	binutils-2_22:1.43
	binutils-2_22-branch:1.43.0.2
	binutils-2_22-branchpoint:1.43
	binutils-2_21:1.40
	binutils-2_21-branch:1.40.0.2
	binutils-2_21-branchpoint:1.40
	binutils-2_20_1:1.36.4.2
	binutils-2_20:1.36.4.2
	binutils-arc-20081103-branch:1.31.0.6
	binutils-arc-20081103-branchpoint:1.31
	binutils-2_20-branch:1.36.0.4
	binutils-2_20-branchpoint:1.36
	dje-cgen-play1-branch:1.36.0.2
	dje-cgen-play1-branchpoint:1.36
	arc-20081103-branch:1.31.0.4
	arc-20081103-branchpoint:1.31
	binutils-2_19_1:1.31
	binutils-2_19:1.31
	binutils-2_19-branch:1.31.0.2
	binutils-2_19-branchpoint:1.31
	binutils-2_18:1.29
	binutils-2_18-branch:1.29.0.2
	binutils-2_18-branchpoint:1.29
	binutils-csl-coldfire-4_1-32:1.23.2.2
	binutils-csl-sourcerygxx-4_1-32:1.23.2.2
	binutils-csl-innovasic-fido-3_4_4-33:1.23.2.2
	binutils-csl-sourcerygxx-3_4_4-32:1.20.2.1
	binutils-csl-coldfire-4_1-30:1.23.2.2
	binutils-csl-sourcerygxx-4_1-30:1.23.2.2
	binutils-csl-coldfire-4_1-28:1.23.2.2
	binutils-csl-sourcerygxx-4_1-29:1.23.2.2
	binutils-csl-sourcerygxx-4_1-28:1.23.2.2
	binutils-csl-arm-2006q3-27:1.23.2.2
	binutils-csl-sourcerygxx-4_1-27:1.23.2.2
	binutils-csl-arm-2006q3-26:1.23.2.2
	binutils-csl-sourcerygxx-4_1-26:1.23.2.2
	binutils-csl-sourcerygxx-4_1-25:1.23.2.1
	binutils-csl-sourcerygxx-4_1-24:1.23.2.1
	binutils-csl-sourcerygxx-4_1-23:1.23.2.1
	binutils-csl-sourcerygxx-4_1-21:1.23.2.1
	binutils-csl-arm-2006q3-21:1.23.2.1
	binutils-csl-sourcerygxx-4_1-22:1.23.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.23.2.1
	binutils-csl-sourcerygxx-4_1-20:1.23.2.1
	binutils-csl-arm-2006q3-19:1.23.2.1
	binutils-csl-sourcerygxx-4_1-19:1.23.2.1
	binutils-csl-sourcerygxx-4_1-18:1.23.2.1
	binutils-csl-renesas-4_1-9:1.23.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.20.2.1
	binutils-csl-renesas-4_1-8:1.23
	binutils-csl-renesas-4_1-7:1.23
	binutils-csl-renesas-4_1-6:1.23
	binutils-csl-sourcerygxx-4_1-17:1.23
	binutils-csl-sourcerygxx-4_1-14:1.23
	binutils-csl-sourcerygxx-4_1-15:1.23
	binutils-csl-sourcerygxx-4_1-13:1.23
	binutils-2_17:1.24
	binutils-csl-sourcerygxx-4_1-12:1.23
	binutils-csl-sourcerygxx-3_4_4-21:1.23
	binutils-csl-wrs-linux-3_4_4-24:1.20
	binutils-csl-wrs-linux-3_4_4-23:1.20
	binutils-csl-sourcerygxx-4_1-9:1.23
	binutils-csl-sourcerygxx-4_1-8:1.23
	binutils-csl-sourcerygxx-4_1-7:1.23
	binutils-csl-arm-2006q1-6:1.23
	binutils-csl-sourcerygxx-4_1-6:1.23
	binutils-csl-wrs-linux-3_4_4-22:1.20
	binutils-csl-coldfire-4_1-11:1.23
	binutils-csl-sourcerygxx-3_4_4-19:1.23
	binutils-csl-coldfire-4_1-10:1.23
	binutils-csl-sourcerygxx-4_1-5:1.23
	binutils-csl-sourcerygxx-4_1-4:1.23
	binutils-csl-wrs-linux-3_4_4-21:1.20
	binutils-csl-morpho-4_1-4:1.23
	binutils-csl-sourcerygxx-3_4_4-17:1.23
	binutils-csl-wrs-linux-3_4_4-20:1.20
	binutils-2_17-branch:1.24.0.2
	binutils-2_17-branchpoint:1.24
	binutils-csl-2_17-branch:1.23.0.2
	binutils-csl-2_17-branchpoint:1.23
	binutils-csl-gxxpro-3_4-branch:1.20.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.20.2.1
	binutils-2_16_1:1.20.2.1
	binutils-csl-arm-2005q1b:1.20
	binutils-2_16:1.20.2.1
	binutils-csl-arm-2005q1a:1.20
	binutils-csl-arm-2005q1-branch:1.20.0.4
	binutils-csl-arm-2005q1-branchpoint:1.20
	binutils-2_16-branch:1.20.0.2
	binutils-2_16-branchpoint:1.20
	csl-arm-2004-q3d:1.19
	csl-arm-2004-q3:1.19
	gprof-pre-ansify-2004-05-26:1.16
	gprof-post-ansify-2004-05-26:1.17
	binutils-2_15:1.15
	binutils-2_15-branchpoint:1.15
	csl-arm-2004-q1a:1.15
	csl-arm-2004-q1:1.15
	binutils-2_15-branch:1.15.0.6
	cagney_bfdfile-20040213-branch:1.15.0.4
	cagney_bfdfile-20040213-branchpoint:1.15
	cagney_bigcore-20040122-branch:1.15.0.2
	cagney_bigcore-20040122-branchpoint:1.15
	csl-arm-2003-q4:1.15
	binutils-2_14:1.14
	binutils-2_14-branch:1.14.0.2
	binutils-2_14-branchpoint:1.14
	binutils-2_13_2_1:1.11
	binutils-2_13_2:1.11
	binutils-2_13_1:1.11
	binutils-2_13:1.11
	binutils-2_13-branchpoint:1.11
	binutils-2_13-branch:1.11.0.4
	binutils-2_12_1:1.11
	binutils-2_12:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	cygnus_cvs_20020108_pre:1.7
	binutils-2_11_2:1.5.2.2
	binutils-2_11_1:1.5.2.2
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	binutils-2_10_1:1.4
	binutils-2_10:1.4
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.47
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.47
date	2013.10.09.16.34.30;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2013.05.22.13.29.43;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2012.09.20.13.15.48;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2012.03.06.13.54.59;	author gingold;	state Exp;
branches;
next	1.43;

1.43
date	2011.06.07.13.33.20;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2011.02.28.18.36.14;	author ktietz;	state Exp;
branches;
next	1.41;

1.41
date	2011.02.06.23.38.38;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.16.14.52.15;	author nickc;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2010.04.27.14.46.09;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2009.09.11.15.27.34;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.05.07.56.24;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.16.11.49.12;	author nickc;	state Exp;
branches
	1.36.4.1;
next	1.35;

1.35
date	2009.06.15.08.48.49;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.12.15.33.30;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2009.04.09.13.07.34;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.12.12.47.39;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2008.07.30.04.34.57;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.19.16.30.29;	author schwab;	state Exp;
branches;
next	1.29;

1.29
date	2007.07.06.10.40.34;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.05.09.07.30;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2007.04.19.10.46.56;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2007.04.10.07.57.31;	author vprus;	state Exp;
branches;
next	1.25;

1.25
date	2007.01.15.23.26.08;	author bje;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.22.03.51.02;	author bje;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.09.06.55.24;	author nickc;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2005.04.23.17.13.31;	author bje;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.14.10.33.55;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.03.12.05.12;	author amodra;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2004.06.15.01.11.43;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.26.19.40.53;	author cagney;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.26.04.55.55;	author bje;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.26.04.06.26;	author bje;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.11.12.34.31;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2003.02.21.12.42.56;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.24.15.25.03;	author brolley;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.01.08.24.15;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.01.01.18.06;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.31.12.56.07;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.26.17.19.35;	author thorpej;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.14.03.14.56;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.21.07.29;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.24.20.59.03;	author nickc;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.08.06.18.57.53;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.07.11.20.06.45;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.30.22.38.19;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.40.2.1
date	2011.02.06.23.39.54;	author amodra;	state Exp;
branches;
next	;

1.36.4.1
date	2009.09.05.08.00.20;	author nickc;	state Exp;
branches;
next	1.36.4.2;

1.36.4.2
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.23.2.1
date	2006.08.22.15.08.39;	author jsm28;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2006.10.30.19.46.10;	author kazu;	state Exp;
branches;
next	;

1.20.2.1
date	2005.04.14.11.10.34;	author amodra;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.16.27;	author amodra;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.06.11.10.05.03;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches;
next	;


desc
@@


1.47
log
@	PR gprof/16027
	* source.c (annotate_source): Close ifp.
	* corefile.c (read_function_mappings): Close file.
@
text
@/* corefile.c

   Copyright 1999-2013 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "gprof.h"
#include "libiberty.h"
#include "filenames.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "hist.h"
#include "corefile.h"
#include "safe-ctype.h"

bfd *core_bfd;
static int core_num_syms;
static asymbol **core_syms;
asection *core_text_sect;
void * core_text_space;

static int min_insn_size;
int offset_to_code;

/* For mapping symbols to specific .o files during file ordering.  */
struct function_map * symbol_map;
unsigned int symbol_map_count;

static void read_function_mappings (const char *);
static int core_sym_class (asymbol *);
static bfd_boolean get_src_info
  (bfd_vma, const char **, const char **, int *);

extern void i386_find_call  (Sym *, bfd_vma, bfd_vma);
extern void alpha_find_call (Sym *, bfd_vma, bfd_vma);
extern void vax_find_call   (Sym *, bfd_vma, bfd_vma);
extern void tahoe_find_call (Sym *, bfd_vma, bfd_vma);
extern void sparc_find_call (Sym *, bfd_vma, bfd_vma);
extern void mips_find_call  (Sym *, bfd_vma, bfd_vma);
extern void aarch64_find_call (Sym *, bfd_vma, bfd_vma);

static void
parse_error (const char *filename)
{
  fprintf (stderr, _("%s: unable to parse mapping file %s.\n"), whoami, filename);
  done (1);
}

/* Compare two function_map structs based on function name.
   We want to sort in ascending order.  */

static int
cmp_symbol_map (const void * l, const void * r)
{
  return strcmp (((struct function_map *) l)->function_name,
		 ((struct function_map *) r)->function_name);
}

static void
read_function_mappings (const char *filename)
{
  FILE * file = fopen (filename, "r");
  char dummy[1024];
  int count = 0;
  unsigned int i;

  if (!file)
    {
      fprintf (stderr, _("%s: could not open %s.\n"), whoami, filename);
      done (1);
    }

  /* First parse the mapping file so we know how big we need to
     make our tables.  We also do some sanity checks at this
     time.  */
  while (!feof (file))
    {
      int matches;

      matches = fscanf (file, "%[^\n:]", dummy);
      if (!matches)
	parse_error (filename);

      /* Just skip messages about files with no symbols.  */
      if (!strncmp (dummy, "No symbols in ", 14))
	{
	  matches = fscanf (file, "\n");
	  if (matches == EOF)
	    parse_error (filename);
	  continue;
	}

      /* Don't care what else is on this line at this point.  */
      matches = fscanf (file, "%[^\n]\n", dummy);
      if (!matches)
	parse_error (filename);
      count++;
    }

  /* Now we know how big we need to make our table.  */
  symbol_map = ((struct function_map *)
		xmalloc (count * sizeof (struct function_map)));

  /* Rewind the input file so we can read it again.  */
  rewind (file);

  /* Read each entry and put it into the table.  */
  count = 0;
  while (!feof (file))
    {
      int matches;
      char *tmp;

      matches = fscanf (file, "%[^\n:]", dummy);
      if (!matches)
	parse_error (filename);

      /* Just skip messages about files with no symbols.  */
      if (!strncmp (dummy, "No symbols in ", 14))
	{
	  matches = fscanf (file, "\n");
	  if (matches == EOF)
	    parse_error (filename);
	  continue;
	}

      /* dummy has the filename, go ahead and copy it.  */
      symbol_map[count].file_name = (char *) xmalloc (strlen (dummy) + 1);
      strcpy (symbol_map[count].file_name, dummy);

      /* Now we need the function name.  */
      matches = fscanf (file, "%[^\n]\n", dummy);
      if (!matches)
	parse_error (filename);
      tmp = strrchr (dummy, ' ') + 1;
      symbol_map[count].function_name = (char *) xmalloc (strlen (tmp) + 1);
      strcpy (symbol_map[count].function_name, tmp);
      count++;
    }

  /* Record the size of the map table for future reference.  */
  symbol_map_count = count;

  for (i = 0; i < symbol_map_count; ++i)
    if (i == 0
        || filename_cmp (symbol_map[i].file_name, symbol_map[i - 1].file_name))
      symbol_map[i].is_first = 1;

  qsort (symbol_map, symbol_map_count, sizeof (struct function_map), cmp_symbol_map);

  fclose (file);
}

void
core_init (const char * aout_name)
{
  int core_sym_bytes;
  asymbol *synthsyms;
  long synth_count;

  core_bfd = bfd_openr (aout_name, 0);

  if (!core_bfd)
    {
      perror (aout_name);
      done (1);
    }

  if (!bfd_check_format (core_bfd, bfd_object))
    {
      fprintf (stderr, _("%s: %s: not in executable format\n"), whoami, aout_name);
      done (1);
    }

  /* Get core's text section.  */
  core_text_sect = bfd_get_section_by_name (core_bfd, ".text");
  if (!core_text_sect)
    {
      core_text_sect = bfd_get_section_by_name (core_bfd, "$CODE$");
      if (!core_text_sect)
	{
	  fprintf (stderr, _("%s: can't find .text section in %s\n"),
		   whoami, aout_name);
	  done (1);
	}
    }

  /* Read core's symbol table.  */

  /* This will probably give us more than we need, but that's ok.  */
  core_sym_bytes = bfd_get_symtab_upper_bound (core_bfd);
  if (core_sym_bytes < 0)
    {
      fprintf (stderr, "%s: %s: %s\n", whoami, aout_name,
	       bfd_errmsg (bfd_get_error ()));
      done (1);
    }

  core_syms = (asymbol **) xmalloc (core_sym_bytes);
  core_num_syms = bfd_canonicalize_symtab (core_bfd, core_syms);

  if (core_num_syms < 0)
    {
      fprintf (stderr, "%s: %s: %s\n", whoami, aout_name,
	       bfd_errmsg (bfd_get_error ()));
      done (1);
    }

  synth_count = bfd_get_synthetic_symtab (core_bfd, core_num_syms, core_syms,
					  0, NULL, &synthsyms);
  if (synth_count > 0)
    {
      asymbol **symp;
      long new_size;
      long i;

      new_size = (core_num_syms + synth_count + 1) * sizeof (*core_syms);
      core_syms = (asymbol **) xrealloc (core_syms, new_size);
      symp = core_syms + core_num_syms;
      core_num_syms += synth_count;
      for (i = 0; i < synth_count; i++)
	*symp++ = synthsyms + i;
      *symp = 0;
    }

  min_insn_size = 1;
  offset_to_code = 0;

  switch (bfd_get_arch (core_bfd))
    {
    case bfd_arch_vax:
    case bfd_arch_tahoe:
      offset_to_code = 2;
      break;

    case bfd_arch_alpha:
      min_insn_size = 4;
      break;

    default:
      break;
    }

  if (function_mapping_file)
    read_function_mappings (function_mapping_file);
}

/* Read in the text space of an a.out file.  */

void
core_get_text_space (bfd *cbfd)
{
  core_text_space = malloc (bfd_get_section_size (core_text_sect));

  if (!core_text_space)
    {
      fprintf (stderr, _("%s: ran out room for %lu bytes of text space\n"),
	       whoami, (unsigned long) bfd_get_section_size (core_text_sect));
      done (1);
    }

  if (!bfd_get_section_contents (cbfd, core_text_sect, core_text_space,
				 0, bfd_get_section_size (core_text_sect)))
    {
      bfd_perror ("bfd_get_section_contents");
      free (core_text_space);
      core_text_space = 0;
    }

  if (!core_text_space)
    fprintf (stderr, _("%s: can't do -c\n"), whoami);
}


void
find_call (Sym *parent, bfd_vma p_lowpc, bfd_vma p_highpc)
{
  if (core_text_space == 0)
    return;

  hist_clip_symbol_address (&p_lowpc, &p_highpc);

  switch (bfd_get_arch (core_bfd))
    {
    case bfd_arch_i386:
      i386_find_call (parent, p_lowpc, p_highpc);
      break;

    case bfd_arch_alpha:
      alpha_find_call (parent, p_lowpc, p_highpc);
      break;

    case bfd_arch_vax:
      vax_find_call (parent, p_lowpc, p_highpc);
      break;

    case bfd_arch_sparc:
      sparc_find_call (parent, p_lowpc, p_highpc);
      break;

    case bfd_arch_tahoe:
      tahoe_find_call (parent, p_lowpc, p_highpc);
      break;

    case bfd_arch_mips:
      mips_find_call (parent, p_lowpc, p_highpc);
      break;

    case bfd_arch_aarch64:
      aarch64_find_call (parent, p_lowpc, p_highpc);
      break;

    default:
      fprintf (stderr, _("%s: -c not supported on architecture %s\n"),
	       whoami, bfd_printable_name(core_bfd));

      /* Don't give the error more than once.  */
      ignore_direct_calls = FALSE;
    }
}

/* Return class of symbol SYM.  The returned class can be any of:
	0   -> symbol is not interesting to us
	'T' -> symbol is a global name
	't' -> symbol is a local (static) name.  */

static int
core_sym_class (asymbol *sym)
{
  symbol_info syminfo;
  const char *name;
  char sym_prefix;
  int i;

  if (sym->section == NULL || (sym->flags & BSF_DEBUGGING) != 0)
    return 0;

  /* Must be a text symbol, and static text symbols
     don't qualify if ignore_static_funcs set.   */
  if (ignore_static_funcs && (sym->flags & BSF_LOCAL))
    {
      DBG (AOUTDEBUG, printf ("[core_sym_class] %s: not a function\n",
			      sym->name));
      return 0;
    }

  bfd_get_symbol_info (core_bfd, sym, &syminfo);
  i = syminfo.type;

  if (i == 'T')
    return i;			/* It's a global symbol.  */

  if (i == 'W')
    /* Treat weak symbols as text symbols.  FIXME: a weak symbol may
       also be a data symbol.  */
    return 'T';

  if (i != 't')
    {
      /* Not a static text symbol.  */
      DBG (AOUTDEBUG, printf ("[core_sym_class] %s is of class %c\n",
			      sym->name, i));
      return 0;
    }

  /* Do some more filtering on static function-names.  */
  if (ignore_static_funcs)
    return 0;

  /* Can't zero-length name or funny characters in name, where
     `funny' includes: `.' (.o file names) and `$' (Pascal labels).  */
  if (!sym->name || sym->name[0] == '\0')
    return 0;

  for (name = sym->name; *name; ++name)
    {
      if (*name == '$')
        return 0;

      while (*name == '.')
	{
	  /* Allow both nested subprograms (which end with ".NNN", where N is
	     a digit) and GCC cloned functions (which contain ".clone").
	     Allow for multiple iterations of both - apparently GCC can clone
	     clones and subprograms.  */
	  int digit_seen = 0;
#define CLONE_NAME	    ".clone."
#define CLONE_NAME_LEN	    strlen (CLONE_NAME)
#define CONSTPROP_NAME	    ".constprop."
#define CONSTPROP_NAME_LEN  strlen (CONSTPROP_NAME)

	  if (strlen (name) > CLONE_NAME_LEN
	      && strncmp (name, CLONE_NAME, CLONE_NAME_LEN) == 0)
	    name += CLONE_NAME_LEN - 1;

	  else if (strlen (name) > CONSTPROP_NAME_LEN
	      && strncmp (name, CONSTPROP_NAME, CONSTPROP_NAME_LEN) == 0)
	    name += CONSTPROP_NAME_LEN - 1;

	  for (name++; *name; name++)
	    if (digit_seen && *name == '.')
	      break;
	    else if (ISDIGIT (*name))
	      digit_seen = 1;
	    else
	      return 0;
	}
    }

  /* On systems where the C compiler adds an underscore to all
     names, static names without underscores seem usually to be
     labels in hand written assembler in the library.  We don't want
     these names.  This is certainly necessary on a Sparc running
     SunOS 4.1 (try profiling a program that does a lot of
     division). I don't know whether it has harmful side effects on
     other systems.  Perhaps it should be made configurable.  */
  sym_prefix = bfd_get_symbol_leading_char (core_bfd);

  if ((sym_prefix && sym_prefix != sym->name[0])
      /* GCC may add special symbols to help gdb figure out the file
	language.  We want to ignore these, since sometimes they mask
	the real function.  (dj@@ctron)  */
      || !strncmp (sym->name, "__gnu_compiled", 14)
      || !strncmp (sym->name, "___gnu_compiled", 15))
    {
      return 0;
    }

  /* If the object file supports marking of function symbols, then
     we can zap anything that doesn't have BSF_FUNCTION set.  */
  if (ignore_non_functions && (sym->flags & BSF_FUNCTION) == 0)
    return 0;

  return 't';			/* It's a static text symbol.  */
}

/* Get whatever source info we can get regarding address ADDR.  */

static bfd_boolean
get_src_info (bfd_vma addr, const char **filename, const char **name, int *line_num)
{
  const char *fname = 0, *func_name = 0;
  int l = 0;

  if (bfd_find_nearest_line (core_bfd, core_text_sect, core_syms,
			     addr - core_text_sect->vma,
			     &fname, &func_name, (unsigned int *) &l)
      && fname && func_name && l)
    {
      DBG (AOUTDEBUG, printf ("[get_src_info] 0x%lx -> %s:%d (%s)\n",
			      (unsigned long) addr, fname, l, func_name));
      *filename = fname;
      *name = func_name;
      *line_num = l;
      return TRUE;
    }
  else
    {
      DBG (AOUTDEBUG, printf ("[get_src_info] no info for 0x%lx (%s:%d,%s)\n",
			      (unsigned long) addr,
			      fname ? fname : "<unknown>", l,
			      func_name ? func_name : "<unknown>"));
      return FALSE;
    }
}

/* Return number of symbols in a symbol-table file.  */

static int
num_of_syms_in (FILE * f)
{
  const int BUFSIZE = 1024;
  char * buf = (char *) xmalloc (BUFSIZE);
  char * address = (char *) xmalloc (BUFSIZE);
  char   type;
  char * name = (char *) xmalloc (BUFSIZE);
  int num = 0;

  while (!feof (f) && fgets (buf, BUFSIZE - 1, f))
    {
      if (sscanf (buf, "%s %c %s", address, &type, name) == 3)
        if (type == 't' || type == 'T')
          ++num;
    }

  free (buf);
  free (address);
  free (name);

  return num;
}

/* Read symbol table from a file.  */

void
core_create_syms_from (const char * sym_table_file)
{
  const int BUFSIZE = 1024;
  char * buf = (char *) xmalloc (BUFSIZE);
  char * address = (char *) xmalloc (BUFSIZE);
  char type;
  char * name = (char *) xmalloc (BUFSIZE);
  bfd_vma min_vma = ~(bfd_vma) 0;
  bfd_vma max_vma = 0;
  FILE * f;

  f = fopen (sym_table_file, "r");
  if (!f)
    {
      fprintf (stderr, _("%s: could not open %s.\n"), whoami, sym_table_file);
      done (1);
    }

  /* Pass 1 - determine upper bound on number of function names.  */
  symtab.len = num_of_syms_in (f);

  if (symtab.len == 0)
    {
      fprintf (stderr, _("%s: file `%s' has no symbols\n"), whoami, sym_table_file);
      done (1);
    }

  symtab.base = (Sym *) xmalloc (symtab.len * sizeof (Sym));

  /* Pass 2 - create symbols.  */
  symtab.limit = symtab.base;

  if (fseek (f, 0, SEEK_SET) != 0)
    {
      perror (sym_table_file);
      done (1);
    }

  while (!feof (f) && fgets (buf, BUFSIZE - 1, f))
    {
      if (sscanf (buf, "%s %c %s", address, &type, name) == 3)
        if (type != 't' && type != 'T')
          continue;

      sym_init (symtab.limit);

      sscanf (address, "%" BFD_VMA_FMT "x", &(symtab.limit->addr) );

      symtab.limit->name = (char *) xmalloc (strlen (name) + 1);
      strcpy ((char *) symtab.limit->name, name);
      symtab.limit->mapped = 0;
      symtab.limit->is_func = TRUE;
      symtab.limit->is_bb_head = TRUE;
      symtab.limit->is_static = (type == 't');
      min_vma = MIN (symtab.limit->addr, min_vma);
      max_vma = MAX (symtab.limit->addr, max_vma);

      ++symtab.limit;
    }
  fclose (f);

  symtab.len = symtab.limit - symtab.base;
  symtab_finalize (&symtab);

  free (buf);
  free (address);
  free (name);
}

static int
search_mapped_symbol (const void * l, const void * r)
{
    return strcmp ((const char *) l, ((const struct function_map *) r)->function_name);
}

/* Read in symbol table from core.
   One symbol per function is entered.  */

void
core_create_function_syms (void)
{
  bfd_vma min_vma = ~ (bfd_vma) 0;
  bfd_vma max_vma = 0;
  int cxxclass;
  long i;
  struct function_map * found = NULL;
  int core_has_func_syms = 0;

  switch (core_bfd->xvec->flavour)
    {
    default:
      break;
    case bfd_target_coff_flavour:
    case bfd_target_ecoff_flavour:
    case bfd_target_xcoff_flavour:
    case bfd_target_elf_flavour:
    case bfd_target_nlm_flavour:
    case bfd_target_som_flavour:
      core_has_func_syms = 1;
    }

  /* Pass 1 - determine upper bound on number of function names.  */
  symtab.len = 0;

  for (i = 0; i < core_num_syms; ++i)
    {
      if (!core_sym_class (core_syms[i]))
	continue;

      /* Don't create a symtab entry for a function that has
	 a mapping to a file, unless it's the first function
	 in the file.  */
      if (symbol_map_count != 0)
	{
	  /* Note: some systems (SunOS 5.8) crash if bsearch base argument
	     is NULL.  */
	  found = (struct function_map *) bsearch
	    (core_syms[i]->name, symbol_map, symbol_map_count,
	     sizeof (struct function_map), search_mapped_symbol);
	}
      if (found == NULL || found->is_first)
	++symtab.len;
    }

  if (symtab.len == 0)
    {
      fprintf (stderr, _("%s: file `%s' has no symbols\n"), whoami, a_out_name);
      done (1);
    }

  symtab.base = (Sym *) xmalloc (symtab.len * sizeof (Sym));

  /* Pass 2 - create symbols.  */
  symtab.limit = symtab.base;

  for (i = 0; i < core_num_syms; ++i)
    {
      asection *sym_sec;

      cxxclass = core_sym_class (core_syms[i]);

      if (!cxxclass)
	{
	  DBG (AOUTDEBUG,
	       printf ("[core_create_function_syms] rejecting: 0x%lx %s\n",
		       (unsigned long) core_syms[i]->value,
		       core_syms[i]->name));
	  continue;
	}

      if (symbol_map_count != 0)
	{
	  /* Note: some systems (SunOS 5.8) crash if bsearch base argument
	     is NULL.  */
	  found = (struct function_map *) bsearch
	    (core_syms[i]->name, symbol_map, symbol_map_count,
	     sizeof (struct function_map), search_mapped_symbol);
	}
      if (found && ! found->is_first)
	continue;

      sym_init (symtab.limit);

      /* Symbol offsets are always section-relative.  */
      sym_sec = core_syms[i]->section;
      symtab.limit->addr = core_syms[i]->value;
      if (sym_sec)
	symtab.limit->addr += bfd_get_section_vma (sym_sec->owner, sym_sec);

      if (found)
	{
	  symtab.limit->name = found->file_name;
	  symtab.limit->mapped = 1;
	}
      else
	{
	  symtab.limit->name = core_syms[i]->name;
	  symtab.limit->mapped = 0;
	}

      /* Lookup filename and line number, if we can.  */
      {
	const char * filename;
	const char * func_name;

	if (get_src_info (symtab.limit->addr, & filename, & func_name,
			  & symtab.limit->line_num))
	  {
	    symtab.limit->file = source_file_lookup_path (filename);

	    /* FIXME: Checking __osf__ here does not work with a cross
	       gprof.  */
#ifdef __osf__
	    /* Suppress symbols that are not function names.  This is
	       useful to suppress code-labels and aliases.

	       This is known to be useful under DEC's OSF/1.  Under SunOS 4.x,
	       labels do not appear in the symbol table info, so this isn't
	       necessary.  */

	    if (strcmp (symtab.limit->name, func_name) != 0)
	      {
		/* The symbol's address maps to a different name, so
		   it can't be a function-entry point.  This happens
		   for labels, for example.  */
		DBG (AOUTDEBUG,
		     printf ("[core_create_function_syms: rej %s (maps to %s)\n",
			     symtab.limit->name, func_name));
		continue;
	      }
#endif
	  }
      }

      symtab.limit->is_func = (!core_has_func_syms
			       || (core_syms[i]->flags & BSF_FUNCTION) != 0);
      symtab.limit->is_bb_head = TRUE;

      if (cxxclass == 't')
	symtab.limit->is_static = TRUE;

      /* Keep track of the minimum and maximum vma addresses used by all
	 symbols.  When computing the max_vma, use the ending address of the
	 section containing the symbol, if available.  */
      min_vma = MIN (symtab.limit->addr, min_vma);
      if (sym_sec)
	max_vma = MAX (bfd_get_section_vma (sym_sec->owner, sym_sec)
		       + bfd_section_size (sym_sec->owner, sym_sec) - 1,
		       max_vma);
      else
	max_vma = MAX (symtab.limit->addr, max_vma);

      DBG (AOUTDEBUG, printf ("[core_create_function_syms] %ld %s 0x%lx\n",
			      (long) (symtab.limit - symtab.base),
			      symtab.limit->name,
			      (unsigned long) symtab.limit->addr));
      ++symtab.limit;
    }

  symtab.len = symtab.limit - symtab.base;
  symtab_finalize (&symtab);
}

/* Read in symbol table from core.
   One symbol per line of source code is entered.  */

void
core_create_line_syms (void)
{
  char *prev_name, *prev_filename;
  unsigned int prev_name_len, prev_filename_len;
  bfd_vma vma, min_vma = ~(bfd_vma) 0, max_vma = 0;
  Sym *prev, dummy, *sym;
  const char *filename;
  int prev_line_num;
  Sym_Table ltab;
  bfd_vma vma_high;

  /* Create symbols for functions as usual.  This is necessary in
     cases where parts of a program were not compiled with -g.  For
     those parts we still want to get info at the function level.  */
  core_create_function_syms ();

  /* Pass 1: count the number of symbols.  */

  /* To find all line information, walk through all possible
     text-space addresses (one by one!) and get the debugging
     info for each address.  When the debugging info changes,
     it is time to create a new symbol.

     Of course, this is rather slow and it would be better if
     BFD would provide an iterator for enumerating all line infos.  */
  prev_name_len = PATH_MAX;
  prev_filename_len = PATH_MAX;
  prev_name = (char *) xmalloc (prev_name_len);
  prev_filename = (char *) xmalloc (prev_filename_len);
  ltab.len = 0;
  prev_line_num = 0;

  vma_high = core_text_sect->vma + bfd_get_section_size (core_text_sect);
  for (vma = core_text_sect->vma; vma < vma_high; vma += min_insn_size)
    {
      unsigned int len;

      if (!get_src_info (vma, &filename, &dummy.name, &dummy.line_num)
	  || (prev_line_num == dummy.line_num
	      && prev_name != NULL
	      && strcmp (prev_name, dummy.name) == 0
	      && filename_cmp (prev_filename, filename) == 0))
	continue;

      ++ltab.len;
      prev_line_num = dummy.line_num;

      len = strlen (dummy.name);
      if (len >= prev_name_len)
	{
	  prev_name_len = len + 1024;
	  free (prev_name);
	  prev_name = (char *) xmalloc (prev_name_len);
	}

      strcpy (prev_name, dummy.name);
      len = strlen (filename);

      if (len >= prev_filename_len)
	{
	  prev_filename_len = len + 1024;
	  free (prev_filename);
	  prev_filename = (char *) xmalloc (prev_filename_len);
	}

      strcpy (prev_filename, filename);

      min_vma = MIN (vma, min_vma);
      max_vma = MAX (vma, max_vma);
    }

  free (prev_name);
  free (prev_filename);

  /* Make room for function symbols, too.  */
  ltab.len += symtab.len;
  ltab.base = (Sym *) xmalloc (ltab.len * sizeof (Sym));
  ltab.limit = ltab.base;

  /* Pass 2 - create symbols.  */

  /* We now set is_static as we go along, rather than by running
     through the symbol table at the end.

     The old way called symtab_finalize before the is_static pass,
     causing a problem since symtab_finalize uses is_static as part of
     its address conflict resolution algorithm.  Since global symbols
     were prefered over static symbols, and all line symbols were
     global at that point, static function names that conflicted with
     their own line numbers (static, but labeled as global) were
     rejected in favor of the line num.

     This was not the desired functionality.  We always want to keep
     our function symbols and discard any conflicting line symbols.
     Perhaps symtab_finalize should be modified to make this
     distinction as well, but the current fix works and the code is a
     lot cleaner now.  */
  prev = 0;

  for (vma = core_text_sect->vma; vma < vma_high; vma += min_insn_size)
    {
      sym_init (ltab.limit);

      if (!get_src_info (vma, &filename, &ltab.limit->name, &ltab.limit->line_num)
	  || (prev && prev->line_num == ltab.limit->line_num
	      && strcmp (prev->name, ltab.limit->name) == 0
	      && filename_cmp (prev->file->name, filename) == 0))
	continue;

      /* Make name pointer a malloc'ed string.  */
      ltab.limit->name = xstrdup (ltab.limit->name);
      ltab.limit->file = source_file_lookup_path (filename);

      ltab.limit->addr = vma;

      /* Set is_static based on the enclosing function, using either:
	 1) the previous symbol, if it's from the same function, or
	 2) a symtab lookup.  */
      if (prev && ltab.limit->file == prev->file &&
	  strcmp (ltab.limit->name, prev->name) == 0)
	{
	  ltab.limit->is_static = prev->is_static;
	}
      else
	{
	  sym = sym_lookup(&symtab, ltab.limit->addr);
          if (sym)
	    ltab.limit->is_static = sym->is_static;
	}

      prev = ltab.limit;

      DBG (AOUTDEBUG, printf ("[core_create_line_syms] %lu %s 0x%lx\n",
			      (unsigned long) (ltab.limit - ltab.base),
			      ltab.limit->name,
			      (unsigned long) ltab.limit->addr));
      ++ltab.limit;
    }

  /* Copy in function symbols.  */
  memcpy (ltab.limit, symtab.base, symtab.len * sizeof (Sym));
  ltab.limit += symtab.len;

  if ((unsigned int) (ltab.limit - ltab.base) != ltab.len)
    {
      fprintf (stderr,
	       _("%s: somebody miscounted: ltab.len=%d instead of %ld\n"),
	       whoami, ltab.len, (long) (ltab.limit - ltab.base));
      done (1);
    }

  /* Finalize ltab and make it symbol table.  */
  symtab_finalize (&ltab);
  free (symtab.base);
  symtab = ltab;
}
@


1.46
log
@	* aarch64.c: New file.
	* corefile.c (find_call): Call aarch64_find_call for bfd_arch_aarch64.
	* Makefile.am (sources): Add aarch64.c.
	* Makefile.in: Regenerate.
@
text
@d3 1
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009,
   2010, 2011, 2012  Free Software Foundation, Inc.
d166 2
@


1.45
log
@	* corefile.c (core_sym_class): Allow for ".constprop.N" cloned
	functions.
@
text
@d57 1
d324 4
@


1.44
log
@2012-03-06  Tristan Gingold  <gingold@@adacore.com>

	* corefile.c (core_create_function_syms): Do not call bsearch if
	symbol_map_count is 0.
@
text
@d4 1
a4 1
   2010, 2011  Free Software Foundation, Inc.
d71 1
a71 1
  return strcmp (((struct function_map *) l)->function_name, 
d397 5
a401 3
#define CLONE_NAME      ".clone."
#define CLONE_NAME_LEN  strlen (CLONE_NAME)
	      
d406 4
d479 1
a479 1
static int 
d488 1
a488 1
  
@


1.43
log
@	* corefile.c (core_sym_class): Allow for multiple iterations of
	clone clones and subprograms.
@
text
@d585 1
a585 1
  struct function_map * found;
d612 8
a619 4
      found = (struct function_map *) bsearch (core_syms[i]->name, symbol_map,
                                               symbol_map_count,
                                               sizeof (struct function_map),
                                               search_mapped_symbol);
d650 8
a657 3
      found = (struct function_map *) bsearch (core_syms[i]->name, symbol_map,
                                               symbol_map_count,
		       sizeof (struct function_map), search_mapped_symbol);
@


1.42
log
@2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* basic_blocks.c (cmp_bb): Use filename_(n)cmp.
	* cg_print.c (order_and_dump_functions_by_arcs): Likewise.
	(cg_print_file_ordering): Likewise.
	* corefile.c (read_function_mappings): Likewise.
	(core_create_line_syms): Likewise.
@
text
@d390 1
a390 1
      if (*name == '.')
d392 11
a402 3
	  /* Allow GCC cloned functions.  */
	  if (strlen (name) > 7 && strncmp (name, ".clone.", 7) == 0)
	    name += 6;
a403 2
	  /* Do not discard nested subprograms (those
	     which end with .NNN, where N are digits).  */
d405 5
a409 1
	    if (! ISDIGIT (*name))
a410 2

	  break;
@


1.41
log
@	PR gprof/12468
	* corefile.c (core_create_function_syms): Set is_func for targets
	that have no BSF_FUNCTION syms.
@
text
@d25 1
d161 2
a162 1
    if (i == 0 || strcmp (symbol_map[i].file_name, symbol_map[i - 1].file_name))
d771 1
a771 1
	      && strcmp (prev_filename, filename) == 0))
d836 1
a836 1
	      && strcmp (prev->file->name, filename) == 0))
@


1.40
log
@        * corefile.c (core_sym_class): Fix handling of subprogram names
        and add support for cloned function names.
@
text
@d4 1
a4 1
   2010  Free Software Foundation, Inc.
d576 14
d695 2
a696 1
      symtab.limit->is_func = (core_syms[i]->flags & BSF_FUNCTION) != 0; 
@


1.40.2.1
log
@	PR gprof/12468
	* corefile.c (core_create_function_syms): Set is_func for targets
	that have no BSF_FUNCTION syms.
@
text
@d4 1
a4 1
   2010, 2011  Free Software Foundation, Inc.
a575 14
  int core_has_func_syms = 0;

  switch (core_bfd->xvec->flavour)
    {
    default:
      break;
    case bfd_target_coff_flavour:
    case bfd_target_ecoff_flavour:
    case bfd_target_xcoff_flavour:
    case bfd_target_elf_flavour:
    case bfd_target_nlm_flavour:
    case bfd_target_som_flavour:
      core_has_func_syms = 1;
    }
d681 1
a681 2
      symtab.limit->is_func = (!core_has_func_syms
			       || (core_syms[i]->flags & BSF_FUNCTION) != 0);
@


1.39
log
@        PR gprof/11524
        * corefile.c (core_create_syms_from): Use correct size of buffer.
@
text
@a387 2
      /* Do not discard nested subprograms (those
	 which end with .NNN, where N are digits).  */
d389 13
a401 3
	for (name++; *name; name++)
	  if (! ISDIGIT (*name))
	    return 0;
@


1.38
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d3 2
a4 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
   Free Software Foundation, Inc.
d520 1
a520 1
  while (!feof (f) && fgets (buf, sizeof (buf), f))
@


1.37
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d143 1
a143 1
      symbol_map[count].file_name = xmalloc (strlen (dummy) + 1);
d151 1
a151 1
      symbol_map[count].function_name = xmalloc (strlen (tmp) + 1);
d230 1
a230 1
      core_syms = xrealloc (core_syms, new_size);
d580 4
a583 2
      found = bsearch (core_syms[i]->name, symbol_map, symbol_map_count,
		       sizeof (struct function_map), search_mapped_symbol);
d614 2
a615 1
      found = bsearch (core_syms[i]->name, symbol_map, symbol_map_count,
d732 2
a733 2
  prev_name = xmalloc (prev_name_len);
  prev_filename = xmalloc (prev_filename_len);
d757 1
a757 1
	  prev_name = xmalloc (prev_name_len);
d767 1
a767 1
	  prev_filename = xmalloc (prev_filename_len);
@


1.36
log
@        * corefile.c (cmp_symbol_map): New function.
        (read_function_mappins): Use qsort to sort the symbols.
        (search_mapped_symbol): New function.
        (core_create_function_syms): Use bsearch to find symbols.
        * corefile.h (struct function_map): Add new bit-field: is_first.
        * cg_print.c (cmp_symbol_map): New function.
        (cg_print_file_ordering): Sort the symbol map.
@
text
@d565 1
a565 1
  int class;
d601 1
a601 1
      class = core_sym_class (core_syms[i]);
d603 1
a603 1
      if (!class)
d673 1
a673 1
      if (class == 't')
@


1.36.4.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d565 1
a565 1
  int cxxclass;
d601 1
a601 1
      cxxclass = core_sym_class (core_syms[i]);
d603 1
a603 1
      if (!cxxclass)
d673 1
a673 1
      if (cxxclass == 't')
@


1.36.4.2
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d143 1
a143 1
      symbol_map[count].file_name = (char *) xmalloc (strlen (dummy) + 1);
d151 1
a151 1
      symbol_map[count].function_name = (char *) xmalloc (strlen (tmp) + 1);
d230 1
a230 1
      core_syms = (asymbol **) xrealloc (core_syms, new_size);
d580 2
a581 4
      found = (struct function_map *) bsearch (core_syms[i]->name, symbol_map,
                                               symbol_map_count,
                                               sizeof (struct function_map),
                                               search_mapped_symbol);
d612 1
a612 2
      found = (struct function_map *) bsearch (core_syms[i]->name, symbol_map,
                                               symbol_map_count,
d729 2
a730 2
  prev_name = (char *) xmalloc (prev_name_len);
  prev_filename = (char *) xmalloc (prev_filename_len);
d754 1
a754 1
	  prev_name = (char *) xmalloc (prev_name_len);
d764 1
a764 1
	  prev_filename = (char *) xmalloc (prev_filename_len);
@


1.35
log
@        * corefile.c (core_create_syms_from): Use BFD_VMA_FMT when
        scanning in an address.
@
text
@d64 10
d77 1
a77 1
  FILE *file = fopen (filename, "r");
d80 1
d158 6
a165 1

d167 1
a167 1
core_init (const char *aout_name)
d551 6
d561 1
a561 1
core_create_function_syms ()
d563 1
a563 1
  bfd_vma min_vma = ~(bfd_vma) 0;
d566 2
a567 2
  long i, found, skip;
  unsigned int j;
d577 1
a577 4
      /* This should be replaced with a binary search or hashed
	 search.  Gross.

	 Don't create a symtab entry for a function that has
d580 3
a582 11
      skip = 0;
      for (j = 0; j < symbol_map_count; j++)
	if (!strcmp (core_syms[i]->name, symbol_map[j].function_name))
	  {
	    if (j > 0 && ! strcmp (symbol_map [j].file_name,
				   symbol_map [j - 1].file_name))
	      skip = 1;
	    break;
	  }

      if (!skip)
d612 3
a614 17
      /* This should be replaced with a binary search or hashed
	 search.  Gross.   */
      skip = 0;
      found = 0;

      for (j = 0; j < symbol_map_count; j++)
	if (!strcmp (core_syms[i]->name, symbol_map[j].function_name))
	  {
	    if (j > 0 && ! strcmp (symbol_map [j].file_name,
				   symbol_map [j - 1].file_name))
	      skip = 1;
	    else
	      found = j;
	    break;
	  }

      if (skip)
d625 1
a625 2
      if (symbol_map_count
	  && !strcmp (core_syms[i]->name, symbol_map[found].function_name))
d627 1
a627 1
	  symtab.limit->name = symbol_map[found].file_name;
d638 2
a639 1
	const char *filename, *func_name;
d641 2
a642 2
	if (get_src_info (symtab.limit->addr, &filename, &func_name,
			  &symtab.limit->line_num))
d702 1
a702 1
core_create_line_syms ()
@


1.34
log
@        * corefile.c (num_of_syms_in): New function - computes the number
        of symbols in a given file.
        (core_create_syms_from): New function - populates a symbol table
        from the symbols found in a specified file.
        * corefile.h: Prototype core_create_syms_from.
        * gprof.c (long_options): Add --external-symbol-table.
        (usage): Mention it.
        (main): Initiailize external_symbol_table from
        --external-symbol-table option.  If set use it.
        * gprof.texi: Document the new option.

        * NEWS: Mention new feature added to gprof.
@
text
@d512 1
a512 1
      sscanf (address, "%lx", &(symtab.limit->addr) );
@


1.33
log
@        * corefile.c (core_create_function_syms): Initialise a symbol's
        is_func field based on the setting of the BSF_FUNCTION flag.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
d36 1
a36 1
PTR core_text_space;
d42 1
a42 1
struct function_map *symbol_map;
d437 98
@


1.32
log
@        * corefile.c (core_create_function_syms): Remove "<locore>" and
        "<hicore>" sentinels.
        * gprof.c: Likewise.
        * cg_print.c (cg_print_function_ordering): Likewise.
        * alpha.c (alpha_find_call): Add check for return value of sym_lookup.
        * mips.c (mips_find_call): Likewise.
        * sparc.c (sparc_find_call): Likewise.
        * tahoe.c (tahoe_find_call): Likewise.
        * vax.c (vax_find_call): Likewise.
@
text
@d575 1
a575 1
      symtab.limit->is_func = TRUE;
@


1.31
log
@Silence gcc printf warnings
@
text
@d483 1
a483 2
  /* The "+ 2" is for the sentinels.  */
  symtab.base = (Sym *) xmalloc ((symtab.len + 2) * sizeof (Sym));
a598 13
  /* Create sentinels.  */
  sym_init (symtab.limit);
  symtab.limit->name = "<locore>";
  symtab.limit->addr = 0;
  symtab.limit->end_addr = min_vma - 1;
  ++symtab.limit;

  sym_init (symtab.limit);
  symtab.limit->name = "<hicore>";
  symtab.limit->addr = max_vma + 1;
  symtab.limit->end_addr = ~(bfd_vma) 0;
  ++symtab.limit;

d612 1
a612 1
  Sym *prev, dummy, *sentinel, *sym;
d733 2
a734 1
	  ltab.limit->is_static = sym->is_static;
a745 15
  /* Update sentinels.  */
  sentinel = sym_lookup (&symtab, (bfd_vma) 0);

  if (sentinel
      && strcmp (sentinel->name, "<locore>") == 0
      && min_vma <= sentinel->end_addr)
    sentinel->end_addr = min_vma - 1;

  sentinel = sym_lookup (&symtab, ~(bfd_vma) 0);

  if (sentinel
      && strcmp (sentinel->name, "<hicore>") == 0
      && max_vma >= sentinel->addr)
    sentinel->addr = max_vma + 1;

@


1.30
log
@* basic_blocks.c: Always include "gprof.h" first.
* cg_arcs.c: Likewise.
* cg_dfn.c: Likewise.
* cg_print.c: Likewise.
* corefile.c: Likewise.
* gprof.c: Likewise.
* hist.c: Likewise.
* search_list.c: Likewise.
* sym_ids.c: Likewise.
* utils.c: Likewise.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
d430 2
a431 1
			      (long) addr, fname ? fname : "<unknown>", l,
@


1.29
log
@CHange FSF sources over to GPLv3
@
text
@d23 1
a24 1
#include "gprof.h"
@


1.28
log
@* corefile.c (core_sym_class): Do not discard nested subprograms.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.27
log
@	* corefile.c (core_create_function_syms, core_create_line_syms): Don't
	set discard_underscores.
	* gprof.c (discard_underscores): Delete.
	* gprof.h (discard_underscores): Delete.
	* sym_ids.c (match): Use bfd_get_symbol_leading_char to check for
	leading underscores.
	* utils.c (print_name_only): Call bfd_demangle rather than
	cplus_demangle.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
d30 1
d369 9
a377 2
      if (*name == '.' || *name == '$')
	return 0;
@


1.26
log
@	* hist.h (struct histogram)
	(histograms, num_histograms): New.
	* hist.c (find_histogram, find_histogram_for_pc)
	(read_histogram_header): New.
	(s_lowpc, s_highpc, lowpc, highpc, hist_num_bins)
	(hist_sample): Remove.
	(hist_read_rec): Use the above, and handle multiple
	histogram records with disjoint address ranges.
	(hist_write_hist): Support several histogram records.
	(scale_and_align_entries): Adjust for multiple histograms.
	(hist_assign_samples_1): New.
	(hist_assign_samples): Use the above.
	(hist_clip_symbol_address): New.
	* hist.h (hist_check_address)
	(hist_clip_symbol_address): Declare.
	* gmon_io.c (gmon_out_read, gmon_out_write): Adjust handling
	of legacy format for multiple histogram changes.
	* corefile.c (find_call): Check for core_text_space and
	clip symbol address range here.
	* vax.c	(vax_find_call): Don't check for
	core_text_space, or clip the symbol's address range here.
	Use hist_check_address to check call's target address.
	* sparc.c: Likewise.
	* tahoe.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise. Also use core_text_sect->vma as the base
	address for code accesses, just like other machine-specific
	routines do.
	* gprof.texi: Adjust for the new logic.
@
text
@a583 6
      /* If we see "main" without an initial '_', we assume names
	 are *not* prefixed by '_'.  */
      if (symtab.limit->name[0] == 'm' && discard_underscores
	  && strcmp (symtab.limit->name, "main") == 0)
	discard_underscores = 0;

a742 6
      /* If we see "main" without an initial '_', we assume names
	 are *not* prefixed by '_'.  */
      if (ltab.limit->name[0] == 'm' && discard_underscores
	  && strcmp (ltab.limit->name, "main") == 0)
	discard_underscores = 0;

@


1.25
log
@	* corefile.c (parse_error): New function.
	(read_function_mappings): Check calls to fscanf and report any
	errors in parsing the mapping file.
@
text
@d28 1
d273 5
@


1.24
log
@	* corefile.c (core_init): Report that the executable is not in the
	expected executable format rather than "a.out" format.
@
text
@d56 7
d84 1
a84 5
	{
	  fprintf (stderr, _("%s: unable to parse mapping file %s.\n"),
		   whoami, filename);
	  done (1);
	}
d89 3
a91 1
	  fscanf (file, "\n");
d96 3
a98 1
      fscanf (file, "%[^\n]\n", dummy);
d118 1
a118 5
	{
	  fprintf (stderr, _("%s: unable to parse mapping file %s.\n"),
		   whoami, filename);
	  done (1);
	}
d123 3
a125 1
	  fscanf (file, "\n");
d134 3
a136 1
      fscanf (file, "%[^\n]\n", dummy);
@


1.23
log
@Update the address of the FSF
@
text
@d158 1
a158 1
      fprintf (stderr, _("%s: %s: not in a.out format\n"), whoami, aout_name);
@


1.23.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d158 1
a158 1
      fprintf (stderr, _("%s: %s: not in executable format\n"), whoami, aout_name);
@


1.23.2.2
log
@	Merge fido bits:
	2006-10-25  Kazu Hirata  <kazu@@codesourcery.com>

	gprof/
	* hist.c, hist.h: Fix formatting.

	gprof/
	* Makefile.in (corefile.o): Depend on hist.h.
	* corefile.c: Include hist.h.

	2006-10-06  Vladimir Prus  <vladimir@@codesourcery.com>

	* hist.h (struct histogram)
	(histograms, num_histograms): New.
	* hist.c (find_histogram, find_histogram_for_pc)
	(read_histogram_header): New.
	(s_lowpc, s_highpc, lowpc, highpc, hist_num_bins)
	(hist_sample): Remove.
	(hist_read_rec): Use the above, and handle multiple
	histogram records with disjoint address ranges.
	(hist_write_hist): Support several histogram records.
	(scale_and_align_entries): Adjust for multiple histograms.
	(hist_assign_samples_1): New.
	(hist_assign_samples): Use the above.
	(hist_clip_symbol_address): New.
	* hist.h (hist_check_address)
	(hist_clip_symbol_address): Declare.
	* gmon_io.c (gmon_out_read, gmon_out_write): Adjust handling
	of legacy format for multiple histogram changes.
	* corefile.c (find_call): Check for core_text_space and
	clip symbol address range here.
	* vax.c	(vax_find_call): Don't check for
	core_text_space, or clip the symbol's address range here.
	Use hist_check_address to check call's target address.
	* sparc.c: Likewise.
	* tahoe.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise. Also use core_text_sect->vma as the base
	address for code accesses, just like other machine-specific
	routines do.

	2006-08-03  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add -mfido as an alias for
	-mfido_a.

	2006-06-23  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (cpu_of_arch): Replace fido with
	fido_a.
	(archs): Likewise.
	(m68k_ip): Likewise.
	(select_control_regs): Likewise.
	(md_show_usage): Replace -mfido with -mfidoa.
	* include/opcode/m68k.h (fido): Rename to fido_a.
	* opcodes/m68k-opc.c (m68k_opcodes): Replace fido with fido_a.

	2006-06-22  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Replace fido with fido.
	* bfd/config.bfd: Likewise
	* gas/configure.tgt: Likewise.
	* gas/config/m68k-parse.h: Likewise.
	* gas/config/tc-m68k.c: Likewise.
	* gas/testsuite/gas/m68k/all.exp: Likewise.
	* gas/testsuite/gas/m68k/fido.d: Rename to fido.d.
	* gas/testsuite/gas/m68k/fido.s: Rename to fido.s.
	* include/opcode/m68k.h: Replace fido with fido.
	* ld/configure.tgt: Likewise.
	* opcodes/m68k-dis.c: Likewise.
	* opcodes/m68k-opc.c: Likewise.

	2005-08-01  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/m68k-parse.h (m68k_register): Add CAC and MBB.
	* gas/config/tc-m68k.c (fido_control_regs): New.
	(cpu_of_arch): Add fido.
	(archs): Add an entry for fido.
	(m68k_ip): Add warnings for uses of tbl[su]{n,}[bwl] on
	fido.  Recognize CAC and MBB.
	(init_tabl): Add CAC and MBB.
	(select_control_regs): Choose fido as the current chip
	when the current architecture is fido or when -mfido
	is given explicitly.
	* gas/testsuite/gas/m68k/all.exp: Disable operands, cas, and
	bitfield on fido-*-*.  Run fido on fido-*-*.
	* gas/testsuite/gas/m68k/fido.d: New.
	* gas/testsuite/gas/m68k/fido.s: Likewise.
	* include/opcode/m68k.h: Document new control registers CAC
	and MBB.
	* opcodes/m68k-dis.c (print_insn_arg): Add cac and mbb.
	* opcodes/m68k-opc.c (m68k_opcodes): Add sleep and trapx.

	2005-07-22  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add fido as an OR of
	cpu32 and fido.
	(md_show_usage): Add -mfido.
	* include/opcode/m68k.h (fido): New.

	2005-07-11  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Recognize fido and fido-*.
	* bfd/config.bfd: Likewise.
	* gas/configure.tgt: Likewise.
	* ld/configure.tgt: Likewise.
@
text
@a27 1
#include "hist.h"
a264 5
  if (core_text_space == 0)
    return;

  hist_clip_symbol_address (&p_lowpc, &p_highpc);

@


1.22
log
@	* corefile.c (core_num_syms): Make static.
	(core_syms): Likewise.
	(min_insn_size): Likewise.
	* gprof.c (abfd): Remove unused variable.
	* hist.c (hist_dimension): Make static.
	(hist_dimension_abbrev): Likewise.
	* sym_ids.c (id_list): Likewise.
	(table_name): Likewise.
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.21
log
@	* corefile.c (core_init): Call bfd_get_synthetic_symtab.
@
text
@d31 2
a32 2
int core_num_syms;
asymbol **core_syms;
d36 1
a36 1
int min_insn_size;
@


1.20
log
@update copyright dates
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004
d145 3
d196 17
@


1.20.2.1
log
@	* corefile.c (core_init): Call bfd_get_synthetic_symtab.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
a144 3
  asymbol *synthsyms;
  long synth_count;

a192 17
  synth_count = bfd_get_synthetic_symtab (core_bfd, core_num_syms, core_syms,
					  0, NULL, &synthsyms);
  if (synth_count > 0)
    {
      asymbol **symp;
      long new_size;
      long i;

      new_size = (core_num_syms + synth_count + 1) * sizeof (*core_syms);
      core_syms = xrealloc (core_syms, new_size);
      symp = core_syms + core_num_syms;
      core_num_syms += synth_count;
      for (i = 0; i < synth_count; i++)
	*symp++ = synthsyms + i;
      *symp = 0;
    }

@


1.19
log
@	* corefile.c (core_init): Use bfd_get_section_size
	instead of bfd_get_section_size_before_reloc or _raw_size.
	* symtab.c (symtab_finalize): Likewise.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.18
log
@2004-05-26  Andrew Cagney  <cagney@@gnu.org>

	* corefile.c (core_create_line_syms): Per ISO C '90, move
	vma_high's declaration to the function's start.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d219 1
a219 1
  core_text_space = (PTR) malloc ((unsigned int) core_text_sect->_raw_size);
d224 1
a224 1
	       whoami, (unsigned long) core_text_sect->_raw_size);
d229 1
a229 1
				 (bfd_vma) 0, core_text_sect->_raw_size))
d616 1
a616 1
  vma_high = core_text_sect->vma + core_text_sect->_raw_size;
@


1.17
log
@	* alpha.c, basic_blocks.c, basic_blocks.h, bb_exit_func.c,
	call_graph.c, call_graph.h, cg_arcs.c, cg_arcs.h, cg_dfn.c,
	cg_dfn.h, cg_print.c, cg_print.h, corefile.c, corefile.h,
	gmon_io.c, gmon_io.h, gprof.c, gprof.h, hertz.h, hist.c, hist.h,
	i386.c, mips.c, search_list.c, search_list.h, source.c, source.h,
	sparc.c, sym_ids.c, sym_ids.h, symtab.c, symtab.h, tahoe.c,
	utils.c, utils.h, vax.c, gen-c-prog.awk: Convert K&R C to ANSI C.
@
text
@d593 1
d616 1
a616 1
  bfd_vma vma_high = core_text_sect->vma + core_text_sect->_raw_size;
@


1.16
log
@	* corefile.c (core_init): Use a separate local variable,
	core_sym_bytes, to make the units from bfd_get_symtab_upper_bound
	more obvious.
	(core_create_function_syms): Discard cbfd argument.  Eliminate
	`offset' variable and calculate VMA directly. Update all users.
	* corefile.h (core_create_function_syms): Update prototype.
	(core_create_line_syms): Likewise.
	* gprof.c (main): Remove #ifdef PROF_SUPPORT_IMPLEMENTED code.
	Tidy.
@
text
@d42 2
a43 2
static void read_function_mappings PARAMS ((const char *));
static int core_sym_class PARAMS ((asymbol *));
d45 1
a45 1
  PARAMS ((bfd_vma, const char **, const char **, int *));
d47 6
a52 6
extern void i386_find_call  PARAMS ((Sym *, bfd_vma, bfd_vma));
extern void alpha_find_call PARAMS ((Sym *, bfd_vma, bfd_vma));
extern void vax_find_call   PARAMS ((Sym *, bfd_vma, bfd_vma));
extern void tahoe_find_call PARAMS ((Sym *, bfd_vma, bfd_vma));
extern void sparc_find_call PARAMS ((Sym *, bfd_vma, bfd_vma));
extern void mips_find_call  PARAMS ((Sym *, bfd_vma, bfd_vma));
d55 1
a55 2
read_function_mappings (filename)
     const char *filename;
d141 1
a141 2
core_init (aout_name)
     const char *aout_name;
d217 1
a217 2
core_get_text_space (cbfd)
     bfd *cbfd;
d242 1
a242 4
find_call (parent, p_lowpc, p_highpc)
     Sym *parent;
     bfd_vma p_lowpc;
     bfd_vma p_highpc;
d285 1
a285 2
core_sym_class (sym)
     asymbol *sym;
d368 1
a368 5
get_src_info (addr, filename, name, line_num)
     bfd_vma addr;
     const char **filename;
     const char **name;
     int *line_num;
@


1.15
log
@	* corefile.c (core_create_function_syms): Don't refer directly to
	_cooked_size and vma;  Use bfd_section_size and bfd_get_section_vma.
@
text
@d145 1
d176 2
a177 2
  core_num_syms = bfd_get_symtab_upper_bound (core_bfd);
  if (core_num_syms < 0)
d184 1
a184 1
  core_syms = (asymbol **) xmalloc (core_num_syms);
d409 1
a409 2
core_create_function_syms (cbfd)
     bfd *cbfd ATTRIBUTE_UNUSED;
d595 1
a595 2
core_create_line_syms (cbfd)
     bfd *cbfd;
a599 1
  bfd_vma offset;
d608 1
a608 1
  core_create_function_syms (cbfd);
d610 1
a610 1
  /* Pass 1 - counter number of symbols.  */
d618 1
a618 1
     bfd would provide an iterator for enumerating all line infos.  */
d626 2
a627 1
  for (offset = 0; offset < core_text_sect->_raw_size; offset += min_insn_size)
a630 2
      vma = core_text_sect->vma + offset;

d693 1
a693 1
  for (offset = 0; offset < core_text_sect->_raw_size; offset += min_insn_size)
d697 1
a697 2
      if (!get_src_info (core_text_sect->vma + offset, &filename,
			 &ltab.limit->name, &ltab.limit->line_num)
d707 1
a707 1
      ltab.limit->addr = core_text_sect->vma + offset;
@


1.14
log
@Check for a NULL sentinel value before using it.
@
text
@d459 2
d494 4
a497 1
      symtab.limit->addr = core_syms[i]->value + core_syms[i]->section->vma;
d554 4
a557 3
      if (core_syms[i]->section)
	max_vma = MAX (core_syms[i]->section->vma
		       + core_syms[i]->section->_cooked_size - 1, max_vma);
@


1.13
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d739 2
a740 1
  if (strcmp (sentinel->name, "<locore>") == 0
d746 3
a748 1
  if (strcmp (sentinel->name, "<hicore>") == 0 && max_vma >= sentinel->addr)
@


1.12
log
@2002-07-24  Dave Brolley  <brolley@@redhat.com>

	* corefile.c (core_create_function_syms): Use the end of the section
	containing the symbol to compute max_vma.
@
text
@d44 1
a44 1
static boolean get_src_info
d280 1
a280 1
      ignore_direct_calls = false;
d373 1
a373 1
static boolean
d393 1
a393 1
      return true;
d400 1
a400 1
      return false;
d539 2
a540 2
      symtab.limit->is_func = true;
      symtab.limit->is_bb_head = true;
d543 1
a543 1
	symtab.limit->is_static = true;
@


1.11
log
@	* alpha.c (alpha_find_call): Warning fixes.
	* mips.c (mips_find_call): Likewise.
	* sparc.c (sparc_find_call): Likewise.
	* basic_blocks.c: Warning fixes.  Eliminate DEFUN.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.cp: Likewise.
	* gprof.c: Likewise.
	* gprof.h: Likewise.
	* hist.c: Likewise.
	* search_list.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* symtab.h: Likewise.
	* utils.c: Likewise.
	* cg_print.c: Likewise.
	(struct function_map, symbol_map, symbol_map_count): Move
	declaration to..
	* corefile: ..here.
	* corefile.c: Warning fixes.  Eliminate DEFUN.
	(struct function_map): Remove declaration.
	* gmon_io.c: Warning fixes.  Eliminate DEFUN.
	(gmon_io_read_64): Make static.
	(gmon_io_write_64): Likewise.
	(gmon_read_raw_arc): Likewise.
	(gmon_write_raw_arc): Likewise.
	(gmon_io_write_8): Don't pass char, pass int param.
	* gmon_io.h (gmon_io_write_8): Likewise.

and a few copyright dates that should have been done previously.
@
text
@d545 3
d549 5
a553 1
      max_vma = MAX (symtab.limit->addr, max_vma);
@


1.10
log
@	* basic_blocks.c: Replace bool with boolean, TRUE with true and
	FALSE with false throughout.
	* basic_blocks.h: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hist.c: Likewise.
	* mips.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* tahoe.c: Likewise.
	* vax.c: Likewise.
	* gprof.h: Likewise.
	(TRUE): Don't define.
	(FALSE): Don't define.
@
text
@a38 6
struct function_map
{
  char *function_name;
  char *file_name;
};

d42 5
d55 2
a56 1
DEFUN (read_function_mappings, (filename), const char *filename)
d142 2
a143 1
DEFUN (core_init, (a_out_name), const char *a_out_name)
d145 1
a145 1
  core_bfd = bfd_openr (a_out_name, 0);
d149 1
a149 1
      perror (a_out_name);
d155 1
a155 1
      fprintf (stderr, _("%s: %s: not in a.out format\n"), whoami, a_out_name);
d167 1
a167 1
		   whoami, a_out_name);
d178 1
a178 1
      fprintf (stderr, "%s: %s: %s\n", whoami, a_out_name,
d188 1
a188 1
      fprintf (stderr, "%s: %s: %s\n", whoami, a_out_name,
d218 2
a219 1
DEFUN (core_get_text_space, (core_bfd), bfd * core_bfd)
d221 1
a221 1
  core_text_space = (PTR) malloc (core_text_sect->_raw_size);
d230 2
a231 2
  if (!bfd_get_section_contents (core_bfd, core_text_sect, core_text_space,
				 0, core_text_sect->_raw_size))
d244 4
a247 2
DEFUN (find_call, (parent, p_lowpc, p_highpc),
       Sym * parent AND bfd_vma p_lowpc AND bfd_vma p_highpc)
d290 2
a291 1
DEFUN (core_sym_class, (sym), asymbol * sym)
d374 5
a378 3
DEFUN (get_src_info, (addr, filename, name, line_num),
       bfd_vma addr AND const char **filename AND const char **name
       AND int *line_num)
d408 2
a409 2
core_create_function_syms (core_bfd)
     bfd *core_bfd ATTRIBUTE_UNUSED;
d411 2
a412 1
  bfd_vma min_vma = ~0, max_vma = 0;
d571 1
a571 1
  symtab.limit->end_addr = ~0;
d582 2
a583 1
DEFUN (core_create_line_syms, (core_bfd), bfd * core_bfd)
d586 2
a587 2
  int prev_name_len, prev_filename_len;
  bfd_vma vma, min_vma = ~0, max_vma = 0;
d597 1
a597 1
  core_create_function_syms (core_bfd);
d617 1
a617 1
      int len;
d730 1
a730 1
  sentinel = sym_lookup (&symtab, 0);
d736 1
a736 1
  sentinel = sym_lookup (&symtab, ~0);
@


1.9
log
@	* alpha.c (alpha_Instruction): Don't use.
	(alpha_find_call): Avoid use of bitfields and casts between
	pointers and integers of different sizes.  Avoid endian problems
	when cross-compiling.
	* vax.c (vax_find_call): Likewise.
	(struct modebyte): Don't use.
	(vax_operandmode): Pass in an unsigned char *.
	(vax_operandlength): Likewise.
	(vax_reladdr): Rename to vax_offset and return relative offset
	rather than address.
	* i386.c (i386_find_call): Avoid casts between pointers and
	integers of different sizes.
	* sparc.c (sparc_find_call): Likewise.  Avoid endian problems.
	* tahoe.c (tahoe_find_call): Likewise.
	(tahoe_reladdr): Rename to tahoe_offset and return relative offset
	rather than address.

	* basic_blocks.h: Don't include headers here.
	* call_graph.h: Likewise.
	* cg_arcs.h: Likewise.
	* cg_print.h: Likewise.
	* corefile.h: Likewise.
	* gmon_io.h: Likewise.
	* gmon_out.h: Likewise.
	* hertz.h: Likewise.
	* hist.h: Likewise.
	* source.h: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* gprof.h: Don't include ansidecl.h, do include bfd.h.
	(bool): Don't typedef.
	* alpha.c: Adjust #include's for above header changes.
	* basic_blocks.c: Likewise.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hertz.c: Likewise.
	* hist.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise.
	* sparc.c: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* tahoe.c: Likewise.
	* utils.c: Likewise.
	* vax.c: Likewise.

	* po/POTFILES.in: Regenerate.
@
text
@d276 1
a276 1
      ignore_direct_calls = FALSE;
d368 1
a368 1
static bool
d386 1
a386 1
      return TRUE;
d393 1
a393 1
      return FALSE;
d531 2
a532 2
      symtab.limit->is_func = TRUE;
      symtab.limit->is_bb_head = TRUE;
d535 1
a535 1
	symtab.limit->is_static = TRUE;
@


1.8
log
@* mips.c: New file.
* Makefile.am (sources): Add mips.c.
(mips.o): New rule.
* Makefile.in: Regenerate.
* corefile.c: Update copyright years.
(find_call): Call mips_find_call for bfd_arch_mips.
@
text
@d24 3
a27 1
#include "symtab.h"
@


1.7
log
@David Mosberger's fixes for cross compiling gprof.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d51 1
d263 4
@


1.6
log
@Fix typos in ChangeLog; fix dates in copyright notices
@
text
@d3 1
a3 1
   Copyright 2000 Free Software Foundation, Inc.
d181 1
a181 1
  
d224 1
a224 1
  
d232 1
a232 1
  
d274 3
a276 3
        0   -> symbol is not interesting to us
        'T' -> symbol is a global name
        't' -> symbol is a local (static) name.  */
d331 1
a331 1
  
d340 1
a340 1
  
d343 1
a343 1
        language.  We want to ignore these, since sometimes they mask
d404 1
a404 1
  
d411 1
a411 1
	 search.  Gross. 
d421 1
a421 1
			 	   symbol_map [j - 1].file_name))
d425 1
a425 1
      
d427 1
a427 1
        ++symtab.len;
d441 1
a441 1
  
d445 1
a445 1
      
d454 1
a454 1
      
d459 1
a459 1
      
d464 1
a464 1
			 	   symbol_map [j - 1].file_name))
d478 1
a478 1
      
d494 1
a494 1
	
d501 1
a501 1
               gprof.  */
d505 1
a505 1
	      
d526 1
a526 1
      
d534 1
a534 1
         are *not* prefixed by '_'.  */
d577 1
a577 1
  
d589 1
a589 1
    
d598 1
a598 1
  
d604 1
a604 1
      
d622 1
a622 1
      
d625 1
a625 1
      
d632 1
a632 1
      
d666 1
a666 1
  
d670 1
a670 1
      
d685 2
a686 2
         1) the previous symbol, if it's from the same function, or
         2) a symtab lookup.  */
d701 1
a701 1
         are *not* prefixed by '_'.  */
d715 1
a715 1
  
d721 1
a721 1
  
@


1.5
log
@Add GPL copyright notices to uncopyrighted files.
Add copy of GPL.
@
text
@d3 1
a3 1
   Copyright (C) 2000  Free Software Foundation, Inc.
@


1.5.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
@


1.5.2.2
log
@Merge from mainline.
@
text
@d181 1
a181 1

d224 1
a224 1

d232 1
a232 1

d274 3
a276 3
	0   -> symbol is not interesting to us
	'T' -> symbol is a global name
	't' -> symbol is a local (static) name.  */
d331 1
a331 1

d340 1
a340 1

d343 1
a343 1
	language.  We want to ignore these, since sometimes they mask
d404 1
a404 1

d411 1
a411 1
	 search.  Gross.
d421 1
a421 1
				   symbol_map [j - 1].file_name))
d425 1
a425 1

d427 1
a427 1
	++symtab.len;
d441 1
a441 1

d445 1
a445 1

d454 1
a454 1

d459 1
a459 1

d464 1
a464 1
				   symbol_map [j - 1].file_name))
d478 1
a478 1

d494 1
a494 1

d501 1
a501 1
	       gprof.  */
d505 1
a505 1

d526 1
a526 1

d534 1
a534 1
	 are *not* prefixed by '_'.  */
d577 1
a577 1

d589 1
a589 1

d598 1
a598 1

d604 1
a604 1

d622 1
a622 1

d625 1
a625 1

d632 1
a632 1

d666 1
a666 1

d670 1
a670 1

d685 2
a686 2
	 1) the previous symbol, if it's from the same function, or
	 2) a symtab lookup.  */
d701 1
a701 1
	 are *not* prefixed by '_'.  */
d715 1
a715 1

d721 1
a721 1

@


1.4
log
@	From Brad Lucier <lucier@@math.purdue.edu>:
	* corefile.c (core_create_line_syms): Add cast for printf.
@
text
@d1 21
d37 2
a38 1
struct function_map {
d46 1
a46 1
extern void i386_find_call PARAMS ((Sym *, bfd_vma, bfd_vma));
d48 1
a48 1
extern void vax_find_call PARAMS ((Sym *, bfd_vma, bfd_vma));
d137 1
d155 1
a155 1
  /* get core's text section: */
d168 1
a168 1
  /* read core's symbol table: */
d170 1
a170 1
  /* this will probably give us more than we need, but that's ok:  */
d181 1
d211 1
a212 3
/*
 * Read in the text space of an a.out file
 */
d224 1
d232 1
d234 1
a234 3
    {
      fprintf (stderr, _("%s: can't do -c\n"), whoami);
    }
d273 5
a277 6
/*
 * Return class of symbol SYM.  The returned class can be any of:
 *      0   -> symbol is not interesting to us
 *      'T' -> symbol is a global name
 *      't' -> symbol is a local (static) name
 */
d287 1
a287 3
    {
      return 0;
    }
d289 2
a290 4
  /*
   * Must be a text symbol, and static text symbols don't qualify if
   * ignore_static_funcs set.
   */
d302 1
a302 3
    {
      return i;			/* it's a global symbol */
    }
d305 3
a307 5
    {
      /* Treat weak symbols as text symbols.  FIXME: a weak symbol may
         also be a data symbol.  */
      return 'T';
    }
d311 1
a311 1
      /* not a static text symbol */
d317 3
a319 1
  /* do some more filtering on static function-names: */
d321 2
a322 8
  if (ignore_static_funcs)
    {
      return 0;
    }
  /*
   * Can't zero-length name or funny characters in name, where
   * `funny' includes: `.' (.o file names) and `$' (Pascal labels).
   */
d324 1
a324 3
    {
      return 0;
    }
d329 1
a329 3
	{
	  return 0;
	}
d331 8
a338 9
  /*
   * On systems where the C compiler adds an underscore to all
   * names, static names without underscores seem usually to be
   * labels in hand written assembler in the library.  We don't want
   * these names.  This is certainly necessary on a Sparc running
   * SunOS 4.1 (try profiling a program that does a lot of
   * division). I don't know whether it has harmful side effects on
   * other systems.  Perhaps it should be made configurable.
   */
d340 1
d342 3
a344 5
  /*
   * GCC may add special symbols to help gdb figure out the file
   * language.  We want to ignore these, since sometimes they mask
   * the real function.  (dj@@ctron)
   */
d351 2
a352 2
  /* If the object file supports marking of function symbols, then we can
     zap anything that doesn't have BSF_FUNCTION set.  */
d356 1
a356 1
  return 't';			/* it's a static text symbol */
d359 1
a360 3
/*
 * Get whatever source info we can get regarding address ADDR:
 */
d390 2
a392 4
/*
 * Read in symbol table from core.  One symbol per function is
 * entered.
 */
d402 1
a402 1
  /* pass 1 - determine upper bound on number of function names: */
d404 1
d408 1
a408 3
	{
	  continue;
	}
d425 1
d436 1
a436 1
  /* the "+ 2" is for the sentinels: */
d439 1
a439 2
  /* pass 2 - create symbols: */

d441 1
d445 1
d454 1
a456 1

d459 1
d476 1
a476 2
      /* symbol offsets are always section-relative: */

d478 1
d491 1
a491 2
      /* Lookup filename and line number, if we can */

d503 6
a508 8
	    /*
	     * Suppress symbols that are not function names.  This is
	     * useful to suppress code-labels and aliases.
	     *
	     * This is known to be useful under DEC's OSF/1.  Under SunOS 4.x,
	     * labels do not appear in the symbol table info, so this isn't
	     * necessary.
	     */
d512 3
a514 5
		/*
		 * The symbol's address maps to a different name, so
		 * it can't be a function-entry point.  This happens
		 * for labels, for example.
		 */
d526 1
d528 1
a528 3
	{
	  symtab.limit->is_static = TRUE;
	}
d533 2
a534 4
      /*
       * If we see "main" without an initial '_', we assume names
       * are *not* prefixed by '_'.
       */
d537 1
a537 3
	{
	  discard_underscores = 0;
	}
d546 1
a546 2
  /* create sentinels: */

d563 2
a565 4
/*
 * Read in symbol table from core.  One symbol per line of source code
 * is entered.
 */
d577 4
a580 5
  /*
   * Create symbols for functions as usual.  This is necessary in
   * cases where parts of a program were not compiled with -g.  For
   * those parts we still want to get info at the function level:
   */
d583 1
a583 1
  /* pass 1 - counter number of symbols: */
d585 7
a591 9
  /*
   * To find all line information, walk through all possible
   * text-space addresses (one by one!) and get the debugging
   * info for each address.  When the debugging info changes,
   * it is time to create a new symbol.
   *
   * Of course, this is rather slow and it would be better if
   * bfd would provide an iterator for enumerating all line infos
   */
d598 1
d604 1
d610 1
a610 3
	{
	  continue;
	}
d622 1
a623 1

d625 1
d632 1
d642 1
a642 1
  /* make room for function symbols, too: */
d647 1
a647 1
  /* pass 2 - create symbols: */
a664 1

d666 1
d670 1
d676 1
a676 3
	{
	  continue;
	}
d678 1
a678 1
      /* make name pointer a malloc'ed string: */
d685 2
a686 4
       * 1) the previous symbol, if it's from the same function, or
       * 2) a symtab lookup
       */

d700 2
a701 4
      /*
       * If we see "main" without an initial '_', we assume names
       * are *not* prefixed by '_'.
       */
d704 1
a704 3
	{
	  discard_underscores = 0;
	}
d713 1
a713 2
  /* update sentinels: */

d715 1
d718 1
a718 3
    {
      sentinel->end_addr = min_vma - 1;
    }
d721 1
d723 1
a723 3
    {
      sentinel->addr = max_vma + 1;
    }
d725 1
a725 1
  /* copy in function symbols: */
d737 1
a737 2
  /* finalize ltab and make it symbol table: */

a740 1

@


1.3
log
@	* corefile.c (core_create_function_syms): Add ATTRIBUTED_UNUSED.
	* sym-ids.c (non_existent_file): Fully initialize structure.
@
text
@d726 3
a728 2
      DBG (AOUTDEBUG, printf ("[core_create_line_syms] %d %s 0x%lx\n",
			      ltab.limit - ltab.base, ltab.limit->name,
@


1.2
log
@	* Many files: Add casts in many print statements to cast bfd_vma
	values to unsigned long when calling printf.
	* Makefile.am ($(OBJECTS)): Add gmon.h.
	* Makefile.in: Rebuild.
@
text
@d395 2
a396 1
DEFUN (core_create_function_syms, (core_bfd), bfd * core_bfd)
@


1.1
log
@Initial revision
@
text
@d198 2
a199 2
      fprintf (stderr, _("%s: ran out room for %ld bytes of text space\n"),
	       whoami, core_text_sect->_raw_size);
d374 1
a374 1
			      addr, fname, l, func_name));
d449 2
a450 1
		       core_syms[i]->value, core_syms[i]->name));
d549 2
a550 1
			      symtab.limit->name, symtab.limit->addr));
d727 1
a727 1
			      ltab.limit->addr));
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

