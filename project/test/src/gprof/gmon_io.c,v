head	1.29;
access;
symbols
	binutils-2_24-branch:1.29.0.10
	binutils-2_24-branchpoint:1.29
	binutils-2_21_1:1.29
	binutils-2_23_2:1.29
	binutils-2_23_1:1.29
	binutils-2_23:1.29
	binutils-2_23-branch:1.29.0.8
	binutils-2_23-branchpoint:1.29
	binutils-2_22_branch:1.29.0.6
	binutils-2_22:1.29
	binutils-2_22-branch:1.29.0.4
	binutils-2_22-branchpoint:1.29
	binutils-2_21:1.29
	binutils-2_21-branch:1.29.0.2
	binutils-2_21-branchpoint:1.29
	binutils-2_20_1:1.26.8.1
	binutils-2_20:1.26.8.1
	binutils-arc-20081103-branch:1.26.0.10
	binutils-arc-20081103-branchpoint:1.26
	binutils-2_20-branch:1.26.0.8
	binutils-2_20-branchpoint:1.26
	dje-cgen-play1-branch:1.26.0.6
	dje-cgen-play1-branchpoint:1.26
	arc-20081103-branch:1.26.0.4
	arc-20081103-branchpoint:1.26
	binutils-2_19_1:1.26
	binutils-2_19:1.26
	binutils-2_19-branch:1.26.0.2
	binutils-2_19-branchpoint:1.26
	binutils-2_18:1.24
	binutils-2_18-branch:1.24.0.2
	binutils-2_18-branchpoint:1.24
	binutils-csl-coldfire-4_1-32:1.22.2.1
	binutils-csl-sourcerygxx-4_1-32:1.22.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.22.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.20.2.1
	binutils-csl-coldfire-4_1-30:1.22.2.1
	binutils-csl-sourcerygxx-4_1-30:1.22.2.1
	binutils-csl-coldfire-4_1-28:1.22.2.1
	binutils-csl-sourcerygxx-4_1-29:1.22.2.1
	binutils-csl-sourcerygxx-4_1-28:1.22.2.1
	binutils-csl-arm-2006q3-27:1.22.2.1
	binutils-csl-sourcerygxx-4_1-27:1.22.2.1
	binutils-csl-arm-2006q3-26:1.22.2.1
	binutils-csl-sourcerygxx-4_1-26:1.22.2.1
	binutils-csl-sourcerygxx-4_1-25:1.22
	binutils-csl-sourcerygxx-4_1-24:1.22
	binutils-csl-sourcerygxx-4_1-23:1.22
	binutils-csl-sourcerygxx-4_1-21:1.22
	binutils-csl-arm-2006q3-21:1.22
	binutils-csl-sourcerygxx-4_1-22:1.22
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.22
	binutils-csl-sourcerygxx-4_1-20:1.22
	binutils-csl-arm-2006q3-19:1.22
	binutils-csl-sourcerygxx-4_1-19:1.22
	binutils-csl-sourcerygxx-4_1-18:1.22
	binutils-csl-renesas-4_1-9:1.22
	binutils-csl-sourcerygxx-3_4_4-25:1.20.2.1
	binutils-csl-renesas-4_1-8:1.22
	binutils-csl-renesas-4_1-7:1.22
	binutils-csl-renesas-4_1-6:1.22
	binutils-csl-sourcerygxx-4_1-17:1.22
	binutils-csl-sourcerygxx-4_1-14:1.22
	binutils-csl-sourcerygxx-4_1-15:1.22
	binutils-csl-sourcerygxx-4_1-13:1.22
	binutils-2_17:1.22
	binutils-csl-sourcerygxx-4_1-12:1.22
	binutils-csl-sourcerygxx-3_4_4-21:1.22
	binutils-csl-wrs-linux-3_4_4-24:1.20.2.1
	binutils-csl-wrs-linux-3_4_4-23:1.20.2.1
	binutils-csl-sourcerygxx-4_1-9:1.22
	binutils-csl-sourcerygxx-4_1-8:1.22
	binutils-csl-sourcerygxx-4_1-7:1.22
	binutils-csl-arm-2006q1-6:1.22
	binutils-csl-sourcerygxx-4_1-6:1.22
	binutils-csl-wrs-linux-3_4_4-22:1.20.2.1
	binutils-csl-coldfire-4_1-11:1.22
	binutils-csl-sourcerygxx-3_4_4-19:1.22
	binutils-csl-coldfire-4_1-10:1.22
	binutils-csl-sourcerygxx-4_1-5:1.22
	binutils-csl-sourcerygxx-4_1-4:1.22
	binutils-csl-wrs-linux-3_4_4-21:1.20.2.1
	binutils-csl-morpho-4_1-4:1.22
	binutils-csl-sourcerygxx-3_4_4-17:1.22
	binutils-csl-wrs-linux-3_4_4-20:1.20.2.1
	binutils-2_17-branch:1.22.0.4
	binutils-2_17-branchpoint:1.22
	binutils-csl-2_17-branch:1.22.0.2
	binutils-csl-2_17-branchpoint:1.22
	binutils-csl-gxxpro-3_4-branch:1.20.2.1.0.4
	binutils-csl-gxxpro-3_4-branchpoint:1.20.2.1
	binutils-2_16_1:1.20.2.1
	binutils-csl-arm-2005q1b:1.20.2.1
	binutils-2_16:1.20.2.1
	binutils-csl-arm-2005q1a:1.20.2.1
	binutils-csl-arm-2005q1-branch:1.20.2.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.20.2.1
	binutils-2_16-branch:1.20.0.2
	binutils-2_16-branchpoint:1.20
	csl-arm-2004-q3d:1.18
	csl-arm-2004-q3:1.18
	gprof-pre-ansify-2004-05-26:1.17
	gprof-post-ansify-2004-05-26:1.18
	binutils-2_15:1.17
	binutils-2_15-branchpoint:1.17
	csl-arm-2004-q1a:1.17
	csl-arm-2004-q1:1.17
	binutils-2_15-branch:1.17.0.8
	cagney_bfdfile-20040213-branch:1.17.0.6
	cagney_bfdfile-20040213-branchpoint:1.17
	cagney_bigcore-20040122-branch:1.17.0.4
	cagney_bigcore-20040122-branchpoint:1.17
	csl-arm-2003-q4:1.17
	binutils-2_14:1.17
	binutils-2_14-branch:1.17.0.2
	binutils-2_14-branchpoint:1.17
	binutils-2_13_2_1:1.14
	binutils-2_13_2:1.14
	binutils-2_13_1:1.14
	binutils-2_13:1.14
	binutils-2_13-branchpoint:1.14
	binutils-2_13-branch:1.14.0.4
	binutils-2_12_1:1.14
	binutils-2_12:1.14
	binutils-2_12-branch:1.14.0.2
	binutils-2_12-branchpoint:1.14
	cygnus_cvs_20020108_pre:1.10
	binutils-2_11_2:1.5.2.2
	binutils-2_11_1:1.5.2.2
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	binutils-2_10_1:1.3.2.1
	binutils-2_10:1.3.2.1
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.29
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2010.06.16.08.04.21;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2010.03.16.18.24.24;	author segher;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.11.15.27.34;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2008.08.25.04.38.45;	author amodra;	state Exp;
branches
	1.26.8.1;
next	1.25;

1.25
date	2008.08.05.19.09.06;	author briand;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.06.10.40.34;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.10.07.57.31;	author vprus;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.09.06.55.24;	author nickc;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2005.03.14.12.32.02;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.03.12.05.12;	author amodra;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2005.02.22.12.59.21;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.26.04.55.55;	author bje;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.31.19.01.04;	author cgd;	state Exp;
branches;
next	1.16;

1.16
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.08.20.23.47.26;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.02.01.08.24.16;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.02.01.01.18.06;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.01.31.18.37.56;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.31.12.56.07;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.03.21.32.36;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.02.15.55.48;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.16.05.26.57;	author aoliva;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.14.03.14.56;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.21.07.29;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.24.20.59.03;	author nickc;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.05.26.13.11.56;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	99.09.24.09.03.49;	author nickc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.06.30.22.38.20;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.26.8.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.22.2.1
date	2006.10.30.19.46.10;	author kazu;	state Exp;
branches;
next	;

1.20.2.1
date	2005.03.14.12.33.53;	author amodra;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.16.27;	author amodra;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.06.11.10.05.03;	author amodra;	state Exp;
branches;
next	;

1.3.2.1
date	2000.05.28.10.57.51;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches;
next	;


desc
@@


1.29
log
@        * gmon_io.c (gmon_out_read): Remove double fclose of input file.
@
text
@/* gmon_io.c - Input and output from/to gmon.out files.

   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "gprof.h"
#include "binary-io.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "cg_arcs.h"
#include "basic_blocks.h"
#include "corefile.h"
#include "call_graph.h"
#include "gmon_io.h"
#include "gmon_out.h"
#include "gmon.h"		/* Fetch header for old format.  */
#include "hertz.h"
#include "hist.h"
#include "libiberty.h"

enum gmon_ptr_size {
  ptr_32bit,
  ptr_64bit
};

enum gmon_ptr_signedness {
  ptr_signed,
  ptr_unsigned
};

static enum gmon_ptr_size gmon_get_ptr_size (void);
static enum gmon_ptr_signedness gmon_get_ptr_signedness (void);

#ifdef BFD_HOST_U_64_BIT
static int gmon_io_read_64 (FILE *, BFD_HOST_U_64_BIT *);
static int gmon_io_write_64 (FILE *, BFD_HOST_U_64_BIT);
#endif
static int gmon_read_raw_arc
  (FILE *, bfd_vma *, bfd_vma *, unsigned long *);
static int gmon_write_raw_arc
  (FILE *, bfd_vma, bfd_vma, unsigned long);

int gmon_input = 0;
int gmon_file_version = 0;	/* 0 == old (non-versioned) file format.  */

static enum gmon_ptr_size
gmon_get_ptr_size ()
{
  int size;

  /* Pick best size for pointers.  Start with the ELF size, and if not
     elf go with the architecture's address size.  */
  size = bfd_get_arch_size (core_bfd);
  if (size == -1)
    size = bfd_arch_bits_per_address (core_bfd);

  switch (size)
    {
    case 32:
      return ptr_32bit;

    case 64:
      return ptr_64bit;

    default:
      fprintf (stderr, _("%s: address size has unexpected value of %u\n"),
	       whoami, size);
      done (1);
    }
}

static enum gmon_ptr_signedness
gmon_get_ptr_signedness ()
{
  int sext;

  /* Figure out whether to sign extend.  If BFD doesn't know, assume no.  */
  sext = bfd_get_sign_extend_vma (core_bfd);
  if (sext == -1)
    return ptr_unsigned;
  return (sext ? ptr_signed : ptr_unsigned);
}

int
gmon_io_read_32 (FILE *ifp, unsigned int *valp)
{
  char buf[4];

  if (fread (buf, 1, 4, ifp) != 4)
    return 1;
  *valp = bfd_get_32 (core_bfd, buf);
  return 0;
}

#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_read_64 (FILE *ifp, BFD_HOST_U_64_BIT *valp)
{
  char buf[8];

  if (fread (buf, 1, 8, ifp) != 8)
    return 1;
  *valp = bfd_get_64 (core_bfd, buf);
  return 0;
}
#endif

int
gmon_io_read_vma (FILE *ifp, bfd_vma *valp)
{
  unsigned int val32;
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT val64;
#endif

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &val32))
	return 1;
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (int) val32;
      else
        *valp = val32;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &val64))
	return 1;
#ifdef BFD_HOST_64_BIT
      if (gmon_get_ptr_signedness () == ptr_signed)
        *valp = (BFD_HOST_64_BIT) val64;
      else
#endif
        *valp = val64;
      break;
#endif
    }
  return 0;
}

int
gmon_io_read (FILE *ifp, char *buf, size_t n)
{
  if (fread (buf, 1, n, ifp) != n)
    return 1;
  return 0;
}

int
gmon_io_write_32 (FILE *ofp, unsigned int val)
{
  char buf[4];

  bfd_put_32 (core_bfd, (bfd_vma) val, buf);
  if (fwrite (buf, 1, 4, ofp) != 4)
    return 1;
  return 0;
}

#ifdef BFD_HOST_U_64_BIT
static int
gmon_io_write_64 (FILE *ofp, BFD_HOST_U_64_BIT val)
{
  char buf[8];

  bfd_put_64 (core_bfd, (bfd_vma) val, buf);
  if (fwrite (buf, 1, 8, ofp) != 8)
    return 1;
  return 0;
}
#endif

int
gmon_io_write_vma (FILE *ofp, bfd_vma val)
{

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) val))
	return 1;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) val))
	return 1;
      break;
#endif
    }
  return 0;
}

int
gmon_io_write_8 (FILE *ofp, unsigned int val)
{
  char buf[1];

  bfd_put_8 (core_bfd, val, buf);
  if (fwrite (buf, 1, 1, ofp) != 1)
    return 1;
  return 0;
}

int
gmon_io_write (FILE *ofp, char *buf, size_t n)
{
  if (fwrite (buf, 1, n, ofp) != n)
    return 1;
  return 0;
}

static int
gmon_read_raw_arc (FILE *ifp, bfd_vma *fpc, bfd_vma *spc, unsigned long *cnt)
{
#ifdef BFD_HOST_U_64_BIT
  BFD_HOST_U_64_BIT cnt64;
#endif
  unsigned int cnt32;

  if (gmon_io_read_vma (ifp, fpc)
      || gmon_io_read_vma (ifp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_read_32 (ifp, &cnt32))
	return 1;
      *cnt = cnt32;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_read_64 (ifp, &cnt64))
	return 1;
      *cnt = cnt64;
      break;
#endif

    default:
      return 1;
    }
  return 0;
}

static int
gmon_write_raw_arc (FILE *ofp, bfd_vma fpc, bfd_vma spc, unsigned long cnt)
{

  if (gmon_io_write_vma (ofp, fpc)
      || gmon_io_write_vma (ofp, spc))
    return 1;

  switch (gmon_get_ptr_size ())
    {
    case ptr_32bit:
      if (gmon_io_write_32 (ofp, (unsigned int) cnt))
	return 1;
      break;

#ifdef BFD_HOST_U_64_BIT
    case ptr_64bit:
      if (gmon_io_write_64 (ofp, (BFD_HOST_U_64_BIT) cnt))
	return 1;
      break;
#endif
    }
  return 0;
}

void
gmon_out_read (const char *filename)
{
  FILE *ifp;
  struct gmon_hdr ghdr;
  unsigned char tag;
  int nhist = 0, narcs = 0, nbbs = 0;

  /* Open gmon.out file.  */
  if (strcmp (filename, "-") == 0)
    {
      ifp = stdin;
      SET_BINARY (fileno (stdin));
    }
  else
    {
      ifp = fopen (filename, FOPEN_RB);

      if (!ifp)
	{
	  perror (filename);
	  done (1);
	}
    }

  if (fread (&ghdr, sizeof (struct gmon_hdr), 1, ifp) != 1)
    {
      fprintf (stderr, _("%s: file too short to be a gmon file\n"),
	       filename);
      done (1);
    }

  if ((file_format == FF_MAGIC)
      || (file_format == FF_AUTO && !strncmp (&ghdr.cookie[0], GMON_MAGIC, 4)))
    {
      if (file_format == FF_MAGIC && strncmp (&ghdr.cookie[0], GMON_MAGIC, 4))
	{
	  fprintf (stderr, _("%s: file `%s' has bad magic cookie\n"),
		   whoami, filename);
	  done (1);
	}

      /* Right magic, so it's probably really a new gmon.out file.  */
      gmon_file_version = bfd_get_32 (core_bfd, (bfd_byte *) ghdr.version);

      if (gmon_file_version != GMON_VERSION && gmon_file_version != 0)
	{
	  fprintf (stderr,
		   _("%s: file `%s' has unsupported version %d\n"),
		   whoami, filename, gmon_file_version);
	  done (1);
	}

      /* Read in all the records.  */
      while (fread (&tag, sizeof (tag), 1, ifp) == 1)
	{
	  switch (tag)
	    {
	    case GMON_TAG_TIME_HIST:
	      ++nhist;
	      gmon_input |= INPUT_HISTOGRAM;
	      hist_read_rec (ifp, filename);
	      break;

	    case GMON_TAG_CG_ARC:
	      ++narcs;
	      gmon_input |= INPUT_CALL_GRAPH;
	      cg_read_rec (ifp, filename);
	      break;

	    case GMON_TAG_BB_COUNT:
	      ++nbbs;
	      gmon_input |= INPUT_BB_COUNTS;
	      bb_read_rec (ifp, filename);
	      break;

	    default:
	      fprintf (stderr,
		       _("%s: %s: found bad tag %d (file corrupted?)\n"),
		       whoami, filename, tag);
	      done (1);
	    }
	}
    }
  else if (file_format == FF_AUTO
	   || file_format == FF_BSD
	   || file_format == FF_BSD44)
    {
      struct hdr
      {
	bfd_vma low_pc;
	bfd_vma high_pc;
	unsigned int ncnt;
      };
      unsigned int i;
      int samp_bytes, header_size = 0;
      unsigned long count;
      bfd_vma from_pc, self_pc;
      UNIT raw_bin_count;
      struct hdr tmp;
      unsigned int version;
      unsigned int hist_num_bins;

      /* Information from a gmon.out file is in two parts: an array of
	 sampling hits within pc ranges, and the arcs.  */
      gmon_input = INPUT_HISTOGRAM | INPUT_CALL_GRAPH;

      /* This fseek() ought to work even on stdin as long as it's
	 not an interactive device (heck, is there anybody who would
	 want to type in a gmon.out at the terminal?).  */
      if (fseek (ifp, 0, SEEK_SET) < 0)
	{
	  perror (filename);
	  done (1);
	}

      /* The beginning of the old BSD header and the 4.4BSD header
	 are the same: lowpc, highpc, ncnt  */
      if (gmon_io_read_vma (ifp, &tmp.low_pc)
          || gmon_io_read_vma (ifp, &tmp.high_pc)
          || gmon_io_read_32 (ifp, &tmp.ncnt))
	{
 bad_gmon_file:
          fprintf (stderr, _("%s: file too short to be a gmon file\n"),
		   filename);
	  done (1);
	}

      /* Check to see if this a 4.4BSD-style header.  */
      if (gmon_io_read_32 (ifp, &version))
	goto bad_gmon_file;

      if (version == GMONVERSION)
	{
	  unsigned int profrate;

	  /* 4.4BSD format header.  */
          if (gmon_io_read_32 (ifp, &profrate))
	    goto bad_gmon_file;

	  if (!histograms)
	    hz = profrate;
	  else if (hz != (int) profrate)
	    {
	      fprintf (stderr,
		       _("%s: profiling rate incompatible with first gmon file\n"),
		       filename);
	      done (1);
	    }

	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_BSD44_64;
	      break;
	    }
	}
      else
	{
	  /* Old style BSD format.  */
	  if (file_format == FF_BSD44)
	    {
	      fprintf (stderr, _("%s: file `%s' has bad magic cookie\n"),
		       whoami, filename);
	      done (1);
	    }

	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      header_size = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      header_size = GMON_HDRSIZE_OLDBSD_64;
	      break;
	    }
	}

      /* Position the file to after the header.  */
      if (fseek (ifp, header_size, SEEK_SET) < 0)
	{
	  perror (filename);
	  done (1);
	}

      samp_bytes = tmp.ncnt - header_size;
      hist_num_bins = samp_bytes / sizeof (UNIT);
      if (histograms && (tmp.low_pc != histograms->lowpc
			 || tmp.high_pc != histograms->highpc
			 || (hist_num_bins != histograms->num_bins)))
	{
	  fprintf (stderr, _("%s: incompatible with first gmon file\n"),
		   filename);
	  done (1);
	}

      if (!histograms)
	{
	  num_histograms = 1;
	  histograms = (struct histogram *) xmalloc (sizeof (struct histogram));
	  histograms->lowpc = tmp.low_pc;
	  histograms->highpc = tmp.high_pc;
	  histograms->num_bins = hist_num_bins;
	  hist_scale = (double)((tmp.high_pc - tmp.low_pc) / sizeof (UNIT))
	    / hist_num_bins;
	  histograms->sample = (int *) xmalloc (hist_num_bins * sizeof (int));
	  memset (histograms->sample, 0, 
		  hist_num_bins * sizeof (int));
	}

      DBG (SAMPLEDEBUG,
	   printf ("[gmon_out_read] lowpc 0x%lx highpc 0x%lx ncnt %d\n",
		   (unsigned long) tmp.low_pc, (unsigned long) tmp.high_pc,
		   tmp.ncnt);
	   printf ("[gmon_out_read] samp_bytes %d hist_num_bins %d\n",
		   samp_bytes, hist_num_bins));

      /* Make sure that we have sensible values.  */
      if (samp_bytes < 0 || histograms->lowpc > histograms->highpc)
	{
	  fprintf (stderr,
	    _("%s: file '%s' does not appear to be in gmon.out format\n"),
	    whoami, filename);
	  done (1);
	}

      if (hist_num_bins)
	++nhist;

      for (i = 0; i < hist_num_bins; ++i)
	{
	  if (fread (raw_bin_count, sizeof (raw_bin_count), 1, ifp) != 1)
	    {
	      fprintf (stderr,
		       _("%s: unexpected EOF after reading %d/%d bins\n"),
		       whoami, --i, hist_num_bins);
	      done (1);
	    }

	  histograms->sample[i] 
	    += bfd_get_16 (core_bfd, (bfd_byte *) raw_bin_count);
	}

      /* The rest of the file consists of a bunch of
	 <from,self,count> tuples.  */
      while (gmon_read_raw_arc (ifp, &from_pc, &self_pc, &count) == 0)
	{
	  ++narcs;

	  DBG (SAMPLEDEBUG,
	     printf ("[gmon_out_read] frompc 0x%lx selfpc 0x%lx count %lu\n",
		     (unsigned long) from_pc, (unsigned long) self_pc, count));

	  /* Add this arc.  */
	  cg_tally (from_pc, self_pc, count);
	}

      if (hz == HZ_WRONG)
	{
	  /* How many ticks per second?  If we can't tell, report
	     time in ticks.  */
	  hz = hertz ();

	  if (hz == HZ_WRONG)
	    {
	      hz = 1;
	      fprintf (stderr, _("time is in ticks, not seconds\n"));
	    }
	}
    }
  else
    {
      fprintf (stderr, _("%s: don't know how to deal with file format %d\n"),
	       whoami, file_format);
      done (1);
    }

  if (ifp != stdin)
    fclose (ifp);

  if (output_style & STYLE_GMON_INFO)
    {
      printf (_("File `%s' (version %d) contains:\n"),
	      filename, gmon_file_version);
      printf (nhist == 1 ?
	      _("\t%d histogram record\n") :
	      _("\t%d histogram records\n"), nhist);
      printf (narcs == 1 ?
	      _("\t%d call-graph record\n") :
	      _("\t%d call-graph records\n"), narcs);
      printf (nbbs == 1 ?
	      _("\t%d basic-block count record\n") :
	      _("\t%d basic-block count records\n"), nbbs);
      first_output = FALSE;
    }
}


void
gmon_out_write (const char *filename)
{
  FILE *ofp;
  struct gmon_hdr ghdr;

  ofp = fopen (filename, FOPEN_WB);
  if (!ofp)
    {
      perror (filename);
      done (1);
    }

  if (file_format == FF_AUTO || file_format == FF_MAGIC)
    {
      /* Write gmon header.  */

      memcpy (&ghdr.cookie[0], GMON_MAGIC, 4);
      bfd_put_32 (core_bfd, (bfd_vma) GMON_VERSION, (bfd_byte *) ghdr.version);

      if (fwrite (&ghdr, sizeof (ghdr), 1, ofp) != 1)
	{
	  perror (filename);
	  done (1);
	}

      /* Write execution time histogram if we have one.  */
      if (gmon_input & INPUT_HISTOGRAM)
	hist_write_hist (ofp, filename);

      /* Write call graph arcs if we have any.  */
      if (gmon_input & INPUT_CALL_GRAPH)
	cg_write_arcs (ofp, filename);

      /* Write basic-block info if we have it.  */
      if (gmon_input & INPUT_BB_COUNTS)
	bb_write_blocks (ofp, filename);
    }
  else if (file_format == FF_BSD || file_format == FF_BSD44)
    {
      UNIT raw_bin_count;
      unsigned int i, hdrsize;
      unsigned padsize;
      char pad[3*4];
      Arc *arc;
      Sym *sym;

      memset (pad, 0, sizeof (pad));

      hdrsize = 0;
      /* Decide how large the header will be.  Use the 4.4BSD format
         header if explicitly specified, or if the profiling rate is
         non-standard.  Otherwise, use the old BSD format.  */
      if (file_format == FF_BSD44
	  || hz != hertz())
	{
	  padsize = 3*4;
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_BSD44_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_BSD44_64;
	      break;
	    }
	}
      else
	{
	  padsize = 0;
	  switch (gmon_get_ptr_size ())
	    {
	    case ptr_32bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_32;
	      break;

	    case ptr_64bit:
	      hdrsize = GMON_HDRSIZE_OLDBSD_64;
	      /* FIXME: Checking host compiler defines here means that we can't
		 use a cross gprof alpha OSF.  */ 
#if defined(__alpha__) && defined (__osf__)
	      padsize = 4;
#endif
	      break;
	    }
	}

      /* Write the parts of the headers that are common to both the
	 old BSD and 4.4BSD formats.  */
      if (gmon_io_write_vma (ofp, histograms->lowpc)
          || gmon_io_write_vma (ofp, histograms->highpc)
          || gmon_io_write_32 (ofp, histograms->num_bins 
			       * sizeof (UNIT) + hdrsize))
	{
	  perror (filename);
	  done (1);
	}

      /* Write out the 4.4BSD header bits, if that's what we're using.  */
      if (file_format == FF_BSD44
	  || hz != hertz())
	{
          if (gmon_io_write_32 (ofp, GMONVERSION)
	      || gmon_io_write_32 (ofp, (unsigned int) hz))
	    {
	      perror (filename);
	      done (1);
	    }
	}

      /* Now write out any necessary padding after the meaningful
	 header bits.  */
      if (padsize != 0
          && fwrite (pad, 1, padsize, ofp) != padsize)
        {
          perror (filename);
	  done (1);
	}

      /* Dump the samples.  */
      for (i = 0; i < histograms->num_bins; ++i)
	{
	  bfd_put_16 (core_bfd, (bfd_vma) histograms->sample[i],
		      (bfd_byte *) &raw_bin_count[0]);
	  if (fwrite (&raw_bin_count[0], sizeof (raw_bin_count), 1, ofp) != 1)
	    {
	      perror (filename);
	      done (1);
	    }
	}

      /* Dump the normalized raw arc information.  */
      for (sym = symtab.base; sym < symtab.limit; ++sym)
	{
	  for (arc = sym->cg.children; arc; arc = arc->next_child)
	    {
	      if (gmon_write_raw_arc (ofp, arc->parent->addr,
				      arc->child->addr, arc->count))
		{
		  perror (filename);
		  done (1);
		}
	      DBG (SAMPLEDEBUG,
		   printf ("[dumpsum] frompc 0x%lx selfpc 0x%lx count %lu\n",
			   (unsigned long) arc->parent->addr,
			   (unsigned long) arc->child->addr, arc->count));
	    }
	}

      fclose (ofp);
    }
  else
    {
      fprintf (stderr, _("%s: don't know how to deal with file format %d\n"),
	       whoami, file_format);
      done (1);
    }
}
@


1.28
log
@2010-03-16  Segher Boessenkool  <segher@@kernel.crashing.org>

        * gmon_io.c (gmon_out_read): Close file when done.
@
text
@a553 2
      fclose (ifp);

@


1.27
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d576 3
@


1.26
log
@	* gmon_io.h: Don't include sysdep.h here.
	(O_BINARY, SET_BINARY): Don't define here.
	* gmon_io.c: Include "binary-io.h".
	(gmon_out_read): Remove #ifdef SET_BINARY.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
@
text
@d496 1
a496 1
	  histograms = xmalloc (sizeof (struct histogram));
d502 1
a502 1
	  histograms->sample = xmalloc (hist_num_bins * sizeof (int));
@


1.26.8.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d496 1
a496 1
	  histograms = (struct histogram *) xmalloc (sizeof (struct histogram));
d502 1
a502 1
	  histograms->sample = (int *) xmalloc (hist_num_bins * sizeof (int));
@


1.25
log
@	* gmon_io.c (gmon_out_read): When reading old format gmon.out,
	set num_histograms and hist_scale.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
d24 1
a303 1
#ifdef SET_BINARY
a304 1
#endif
@


1.24
log
@CHange FSF sources over to GPLv3
@
text
@d496 1
d501 2
@


1.23
log
@	* hist.h (struct histogram)
	(histograms, num_histograms): New.
	* hist.c (find_histogram, find_histogram_for_pc)
	(read_histogram_header): New.
	(s_lowpc, s_highpc, lowpc, highpc, hist_num_bins)
	(hist_sample): Remove.
	(hist_read_rec): Use the above, and handle multiple
	histogram records with disjoint address ranges.
	(hist_write_hist): Support several histogram records.
	(scale_and_align_entries): Adjust for multiple histograms.
	(hist_assign_samples_1): New.
	(hist_assign_samples): Use the above.
	(hist_clip_symbol_address): New.
	* hist.h (hist_check_address)
	(hist_clip_symbol_address): Declare.
	* gmon_io.c (gmon_out_read, gmon_out_write): Adjust handling
	of legacy format for multiple histogram changes.
	* corefile.c (find_call): Check for core_text_space and
	clip symbol address range here.
	* vax.c	(vax_find_call): Don't check for
	core_text_space, or clip the symbol's address range here.
	Use hist_check_address to check call's target address.
	* sparc.c: Likewise.
	* tahoe.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise. Also use core_text_sect->vma as the base
	address for code accesses, just like other machine-specific
	routines do.
	* gprof.texi: Adjust for the new logic.
@
text
@d3 1
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.22
log
@Update the address of the FSF
@
text
@a390 1
      static struct hdr h;
d394 1
d433 1
a433 1
	  if (!s_highpc)
d483 5
a487 2
      if (s_highpc && (tmp.low_pc != h.low_pc
		       || tmp.high_pc != h.high_pc || tmp.ncnt != h.ncnt))
d494 10
a503 7
      h = tmp;
      s_lowpc = (bfd_vma) h.low_pc;
      s_highpc = (bfd_vma) h.high_pc;
      lowpc = (bfd_vma) h.low_pc / sizeof (UNIT);
      highpc = (bfd_vma) h.high_pc / sizeof (UNIT);
      samp_bytes = h.ncnt - header_size;
      hist_num_bins = samp_bytes / sizeof (UNIT);
d507 2
a508 6
		   (unsigned long) h.low_pc, (unsigned long) h.high_pc,
		   h.ncnt);
	   printf ("[gmon_out_read]   s_lowpc 0x%lx   s_highpc 0x%lx\n",
		   (unsigned long) s_lowpc, (unsigned long) s_highpc);
	   printf ("[gmon_out_read]     lowpc 0x%lx     highpc 0x%lx\n",
		   (unsigned long) lowpc, (unsigned long) highpc);
d513 1
a513 1
      if (samp_bytes < 0 || lowpc > highpc)
a523 8
      if (!hist_sample)
	{
	  hist_sample =
	    (int *) xmalloc (hist_num_bins * sizeof (hist_sample[0]));

	  memset (hist_sample, 0, hist_num_bins * sizeof (hist_sample[0]));
	}

d534 2
a535 1
	  hist_sample[i] += bfd_get_16 (core_bfd, (bfd_byte *) raw_bin_count);
d682 4
a685 3
      if (gmon_io_write_vma (ofp, s_lowpc)
          || gmon_io_write_vma (ofp, s_highpc)
          || gmon_io_write_32 (ofp, hist_num_bins * sizeof (UNIT) + hdrsize))
d713 1
a713 1
      for (i = 0; i < hist_num_bins; ++i)
d715 1
a715 1
	  bfd_put_16 (core_bfd, (bfd_vma) hist_sample[i],
@


1.22.2.1
log
@	Merge fido bits:
	2006-10-25  Kazu Hirata  <kazu@@codesourcery.com>

	gprof/
	* hist.c, hist.h: Fix formatting.

	gprof/
	* Makefile.in (corefile.o): Depend on hist.h.
	* corefile.c: Include hist.h.

	2006-10-06  Vladimir Prus  <vladimir@@codesourcery.com>

	* hist.h (struct histogram)
	(histograms, num_histograms): New.
	* hist.c (find_histogram, find_histogram_for_pc)
	(read_histogram_header): New.
	(s_lowpc, s_highpc, lowpc, highpc, hist_num_bins)
	(hist_sample): Remove.
	(hist_read_rec): Use the above, and handle multiple
	histogram records with disjoint address ranges.
	(hist_write_hist): Support several histogram records.
	(scale_and_align_entries): Adjust for multiple histograms.
	(hist_assign_samples_1): New.
	(hist_assign_samples): Use the above.
	(hist_clip_symbol_address): New.
	* hist.h (hist_check_address)
	(hist_clip_symbol_address): Declare.
	* gmon_io.c (gmon_out_read, gmon_out_write): Adjust handling
	of legacy format for multiple histogram changes.
	* corefile.c (find_call): Check for core_text_space and
	clip symbol address range here.
	* vax.c	(vax_find_call): Don't check for
	core_text_space, or clip the symbol's address range here.
	Use hist_check_address to check call's target address.
	* sparc.c: Likewise.
	* tahoe.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise. Also use core_text_sect->vma as the base
	address for code accesses, just like other machine-specific
	routines do.

	2006-08-03  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add -mfido as an alias for
	-mfido_a.

	2006-06-23  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (cpu_of_arch): Replace fido with
	fido_a.
	(archs): Likewise.
	(m68k_ip): Likewise.
	(select_control_regs): Likewise.
	(md_show_usage): Replace -mfido with -mfidoa.
	* include/opcode/m68k.h (fido): Rename to fido_a.
	* opcodes/m68k-opc.c (m68k_opcodes): Replace fido with fido_a.

	2006-06-22  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Replace fido with fido.
	* bfd/config.bfd: Likewise
	* gas/configure.tgt: Likewise.
	* gas/config/m68k-parse.h: Likewise.
	* gas/config/tc-m68k.c: Likewise.
	* gas/testsuite/gas/m68k/all.exp: Likewise.
	* gas/testsuite/gas/m68k/fido.d: Rename to fido.d.
	* gas/testsuite/gas/m68k/fido.s: Rename to fido.s.
	* include/opcode/m68k.h: Replace fido with fido.
	* ld/configure.tgt: Likewise.
	* opcodes/m68k-dis.c: Likewise.
	* opcodes/m68k-opc.c: Likewise.

	2005-08-01  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/m68k-parse.h (m68k_register): Add CAC and MBB.
	* gas/config/tc-m68k.c (fido_control_regs): New.
	(cpu_of_arch): Add fido.
	(archs): Add an entry for fido.
	(m68k_ip): Add warnings for uses of tbl[su]{n,}[bwl] on
	fido.  Recognize CAC and MBB.
	(init_tabl): Add CAC and MBB.
	(select_control_regs): Choose fido as the current chip
	when the current architecture is fido or when -mfido
	is given explicitly.
	* gas/testsuite/gas/m68k/all.exp: Disable operands, cas, and
	bitfield on fido-*-*.  Run fido on fido-*-*.
	* gas/testsuite/gas/m68k/fido.d: New.
	* gas/testsuite/gas/m68k/fido.s: Likewise.
	* include/opcode/m68k.h: Document new control registers CAC
	and MBB.
	* opcodes/m68k-dis.c (print_insn_arg): Add cac and mbb.
	* opcodes/m68k-opc.c (m68k_opcodes): Add sleep and trapx.

	2005-07-22  Kazu Hirata  <kazu@@codesourcery.com>

	* gas/config/tc-m68k.c (archs): Add fido as an OR of
	cpu32 and fido.
	(md_show_usage): Add -mfido.
	* include/opcode/m68k.h (fido): New.

	2005-07-11  Kazu Hirata  <kazu@@codesourcery.com>

	* config.sub: Recognize fido and fido-*.
	* bfd/config.bfd: Likewise.
	* gas/configure.tgt: Likewise.
	* ld/configure.tgt: Likewise.
@
text
@d391 1
a394 1
      unsigned int hist_num_bins;
d433 1
a433 1
	  if (!histograms)
d483 2
a484 5
      samp_bytes = tmp.ncnt - header_size;
      hist_num_bins = samp_bytes / sizeof (UNIT);
      if (histograms && (tmp.low_pc != histograms->lowpc
			 || tmp.high_pc != histograms->highpc
			 || (hist_num_bins != histograms->num_bins)))
d491 7
a497 11
      if (!histograms)
	{
	  histograms = (struct histogram *)malloc 
	    (sizeof (struct histogram));
	  histograms->lowpc = tmp.low_pc;
	  histograms->highpc = tmp.high_pc;
	  histograms->num_bins = hist_num_bins;
	  histograms->sample = (int *)malloc (hist_num_bins * sizeof (int));
	  memset (histograms->sample, 0, 
		  hist_num_bins * sizeof (int));
	}
d501 6
a506 2
		   (unsigned long) tmp.low_pc, (unsigned long) tmp.high_pc,
		   tmp.ncnt);
d511 1
a511 1
      if (samp_bytes < 0 || histograms->lowpc > histograms->highpc)
d522 8
d540 1
a540 2
	  histograms->sample[i] 
	    += bfd_get_16 (core_bfd, (bfd_byte *) raw_bin_count);
d687 3
a689 4
      if (gmon_io_write_vma (ofp, histograms->lowpc)
          || gmon_io_write_vma (ofp, histograms->highpc)
          || gmon_io_write_32 (ofp, histograms->num_bins 
			       * sizeof (UNIT) + hdrsize))
d717 1
a717 1
      for (i = 0; i < histograms->num_bins; ++i)
d719 1
a719 1
	  bfd_put_16 (core_bfd, (bfd_vma) histograms->sample[i],
@


1.21
log
@	* gmon_io.c (gmon_write_raw_arc): Return 1 for invalid size.
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.20
log
@update copyright dates
@
text
@d259 3
@


1.20.2.1
log
@	* gmon_io.c (gmon_write_raw_arc): Return 1 for invalid size.
@
text
@a258 3

    default:
      return 1;
@


1.19
log
@	* basic_blocks.c: Warning fixes.
	* gmon_io.c: Likewise.
	* hist.c: Likewise.
	* hist.h: Likewise.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2002, 2004, 2005 Free Software Foundation, Inc.
@


1.18
log
@	* alpha.c, basic_blocks.c, basic_blocks.h, bb_exit_func.c,
	call_graph.c, call_graph.h, cg_arcs.c, cg_arcs.h, cg_dfn.c,
	cg_dfn.h, cg_print.c, cg_print.h, corefile.c, corefile.h,
	gmon_io.c, gmon_io.h, gprof.c, gprof.h, hertz.h, hist.c, hist.h,
	i386.c, mips.c, search_list.c, search_list.h, source.c, source.h,
	sparc.c, sym_ids.c, sym_ids.h, symtab.c, symtab.h, tahoe.c,
	utils.c, utils.h, vax.c, gen-c-prog.awk: Convert K&R C to ANSI C.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2002 Free Software Foundation, Inc.
d381 1
a381 1
	int ncnt;
d383 2
a384 1
      int i, samp_bytes, header_size = 0;
d390 1
a390 1
      int version;
d423 1
a423 1
	  int profrate;
d431 1
a431 1
	  else if (hz != profrate)
d634 1
a634 1
      int i, hdrsize;
@


1.17
log
@2003-03-31  Chris Demetriou  <cgd@@broadcom.com>

        * gmon_io.c (enum gmon_ptr_size, enum gmon_ptr_signedness): New.
        (gmon_get_ptr_size, gmon_get_ptr_signedness): New.
        (gmon_io_read_vma, gmon_io_write_vma, gmon_read_raw_arc)
        (gmon_write_raw_arc, gmon_out_read, gmon_out_write): Adjust to
        use new functions and enums.
@
text
@d47 2
a48 2
static enum gmon_ptr_size gmon_get_ptr_size PARAMS ((void));
static enum gmon_ptr_signedness gmon_get_ptr_signedness PARAMS ((void));
d51 2
a52 2
static int gmon_io_read_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT *));
static int gmon_io_write_64 PARAMS ((FILE *, BFD_HOST_U_64_BIT));
d55 1
a55 1
  PARAMS ((FILE *, bfd_vma *, bfd_vma *, unsigned long *));
d57 1
a57 1
  PARAMS ((FILE *, bfd_vma, bfd_vma, unsigned long));
d101 1
a101 3
gmon_io_read_32 (ifp, valp)
     FILE *ifp;
     unsigned int *valp;
d113 1
a113 3
gmon_io_read_64 (ifp, valp)
     FILE *ifp;
     BFD_HOST_U_64_BIT *valp;
d125 1
a125 3
gmon_io_read_vma (ifp, valp)
     FILE *ifp;
     bfd_vma *valp;
d160 1
a160 4
gmon_io_read (ifp, buf, n)
     FILE *ifp;
     char *buf;
     size_t n;
d168 1
a168 3
gmon_io_write_32 (ofp, val)
     FILE *ofp;
     unsigned int val;
d180 1
a180 3
gmon_io_write_64 (ofp, val)
     FILE *ofp;	
     BFD_HOST_U_64_BIT val;
d192 1
a192 3
gmon_io_write_vma (ofp, val)
     FILE *ofp;
     bfd_vma val;
d213 1
a213 3
gmon_io_write_8 (ofp, val)
     FILE *ofp;	
     unsigned int val;
d224 1
a224 4
gmon_io_write (ofp, buf, n)
     FILE *ofp;	
     char *buf;
     size_t n;
d232 1
a232 5
gmon_read_raw_arc (ifp, fpc, spc, cnt)
     FILE *ifp;
     bfd_vma *fpc;
     bfd_vma *spc;
     unsigned long *cnt;
d263 1
a263 5
gmon_write_raw_arc (ofp, fpc, spc, cnt)
     FILE *ofp;
     bfd_vma fpc;
     bfd_vma spc;
     unsigned long cnt;
d288 1
a288 2
gmon_out_read (filename)
     const char *filename;
d593 1
a593 2
gmon_out_write (filename)
     const char *filename;
@


1.16
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d37 13
d62 38
d138 1
a138 1
  switch (bfd_arch_bits_per_address (core_bfd))
d140 1
a140 1
    case 32:
d143 4
a146 1
      *valp = val32;
d150 1
a150 1
    case 64:
d153 6
a158 1
      *valp = val64;
a160 5

    default:
      fprintf (stderr, _("%s: bits per address has unexpected value of %u\n"),
	       whoami, bfd_arch_bits_per_address (core_bfd));
      done (1);
d210 1
a210 1
  switch (bfd_arch_bits_per_address (core_bfd))
d212 1
a212 1
    case 32:
d218 1
a218 1
    case 64:
a222 5

    default:
      fprintf (stderr, _("%s: bits per address has unexpected value of %u\n"),
	       whoami, bfd_arch_bits_per_address (core_bfd));
      done (1);
d267 1
a267 1
  switch (bfd_arch_bits_per_address (core_bfd))
d269 1
a269 1
    case 32:
d276 1
a276 1
    case 64:
a281 5

    default:
      fprintf (stderr, _("%s: bits per address has unexpected value of %u\n"),
	       whoami, bfd_arch_bits_per_address (core_bfd));
      done (1);
d298 1
a298 1
  switch (bfd_arch_bits_per_address (core_bfd))
d300 1
a300 1
    case 32:
d306 1
a306 1
    case 64:
a310 5

    default:
      fprintf (stderr, _("%s: bits per address has unexpected value of %u\n"),
	       whoami, bfd_arch_bits_per_address (core_bfd));
      done (1);
d467 1
a467 1
	  switch (bfd_arch_bits_per_address (core_bfd))
d469 1
a469 1
	    case 32:
d473 1
a473 1
	    case 64:
a475 6

	    default:
              fprintf (stderr,
                       _("%s: bits per address has unexpected value of %u\n"),
	               whoami, bfd_arch_bits_per_address (core_bfd));
              done (1);
d488 1
a488 1
	  switch (bfd_arch_bits_per_address (core_bfd))
d490 1
a490 1
	    case 32:
d494 1
a494 1
	    case 64:
a496 6

	    default:
              fprintf (stderr,
                       _("%s: bits per address has unexpected value of %u\n"),
	               whoami, bfd_arch_bits_per_address (core_bfd));
              done (1);
d679 1
a679 1
	  switch (bfd_arch_bits_per_address (core_bfd))
d681 1
a681 1
	    case 32:
d685 1
a685 1
	    case 64:
a687 6

	    default:
              fprintf (stderr,
                       _("%s: bits per address has unexpected value of %u\n"),
	               whoami, bfd_arch_bits_per_address (core_bfd));
              done (1);
d693 1
a693 1
	  switch (bfd_arch_bits_per_address (core_bfd))
d695 1
a695 1
	    case 32:
d699 1
a699 1
	    case 64:
a706 6

	    default:
              fprintf (stderr,
                       _("%s: bits per address has unexpected value of %u\n"),
	               whoami, bfd_arch_bits_per_address (core_bfd));
              done (1);
@


1.15
log
@	* gmon_io.c (gmon_io_read_64, gmon_io_write_64): Define only if
	BFD_HOST_U_64_BIT is defined.
	(gmon_io_read_vma, gmon_io_write_vma): Add ifdefs.
@
text
@d589 1
a589 1
      first_output = false;
@


1.14
log
@	* alpha.c (alpha_find_call): Warning fixes.
	* mips.c (mips_find_call): Likewise.
	* sparc.c (sparc_find_call): Likewise.
	* basic_blocks.c: Warning fixes.  Eliminate DEFUN.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.cp: Likewise.
	* gprof.c: Likewise.
	* gprof.h: Likewise.
	* hist.c: Likewise.
	* search_list.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* symtab.h: Likewise.
	* utils.c: Likewise.
	* cg_print.c: Likewise.
	(struct function_map, symbol_map, symbol_map_count): Move
	declaration to..
	* corefile: ..here.
	* corefile.c: Warning fixes.  Eliminate DEFUN.
	(struct function_map): Remove declaration.
	* gmon_io.c: Warning fixes.  Eliminate DEFUN.
	(gmon_io_read_64): Make static.
	(gmon_io_write_64): Likewise.
	(gmon_read_raw_arc): Likewise.
	(gmon_write_raw_arc): Likewise.
	(gmon_io_write_8): Don't pass char, pass int param.
	* gmon_io.h (gmon_io_write_8): Likewise.

and a few copyright dates that should have been done previously.
@
text
@d37 1
d40 1
d62 1
d75 1
d83 1
d85 1
d95 1
d101 1
d135 1
d148 1
d163 1
d168 1
d209 1
d211 1
d226 1
d232 1
d261 1
d266 1
@


1.13
log
@	* basic_blocks.c: Replace bool with boolean, TRUE with true and
	FALSE with false throughout.
	* basic_blocks.h: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hist.c: Likewise.
	* mips.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* tahoe.c: Likewise.
	* vax.c: Likewise.
	* gprof.h: Likewise.
	(TRUE): Don't define.
	(FALSE): Don't define.
@
text
@d37 7
d48 3
a50 1
DEFUN (gmon_io_read_32, (ifp, valp), FILE * ifp AND unsigned int *valp)
d60 4
a63 2
int
DEFUN (gmon_io_read_64, (ifp, valp), FILE * ifp AND BFD_HOST_U_64_BIT *valp)
d74 3
a76 1
DEFUN (gmon_io_read_vma, (ifp, valp), FILE * ifp AND bfd_vma *valp)
d104 4
a107 1
DEFUN (gmon_io_read, (ifp, buf, n), FILE * ifp AND char *buf AND size_t n)
d115 3
a117 1
DEFUN (gmon_io_write_32, (ofp, val), FILE * ofp AND unsigned int val)
d121 1
a121 1
  bfd_put_32 (core_bfd, val, buf);
d127 4
a130 2
int
DEFUN (gmon_io_write_64, (ofp, val), FILE * ofp AND BFD_HOST_U_64_BIT val)
d134 1
a134 1
  bfd_put_64 (core_bfd, val, buf);
d141 3
a143 1
DEFUN (gmon_io_write_vma, (ofp, val), FILE * ofp AND bfd_vma val)
d167 3
a169 1
DEFUN (gmon_io_write_8, (ofp, val), FILE * ofp AND unsigned char val)
d180 4
a183 1
DEFUN (gmon_io_write, (ofp, buf, n), FILE * ofp AND char *buf AND size_t n)
d190 6
a195 2
int
DEFUN (gmon_read_raw_arc, (ifp, fpc, spc, cnt), FILE * ifp AND bfd_vma * fpc AND bfd_vma * spc AND unsigned long * cnt)
d226 6
a231 2
int
DEFUN (gmon_write_raw_arc, (ofp, fpc, spc, cnt), FILE * ofp AND bfd_vma fpc AND bfd_vma spc AND unsigned long cnt)
d259 2
a260 1
DEFUN (gmon_out_read, (filename), const char *filename)
d577 2
a578 1
DEFUN (gmon_out_write, (filename), const char *filename)
d595 1
a595 1
      bfd_put_32 (core_bfd, GMON_VERSION, (bfd_byte *) ghdr.version);
d692 1
a692 1
	      || gmon_io_write_32 (ofp, hz))
d711 2
a712 1
	  bfd_put_16 (core_bfd, hist_sample[i], (bfd_byte *) & raw_bin_count[0]);
@


1.12
log
@Deal with target architecture that have a pointer size that is different from
the host architectures pointer size.
@
text
@d535 1
a535 1
      first_output = FALSE;
@


1.11
log
@	* alpha.c (alpha_Instruction): Don't use.
	(alpha_find_call): Avoid use of bitfields and casts between
	pointers and integers of different sizes.  Avoid endian problems
	when cross-compiling.
	* vax.c (vax_find_call): Likewise.
	(struct modebyte): Don't use.
	(vax_operandmode): Pass in an unsigned char *.
	(vax_operandlength): Likewise.
	(vax_reladdr): Rename to vax_offset and return relative offset
	rather than address.
	* i386.c (i386_find_call): Avoid casts between pointers and
	integers of different sizes.
	* sparc.c (sparc_find_call): Likewise.  Avoid endian problems.
	* tahoe.c (tahoe_find_call): Likewise.
	(tahoe_reladdr): Rename to tahoe_offset and return relative offset
	rather than address.

	* basic_blocks.h: Don't include headers here.
	* call_graph.h: Likewise.
	* cg_arcs.h: Likewise.
	* cg_print.h: Likewise.
	* corefile.h: Likewise.
	* gmon_io.h: Likewise.
	* gmon_out.h: Likewise.
	* hertz.h: Likewise.
	* hist.h: Likewise.
	* source.h: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* gprof.h: Don't include ansidecl.h, do include bfd.h.
	(bool): Don't typedef.
	* alpha.c: Adjust #include's for above header changes.
	* basic_blocks.c: Likewise.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hertz.c: Likewise.
	* hist.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise.
	* sparc.c: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* tahoe.c: Likewise.
	* utils.c: Likewise.
	* vax.c: Likewise.

	* po/POTFILES.in: Regenerate.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d41 22
d65 2
a66 2
  char buf[8];
  bfd_vma val;
d68 1
a68 1
  switch (GMON_PTR_SIZE)
d70 2
a71 2
    case 4:
      if (fread (buf, 1, 4, ifp) != 4)
d73 1
a73 1
      val = bfd_get_32 (core_bfd, buf);
d76 2
a77 2
    case 8:
      if (fread (buf, 1, 8, ifp) != 8)
d79 1
a79 1
      val = bfd_get_64 (core_bfd, buf);
d83 2
a84 2
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
a86 1
  *valp = val;
d91 9
a99 1
DEFUN (gmon_io_read_32, (ifp, valp), FILE * ifp AND unsigned int *valp)
d103 2
a104 1
  if (fread (buf, 1, 4, ifp) != 4)
a105 1
  *valp = bfd_get_32 (core_bfd, buf);
d110 1
a110 1
DEFUN (gmon_io_read, (ifp, buf, n), FILE * ifp AND char *buf AND size_t n)
d112 4
a115 1
  if (fread (buf, 1, n, ifp) != n)
a122 1
  char buf[8];
d124 1
a124 1
  switch (GMON_PTR_SIZE)
d126 2
a127 3
    case 4:
      bfd_put_32 (core_bfd, val, buf);
      if (fwrite (buf, 1, 4, ofp) != 4)
d131 2
a132 3
    case 8:
      bfd_put_64 (core_bfd, val, buf);
      if (fwrite (buf, 1, 8, ofp) != 8)
d137 2
a138 2
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
a144 11
DEFUN (gmon_io_write_32, (ofp, val), FILE * ofp AND unsigned int val)
{
  char buf[4];

  bfd_put_32 (core_bfd, val, buf);
  if (fwrite (buf, 1, 4, ofp) != 4)
    return 1;
  return 0;
}

int
d163 24
a186 10
/* get_vma and put_vma are for backwards compatibility only */
static bfd_vma
DEFUN (get_vma, (abfd, addr), bfd * abfd AND bfd_byte * addr)
{
  switch (sizeof (char*))
    {
    case 4:
      return bfd_get_32 (abfd, addr);
    case 8:
      return bfd_get_64 (abfd, addr);
d188 2
a189 2
      fprintf (stderr, _("%s: bfd_vma has unexpected size of %ld bytes\n"),
	       whoami, (long) sizeof (char*));
d192 1
d195 2
a196 2
static void
DEFUN (put_vma, (abfd, val, addr), bfd * abfd AND bfd_vma val AND bfd_byte * addr)
d198 6
a203 1
  switch (sizeof (char*))
d205 3
a207 2
    case 4:
      bfd_put_32 (abfd, val, addr);
d209 4
a212 2
    case 8:
      bfd_put_64 (abfd, val, addr);
d214 1
d216 2
a217 2
      fprintf (stderr, _("%s: bfd_vma has unexpected size of %ld bytes\n"),
	       whoami, (long) sizeof (char*));
d220 1
d319 1
a319 1
      int i, samp_bytes, header_size;
a321 2
      struct raw_arc raw_arc;
      struct raw_phdr raw;
d325 1
d340 5
a344 2
      if (fread (&raw, 1, sizeof (struct raw_phdr), ifp)
	  != sizeof (struct raw_phdr))
d346 2
a347 1
	  fprintf (stderr, _("%s: file too short to be a gmon file\n"),
d352 3
a354 3
      tmp.low_pc = get_vma (core_bfd, (bfd_byte *) &raw.low_pc[0]);
      tmp.high_pc = get_vma (core_bfd, (bfd_byte *) &raw.high_pc[0]);
      tmp.ncnt = bfd_get_32 (core_bfd, (bfd_byte *) &raw.ncnt[0]);
d356 1
a356 2
      if (bfd_get_32 (core_bfd, (bfd_byte *) &raw.version[0])
	  == GMONVERSION)
d361 2
a362 1
	  profrate = bfd_get_32 (core_bfd, (bfd_byte *) &raw.profrate[0]);
d374 16
a389 1
	  header_size = sizeof (struct raw_phdr);
d401 1
a401 1
	  if (fseek (ifp, sizeof (struct old_raw_phdr), SEEK_SET) < 0)
d403 13
a415 2
	      perror (filename);
	      done (1);
d417 1
d419 5
a423 1
	  header_size = sizeof (struct old_raw_phdr);
d488 1
a488 1
      while (fread (&raw_arc, sizeof (raw_arc), 1, ifp) == 1)
a490 3
	  from_pc = get_vma (core_bfd, (bfd_byte *) raw_arc.from_pc);
	  self_pc = get_vma (core_bfd, (bfd_byte *) raw_arc.self_pc);
	  count = bfd_get_32 (core_bfd, (bfd_byte *) raw_arc.count);
a579 1
      struct raw_arc raw_arc;
d581 3
a583 2
      struct raw_phdr h;
      int i;
d587 6
a592 10
      memset (&h, 0, sizeof h);
      put_vma (core_bfd, s_lowpc, (bfd_byte *) &h.low_pc);
      put_vma (core_bfd, s_highpc, (bfd_byte *) &h.high_pc);
      bfd_put_32 (core_bfd,
		  hist_num_bins * sizeof (UNIT) + sizeof (struct raw_phdr),
		  (bfd_byte *) &h.ncnt);

      /* Write header.  Use new style BSD format is explicitly
	 specified, or if the profiling rate is non-standard;
	 otherwise, use the old BSD format.  */
d594 1
a594 1
	  || hz != hertz ())
d596 2
a597 3
	  bfd_put_32 (core_bfd, GMONVERSION, (bfd_byte *) &h.version);
	  bfd_put_32 (core_bfd, hz, (bfd_byte *) &h.profrate);
	  if (fwrite (&h, sizeof (struct raw_phdr), 1, ofp) != 1)
d599 13
a611 2
	      perror (filename);
	      done (1);
d616 40
a655 1
	  if (fwrite (&h, sizeof (struct old_raw_phdr), 1, ofp) != 1)
d662 9
d687 2
a688 6
	      put_vma (core_bfd, arc->parent->addr,
		       (bfd_byte *) raw_arc.from_pc);
	      put_vma (core_bfd, arc->child->addr,
		       (bfd_byte *) raw_arc.self_pc);
	      bfd_put_32 (core_bfd, arc->count, (bfd_byte *) raw_arc.count);
	      if (fwrite (&raw_arc, sizeof (raw_arc), 1, ofp) != 1)
@


1.10
log
@Remove use of ngettext()
@
text
@d22 4
a27 1
#include "bfd.h"
a32 1
#include "gprof.h"
@


1.9
log
@Fix spelling typo.
Reformat messages to ease translation into other languages.
@
text
@d450 9
a458 6
      printf (ngettext ("\t%d histogram record\n",
			"\t%d histogram records\n", nhist), nhist);
      printf (ngettext ("\t%d call-graph record\n",
			"\t%d call-graph records\n", narcs), narcs);
      printf (ngettext ("\t%d basic-block count record\n",
			"\t%d basic-block count records\n", nbbs), nbbs);
@


1.8
log
@* gmon_io.c (gmon_io_read, gmon_io_write_vma,
gmon_io_write_32, gmon_io_write_8, gmon_io_write): Adjust
argument list for K&R C.
@
text
@d450 6
a455 6
      printf (_("\t%d histogram record%s\n"),
	      nhist, nhist == 1 ? "" : "s");
      printf (_("\t%d call-graph record%s\n"),
	      narcs, narcs == 1 ? "" : "s");
      printf (_("\t%d basic-block count record%s\n"),
	      nbbs, nbbs == 1 ? "" : "s");
@


1.7
log
@David Mosberger's fixes for cross compiling gprof.
@
text
@d79 1
a79 1
DEFUN (gmon_io_read, (ifp, valp), FILE * ifp AND char *buf AND size_t n)
d87 1
a87 1
DEFUN (gmon_io_write_vma, (ofp, valp), FILE * ofp AND bfd_vma val)
d114 1
a114 1
DEFUN (gmon_io_write_32, (ofp, valp), FILE * ofp AND unsigned int val)
d125 1
a125 1
DEFUN (gmon_io_write_8, (ofp, valp), FILE * ofp AND unsigned char val)
d136 1
a136 1
DEFUN (gmon_io_write, (ofp, valp), FILE * ofp AND char *buf AND size_t n)
@


1.6
log
@Fix typos in ChangeLog; fix dates in copyright notices
@
text
@d3 1
a3 1
   Copyright 2000 Free Software Foundation, Inc.
d38 28
a65 1
/* This probably ought to be in libbfd.  */
d67 78
a144 1
bfd_vma
d160 1
a160 4

/* This probably ought to be in libbfd.  */

void
a177 1

d197 1
a197 1
      
d204 1
a204 1
  
d212 2
a213 2
  if ((file_format == FF_MAGIC) ||
      (file_format == FF_AUTO && !strncmp (&ghdr.cookie[0], GMON_MAGIC, 4)))
d224 1
a224 1
      
d284 1
a284 1
         sampling hits within pc ranges, and the arcs.  */
d288 2
a289 2
         not an interactive device (heck, is there anybody who would
         want to type in a gmon.out at the terminal?).  */
d295 1
a295 1
      
d303 1
a303 1
      
d315 1
a315 1
	  
d347 2
a348 2
      if (s_highpc && (tmp.low_pc != h.low_pc ||
		       tmp.high_pc != h.high_pc || tmp.ncnt != h.ncnt))
d354 1
a354 1
      
d362 1
a362 1
      
d376 2
a377 2
        {
          fprintf (stderr, 
d380 2
a381 2
          done (1);
        }
d390 1
a390 1
	  
d403 1
a403 1
	  
d415 1
a415 1
	  
d419 1
a419 1
	  
d423 1
a423 1
      
d431 1
a431 1
	  
d480 1
a480 1
      
d516 2
a517 2
         specified, or if the profiling rate is non-standard;
         otherwise, use the old BSD format.  */
d570 1
a570 1
      
@


1.5
log
@Add GPL copyright notices to uncopyrighted files.
Add copy of GPL.
@
text
@d3 1
a3 1
   Copyright (C) 2000  Free Software Foundation, Inc.
@


1.5.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
@


1.5.2.2
log
@Merge from mainline.
@
text
@d38 1
a38 28
int
DEFUN (gmon_io_read_vma, (ifp, valp), FILE * ifp AND bfd_vma *valp)
{
  char buf[8];
  bfd_vma val;

  switch (GMON_PTR_SIZE)
    {
    case 4:
      if (fread (buf, 1, 4, ifp) != 4)
	return 1;
      val = bfd_get_32 (core_bfd, buf);
      break;

    case 8:
      if (fread (buf, 1, 8, ifp) != 8)
	return 1;
      val = bfd_get_64 (core_bfd, buf);
      break;

    default:
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
      done (1);
    }
  *valp = val;
  return 0;
}
d40 1
a40 78
int
DEFUN (gmon_io_read_32, (ifp, valp), FILE * ifp AND unsigned int *valp)
{
  char buf[4];

  if (fread (buf, 1, 4, ifp) != 4)
    return 1;
  *valp = bfd_get_32 (core_bfd, buf);
  return 0;
}

int
DEFUN (gmon_io_read, (ifp, buf, n), FILE * ifp AND char *buf AND size_t n)
{
  if (fread (buf, 1, n, ifp) != n)
    return 1;
  return 0;
}

int
DEFUN (gmon_io_write_vma, (ofp, val), FILE * ofp AND bfd_vma val)
{
  char buf[8];

  switch (GMON_PTR_SIZE)
    {
    case 4:
      bfd_put_32 (core_bfd, val, buf);
      if (fwrite (buf, 1, 4, ofp) != 4)
	return 1;
      break;

    case 8:
      bfd_put_64 (core_bfd, val, buf);
      if (fwrite (buf, 1, 8, ofp) != 8)
	return 1;
      break;

    default:
      fprintf (stderr, _("%s: GMON_PTR_SIZE has unexpected value of %u\n"),
	       whoami, GMON_PTR_SIZE);
      done (1);
    }
  return 0;
}

int
DEFUN (gmon_io_write_32, (ofp, val), FILE * ofp AND unsigned int val)
{
  char buf[4];

  bfd_put_32 (core_bfd, val, buf);
  if (fwrite (buf, 1, 4, ofp) != 4)
    return 1;
  return 0;
}

int
DEFUN (gmon_io_write_8, (ofp, val), FILE * ofp AND unsigned char val)
{
  char buf[1];

  bfd_put_8 (core_bfd, val, buf);
  if (fwrite (buf, 1, 1, ofp) != 1)
    return 1;
  return 0;
}

int
DEFUN (gmon_io_write, (ofp, buf, n), FILE * ofp AND char *buf AND size_t n)
{
  if (fwrite (buf, 1, n, ofp) != n)
    return 1;
  return 0;
}

/* get_vma and put_vma are for backwards compatibility only */
static bfd_vma
d56 4
a59 1
static void
d77 1
d97 1
a97 1

d104 1
a104 1

d112 2
a113 2
  if ((file_format == FF_MAGIC)
      || (file_format == FF_AUTO && !strncmp (&ghdr.cookie[0], GMON_MAGIC, 4)))
d124 1
a124 1

d184 1
a184 1
	 sampling hits within pc ranges, and the arcs.  */
d188 2
a189 2
	 not an interactive device (heck, is there anybody who would
	 want to type in a gmon.out at the terminal?).  */
d195 1
a195 1

d203 1
a203 1

d215 1
a215 1

d247 2
a248 2
      if (s_highpc && (tmp.low_pc != h.low_pc
		       || tmp.high_pc != h.high_pc || tmp.ncnt != h.ncnt))
d254 1
a254 1

d262 1
a262 1

d276 2
a277 2
	{
	  fprintf (stderr,
d280 2
a281 2
	  done (1);
	}
d290 1
a290 1

d303 1
a303 1

d315 1
a315 1

d319 1
a319 1

d323 1
a323 1

d331 1
a331 1

d380 1
a380 1

d416 2
a417 2
	 specified, or if the profiling rate is non-standard;
	 otherwise, use the old BSD format.  */
d470 1
a470 1

@


1.4
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d1 21
a21 3
/*
 * Input and output from/to gmon.out files.
 */
d29 1
a29 1
#include "gmon.h"		/* fetch header for old format */
d36 3
a38 1
int gmon_file_version = 0;	/* 0 == old (non-versioned) file format */
a39 3
/*
 * This probably ought to be in libbfd.
 */
d57 2
a58 3
/*
 * This probably ought to be in libbfd.
 */
d86 1
a86 2
  /* open gmon.out file: */

d97 1
d104 1
d122 1
a122 2
      /* right magic, so it's probably really a new gmon.out file */

d124 1
d133 1
a133 1
      /* read in all the records: */
d183 2
a184 4
      /*
       * Information from a gmon.out file is in two parts: an array of
       * sampling hits within pc ranges, and the arcs.
       */
d187 3
a189 5
      /*
       * This fseek() ought to work even on stdin as long as it's
       * not an interactive device (heck, is there anybody who would
       * want to type in a gmon.out at the terminal?).
       */
d195 1
d203 1
a213 1

d215 1
d230 1
a230 1
	  /* old style BSD format.  */
d254 1
d262 1
d284 1
a284 3
	{
	  ++nhist;
	}
d290 1
d303 1
d307 2
a308 4
      /*
       * The rest of the file consists of a bunch of <from,self,count>
       * tuples:
       */
d315 1
d319 2
a320 1
	  /* add this arc: */
d323 1
d328 2
a329 4
	  /*
	   * How many ticks per second?  If we can't tell, report
	   * time in ticks.
	   */
d331 1
d376 1
a376 1
      /* write gmon header: */
d380 1
d387 1
a387 1
      /* write execution time histogram if we have one: */
d389 1
a389 3
	{
	  hist_write_hist (ofp, filename);
	}
d391 1
a391 1
      /* write call graph arcs if we have any: */
d393 1
a393 3
	{
	  cg_write_arcs (ofp, filename);
	}
d395 1
a395 1
      /* write basic-block info if we have it: */
d397 1
a397 3
	{
	  bb_write_blocks (ofp, filename);
	}
d438 1
a438 2
      /* dump the samples: */

d449 1
a449 2
      /* dump the normalized raw arc information: */

d470 1
@


1.3
log
@Make sure that sensible values are extracted from a raw header.
@
text
@d75 3
@


1.3.2.1
log
@Eli Zaretskii's DOSish file name patches.
@
text
@a74 3
#ifdef SET_BINARY
      SET_BINARY (fileno (stdin));
#endif
@


1.2
log
@	* Many files: Add casts in many print statements to cast bfd_vma
	values to unsigned long when calling printf.
	* Makefile.am ($(OBJECTS)): Add gmon.h.
	* Makefile.in: Rebuild.
@
text
@d254 9
@


1.1
log
@Initial revision
@
text
@d245 2
a246 1
		   h.low_pc, h.high_pc, h.ncnt);
d248 1
a248 1
		   s_lowpc, s_highpc);
d250 1
a250 1
		   lowpc, highpc);
d290 1
a290 1
		     from_pc, self_pc, count));
d444 2
a445 1
			   arc->parent->addr, arc->child->addr, arc->count));
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

