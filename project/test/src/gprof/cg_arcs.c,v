head	1.10;
access;
symbols
	binutils-2_24-branch:1.10.0.10
	binutils-2_24-branchpoint:1.10
	binutils-2_21_1:1.10
	binutils-2_23_2:1.10
	binutils-2_23_1:1.10
	binutils-2_23:1.10
	binutils-2_23-branch:1.10.0.8
	binutils-2_23-branchpoint:1.10
	binutils-2_22_branch:1.10.0.6
	binutils-2_22:1.10
	binutils-2_22-branch:1.10.0.4
	binutils-2_22-branchpoint:1.10
	binutils-2_21:1.10
	binutils-2_21-branch:1.10.0.2
	binutils-2_21-branchpoint:1.10
	binutils-2_20_1:1.9
	binutils-2_20:1.9
	binutils-arc-20081103-branch:1.9.0.10
	binutils-arc-20081103-branchpoint:1.9
	binutils-2_20-branch:1.9.0.8
	binutils-2_20-branchpoint:1.9
	dje-cgen-play1-branch:1.9.0.6
	dje-cgen-play1-branchpoint:1.9
	arc-20081103-branch:1.9.0.4
	arc-20081103-branchpoint:1.9
	binutils-2_19_1:1.9
	binutils-2_19:1.9
	binutils-2_19-branch:1.9.0.2
	binutils-2_19-branchpoint:1.9
	binutils-2_18:1.8
	binutils-2_18-branch:1.8.0.12
	binutils-2_18-branchpoint:1.8
	binutils-csl-coldfire-4_1-32:1.8
	binutils-csl-sourcerygxx-4_1-32:1.8
	binutils-csl-innovasic-fido-3_4_4-33:1.8
	binutils-csl-sourcerygxx-3_4_4-32:1.8
	binutils-csl-coldfire-4_1-30:1.8
	binutils-csl-sourcerygxx-4_1-30:1.8
	binutils-csl-coldfire-4_1-28:1.8
	binutils-csl-sourcerygxx-4_1-29:1.8
	binutils-csl-sourcerygxx-4_1-28:1.8
	binutils-csl-arm-2006q3-27:1.8
	binutils-csl-sourcerygxx-4_1-27:1.8
	binutils-csl-arm-2006q3-26:1.8
	binutils-csl-sourcerygxx-4_1-26:1.8
	binutils-csl-sourcerygxx-4_1-25:1.8
	binutils-csl-sourcerygxx-4_1-24:1.8
	binutils-csl-sourcerygxx-4_1-23:1.8
	binutils-csl-sourcerygxx-4_1-21:1.8
	binutils-csl-arm-2006q3-21:1.8
	binutils-csl-sourcerygxx-4_1-22:1.8
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.8
	binutils-csl-sourcerygxx-4_1-20:1.8
	binutils-csl-arm-2006q3-19:1.8
	binutils-csl-sourcerygxx-4_1-19:1.8
	binutils-csl-sourcerygxx-4_1-18:1.8
	binutils-csl-renesas-4_1-9:1.8
	binutils-csl-sourcerygxx-3_4_4-25:1.8
	binutils-csl-renesas-4_1-8:1.8
	binutils-csl-renesas-4_1-7:1.8
	binutils-csl-renesas-4_1-6:1.8
	binutils-csl-sourcerygxx-4_1-17:1.8
	binutils-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-15:1.8
	binutils-csl-sourcerygxx-4_1-13:1.8
	binutils-2_17:1.8
	binutils-csl-sourcerygxx-4_1-12:1.8
	binutils-csl-sourcerygxx-3_4_4-21:1.8
	binutils-csl-wrs-linux-3_4_4-24:1.8
	binutils-csl-wrs-linux-3_4_4-23:1.8
	binutils-csl-sourcerygxx-4_1-9:1.8
	binutils-csl-sourcerygxx-4_1-8:1.8
	binutils-csl-sourcerygxx-4_1-7:1.8
	binutils-csl-arm-2006q1-6:1.8
	binutils-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-wrs-linux-3_4_4-22:1.8
	binutils-csl-coldfire-4_1-11:1.8
	binutils-csl-sourcerygxx-3_4_4-19:1.8
	binutils-csl-coldfire-4_1-10:1.8
	binutils-csl-sourcerygxx-4_1-5:1.8
	binutils-csl-sourcerygxx-4_1-4:1.8
	binutils-csl-wrs-linux-3_4_4-21:1.8
	binutils-csl-morpho-4_1-4:1.8
	binutils-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-wrs-linux-3_4_4-20:1.8
	binutils-2_17-branch:1.8.0.10
	binutils-2_17-branchpoint:1.8
	binutils-csl-2_17-branch:1.8.0.8
	binutils-csl-2_17-branchpoint:1.8
	binutils-csl-gxxpro-3_4-branch:1.8.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.8
	binutils-2_16_1:1.8
	binutils-csl-arm-2005q1b:1.8
	binutils-2_16:1.8
	binutils-csl-arm-2005q1a:1.8
	binutils-csl-arm-2005q1-branch:1.8.0.4
	binutils-csl-arm-2005q1-branchpoint:1.8
	binutils-2_16-branch:1.8.0.2
	binutils-2_16-branchpoint:1.8
	csl-arm-2004-q3d:1.8
	csl-arm-2004-q3:1.8
	gprof-pre-ansify-2004-05-26:1.7
	gprof-post-ansify-2004-05-26:1.8
	binutils-2_15:1.7
	binutils-2_15-branchpoint:1.7
	csl-arm-2004-q1a:1.7
	csl-arm-2004-q1:1.7
	binutils-2_15-branch:1.7.0.8
	cagney_bfdfile-20040213-branch:1.7.0.6
	cagney_bfdfile-20040213-branchpoint:1.7
	cagney_bigcore-20040122-branch:1.7.0.4
	cagney_bigcore-20040122-branchpoint:1.7
	csl-arm-2003-q4:1.7
	binutils-2_14:1.7
	binutils-2_14-branch:1.7.0.2
	binutils-2_14-branchpoint:1.7
	binutils-2_13_2_1:1.5.4.1
	binutils-2_13_2:1.5.4.1
	binutils-2_13_1:1.5.4.1
	binutils-2_13:1.5.4.1
	binutils-2_13-branchpoint:1.5
	binutils-2_13-branch:1.5.0.4
	binutils-2_12_1:1.5
	binutils-2_12:1.5
	binutils-2_12-branch:1.5.0.2
	binutils-2_12-branchpoint:1.5
	cygnus_cvs_20020108_pre:1.2
	binutils-2_11_2:1.1.1.1.4.2
	binutils-2_11_1:1.1.1.1.4.2
	binutils-2_11:1.1.1.1
	x86_64versiong3:1.1.1.1
	binutils-2_11-branch:1.1.1.1.0.4
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.10
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.10
date	2009.12.11.13.42.12;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.19.16.30.29;	author schwab;	state Exp;
branches;
next	1.8;

1.8
date	2004.05.26.04.55.55;	author bje;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.30.09.07.00;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2002.02.01.08.24.15;	author amodra;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2002.02.01.01.18.06;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.31.12.56.06;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.14.03.14.56;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.5.4.1
date	2002.07.30.18.20.36;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.11;	author rth;	state Exp;
branches
	1.1.1.1.4.1;
next	;

1.1.1.1.4.1
date	2001.06.07.03.16.26;	author amodra;	state Exp;
branches;
next	1.1.1.1.4.2;

1.1.1.1.4.2
date	2001.06.11.10.05.03;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@/*
 * Copyright (c) 1983, 1993, 2001
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "gprof.h"
#include "libiberty.h"
#include "search_list.h"
#include "source.h"
#include "symtab.h"
#include "call_graph.h"
#include "cg_arcs.h"
#include "cg_dfn.h"
#include "cg_print.h"
#include "utils.h"
#include "sym_ids.h"

static int cmp_topo (const PTR, const PTR);
static void propagate_time (Sym *);
static void cycle_time (void);
static void cycle_link (void);
static void inherit_flags (Sym *);
static void propagate_flags (Sym **);
static int cmp_total (const PTR, const PTR);

Sym *cycle_header;
unsigned int num_cycles;
Arc **arcs;
unsigned int numarcs;

/*
 * Return TRUE iff PARENT has an arc to covers the address
 * range covered by CHILD.
 */
Arc *
arc_lookup (Sym *parent, Sym *child)
{
  Arc *arc;

  if (!parent || !child)
    {
      printf ("[arc_lookup] parent == 0 || child == 0\n");
      return 0;
    }
  DBG (LOOKUPDEBUG, printf ("[arc_lookup] parent %s child %s\n",
			    parent->name, child->name));
  for (arc = parent->cg.children; arc; arc = arc->next_child)
    {
      DBG (LOOKUPDEBUG, printf ("[arc_lookup]\t parent %s child %s\n",
				arc->parent->name, arc->child->name));
      if (child->addr >= arc->child->addr
	  && child->end_addr <= arc->child->end_addr)
	{
	  return arc;
	}
    }
  return 0;
}


/*
 * Add (or just increment) an arc:
 */
void
arc_add (Sym *parent, Sym *child, unsigned long count)
{
  static unsigned int maxarcs = 0;
  Arc *arc, **newarcs;

  DBG (TALLYDEBUG, printf ("[arc_add] %lu arcs from %s to %s\n",
			   count, parent->name, child->name));
  arc = arc_lookup (parent, child);
  if (arc)
    {
      /*
       * A hit: just increment the count.
       */
      DBG (TALLYDEBUG, printf ("[tally] hit %lu += %lu\n",
			       arc->count, count));
      arc->count += count;
      return;
    }
  arc = (Arc *) xmalloc (sizeof (*arc));
  memset (arc, 0, sizeof (*arc));
  arc->parent = parent;
  arc->child = child;
  arc->count = count;

  /* If this isn't an arc for a recursive call to parent, then add it
     to the array of arcs.  */
  if (parent != child)
    {
      /* If we've exhausted space in our current array, get a new one
	 and copy the contents.   We might want to throttle the doubling
	 factor one day.  */
      if (numarcs == maxarcs)
	{
	  /* Determine how much space we want to allocate.  */
	  if (maxarcs == 0)
	    maxarcs = 1;
	  maxarcs *= 2;

	  /* Allocate the new array.  */
	  newarcs = (Arc **)xmalloc(sizeof (Arc *) * maxarcs);

	  /* Copy the old array's contents into the new array.  */
	  memcpy (newarcs, arcs, numarcs * sizeof (Arc *));

	  /* Free up the old array.  */
	  free (arcs);

	  /* And make the new array be the current array.  */
	  arcs = newarcs;
	}

      /* Place this arc in the arc array.  */
      arcs[numarcs++] = arc;
    }

  /* prepend this child to the children of this parent: */
  arc->next_child = parent->cg.children;
  parent->cg.children = arc;

  /* prepend this parent to the parents of this child: */
  arc->next_parent = child->cg.parents;
  child->cg.parents = arc;
}


static int
cmp_topo (const PTR lp, const PTR rp)
{
  const Sym *left = *(const Sym **) lp;
  const Sym *right = *(const Sym **) rp;

  return left->cg.top_order - right->cg.top_order;
}


static void
propagate_time (Sym *parent)
{
  Arc *arc;
  Sym *child;
  double share, prop_share;

  if (parent->cg.prop.fract == 0.0)
    {
      return;
    }

  /* gather time from children of this parent: */

  for (arc = parent->cg.children; arc; arc = arc->next_child)
    {
      child = arc->child;
      if (arc->count == 0 || child == parent || child->cg.prop.fract == 0)
	{
	  continue;
	}
      if (child->cg.cyc.head != child)
	{
	  if (parent->cg.cyc.num == child->cg.cyc.num)
	    {
	      continue;
	    }
	  if (parent->cg.top_order <= child->cg.top_order)
	    {
	      fprintf (stderr, "[propagate] toporder botches\n");
	    }
	  child = child->cg.cyc.head;
	}
      else
	{
	  if (parent->cg.top_order <= child->cg.top_order)
	    {
	      fprintf (stderr, "[propagate] toporder botches\n");
	      continue;
	    }
	}
      if (child->ncalls == 0)
	{
	  continue;
	}

      /* distribute time for this arc: */
      arc->time = child->hist.time * (((double) arc->count)
				      / ((double) child->ncalls));
      arc->child_time = child->cg.child_time
	* (((double) arc->count) / ((double) child->ncalls));
      share = arc->time + arc->child_time;
      parent->cg.child_time += share;

      /* (1 - cg.prop.fract) gets lost along the way: */
      prop_share = parent->cg.prop.fract * share;

      /* fix things for printing: */
      parent->cg.prop.child += prop_share;
      arc->time *= parent->cg.prop.fract;
      arc->child_time *= parent->cg.prop.fract;

      /* add this share to the parent's cycle header, if any: */
      if (parent->cg.cyc.head != parent)
	{
	  parent->cg.cyc.head->cg.child_time += share;
	  parent->cg.cyc.head->cg.prop.child += prop_share;
	}
      DBG (PROPDEBUG,
	   printf ("[prop_time] child \t");
	   print_name (child);
	   printf (" with %f %f %lu/%lu\n", child->hist.time,
		   child->cg.child_time, arc->count, child->ncalls);
	   printf ("[prop_time] parent\t");
	   print_name (parent);
	   printf ("\n[prop_time] share %f\n", share));
    }
}


/*
 * Compute the time of a cycle as the sum of the times of all
 * its members.
 */
static void
cycle_time ()
{
  Sym *member, *cyc;

  for (cyc = &cycle_header[1]; cyc <= &cycle_header[num_cycles]; ++cyc)
    {
      for (member = cyc->cg.cyc.next; member; member = member->cg.cyc.next)
	{
	  if (member->cg.prop.fract == 0.0)
	    {
	      /*
	       * All members have the same propfraction except those
	       * that were excluded with -E.
	       */
	      continue;
	    }
	  cyc->hist.time += member->hist.time;
	}
      cyc->cg.prop.self = cyc->cg.prop.fract * cyc->hist.time;
    }
}


static void
cycle_link ()
{
  Sym *sym, *cyc, *member;
  Arc *arc;
  int num;

  /* count the number of cycles, and initialize the cycle lists: */

  num_cycles = 0;
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      /* this is how you find unattached cycles: */
      if (sym->cg.cyc.head == sym && sym->cg.cyc.next)
	{
	  ++num_cycles;
	}
    }

  /*
   * cycle_header is indexed by cycle number: i.e. it is origin 1,
   * not origin 0.
   */
  cycle_header = (Sym *) xmalloc ((num_cycles + 1) * sizeof (Sym));

  /*
   * Now link cycles to true cycle-heads, number them, accumulate
   * the data for the cycle.
   */
  num = 0;
  cyc = cycle_header;
  for (sym = symtab.base; sym < symtab.limit; ++sym)
    {
      if (!(sym->cg.cyc.head == sym && sym->cg.cyc.next != 0))
	{
	  continue;
	}
      ++num;
      ++cyc;
      sym_init (cyc);
      cyc->cg.print_flag = TRUE;	/* should this be printed? */
      cyc->cg.top_order = DFN_NAN;	/* graph call chain top-sort order */
      cyc->cg.cyc.num = num;	/* internal number of cycle on */
      cyc->cg.cyc.head = cyc;	/* pointer to head of cycle */
      cyc->cg.cyc.next = sym;	/* pointer to next member of cycle */
      DBG (CYCLEDEBUG, printf ("[cycle_link] ");
	   print_name (sym);
	   printf (" is the head of cycle %d\n", num));

      /* link members to cycle header: */
      for (member = sym; member; member = member->cg.cyc.next)
	{
	  member->cg.cyc.num = num;
	  member->cg.cyc.head = cyc;
	}

      /*
       * Count calls from outside the cycle and those among cycle
       * members:
       */
      for (member = sym; member; member = member->cg.cyc.next)
	{
	  for (arc = member->cg.parents; arc; arc = arc->next_parent)
	    {
	      if (arc->parent == member)
		{
		  continue;
		}
	      if (arc->parent->cg.cyc.num == num)
		{
		  cyc->cg.self_calls += arc->count;
		}
	      else
		{
		  cyc->ncalls += arc->count;
		}
	    }
	}
    }
}


/*
 * Check if any parent of this child (or outside parents of this
 * cycle) have their print flags on and set the print flag of the
 * child (cycle) appropriately.  Similarly, deal with propagation
 * fractions from parents.
 */
static void
inherit_flags (Sym *child)
{
  Sym *head, *parent, *member;
  Arc *arc;

  head = child->cg.cyc.head;
  if (child == head)
    {
      /* just a regular child, check its parents: */
      child->cg.print_flag = FALSE;
      child->cg.prop.fract = 0.0;
      for (arc = child->cg.parents; arc; arc = arc->next_parent)
	{
	  parent = arc->parent;
	  if (child == parent)
	    {
	      continue;
	    }
	  child->cg.print_flag |= parent->cg.print_flag;
	  /*
	   * If the child was never actually called (e.g., this arc
	   * is static (and all others are, too)) no time propagates
	   * along this arc.
	   */
	  if (child->ncalls != 0)
	    {
	      child->cg.prop.fract += parent->cg.prop.fract
		* (((double) arc->count) / ((double) child->ncalls));
	    }
	}
    }
  else
    {
      /*
       * Its a member of a cycle, look at all parents from outside
       * the cycle.
       */
      head->cg.print_flag = FALSE;
      head->cg.prop.fract = 0.0;
      for (member = head->cg.cyc.next; member; member = member->cg.cyc.next)
	{
	  for (arc = member->cg.parents; arc; arc = arc->next_parent)
	    {
	      if (arc->parent->cg.cyc.head == head)
		{
		  continue;
		}
	      parent = arc->parent;
	      head->cg.print_flag |= parent->cg.print_flag;
	      /*
	       * If the cycle was never actually called (e.g. this
	       * arc is static (and all others are, too)) no time
	       * propagates along this arc.
	       */
	      if (head->ncalls != 0)
		{
		  head->cg.prop.fract += parent->cg.prop.fract
		    * (((double) arc->count) / ((double) head->ncalls));
		}
	    }
	}
      for (member = head; member; member = member->cg.cyc.next)
	{
	  member->cg.print_flag = head->cg.print_flag;
	  member->cg.prop.fract = head->cg.prop.fract;
	}
    }
}


/*
 * In one top-to-bottom pass over the topologically sorted symbols
 * propagate:
 *      cg.print_flag as the union of parents' print_flags
 *      propfraction as the sum of fractional parents' propfractions
 * and while we're here, sum time for functions.
 */
static void
propagate_flags (Sym **symbols)
{
  int sym_index;
  Sym *old_head, *child;

  old_head = 0;
  for (sym_index = symtab.len - 1; sym_index >= 0; --sym_index)
    {
      child = symbols[sym_index];
      /*
       * If we haven't done this function or cycle, inherit things
       * from parent.  This way, we are linear in the number of arcs
       * since we do all members of a cycle (and the cycle itself)
       * as we hit the first member of the cycle.
       */
      if (child->cg.cyc.head != old_head)
	{
	  old_head = child->cg.cyc.head;
	  inherit_flags (child);
	}
      DBG (PROPDEBUG,
	   printf ("[prop_flags] ");
	   print_name (child);
	   printf ("inherits print-flag %d and prop-fract %f\n",
		   child->cg.print_flag, child->cg.prop.fract));
      if (!child->cg.print_flag)
	{
	  /*
	   * Printflag is off. It gets turned on by being in the
	   * INCL_GRAPH table, or there being an empty INCL_GRAPH
	   * table and not being in the EXCL_GRAPH table.
	   */
	  if (sym_lookup (&syms[INCL_GRAPH], child->addr)
	      || (syms[INCL_GRAPH].len == 0
		  && !sym_lookup (&syms[EXCL_GRAPH], child->addr)))
	    {
	      child->cg.print_flag = TRUE;
	    }
	}
      else
	{
	  /*
	   * This function has printing parents: maybe someone wants
	   * to shut it up by putting it in the EXCL_GRAPH table.
	   * (But favor INCL_GRAPH over EXCL_GRAPH.)
	   */
	  if (!sym_lookup (&syms[INCL_GRAPH], child->addr)
	      && sym_lookup (&syms[EXCL_GRAPH], child->addr))
	    {
	      child->cg.print_flag = FALSE;
	    }
	}
      if (child->cg.prop.fract == 0.0)
	{
	  /*
	   * No parents to pass time to.  Collect time from children
	   * if its in the INCL_TIME table, or there is an empty
	   * INCL_TIME table and its not in the EXCL_TIME table.
	   */
	  if (sym_lookup (&syms[INCL_TIME], child->addr)
	      || (syms[INCL_TIME].len == 0
		  && !sym_lookup (&syms[EXCL_TIME], child->addr)))
	    {
	      child->cg.prop.fract = 1.0;
	    }
	}
      else
	{
	  /*
	   * It has parents to pass time to, but maybe someone wants
	   * to shut it up by puttting it in the EXCL_TIME table.
	   * (But favor being in INCL_TIME tabe over being in
	   * EXCL_TIME table.)
	   */
	  if (!sym_lookup (&syms[INCL_TIME], child->addr)
	      && sym_lookup (&syms[EXCL_TIME], child->addr))
	    {
	      child->cg.prop.fract = 0.0;
	    }
	}
      child->cg.prop.self = child->hist.time * child->cg.prop.fract;
      print_time += child->cg.prop.self;
      DBG (PROPDEBUG,
	   printf ("[prop_flags] ");
	   print_name (child);
	   printf (" ends up with printflag %d and prop-fract %f\n",
		   child->cg.print_flag, child->cg.prop.fract);
	   printf ("[prop_flags] time %f propself %f print_time %f\n",
		   child->hist.time, child->cg.prop.self, print_time));
    }
}


/*
 * Compare by decreasing propagated time.  If times are equal, but one
 * is a cycle header, say that's first (e.g. less, i.e. -1).  If one's
 * name doesn't have an underscore and the other does, say that one is
 * first.  All else being equal, compare by names.
 */
static int
cmp_total (const PTR lp, const PTR rp)
{
  const Sym *left = *(const Sym **) lp;
  const Sym *right = *(const Sym **) rp;
  double diff;

  diff = (left->cg.prop.self + left->cg.prop.child)
    - (right->cg.prop.self + right->cg.prop.child);
  if (diff < 0.0)
    {
      return 1;
    }
  if (diff > 0.0)
    {
      return -1;
    }
  if (!left->name && left->cg.cyc.num != 0)
    {
      return -1;
    }
  if (!right->name && right->cg.cyc.num != 0)
    {
      return 1;
    }
  if (!left->name)
    {
      return -1;
    }
  if (!right->name)
    {
      return 1;
    }
  if (left->name[0] != '_' && right->name[0] == '_')
    {
      return -1;
    }
  if (left->name[0] == '_' && right->name[0] != '_')
    {
      return 1;
    }
  if (left->ncalls > right->ncalls)
    {
      return -1;
    }
  if (left->ncalls < right->ncalls)
    {
      return 1;
    }
  return strcmp (left->name, right->name);
}


/* Topologically sort the graph (collapsing cycles), and propagates
   time bottom up and flags top down.  */

Sym **
cg_assemble (void)
{
  Sym *parent, **time_sorted_syms, **top_sorted_syms;
  unsigned int sym_index;
  Arc *arc;

  /* Initialize various things:
       Zero out child times.
       Count self-recursive calls.
       Indicate that nothing is on cycles.  */
  for (parent = symtab.base; parent < symtab.limit; parent++)
    {
      parent->cg.child_time = 0.0;
      arc = arc_lookup (parent, parent);
      if (arc && parent == arc->child)
	{
	  parent->ncalls -= arc->count;
	  parent->cg.self_calls = arc->count;
	}
      else
	{
	  parent->cg.self_calls = 0;
	}
      parent->cg.prop.fract = 0.0;
      parent->cg.prop.self = 0.0;
      parent->cg.prop.child = 0.0;
      parent->cg.print_flag = FALSE;
      parent->cg.top_order = DFN_NAN;
      parent->cg.cyc.num = 0;
      parent->cg.cyc.head = parent;
      parent->cg.cyc.next = 0;
      if (ignore_direct_calls)
	find_call (parent, parent->addr, (parent + 1)->addr);
    }

  /* Topologically order things.  If any node is unnumbered, number
     it and any of its descendents.  */
  for (parent = symtab.base; parent < symtab.limit; parent++)
    {
      if (parent->cg.top_order == DFN_NAN)
	cg_dfn (parent);
    }

  /* Link together nodes on the same cycle.  */
  cycle_link ();

  /* Sort the symbol table in reverse topological order.  */
  top_sorted_syms = (Sym **) xmalloc (symtab.len * sizeof (Sym *));
  for (sym_index = 0; sym_index < symtab.len; ++sym_index)
    top_sorted_syms[sym_index] = &symtab.base[sym_index];

  qsort (top_sorted_syms, symtab.len, sizeof (Sym *), cmp_topo);
  DBG (DFNDEBUG,
       printf ("[cg_assemble] topological sort listing\n");
       for (sym_index = 0; sym_index < symtab.len; ++sym_index)
	 {
	   printf ("[cg_assemble] ");
	   printf ("%d:", top_sorted_syms[sym_index]->cg.top_order);
	   print_name (top_sorted_syms[sym_index]);
	   printf ("\n");
	 }
  );

  /* Starting from the topological top, propagate print flags to
     children.  also, calculate propagation fractions.  this happens
     before time propagation since time propagation uses the
     fractions.  */
  propagate_flags (top_sorted_syms);

  /* Starting from the topological bottom, propogate children times
     up to parents.  */
  cycle_time ();
  for (sym_index = 0; sym_index < symtab.len; ++sym_index)
    propagate_time (top_sorted_syms[sym_index]);

  free (top_sorted_syms);

  /* Now, sort by CG.PROP.SELF + CG.PROP.CHILD.  Sorting both the regular
     function names and cycle headers.  */
  time_sorted_syms = (Sym **) xmalloc ((symtab.len + num_cycles) * sizeof (Sym *));
  for (sym_index = 0; sym_index < symtab.len; sym_index++)
    time_sorted_syms[sym_index] = &symtab.base[sym_index];

  for (sym_index = 1; sym_index <= num_cycles; sym_index++)
    time_sorted_syms[symtab.len + sym_index - 1] = &cycle_header[sym_index];

  qsort (time_sorted_syms, symtab.len + num_cycles, sizeof (Sym *),
	 cmp_total);

  for (sym_index = 0; sym_index < symtab.len + num_cycles; sym_index++)
    time_sorted_syms[sym_index]->cg.index = sym_index + 1;

  return time_sorted_syms;
}
@


1.9
log
@* basic_blocks.c: Always include "gprof.h" first.
* cg_arcs.c: Likewise.
* cg_dfn.c: Likewise.
* cg_print.c: Likewise.
* corefile.c: Likewise.
* gprof.c: Likewise.
* hist.c: Likewise.
* search_list.c: Likewise.
* sym_ids.c: Likewise.
* utils.c: Likewise.
@
text
@d440 1
a440 1
  int index;
d444 1
a444 1
  for (index = symtab.len - 1; index >= 0; --index)
d446 1
a446 1
      child = symbols[index];
d590 3
a592 4
/*
 * Topologically sort the graph (collapsing cycles), and propagates
 * time bottom up and flags top down.
 */
d594 1
a594 1
cg_assemble ()
d597 1
a597 1
  unsigned int index;
d600 4
a603 6
  /*
   * initialize various things:
   *      zero out child times.
   *      count self-recursive calls.
   *      indicate that nothing is on cycles.
   */
d626 1
a626 3
	{
	  find_call (parent, parent->addr, (parent + 1)->addr);
	}
d628 3
a630 4
  /*
   * Topologically order things.  If any node is unnumbered, number
   * it and any of its descendents.
   */
d634 1
a634 3
	{
	  cg_dfn (parent);
	}
d637 1
a637 1
  /* link together nodes on the same cycle: */
d640 1
a640 1
  /* sort the symbol table in reverse topological order: */
d642 3
a644 4
  for (index = 0; index < symtab.len; ++index)
    {
      top_sorted_syms[index] = &symtab.base[index];
    }
d648 7
a654 7
       for (index = 0; index < symtab.len; ++index)
       {
       printf ("[cg_assemble] ");
       printf ("%d:", top_sorted_syms[index]->cg.top_order);
       print_name (top_sorted_syms[index]);
       printf ("\n");
       }
d656 5
a660 6
  /*
   * Starting from the topological top, propagate print flags to
   * children.  also, calculate propagation fractions.  this happens
   * before time propagation since time propagation uses the
   * fractions.
   */
d663 2
a664 4
  /*
   * Starting from the topological bottom, propogate children times
   * up to parents.
   */
d666 2
a667 4
  for (index = 0; index < symtab.len; ++index)
    {
      propagate_time (top_sorted_syms[index]);
    }
d671 2
a672 4
  /*
   * Now, sort by CG.PROP.SELF + CG.PROP.CHILD.  Sorting both the regular
   * function names and cycle headers.
   */
d674 6
a679 8
  for (index = 0; index < symtab.len; index++)
    {
      time_sorted_syms[index] = &symtab.base[index];
    }
  for (index = 1; index <= num_cycles; index++)
    {
      time_sorted_syms[symtab.len + index - 1] = &cycle_header[index];
    }
d682 4
a685 4
  for (index = 0; index < symtab.len + num_cycles; index++)
    {
      time_sorted_syms[index]->cg.index = index + 1;
    }
@


1.8
log
@	* alpha.c, basic_blocks.c, basic_blocks.h, bb_exit_func.c,
	call_graph.c, call_graph.h, cg_arcs.c, cg_arcs.h, cg_dfn.c,
	cg_dfn.h, cg_print.c, cg_print.h, corefile.c, corefile.h,
	gmon_io.c, gmon_io.h, gprof.c, gprof.h, hertz.h, hist.c, hist.h,
	i386.c, mips.c, search_list.c, search_list.h, source.c, source.h,
	sparc.c, sym_ids.c, sym_ids.h, symtab.c, symtab.h, tahoe.c,
	utils.c, utils.h, vax.c, gen-c-prog.awk: Convert K&R C to ANSI C.
@
text
@d29 1
a30 1
#include "gprof.h"
@


1.7
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d41 7
a47 7
static int cmp_topo PARAMS ((const PTR, const PTR));
static void propagate_time PARAMS ((Sym *));
static void cycle_time PARAMS ((void));
static void cycle_link PARAMS ((void));
static void inherit_flags PARAMS ((Sym *));
static void propagate_flags PARAMS ((Sym **));
static int cmp_total PARAMS ((const PTR, const PTR));
d59 1
a59 3
arc_lookup (parent, child)
     Sym *parent;
     Sym *child;
d88 1
a88 4
arc_add (parent, child, count)
     Sym *parent;
     Sym *child;
     unsigned long count;
d154 1
a154 3
cmp_topo (lp, rp)
     const PTR lp;
     const PTR rp;
d164 1
a164 2
propagate_time (parent)
     Sym *parent;
d360 1
a360 2
inherit_flags (child)
     Sym *child;
d438 1
a438 2
propagate_flags (symbols)
     Sym **symbols;
d538 1
a538 3
cmp_total (lp, rp)
     const PTR lp;
     const PTR rp;
@


1.6
log
@Update copyright notice
@
text
@d319 1
a319 1
      cyc->cg.print_flag = true;	/* should this be printed? */
d378 1
a378 1
      child->cg.print_flag = false;
d406 1
a406 1
      head->cg.print_flag = false;
d484 1
a484 1
	      child->cg.print_flag = true;
d497 1
a497 1
	      child->cg.print_flag = false;
d635 1
a635 1
      parent->cg.print_flag = false;
@


1.5
log
@	* alpha.c (alpha_find_call): Warning fixes.
	* mips.c (mips_find_call): Likewise.
	* sparc.c (sparc_find_call): Likewise.
	* basic_blocks.c: Warning fixes.  Eliminate DEFUN.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.cp: Likewise.
	* gprof.c: Likewise.
	* gprof.h: Likewise.
	* hist.c: Likewise.
	* search_list.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* symtab.h: Likewise.
	* utils.c: Likewise.
	* cg_print.c: Likewise.
	(struct function_map, symbol_map, symbol_map_count): Move
	declaration to..
	* corefile: ..here.
	* corefile.c: Warning fixes.  Eliminate DEFUN.
	(struct function_map): Remove declaration.
	* gmon_io.c: Warning fixes.  Eliminate DEFUN.
	(gmon_io_read_64): Make static.
	(gmon_io_write_64): Likewise.
	(gmon_read_raw_arc): Likewise.
	(gmon_write_raw_arc): Likewise.
	(gmon_io_write_8): Don't pass char, pass int param.
	* gmon_io.h (gmon_io_write_8): Likewise.

and a few copyright dates that should have been done previously.
@
text
@d2 2
a3 2
 * Copyright (c) 1983, 2001 Regents of the University of California.
 * All rights reserved.
d5 23
a27 13
 * Redistribution and use in source and binary forms are permitted
 * provided that: (1) source distributions retain this entire copyright
 * notice and comment, and (2) distributions including binaries display
 * the following acknowledgement:  ``This product includes software
 * developed by the University of California, Berkeley and its contributors''
 * in the documentation or other materials provided with the distribution
 * and in all advertising materials mentioning features or use of this
 * software. Neither the name of the University nor the names of its
 * contributors may be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
@


1.5.4.1
log
@        Merge from mainline:
        2002-07-30  Nick Clifton  <nickc@@redhat.com>
        * po/tr.po: Updated Turkish translation.

        2002-07-30  Nick Clifton  <nickc@@redhat.com>
        * alpha.c, cg_arcs.c, cg_dfn.c, gmon.h, gprof.c, gprof.h, hertz.c,
        i386.c, mips.c, sparc.c, tahoe.c, utils.c, vax.c: Update Copyright
        notice so that it applies even if the sources are modified.
@
text
@d2 2
a3 2
 * Copyright (c) 1983, 1993, 2001
 *      The Regents of the University of California.  All rights reserved.
d5 13
a17 23
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
@


1.4
log
@	* basic_blocks.c: Replace bool with boolean, TRUE with true and
	FALSE with false throughout.
	* basic_blocks.h: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hist.c: Likewise.
	* mips.c: Likewise.
	* source.c: Likewise.
	* source.h: Likewise.
	* sym_ids.c: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* tahoe.c: Likewise.
	* vax.c: Likewise.
	* gprof.h: Likewise.
	(TRUE): Don't define.
	(FALSE): Don't define.
@
text
@d31 8
d49 3
a51 1
DEFUN (arc_lookup, (parent, child), Sym * parent AND Sym * child)
d80 4
a83 2
DEFUN (arc_add, (parent, child, count),
       Sym * parent AND Sym * child AND unsigned long count)
d149 3
a151 1
DEFUN (cmp_topo, (lp, rp), const PTR lp AND const PTR rp)
d161 2
a162 1
DEFUN (propagate_time, (parent), Sym * parent)
d246 1
a246 1
DEFUN_VOID (cycle_time)
d270 1
a270 1
DEFUN_VOID (cycle_link)
d358 2
a359 1
DEFUN (inherit_flags, (child), Sym * child)
d437 2
a438 1
DEFUN (propagate_flags, (symbols), Sym ** symbols)
d538 3
a540 1
DEFUN (cmp_total, (lp, rp), const PTR lp AND const PTR rp)
d597 1
a597 1
DEFUN_VOID (cg_assemble)
@


1.3
log
@	* alpha.c (alpha_Instruction): Don't use.
	(alpha_find_call): Avoid use of bitfields and casts between
	pointers and integers of different sizes.  Avoid endian problems
	when cross-compiling.
	* vax.c (vax_find_call): Likewise.
	(struct modebyte): Don't use.
	(vax_operandmode): Pass in an unsigned char *.
	(vax_operandlength): Likewise.
	(vax_reladdr): Rename to vax_offset and return relative offset
	rather than address.
	* i386.c (i386_find_call): Avoid casts between pointers and
	integers of different sizes.
	* sparc.c (sparc_find_call): Likewise.  Avoid endian problems.
	* tahoe.c (tahoe_find_call): Likewise.
	(tahoe_reladdr): Rename to tahoe_offset and return relative offset
	rather than address.

	* basic_blocks.h: Don't include headers here.
	* call_graph.h: Likewise.
	* cg_arcs.h: Likewise.
	* cg_print.h: Likewise.
	* corefile.h: Likewise.
	* gmon_io.h: Likewise.
	* gmon_out.h: Likewise.
	* hertz.h: Likewise.
	* hist.h: Likewise.
	* source.h: Likewise.
	* sym_ids.h: Likewise.
	* symtab.h: Likewise.
	* gprof.h: Don't include ansidecl.h, do include bfd.h.
	(bool): Don't typedef.
	* alpha.c: Adjust #include's for above header changes.
	* basic_blocks.c: Likewise.
	* call_graph.c: Likewise.
	* cg_arcs.c: Likewise.
	* cg_dfn.c: Likewise.
	* cg_print.c: Likewise.
	* corefile.c: Likewise.
	* gmon_io.c: Likewise.
	* gprof.c: Likewise.
	* hertz.c: Likewise.
	* hist.c: Likewise.
	* i386.c: Likewise.
	* mips.c: Likewise.
	* sparc.c: Likewise.
	* sym_ids.c: Likewise.
	* symtab.c: Likewise.
	* tahoe.c: Likewise.
	* utils.c: Likewise.
	* vax.c: Likewise.

	* po/POTFILES.in: Regenerate.
@
text
@d294 1
a294 1
      cyc->cg.print_flag = TRUE;	/* should this be printed? */
d352 1
a352 1
      child->cg.print_flag = FALSE;
d380 1
a380 1
      head->cg.print_flag = FALSE;
d457 1
a457 1
	      child->cg.print_flag = TRUE;
d470 1
a470 1
	      child->cg.print_flag = FALSE;
d606 1
a606 1
      parent->cg.print_flag = FALSE;
@


1.2
log
@David Mosberger's fixes for cross compiling gprof.
@
text
@d21 3
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
 * Copyright (c) 1983 Regents of the University of California.
d105 1
a105 1
	
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.4.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
 * Copyright (c) 1983, 2001 Regents of the University of California.
@


1.1.1.1.4.2
log
@Merge from mainline.
@
text
@d105 1
a105 1

@


