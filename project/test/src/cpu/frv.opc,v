head	1.19;
access;
symbols
	sid-snapshot-20180601:1.19
	cgen-snapshot-20180601:1.19
	sid-snapshot-20180501:1.19
	cgen-snapshot-20180501:1.19
	sid-snapshot-20180401:1.19
	cgen-snapshot-20180401:1.19
	sid-snapshot-20180301:1.19
	cgen-snapshot-20180301:1.19
	sid-snapshot-20180201:1.19
	cgen-snapshot-20180201:1.19
	sid-snapshot-20180101:1.19
	cgen-snapshot-20180101:1.19
	sid-snapshot-20171201:1.19
	cgen-snapshot-20171201:1.19
	sid-snapshot-20171101:1.19
	cgen-snapshot-20171101:1.19
	sid-snapshot-20171001:1.19
	cgen-snapshot-20171001:1.19
	sid-snapshot-20170901:1.19
	cgen-snapshot-20170901:1.19
	sid-snapshot-20170801:1.19
	cgen-snapshot-20170801:1.19
	sid-snapshot-20170701:1.19
	cgen-snapshot-20170701:1.19
	sid-snapshot-20170601:1.19
	cgen-snapshot-20170601:1.19
	sid-snapshot-20170501:1.19
	cgen-snapshot-20170501:1.19
	sid-snapshot-20170401:1.19
	cgen-snapshot-20170401:1.19
	sid-snapshot-20170301:1.19
	cgen-snapshot-20170301:1.19
	sid-snapshot-20170201:1.19
	cgen-snapshot-20170201:1.19
	sid-snapshot-20170101:1.19
	cgen-snapshot-20170101:1.19
	sid-snapshot-20161201:1.19
	cgen-snapshot-20161201:1.19
	sid-snapshot-20161101:1.19
	cgen-snapshot-20161101:1.19
	sid-snapshot-20160901:1.19
	cgen-snapshot-20160901:1.19
	sid-snapshot-20160801:1.19
	cgen-snapshot-20160801:1.19
	sid-snapshot-20160701:1.19
	cgen-snapshot-20160701:1.19
	sid-snapshot-20160601:1.19
	cgen-snapshot-20160601:1.19
	sid-snapshot-20160501:1.19
	cgen-snapshot-20160501:1.19
	sid-snapshot-20160401:1.19
	cgen-snapshot-20160401:1.19
	sid-snapshot-20160301:1.19
	cgen-snapshot-20160301:1.19
	sid-snapshot-20160201:1.19
	cgen-snapshot-20160201:1.19
	sid-snapshot-20160101:1.19
	cgen-snapshot-20160101:1.19
	sid-snapshot-20151201:1.19
	cgen-snapshot-20151201:1.19
	sid-snapshot-20151101:1.19
	cgen-snapshot-20151101:1.19
	sid-snapshot-20151001:1.19
	cgen-snapshot-20151001:1.19
	sid-snapshot-20150901:1.19
	cgen-snapshot-20150901:1.19
	sid-snapshot-20150801:1.19
	cgen-snapshot-20150801:1.19
	sid-snapshot-20150701:1.19
	cgen-snapshot-20150701:1.19
	sid-snapshot-20150601:1.19
	cgen-snapshot-20150601:1.19
	sid-snapshot-20150501:1.19
	cgen-snapshot-20150501:1.19
	sid-snapshot-20150401:1.19
	cgen-snapshot-20150401:1.19
	sid-snapshot-20150301:1.19
	cgen-snapshot-20150301:1.19
	sid-snapshot-20150201:1.19
	cgen-snapshot-20150201:1.19
	sid-snapshot-20150101:1.19
	cgen-snapshot-20150101:1.19
	sid-snapshot-20141201:1.19
	cgen-snapshot-20141201:1.19
	sid-snapshot-20141101:1.19
	cgen-snapshot-20141101:1.19
	sid-snapshot-20141001:1.19
	cgen-snapshot-20141001:1.19
	sid-snapshot-20140901:1.19
	cgen-snapshot-20140901:1.19
	sid-snapshot-20140801:1.19
	cgen-snapshot-20140801:1.19
	sid-snapshot-20140701:1.19
	cgen-snapshot-20140701:1.19
	sid-snapshot-20140601:1.19
	cgen-snapshot-20140601:1.19
	sid-snapshot-20140501:1.19
	cgen-snapshot-20140501:1.19
	sid-snapshot-20140401:1.19
	cgen-snapshot-20140401:1.19
	sid-snapshot-20140301:1.19
	cgen-snapshot-20140301:1.19
	sid-snapshot-20140201:1.19
	cgen-snapshot-20140201:1.19
	sid-snapshot-20140101:1.19
	cgen-snapshot-20140101:1.19
	sid-snapshot-20131201:1.19
	cgen-snapshot-20131201:1.19
	sid-snapshot-20131101:1.19
	cgen-snapshot-20131101:1.19
	sid-snapshot-20131001:1.19
	cgen-snapshot-20131001:1.19
	binutils-2_24-branch:1.19.0.8
	binutils-2_24-branchpoint:1.19
	binutils-2_21_1:1.18
	sid-snapshot-20130901:1.19
	cgen-snapshot-20130901:1.19
	gdb_7_6_1-2013-08-30-release:1.19
	sid-snapshot-20130801:1.19
	cgen-snapshot-20130801:1.19
	sid-snapshot-20130701:1.19
	cgen-snapshot-20130701:1.19
	sid-snapshot-20130601:1.19
	cgen-snapshot-20130601:1.19
	sid-snapshot-20130501:1.19
	cgen-snapshot-20130501:1.19
	gdb_7_6-2013-04-26-release:1.19
	sid-snapshot-20130401:1.19
	cgen-snapshot-20130401:1.19
	binutils-2_23_2:1.19
	gdb_7_6-branch:1.19.0.6
	gdb_7_6-2013-03-12-branchpoint:1.19
	sid-snapshot-20130301:1.19
	cgen-snapshot-20130301:1.19
	sid-snapshot-20130201:1.19
	cgen-snapshot-20130201:1.19
	sid-snapshot-20130101:1.19
	cgen-snapshot-20130101:1.19
	sid-snapshot-20121201:1.19
	cgen-snapshot-20121201:1.19
	gdb_7_5_1-2012-11-29-release:1.19
	binutils-2_23_1:1.19
	sid-snapshot-20121101:1.19
	cgen-snapshot-20121101:1.19
	binutils-2_23:1.19
	sid-snapshot-20121001:1.19
	cgen-snapshot-20121001:1.19
	sid-snapshot-20120901:1.19
	cgen-snapshot-20120901:1.19
	gdb_7_5-2012-08-17-release:1.19
	sid-snapshot-20120801:1.19
	cgen-snapshot-20120801:1.19
	binutils-2_23-branch:1.19.0.4
	binutils-2_23-branchpoint:1.19
	gdb_7_5-branch:1.19.0.2
	gdb_7_5-2012-07-18-branchpoint:1.19
	sid-snapshot-20120701:1.19
	cgen-snapshot-20120701:1.19
	sid-snapshot-20120601:1.19
	cgen-snapshot-20120601:1.19
	sid-snapshot-20120501:1.19
	cgen-snapshot-20120501:1.19
	binutils-2_22_branch:1.18.0.10
	gdb_7_4_1-2012-04-26-release:1.18
	sid-snapshot-20120401:1.19
	cgen-snapshot-20120401:1.19
	sid-snapshot-20120301:1.19
	cgen-snapshot-20120301:1.19
	sid-snapshot-20120201:1.19
	cgen-snapshot-20120201:1.19
	gdb_7_4-2012-01-24-release:1.18
	sid-snapshot-20120101:1.19
	cgen-snapshot-20120101:1.19
	gdb_7_4-branch:1.18.0.8
	gdb_7_4-2011-12-13-branchpoint:1.18
	sid-snapshot-20111201:1.18
	cgen-snapshot-20111201:1.18
	binutils-2_22:1.18
	sid-snapshot-20111101:1.18
	cgen-snapshot-20111101:1.18
	sid-snapshot-20111001:1.18
	cgen-snapshot-20111001:1.18
	binutils-2_22-branch:1.18.0.6
	binutils-2_22-branchpoint:1.18
	gdb_7_3_1-2011-09-04-release:1.18
	sid-snapshot-20110901:1.18
	cgen-snapshot-20110901:1.18
	sid-snapshot-20110801:1.18
	cgen-snapshot-20110801:1.18
	gdb_7_3-2011-07-26-release:1.18
	sid-snapshot-20110701:1.18
	cgen-snapshot-20110701:1.18
	sid-snapshot-20110601:1.18
	cgen-snapshot-20110601:1.18
	sid-snapshot-20110501:1.18
	cgen-snapshot-20110501:1.18
	gdb_7_3-branch:1.18.0.4
	gdb_7_3-2011-04-01-branchpoint:1.18
	sid-snapshot-20110401:1.18
	cgen-snapshot-20110401:1.18
	sid-snapshot-20110301:1.18
	cgen-snapshot-20110301:1.18
	sid-snapshot-20110201:1.18
	cgen-snapshot-20110201:1.18
	sid-snapshot-20110101:1.18
	cgen-snapshot-20110101:1.18
	binutils-2_21:1.18
	sid-snapshot-20101201:1.18
	cgen-snapshot-20101201:1.18
	binutils-2_21-branch:1.18.0.2
	binutils-2_21-branchpoint:1.18
	sid-snapshot-20101101:1.18
	cgen-snapshot-20101101:1.18
	sid-snapshot-20101001:1.17
	cgen-snapshot-20101001:1.17
	binutils-2_20_1:1.16
	gdb_7_2-2010-09-02-release:1.17
	sid-snapshot-20100901:1.17
	cgen-snapshot-20100901:1.17
	sid-snapshot-20100801:1.17
	cgen-snapshot-20100801:1.17
	gdb_7_2-branch:1.17.0.4
	gdb_7_2-2010-07-07-branchpoint:1.17
	sid-snapshot-20100701:1.17
	cgen-snapshot-20100701:1.17
	sid-snapshot-20100601:1.17
	cgen-snapshot-20100601:1.17
	sid-snapshot-20100501:1.17
	cgen-snapshot-20100501:1.17
	sid-snapshot-20100401:1.17
	cgen-snapshot-20100401:1.17
	gdb_7_1-2010-03-18-release:1.17
	sid-snapshot-20100301:1.17
	cgen-snapshot-20100301:1.17
	gdb_7_1-branch:1.17.0.2
	gdb_7_1-2010-02-18-branchpoint:1.17
	sid-snapshot-20100201:1.17
	cgen-snapshot-20100201:1.17
	sid-snapshot-20100101:1.17
	cgen-snapshot-20100101:1.17
	gdb_7_0_1-2009-12-22-release:1.16
	sid-snapshot-20091201:1.16
	cgen-snapshot-20091201:1.16
	sid-snapshot-20091101:1.16
	cgen-snapshot-20091101:1.16
	binutils-2_20:1.16
	gdb_7_0-2009-10-06-release:1.16
	sid-snapshot-20091001:1.16
	cgen-snapshot-20091001:1.16
	gdb_7_0-branch:1.16.0.4
	gdb_7_0-2009-09-16-branchpoint:1.16
	arc-sim-20090309:1.15
	binutils-arc-20081103-branch:1.15.0.32
	binutils-arc-20081103-branchpoint:1.15
	binutils-2_20-branch:1.16.0.2
	binutils-2_20-branchpoint:1.16
	sid-snapshot-20090901:1.15
	cgen-snapshot-20090901:1.15
	sid-snapshot-20090801:1.15
	cgen-snapshot-20090801:1.15
	msnyder-checkpoint-072509-branch:1.15.0.30
	msnyder-checkpoint-072509-branchpoint:1.15
	sid-snapshot-20090701:1.15
	cgen-snapshot-20090701:1.15
	dje-cgen-play1-branch:1.15.0.28
	dje-cgen-play1-branchpoint:1.15
	cgen-1_1-branch:1.15.0.26
	cgen-1_1-branchpoint:1.15
	sid-snapshot-20090601:1.15
	cgen-snapshot-20090601:1.15
	sid-snapshot-20090501:1.15
	cgen-snapshot-20090501:1.15
	sid-snapshot-20090401:1.15
	cgen-snapshot-20090401:1.15
	arc-20081103-branch:1.15.0.24
	arc-20081103-branchpoint:1.15
	arc-insight_6_8-branch:1.15.0.22
	arc-insight_6_8-branchpoint:1.15
	insight_6_8-branch:1.15.0.20
	insight_6_8-branchpoint:1.15
	sid-snapshot-20090301:1.15
	cgen-snapshot-20090301:1.15
	binutils-2_19_1:1.15
	sid-snapshot-20090201:1.15
	cgen-snapshot-20090201:1.15
	sid-snapshot-20090101:1.15
	cgen-snapshot-20090101:1.15
	reverse-20081226-branch:1.15.0.18
	reverse-20081226-branchpoint:1.15
	sid-snapshot-20081201:1.15
	cgen-snapshot-20081201:1.15
	multiprocess-20081120-branch:1.15.0.16
	multiprocess-20081120-branchpoint:1.15
	sid-snapshot-20081101:1.15
	cgen-snapshot-20081101:1.15
	binutils-2_19:1.15
	sid-snapshot-20081001:1.15
	cgen-snapshot-20081001:1.15
	reverse-20080930-branch:1.15.0.14
	reverse-20080930-branchpoint:1.15
	binutils-2_19-branch:1.15.0.12
	binutils-2_19-branchpoint:1.15
	sid-snapshot-20080901:1.15
	cgen-snapshot-20080901:1.15
	sid-snapshot-20080801:1.15
	cgen-snapshot-20080801:1.15
	reverse-20080717-branch:1.15.0.10
	reverse-20080717-branchpoint:1.15
	sid-snapshot-20080701:1.15
	cgen-snapshot-20080701:1.15
	msnyder-reverse-20080609-branch:1.15.0.8
	msnyder-reverse-20080609-branchpoint:1.15
	drow-reverse-20070409-branch:1.14.0.30
	drow-reverse-20070409-branchpoint:1.14
	sid-snapshot-20080601:1.15
	cgen-snapshot-20080601:1.15
	sid-snapshot-20080501:1.15
	cgen-snapshot-20080501:1.15
	sid-snapshot-20080403:1.15
	sid-snapshot-20080401:1.15
	cgen-snapshot-20080401:1.15
	gdb_6_8-2008-03-27-release:1.15
	sid-snapshot-20080301:1.15
	cgen-snapshot-20080301:1.15
	gdb_6_8-branch:1.15.0.6
	gdb_6_8-2008-02-26-branchpoint:1.15
	sid-snapshot-20080201:1.15
	cgen-snapshot-20080201:1.15
	sid-snapshot-20080101:1.15
	cgen-snapshot-20080101:1.15
	sid-snapshot-20071201:1.15
	cgen-snapshot-20071201:1.15
	sid-snapshot-20071101:1.15
	cgen-snapshot-20071101:1.15
	gdb_6_7_1-2007-10-29-release:1.15
	gdb_6_7-2007-10-10-release:1.15
	sid-snapshot-20071001:1.15
	cgen-snapshot-20071001:1.15
	gdb_6_7-branch:1.15.0.4
	gdb_6_7-2007-09-07-branchpoint:1.15
	binutils-2_18:1.15
	binutils-2_18-branch:1.15.0.2
	binutils-2_18-branchpoint:1.15
	insight_6_6-20070208-release:1.14
	binutils-csl-coldfire-4_1-32:1.14
	binutils-csl-sourcerygxx-4_1-32:1.14
	gdb_6_6-2006-12-18-release:1.14
	binutils-csl-innovasic-fido-3_4_4-33:1.14
	binutils-csl-sourcerygxx-3_4_4-32:1.11
	binutils-csl-coldfire-4_1-30:1.14
	binutils-csl-sourcerygxx-4_1-30:1.14
	binutils-csl-coldfire-4_1-28:1.14
	binutils-csl-sourcerygxx-4_1-29:1.14
	binutils-csl-sourcerygxx-4_1-28:1.14
	gdb_6_6-branch:1.14.0.28
	gdb_6_6-2006-11-15-branchpoint:1.14
	binutils-csl-arm-2006q3-27:1.14
	binutils-csl-sourcerygxx-4_1-27:1.14
	binutils-csl-arm-2006q3-26:1.14
	binutils-csl-sourcerygxx-4_1-26:1.14
	binutils-csl-sourcerygxx-4_1-25:1.14
	binutils-csl-sourcerygxx-4_1-24:1.14
	binutils-csl-sourcerygxx-4_1-23:1.14
	insight_6_5-20061003-release:1.14
	gdb-csl-symbian-6_4_50_20060226-12:1.14
	binutils-csl-sourcerygxx-4_1-21:1.14
	binutils-csl-arm-2006q3-21:1.14
	binutils-csl-sourcerygxx-4_1-22:1.14
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.14
	binutils-csl-sourcerygxx-4_1-20:1.14
	binutils-csl-arm-2006q3-19:1.14
	binutils-csl-sourcerygxx-4_1-19:1.14
	binutils-csl-sourcerygxx-4_1-18:1.14
	binutils-csl-renesas-4_1-9:1.14
	gdb-csl-sourcerygxx-3_4_4-25:1.14
	binutils-csl-sourcerygxx-3_4_4-25:1.11
	nickrob-async-20060828-mergepoint:1.14
	gdb-csl-symbian-6_4_50_20060226-11:1.14
	binutils-csl-renesas-4_1-8:1.14
	binutils-csl-renesas-4_1-7:1.14
	binutils-csl-renesas-4_1-6:1.14
	gdb-csl-sourcerygxx-4_1-17:1.14
	binutils-csl-sourcerygxx-4_1-17:1.14
	gdb-csl-20060226-branch-local-2:1.14
	gdb-csl-sourcerygxx-4_1-14:1.14
	binutils-csl-sourcerygxx-4_1-14:1.14
	binutils-csl-sourcerygxx-4_1-15:1.14
	gdb-csl-sourcerygxx-4_1-13:1.14
	binutils-csl-sourcerygxx-4_1-13:1.14
	binutils-2_17:1.14
	gdb-csl-sourcerygxx-4_1-12:1.14
	binutils-csl-sourcerygxx-4_1-12:1.14
	gdb-csl-sourcerygxx-3_4_4-21:1.14
	binutils-csl-sourcerygxx-3_4_4-21:1.14
	gdb_6_5-20060621-release:1.14
	binutils-csl-wrs-linux-3_4_4-24:1.11
	binutils-csl-wrs-linux-3_4_4-23:1.11
	gdb-csl-sourcerygxx-4_1-9:1.14
	binutils-csl-sourcerygxx-4_1-9:1.14
	gdb-csl-sourcerygxx-4_1-8:1.14
	binutils-csl-sourcerygxx-4_1-8:1.14
	gdb-csl-sourcerygxx-4_1-7:1.14
	binutils-csl-sourcerygxx-4_1-7:1.14
	gdb-csl-arm-2006q1-6:1.14
	binutils-csl-arm-2006q1-6:1.14
	gdb-csl-sourcerygxx-4_1-6:1.14
	binutils-csl-sourcerygxx-4_1-6:1.14
	binutils-csl-wrs-linux-3_4_4-22:1.11
	gdb-csl-symbian-6_4_50_20060226-10:1.14
	gdb-csl-symbian-6_4_50_20060226-9:1.14
	gdb-csl-symbian-6_4_50_20060226-8:1.14
	gdb-csl-coldfire-4_1-11:1.14
	binutils-csl-coldfire-4_1-11:1.14
	gdb-csl-sourcerygxx-3_4_4-19:1.14
	binutils-csl-sourcerygxx-3_4_4-19:1.14
	gdb-csl-coldfire-4_1-10:1.14
	gdb_6_5-branch:1.14.0.26
	gdb_6_5-2006-05-14-branchpoint:1.14
	binutils-csl-coldfire-4_1-10:1.14
	gdb-csl-sourcerygxx-4_1-5:1.14
	binutils-csl-sourcerygxx-4_1-5:1.14
	nickrob-async-20060513-branch:1.14.0.24
	nickrob-async-20060513-branchpoint:1.14
	gdb-csl-sourcerygxx-4_1-4:1.14
	binutils-csl-sourcerygxx-4_1-4:1.14
	msnyder-reverse-20060502-branch:1.14.0.22
	msnyder-reverse-20060502-branchpoint:1.14
	binutils-csl-wrs-linux-3_4_4-21:1.11
	gdb-csl-morpho-4_1-4:1.14
	binutils-csl-morpho-4_1-4:1.14
	gdb-csl-sourcerygxx-3_4_4-17:1.14
	binutils-csl-sourcerygxx-3_4_4-17:1.14
	binutils-csl-wrs-linux-3_4_4-20:1.11
	readline_5_1-import-branch:1.14.0.20
	readline_5_1-import-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.14
	binutils-2_17-branch:1.14.0.18
	binutils-2_17-branchpoint:1.14
	gdb-csl-symbian-20060226-branch:1.14.0.16
	gdb-csl-symbian-20060226-branchpoint:1.14
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.14
	msnyder-reverse-20060331-branch:1.14.0.14
	msnyder-reverse-20060331-branchpoint:1.14
	binutils-csl-2_17-branch:1.14.0.12
	binutils-csl-2_17-branchpoint:1.14
	gdb-csl-available-20060303-branch:1.14.0.10
	gdb-csl-available-20060303-branchpoint:1.14
	gdb-csl-20060226-branch:1.14.0.8
	gdb-csl-20060226-branchpoint:1.14
	gdb_6_4-20051202-release:1.14
	msnyder-fork-checkpoint-branch:1.14.0.6
	msnyder-fork-checkpoint-branchpoint:1.14
	gdb-csl-gxxpro-6_3-branch:1.14.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.14
	gdb_6_4-branch:1.14.0.2
	gdb_6_4-2005-11-01-branchpoint:1.14
	gdb-csl-arm-20051020-branch:1.13.0.2
	gdb-csl-arm-20051020-branchpoint:1.13
	binutils-csl-gxxpro-3_4-branch:1.11.0.8
	binutils-csl-gxxpro-3_4-branchpoint:1.11
	binutils-2_16_1:1.11
	msnyder-tracepoint-checkpoint-branch:1.12.0.2
	msnyder-tracepoint-checkpoint-branchpoint:1.12
	gdb-csl-arm-20050325-2005-q1b:1.11
	binutils-csl-arm-2005q1b:1.11
	binutils-2_16:1.11
	gdb-csl-arm-20050325-2005-q1a:1.11
	binutils-csl-arm-2005q1a:1.11
	csl-arm-20050325-branch:1.11.0.6
	csl-arm-20050325-branchpoint:1.11
	binutils-csl-arm-2005q1-branch:1.11.0.4
	binutils-csl-arm-2005q1-branchpoint:1.11
	binutils-2_16-branch:1.11.0.2
	binutils-2_16-branchpoint:1.11
	csl-arm-2004-q3d:1.8
	gdb_6_3-20041109-release:1.8
	gdb_6_3-branch:1.8.0.8
	gdb_6_3-20041019-branchpoint:1.8
	csl-arm-2004-q3:1.8
	drow_intercu-merge-20040921:1.8
	drow_intercu-merge-20040915:1.8
	jimb-gdb_6_2-e500-branch:1.8.0.10
	jimb-gdb_6_2-e500-branchpoint:1.8
	gdb_6_2-20040730-release:1.8
	gdb_6_2-branch:1.8.0.6
	gdb_6_2-2004-07-10-gmt-branchpoint:1.8
	gdb_6_1_1-20040616-release:1.6
	binutils-2_15:1.6
	binutils-2_15-branchpoint:1.6
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.8
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.8
	drow_intercu-merge-20040327:1.8
	ezannoni_pie-20040323-branch:1.8.0.4
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.2
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.6.0.10
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.8
	drow_intercu-20040221-branchpoint:1.6
	binutils-2_15-branch:1.6.0.6
	cagney_bfdfile-20040213-branch:1.6.0.4
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.2
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.5
	csl-arm-2003-q4:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-branch:1.4.0.2
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.2
	kettenis_sparc-20030918-branch:1.3.0.4
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.2
	cagney_x86i386-20030821-branch:1.2.0.8
	cagney_x86i386-20030821-branchpoint:1.2
	carlton_dictionary-20030805-merge:1.2
	carlton_dictionary-20030627-merge:1.2
	gdb_6_0-branch:1.2.0.6
	gdb_6_0-2003-06-23-branchpoint:1.2
	jimb-ppc64-linux-20030613-branch:1.2.0.4
	jimb-ppc64-linux-20030613-branchpoint:1.2
	cagney_convert-20030606-branch:1.2.0.2
	cagney_convert-20030606-branchpoint:1.2
	binutils_latest_snapshot:1.19;
locks; strict;
comment	@# @;


1.19
date	2011.12.15.10.21.48;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2010.10.08.14.00.48;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.11.13.42.07;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.02.07.21.03;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.05.09.49.03;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.10.28.19.33.06;	author brolley;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.01.11.16.30;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.10.10.21.07;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.02.24.13.36.46;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2005.02.23.16.04.37;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.25.20.22.28;	author aoliva;	state Exp;
branches;
next	1.8;

1.8
date	2004.03.01.10.11.39;	author rsandifo;	state Exp;
branches;
next	1.7;

1.7
date	2004.03.01.09.42.32;	author rsandifo;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.14.10.04.59;	author rsandifo;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2004.01.06.19.18.37;	author aoliva;	state Exp;
branches;
next	1.4;

1.4
date	2003.10.08.17.53.40;	author brolley;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2003.09.03.23.03.45;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.05.16.04.18;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2003.06.03.15.41.12;	author cagney;	state Exp;
branches;
next	;

1.6.8.1
date	2004.03.27.17.37.40;	author drow;	state Exp;
branches;
next	;

1.4.2.1
date	2003.12.14.20.26.58;	author drow;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2004.01.13.16.11.41;	author drow;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2004.02.09.19.43.26;	author drow;	state Exp;
branches;
next	;


desc
@@


1.19
log
@	* frv.opc (parse_uhi16): Fix handling of %hi operator on 64-bit
	hosts.

	* cgen-asm.c (cgen_parse_signed_integer): Add code to handle the
	sign extension of negative values on a 64-bit host.
	* frv-asm.c: Regenerate.

	* gas/frv/immediates.s: New test file - checks assembly of
	constant values.
	* gas/frv/immediates.d: Expected disassmbly.
	* gas/frv/allinsn.exp: Run the new test.
@
text
@/* Fujitsu FRV opcode support, for GNU Binutils.  -*- C -*-

   Copyright 2000, 2001, 2003, 2004, 2005, 2007, 2009
   Free Software Foundation, Inc.

   Contributed by Red Hat Inc; developed under contract from Fujitsu.

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This file is an addendum to frv.cpu.  Heavy use of C code isn't
   appropriate in .cpu files, so it resides here.  This especially applies
   to assembly/disassembly where parsing/printing can be quite involved.
   Such things aren't really part of the specification of the cpu, per se,
   so .cpu files provide the general framework and .opc files handle the
   nitty-gritty details as necessary.

   Each section is delimited with start and end markers.

   <arch>-opc.h additions use: "-- opc.h"
   <arch>-opc.c additions use: "-- opc.c"
   <arch>-asm.c additions use: "-- asm.c"
   <arch>-dis.c additions use: "-- dis.c"
   <arch>-ibd.h additions use: "-- ibd.h".  */

/* -- opc.h */

#undef  CGEN_DIS_HASH_SIZE
#define CGEN_DIS_HASH_SIZE 128
#undef  CGEN_DIS_HASH
#define CGEN_DIS_HASH(buffer, value) (((value) >> 18) & 127)

/* Allows reason codes to be output when assembler errors occur.  */
#define CGEN_VERBOSE_ASSEMBLER_ERRORS

/* Vliw support.  */
#define FRV_VLIW_SIZE 8 /* fr550 has largest vliw size of 8.  */
#define PAD_VLIW_COMBO ,UNIT_NIL,UNIT_NIL,UNIT_NIL,UNIT_NIL

typedef CGEN_ATTR_VALUE_ENUM_TYPE VLIW_COMBO[FRV_VLIW_SIZE];

typedef struct
{
  int                    next_slot;
  int                    constraint_violation;
  unsigned long          mach;
  unsigned long          elf_flags;
  CGEN_ATTR_VALUE_ENUM_TYPE * unit_mapping;
  VLIW_COMBO *           current_vliw;
  CGEN_ATTR_VALUE_ENUM_TYPE   major[FRV_VLIW_SIZE];
  const CGEN_INSN *      insn[FRV_VLIW_SIZE];
} FRV_VLIW;

int frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);
int frv_is_float_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);
int frv_is_media_major  (CGEN_ATTR_VALUE_ENUM_TYPE, unsigned long);
int frv_is_branch_insn  (const CGEN_INSN *);
int frv_is_float_insn   (const CGEN_INSN *);
int frv_is_media_insn   (const CGEN_INSN *);
void frv_vliw_reset     (FRV_VLIW *, unsigned long, unsigned long);
int frv_vliw_add_insn   (FRV_VLIW *, const CGEN_INSN *);
int spr_valid           (long);
/* -- */

/* -- opc.c */
#include "elf/frv.h"
#include <stdio.h>

/* DEBUG appears below as argument of OP macro.  */
#undef DEBUG

/* Returns TRUE if {MAJOR,MACH} is a major branch of the FRV
   development tree.  */

bfd_boolean
frv_is_branch_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)
{
  switch (mach)
    {
    case bfd_mach_fr400:
      if (major >= FR400_MAJOR_B_1 && major <= FR400_MAJOR_B_6)
	return TRUE;
      break;
    case bfd_mach_fr450:
      if (major >= FR450_MAJOR_B_1 && major <= FR450_MAJOR_B_6)
	return TRUE;
      break;
    default:
      if (major >= FR500_MAJOR_B_1 && major <= FR500_MAJOR_B_6)
	return TRUE;
      break;
    }

  return FALSE;
}

/* Returns TRUE if {MAJOR,MACH} supports floating point insns.  */

bfd_boolean
frv_is_float_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)
{
  switch (mach)
    {
    case bfd_mach_fr400:
    case bfd_mach_fr450:
      return FALSE;
    default:
      if (major >= FR500_MAJOR_F_1 && major <= FR500_MAJOR_F_8)
	return TRUE;
      break;
    }

  return FALSE;
}

/* Returns TRUE if {MAJOR,MACH} supports media insns.  */

bfd_boolean
frv_is_media_major (CGEN_ATTR_VALUE_ENUM_TYPE major, unsigned long mach)
{
  switch (mach)
    {
    case bfd_mach_fr400:
      if (major >= FR400_MAJOR_M_1 && major <= FR400_MAJOR_M_2)
	return TRUE;
      break;
    case bfd_mach_fr450:
      if (major >= FR450_MAJOR_M_1 && major <= FR450_MAJOR_M_6)
	return TRUE;
      break;
    default:
      if (major >= FR500_MAJOR_M_1 && major <= FR500_MAJOR_M_8)
	return TRUE;
      break;
    }

  return FALSE;
}

bfd_boolean
frv_is_branch_insn (const CGEN_INSN *insn)
{
  if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR),
			   bfd_mach_fr400))
    return TRUE;
  if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),
			   bfd_mach_fr450))
    return TRUE;
  if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR),
			   bfd_mach_fr500))
    return TRUE;

  return FALSE;
}

bfd_boolean
frv_is_float_insn (const CGEN_INSN *insn)
{
  if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR),
			  bfd_mach_fr400))
    return TRUE;
  if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),
			  bfd_mach_fr450))
    return TRUE;
  if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR),
			  bfd_mach_fr500))
    return TRUE;

  return FALSE;
}

bfd_boolean
frv_is_media_insn (const CGEN_INSN *insn)
{
  if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR),
			  bfd_mach_fr400))
    return TRUE;
  if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),
			  bfd_mach_fr450))
    return TRUE;
  if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR),
			  bfd_mach_fr500))
    return TRUE;

  return FALSE;
}

/* This table represents the allowable packing for vliw insns for the fr400.
   The fr400 has only 2 vliw slots. Represent this by not allowing any insns
   in the extra slots.
   Subsets of any given row are also allowed.  */
static VLIW_COMBO fr400_allowed_vliw[] =
{
  /*  slot0       slot1       slot2       slot3    */
  {  UNIT_I0,    UNIT_I1,    UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_I0,    UNIT_FM0,   UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_I0,    UNIT_B0,    UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_FM0,   UNIT_FM1,   UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_FM0,   UNIT_B0,    UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_B0,    UNIT_NIL,   UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_C,     UNIT_NIL,   UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO }
};

/* This table represents the allowable packing for vliw insns for the fr500.
   The fr500 has only 4 vliw slots. Represent this by not allowing any insns
   in the extra slots.
   Subsets of any given row are also allowed.  */
static VLIW_COMBO fr500_allowed_vliw[] =
{
  /*  slot0       slot1       slot2       slot3    */
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1  PAD_VLIW_COMBO },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_B0   PAD_VLIW_COMBO },
  {  UNIT_I0,    UNIT_FM0,   UNIT_FM1,   UNIT_B0   PAD_VLIW_COMBO },
  {  UNIT_I0,    UNIT_FM0,   UNIT_B0,    UNIT_B1   PAD_VLIW_COMBO },
  {  UNIT_I0,    UNIT_I1,    UNIT_B0,    UNIT_B1   PAD_VLIW_COMBO },
  {  UNIT_I0,    UNIT_B0,    UNIT_B1,    UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_FM0,   UNIT_FM1,   UNIT_B0,    UNIT_B1   PAD_VLIW_COMBO },
  {  UNIT_FM0,   UNIT_B0,    UNIT_B1,    UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_C,     UNIT_NIL,   UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO },
  {  UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL  PAD_VLIW_COMBO }
};

/* This table represents the allowable packing for vliw insns for the fr550.
   Subsets of any given row are also allowed.  */
static VLIW_COMBO fr550_allowed_vliw[] =
{
  /*  slot0       slot1       slot2       slot3       slot4       slot5       slot6       slot7   */
  {  UNIT_I0,    UNIT_I1,    UNIT_I2,    UNIT_I3,    UNIT_B0,    UNIT_B1 ,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_I0,    UNIT_I1,    UNIT_I2,    UNIT_B0,    UNIT_B1 ,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_I0,    UNIT_I1,    UNIT_B0,    UNIT_B1 ,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_I0,    UNIT_B0,    UNIT_B1 ,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_I2,    UNIT_FM2,   UNIT_I3,    UNIT_FM3 },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_I2,    UNIT_FM2,   UNIT_I3,    UNIT_B0  },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_I2,    UNIT_FM2,   UNIT_FM3,   UNIT_B0  },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_I2,    UNIT_FM2,   UNIT_B0,    UNIT_B1  },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_I2,    UNIT_I3,    UNIT_B0,    UNIT_B1  },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_I2,    UNIT_B0,    UNIT_B1,    UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_FM2,   UNIT_FM3,   UNIT_B0,    UNIT_B1  },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_FM2,   UNIT_FM3,   UNIT_B0,    UNIT_B1  },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_FM2,   UNIT_B0,    UNIT_B1,    UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1,   UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_I2,    UNIT_I3,    UNIT_B0,    UNIT_B1,    UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_I2,    UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_FM1,   UNIT_FM2,   UNIT_FM3,   UNIT_B0,    UNIT_B1,    UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_FM1,   UNIT_FM2,   UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_FM1,   UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_I0,    UNIT_FM0,   UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_C,     UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_FM0,   UNIT_FM1,   UNIT_FM2,   UNIT_FM3,   UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL },
  {  UNIT_FM0,   UNIT_FM1,   UNIT_FM2,   UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_FM0,   UNIT_FM1,   UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_FM0,   UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL },
  {  UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL }
};

/* Some insns are assigned specialized implementation units which map to
   different actual implementation units on different machines.  These
   tables perform that mapping.  */
static CGEN_ATTR_VALUE_ENUM_TYPE fr400_unit_mapping[] =
{
/* unit in insn    actual unit */
/* NIL      */     UNIT_NIL,
/* I0       */     UNIT_I0,
/* I1       */     UNIT_I1,
/* I01      */     UNIT_I01, 
/* I2       */     UNIT_NIL, /* no I2 or I3 unit */
/* I3       */     UNIT_NIL,
/* IALL     */     UNIT_I01, /* only I0 and I1 units */
/* FM0      */     UNIT_FM0,
/* FM1      */     UNIT_FM1,
/* FM01     */     UNIT_FM01,
/* FM2      */     UNIT_NIL, /* no F2 or M2 units */
/* FM3      */     UNIT_NIL, /* no F3 or M3 units */
/* FMALL    */     UNIT_FM01,/* Only F0,F1,M0,M1 units */
/* FMLOW    */     UNIT_FM0, /* Only F0,M0 units */
/* B0       */     UNIT_B0,  /* branches only in B0 unit.  */
/* B1       */     UNIT_B0,
/* B01      */     UNIT_B0,
/* C        */     UNIT_C,
/* MULT-DIV */     UNIT_I0,  /* multiply and divide only in I0  unit.  */
/* IACC     */     UNIT_I01, /* iacc multiply       in I0 or I1 unit.  */
/* LOAD     */     UNIT_I0,  /* load                only in I0  unit.  */
/* STORE    */     UNIT_I0,  /* store               only in I0  unit.  */
/* SCAN     */     UNIT_I0,  /* scan                only in I0  unit.  */
/* DCPL     */     UNIT_C,   /* dcpl                only in C   unit.  */
/* MDUALACC */     UNIT_FM0, /* media dual acc insn only in FM0 unit.  */
/* MDCUTSSI */     UNIT_FM0, /* mdcutssi            only in FM0 unit.  */
/* MCLRACC-1*/     UNIT_FM0  /* mclracc,A==1   insn only in FM0 unit.  */
};

/* Some insns are assigned specialized implementation units which map to
   different actual implementation units on different machines.  These
   tables perform that mapping.  */
static CGEN_ATTR_VALUE_ENUM_TYPE fr450_unit_mapping[] =
{
/* unit in insn    actual unit */
/* NIL      */     UNIT_NIL,
/* I0       */     UNIT_I0,
/* I1       */     UNIT_I1,
/* I01      */     UNIT_I01, 
/* I2       */     UNIT_NIL, /* no I2 or I3 unit */
/* I3       */     UNIT_NIL,
/* IALL     */     UNIT_I01, /* only I0 and I1 units */
/* FM0      */     UNIT_FM0,
/* FM1      */     UNIT_FM1,
/* FM01     */     UNIT_FM01,
/* FM2      */     UNIT_NIL, /* no F2 or M2 units */
/* FM3      */     UNIT_NIL, /* no F3 or M3 units */
/* FMALL    */     UNIT_FM01,/* Only F0,F1,M0,M1 units */
/* FMLOW    */     UNIT_FM0, /* Only F0,M0 units */
/* B0       */     UNIT_B0,  /* branches only in B0 unit.  */
/* B1       */     UNIT_B0,
/* B01      */     UNIT_B0,
/* C        */     UNIT_C,
/* MULT-DIV */     UNIT_I0,  /* multiply and divide only in I0  unit.  */
/* IACC     */     UNIT_I01, /* iacc multiply       in I0 or I1 unit.  */
/* LOAD     */     UNIT_I0,  /* load                only in I0  unit.  */
/* STORE    */     UNIT_I0,  /* store               only in I0  unit.  */
/* SCAN     */     UNIT_I0,  /* scan                only in I0  unit.  */
/* DCPL     */     UNIT_I0,  /* dcpl                only in I0  unit.  */
/* MDUALACC */     UNIT_FM0, /* media dual acc insn only in FM0 unit.  */
/* MDCUTSSI */     UNIT_FM01, /* mdcutssi           in FM0 or FM1.  */
/* MCLRACC-1*/     UNIT_FM0  /* mclracc,A==1   insn only in FM0 unit.  */
};

static CGEN_ATTR_VALUE_ENUM_TYPE fr500_unit_mapping[] =
{
/* unit in insn    actual unit */
/* NIL      */     UNIT_NIL,
/* I0       */     UNIT_I0,
/* I1       */     UNIT_I1,
/* I01      */     UNIT_I01, 
/* I2       */     UNIT_NIL, /* no I2 or I3 unit */
/* I3       */     UNIT_NIL,
/* IALL     */     UNIT_I01, /* only I0 and I1 units */
/* FM0      */     UNIT_FM0,
/* FM1      */     UNIT_FM1,
/* FM01     */     UNIT_FM01,
/* FM2      */     UNIT_NIL, /* no F2 or M2 units */
/* FM3      */     UNIT_NIL, /* no F3 or M2 units */
/* FMALL    */     UNIT_FM01,/* Only F0,F1,M0,M1 units */
/* FMLOW    */     UNIT_FM0, /* Only F0,M0 units */
/* B0       */     UNIT_B0,
/* B1       */     UNIT_B1,
/* B01      */     UNIT_B01,
/* C        */     UNIT_C,
/* MULT-DIV */     UNIT_I01, /* multiply and divide in I0 or I1 unit.  */
/* IACC     */     UNIT_NIL, /* iacc multiply       not implemented */
/* LOAD     */     UNIT_I01, /* load                in I0 or I1 unit.  */
/* STORE    */     UNIT_I0,  /* store               only in I0 unit.  */
/* SCAN     */     UNIT_I01, /* scan                in I0 or I1 unit.  */
/* DCPL     */     UNIT_C,   /* dcpl                only in C unit.  */
/* MDUALACC */     UNIT_FM0, /* media dual acc insn only in FM0 unit.  */
/* MDCUTSSI */     UNIT_FM0, /* mdcutssi            only in FM0 unit.  */
/* MCLRACC-1*/     UNIT_FM01 /* mclracc,A==1 in FM0 or FM1 unit.  */
};

static CGEN_ATTR_VALUE_ENUM_TYPE fr550_unit_mapping[] =
{
/* unit in insn    actual unit */
/* NIL      */     UNIT_NIL,
/* I0       */     UNIT_I0,
/* I1       */     UNIT_I1,
/* I01      */     UNIT_I01, 
/* I2       */     UNIT_I2,
/* I3       */     UNIT_I3,
/* IALL     */     UNIT_IALL, 
/* FM0      */     UNIT_FM0,
/* FM1      */     UNIT_FM1,
/* FM01     */     UNIT_FM01,
/* FM2      */     UNIT_FM2,
/* FM3      */     UNIT_FM3,
/* FMALL    */     UNIT_FMALL,
/* FMLOW    */     UNIT_FM01, /* Only F0,F1,M0,M1 units */
/* B0       */     UNIT_B0,
/* B1       */     UNIT_B1,
/* B01      */     UNIT_B01,
/* C        */     UNIT_C,
/* MULT-DIV */     UNIT_I01,  /* multiply and divide in I0 or I1 unit.    */
/* IACC     */     UNIT_NIL,  /* iacc multiply       not implemented.     */
/* LOAD     */     UNIT_I01,  /* load                in I0 or I1 unit.    */
/* STORE    */     UNIT_I01,  /* store               in I0 or I1 unit.    */
/* SCAN     */     UNIT_IALL, /* scan                in any integer unit. */
/* DCPL     */     UNIT_I0,   /* dcpl                only in I0 unit.     */
/* MDUALACC */     UNIT_FMALL,/* media dual acc insn in all media units   */
/* MDCUTSSI */     UNIT_FM01, /* mdcutssi            in FM0 or FM1 unit.  */
/* MCLRACC-1*/     UNIT_FM01  /* mclracc,A==1 in FM0 or FM1 unit.         */
};

void
frv_vliw_reset (FRV_VLIW *vliw, unsigned long mach, unsigned long elf_flags)
{
  vliw->next_slot = 0;
  vliw->constraint_violation = 0;
  vliw->mach = mach;
  vliw->elf_flags = elf_flags;

  switch (mach)
    {
    case bfd_mach_fr400:
      vliw->current_vliw = fr400_allowed_vliw;
      vliw->unit_mapping = fr400_unit_mapping;
      break;
    case bfd_mach_fr450:
      vliw->current_vliw = fr400_allowed_vliw;
      vliw->unit_mapping = fr450_unit_mapping;
      break;
    case bfd_mach_fr550:
      vliw->current_vliw = fr550_allowed_vliw;
      vliw->unit_mapping = fr550_unit_mapping;
      break;
    default:
      vliw->current_vliw = fr500_allowed_vliw;
      vliw->unit_mapping = fr500_unit_mapping;
      break;
    }
}

/* Return TRUE if unit1 is a match for unit2.
   Unit1 comes from the insn's UNIT attribute. unit2 comes from one of the
   *_allowed_vliw tables above.  */
static bfd_boolean
match_unit (FRV_VLIW *vliw,
	    CGEN_ATTR_VALUE_ENUM_TYPE unit1, CGEN_ATTR_VALUE_ENUM_TYPE unit2)
{
  /* Map any specialized implementation units to actual ones.  */
  unit1 = vliw->unit_mapping[unit1];

  if (unit1 == unit2)
    return TRUE;
  if (unit1 < unit2)
    return FALSE;

  switch (unit1)
    {
    case UNIT_I01:
    case UNIT_FM01:
    case UNIT_B01:
      /* The 01 versions of these units are within 2 enums of the 0 or 1
	 versions.  */
      if (unit1 - unit2 <= 2)
	return TRUE;
      break;
    case UNIT_IALL:
    case UNIT_FMALL:
      /* The ALL versions of these units are within 5 enums of the 0, 1, 2 or 3
	 versions.  */
      if (unit1 - unit2 <= 5)
	return TRUE;
      break;
    default:
      break;
    }

  return FALSE;
}

/* Return TRUE if the vliws match, FALSE otherwise.  */

static bfd_boolean
match_vliw (VLIW_COMBO *vliw1, VLIW_COMBO *vliw2, int vliw_size)
{
  int i;

  for (i = 0; i < vliw_size; ++i)
    if ((*vliw1)[i] != (*vliw2)[i])
      return FALSE;

  return TRUE;
}

/* Find the next vliw vliw in the table that can accomodate the new insn.
   If one is found then return it. Otherwise return NULL.  */

static VLIW_COMBO *
add_next_to_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE unit)
{
  int           next    = vliw->next_slot;
  VLIW_COMBO    *current = vliw->current_vliw;
  VLIW_COMBO    *potential;

  if (next <= 0)
    {
      fprintf (stderr, "frv-opc.c line %d: bad vliw->next_slot value.\n",
	       __LINE__);
      abort (); /* Should never happen.  */
    }

  /* The table is sorted by units allowed within slots, so vliws with
     identical starting sequences are together.  */
  potential = current;
  do
    {
      if (match_unit (vliw, unit, (*potential)[next]))
	return potential;
      ++potential;
    }
  while (match_vliw (potential, current, next));

  return NULL;
}

/* Look for the given major insn type in the given vliw.
   Returns TRUE if found, FALSE otherwise.  */

static bfd_boolean
find_major_in_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)
{
  int i;

  for (i = 0; i < vliw->next_slot; ++i)
    if (vliw->major[i] == major)
      return TRUE;

  return FALSE;
}

/* Check for constraints between the insns in the vliw due to major insn
   types.  */

static bfd_boolean
fr400_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)
{
  /* In the cpu file, all media insns are represented as being allowed in
     both media units. This makes it easier since this is the case for fr500.
     Catch the invalid combinations here.  Insns of major class FR400_MAJOR_M_2
     cannot coexist with any other media insn in a vliw.  */
  switch (major)
    {
    case FR400_MAJOR_M_2:
      return ! find_major_in_vliw (vliw, FR400_MAJOR_M_1)
	&&   ! find_major_in_vliw (vliw, FR400_MAJOR_M_2);
    case FR400_MAJOR_M_1:
      return ! find_major_in_vliw (vliw, FR400_MAJOR_M_2);
    default:
      break;
    }
  return TRUE;
}

static bfd_boolean
fr450_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)
{
  CGEN_ATTR_VALUE_ENUM_TYPE other_major;

  /* Our caller guarantees there's at least one other instruction.  */
  other_major = CGEN_INSN_ATTR_VALUE (vliw->insn[0], CGEN_INSN_FR450_MAJOR);

  /* (M4, M5) and (M4, M6) are allowed.  */
  if (other_major == FR450_MAJOR_M_4)
    if (major == FR450_MAJOR_M_5 || major == FR450_MAJOR_M_6)
      return TRUE;

  /* Otherwise, instructions in even-numbered media categories cannot be
     executed in parallel with other media instructions.  */
  switch (major)
    {
    case FR450_MAJOR_M_2:
    case FR450_MAJOR_M_4:
    case FR450_MAJOR_M_6:
      return !(other_major >= FR450_MAJOR_M_1
	       && other_major <= FR450_MAJOR_M_6);

    case FR450_MAJOR_M_1:
    case FR450_MAJOR_M_3:
    case FR450_MAJOR_M_5:
      return !(other_major == FR450_MAJOR_M_2
	       || other_major == FR450_MAJOR_M_4
	       || other_major == FR450_MAJOR_M_6);

    default:
      return TRUE;
    }
}

static bfd_boolean
find_unit_in_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE unit)
{
  int i;

  for (i = 0; i < vliw->next_slot; ++i)
    if (CGEN_INSN_ATTR_VALUE (vliw->insn[i], CGEN_INSN_UNIT) == unit)
      return TRUE;

  return FALSE; /* Not found.  */
}

static bfd_boolean
find_major_in_slot (FRV_VLIW *vliw,
		    CGEN_ATTR_VALUE_ENUM_TYPE major,
		    CGEN_ATTR_VALUE_ENUM_TYPE slot)
{
  int i;

  for (i = 0; i < vliw->next_slot; ++i)
    if (vliw->major[i] == major && (*vliw->current_vliw)[i] == slot)
      return TRUE;

  return FALSE;
}

static bfd_boolean
fr550_find_media_in_vliw (FRV_VLIW *vliw)
{
  int i;

  for (i = 0; i < vliw->next_slot; ++i)
    {
      if (vliw->major[i] < FR550_MAJOR_M_1 || vliw->major[i] > FR550_MAJOR_M_5)
	continue;

      /* Found a media insn, however, MNOP and MCLRACC don't count.  */
      if (CGEN_INSN_NUM (vliw->insn[i]) == FRV_INSN_MNOP
	  || CGEN_INSN_NUM (vliw->insn[i]) == FRV_INSN_MCLRACC_0
	  || CGEN_INSN_NUM (vliw->insn[i]) == FRV_INSN_MCLRACC_1)
	continue;

      return TRUE; /* Found one.  */
    }

  return FALSE;
}

static bfd_boolean
fr550_find_float_in_vliw (FRV_VLIW *vliw)
{
  int i;

  for (i = 0; i < vliw->next_slot; ++i)
    {
      if (vliw->major[i] < FR550_MAJOR_F_1 || vliw->major[i] > FR550_MAJOR_F_4)
	continue;

      /* Found a floating point insn, however, FNOP doesn't count.  */
      if (CGEN_INSN_NUM (vliw->insn[i]) == FRV_INSN_FNOP)
	continue;

      return TRUE; /* Found one.  */
    }

  return FALSE;
}

static bfd_boolean
fr550_check_insn_major_constraints (FRV_VLIW *vliw,
				    CGEN_ATTR_VALUE_ENUM_TYPE major,
				    const CGEN_INSN *insn)
{
  CGEN_ATTR_VALUE_ENUM_TYPE unit;
  CGEN_ATTR_VALUE_ENUM_TYPE slot = (*vliw->current_vliw)[vliw->next_slot];
  switch (slot)
    {
    case UNIT_I2:
      /* If it's a store, then there must be another store in I1 */
      unit = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_UNIT);
      if (unit == UNIT_STORE)
	return find_unit_in_vliw (vliw, UNIT_STORE);
      break;
    case UNIT_FM2:
    case UNIT_FM3:
      /* Floating point insns other than FNOP in slot f2 or f3 cannot coexist
	 with media insns.  */
      if (major >= FR550_MAJOR_F_1 && major <= FR550_MAJOR_F_4
	  && CGEN_INSN_NUM (insn) != FRV_INSN_FNOP)
	return ! fr550_find_media_in_vliw (vliw);
      /* Media insns other than MNOP in slot m2 or m3 cannot coexist with
	 floating point insns.  */
      if (major >= FR550_MAJOR_M_1 && major <= FR550_MAJOR_M_5
	  && CGEN_INSN_NUM (insn) != FRV_INSN_MNOP)
	return ! fr550_find_float_in_vliw (vliw);
      /* F-2 in slot f2 or f3 cannot coexist with F-2 or F-4 in slot f1 or f2
	 respectively.  */
      if (major == FR550_MAJOR_F_2)
	return ! find_major_in_slot (vliw, FR550_MAJOR_F_2,
				     slot - (UNIT_FM2 - UNIT_FM0))
	  &&   ! find_major_in_slot (vliw, FR550_MAJOR_F_4,
				     slot - (UNIT_FM2 - UNIT_FM0));
      /* M-2 or M-5 in slot m2 or m3 cannot coexist with M-2 in slot m1 or m2
	 respectively.  */
      if (major == FR550_MAJOR_M_2 || major == FR550_MAJOR_M_5)
	return ! find_major_in_slot (vliw, FR550_MAJOR_M_2,
				     slot - (UNIT_FM2 - UNIT_FM0));
      /* M-4 in slot m2 or m3 cannot coexist with M-4 in slot m1 or m2
	 respectively.  */
      if (major == FR550_MAJOR_M_4)
	return ! find_major_in_slot (vliw, FR550_MAJOR_M_4,
				     slot - (UNIT_FM2 - UNIT_FM0));
      break;
    default:
      break;
    }
  return TRUE; /* All OK.  */
}

static bfd_boolean
fr500_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_ENUM_TYPE major)
{
  /* TODO: A table might be faster for some of the more complex instances
     here.  */
  switch (major)
    {
    case FR500_MAJOR_I_1:
    case FR500_MAJOR_I_4:
    case FR500_MAJOR_I_5:
    case FR500_MAJOR_I_6:
    case FR500_MAJOR_B_1:
    case FR500_MAJOR_B_2:
    case FR500_MAJOR_B_3:
    case FR500_MAJOR_B_4:
    case FR500_MAJOR_B_5:
    case FR500_MAJOR_B_6:
    case FR500_MAJOR_F_4:
    case FR500_MAJOR_F_8:
    case FR500_MAJOR_M_8:
      return TRUE; /* OK */
    case FR500_MAJOR_I_2:
      /* Cannot coexist with I-3 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_I_3);
    case FR500_MAJOR_I_3:
      /* Cannot coexist with I-2 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_I_2);
    case FR500_MAJOR_F_1:
    case FR500_MAJOR_F_2:
      /* Cannot coexist with F-5, F-6, or M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_F_5)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_6)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_7);
    case FR500_MAJOR_F_3:
      /* Cannot coexist with F-7, or M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_F_7)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_7);
    case FR500_MAJOR_F_5:
      /* Cannot coexist with F-1, F-2, F-6, F-7, or M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_F_1)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_2)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_6)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_7)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_7);
    case FR500_MAJOR_F_6:
      /* Cannot coexist with F-1, F-2, F-5, F-6, or M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_F_1)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_2)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_5)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_6)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_7);
    case FR500_MAJOR_F_7:
      /* Cannot coexist with F-3, F-5, F-7, or M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_F_3)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_5)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_7)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_7);
    case FR500_MAJOR_M_1:
      /* Cannot coexist with M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_M_7);
    case FR500_MAJOR_M_2:
    case FR500_MAJOR_M_3:
      /* Cannot coexist with M-5, M-6 or M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_M_5)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_6)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_7);
    case FR500_MAJOR_M_4:
      /* Cannot coexist with M-6 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_M_6);
    case FR500_MAJOR_M_5:
      /* Cannot coexist with M-2, M-3, M-5, M-6  or M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_M_2)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_3)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_5)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_6)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_7);
    case FR500_MAJOR_M_6:
      /* Cannot coexist with M-2, M-3, M-4, M-5, M-6  or M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_M_2)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_3)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_4)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_5)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_6)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_7);
    case FR500_MAJOR_M_7:
      /* Cannot coexist with M-1, M-2, M-3, M-5, M-6  or M-7 insn.  */
      return ! find_major_in_vliw (vliw, FR500_MAJOR_M_1)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_2)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_3)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_5)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_6)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_M_7)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_1)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_2)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_3)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_5)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_6)
	&&   ! find_major_in_vliw (vliw, FR500_MAJOR_F_7);
    default:
      fprintf (stderr, "frv-opc.c, line %d: bad major code, aborting.\n",
	       __LINE__);
      abort ();
      break;
    }
  return TRUE;
}

static bfd_boolean
check_insn_major_constraints (FRV_VLIW *vliw,
			      CGEN_ATTR_VALUE_ENUM_TYPE major,
			      const CGEN_INSN *insn)
{
  switch (vliw->mach)
    {
    case bfd_mach_fr400:
      return fr400_check_insn_major_constraints (vliw, major);

    case bfd_mach_fr450:
      return fr450_check_insn_major_constraints (vliw, major);

    case bfd_mach_fr550:
      return fr550_check_insn_major_constraints (vliw, major, insn);

    default:
      return fr500_check_insn_major_constraints (vliw, major);
    }
}

/* Add in insn to the VLIW vliw if possible.
   Return 0 if successful, non-zero otherwise.  */

int
frv_vliw_add_insn (FRV_VLIW *vliw, const CGEN_INSN *insn)
{
  int slot_index;
  CGEN_ATTR_VALUE_ENUM_TYPE major;
  CGEN_ATTR_VALUE_ENUM_TYPE unit;
  VLIW_COMBO *new_vliw;

  if (vliw->constraint_violation || CGEN_INSN_INVALID_P (insn))
    return 1;

  slot_index = vliw->next_slot;
  if (slot_index >= FRV_VLIW_SIZE)
    return 1;

  unit = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_UNIT);
  if (unit == UNIT_NIL)
    {
      fprintf (stderr, "frv-opc.c line %d: bad insn unit.\n",
	       __LINE__);
      abort (); /* No UNIT specified for this insn in frv.cpu.  */
    }

  switch (vliw->mach)
    {
    case bfd_mach_fr400:
      major = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR);
      break;
    case bfd_mach_fr450:
      major = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR);
      break;
    case bfd_mach_fr550:
      major = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR550_MAJOR);
      break;
    default:
      major = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR);
      break;
    }

  if (slot_index <= 0)
    {
      /* Any insn can be added to slot 0.  */
      while (! match_unit (vliw, unit, (*vliw->current_vliw)[0]))
	++vliw->current_vliw;
      vliw->major[0] = major;
      vliw->insn[0] = insn;
      vliw->next_slot = 1;
      return 0;
    }

  /* If there are already insns in the vliw(s) check to see that
     this one can be added.  Do this by finding an allowable vliw
     combination that can accept the new insn.  */
  if (! (vliw->elf_flags & EF_FRV_NOPACK))
    {
      new_vliw = add_next_to_vliw (vliw, unit);
      if (new_vliw && check_insn_major_constraints (vliw, major, insn))
	{
	  vliw->current_vliw = new_vliw;
	  vliw->major[slot_index] = major;
	  vliw->insn[slot_index] = insn;
	  vliw->next_slot++;
	  return 0;
	}

      /* The frv machine supports all packing conbinations.  If we fail,
	 to add the insn, then it could not be handled as if it was the fr500.
	 Just return as if it was handled ok.  */
      if (vliw->mach == bfd_mach_frv)
	return 0;
    }

  vliw->constraint_violation = 1;
  return 1;
}

bfd_boolean
spr_valid (long regno)
{
  if (regno < 0)     return FALSE;
  if (regno <= 4095) return TRUE;
  return FALSE;
}
/* -- */

/* -- asm.c */
inline static const char *
parse_symbolic_address (CGEN_CPU_DESC cd,
			const char **strp,
			int opindex,
			int opinfo,
			enum cgen_parse_operand_result *resultp,
			bfd_vma *valuep)
{
  enum cgen_parse_operand_result result_type;
  const char *errmsg = (* cd->parse_operand_fn)
    (cd, CGEN_PARSE_OPERAND_SYMBOLIC, strp, opindex, opinfo,
     &result_type, valuep);

  if (errmsg == NULL
      && result_type != CGEN_PARSE_OPERAND_RESULT_QUEUED)
    return "symbolic expression required";

  if (resultp)
    *resultp = result_type;

  return errmsg;
}

static const char *
parse_ldd_annotation (CGEN_CPU_DESC cd,
		      const char **strp,
		      int opindex,
		      unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;

  if (**strp == '#' || **strp == '%')
    {
      if (strncasecmp (*strp + 1, "tlsdesc(", 8) == 0)
	{
	  *strp += 9;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_TLSDESC_RELAX,
					   &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  if (valuep)
	    *valuep = value;
	  ++*strp;
	  if (errmsg)
	    return errmsg;
	}
    }
  
  while (**strp == ' ' || **strp == '\t')
    ++*strp;
  
  if (**strp != '@@')
    return "missing `@@'";

  ++*strp;

  return NULL;
}

static const char *
parse_call_annotation (CGEN_CPU_DESC cd,
		       const char **strp,
		       int opindex,
		       unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;

  if (**strp == '#' || **strp == '%')
    {
      if (strncasecmp (*strp + 1, "gettlsoff(", 10) == 0)
	{
	  *strp += 11;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GETTLSOFF_RELAX,
					   &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  if (valuep)
	    *valuep = value;
	  ++*strp;
	  if (errmsg)
	    return errmsg;
	}
    }
  
  while (**strp == ' ' || **strp == '\t')
    ++*strp;
  
  if (**strp != '@@')
    return "missing `@@'";

  ++*strp;

  return NULL;
}

static const char *
parse_ld_annotation (CGEN_CPU_DESC cd,
		     const char **strp,
		     int opindex,
		     unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;

  if (**strp == '#' || **strp == '%')
    {
      if (strncasecmp (*strp + 1, "tlsoff(", 7) == 0)
	{
	  *strp += 8;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_TLSOFF_RELAX,
					   &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  if (valuep)
	    *valuep = value;
	  ++*strp;
	  if (errmsg)
	    return errmsg;
	}
    }
  
  while (**strp == ' ' || **strp == '\t')
    ++*strp;
  
  if (**strp != '@@')
    return "missing `@@'";

  ++*strp;

  return NULL;
}

static const char *
parse_ulo16 (CGEN_CPU_DESC cd,
	     const char **strp,
	     int opindex,
	     unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;
 
  if (**strp == '#' || **strp == '%')
    {
      if (strncasecmp (*strp + 1, "lo(", 3) == 0)
	{
	  *strp += 4;
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_LO16,
				       & result_type, & value);
	  if (**strp != ')')
	    return "missing `)'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
      if (strncasecmp (*strp + 1, "gprello(", 8) == 0)
	{
	  *strp += 9;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GPRELLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotlo(", 6) == 0)
	{
	  *strp += 7;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotfuncdesclo(", 14) == 0)
	{
	  *strp += 15;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOTLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofflo(", 9) == 0)
	{
	  *strp += 10;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTOFFLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofffuncdesclo(", 17) == 0)
	{
	  *strp += 18;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsdesclo(", 13) == 0)
	{
	  *strp += 14;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSDESCLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "tlsmofflo(", 10) == 0)
	{
	  *strp += 11;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_TLSMOFFLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsofflo(", 12) == 0)
	{
	  *strp += 13;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSOFFLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
    }
  return cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
}

static const char *
parse_uslo16 (CGEN_CPU_DESC cd,
	      const char **strp,
	      int opindex,
	      signed long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;
 
  if (**strp == '#' || **strp == '%')
    {
      if (strncasecmp (*strp + 1, "lo(", 3) == 0)
	{
	  *strp += 4;
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_LO16,
				       & result_type, & value);
	  if (**strp != ')')
	    return "missing `)'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gprello(", 8) == 0)
	{
	  *strp += 9;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GPRELLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotlo(", 6) == 0)
	{
	  *strp += 7;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotfuncdesclo(", 14) == 0)
	{
	  *strp += 15;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOTLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofflo(", 9) == 0)
	{
	  *strp += 10;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTOFFLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofffuncdesclo(", 17) == 0)
	{
	  *strp += 18;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsdesclo(", 13) == 0)
	{
	  *strp += 14;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSDESCLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "tlsmofflo(", 10) == 0)
	{
	  *strp += 11;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_TLSMOFFLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsofflo(", 12) == 0)
	{
	  *strp += 13;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSOFFLO,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
    }
  return cgen_parse_signed_integer (cd, strp, opindex, valuep);
}

static const char *
parse_uhi16 (CGEN_CPU_DESC cd,
	     const char **strp,
	     int opindex,
	     unsigned long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;
 
  if (**strp == '#' || **strp == '%')
    {
      if (strncasecmp (*strp + 1, "hi(", 3) == 0)
	{
	  *strp += 4;
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_HI16,
				       & result_type, & value);
	  if (**strp != ')')
	    return "missing `)'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    {
 	      /* If value is wider than 32 bits then be
 		 careful about how we extract bits 16-31.  */
 	      if (sizeof (value) > 4)
 		value &= (((bfd_vma)1 << 16) << 16) - 1;

	      value >>= 16;
	    }
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gprelhi(", 8) == 0)
	{
	  *strp += 9;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GPRELHI,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gothi(", 6) == 0)
	{
	  *strp += 7;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTHI,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotfuncdeschi(", 14) == 0)
	{
	  *strp += 15;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOTHI,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotoffhi(", 9) == 0)
	{
	  *strp += 10;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTOFFHI,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofffuncdeschi(", 17) == 0)
	{
	  *strp += 18;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsdeschi(", 13) == 0)
	{
	  *strp += 14;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSDESCHI,
					   &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "tlsmoffhi(", 10) == 0)
	{
	  *strp += 11;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_TLSMOFFHI,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsoffhi(", 12) == 0)
	{
	  *strp += 13;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSOFFHI,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
    }
  return cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
}

static long
parse_register_number (const char **strp)
{
  int regno;

  if (**strp < '0' || **strp > '9')
    return -1; /* error */

  regno = **strp - '0';
  for (++*strp; **strp >= '0' && **strp <= '9'; ++*strp)
    regno = regno * 10 + (**strp - '0');

  return regno;
}

static const char *
parse_spr (CGEN_CPU_DESC cd,
	   const char **strp,
	   CGEN_KEYWORD * table,
	   long *valuep)
{
  const char *save_strp;
  long regno;

  /* Check for spr index notation.  */
  if (strncasecmp (*strp, "spr[", 4) == 0)
    {
      *strp += 4;
      regno = parse_register_number (strp);
      if (**strp != ']')
        return _("missing `]'");
      ++*strp;
      if (! spr_valid (regno))
	return _("Special purpose register number is out of range");
      *valuep = regno;
      return NULL;
    }

  save_strp = *strp;
  regno = parse_register_number (strp);
  if (regno != -1)
    {
      if (! spr_valid (regno))
	return _("Special purpose register number is out of range");
      *valuep = regno;
      return NULL;
    }

  *strp = save_strp;
  return cgen_parse_keyword (cd, strp, table, valuep);
}

static const char *
parse_d12 (CGEN_CPU_DESC cd,
	   const char **strp,
	   int opindex,
	   long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;
 
  /* Check for small data reference.  */
  if (**strp == '#' || **strp == '%')
    {
      if (strncasecmp (*strp + 1, "gprel12(", 8) == 0)
        {
          *strp += 9;
          errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GPREL12,
					   & result_type, & value);
          if (**strp != ')')
            return "missing `)'";
          ++*strp;
          *valuep = value;
          return errmsg;
        }
      else if (strncasecmp (*strp + 1, "got12(", 6) == 0)
	{
	  *strp += 7;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOT12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotfuncdesc12(", 14) == 0)
	{
	  *strp += 15;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOT12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotoff12(", 9) == 0)
	{
	  *strp += 10;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTOFF12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofffuncdesc12(", 17) == 0)
	{
	  *strp += 18;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsdesc12(", 13) == 0)
	{
	  *strp += 14;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSDESC12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "tlsmoff12(", 10) == 0)
	{
	  *strp += 11;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_TLSMOFF12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsoff12(", 12) == 0)
	{
	  *strp += 13;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSOFF12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
    }
  return cgen_parse_signed_integer (cd, strp, opindex, valuep);
}

static const char *
parse_s12 (CGEN_CPU_DESC cd,
	   const char **strp,
	   int opindex,
	   long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;
 
  /* Check for small data reference.  */
  if (**strp == '#' || **strp == '%')
    {
      if (strncasecmp (*strp + 1, "gprel12(", 8) == 0)
	{
	  *strp += 9;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GPREL12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing `)'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "got12(", 6) == 0)
	{
	  *strp += 7;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOT12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotfuncdesc12(", 14) == 0)
	{
	  *strp += 15;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOT12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotoff12(", 9) == 0)
	{
	  *strp += 10;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTOFF12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofffuncdesc12(", 17) == 0)
	{
	  *strp += 18;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsdesc12(", 13) == 0)
	{
	  *strp += 14;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSDESC12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "tlsmoff12(", 10) == 0)
	{
	  *strp += 11;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_TLSMOFF12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gottlsoff12(", 12) == 0)
	{
	  *strp += 13;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GOTTLSOFF12,
					   & result_type, & value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
    }

  if (**strp == '#')
    ++*strp;
  return cgen_parse_signed_integer (cd, strp, opindex, valuep);
}

static const char *
parse_u12 (CGEN_CPU_DESC cd,
	   const char **strp,
	   int opindex,
	   long *valuep)
{
  const char *errmsg;
  enum cgen_parse_operand_result result_type;
  bfd_vma value;
 
  /* Check for small data reference.  */
  if ((**strp == '#' || **strp == '%')
      && strncasecmp (*strp + 1, "gprel12(", 8) == 0)
    {
      *strp += 9;
      errmsg = parse_symbolic_address (cd, strp, opindex,
				       BFD_RELOC_FRV_GPRELU12,
				       & result_type, & value);
      if (**strp != ')')
        return "missing `)'";
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else
    {
      if (**strp == '#')
        ++*strp;
      return cgen_parse_signed_integer (cd, strp, opindex, valuep);
    }
}

static const char *
parse_A (CGEN_CPU_DESC cd,
	 const char **strp,
	 int opindex,
	 unsigned long *valuep,
	 unsigned long A)
{
  const char *errmsg;
 
  if (**strp == '#')
    ++*strp;

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
  if (errmsg)
    return errmsg;

  if (*valuep != A)
    return _("Value of A operand must be 0 or 1");

  return NULL;
}

static const char *
parse_A0 (CGEN_CPU_DESC cd,
	  const char **strp,
	  int opindex,
	  unsigned long *valuep)
{
  return parse_A (cd, strp, opindex, valuep, 0);
}

static const char *
parse_A1 (CGEN_CPU_DESC cd,
	  const char **strp,
	  int opindex,
	  unsigned long *valuep)
{
  return parse_A (cd, strp, opindex, valuep, 1);
}

static const char *
parse_even_register (CGEN_CPU_DESC  cd,
		     const char **  strP,
		     CGEN_KEYWORD * tableP,
		     long *         valueP)
{
  const char * errmsg;
  const char * saved_star_strP = * strP;

  errmsg = cgen_parse_keyword (cd, strP, tableP, valueP);

  if (errmsg == NULL && ((* valueP) & 1))
    {
      errmsg = _("register number must be even");
      * strP = saved_star_strP;
    }

  return errmsg;
}

static const char *
parse_call_label (CGEN_CPU_DESC cd,
		  const char **strp,
		  int opindex,
		  int opinfo,
		  enum cgen_parse_operand_result *resultp,
		  bfd_vma *valuep)
{
  const char *errmsg;
  bfd_vma value;
 
  /* Check for small data reference.  */
  if (opinfo == 0 && (**strp == '#' || **strp == '%'))
    {
      if (strncasecmp (*strp + 1, "gettlsoff(", 10) == 0)
	{
	  *strp += 11;
	  errmsg = parse_symbolic_address (cd, strp, opindex,
					   BFD_RELOC_FRV_GETTLSOFF,
					   resultp, &value);
	  if (**strp != ')')
	    return _("missing `)'");
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
    }

  return cgen_parse_address (cd, strp, opindex, opinfo, resultp, valuep);
}

/* -- */

/* -- dis.c */
static void
print_at (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	  void * dis_info,
	  long reloc_ann ATTRIBUTE_UNUSED,
	  long value ATTRIBUTE_UNUSED,
	  bfd_vma pc ATTRIBUTE_UNUSED,
	  int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  (*info->fprintf_func) (info->stream, "@@");
}  

static void
print_spr (CGEN_CPU_DESC cd,
	   void * dis_info,
	   CGEN_KEYWORD *names,
	   long regno,
	   unsigned int attrs)
{
  /* Use the register index format for any unnamed registers.  */
  if (cgen_keyword_lookup_value (names, regno) == NULL)
    {
      disassemble_info *info = (disassemble_info *) dis_info;
      (*info->fprintf_func) (info->stream, "spr[%ld]", regno);
    }
  else
    print_keyword (cd, dis_info, names, regno, attrs);
}

static void
print_hi (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	  void * dis_info,
	  long value,
	  unsigned int attrs ATTRIBUTE_UNUSED,
	  bfd_vma pc ATTRIBUTE_UNUSED,
	  int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;

  (*info->fprintf_func) (info->stream, value ? "0x%lx" : "hi(0x%lx)", value);
}

static void
print_lo (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	  void * dis_info,
	  long value,
	  unsigned int attrs ATTRIBUTE_UNUSED,
	  bfd_vma pc ATTRIBUTE_UNUSED,
	  int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = (disassemble_info *) dis_info;
  if (value)
    (*info->fprintf_func) (info->stream, "0x%lx", value);
  else
    (*info->fprintf_func) (info->stream, "lo(0x%lx)", value);
}

/* -- */
@


1.18
log
@Fix build with -DDEBUG=7
@
text
@d1346 5
a1350 5
	      /* If bfd_vma is wider than 32 bits, but we have a sign-
		 or zero-extension, truncate it.  */
	      if (value >= - ((bfd_vma)1 << 31)
		  || value <= ((bfd_vma)1 << 31) - (bfd_vma)1)
		value &= (((bfd_vma)1 << 16) << 16) - 1;
@


1.17
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d84 3
@


1.16
log
@update copyright dates
@
text
@d845 1
a845 1
  int index;
d853 2
a854 2
  index = vliw->next_slot;
  if (index >= FRV_VLIW_SIZE)
d881 1
a881 1
  if (index <= 0)
d901 2
a902 2
	  vliw->major[index] = major;
	  vliw->insn[index] = insn;
@


1.15
log
@Change source files over to GPLv3.
@
text
@d3 2
a4 1
   Copyright 2000, 2001, 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
@


1.14
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        Contribute the following change:
        2003-09-24  Dave Brolley  <brolley@@redhat.com>

        * frv.opc: Use CGEN_ATTR_VALUE_ENUM_TYPE in place of
        CGEN_ATTR_VALUE_TYPE.
        * m32c.opc (m32c_cgen_insn_supported): Use CGEN_INSN_BITSET_ATTR_VALUE.
        Use cgen_bitset_intersect_p.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.
d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d24 1
@


1.13
log
@Update function declarations to ISO C90 formatting
@
text
@d53 1
a53 1
typedef CGEN_ATTR_VALUE_TYPE VLIW_COMBO[FRV_VLIW_SIZE];
d61 1
a61 1
  CGEN_ATTR_VALUE_TYPE * unit_mapping;
d63 1
a63 1
  CGEN_ATTR_VALUE_TYPE   major[FRV_VLIW_SIZE];
d67 3
a69 3
int frv_is_branch_major (CGEN_ATTR_VALUE_TYPE, unsigned long);
int frv_is_float_major  (CGEN_ATTR_VALUE_TYPE, unsigned long);
int frv_is_media_major  (CGEN_ATTR_VALUE_TYPE, unsigned long);
d86 1
a86 1
frv_is_branch_major (CGEN_ATTR_VALUE_TYPE major, unsigned long mach)
d110 1
a110 1
frv_is_float_major (CGEN_ATTR_VALUE_TYPE major, unsigned long mach)
d129 1
a129 1
frv_is_media_major (CGEN_ATTR_VALUE_TYPE major, unsigned long mach)
d273 1
a273 1
static CGEN_ATTR_VALUE_TYPE fr400_unit_mapping[] =
d308 1
a308 1
static CGEN_ATTR_VALUE_TYPE fr450_unit_mapping[] =
d340 1
a340 1
static CGEN_ATTR_VALUE_TYPE fr500_unit_mapping[] =
d372 1
a372 1
static CGEN_ATTR_VALUE_TYPE fr550_unit_mapping[] =
d438 1
a438 1
	    CGEN_ATTR_VALUE_TYPE unit1, CGEN_ATTR_VALUE_TYPE unit2)
d490 1
a490 1
add_next_to_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE unit)
d521 1
a521 1
find_major_in_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major)
d536 1
a536 1
fr400_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major)
d556 1
a556 1
fr450_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major)
d558 1
a558 1
  CGEN_ATTR_VALUE_TYPE other_major;
d591 1
a591 1
find_unit_in_vliw (FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE unit)
d604 2
a605 2
		    CGEN_ATTR_VALUE_TYPE major,
		    CGEN_ATTR_VALUE_TYPE slot)
d660 1
a660 1
				    CGEN_ATTR_VALUE_TYPE major,
d663 2
a664 2
  CGEN_ATTR_VALUE_TYPE unit;
  CGEN_ATTR_VALUE_TYPE slot = (*vliw->current_vliw)[vliw->next_slot];
d710 1
a710 1
fr500_check_insn_major_constraints (FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major)
d818 1
a818 1
			      CGEN_ATTR_VALUE_TYPE major,
d844 2
a845 2
  CGEN_ATTR_VALUE_TYPE major;
  CGEN_ATTR_VALUE_TYPE unit;
@


1.12
log
@Update the address and phone number of the FSF organization
@
text
@d21 2
a22 3
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.

*/
d37 1
a37 2
   <arch>-ibd.h additions use: "-- ibd.h"
*/
d52 1
d57 8
a64 8
  int                   next_slot;
  int                   constraint_violation;
  unsigned long         mach;
  unsigned long         elf_flags;
  CGEN_ATTR_VALUE_TYPE *unit_mapping;
  VLIW_COMBO           *current_vliw;
  CGEN_ATTR_VALUE_TYPE  major[FRV_VLIW_SIZE];
  const CGEN_INSN*      insn[FRV_VLIW_SIZE];
d67 9
a75 9
int frv_is_branch_major PARAMS ((CGEN_ATTR_VALUE_TYPE, unsigned long));
int frv_is_float_major  PARAMS ((CGEN_ATTR_VALUE_TYPE, unsigned long));
int frv_is_media_major  PARAMS ((CGEN_ATTR_VALUE_TYPE, unsigned long));
int frv_is_branch_insn  PARAMS ((const CGEN_INSN *));
int frv_is_float_insn   PARAMS ((const CGEN_INSN *));
int frv_is_media_insn   PARAMS ((const CGEN_INSN *));
void frv_vliw_reset     PARAMS ((FRV_VLIW *, unsigned long mach, unsigned long elf_flags));
int frv_vliw_add_insn   PARAMS ((FRV_VLIW *, const CGEN_INSN *));
int spr_valid           PARAMS ((long));
d82 2
a83 18
static int match_unit
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE, CGEN_ATTR_VALUE_TYPE));
static int match_vliw
  PARAMS ((VLIW_COMBO *, VLIW_COMBO *, int));
static VLIW_COMBO * add_next_to_vliw
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE));
static int find_major_in_vliw
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE));
static int fr400_check_insn_major_constraints
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE));
static int fr450_check_insn_major_constraints
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE));
static int fr500_check_insn_major_constraints
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE));
static int fr550_check_insn_major_constraints
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE, const CGEN_INSN *));
static int check_insn_major_constraints
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE, const CGEN_INSN *));
d85 1
a85 1
int
d92 1
a92 1
	return 1; /* is a branch */
d96 1
a96 1
	return 1; /* is a branch */
d100 1
a100 1
	return 1; /* is a branch */
d104 1
a104 1
  return 0; /* not a branch */
d107 3
a109 1
int
d116 1
a116 1
      return 0; /* No float insns */
d119 1
a119 1
	return 1; /* is a float insn */
d123 1
a123 1
  return 0; /* not a branch */
d126 3
a128 1
int
d135 1
a135 1
	return 1; /* is a media insn */
d139 1
a139 1
	return 1; /* is a media insn */
d143 1
a143 1
	return 1; /* is a media insn */
d147 1
a147 1
  return 0; /* not a branch */
d150 1
a150 1
int
d155 1
a155 1
    return 1;
d158 1
a158 1
    return 1;
d161 1
a161 1
    return 1;
d163 1
a163 1
  return 0;
d166 1
a166 1
int
d171 1
a171 1
    return 1;
d174 1
a174 1
    return 1;
d177 1
a177 1
    return 1;
d179 1
a179 1
  return 0;
d182 1
a182 1
int
d187 1
a187 1
    return 1;
d190 1
a190 1
    return 1;
d193 1
a193 1
    return 1;
d195 1
a195 1
  return 0;
d433 1
a433 1
/* Return 1 if unit1 is a match for unit2.
d436 1
a436 1
static int
d444 1
a444 1
    return 1;
d446 1
a446 1
    return 0;
d456 1
a456 1
	return 1;
d463 1
a463 1
	return 1;
d469 1
a469 1
  return 0;
d472 1
a472 1
/* Return 1 if the vliws match, 0 otherwise.  */
d474 1
a474 1
static int
d480 2
a481 4
    {
      if ((*vliw1)[i] != (*vliw2)[i])
	return 0;
    }
d483 1
a483 1
  return 1;
d500 1
a500 1
      abort (); /* Should never happen */
d517 2
a518 2
/* Look for the given major insn type in the given vliw. Return 1 if found,
   return 0 otherwise.  */
d520 1
a520 1
static int
d527 1
a527 1
      return 1;
d529 1
a529 1
  return 0;
d535 2
a536 4
static int
fr400_check_insn_major_constraints (
  FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major
)
d548 1
a548 1
      return !find_major_in_vliw (vliw, FR400_MAJOR_M_2);
d552 1
a552 1
  return 1;
d555 2
a556 4
static int
fr450_check_insn_major_constraints (
  FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major
)
d566 1
a566 1
      return 1;
d586 1
a586 1
      return 1;
d590 2
a591 4
static int
find_unit_in_vliw (
  FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE unit
)
d594 1
d597 1
a597 1
      return 1;
d599 1
a599 1
  return 0; /* not found */
d602 4
a605 4
static int
find_major_in_slot (
  FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major, CGEN_ATTR_VALUE_TYPE slot
)
d611 1
a611 1
      return 1;
d613 1
a613 1
  return 0;
d616 1
a616 1
static int
d632 1
a632 1
      return 1; /* found one */
d635 1
a635 1
  return 0;
d638 1
a638 1
static int
d652 1
a652 1
      return 1; /* found one */
d655 1
a655 1
  return 0;
d658 4
a661 4
static int
fr550_check_insn_major_constraints (
  FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major, const CGEN_INSN *insn
)
d675 2
a676 2
      /* Floating point insns other than FNOP in slot f2 or f3 cannot coexist with
	 media insns.  */
d686 1
a686 2
	 respectively.
       */
d688 4
a691 2
	return ! find_major_in_slot (vliw, FR550_MAJOR_F_2, slot - (UNIT_FM2 - UNIT_FM0))
	  &&   ! find_major_in_slot (vliw, FR550_MAJOR_F_4, slot - (UNIT_FM2 - UNIT_FM0));
d695 2
a696 1
	return ! find_major_in_slot (vliw, FR550_MAJOR_M_2, slot - (UNIT_FM2 - UNIT_FM0));
d700 2
a701 1
	return ! find_major_in_slot (vliw, FR550_MAJOR_M_4, slot - (UNIT_FM2 - UNIT_FM0));
d706 1
a706 1
  return 1; /* all ok */
d709 2
a710 4
static int
fr500_check_insn_major_constraints (
  FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major
)
d729 1
a729 1
      return 1; /* OK */
d813 1
a813 1
  return 1;
d816 4
a819 4
static int
check_insn_major_constraints (
  FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major, const CGEN_INSN *insn
)
a820 1
  int rc;
d824 2
a825 2
      rc = fr400_check_insn_major_constraints (vliw, major);
      break;
d827 2
a828 2
      rc = fr450_check_insn_major_constraints (vliw, major);
      break;
d830 2
a831 2
      rc = fr550_check_insn_major_constraints (vliw, major, insn);
      break;
d833 1
a833 2
      rc = fr500_check_insn_major_constraints (vliw, major);
      break;
a834 1
  return rc;
d837 3
a839 2
/* Add in insn to the VLIW vliw if possible. Return 0 if successful,
   non-zero otherwise.  */
d860 1
a860 1
      abort (); /* no UNIT specified for this insn in frv.cpu  */
d916 2
a917 3
int
spr_valid (regno)
     long regno;
d919 3
a921 3
  if (regno < 0)     return 0;
  if (regno <= 4095) return 1;
  return 0;
a925 25
static const char * parse_ulo16
  PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
static const char * parse_uslo16
  PARAMS ((CGEN_CPU_DESC, const char **, int, signed long *));
static const char * parse_uhi16
  PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
static long parse_register_number
  PARAMS ((const char **));
static const char * parse_spr
  PARAMS ((CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *));
static const char * parse_d12
  PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
static const char * parse_s12
  PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
static const char * parse_u12
  PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
static const char * parse_even_register
  PARAMS ((CGEN_CPU_DESC, const char **, CGEN_KEYWORD *, long *));
static const char * parse_A0
  PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
static const char * parse_A1
  PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
static const char * parse_A
  PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *, unsigned long));

d1067 4
a1070 5
parse_ulo16 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     unsigned long *valuep;
d1082 1
a1082 1
				       &result_type, &value);
d1097 1
a1097 1
					   &result_type, &value);
d1109 1
a1109 1
					   &result_type, &value);
d1121 1
a1121 1
					   &result_type, &value);
d1133 1
a1133 1
					   &result_type, &value);
d1145 1
a1145 1
					   &result_type, &value);
d1157 1
a1157 1
					   &result_type, &value);
d1169 1
a1169 1
					   &result_type, &value);
d1181 1
a1181 1
					   &result_type, &value);
d1193 4
a1196 5
parse_uslo16 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     signed long *valuep;
d1208 1
a1208 1
				       &result_type, &value);
d1223 1
a1223 1
					   &result_type, &value);
d1235 1
a1235 1
					   &result_type, &value);
d1247 1
a1247 1
					   &result_type, &value);
d1259 1
a1259 1
					   &result_type, &value);
d1271 1
a1271 1
					   &result_type, &value);
d1283 1
a1283 1
					   &result_type, &value);
d1295 1
a1295 1
					   &result_type, &value);
d1307 1
a1307 1
					   &result_type, &value);
d1319 4
a1322 5
parse_uhi16 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     unsigned long *valuep;
d1334 1
a1334 1
				       &result_type, &value);
d1356 1
a1356 1
					   &result_type, &value);
d1368 1
a1368 1
					   &result_type, &value);
d1380 1
a1380 1
					   &result_type, &value);
d1392 1
a1392 1
					   &result_type, &value);
d1404 1
a1404 1
					   &result_type, &value);
d1428 1
a1428 1
					   &result_type, &value);
d1440 1
a1440 1
					   &result_type, &value);
d1452 1
a1452 2
parse_register_number (strp)
     const char **strp;
d1455 1
d1467 4
a1470 5
parse_spr (cd, strp, table, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     CGEN_KEYWORD * table;
     long *valuep;
d1481 1
a1481 1
        return "missing `]'";
d1484 1
a1484 1
	return "Special purpose register number is out of range";
d1494 1
a1494 1
	return "Special purpose register number is out of range";
d1504 4
a1507 5
parse_d12 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     long *valuep;
d1521 1
a1521 1
					   &result_type, &value);
d1533 1
a1533 1
					   &result_type, &value);
d1545 1
a1545 1
					   &result_type, &value);
d1557 1
a1557 1
					   &result_type, &value);
d1569 1
a1569 1
					   &result_type, &value);
d1581 1
a1581 1
					   &result_type, &value);
d1593 1
a1593 1
					   &result_type, &value);
d1605 1
a1605 1
					   &result_type, &value);
d1617 4
a1620 5
parse_s12 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     long *valuep;
d1634 1
a1634 1
					   &result_type, &value);
d1646 1
a1646 1
					   &result_type, &value);
d1658 1
a1658 1
					   &result_type, &value);
d1670 1
a1670 1
					   &result_type, &value);
d1682 1
a1682 1
					   &result_type, &value);
d1694 1
a1694 1
					   &result_type, &value);
d1706 1
a1706 1
					   &result_type, &value);
d1718 1
a1718 1
					   &result_type, &value);
d1733 4
a1736 5
parse_u12 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     long *valuep;
d1749 1
a1749 1
				       &result_type, &value);
d1765 5
a1769 6
parse_A (cd, strp, opindex, valuep, A)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     unsigned long *valuep;
     unsigned long A;
d1781 1
a1781 1
    return "Value of A operand must be 0 or 1";
d1787 4
a1790 5
parse_A0 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     unsigned long *valuep;
d1796 4
a1799 5
parse_A1 (cd, strp, opindex, valuep)
     CGEN_CPU_DESC cd;
     const char **strp;
     int opindex;
     unsigned long *valuep;
d1805 4
a1808 5
parse_even_register (cd, strP, tableP, valueP)
     CGEN_CPU_DESC  cd;
     const char **  strP;
     CGEN_KEYWORD * tableP;
     long *         valueP;
d1845 1
a1845 1
	    return "missing `)'";
a1857 7
static void print_spr
  PARAMS ((CGEN_CPU_DESC, PTR, CGEN_KEYWORD *, long, unsigned));
static void print_hi
  PARAMS ((CGEN_CPU_DESC, PTR, long, unsigned, bfd_vma, int));
static void print_lo
  PARAMS ((CGEN_CPU_DESC, PTR, long, unsigned, bfd_vma, int));

d1860 1
a1860 1
	  PTR dis_info,
d1864 1
a1864 2
	  int length ATTRIBUTE_UNUSED
	  )
d1867 1
d1872 5
a1876 6
print_spr (cd, dis_info, names, regno, attrs)
     CGEN_CPU_DESC cd;
     PTR dis_info;
     CGEN_KEYWORD *names;
     long regno;
     unsigned int attrs;
d1889 6
a1894 7
print_hi (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
d1897 2
a1898 4
  if (value)
    (*info->fprintf_func) (info->stream, "0x%lx", value);
  else
    (*info->fprintf_func) (info->stream, "hi(0x%lx)", value);
d1902 6
a1907 7
print_lo (cd, dis_info, value, attrs, pc, length)
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
     PTR dis_info;
     long value;
     unsigned int attrs ATTRIBUTE_UNUSED;
     bfd_vma pc ATTRIBUTE_UNUSED;
     int length ATTRIBUTE_UNUSED;
@


1.11
log
@	* frv.opc (parse_A): Warning fix.
@
text
@d21 1
a21 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.10
log
@Fix compile time warnings generated by gcc 4.0
@
text
@d971 1
a971 1
  PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *, long));
d1824 1
a1824 1
     long A;
@


1.9
log
@bfd/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_relocate_section): Force local binding
for TLSMOFF.
* reloc.c: Add R_FRV_TLSMOFF.
* elf32-frv.c (elf32_frv_howto_table): Likewise.
(frv_reloc_map, frv_reloc_type_lookup): Map it.
(elf32_frv_relocate_section): Handle it.
(elf32_frv_check_relocs): Likewise.
* libbfd.h, bfd-in2.h: Rebuilt.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (_frvfdpic_emit_got_relocs_plt_entries): Don't crash
when given an undefweak TLS symbol.  Fix constant TLS PLT entries
such that they return the constant in gr9.
(_frvfdpic_relax_tls_entries): Don't crash for undefweak TLS
symbols.
(_frvfdpic_size_got_plt): Set _cooked_size of dynamic sections.
too, such that they shrink on relaxation.
(elf32_frvfdpic_finish_dynamic_sections): Check __ROFIXUP_END__ as
marking the position right past the _GLOBAL_OFFSET_TABLE_ value.
(_frvfdpic_assign_plt_entries): Shrink constant TLS PLT entries
if we can guarantee the use of 16-bit constants.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
Introduce TLS support for FR-V FDPIC.
* reloc.c: Add TLS relocations.
* elf32-frv.c (elf32_frv_howto_table): Add TLS relocations.
(elf32_frv_rel_tlsdesc_value_howto): New.
(elf32_frv_rel_tlsoff_howto): New.
(frv_reloc_map): Add new mappings.
(struct frvfdpic_elf_link_hash_table): Add pointer to summary
reloc information.
(frvfdpic_dynamic_got_plt_info): New.
(frvfdpic_plt_tls_ret_offset): New.
(ELF_DYNAMIC_INTERPRETER, DEFAULT_STACK_SIZE): Move earlier.
(struct _frvfdpic_dynamic_got_info): Likewise.  Add TLS members.
(struct _frvfdpic_dynamic_got_plt_info): Likewise.
(FRVFDPIC_SYM_LOCAL): Regard symbols defined in the absolute
section as local.
(struct frvfdpic_relocs_info): Add TLS fields.
(frvfdpic_relocs_info_hash): Warning clean up.
(frvfdpic_relocs_info_find): Initialize tlsplt_entry.
(frvfdpic_pic_merge_early_relocs_info): Merge TLS fields.
(FRVFDPIC_TLS_BIAS): Define.
(tls_biased_base): New.
(_frvfdpic_emit_got_relocs_plt_entries): Deal with TLS
relocations.
(frv_reloc_type_lookup): Likewise.
(frvfdpic_info_to_howto_rel): Likewise.
(elf32_frv_relocate_section): Likewise.
(_frv_create_got_section): Create the PLT section here.
(elf32_frvfdpic_create_dynamic_sections): Not here.
(_frvfdpic_count_nontls_entries): Move out of...
(_frvfdpic_count_got_plt_entries): ... here.
(_frvfdpic_count_tls_entries): Likewise.  Add TLS support.
(_frvfdpic_count_relocs_fixups): Likewise.  Add relaxation
support.
(_frvfdpic_relax_tls_entries): New.
(_frvfdpic_compute_got_alloc_data): Add TLS support.
(_frvfdpic_get_tlsdesc_entry): New.
(_frvfdpic_assign_got_entries): Add TLS support.
(_frvfdpic_assign_plt_entries): Likewise.
(_frvfdpic_reset_got_plt_entries): New.
(_frvfdpic_size_got_plt): Move out of...
(elf32_frvfdpic_size_dynamic_sections): ... here.
(_frvfdpic_relax_got_plt_entries): New.
(elf32_frvfdpic_relax_section): New.
(elf32_frvfdpic_finish_dynamic_sections): Add TLS sanity check.
(elf32_frv_check_relocs): Add TLS support.
(bfd_elf32_bfd_relax_section): Define for FDPIC.
* libbfd.h, bfd-in2.h: Rebuilt.
cpu/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.cpu: Add support for TLS annotations in loads and calll.
* frv.opc (parse_symbolic_address): New.
(parse_ldd_annotation): New.
(parse_call_annotation): New.
(parse_ld_annotation): New.
(parse_ulo16, parse_uslo16): Use parse_symbolic_address.
Introduce TLS relocations.
(parse_d12, parse_s12, parse_u12): Likewise.
(parse_uhi16): Likewise.  Fix constant checking on 64-bit host.
(parse_call_label, print_at): New.
gas/ChangeLog:
* config/tc-frv.c (md_apply_fix3): Mark TLS symbols as such.
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.c (frv_pic_ptr): Add tlsmoff support.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.c (gas_cgen_parse_operand): Handle
CGEN_PARSE_OPERAND_SYMBOLIC.
* config/tc-frv.c (md_cgen_lookup_reloc): Handle TLS relocations.
(frv_force_relocation): Likewise.  Fix handling of PIC
relocations.
(md_apply_fix3): Likewise.
include/elf/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add R_FRV_TLSMOFF.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add TLS relocations.
include/opcode/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.h (enum cgen_parse_operand_type): Add
CGEN_PARSE_OPERAND_SYMBOLIC.
ld/testsuite/ChangeLog:
* ld-frv/fdpic.exp: Add -mfdpic to ASFLAGS.
* ld-frv/tls.exp: Likewise.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-3.s: New.
* ld-frv/tls-static-3.d: New.
* ld-frv/tls-dynamic-3.d: New.
* ld-frv/tls-pie-3.d: New.
* ld-frv/tls-shared-3.d: New.
* ld-frv/tls-relax-static-3.d: New.
* ld-frv/tls-relax-dynamic-3.d: New.
* ld-frv/tls-relax-pie-3.d: New.
* ld-frv/tls-relax-shared-3.d: New.
* ld-frv/tls.exp: Run the new tests.
* ld-frv/tls-dynamic-2.d: Adjust for improved relaxation.
* ld-frv/tls-relax-dynamic-2.d: Likewise.
* ld-frv/tls-relax-initial-shared-2.d: Likewise.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-1-dep.s: New.
* ld-frv/tls-1-shared.lds: New.
* ld-frv/tls-1.s: New.
* ld-frv/tls-2.s: New.
* ld-frv/tls-dynamic-1.d: New.
* ld-frv/tls-dynamic-2.d: New.
* ld-frv/tls-initial-shared-2.d: New.
* ld-frv/tls-pie-1.d: New.
* ld-frv/tls-relax-dynamic-1.d: New.
* ld-frv/tls-relax-dynamic-2.d: New.
* ld-frv/tls-relax-initial-shared-2.d: New.
* ld-frv/tls-relax-pie-1.d: New.
* ld-frv/tls-relax-shared-1.d: New.
* ld-frv/tls-relax-shared-2.d: New.
* ld-frv/tls-relax-static-1.d: New.
* ld-frv/tls-shared-1-fail.d: New.
* ld-frv/tls-shared-1.d: New.
* ld-frv/tls-shared-2.d: New.
* ld-frv/tls-static-1.d: New.
* ld-frv/tls.exp: New.
* ld-frv/fdpic-pie-1.d: Adjust for 64-bit host.
* ld-frv/fdpic-pie-2.d: Likewise.
* ld-frv/fdpic-pie-6.d: Likewise.
* ld-frv/fdpic-pie-7.d: Likewise.
* ld-frv/fdpic-pie-8.d: Likewise.
* ld-frv/fdpic-shared-1.d: Likewise.
* ld-frv/fdpic-shared-2.d: Likewise.
* ld-frv/fdpic-shared-3.d: Likewise.
* ld-frv/fdpic-shared-4.d: Likewise.
* ld-frv/fdpic-shared-5.d: Likewise.
* ld-frv/fdpic-shared-6.d: Likewise.
* ld-frv/fdpic-shared-7.d: Likewise.
* ld-frv/fdpic-shared-8.d: Likewise.
* ld-frv/fdpic-shared-local-2.d: Likewise.
* ld-frv/fdpic-shared-local-8.d: Likewise.
* ld-frv/fdpic-static-1.d: Likewise.
* ld-frv/fdpic-static-2.d: Likewise.
* ld-frv/fdpic-static-6.d: Likewise.
* ld-frv/fdpic-static-7.d: Likewise.
* ld-frv/fdpic-static-8.d: Likewise.
opcodes/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv-asm.c: Rebuilt.
* frv-desc.c: Rebuilt.
* frv-desc.h: Rebuilt.
* frv-dis.c: Rebuilt.
* frv-ibld.c: Rebuilt.
* frv-opc.c: Rebuilt.
* frv-opc.h: Rebuilt.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
d951 1
a951 1
  PARAMS ((CGEN_CPU_DESC, const char **, int, unsigned long *));
d967 1
a967 1
  PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
d969 1
a969 1
  PARAMS ((CGEN_CPU_DESC, const char **, int, long *));
d971 1
a971 1
  PARAMS ((CGEN_CPU_DESC, const char **, int, long *, long));
d1000 1
a1000 1
		      long *valuep)
d1039 1
a1039 1
		       long *valuep)
d1078 1
a1078 1
		     long *valuep)
d1237 1
a1237 1
  return cgen_parse_signed_integer (cd, strp, opindex, valuep);
d1245 1
a1245 1
     unsigned long *valuep;
d1364 1
a1364 1
  return cgen_parse_unsigned_integer (cd, strp, opindex, valuep);
d1823 1
a1823 1
     long *valuep;
d1846 1
a1846 1
     long *valuep;
d1856 1
a1856 1
     long *valuep;
@


1.8
log
@Add fr450 support.
@
text
@d973 140
d1143 3
a1145 2
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GPRELLO,
				       &result_type, &value);
a1148 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1155 3
a1157 2
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOTLO,
				       &result_type, &value);
a1160 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1167 3
a1169 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTLO,
				       &result_type, &value);
a1172 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1179 3
a1181 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_GOTOFFLO,
				       &result_type, &value);
a1184 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1191 39
a1229 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
				       &result_type, &value);
a1232 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1270 3
a1272 2
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GPRELLO,
				       &result_type, &value);
a1275 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1282 3
a1284 2
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOTLO,
				       &result_type, &value);
a1287 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1294 3
a1296 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTLO,
				       &result_type, &value);
a1299 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1306 3
a1308 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_GOTOFFLO,
				       &result_type, &value);
a1311 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1318 39
a1356 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
				       &result_type, &value);
a1359 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
d1390 8
a1397 1
	    value >>= 16;
d1404 3
a1406 2
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GPRELHI,
				       &result_type, &value);
a1409 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value >>= 16;
d1416 3
a1418 2
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOTHI,
				       &result_type, &value);
a1421 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value >>= 16;
d1428 3
a1430 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTHI,
				       &result_type, &value);
a1433 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value >>= 16;
d1440 3
a1442 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_GOTOFFHI,
				       &result_type, &value);
a1445 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value >>= 16;
d1452 39
a1490 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
				       &result_type, &value);
a1493 3
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value >>= 16;
d1571 3
a1573 2
          errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GPREL12,
                                       &result_type, &value);
d1583 3
a1585 2
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOT12,
				       &result_type, &value);
d1595 3
a1597 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOT12,
				       &result_type, &value);
d1607 3
a1609 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_GOTOFF12,
				       &result_type, &value);
d1619 39
a1657 3
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
				       &result_type, &value);
d1680 1
a1680 2
  if ((**strp == '#' || **strp == '%')
      && strncasecmp (*strp + 1, "gprel12(", 8) == 0)
d1682 96
a1777 64
      *strp += 9;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GPREL12,
                                    &result_type, &value);
      if (**strp != ')')
        return "missing `)'";
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else if ((**strp == '#' || **strp == '%')
	   && strncasecmp (*strp + 1, "got12(", 6) == 0)
    {
      *strp += 7;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOT12,
				   &result_type, &value);
      if (**strp != ')')
	return "missing ')'";
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else if ((**strp == '#' || **strp == '%')
	   && strncasecmp (*strp + 1, "gotfuncdesc12(", 14) == 0)
    {
      *strp += 15;
      errmsg = cgen_parse_address (cd, strp, opindex,
				   BFD_RELOC_FRV_FUNCDESC_GOT12,
				   &result_type, &value);
      if (**strp != ')')
	return "missing ')'";
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else if ((**strp == '#' || **strp == '%')
	   && strncasecmp (*strp + 1, "gotoff12(", 9) == 0)
    {
      *strp += 10;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOTOFF12,
				   &result_type, &value);
      if (**strp != ')')
	return "missing ')'";
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else if ((**strp == '#' || **strp == '%')
	   && strncasecmp (*strp + 1, "gotofffuncdesc12(", 17) == 0)
    {
      *strp += 18;
      errmsg = cgen_parse_address (cd, strp, opindex,
				   BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
				   &result_type, &value);
      if (**strp != ')')
	return "missing ')'";
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else
    {
      if (**strp == '#')
        ++*strp;
      return cgen_parse_signed_integer (cd, strp, opindex, valuep);
d1779 4
d1801 3
a1803 2
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GPRELU12,
                                    &result_type, &value);
d1881 32
d1924 13
@


1.7
log
@cpu/
	* frv.cpu (nsdiv, nudiv, nsdivi, nudivi): Remove fr400 profiling unit.
	(scutss): Change unit to I0.
	(calll, callil, ccalll): Add missing FR550-MAJOR and profile unit.
	(mqsaths): Fix FR400-MAJOR categorization.
	(media-quad-multiply-cross-acc, media-quad-cross-multiply-cross-acc)
	(media-quad-cross-multiply-acc): Change unit from MDUALACC to FMALL.
	* frv.opc (fr400_check_insn_major_constraints): Check for (M-2,M-1)
	combinations.

opcodes/
	* frv-desc.c, frv-opc.c: Regenerate.

sim/frv/
	* cache.c (frv_cache_init): Change fr400 cache statistics to match
	the fr405.
	(non_cache_access): Add missing breaks.
	* interrupts.c (set_exception_status_registers): Always set EAR15
	for data_access_errors.
	* memory.c (fr400_check_write_address): Remove redundant alignment
	check.
	* model.c: Regenerate.
@
text
@d93 2
d111 4
d130 1
d150 4
d169 3
d185 3
d201 3
d314 36
d381 1
d413 1
d431 4
d573 37
d846 3
d888 3
@


1.6
log
@cpu/
	* frv.cpu (UNIT): Add IACC.
	(iacc-multiply-r-r): Use it.
	* frv.opc (fr400_unit_mapping): Add entry for IACC.
	(fr500_unit_mapping, fr550_unit_mapping): Likewise.

opcodes/
	* frv-desc.h: Regenerate.
	* frv-desc.c: Regenerate.
	* frv-opc.c: Regenerate.
@
text
@d502 2
@


1.6.8.1
log
@Merge mainline to intercu branch.
@
text
@a92 2
static int fr450_check_insn_major_constraints
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE));
a108 4
    case bfd_mach_fr450:
      if (major >= FR450_MAJOR_B_1 && major <= FR450_MAJOR_B_6)
	return 1; /* is a branch */
      break;
a123 1
    case bfd_mach_fr450:
a142 4
    case bfd_mach_fr450:
      if (major >= FR450_MAJOR_M_1 && major <= FR450_MAJOR_M_6)
	return 1; /* is a media insn */
      break;
a157 3
  if (frv_is_branch_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),
			   bfd_mach_fr450))
    return 1;
a170 3
  if (frv_is_float_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),
			  bfd_mach_fr450))
    return 1;
a183 3
  if (frv_is_media_major (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR),
			  bfd_mach_fr450))
    return 1;
a293 36
/* MDCUTSSI */     UNIT_FM0, /* mdcutssi            only in FM0 unit.  */
/* MCLRACC-1*/     UNIT_FM0  /* mclracc,A==1   insn only in FM0 unit.  */
};

/* Some insns are assigned specialized implementation units which map to
   different actual implementation units on different machines.  These
   tables perform that mapping.  */
static CGEN_ATTR_VALUE_TYPE fr450_unit_mapping[] =
{
/* unit in insn    actual unit */
/* NIL      */     UNIT_NIL,
/* I0       */     UNIT_I0,
/* I1       */     UNIT_I1,
/* I01      */     UNIT_I01, 
/* I2       */     UNIT_NIL, /* no I2 or I3 unit */
/* I3       */     UNIT_NIL,
/* IALL     */     UNIT_I01, /* only I0 and I1 units */
/* FM0      */     UNIT_FM0,
/* FM1      */     UNIT_FM1,
/* FM01     */     UNIT_FM01,
/* FM2      */     UNIT_NIL, /* no F2 or M2 units */
/* FM3      */     UNIT_NIL, /* no F3 or M3 units */
/* FMALL    */     UNIT_FM01,/* Only F0,F1,M0,M1 units */
/* FMLOW    */     UNIT_FM0, /* Only F0,M0 units */
/* B0       */     UNIT_B0,  /* branches only in B0 unit.  */
/* B1       */     UNIT_B0,
/* B01      */     UNIT_B0,
/* C        */     UNIT_C,
/* MULT-DIV */     UNIT_I0,  /* multiply and divide only in I0  unit.  */
/* IACC     */     UNIT_I01, /* iacc multiply       in I0 or I1 unit.  */
/* LOAD     */     UNIT_I0,  /* load                only in I0  unit.  */
/* STORE    */     UNIT_I0,  /* store               only in I0  unit.  */
/* SCAN     */     UNIT_I0,  /* scan                only in I0  unit.  */
/* DCPL     */     UNIT_I0,  /* dcpl                only in I0  unit.  */
/* MDUALACC */     UNIT_FM0, /* media dual acc insn only in FM0 unit.  */
/* MDCUTSSI */     UNIT_FM01, /* mdcutssi           in FM0 or FM1.  */
a324 1
/* MDCUTSSI */     UNIT_FM0, /* mdcutssi            only in FM0 unit.  */
a355 1
/* MDCUTSSI */     UNIT_FM01, /* mdcutssi            in FM0 or FM1 unit.  */
a372 4
    case bfd_mach_fr450:
      vliw->current_vliw = fr400_allowed_vliw;
      vliw->unit_mapping = fr450_unit_mapping;
      break;
a501 2
    case FR400_MAJOR_M_1:
      return !find_major_in_vliw (vliw, FR400_MAJOR_M_2);
a508 37
fr450_check_insn_major_constraints (
  FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major
)
{
  CGEN_ATTR_VALUE_TYPE other_major;

  /* Our caller guarantees there's at least one other instruction.  */
  other_major = CGEN_INSN_ATTR_VALUE (vliw->insn[0], CGEN_INSN_FR450_MAJOR);

  /* (M4, M5) and (M4, M6) are allowed.  */
  if (other_major == FR450_MAJOR_M_4)
    if (major == FR450_MAJOR_M_5 || major == FR450_MAJOR_M_6)
      return 1;

  /* Otherwise, instructions in even-numbered media categories cannot be
     executed in parallel with other media instructions.  */
  switch (major)
    {
    case FR450_MAJOR_M_2:
    case FR450_MAJOR_M_4:
    case FR450_MAJOR_M_6:
      return !(other_major >= FR450_MAJOR_M_1
	       && other_major <= FR450_MAJOR_M_6);

    case FR450_MAJOR_M_1:
    case FR450_MAJOR_M_3:
    case FR450_MAJOR_M_5:
      return !(other_major == FR450_MAJOR_M_2
	       || other_major == FR450_MAJOR_M_4
	       || other_major == FR450_MAJOR_M_6);

    default:
      return 1;
    }
}

static int
a744 3
    case bfd_mach_fr450:
      rc = fr450_check_insn_major_constraints (vliw, major);
      break;
a783 3
      break;
    case bfd_mach_fr450:
      major = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR450_MAJOR);
@


1.5
log
@2003-12-19  Alexandre Oliva  <aoliva@@redhat.com>
* frv.opc (parse_ulo16, parse_uhi16, parse_d12): Fix some
cut&paste errors in shifting/truncating numerical operands.
2003-08-08  Alexandre Oliva  <aoliva@@redhat.com>
* frv.opc (parse_ulo16): Parse gotofflo and gotofffuncdesclo.
(parse_uslo16): Likewise.
(parse_uhi16): Parse gotoffhi and gotofffuncdeschi.
(parse_d12): Parse gotoff12 and gotofffuncdesc12.
(parse_s12): Likewise.
2003-08-04  Alexandre Oliva  <aoliva@@redhat.com>
* frv.opc (parse_ulo16): Parse gotlo and gotfuncdesclo.
(parse_uslo16): Likewise.
(parse_uhi16): Parse gothi and gotfuncdeschi.
(parse_d12): Parse got12 and gotfuncdesc12.
(parse_s12): Likewise.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2003 Free Software Foundation, Inc.
d288 1
d319 1
d350 1
@


1.4
log
@2003-10-06  Dave Brolley  <brolley@@redhat.com>

        * frv.cpu, frv.opc: Add support for fr550.
@
text
@d900 60
a959 1
	    value >>= 16;
d1008 59
d1112 59
d1253 47
d1324 50
@


1.4.2.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@@


1.4.2.2
log
@Merge mainline to branch.  GDB is broken until I update cp-names.y.
@
text
@d900 1
a900 60
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotlo(", 6) == 0)
	{
	  *strp += 7;
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOTLO,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotfuncdesclo(", 14) == 0)
	{
	  *strp += 15;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTLO,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofflo(", 9) == 0)
	{
	  *strp += 10;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_GOTOFFLO,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofffuncdesclo(", 17) == 0)
	{
	  *strp += 18;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
a948 59
      else if (strncasecmp (*strp + 1, "gotlo(", 6) == 0)
	{
	  *strp += 7;
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOTLO,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotfuncdesclo(", 14) == 0)
	{
	  *strp += 15;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTLO,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofflo(", 9) == 0)
	{
	  *strp += 10;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_GOTOFFLO,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofffuncdesclo(", 17) == 0)
	{
	  *strp += 18;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTOFFLO,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value &= 0xffff;
	  *valuep = value;
	  return errmsg;
	}
a993 59
      else if (strncasecmp (*strp + 1, "gothi(", 6) == 0)
	{
	  *strp += 7;
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOTHI,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value >>= 16;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotfuncdeschi(", 14) == 0)
	{
	  *strp += 15;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTHI,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value >>= 16;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotoffhi(", 9) == 0)
	{
	  *strp += 10;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_GOTOFFHI,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value >>= 16;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofffuncdeschi(", 17) == 0)
	{
	  *strp += 18;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTOFFHI,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  if (errmsg == NULL
	      && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	    value >>= 16;
	  *valuep = value;
	  return errmsg;
	}
a1075 47
      else if (strncasecmp (*strp + 1, "got12(", 6) == 0)
	{
	  *strp += 7;
	  errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOT12,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotfuncdesc12(", 14) == 0)
	{
	  *strp += 15;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOT12,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotoff12(", 9) == 0)
	{
	  *strp += 10;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_GOTOFF12,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
      else if (strncasecmp (*strp + 1, "gotofffuncdesc12(", 17) == 0)
	{
	  *strp += 18;
	  errmsg = cgen_parse_address (cd, strp, opindex,
				       BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
				       &result_type, &value);
	  if (**strp != ')')
	    return "missing ')'";
	  ++*strp;
	  *valuep = value;
	  return errmsg;
	}
a1099 50
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else if ((**strp == '#' || **strp == '%')
	   && strncasecmp (*strp + 1, "got12(", 6) == 0)
    {
      *strp += 7;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOT12,
				   &result_type, &value);
      if (**strp != ')')
	return "missing ')'";
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else if ((**strp == '#' || **strp == '%')
	   && strncasecmp (*strp + 1, "gotfuncdesc12(", 14) == 0)
    {
      *strp += 15;
      errmsg = cgen_parse_address (cd, strp, opindex,
				   BFD_RELOC_FRV_FUNCDESC_GOT12,
				   &result_type, &value);
      if (**strp != ')')
	return "missing ')'";
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else if ((**strp == '#' || **strp == '%')
	   && strncasecmp (*strp + 1, "gotoff12(", 9) == 0)
    {
      *strp += 10;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_FRV_GOTOFF12,
				   &result_type, &value);
      if (**strp != ')')
	return "missing ')'";
      ++*strp;
      *valuep = value;
      return errmsg;
    }
  else if ((**strp == '#' || **strp == '%')
	   && strncasecmp (*strp + 1, "gotofffuncdesc12(", 17) == 0)
    {
      *strp += 18;
      errmsg = cgen_parse_address (cd, strp, opindex,
				   BFD_RELOC_FRV_FUNCDESC_GOTOFF12,
				   &result_type, &value);
      if (**strp != ')')
	return "missing ')'";
@


1.4.2.3
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d3 1
a3 1
   Copyright 2000, 2001, 2003, 2004 Free Software Foundation, Inc.
a287 1
/* IACC     */     UNIT_I01, /* iacc multiply       in I0 or I1 unit.  */
a317 1
/* IACC     */     UNIT_NIL, /* iacc multiply       not implemented */
a347 1
/* IACC     */     UNIT_NIL,  /* iacc multiply       not implemented.     */
@


1.3
log
@2003-09-03  Dave Brolley  <brolley@@redhat.com>

        * frv.opc (parse_A, parse_A0, parse_A1): New parse handlers.
        * frv.cpu (UNIT): Add IALL, FMALL, FMLOW, STORE, SCAN, DCPL, MDUALACC,
        MCLRACC-1.
        (A): Removed operand.
        (A0,A1): New operands replace operand A.
        (mnop): Now a real insn
        (mclracc): Removed insn.
        (mclracc-0, mclracc-1): New insns replace mclracc.
        (all insns): Use new UNIT attributes.
@
text
@d3 1
a3 1
   Copyright 2003 Free Software Foundation, Inc.
d52 2
a53 1
#define FRV_VLIW_SIZE 4 /* fr500 has largest vliw size of 4.  */
d65 1
d81 1
d95 2
d98 1
a98 1
  PARAMS ((FRV_VLIW *, CGEN_ATTR_VALUE_TYPE));
d198 8
a205 8
  {  UNIT_I0,    UNIT_I1,    UNIT_NIL,   UNIT_NIL  },
  {  UNIT_I0,    UNIT_FM0,   UNIT_NIL,   UNIT_NIL  },
  {  UNIT_I0,    UNIT_B0,    UNIT_NIL,   UNIT_NIL  },
  {  UNIT_FM0,   UNIT_FM1,   UNIT_NIL,   UNIT_NIL  },
  {  UNIT_FM0,   UNIT_B0,    UNIT_NIL,   UNIT_NIL  },
  {  UNIT_B0,    UNIT_NIL,   UNIT_NIL,   UNIT_NIL  },
  {  UNIT_C,     UNIT_NIL,   UNIT_NIL,   UNIT_NIL  },
  {  UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL  }
d209 2
d215 46
a260 11
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_FM1  },
  {  UNIT_I0,    UNIT_FM0,   UNIT_I1,    UNIT_B0   },
  {  UNIT_I0,    UNIT_FM0,   UNIT_FM1,   UNIT_B0   },
  {  UNIT_I0,    UNIT_FM0,   UNIT_B0,    UNIT_B1   },
  {  UNIT_I0,    UNIT_I1,    UNIT_B0,    UNIT_B1   },
  {  UNIT_I0,    UNIT_B0,    UNIT_B1,    UNIT_NIL  },
  {  UNIT_FM0,   UNIT_FM1,   UNIT_B0,    UNIT_B1   },
  {  UNIT_FM0,   UNIT_B0,    UNIT_B1,    UNIT_NIL  },
  {  UNIT_B0,    UNIT_B1,    UNIT_NIL,   UNIT_NIL  },
  {  UNIT_C,     UNIT_NIL,   UNIT_NIL,   UNIT_NIL  },
  {  UNIT_NIL,   UNIT_NIL,   UNIT_NIL,   UNIT_NIL  }
d273 2
d279 2
d303 2
d309 2
d326 30
d370 4
d406 7
d447 5
a451 1
    abort (); /* Should never happen */
d506 117
d723 2
d733 1
a733 1
  FRV_VLIW *vliw, CGEN_ATTR_VALUE_TYPE major
d742 3
d771 5
a775 1
    abort (); /* no UNIT specified for this insn in frv.cpu  */
d782 3
d796 1
d807 1
a807 1
      if (new_vliw && check_insn_major_constraints (vliw, major))
d811 1
@


1.2
log
@Add code to handle even-numbered only register operands
@
text
@d188 1
a188 1
   in slots 2 and 3.
d231 1
d235 2
d241 7
a247 2
/* MULT-DIV */     UNIT_I0,  /* multiply and divide only in I0 unit.  */
/* LOAD     */     UNIT_I0   /* load                only in I0 unit.  */
d257 1
d261 2
d268 6
a273 1
/* LOAD     */     UNIT_I01  /* load                in I0 or I1 unit.  */
d556 9
a564 4
  if (vliw->mach == bfd_mach_fr400)
    major = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR400_MAJOR);
  else
    major = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_FR500_MAJOR);
d630 6
d916 43
@


1.1
log
@2003-06-03  Andrew Cagney  <cagney@@redhat.com>

	Contributed by Red Hat.
	* frv.cpu: New file.  Written by Dave Brolley, Catherine Moore,
	and Eric Christopher.
	* frv.opc: New file.  Written by Catherine Moore, and Dave
	Brolley.
	* simplify.inc: New file.  Written by Doug Evans.
@
text
@d43 1
a43 1
#undef CGEN_DIS_HASH_SIZE
d45 1
a45 1
#undef CGEN_DIS_HASH
d48 3
d607 2
d891 20
@

