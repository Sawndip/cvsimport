head	1.16;
access;
symbols
	sid-snapshot-20180601:1.16
	cgen-snapshot-20180601:1.16
	sid-snapshot-20180501:1.16
	cgen-snapshot-20180501:1.16
	sid-snapshot-20180401:1.16
	cgen-snapshot-20180401:1.16
	sid-snapshot-20180301:1.16
	cgen-snapshot-20180301:1.16
	sid-snapshot-20180201:1.16
	cgen-snapshot-20180201:1.16
	sid-snapshot-20180101:1.16
	cgen-snapshot-20180101:1.16
	sid-snapshot-20171201:1.16
	cgen-snapshot-20171201:1.16
	sid-snapshot-20171101:1.16
	cgen-snapshot-20171101:1.16
	sid-snapshot-20171001:1.16
	cgen-snapshot-20171001:1.16
	sid-snapshot-20170901:1.16
	cgen-snapshot-20170901:1.16
	sid-snapshot-20170801:1.16
	cgen-snapshot-20170801:1.16
	sid-snapshot-20170701:1.16
	cgen-snapshot-20170701:1.16
	sid-snapshot-20170601:1.16
	cgen-snapshot-20170601:1.16
	sid-snapshot-20170501:1.16
	cgen-snapshot-20170501:1.16
	sid-snapshot-20170401:1.16
	cgen-snapshot-20170401:1.16
	sid-snapshot-20170301:1.16
	cgen-snapshot-20170301:1.16
	sid-snapshot-20170201:1.16
	cgen-snapshot-20170201:1.16
	sid-snapshot-20170101:1.16
	cgen-snapshot-20170101:1.16
	sid-snapshot-20161201:1.16
	cgen-snapshot-20161201:1.16
	sid-snapshot-20161101:1.16
	cgen-snapshot-20161101:1.16
	sid-snapshot-20160901:1.16
	cgen-snapshot-20160901:1.16
	sid-snapshot-20160801:1.16
	cgen-snapshot-20160801:1.16
	sid-snapshot-20160701:1.16
	cgen-snapshot-20160701:1.16
	sid-snapshot-20160601:1.16
	cgen-snapshot-20160601:1.16
	sid-snapshot-20160501:1.16
	cgen-snapshot-20160501:1.16
	sid-snapshot-20160401:1.16
	cgen-snapshot-20160401:1.16
	sid-snapshot-20160301:1.16
	cgen-snapshot-20160301:1.16
	sid-snapshot-20160201:1.16
	cgen-snapshot-20160201:1.16
	sid-snapshot-20160101:1.16
	cgen-snapshot-20160101:1.16
	sid-snapshot-20151201:1.16
	cgen-snapshot-20151201:1.16
	sid-snapshot-20151101:1.16
	cgen-snapshot-20151101:1.16
	sid-snapshot-20151001:1.16
	cgen-snapshot-20151001:1.16
	sid-snapshot-20150901:1.16
	cgen-snapshot-20150901:1.16
	sid-snapshot-20150801:1.16
	cgen-snapshot-20150801:1.16
	sid-snapshot-20150701:1.16
	cgen-snapshot-20150701:1.16
	sid-snapshot-20150601:1.16
	cgen-snapshot-20150601:1.16
	sid-snapshot-20150501:1.16
	cgen-snapshot-20150501:1.16
	sid-snapshot-20150401:1.16
	cgen-snapshot-20150401:1.16
	sid-snapshot-20150301:1.16
	cgen-snapshot-20150301:1.16
	sid-snapshot-20150201:1.16
	cgen-snapshot-20150201:1.16
	sid-snapshot-20150101:1.16
	cgen-snapshot-20150101:1.16
	sid-snapshot-20141201:1.16
	cgen-snapshot-20141201:1.16
	sid-snapshot-20141101:1.16
	cgen-snapshot-20141101:1.16
	sid-snapshot-20141001:1.16
	cgen-snapshot-20141001:1.16
	sid-snapshot-20140901:1.16
	cgen-snapshot-20140901:1.16
	sid-snapshot-20140801:1.16
	cgen-snapshot-20140801:1.16
	sid-snapshot-20140701:1.16
	cgen-snapshot-20140701:1.16
	sid-snapshot-20140601:1.16
	cgen-snapshot-20140601:1.16
	sid-snapshot-20140501:1.16
	cgen-snapshot-20140501:1.16
	sid-snapshot-20140401:1.16
	cgen-snapshot-20140401:1.16
	sid-snapshot-20140301:1.16
	cgen-snapshot-20140301:1.16
	sid-snapshot-20140201:1.16
	cgen-snapshot-20140201:1.16
	sid-snapshot-20140101:1.16
	cgen-snapshot-20140101:1.16
	sid-snapshot-20131201:1.16
	cgen-snapshot-20131201:1.16
	sid-snapshot-20131101:1.16
	cgen-snapshot-20131101:1.16
	sid-snapshot-20131001:1.16
	cgen-snapshot-20131001:1.16
	binutils-2_24-branch:1.16.0.22
	binutils-2_24-branchpoint:1.16
	binutils-2_21_1:1.16
	sid-snapshot-20130901:1.16
	cgen-snapshot-20130901:1.16
	gdb_7_6_1-2013-08-30-release:1.16
	sid-snapshot-20130801:1.16
	cgen-snapshot-20130801:1.16
	sid-snapshot-20130701:1.16
	cgen-snapshot-20130701:1.16
	sid-snapshot-20130601:1.16
	cgen-snapshot-20130601:1.16
	sid-snapshot-20130501:1.16
	cgen-snapshot-20130501:1.16
	gdb_7_6-2013-04-26-release:1.16
	sid-snapshot-20130401:1.16
	cgen-snapshot-20130401:1.16
	binutils-2_23_2:1.16
	gdb_7_6-branch:1.16.0.20
	gdb_7_6-2013-03-12-branchpoint:1.16
	sid-snapshot-20130301:1.16
	cgen-snapshot-20130301:1.16
	sid-snapshot-20130201:1.16
	cgen-snapshot-20130201:1.16
	sid-snapshot-20130101:1.16
	cgen-snapshot-20130101:1.16
	sid-snapshot-20121201:1.16
	cgen-snapshot-20121201:1.16
	gdb_7_5_1-2012-11-29-release:1.16
	binutils-2_23_1:1.16
	sid-snapshot-20121101:1.16
	cgen-snapshot-20121101:1.16
	binutils-2_23:1.16
	sid-snapshot-20121001:1.16
	cgen-snapshot-20121001:1.16
	sid-snapshot-20120901:1.16
	cgen-snapshot-20120901:1.16
	gdb_7_5-2012-08-17-release:1.16
	sid-snapshot-20120801:1.16
	cgen-snapshot-20120801:1.16
	binutils-2_23-branch:1.16.0.18
	binutils-2_23-branchpoint:1.16
	gdb_7_5-branch:1.16.0.16
	gdb_7_5-2012-07-18-branchpoint:1.16
	sid-snapshot-20120701:1.16
	cgen-snapshot-20120701:1.16
	sid-snapshot-20120601:1.16
	cgen-snapshot-20120601:1.16
	sid-snapshot-20120501:1.16
	cgen-snapshot-20120501:1.16
	binutils-2_22_branch:1.16.0.14
	gdb_7_4_1-2012-04-26-release:1.16
	sid-snapshot-20120401:1.16
	cgen-snapshot-20120401:1.16
	sid-snapshot-20120301:1.16
	cgen-snapshot-20120301:1.16
	sid-snapshot-20120201:1.16
	cgen-snapshot-20120201:1.16
	gdb_7_4-2012-01-24-release:1.16
	sid-snapshot-20120101:1.16
	cgen-snapshot-20120101:1.16
	gdb_7_4-branch:1.16.0.12
	gdb_7_4-2011-12-13-branchpoint:1.16
	sid-snapshot-20111201:1.16
	cgen-snapshot-20111201:1.16
	binutils-2_22:1.16
	sid-snapshot-20111101:1.16
	cgen-snapshot-20111101:1.16
	sid-snapshot-20111001:1.16
	cgen-snapshot-20111001:1.16
	binutils-2_22-branch:1.16.0.10
	binutils-2_22-branchpoint:1.16
	gdb_7_3_1-2011-09-04-release:1.16
	sid-snapshot-20110901:1.16
	cgen-snapshot-20110901:1.16
	sid-snapshot-20110801:1.16
	cgen-snapshot-20110801:1.16
	gdb_7_3-2011-07-26-release:1.16
	sid-snapshot-20110701:1.16
	cgen-snapshot-20110701:1.16
	sid-snapshot-20110601:1.16
	cgen-snapshot-20110601:1.16
	sid-snapshot-20110501:1.16
	cgen-snapshot-20110501:1.16
	gdb_7_3-branch:1.16.0.8
	gdb_7_3-2011-04-01-branchpoint:1.16
	sid-snapshot-20110401:1.16
	cgen-snapshot-20110401:1.16
	sid-snapshot-20110301:1.16
	cgen-snapshot-20110301:1.16
	sid-snapshot-20110201:1.16
	cgen-snapshot-20110201:1.16
	sid-snapshot-20110101:1.16
	cgen-snapshot-20110101:1.16
	binutils-2_21:1.16
	sid-snapshot-20101201:1.16
	cgen-snapshot-20101201:1.16
	binutils-2_21-branch:1.16.0.6
	binutils-2_21-branchpoint:1.16
	sid-snapshot-20101101:1.16
	cgen-snapshot-20101101:1.16
	sid-snapshot-20101001:1.16
	cgen-snapshot-20101001:1.16
	binutils-2_20_1:1.13
	gdb_7_2-2010-09-02-release:1.16
	sid-snapshot-20100901:1.16
	cgen-snapshot-20100901:1.16
	sid-snapshot-20100801:1.16
	cgen-snapshot-20100801:1.16
	gdb_7_2-branch:1.16.0.4
	gdb_7_2-2010-07-07-branchpoint:1.16
	sid-snapshot-20100701:1.16
	cgen-snapshot-20100701:1.16
	sid-snapshot-20100601:1.16
	cgen-snapshot-20100601:1.16
	sid-snapshot-20100501:1.16
	cgen-snapshot-20100501:1.16
	sid-snapshot-20100401:1.16
	cgen-snapshot-20100401:1.16
	gdb_7_1-2010-03-18-release:1.16
	sid-snapshot-20100301:1.16
	cgen-snapshot-20100301:1.16
	gdb_7_1-branch:1.16.0.2
	gdb_7_1-2010-02-18-branchpoint:1.16
	sid-snapshot-20100201:1.16
	cgen-snapshot-20100201:1.16
	sid-snapshot-20100101:1.15
	cgen-snapshot-20100101:1.15
	gdb_7_0_1-2009-12-22-release:1.13
	sid-snapshot-20091201:1.14
	cgen-snapshot-20091201:1.14
	sid-snapshot-20091101:1.14
	cgen-snapshot-20091101:1.14
	binutils-2_20:1.13
	gdb_7_0-2009-10-06-release:1.13
	sid-snapshot-20091001:1.13
	cgen-snapshot-20091001:1.13
	gdb_7_0-branch:1.13.0.4
	gdb_7_0-2009-09-16-branchpoint:1.13
	arc-sim-20090309:1.11
	binutils-arc-20081103-branch:1.11.0.28
	binutils-arc-20081103-branchpoint:1.11
	binutils-2_20-branch:1.13.0.2
	binutils-2_20-branchpoint:1.13
	sid-snapshot-20090901:1.12
	cgen-snapshot-20090901:1.12
	sid-snapshot-20090801:1.12
	cgen-snapshot-20090801:1.12
	msnyder-checkpoint-072509-branch:1.12.0.4
	msnyder-checkpoint-072509-branchpoint:1.12
	sid-snapshot-20090701:1.12
	cgen-snapshot-20090701:1.12
	dje-cgen-play1-branch:1.12.0.2
	dje-cgen-play1-branchpoint:1.12
	cgen-1_1-branch:1.11.0.26
	cgen-1_1-branchpoint:1.11
	sid-snapshot-20090601:1.11
	cgen-snapshot-20090601:1.11
	sid-snapshot-20090501:1.11
	cgen-snapshot-20090501:1.11
	sid-snapshot-20090401:1.11
	cgen-snapshot-20090401:1.11
	arc-20081103-branch:1.11.0.24
	arc-20081103-branchpoint:1.11
	arc-insight_6_8-branch:1.11.0.22
	arc-insight_6_8-branchpoint:1.11
	insight_6_8-branch:1.11.0.20
	insight_6_8-branchpoint:1.11
	sid-snapshot-20090301:1.11
	cgen-snapshot-20090301:1.11
	binutils-2_19_1:1.11
	sid-snapshot-20090201:1.11
	cgen-snapshot-20090201:1.11
	sid-snapshot-20090101:1.11
	cgen-snapshot-20090101:1.11
	reverse-20081226-branch:1.11.0.18
	reverse-20081226-branchpoint:1.11
	sid-snapshot-20081201:1.11
	cgen-snapshot-20081201:1.11
	multiprocess-20081120-branch:1.11.0.16
	multiprocess-20081120-branchpoint:1.11
	sid-snapshot-20081101:1.11
	cgen-snapshot-20081101:1.11
	binutils-2_19:1.11
	sid-snapshot-20081001:1.11
	cgen-snapshot-20081001:1.11
	reverse-20080930-branch:1.11.0.14
	reverse-20080930-branchpoint:1.11
	binutils-2_19-branch:1.11.0.12
	binutils-2_19-branchpoint:1.11
	sid-snapshot-20080901:1.11
	cgen-snapshot-20080901:1.11
	sid-snapshot-20080801:1.11
	cgen-snapshot-20080801:1.11
	reverse-20080717-branch:1.11.0.10
	reverse-20080717-branchpoint:1.11
	sid-snapshot-20080701:1.11
	cgen-snapshot-20080701:1.11
	msnyder-reverse-20080609-branch:1.11.0.8
	msnyder-reverse-20080609-branchpoint:1.11
	drow-reverse-20070409-branch:1.10.0.14
	drow-reverse-20070409-branchpoint:1.10
	sid-snapshot-20080601:1.11
	cgen-snapshot-20080601:1.11
	sid-snapshot-20080501:1.11
	cgen-snapshot-20080501:1.11
	sid-snapshot-20080403:1.11
	sid-snapshot-20080401:1.11
	cgen-snapshot-20080401:1.11
	gdb_6_8-2008-03-27-release:1.11
	sid-snapshot-20080301:1.11
	cgen-snapshot-20080301:1.11
	gdb_6_8-branch:1.11.0.6
	gdb_6_8-2008-02-26-branchpoint:1.11
	sid-snapshot-20080201:1.11
	cgen-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	cgen-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	cgen-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	cgen-snapshot-20071101:1.11
	gdb_6_7_1-2007-10-29-release:1.11
	gdb_6_7-2007-10-10-release:1.11
	sid-snapshot-20071001:1.11
	cgen-snapshot-20071001:1.11
	gdb_6_7-branch:1.11.0.4
	gdb_6_7-2007-09-07-branchpoint:1.11
	binutils-2_18:1.11
	binutils-2_18-branch:1.11.0.2
	binutils-2_18-branchpoint:1.11
	insight_6_6-20070208-release:1.10
	binutils-csl-coldfire-4_1-32:1.9.2.1
	binutils-csl-sourcerygxx-4_1-32:1.9.2.1
	gdb_6_6-2006-12-18-release:1.10
	binutils-csl-innovasic-fido-3_4_4-33:1.9.2.1
	binutils-csl-coldfire-4_1-30:1.9.2.1
	binutils-csl-sourcerygxx-4_1-30:1.9.2.1
	binutils-csl-coldfire-4_1-28:1.9.2.1
	binutils-csl-sourcerygxx-4_1-29:1.9.2.1
	binutils-csl-sourcerygxx-4_1-28:1.9.2.1
	gdb_6_6-branch:1.10.0.12
	gdb_6_6-2006-11-15-branchpoint:1.10
	binutils-csl-arm-2006q3-27:1.9.2.1
	binutils-csl-sourcerygxx-4_1-27:1.9.2.1
	binutils-csl-arm-2006q3-26:1.9.2.1
	binutils-csl-sourcerygxx-4_1-26:1.9.2.1
	binutils-csl-sourcerygxx-4_1-25:1.9.2.1
	binutils-csl-sourcerygxx-4_1-24:1.9.2.1
	binutils-csl-sourcerygxx-4_1-23:1.9.2.1
	insight_6_5-20061003-release:1.10
	gdb-csl-symbian-6_4_50_20060226-12:1.8
	binutils-csl-sourcerygxx-4_1-21:1.9.2.1
	binutils-csl-arm-2006q3-21:1.9.2.1
	binutils-csl-sourcerygxx-4_1-22:1.9.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.9.2.1
	binutils-csl-sourcerygxx-4_1-20:1.9.2.1
	binutils-csl-arm-2006q3-19:1.9.2.1
	binutils-csl-sourcerygxx-4_1-19:1.9.2.1
	binutils-csl-sourcerygxx-4_1-18:1.9.2.1
	binutils-csl-renesas-4_1-9:1.9.2.1
	gdb-csl-sourcerygxx-3_4_4-25:1.8
	nickrob-async-20060828-mergepoint:1.10
	gdb-csl-symbian-6_4_50_20060226-11:1.8
	binutils-csl-renesas-4_1-8:1.9
	binutils-csl-renesas-4_1-7:1.9
	binutils-csl-renesas-4_1-6:1.9
	gdb-csl-sourcerygxx-4_1-17:1.8
	binutils-csl-sourcerygxx-4_1-17:1.9
	gdb-csl-20060226-branch-local-2:1.8
	gdb-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-14:1.9
	binutils-csl-sourcerygxx-4_1-15:1.9
	gdb-csl-sourcerygxx-4_1-13:1.8
	binutils-csl-sourcerygxx-4_1-13:1.9
	binutils-2_17:1.10
	gdb-csl-sourcerygxx-4_1-12:1.8
	binutils-csl-sourcerygxx-4_1-12:1.9
	gdb-csl-sourcerygxx-3_4_4-21:1.8
	binutils-csl-sourcerygxx-3_4_4-21:1.9
	gdb_6_5-20060621-release:1.10
	gdb-csl-sourcerygxx-4_1-9:1.8
	binutils-csl-sourcerygxx-4_1-9:1.9
	gdb-csl-sourcerygxx-4_1-8:1.8
	binutils-csl-sourcerygxx-4_1-8:1.9
	gdb-csl-sourcerygxx-4_1-7:1.8
	binutils-csl-sourcerygxx-4_1-7:1.9
	gdb-csl-arm-2006q1-6:1.8
	binutils-csl-arm-2006q1-6:1.9
	gdb-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-sourcerygxx-4_1-6:1.9
	gdb-csl-symbian-6_4_50_20060226-10:1.8
	gdb-csl-symbian-6_4_50_20060226-9:1.8
	gdb-csl-symbian-6_4_50_20060226-8:1.8
	gdb-csl-coldfire-4_1-11:1.8
	binutils-csl-coldfire-4_1-11:1.9
	gdb-csl-sourcerygxx-3_4_4-19:1.8
	binutils-csl-sourcerygxx-3_4_4-19:1.9
	gdb-csl-coldfire-4_1-10:1.8
	gdb_6_5-branch:1.10.0.10
	gdb_6_5-2006-05-14-branchpoint:1.10
	binutils-csl-coldfire-4_1-10:1.9
	gdb-csl-sourcerygxx-4_1-5:1.8
	binutils-csl-sourcerygxx-4_1-5:1.9
	nickrob-async-20060513-branch:1.10.0.8
	nickrob-async-20060513-branchpoint:1.10
	gdb-csl-sourcerygxx-4_1-4:1.8
	binutils-csl-sourcerygxx-4_1-4:1.9
	msnyder-reverse-20060502-branch:1.10.0.6
	msnyder-reverse-20060502-branchpoint:1.10
	gdb-csl-morpho-4_1-4:1.8
	binutils-csl-morpho-4_1-4:1.9
	gdb-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-sourcerygxx-3_4_4-17:1.9
	readline_5_1-import-branch:1.10.0.4
	readline_5_1-import-branchpoint:1.10
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.8
	binutils-2_17-branch:1.10.0.2
	binutils-2_17-branchpoint:1.10
	gdb-csl-symbian-20060226-branch:1.8.0.12
	gdb-csl-symbian-20060226-branchpoint:1.8
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.8
	msnyder-reverse-20060331-branch:1.9.0.4
	msnyder-reverse-20060331-branchpoint:1.9
	binutils-csl-2_17-branch:1.9.0.2
	binutils-csl-2_17-branchpoint:1.9
	gdb-csl-available-20060303-branch:1.8.0.10
	gdb-csl-available-20060303-branchpoint:1.8
	gdb-csl-20060226-branch:1.8.0.8
	gdb-csl-20060226-branchpoint:1.8
	gdb_6_4-20051202-release:1.8
	msnyder-fork-checkpoint-branch:1.8.0.6
	msnyder-fork-checkpoint-branchpoint:1.8
	gdb-csl-gxxpro-6_3-branch:1.8.0.4
	gdb-csl-gxxpro-6_3-branchpoint:1.8
	gdb_6_4-branch:1.8.0.2
	gdb_6_4-2005-11-01-branchpoint:1.8
	gdb-csl-arm-20051020-branch:1.5.0.2
	gdb-csl-arm-20051020-branchpoint:1.5
	binutils_latest_snapshot:1.16;
locks; strict;
comment	@# @;


1.16
date	2010.01.02.18.37.59;	author devans;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.11.13.42.07;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.24.00.17.07;	author devans;	state Exp;
branches;
next	1.13;

1.13
date	2009.09.02.07.21.03;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.22.00.53.25;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.05.09.49.03;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.10.21.19.14;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.14.04.20.53;	author dj;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2005.10.28.19.33.06;	author brolley;	state Exp;
branches;
next	1.7;

1.7
date	2005.10.27.23.54.17;	author dj;	state Exp;
branches;
next	1.6;

1.6
date	2005.10.26.14.59.10;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.26.03.21.50;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2005.07.18.14.13.29;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2005.07.16.18.43.55;	author jimb;	state Exp;
branches;
next	1.2;

1.2
date	2005.07.15.20.31.17;	author jimb;	state Exp;
branches;
next	1.1;

1.1
date	2005.07.14.22.52.00;	author jimb;	state Exp;
branches;
next	;

1.9.2.1
date	2006.08.22.15.08.30;	author jsm28;	state Exp;
branches;
next	;


desc
@@


1.16
log
@	* m32c.opc (parse_signed16): Fix typo.
@
text
@/* m32c opcode support.  -*- C -*-

   Copyright 2005, 2007, 2009, 2010 Free Software Foundation, Inc.

   Contributed by Red Hat Inc; developed under contract from Renesas

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This file is an addendum to m32c.cpu.  Heavy use of C code isn't
   appropriate in .cpu files, so it resides here.  This especially applies
   to assembly/disassembly where parsing/printing can be quite involved.
   Such things aren't really part of the specification of the cpu, per se,
   so .cpu files provide the general framework and .opc files handle the
   nitty-gritty details as necessary.

   Each section is delimited with start and end markers.

   <arch>-opc.h additions use: "-- opc.h"
   <arch>-opc.c additions use: "-- opc.c"
   <arch>-asm.c additions use: "-- asm.c"
   <arch>-dis.c additions use: "-- dis.c"
   <arch>-ibd.h additions use: "-- ibd.h".  */

/* -- opc.h */

/* Needed for RTL's 'ext' and 'trunc' operators.  */
#include "cgen/basic-modes.h"
#include "cgen/basic-ops.h"

/* We can't use the default hash size because many bits are used by
   operands.  */
#define CGEN_DIS_HASH_SIZE 1
#define CGEN_DIS_HASH(buf, value) 0
#define CGEN_VERBOSE_ASSEMBLER_ERRORS
#define CGEN_VALIDATE_INSN_SUPPORTED

extern int m32c_cgen_insn_supported (CGEN_CPU_DESC, const CGEN_INSN *);

#define CGEN_ASM_HASH_SIZE 0xffff
#define CGEN_ASM_HASH(mnem) m32c_asm_hash ((mnem))

/* -- */

/* -- opc.c */
static unsigned int
m32c_asm_hash (const char *mnem)
{
  unsigned int h;
  
  /* The length of the mnemonic for the Jcnd insns is 1.  Hash jsri.  */
  if (mnem[0] == 'j' && mnem[1] != 's')
    return 'j';
  
  /* Don't hash scCND  */
  if (mnem[0] == 's' && mnem[1] == 'c')
    return 's';
  
  /* Don't hash bmCND  */
  if (mnem[0] == 'b' && mnem[1] == 'm')
    return 'b';
  
  for (h = 0; *mnem && *mnem != ' ' && *mnem != ':'; ++mnem)
    h += *mnem;
  return h % CGEN_ASM_HASH_SIZE;
}

/* -- asm.c */
#include "safe-ctype.h"

#define MACH_M32C 5		/* Must match md_begin.  */

static int
m32c_cgen_isa_register (const char **strp)
 {
   int u;
   const char *s = *strp;
   static char * m32c_register_names [] = 
     {
       "r0", "r1", "r2", "r3", "r0l", "r0h", "r1l", "r1h",
       "a0", "a1", "r2r0", "r3r1", "sp", "fb", "dct0", "dct1", "flg", "svf",
       "drc0", "drc1", "dmd0", "dmd1", "intb", "svp", "vct", "isp", "dma0",
       "dma1", "dra0", "dra1", "dsa0", "dsa1", 0
     };
 
   for (u = 0; m32c_register_names[u]; u++)
     {
       int len = strlen (m32c_register_names[u]);

       if (memcmp (m32c_register_names[u], s, len) == 0
	   && (s[len] == 0 || ! ISALNUM (s[len])))
        return 1;
     }
   return 0;
}

#define PARSE_UNSIGNED							\
  do									\
    {									\
      /* Don't successfully parse literals beginning with '['.  */	\
      if (**strp == '[')						\
	return "Invalid literal"; /* Anything -- will not be seen.  */	\
									\
      errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);\
      if (errmsg)							\
	return errmsg;							\
    }									\
  while (0)

#define PARSE_SIGNED							\
  do									\
    {									\
      /* Don't successfully parse literals beginning with '['.  */	\
      if (**strp == '[')						\
	return "Invalid literal"; /* Anything -- will not be seen.  */	\
									\
      errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);  \
      if (errmsg)							\
	return errmsg;							\
    }									\
  while (0)

static const char *
parse_unsigned6 (CGEN_CPU_DESC cd, const char **strp,
		 int opindex, unsigned long *valuep)
{
  const char *errmsg = 0;
  unsigned long value;

  PARSE_UNSIGNED;

  if (value > 0x3f)
    return _("imm:6 immediate is out of range");

  *valuep = value;
  return 0;
}

static const char *
parse_unsigned8 (CGEN_CPU_DESC cd, const char **strp,
		 int opindex, unsigned long *valuep)
{
  const char *errmsg = 0;
  unsigned long value = 0;
  long have_zero = 0;

  if (strncasecmp (*strp, "%dsp8(", 6) == 0)
    {
      enum cgen_parse_operand_result result_type;
      bfd_vma val;

      *strp += 6;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_8,
				   & result_type, & val);
      if (**strp != ')')
	return _("missing `)'");
      (*strp) ++;

      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	return _("%dsp8() takes a symbolic address, not a number");

      value = val;
      *valuep = value;
      return errmsg;
    }

  if (strncmp (*strp, "0x0", 3) == 0 
      || (**strp == '0' && *(*strp + 1) != 'x'))
    have_zero = 1;

  PARSE_UNSIGNED;

  if (value > 0xff)
    return _("dsp:8 immediate is out of range");

  /* If this field may require a relocation then use larger dsp16.  */
  if (! have_zero && value == 0)
    return _("dsp:8 immediate is out of range");

  *valuep = value;
  return 0;
}

static const char *
parse_signed4 (CGEN_CPU_DESC cd, const char **strp,
	       int opindex, signed long *valuep)
{
  const char *errmsg = 0;
  signed long value;
  long have_zero = 0;

  if (strncmp (*strp, "0x0", 3) == 0 
      || (**strp == '0' && *(*strp + 1) != 'x'))
    have_zero = 1;

  PARSE_SIGNED;

  if (value < -8 || value > 7)
    return _("Immediate is out of range -8 to 7");

  /* If this field may require a relocation then use larger dsp16.  */
  if (! have_zero && value == 0)
    return _("Immediate is out of range -8 to 7");

  *valuep = value;
  return 0;
}

static const char *
parse_signed4n (CGEN_CPU_DESC cd, const char **strp,
		int opindex, signed long *valuep)
{
  const char *errmsg = 0;
  signed long value;
  long have_zero = 0;

  if (strncmp (*strp, "0x0", 3) == 0 
      || (**strp == '0' && *(*strp + 1) != 'x'))
    have_zero = 1;

  PARSE_SIGNED;

  if (value < -7 || value > 8)
    return _("Immediate is out of range -7 to 8");

  /* If this field may require a relocation then use larger dsp16.  */
  if (! have_zero && value == 0)
    return _("Immediate is out of range -7 to 8");

  *valuep = -value;
  return 0;
}

static const char *
parse_signed8 (CGEN_CPU_DESC cd, const char **strp,
	       int opindex, signed long *valuep)
{
  const char *errmsg = 0;
  signed long value = 0;

  if (strncasecmp (*strp, "%hi8(", 5) == 0)
    {
      enum cgen_parse_operand_result result_type;
      bfd_vma val;

      *strp += 5;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_M32C_HI8,
				   & result_type, & val);
      if (**strp != ')')
	return _("missing `)'");
      (*strp) ++;

      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	val >>= 16;

      value = val;
      *valuep = value;
      return errmsg;
    }

  PARSE_SIGNED;

  if (value <= 255 && value > 127)
    value -= 0x100;

  if (value < -128 || value > 127)
    return _("dsp:8 immediate is out of range");

  *valuep = value;
  return 0;
}

static const char *
parse_unsigned16 (CGEN_CPU_DESC cd, const char **strp,
		 int opindex, unsigned long *valuep)
{
  const char *errmsg = 0;
  unsigned long value = 0;
  long have_zero = 0;

  if (strncasecmp (*strp, "%dsp16(", 7) == 0)
    {
      enum cgen_parse_operand_result result_type;
      bfd_vma val;

      *strp += 7;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_16,
				   & result_type, & val);
      if (**strp != ')')
	return _("missing `)'");
      (*strp) ++;

      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	return _("%dsp16() takes a symbolic address, not a number");

      value = val;
      *valuep = value;
      return errmsg;
    }

  /* Don't successfully parse literals beginning with '['.  */
  if (**strp == '[')
    return "Invalid literal"; /* Anything -- will not be seen.  */

  /* Don't successfully parse register names.  */
  if (m32c_cgen_isa_register (strp))
    return "Invalid literal"; /* Anything -- will not be seen.  */

  if (strncmp (*strp, "0x0", 3) == 0 
      || (**strp == '0' && *(*strp + 1) != 'x'))
    have_zero = 1;
  
  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;

  if (value > 0xffff)
    return _("dsp:16 immediate is out of range");

  /* If this field may require a relocation then use larger dsp24.  */
  if (cd->machs == MACH_M32C && ! have_zero && value == 0
      && (strncmp (*strp, "[a", 2) == 0
	  || **strp == ','
	  || **strp == 0))
    return _("dsp:16 immediate is out of range");

  *valuep = value;
  return 0;
}

static const char *
parse_signed16 (CGEN_CPU_DESC cd, const char **strp,
	       int opindex, signed long *valuep)
{
  const char *errmsg = 0;
  signed long value = 0;

  if (strncasecmp (*strp, "%lo16(", 6) == 0)
    {
      enum cgen_parse_operand_result result_type;
      bfd_vma val;

      *strp += 6;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_LO16,
				   & result_type, & val);
      if (**strp != ')')
	return _("missing `)'");
      (*strp) ++;

      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	val &= 0xffff;

      value = val;
      *valuep = value;
      return errmsg;
    }

  if (strncasecmp (*strp, "%hi16(", 6) == 0)
    {
      enum cgen_parse_operand_result result_type;
      bfd_vma val;

      *strp += 6;
      errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16,
				   & result_type, & val);
      if (**strp != ')')
	return _("missing `)'");
      (*strp) ++;

      if (errmsg == NULL
  	  && result_type == CGEN_PARSE_OPERAND_RESULT_NUMBER)
	val >>= 16;

      value = val;
      *valuep = value;
      return errmsg;
    }

  PARSE_SIGNED;

  if (value <= 65535 && value > 32767)
    value -= 0x10000;

  if (value < -32768 || value > 32767)
    return _("dsp:16 immediate is out of range");

  *valuep = value;
  return 0;
}

static const char *
parse_unsigned20 (CGEN_CPU_DESC cd, const char **strp,
		 int opindex, unsigned long *valuep)
{
  const char *errmsg = 0;
  unsigned long value;
  
  /* Don't successfully parse literals beginning with '['.  */
  if (**strp == '[')
    return "Invalid literal"; /* Anything -- will not be seen.  */

  /* Don't successfully parse register names.  */
  if (m32c_cgen_isa_register (strp))
    return "Invalid literal"; /* Anything -- will not be seen.  */

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;

  if (value > 0xfffff)
    return _("dsp:20 immediate is out of range");

  *valuep = value;
  return 0;
}

static const char *
parse_unsigned24 (CGEN_CPU_DESC cd, const char **strp,
		 int opindex, unsigned long *valuep)
{
  const char *errmsg = 0;
  unsigned long value;
  
  /* Don't successfully parse literals beginning with '['.  */
  if (**strp == '[')
    return "Invalid literal"; /* Anything -- will not be seen.  */

  /* Don't successfully parse register names.  */
  if (m32c_cgen_isa_register (strp))
    return "Invalid literal"; /* Anything -- will not be seen.  */

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;

  if (value > 0xffffff)
    return _("dsp:24 immediate is out of range");

  *valuep = value;
  return 0;
}

/* This should only be used for #imm->reg.  */
static const char *
parse_signed24 (CGEN_CPU_DESC cd, const char **strp,
		 int opindex, signed long *valuep)
{
  const char *errmsg = 0;
  signed long value;

  PARSE_SIGNED;

  if (value <= 0xffffff && value > 0x7fffff)
    value -= 0x1000000;

  if (value > 0xffffff)
    return _("dsp:24 immediate is out of range");

  *valuep = value;
  return 0;
}

static const char *
parse_signed32 (CGEN_CPU_DESC cd, const char **strp,
		int opindex, signed long *valuep)
{
  const char *errmsg = 0;
  signed long value;
  
  errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;

  *valuep = value;
  return 0;
}

static const char *
parse_imm1_S (CGEN_CPU_DESC cd, const char **strp,
	     int opindex, signed long *valuep)
{
  const char *errmsg = 0;
  signed long value;

  errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;

  if (value < 1 || value > 2)
    return _("immediate is out of range 1-2");

  *valuep = value;
  return 0;
}

static const char *
parse_imm3_S (CGEN_CPU_DESC cd, const char **strp,
	     int opindex, signed long *valuep)
{
  const char *errmsg = 0;
  signed long value;
  
  errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;

  if (value < 1 || value > 8)
    return _("immediate is out of range 1-8");

  *valuep = value;
  return 0;
}

static const char *
parse_bit3_S (CGEN_CPU_DESC cd, const char **strp,
	     int opindex, signed long *valuep)
{
  const char *errmsg = 0;
  signed long value;
  
  errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;

  if (value < 0 || value > 7)
    return _("immediate is out of range 0-7");

  *valuep = value;
  return 0;
}

static const char *
parse_lab_5_3 (CGEN_CPU_DESC cd,
	       const char **strp,
	       int opindex ATTRIBUTE_UNUSED,
	       int opinfo,
	       enum cgen_parse_operand_result *type_addr,
	       bfd_vma *valuep)
{
  const char *errmsg = 0;
  bfd_vma value;
  enum cgen_parse_operand_result op_res;

  errmsg = cgen_parse_address (cd, strp, M32C_OPERAND_LAB_5_3,
			       opinfo, & op_res, & value);

  if (type_addr)
    *type_addr = op_res;

  if (op_res == CGEN_PARSE_OPERAND_RESULT_QUEUED)
    {
      /* This is a hack; the field cannot handle near-zero signed
	 offsets that CGEN wants to put in to indicate an "empty"
	 operand at first.  */
      *valuep = 2;
      return 0;
    }
  if (errmsg)
    return errmsg;

  if (value < 2 || value > 9)
    return _("immediate is out of range 2-9");

  *valuep = value;
  return 0;
}

static const char *
parse_Bitno16R (CGEN_CPU_DESC cd, const char **strp,
		int opindex, unsigned long *valuep)
{
  const char *errmsg = 0;
  unsigned long value;

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;

  if (value > 15)
    return _("Bit number for indexing general register is out of range 0-15");

  *valuep = value;
  return 0;
}

static const char *
parse_unsigned_bitbase (CGEN_CPU_DESC cd, const char **strp,
			int opindex, unsigned long *valuep,
			unsigned bits, int allow_syms)
{
  const char *errmsg = 0;
  unsigned long bit;
  unsigned long base;
  const char *newp = *strp;
  unsigned long long bitbase;
  long have_zero = 0;

  errmsg = cgen_parse_unsigned_integer (cd, & newp, opindex, & bit);
  if (errmsg)
    return errmsg;

  if (*newp != ',')
    return "Missing base for bit,base:8";

  ++newp;

  if (strncmp (newp, "0x0", 3) == 0 
      || (newp[0] == '0' && newp[1] != 'x'))
    have_zero = 1;

  errmsg = cgen_parse_unsigned_integer (cd, & newp, opindex, & base);
  if (errmsg)
    return errmsg;

  bitbase = (unsigned long long) bit + ((unsigned long long) base * 8);

  if (bitbase >= (1ull << bits))
    return _("bit,base is out of range");

  /* If this field may require a relocation then use larger displacement.  */
  if (! have_zero && base == 0)
    {
      switch (allow_syms) {
      case 0:
	return _("bit,base out of range for symbol");
      case 1:
	break;
      case 2:
	if (strncmp (newp, "[sb]", 4) != 0)
	  return _("bit,base out of range for symbol");
	break;
      }
    }

  *valuep = bitbase;
  *strp = newp;
  return 0;
}

static const char *
parse_signed_bitbase (CGEN_CPU_DESC cd, const char **strp,
		      int opindex, signed long *valuep,
		      unsigned bits, int allow_syms)
{
  const char *errmsg = 0;
  unsigned long bit;
  signed long base;
  const char *newp = *strp;
  long long bitbase;
  long long limit;
  long have_zero = 0;

  errmsg = cgen_parse_unsigned_integer (cd, & newp, opindex, & bit);
  if (errmsg)
    return errmsg;

  if (*newp != ',')
    return "Missing base for bit,base:8";

  ++newp;

  if (strncmp (newp, "0x0", 3) == 0 
      || (newp[0] == '0' && newp[1] != 'x'))
    have_zero = 1;

  errmsg = cgen_parse_signed_integer (cd, & newp, opindex, & base);
  if (errmsg)
    return errmsg;

  bitbase = (long long)bit + ((long long)base * 8);

  limit = 1ll << (bits - 1);
  if (bitbase < -limit || bitbase >= limit)
    return _("bit,base is out of range");

  /* If this field may require a relocation then use larger displacement.  */
  if (! have_zero && base == 0 && ! allow_syms)
    return _("bit,base out of range for symbol");

  *valuep = bitbase;
  *strp = newp;
  return 0;
}

static const char *
parse_unsigned_bitbase8 (CGEN_CPU_DESC cd, const char **strp,
			 int opindex, unsigned long *valuep)
{
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 8, 0);
}

static const char *
parse_unsigned_bitbase11 (CGEN_CPU_DESC cd, const char **strp,
			 int opindex, unsigned long *valuep)
{
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 11, 0);
}

static const char *
parse_unsigned_bitbase16 (CGEN_CPU_DESC cd, const char **strp,
			  int opindex, unsigned long *valuep)
{
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 16, 1);
}

static const char *
parse_unsigned_bitbase19 (CGEN_CPU_DESC cd, const char **strp,
			 int opindex, unsigned long *valuep)
{
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 19, 2);
}

static const char *
parse_unsigned_bitbase27 (CGEN_CPU_DESC cd, const char **strp,
			 int opindex, unsigned long *valuep)
{
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 27, 1);
}

static const char *
parse_signed_bitbase8 (CGEN_CPU_DESC cd, const char **strp,
		       int opindex, signed long *valuep)
{
  return parse_signed_bitbase (cd, strp, opindex, valuep, 8, 1);
}

static const char *
parse_signed_bitbase11 (CGEN_CPU_DESC cd, const char **strp,
		       int opindex, signed long *valuep)
{
  return parse_signed_bitbase (cd, strp, opindex, valuep, 11, 0);
}

static const char *
parse_signed_bitbase19 (CGEN_CPU_DESC cd, const char **strp,
		       int opindex, signed long *valuep)
{
  return parse_signed_bitbase (cd, strp, opindex, valuep, 19, 1);
}

/* Parse the suffix as :<char> or as nothing followed by a whitespace.  */

static const char *
parse_suffix (const char **strp, char suffix)
{
  const char *newp = *strp;
  
  if (**strp == ':' && TOLOWER (*(*strp + 1)) == suffix)
    newp = *strp + 2;

  if (ISSPACE (*newp))
    {
      *strp = newp;
      return 0;
    }
	
  return "Invalid suffix"; /* Anything -- will not be seen.  */
}

static const char *
parse_S (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
{
  return parse_suffix (strp, 's');
}

static const char *
parse_G (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
{
  return parse_suffix (strp, 'g');
}

static const char *
parse_Q (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
{
  return parse_suffix (strp, 'q');
}

static const char *
parse_Z (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
{
  return parse_suffix (strp, 'z');
}

/* Parse an empty suffix. Fail if the next char is ':'.  */

static const char *
parse_X (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
	 int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
{
  if (**strp == ':')
    return "Unexpected suffix";
  return 0;
}

static const char *
parse_r0l_r0h (CGEN_CPU_DESC cd, const char **strp,
	       int opindex ATTRIBUTE_UNUSED, signed long *valuep)
{
  const char *errmsg;
  signed long value;
  signed long junk;
  const char *newp = *strp;

  /* Parse r0[hl].  */
  errmsg = cgen_parse_keyword (cd, & newp, & m32c_cgen_opval_h_r0l_r0h, & value);
  if (errmsg)
    return errmsg;

  if (*newp != ',')
    return _("not a valid r0l/r0h pair");
  ++newp;

  /* Parse the second register in the pair.  */
  if (value == 0) /* r0l */
    errmsg = cgen_parse_keyword (cd, & newp, & m32c_cgen_opval_h_r0h, & junk);
  else
    errmsg = cgen_parse_keyword (cd, & newp, & m32c_cgen_opval_h_r0l, & junk);
  if (errmsg)
    return errmsg;

  *strp = newp;
  *valuep = ! value;
  return 0;
}

/* Accept .b or .w in any case.  */

static const char *
parse_size (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED, const char **strp,
	    int opindex ATTRIBUTE_UNUSED, signed long *valuep ATTRIBUTE_UNUSED)
{
  if (**strp == '.'
      && (*(*strp + 1) == 'b' || *(*strp + 1) == 'B'
	  || *(*strp + 1) == 'w' || *(*strp + 1) == 'W'))
    {
      *strp += 2;
      return NULL;
    }

  return _("Invalid size specifier");
}

/* Special check to ensure that instruction exists for given machine.  */

int
m32c_cgen_insn_supported (CGEN_CPU_DESC cd,
			  const CGEN_INSN *insn)
{
  int machs = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_MACH);
  CGEN_BITSET isas = CGEN_INSN_BITSET_ATTR_VALUE (insn, CGEN_INSN_ISA);

  /* If attributes are absent, assume no restriction.  */
  if (machs == 0)
    machs = ~0;

  return ((machs & cd->machs)
          && cgen_bitset_intersect_p (& isas, cd->isas));
}

/* Parse a set of registers, R0,R1,A0,A1,SB,FB.  */

static const char *
parse_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	      const char **strp,
	      int opindex ATTRIBUTE_UNUSED,
	      unsigned long *valuep,
	      int push)
{
  const char *errmsg = 0;
  int regno = 0;
 
  *valuep = 0;
  while (**strp && **strp != ')')
    {
      if (**strp == 'r' || **strp == 'R')
	{
	  ++*strp;
	  regno = **strp - '0';
	  if (regno > 4)
	    errmsg = _("Register number is not valid");
	}
      else if (**strp == 'a' || **strp == 'A')
	{
	  ++*strp;
	  regno = **strp - '0';
	  if (regno > 2)
	    errmsg = _("Register number is not valid");
	  regno = **strp - '0' + 4;
	}
      
      else if (strncasecmp (*strp, "sb", 2) == 0 || strncasecmp (*strp, "SB", 2) == 0)
	{
	  regno = 6;
	  ++*strp;
	}
      
      else if (strncasecmp (*strp, "fb", 2) == 0 || strncasecmp (*strp, "FB", 2) == 0)
	{
	  regno = 7;
	  ++*strp;
	}
      
      if (push) /* Mask is reversed for push.  */
	*valuep |= 0x80 >> regno;
      else
	*valuep |= 1 << regno;

      ++*strp;
      if (**strp == ',')
        {
          if (*(*strp + 1) == ')')
            break;
          ++*strp;
        }
    }

  if (!*strp)
    errmsg = _("Register list is not valid");

  return errmsg;
}

#define POP  0
#define PUSH 1

static const char *
parse_pop_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		  const char **strp,
		  int opindex ATTRIBUTE_UNUSED,
		  unsigned long *valuep)
{
  return parse_regset (cd, strp, opindex, valuep, POP);
}

static const char *
parse_push_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		   const char **strp,
		   int opindex ATTRIBUTE_UNUSED,
		   unsigned long *valuep)
{
  return parse_regset (cd, strp, opindex, valuep, PUSH);
}

/* -- dis.c */

#include "elf/m32c.h"
#include "elf-bfd.h"

/* Always print the short insn format suffix as ':<char>'.  */

static void
print_suffix (void * dis_info, char suffix)
{
  disassemble_info *info = dis_info;

  (*info->fprintf_func) (info->stream, ":%c", suffix);
}

static void
print_S (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	 void * dis_info,
	 long value ATTRIBUTE_UNUSED,
	 unsigned int attrs ATTRIBUTE_UNUSED,
	 bfd_vma pc ATTRIBUTE_UNUSED,
	 int length ATTRIBUTE_UNUSED)
{
  print_suffix (dis_info, 's');
}


static void
print_G (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	 void * dis_info,
	 long value ATTRIBUTE_UNUSED,
	 unsigned int attrs ATTRIBUTE_UNUSED,
	 bfd_vma pc ATTRIBUTE_UNUSED,
	 int length ATTRIBUTE_UNUSED)
{
  print_suffix (dis_info, 'g');
}

static void
print_Q (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	 void * dis_info,
	 long value ATTRIBUTE_UNUSED,
	 unsigned int attrs ATTRIBUTE_UNUSED,
	 bfd_vma pc ATTRIBUTE_UNUSED,
	 int length ATTRIBUTE_UNUSED)
{
  print_suffix (dis_info, 'q');
}

static void
print_Z (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	 void * dis_info,
	 long value ATTRIBUTE_UNUSED,
	 unsigned int attrs ATTRIBUTE_UNUSED,
	 bfd_vma pc ATTRIBUTE_UNUSED,
	 int length ATTRIBUTE_UNUSED)
{
  print_suffix (dis_info, 'z');
}

/* Print the empty suffix.  */

static void
print_X (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	 void * dis_info ATTRIBUTE_UNUSED,
	 long value ATTRIBUTE_UNUSED,
	 unsigned int attrs ATTRIBUTE_UNUSED,
	 bfd_vma pc ATTRIBUTE_UNUSED,
	 int length ATTRIBUTE_UNUSED)
{
  return;
}

static void
print_r0l_r0h (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	       void * dis_info,
	       long value,
	       unsigned int attrs ATTRIBUTE_UNUSED,
	       bfd_vma pc ATTRIBUTE_UNUSED,
	       int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = dis_info;

  if (value == 0)
    (*info->fprintf_func) (info->stream, "r0h,r0l");
  else
    (*info->fprintf_func) (info->stream, "r0l,r0h");
}

static void
print_unsigned_bitbase (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
			void * dis_info,
			unsigned long value,
			unsigned int attrs ATTRIBUTE_UNUSED,
			bfd_vma pc ATTRIBUTE_UNUSED,
			int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = dis_info;

  (*info->fprintf_func) (info->stream, "%ld,0x%lx", value & 0x7, value >> 3);
}

static void
print_signed_bitbase (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		      void * dis_info,
		      signed long value,
		      unsigned int attrs ATTRIBUTE_UNUSED,
		      bfd_vma pc ATTRIBUTE_UNUSED,
		      int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = dis_info;

  (*info->fprintf_func) (info->stream, "%ld,%ld", value & 0x7, value >> 3);
}

static void
print_size (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	    void * dis_info,
	    long value ATTRIBUTE_UNUSED,
	    unsigned int attrs ATTRIBUTE_UNUSED,
	    bfd_vma pc ATTRIBUTE_UNUSED,
	    int length ATTRIBUTE_UNUSED)
{
  /* Always print the size as '.w'.  */
  disassemble_info *info = dis_info;

  (*info->fprintf_func) (info->stream, ".w");
}

#define POP  0
#define PUSH 1

static void print_pop_regset  (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);
static void print_push_regset (CGEN_CPU_DESC, void *, long, unsigned int, bfd_vma, int);

/* Print a set of registers, R0,R1,A0,A1,SB,FB.  */

static void
print_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
	      void * dis_info,
	      long value,
	      unsigned int attrs ATTRIBUTE_UNUSED,
	      bfd_vma pc ATTRIBUTE_UNUSED,
	      int length ATTRIBUTE_UNUSED,
	      int push)
{
  static char * m16c_register_names [] = 
  {
    "r0", "r1", "r2", "r3", "a0", "a1", "sb", "fb"
  };
  disassemble_info *info = dis_info;
  int mask;
  int reg_index = 0;
  char* comma = "";

  if (push)
    mask = 0x80;
  else
    mask = 1;
 
  if (value & mask)
    {
      (*info->fprintf_func) (info->stream, "%s", m16c_register_names [0]);
      comma = ",";
    }

  for (reg_index = 1; reg_index <= 7; ++reg_index)
    {
      if (push)
        mask >>= 1;
      else
        mask <<= 1;

      if (value & mask)
        {
          (*info->fprintf_func) (info->stream, "%s%s", comma,
				 m16c_register_names [reg_index]);
          comma = ",";
        }
    }
}

static void
print_pop_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		  void * dis_info,
		  long value,
		  unsigned int attrs ATTRIBUTE_UNUSED,
		  bfd_vma pc ATTRIBUTE_UNUSED,
		  int length ATTRIBUTE_UNUSED)
{
  print_regset (cd, dis_info, value, attrs, pc, length, POP);
}

static void
print_push_regset (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		   void * dis_info,
		   long value,
		   unsigned int attrs ATTRIBUTE_UNUSED,
		   bfd_vma pc ATTRIBUTE_UNUSED,
		   int length ATTRIBUTE_UNUSED)
{
  print_regset (cd, dis_info, value, attrs, pc, length, PUSH);
}

static void
print_signed4n (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		void * dis_info,
		signed long value,
		unsigned int attrs ATTRIBUTE_UNUSED,
		bfd_vma pc ATTRIBUTE_UNUSED,
		int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = dis_info;

  (*info->fprintf_func) (info->stream, "%ld", -value);
}
@


1.15
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   Copyright 2005, 2007, 2009 Free Software Foundation, Inc.
d370 1
a370 1
	value &= 0xffff;
@


1.14
log
@	cpu/
	* m32c.opc (opc.h): cgen-types.h -> cgen/basic-modes.h.
	cgen-ops.h -> cgen/basic-ops.h.

	include/opcode/
	* cgen-bitset.h: Delete, moved to ../cgen/bitset.h.
	* cgen.h: Update.  Improve multi-inclusion macro name.

	include/cgen/
	* basic-modes.h: New file.  Moved here from opcodes/cgen-types.h.
	* basic-ops.h: New file.  Moved here from opcodes/cgen-ops.h.
	* bitset.h: New file.  Moved here from ../opcode/cgen-bitset.h.
	Update license to GPL v3.

	opcodes/
	* cgen-ops.h: Delete, moved to ../include/cgen/basic-ops.h.
	* cgen-types.h: Delete, moved to ../include/cgen/basic-modes.h.
	* cgen-bitset.c: Update.
	* fr30-desc.h: Regenerate.
	* frv-desc.h: Regenerate.
	* ip2k-desc.h: Regenerate.
	* iq2000-desc.h: Regenerate.
	* lm32-desc.h: Regenerate.
	* m32c-desc.h: Regenerate.
	* m32c-opc.h: Regenerate.
	* m32r-desc.h: Regenerate.
	* mep-desc.h: Regenerate.
	* mt-desc.h: Regenerate.
	* openrisc-desc.h: Regenerate.
	* xc16x-desc.h: Regenerate.
	* xstormy16-desc.h: Regenerate.
@
text
@d159 1
a159 1
  unsigned long value;
d165 1
a165 2
      bfd_vma value;
      const char *errmsg;
d169 1
a169 1
				   & result_type, & value);
d176 3
a178 3
	{
	  return _("%dsp8() takes a symbolic address, not a number");
	}
d255 1
a255 1
  signed long value;
d260 1
a260 2
      bfd_vma value;
      const char *errmsg;
d264 1
a264 1
				   & result_type, & value);
d271 3
a273 3
	{
	  value >>= 16;
	}
d295 1
a295 1
  unsigned long value;
d301 1
a301 2
      bfd_vma value;
      const char *errmsg;
d305 1
a305 1
				   & result_type, & value);
d312 3
a314 3
	{
	  return _("%dsp16() takes a symbolic address, not a number");
	}
d354 1
a354 1
  signed long value;
d359 1
a359 2
      bfd_vma value;
      const char *errmsg;
d363 1
a363 1
				   & result_type, & value);
d370 3
a372 3
	{
	  value &= 0xffff;
	}
d380 1
a380 2
      bfd_vma value;
      const char *errmsg;
d384 1
a384 1
				   & result_type, & value);
d391 3
a393 3
	{
	  value >>= 16;
	}
d1119 1
a1119 1
  int index = 0;
d1133 1
a1133 1
  for (index = 1; index <= 7; ++index)
d1143 1
a1143 1
				 m16c_register_names [index]);
@


1.13
log
@update copyright dates
@
text
@d43 2
a44 2
#include "cgen-types.h"
#include "cgen-ops.h"
@


1.12
log
@cpu/
	* m32c.opc (parse_lab_5_3): Use correct enum.
opcodes/
	* m32c-asm.c: Regenerate.
@
text
@d3 1
a3 1
   Copyright 2005, 2007 Free Software Foundation, Inc.
@


1.11
log
@Change source files over to GPLv3.
@
text
@d574 1
a574 1
  if (op_res == CGEN_PARSE_OPERAND_ADDRESS)
@


1.10
log
@* m32c.opc (parse_unsigned_bitbase): Take a new parameter which
decides if this function accepts symbolic constants or not.
(parse_signed_bitbase): Likewise.
(parse_unsigned_bitbase8): Pass the new parameter.
(parse_unsigned_bitbase11): Likewise.
(parse_unsigned_bitbase16): Likewise.
(parse_unsigned_bitbase19): Likewise.
(parse_unsigned_bitbase27): Likewise.
(parse_signed_bitbase8): Likewise.
(parse_signed_bitbase11): Likewise.
(parse_signed_bitbase19): Likewise.
* m32c-asm.c: Regenerate.
@
text
@d3 1
a3 1
   Copyright 2005 Free Software Foundation, Inc.
d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d21 3
a23 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.9
log
@* m32c.cpu (Bit3-S): New.
(btst:s): New.
* m32c.opc (parse_bit3_S): New.
@
text
@d611 1
a611 1
			unsigned bits)
d618 1
d628 5
d642 15
d665 1
a665 1
		      unsigned bits)
d673 1
d683 5
d698 4
d711 1
a711 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 8);
d718 1
a718 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 11);
d725 1
a725 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 16);
d732 1
a732 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 19);
d739 1
a739 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 27);
d746 1
a746 1
  return parse_signed_bitbase (cd, strp, opindex, valuep, 8);
d753 1
a753 1
  return parse_signed_bitbase (cd, strp, opindex, valuep, 11);
d760 1
a760 1
  return parse_signed_bitbase (cd, strp, opindex, valuep, 19);
@


1.9.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d611 1
a611 1
			unsigned bits, int allow_syms)
a617 1
  long have_zero = 0;
a626 5

  if (strncmp (newp, "0x0", 3) == 0 
      || (newp[0] == '0' && newp[1] != 'x'))
    have_zero = 1;

a635 15
  /* If this field may require a relocation then use larger displacement.  */
  if (! have_zero && base == 0)
    {
      switch (allow_syms) {
      case 0:
	return _("bit,base out of range for symbol");
      case 1:
	break;
      case 2:
	if (strncmp (newp, "[sb]", 4) != 0)
	  return _("bit,base out of range for symbol");
	break;
      }
    }

d644 1
a644 1
		      unsigned bits, int allow_syms)
a651 1
  long have_zero = 0;
a660 5

  if (strncmp (newp, "0x0", 3) == 0 
      || (newp[0] == '0' && newp[1] != 'x'))
    have_zero = 1;

a670 4
  /* If this field may require a relocation then use larger displacement.  */
  if (! have_zero && base == 0 && ! allow_syms)
    return _("bit,base out of range for symbol");

d680 1
a680 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 8, 0);
d687 1
a687 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 11, 0);
d694 1
a694 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 16, 1);
d701 1
a701 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 19, 2);
d708 1
a708 1
  return parse_unsigned_bitbase (cd, strp, opindex, valuep, 27, 1);
d715 1
a715 1
  return parse_signed_bitbase (cd, strp, opindex, valuep, 8, 1);
d722 1
a722 1
  return parse_signed_bitbase (cd, strp, opindex, valuep, 11, 0);
d729 1
a729 1
  return parse_signed_bitbase (cd, strp, opindex, valuep, 19, 1);
@


1.8
log
@2005-10-28  Dave Brolley  <brolley@@redhat.com>

        Contribute the following change:
        2003-09-24  Dave Brolley  <brolley@@redhat.com>

        * frv.opc: Use CGEN_ATTR_VALUE_ENUM_TYPE in place of
        CGEN_ATTR_VALUE_TYPE.
        * m32c.opc (m32c_cgen_insn_supported): Use CGEN_INSN_BITSET_ATTR_VALUE.
        Use cgen_bitset_intersect_p.
@
text
@d537 18
@


1.7
log
@* m32c.cpu (Imm-8-s4n, Imm-12-s4n): New.
(arith-jnz16-imm4-dst-defn, arith-jnz32-imm4-dst-defn,
arith-jnz-imm4-dst-mach, arith-jnz-imm4-dst): Keep track of which
imm operand is needed.
(adjnz, sbjnz): Pass the right operands.
(unary-insn-defn, unary16-defn, unary32-defn, unary-insn-mach,
unary-insn): Add -g variants for opcodes that need to support :G.
(not.BW:G, push.BW:G): Call it.
(stzx16-imm8-imm8-dsp8sb, stzx16-imm8-imm8-dsp8fb,
stzx16-imm8-imm8-abs16): Fix operand typos.
* m32c.opc (m32c_asm_hash): Support bnCND.
(parse_signed4n, print_signed4n): New.

* m32c-asm.c: Regenerate.
* m32c-desc.c: Regenerate.
* m32c-desc.h: Regenerate.
* m32c-dis.c: Regenerate.
* m32c-ibld.c: Regenerate.
* m32c-opc.c: Regenerate.
* m32c-opc.h: Regenerate.
@
text
@d827 1
a827 1
  int isas = CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_ISA);
d834 1
a834 1
	  && (isas & cd->isas));
@


1.6
log
@* m32c.cpu (f-dsp-8-s24, Dsp-8-s24): New.
(mov-dspsp-dst-defn, mov-src-dspsp-defn, mov16-dspsp-dst-defn,
mov16-src-dspsp-defn, mov32-dspsp-dst-defn, mov32-src-dspsp-defn):
dsp8[sp] is signed.
(mov.WL:S #imm,A0/A1): dsp24 is signed (i.e. -0x800000..0xffffff).
(mov.BW:S r0,r1): Fix typo r1l->r1.
(tst): Allow :G suffix.
* m32c.opc (parse_signed24): New, for -0x800000..0xffffff.

* m32c-asm.c: Regenerate.
* m32c-desc.c: Regenerate.
* m32c-desc.h: Regenerate.
* m32c-dis.c: Regenerate.
* m32c-ibld.c: Regenerate.
* m32c-opc.c: Regenerate.
* m32c-opc.h: Regenerate.
@
text
@d72 4
d225 25
d1124 13
@


1.5
log
@[bfd]
	* reloc.c: Remove unused M32C relocs, add BFD_RELOC_M32C_HI8.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	* elf32-m32c.c (m32c_elf_howto_table): Add R_M32C_8, R_M32C_LO16,
	R_M32C_HI8, R_M32C_HI16.
	(m32c_reloc_map): Likewise.
	(m32c_elf_relocate_section): Add R_M32C_HI8 and R_M32C_HI16.

[cpu]
	* m32c.opc (parse_unsigned8): Add %dsp8().
	(parse_signed8): Add %hi8().
	(parse_unsigned16): Add %dsp16().
	(parse_signed16): Add %lo16() and %hi16().
	(parse_lab_5_3): Make valuep a bfd_vma *.

[gas]
	* config/tc-m32c.c (md_cgen_lookup_reloc): Add 8 bit operands.
	Support %mod() modifiers from opcodes.
	* doc/c-m32c.texi (M32C-Modifiers): New section.

[include/elf]

	* m32c.h: Add R_M32C_8, R_M32C_LO16, R_M32C_HI8, and R_M32C_HI16.

[opcodes]
	* m32c-asm.c Regenerate.
	* m32c-dis.c Regenerate.
@
text
@d436 20
@


1.4
log
@Fix building for MS1 and M32C.
Restore alpha- sorting to the architecture tables.
@
text
@d156 22
d226 23
a248 1
  
d268 23
a290 1
 
d328 44
d493 1
a493 1
	       unsigned long *valuep)
d496 1
a496 1
  unsigned long value;
@


1.3
log
@* m32c.opc (m32c_cgen_insn_supported): Use int, not CGEN_BITSET,
to represent isa sets.
@
text
@d36 1
a36 2
   <arch>-ibd.h additions use: "-- ibd.h"
*/
d78 1
a78 1
#include <ctype.h>
d106 26
a137 5
  long have_zero = 0;

  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */
d139 1
a139 7
  if (strncmp (*strp, "0x0", 3) == 0 
      || (**strp == '0' && *(*strp + 1) != 'x'))
    have_zero = 1;

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;
a155 4
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */

d160 1
a160 3
  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;
a179 4
  
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */
d185 1
a185 3
  errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;
d205 1
a205 7
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */

  errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;
d225 1
a225 1
  /* Don't successfully parse literals beginning with '[' */
d227 1
a227 1
    return "Invalid literal"; /* anything -- will not be seen */
d229 1
a229 1
  /* Don't successfully parse register names */
d231 1
a231 1
    return "Invalid literal"; /* anything -- will not be seen */
a260 4
  
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */
d262 1
a262 3
  errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value);
  if (errmsg)
    return errmsg;
d281 1
a281 1
  /* Don't successfully parse literals beginning with '[' */
d283 1
a283 1
    return "Invalid literal"; /* anything -- will not be seen */
d285 1
a285 1
  /* Don't successfully parse register names */
d287 1
a287 1
    return "Invalid literal"; /* anything -- will not be seen */
d307 1
a307 1
  /* Don't successfully parse literals beginning with '[' */
d309 1
a309 1
    return "Invalid literal"; /* anything -- will not be seen */
d311 1
a311 1
  /* Don't successfully parse register names */
d313 1
a313 1
    return "Invalid literal"; /* anything -- will not be seen */
d328 1
a328 1
		 int opindex, signed long *valuep)
a332 10
#if 0
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */

  /* Don't successfully parse register names */
  if (m32c_cgen_isa_register (strp))
    return "Invalid literal"; /* anything -- will not be seen */
#endif

a346 5
  
#if 0
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */
d348 1
a348 6
  /* Don't successfully parse register names */
  if (m32c_cgen_isa_register (strp))
    return "Invalid literal"; /* anything -- will not be seen */
#endif

  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
d366 25
a390 4
#if 0
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */
d392 2
a393 4
  /* Don't successfully parse register names */
  if (m32c_cgen_isa_register (strp))
    return "Invalid literal"; /* anything -- will not be seen */
#endif
d395 8
a402 1
  errmsg = cgen_parse_unsigned_integer (cd, strp, opindex, & value);
d406 2
a407 2
  if (value < 1 || value > 8)
    return _("immediate is out of range 1-8");
a419 6
#if 0
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */
#endif

a441 6
#if 0
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */
#endif

d454 1
a454 1
  bitbase = (unsigned long long)bit + ((unsigned long long)base * 8);
a475 6
#if 0
  /* Don't successfully parse literals beginning with '[' */
  if (**strp == '[')
    return "Invalid literal"; /* anything -- will not be seen */
#endif

d556 1
d562 1
a562 1
  if (**strp == ':' && tolower (*(*strp + 1)) == suffix)
d565 1
a565 1
  if (isspace (*newp))
d571 1
a571 1
  return "Invalid suffix"; /* anything -- will not be seen */
d603 1
d622 1
a622 1
  /* Parse r0[hl] */
d628 1
a628 1
    return "not a valid r0l/r0h pair";
d631 1
a631 1
  /* Parse the second register in the pair */
d644 2
a645 1
/* Accept .b or .w in any case */
d655 1
a655 1
      return 0;
d657 2
a658 1
  return "Invalid size specifier";
d661 1
a661 183
/* static const char * parse_abs (CGEN_CPU_DESC, const char **, int, */
/* 			       unsigned long *, unsigned long); */
/* static const char * parse_abs16 (CGEN_CPU_DESC, const char **, int, */
/* 				 int ATTRIBUTE_UNUSED, */
/* 				 enum cgen_parse_operand_result * ATTRIBUTE_UNUSED, */
/* 				 unsigned long * ); */
/* static const char * parse_abs24 (CGEN_CPU_DESC, const char **, int, */
/* 				 int ATTRIBUTE_UNUSED, */
/* 				 enum cgen_parse_operand_result  * ATTRIBUTE_UNUSED, */
/* 				 unsigned long *); */

/* /\* Parse absolute  *\/ */

/* static const char * */
/* parse_abs16 (CGEN_CPU_DESC cd, const char **strp, int opindex, */
/* 	     int reloc ATTRIBUTE_UNUSED, */
/* 	     enum cgen_parse_operand_result *type_addr ATTRIBUTE_UNUSED, */
/* 	     unsigned long *valuep) */
/* { */
/*   return parse_abs (cd, strp, opindex, valuep, 16); */
/* } */

/* static const char * */
/* parse_abs24 (CGEN_CPU_DESC cd, const char **strp, int opindex, */
/* 	     int reloc ATTRIBUTE_UNUSED, */
/* 	     enum cgen_parse_operand_result *type_addr ATTRIBUTE_UNUSED, */
/* 	     unsigned long *valuep) */
/* { */
/*   return parse_abs (cd, strp, opindex, valuep, 24); */
/* } */

/* static const char * */
/* parse_abs (CGEN_CPU_DESC cd, const char **strp, int opindex, */
/* 	   unsigned long *valuep, */
/* 	   unsigned long length) */
/* { */
/*   const char *errmsg = 0; */
/*   const char *op; */
/*   int has_register = 0; */
    
/*   for (op = *strp; *op != '\0'; op++) */
/*     { */
/*       if (*op == '[') */
/* 	{ */
/* 	  has_register = 1; */
/* 	  break; */
/* 	} */
/*       else if (*op == ',') */
/* 	break; */
/*     } */
  
/*   if (has_register || m32c_cgen_isa_register (strp)) */
/*     errmsg = _("immediate value cannot be register"); */
/*   else */
/*     { */
/*       enum cgen_parse_operand_result result_type; */
/*       bfd_vma value; */
/*       const char *errmsg; */
 
/*       errmsg = cgen_parse_address (cd, strp, opindex, BFD_RELOC_HI16, */
/*                                    &result_type, &value); */
/*       *valuep = value; */
/*     } */
/*   return errmsg; */
/* } */
/* /\* Handle signed/unsigned literal.  *\/ */

/* static const char * */
/* parse_imm8 (cd, strp, opindex, valuep) */
/*      CGEN_CPU_DESC cd; */
/*      const char **strp; */
/*      int opindex; */
/*      unsigned long *valuep; */
/* { */
/*   const char *errmsg = 0; */
/*   long value; */
/*   long have_zero = 0; */
  
/*   if (strncmp (*strp, "0x0", 3) == 0  */
/*       || (**strp == '0' && *(*strp + 1) != 'x')) */
/*     have_zero = 1; */
/*   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value); */
/*   *valuep = value; */
/*   /\* If this field may require a relocation then use larger dsp16.  *\/ */
/*   if (! have_zero && value == 0) */
/*     errmsg = _("immediate value may not fit in dsp8 field"); */
    
/*   return errmsg; */
/* } */

/* static const char * */
/* parse_imm16 (cd, strp, opindex, valuep) */
/*      CGEN_CPU_DESC cd; */
/*      const char **strp; */
/*      int opindex; */
/*      unsigned long *valuep; */
/* { */
/*   const char *errmsg; */
/*   long value; */
 
/*   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value); */
/*   *valuep = value; */
/*   return errmsg; */
/* } */

/* static const char * */
/* parse_imm24 (cd, strp, opindex, valuep) */
/*      CGEN_CPU_DESC cd; */
/*      const char **strp; */
/*      int opindex; */
/*      unsigned long *valuep; */
/* { */
/*   const char *errmsg; */
/*   long value; */
 
/*   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value); */
/*   *valuep = value; */
/*   return errmsg; */
/* } */

/* static const char * */
/* parse_imm32 (cd, strp, opindex, valuep) */
/*      CGEN_CPU_DESC cd; */
/*      const char **strp; */
/*      int opindex; */
/*      unsigned long *valuep; */
/* { */
/*   const char *errmsg; */
/*   long value; */
 
/*   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value); */
/*   *valuep = value; */
/*   return errmsg; */
/* } */

/* /\* Handle bitfields.  *\/ */

/* static const char * */
/* parse_boff8 (cd, strp, opindex, valuep) */
/*      CGEN_CPU_DESC cd; */
/*      const char **strp; */
/*      int opindex; */
/*      unsigned long *valuep; */
/* { */
/*   const char *errmsg; */
/*   long bit_value, value; */
 
/*   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & bit_value); */
/*   if (errmsg == 0) */
/*     { */
/*       *strp = *strp + 1; */
/*       errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value); */
/*     } */
/*   value = value * 8 + bit_value; */
/*   *valuep = value; */
/*   if (value > 0x100) */
/*     errmsg = _("Operand out of range. Must be between 0 and 255."); */
/*   return errmsg; */
/* } */

/* static const char * */
/* parse_boff16 (cd, strp, opindex, valuep) */
/*      CGEN_CPU_DESC cd; */
/*      const char **strp; */
/*      int opindex; */
/*      unsigned long *valuep; */
/* { */
/*   const char *errmsg; */
/*   long bit_value, value; */
 
/*   errmsg = cgen_parse_signed_integer (cd, strp, opindex, & bit_value); */
/*   if (errmsg == 0) */
/*     { */
/*       *strp = *strp + 1; */
/*       errmsg = cgen_parse_signed_integer (cd, strp, opindex, & value); */
/*     } */
/*   value = value * 8 + bit_value; */
/*   *valuep = value; */
/*   if (value > 0x1000) */
/*     errmsg = _("Operand out of range. Must be between 0 and 65535."); */
/*   return errmsg; */
/* } */

a662 1
/* Special check to ensure that instruction exists for given machine */
d670 1
a670 1
  /* If attributes are absent, assume no restriction. */
d685 1
a685 2
	      int push
	      )
d741 1
a741 1
#define POP 0
d746 3
a748 3
		     const char **strp,
		     int opindex ATTRIBUTE_UNUSED,
		     unsigned long *valuep)
d755 3
a757 3
		     const char **strp,
		     int opindex ATTRIBUTE_UNUSED,
		     unsigned long *valuep)
d767 2
a768 1
/* Always print the short insn format suffix as ':<char>' */
d770 1
a770 1
print_suffix (PTR dis_info, char suffix)
d773 1
d779 1
a779 1
	 PTR dis_info,
d791 1
a791 1
	 PTR dis_info,
d802 1
a802 1
	 PTR dis_info,
d813 1
a813 1
	 PTR dis_info,
d822 2
a823 1
/* Print the empty suffix */
d826 1
a826 1
	 PTR dis_info ATTRIBUTE_UNUSED,
d837 1
a837 1
	       PTR dis_info,
d844 1
d853 1
a853 1
			PTR dis_info,
d860 1
d866 1
a866 1
		      PTR dis_info,
d873 1
d879 1
a879 1
	    PTR dis_info,
d885 1
a885 1
  /* Always print the size as '.w' */
d887 1
d891 1
a891 1
#define POP 0
d894 2
a895 2
static void print_pop_regset (CGEN_CPU_DESC, PTR, long, unsigned int, bfd_vma, int);
static void print_push_regset (CGEN_CPU_DESC, PTR, long, unsigned int, bfd_vma, int);
d901 6
a906 6
		PTR dis_info,
		long value,
		unsigned int attrs ATTRIBUTE_UNUSED,
		bfd_vma pc ATTRIBUTE_UNUSED,
		int length ATTRIBUTE_UNUSED,
		int push)
d909 3
a911 3
    {
      "r0", "r1", "r2", "r3", "a0", "a1", "sb", "fb"
    };
d946 5
a950 5
		    PTR dis_info,
		    long value,
		    unsigned int attrs ATTRIBUTE_UNUSED,
		    bfd_vma pc ATTRIBUTE_UNUSED,
		    int length ATTRIBUTE_UNUSED)
d957 5
a961 5
		     PTR dis_info,
		     long value,
		     unsigned int attrs ATTRIBUTE_UNUSED,
		     bfd_vma pc ATTRIBUTE_UNUSED,
		     int length ATTRIBUTE_UNUSED)
a964 16
#if 0 /* not used? */
static void
print_boff (CGEN_CPU_DESC cd ATTRIBUTE_UNUSED,
		     PTR dis_info,
		     long value,
		     unsigned int attrs ATTRIBUTE_UNUSED,
		     bfd_vma pc ATTRIBUTE_UNUSED,
		     int length ATTRIBUTE_UNUSED)
{
  disassemble_info *info = dis_info;
  if (value)
    info->fprintf_func (info->stream, "%d,%d", value % 16,
			(value / 16) * 2);
}

#endif /* not used? */
@


1.2
log
@* m32c.cpu, m32c.opc: Fix copyright.
@
text
@d869 1
a869 1
  CGEN_BITSET isas = CGEN_INSN_BITSET_ATTR_VALUE (insn, CGEN_INSN_ISA);
d875 2
a876 2
  return (machs & cd->machs)
    && cgen_bitset_intersect_p (& isas, cd->isas);
@


1.1
log
@ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* configure.in: Add cases for Renesas m32c.
	* configure: Regenerated.

bfd/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for m32c-*-elf (Renesas m32c and m16c).
	* Makefile.am (ALL_MACHINES): Add cpu-m32c.lo.
	(ALL_MACHINES_CFILES): Add cpu-m32c.c.
	(BFD32_BACKENDS): Add elf32-m32c.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-m32c.c.
	(cpu-m32c.lo, elf32-m32c.lo): New rules, generated by 'make dep-am'.
	* Makefile.in: Regenerated.
	* archures.c (bfd_arch_m32c, bfd_mach_m16c, bfd_mach_m32c): New
	arch and mach codes.
	(bfd_m32c_arch): New arch info object.
	(bfd_archures_list): List bfd_m32c_arch.
	* bfd-in2.h: Regenerated.
	* config.bfd: Add case for the m32c.
	* configure.in: Add case for the m32c.
	* configure: Regenerated.
	* cpu-m32c.c, elf32-m32c.c: New files.
	* libbfd.h: Regenerated.
	* targets.c (bfd_elf32_m32c_vec): Declare.
	(_bfd_target_vector): List bfd_elf32_m32c_vec.

binutils/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* readelf.c: #include "elf/m32c.h"
	(guess_is_rela, dump_relocations, get_machine_name): Add cases for
	EM_M32C.
	* Makefile.am (readelf.o): Update dependencies.
	* Makefile.in: Regenerated.

cpu/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* m32c.cpu, m32c.opc: Machine description for the Renesas M32C.

gas/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for the Renesas M32C.
	* Makefile.am (CPU_TYPES): List m32c.
	(TARGET_CPU_CFILES): List config/tc-m32c.c.
	(TARGET_CPU_HFILES): List config/tc-m32c.h.
	* configure.in: Add case for m32c.
	* configure.tgt: Add cases for m32c and m32c-*-elf.
	* configure: Regenerated.
	* config/tc-m32c.c, config/tc-m32c.h: New files.
	* doc/Makefile.am (CPU_DOCS): Add c-m32c.texi.
	* doc/Makefile.in: Regenerated.
	* doc/all.texi: Set M32C.
	* doc/as.texinfo: Add text for the M32C-specific options and line
	comment characters, and refer to c-m32c.texi.
	* doc/c-m32c.texi: New file.

include/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* dis-asm.h (print_insn_m32c): New declaration.

include/elf/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for Renesas M32C and M16C.
	* common.h (EM_M32C): New machine number.
	* m32c.h: New file.

ld/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for the Renesas M32C and M16C.
	* Makefile.am (ALL_EMULATIONS): Add eelf32m32c.o.
	(eelf32m32c.c): New target.
	* Makefile.in: Regenerated.
	* configure.tgt: Add case for m32c-*-elf.
	* emulparams/elf32m32c.sh: New file.

opcodes/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for the Renesas M32C and M16C.
	* m32c-asm.c, m32c-desc.c, m32c-dis.c, m32c-ibld.c, m32c-opc.c: New.
	* m32c-desc.h, m32c-opc.h: New.
	* Makefile.am (HFILES): List m32c-desc.h and m32c-opc.h.
	(CFILES): List m32c-asm.c, m32c-desc.c, m32c-dis.c, m32c-ibld.c,
	m32c-opc.c.
	(ALL_MACHINES): List m32c-asm.lo, m32c-desc.lo, m32c-dis.lo,
	m32c-ibld.lo, m32c-opc.lo.
	(CLEANFILES): List stamp-m32c.
	(M32C_DEPS): List stamp-m32c, if CGEN_MAINT.
	(CGEN_CPUS): Add m32c.
	(m32c-asm.c, m32c-desc.c, m32c-dis.c, m32c-ibld.c, m32c-opc.c)
	(m32c-desc.h, m32c-opc.h): Depend on M32C_DEPS.
	(m32c_opc_h): New variable.
	(stamp-m32c, m32c-asm.lo, m32c-desc.lo, m32c-dis.lo, m32c-ibld.lo)
	(m32c-opc.lo): New rules.
	* Makefile.in: Regenerated.
	* configure.in: Add case for bfd_m32c_arch.
	* configure: Regenerated.
	* disassemble.c (ARCH_m32c): New.
	[ARCH_m32c]: #include "m32c-desc.h".
	(disassembler) [ARCH_m32c]: Add case for bfd_arch_m32c.
	(disassemble_init_for_target) [ARCH_m32c]: Same.

	* cgen-ops.h, cgen-types.h: New files.
	* Makefile.am (HFILES): List them.
	* Makefile.in: Regenerated.
@
text
@d2 20
a21 2
   Copyright (C) 2005 Red Hat, Inc.
   This file is part of CGEN.  */
@

