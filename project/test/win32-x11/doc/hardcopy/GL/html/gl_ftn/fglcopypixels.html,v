head	1.2;
access;
symbols
	win32-x11-2001-03-26:1.1.1.1 SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2001.06.03.20.47.08;	author ssiddiqi;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.25.19.36.50;	author ssiddiqi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.25.19.36.50;	author ssiddiqi;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Win32-X11 update sources check in, June 3, 2001 - ssiddiqi
@
text
@<HTML>
<BODY>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
@


1.1
log
@Initial revision
@
text
@a4 160

</PRE>
<H2>bolic constants GL_COLOR, GL_DEPTH, and GL_STENCIL are  accepted.</H2><PRE>
_cmnd copies a screen-aligned rectangle of pixels from the speci­
fied frame buffer location to a region relative  to  the  current
raster  position.   Its operation is well defined only if the en­
tire pixel source region is within the  exposed  portion  of  the
window.   Results  of copies from outside the window, or from re­
gions of the window that are not exposed, are hardware  dependent
and  undefined.   _param1  and _param2 specify the window coordi­
nates of the lower left corner of the rectangular  region  to  be
copied.   _param3 and _param4 specify the dimensions of the rect­
angular region to be copied.  Both _param3 and _param4  must  not
be  negative.   Several  parameters control the processing of the
pixel data while it is being copied.  These  parameters  are  set
with  three  commands: _cmnd(PixelTransfer), _cmnd(PixelMap), and
_cmnd(PixelZoom).  This reference page describes the  effects  on
_cmnd  of most, but not all, of the parameters specified by these
three commands.  _cmnd copies values from  each  pixel  with  the
lower left-hand corner at (_param1 + $i$, _param2 + $j$) for 0 &lt;=
$i$ &lt; _param3 and 0 &lt;= $j$ &lt; _param4.  This pixel is said  to  be
the $i$th pixel in the $j$th row.  Pixels are copied in row order
from the lowest to the highest row, left to right  in  each  row.
_param5  specifies whether color, depth, or stencil data is to be
copied.  The details of the transfer for each data  type  are  as

</PRE>
<H2>follows: GL_COLOR Indices or RGBA colors are read from the buffer</H2><PRE>
currently specified as the read source  buffer  (see  _cmnd(Read­
Buffer)).   If  the GL is in color index mode, each index that is
read from this buffer is converted to a fixed-point  format  with
an  unspecified  number of bits to the right of the binary point.

</PRE>
<H2>Each index is then shifted left by GL_INDEX_SHIFT bits, and added</H2><PRE>

</PRE>
<H2>to  GL_INDEX_OFFSET.  If GL_INDEX_SHIFT is negative, the shift is</H2><PRE>
to the right.  In either case, zero bits fill otherwise  unspeci­

</PRE>
<H2>fied  bit  locations in the result.  If GL_MAP_COLOR is true, the</H2><PRE>
index is replaced with the value that  it  references  in  lookup

</PRE>
<H2>table GL_PIXEL_MAP_I_TO_I.  Whether the lookup replacement of the</H2><PRE>
index is done or not, the integer part of the index is then ANDed
with $2 sup b -1$, where $b$ is the number of bits in a color in­
dex buffer.  If the GL is in RGBA mode, the red, green, blue, and
alpha  components  of each pixel that is read are converted to an
internal floating-point format with unspecified  precision.   The
conversion maps the largest representable component value to 1.0,
and component value 0 to 0.0.  The resulting floating-point color

</PRE>
<H2>values  are then multiplied by GL_c_SCALE and added to GL_c_BIAS,</H2><PRE>
where <I>c</I> is RED, GREEN, BLUE, and ALPHA for the  respective  color
components.   The  results  are  clamped  to the range [0,1].  If

</PRE>
<H2>GL_MAP_COLOR is true, each color component is scaled by the  size</H2><PRE>

</PRE>
<H2>of  lookup  table GL_PIXEL_MAP_c_TO_c, then replaced by the value</H2><PRE>
that it references in that table.  <I>c</I> is R, G, B, or  A.   If  the
_arbstring(imaging)  extension is supported, the color values may
be additionally processed by  color-table  lookups,  color-matrix
transformations,  and  convolution filters.  The GL then converts
the resulting indices or RGBA colors to  fragments  by  attaching
the  current raster position <I>z</I> coordinate and texture coordinates
pixel, then assigning window coordinates ($x sub r ~+~ i , y  sub
r  ~+~ j$), where ($x sub r , y sub r$) is the current raster po­
sition, and the pixel was the  $i$th  pixel  in  the  $j$th  row.
These  pixel  fragments  are then treated just like the fragments
generated by rasterizing points,  lines,  or  polygons.   Texture
mapping,  fog, and all the fragment operations are applied before

</PRE>
<H2>the fragments are written to the frame buffer.  GL_STENCIL  Sten­</H2><PRE>
cil  indices are read from the stencil buffer and converted to an
internal fixed-point format with an unspecified number of bits to
the  right  of  the binary point.  Each fixed-point index is then

</PRE>
<H2>shifted left by GL_INDEX_SHIFT bits, and added  to  GL_INDEX_OFF­</H2><PRE>

</PRE>
<H2>SET.   If  GL_INDEX_SHIFT is negative, the shift is to the right.</H2><PRE>
In either case, zero bits fill otherwise  unspecified  bit  loca­

</PRE>
<H2>tions in the result.  If GL_MAP_STENCIL is true, the index is re­</H2><PRE>

</PRE>
<H2>placed with the value that it references in lookup table  GL_PIX­</H2><PRE>

</PRE>
<H2>EL_MAP_S_TO_S.   Whether  the  lookup replacement of the index is</H2><PRE>
done or not, the integer part of the index is then ANDed with  $2
sup b -1$, where $b$ is the number of bits in the stencil buffer.
The resulting stencil indices are then  written  to  the  stencil
buffer  such  that  the index read from the $i$th location of the
$j$th row is written to location ($x sub r ~+~ i , y  sub  r  ~+~
j$),  where ($x sub r , y sub r$) is the current raster position.
Only the pixel ownership test, the scissor test, and the  stencil
writemask  affect  these write operations.  The rasterization de­
scribed thus far assumes pixel zoom factors of 1.0.  If
_cmnd(PixelZoom) is used to change the $x$  and  $y$  pixel  zoom
factors,  pixels  are  converted to fragments as follows.  If ($x
sub r$, $y sub r$) is the current raster position,  and  a  given
pixel  is  in  the  $i$th location in the $j$th row of the source
pixel rectangle, then fragments are generated  for  pixels  whose
centers are in the rectangle with corners at
    ($x sub r ~+~ zoom sub x^ i$, $y sub r ~+~ zoom sub y^j$)
                               and
($x  sub r ~+~ zoom sub x^ (i ~+~ 1)$, $y sub r ~+~ zoom sub y^ (
                           j ~+~ 1 )$)

</PRE>
<H2>where $zoom sub x$ is the value of GL_ZOOM_X and $zoom sub y$  is</H2><PRE>

</PRE>
<H2>the  value  of  GL_ZOOM_Y.   To copy the color pixel in the lower</H2><PRE>
left corner of the window to the  current  raster  position,  use

</PRE>
<H2>glCopyPixels(0, 0, 1, 1, GL_COLOR); Modes specified by _cmnd(Pix­</H2><PRE>

</PRE>
<H2>elStore) have no  effect  on  the  operation  of  _cmnd.   GL_IN­</H2><PRE>

</PRE>
<H2>VALID_ENUM  is  generated  if  _param5  is not an accepted value.</H2><PRE>

</PRE>
<H2>GL_INVALID_VALUE is generated if either  _param3  or  _param4  is</H2><PRE>

</PRE>
<H2>negative.    GL_INVALID_OPERATION  is  generated  if  _param5  is</H2><PRE>

</PRE>
<H2>GL_DEPTH and there is no depth buffer.   GL_INVALID_OPERATION  is</H2><PRE>

</PRE>
<H2>generated  if  _param5  is  GL_STENCIL  and  there  is no stencil</H2><PRE>

</PRE>
<H2>buffer.  GL_INVALID_OPERATION is generated if _cmnd  is  executed</H2><PRE>
between  the execution of _cmnd(Begin) and the corresponding exe­

</PRE>
<H2>cution  of  _cmnd(End).    _cmnd(Get)   with   argument   GL_CUR­</H2><PRE>

</PRE>
<H2>RENT_RASTER_POSITION</H2><PRE>

</PRE>
<H2>_cmnd(Get)  with  argument  GL_CURRENT_RASTER_POSITION_VALID _cm­</H2><PRE>
nd(ColorTable), _cmnd(ConvolutionFilter1D), _cmnd(ConvolutionFil­
ter2D),  _cmnd(DepthFunc),  _cmnd(DrawBuffer), _cmnd(DrawPixels),
@


1.1.1.1
log
@win32-x11 source tree update March 26, 2001
@
text
@@
