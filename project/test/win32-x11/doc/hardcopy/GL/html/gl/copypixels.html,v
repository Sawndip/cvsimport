head	1.2;
access;
symbols
	win32-x11-2001-03-26:1.1.1.1 SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2001.06.03.20.47.06;	author ssiddiqi;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.25.19.36.50;	author ssiddiqi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.25.19.36.50;	author ssiddiqi;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Win32-X11 update sources check in, June 3, 2001 - ssiddiqi
@
text
@<HTML>
<BODY>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
@


1.1
log
@Initial revision
@
text
@a4 156

</PRE>
<H2>bolic constants GL_COLOR, GL_DEPTH, and GL_STENCIL are  accepted.</H2><PRE>
_cmnd copies a screen-aligned rectangle of pixels from the speci­
fied frame buffer location to a region relative  to  the  current
raster  position.   Its operation is well defined only if the en­
tire pixel source region is within the  exposed  portion  of  the
window.   Results  of copies from outside the window, or from re­
gions of the window that are not exposed, are hardware  dependent
and  undefined.   _param1  and _param2 specify the window coordi­
nates of the lower left corner of the rectangular  region  to  be
copied.   _param3 and _param4 specify the dimensions of the rect­
angular region to be copied.  Both _param3 and _param4  must  not
be  negative.   Several  parameters control the processing of the
pixel data while it is being copied.  These  parameters  are  set
with  three  commands: _cmnd(PixelTransfer), _cmnd(PixelMap), and
_cmnd(PixelZoom).  This reference page describes the  effects  on
_cmnd  of most, but not all, of the parameters specified by these
three commands.  _cmnd copies values from  each  pixel  with  the
lower left-hand corner at (_param1 + $i$, _param2 + $j$) for 0 &lt;=
$i$ &lt; _param3 and 0 &lt;= $j$ &lt; _param4.  This pixel is said  to  be
the $i$th pixel in the $j$th row.  Pixels are copied in row order
from the lowest to the highest row, left to right  in  each  row.
_param5  specifies whether color, depth, or stencil data is to be
copied.  The details of the transfer for each data  type  are  as

</PRE>
<H2>follows: GL_COLOR Indices or RGBA colors are read from the buffer</H2><PRE>
currently specified as the read source  buffer  (see  _cmnd(Read­
Buffer)).   If  the GL is in color index mode, each index that is
read from this buffer is converted to a fixed-point  with an  un­
specified  number of bits to the right of the binary point.  Each

</PRE>
<H2>index is then shifted left by GL_INDEX_SHIFT bits, and  added  to</H2><PRE>

</PRE>
<H2>GL_INDEX_OFFSET.   If GL_INDEX_SHIFT is negative, the shift is to</H2><PRE>
the right.  In either case, zero bits fill otherwise  unspecified

</PRE>
<H2>bit  locations in the result.  If GL_MAP_COLOR is true, the index</H2><PRE>
is replaced with the value that it  references  in  lookup  table

</PRE>
<H2>GL_PIXEL_MAP_I_TO_I.  Whether the lookup replacement of the index</H2><PRE>
is done or not, the integer part of the index is then ANDed  with
$2  sup  b  -1$, where $b$ is the number of bits in a color index
buffer.  If the GL is in RGBA mode, the red, green, blue, and al­
pha components of each pixel that is read are converted to an in­
ternal floating-point  with unspecified precision.   The  conver­
sion  maps  the largest representable component value to 1.0, and
component value 0 to 0.0.   The  resulting  floating-point  color

</PRE>
<H2>values  are then multiplied by GL_c_SCALE and added to GL_c_BIAS,</H2><PRE>
where <I>c</I> is RED, GREEN, BLUE, and ALPHA for the  respective  color
components.   The  results  are  clamped  to the range [0,1].  If

</PRE>
<H2>GL_MAP_COLOR is true, each color component is scaled by the  size</H2><PRE>

</PRE>
<H2>of  lookup  table GL_PIXEL_MAP_c_TO_c, then replaced by the value</H2><PRE>
that it references in that table.  <I>c</I> is R, G, B, or  A.   If  the

</PRE>
<H2>GL_ARB_imaging  extension  is  supported, the color values may be</H2><PRE>
additionally  processed  by  color-table  lookups,   color-matrix
transformations,  and  convolution filters.  The GL then converts
the resulting indices or RGBA colors to  fragments  by  attaching
the  current raster position <I>z</I> coordinate and texture coordinates
assigning window coordinates ($x sub r ~+~ i , y sub r  ~+~  j$),
where  ($x  sub r , y sub r$) is the current raster position, and
the pixel was the $i$th pixel in  the  $j$th  row.   These  pixel
fragments  are  then treated just like the fragments generated by
rasterizing points, lines, or polygons.   Texture  mapping,  fog,
and  all the fragment operations are applied before the fragments

</PRE>
<H2>are written to the frame buffer.  GL_STENCIL Stencil indices  are</H2><PRE>
read  from the stencil buffer and converted to an internal fixed-
point with an unspecified number of bits to the right of the  bi­
nary  point.   Each  fixed-point  index  is  then shifted left by

</PRE>
<H2>GL_INDEX_SHIFT  bits,   and   added   to   GL_INDEX_OFFSET.    If</H2><PRE>

</PRE>
<H2>GL_INDEX_SHIFT is negative, the shift is to the right.  In either</H2><PRE>
case, zero bits fill otherwise unspecified bit locations  in  the

</PRE>
<H2>result.   If  GL_MAP_STENCIL  is true, the index is replaced with</H2><PRE>

</PRE>
<H2>the value that it references in lookup table GL_PIXEL_MAP_S_TO_S.</H2><PRE>
Whether  the  lookup replacement of the index is done or not, the
integer part of the index is then ANDed with $2 sup b -1$,  where
$b$  is  the number of bits in the stencil buffer.  The resulting
stencil indices are then written to the stencil buffer such  that
the  index read from the $i$th location of the $j$th row is writ­
ten to location ($x sub r ~+~ i , y sub r ~+~ j$), where ($x  sub
r  ,  y  sub  r$) is the current raster position.  Only the pixel
ownership test, the scissor test, and the stencil  writemask  af­
fect  these  write  operations.  The rasterization described thus
far assumes pixel zoom factors of 1.0.  If
_cmnd(PixelZoom) is used to change the $x$  and  $y$  pixel  zoom
factors,  pixels  are  converted to fragments as follows.  If ($x
sub r$, $y sub r$) is the current raster position,  and  a  given
pixel  is  in  the  $i$th location in the $j$th row of the source
pixel rectangle, then fragments are generated  for  pixels  whose
centers are in the rectangle with corners at
    ($x sub r ~+~ zoom sub x^ i$, $y sub r ~+~ zoom sub y^j$)
                               and
($x  sub r ~+~ zoom sub x^ (i ~+~ 1)$, $y sub r ~+~ zoom sub y^ (
                           j ~+~ 1 )$)

</PRE>
<H2>where $zoom sub x$ is the value of GL_ZOOM_X and $zoom sub y$  is</H2><PRE>

</PRE>
<H2>the  value  of  GL_ZOOM_Y.   To copy the color pixel in the lower</H2><PRE>
left corner of the window to the  current  raster  position,  use

</PRE>
<H2>glCopyPixels(0, 0, 1, 1, GL_COLOR); Modes specified by _cmnd(Pix­</H2><PRE>
elStore)  have   no   effect   on   the   operation   of   _cmnd.

</PRE>
<H2>GL_INVALID_ENUM is generated if _param5 is not an accepted value.</H2><PRE>

</PRE>
<H2>GL_INVALID_VALUE is generated if either  _param3  or  _param4  is</H2><PRE>

</PRE>
<H2>negative.    GL_INVALID_OPERATION  is  generated  if  _param5  is</H2><PRE>

</PRE>
<H2>GL_DEPTH and there is no depth buffer.   GL_INVALID_OPERATION  is</H2><PRE>

</PRE>
<H2>generated  if  _param5  is  GL_STENCIL  and  there  is no stencil</H2><PRE>

</PRE>
<H2>buffer.  GL_INVALID_OPERATION is generated if _cmnd  is  executed</H2><PRE>
between  the execution of _cmnd(Begin) and the corresponding exe­
cution    of    _cmnd(End).      _cmnd(Get)     with     argument

</PRE>
<H2>GL_CURRENT_RASTER_POSITION</H2><PRE>

</PRE>
<H2>_cmnd(Get)  with  argument  GL_CURRENT_RASTER_POSITION_VALID _cm­</H2><PRE>
nd(ColorTable), _cmnd(ConvolutionFilter1D), _cmnd(ConvolutionFil­
ter2D),  _cmnd(DepthFunc),  _cmnd(DrawBuffer), _cmnd(DrawPixels),
@


1.1.1.1
log
@win32-x11 source tree update March 26, 2001
@
text
@@
