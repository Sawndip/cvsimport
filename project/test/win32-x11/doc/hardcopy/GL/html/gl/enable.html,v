head	1.2;
access;
symbols
	win32-x11-2001-03-26:1.1.1.1 SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2001.06.03.20.47.06;	author ssiddiqi;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.25.19.36.50;	author ssiddiqi;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.03.25.19.36.50;	author ssiddiqi;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Win32-X11 update sources check in, June 3, 2001 - ssiddiqi
@
text
@<HTML>
<BODY>
<PRE>
<!-- Manpage converted by man2html 3.0.1 -->
</PRE>
<HR>
<ADDRESS>
Man(1) output converted with
<a href="http://www.oac.uci.edu/indiv/ehood/man2html.html">man2html</a>
</ADDRESS>
</BODY>
</HTML>
@


1.1
log
@Initial revision
@
text
@a4 286

</PRE>
<H2>exception  of  GL_DITHER  is  GL_FALSE.  The  initial  value  for</H2><PRE>

</PRE>
<H2>GL_DITHER is GL_TRUE.  Both _cmnd(Enable) and _cmnd(Disable) take</H2><PRE>
a single argument, _param1, which can assume one of the following

</PRE>
<H2>values: GL_ALPHA_TEST If enabled, do alpha testing. See _cmnd(Al­</H2><PRE>

</PRE>
<H2>phaFunc).  GL_AUTO_NORMAL If  enabled,  generate  normal  vectors</H2><PRE>

</PRE>
<H2>when  either GL_MAP2_VERTEX_3 or GL_MAP2_VERTEX_4 is used to gen­</H2><PRE>

</PRE>
<H2>erate vertices.  See _cmnd(Map2).  GL_BLEND If enabled, blend the</H2><PRE>
incoming  RGBA color values with the values in the color buffers.

</PRE>
<H2>See _cmnd(BlendFunc).  GL_CLIP_PLANEi If enabled,  clip  geometry</H2><PRE>
against  user-defined  clipping  plane  <I>i</I>.  See _cmnd(ClipPlane).

</PRE>
<H2>GL_COLOR_LOGIC_OP If enabled, apply the currently selected  logi­</H2><PRE>
cal operation to the incoming RGBA color and color buffer values.

</PRE>
<H2>See _cmnd(LogicOp).  GL_COLOR_MATERIAL If enabled,  have  one  or</H2><PRE>
more material parameters track the current color.  See _cmnd(Col­

</PRE>
<H2>orMaterial).  GL_COLOR_TABLE If enabled, preform  a  color  table</H2><PRE>
lookup on the incoming RGBA color values.  See _cmnd(ColorTable).

</PRE>
<H2>GL_CONVOLUTION_1D If enabled, perform a 1D convolution  operation</H2><PRE>
on  incoming  RGBA color values.  See _cmnd(ConvolutionFilter1D).

</PRE>
<H2>GL_CONVOLUTION_2D If enabled, perform a 2D convolution  operation</H2><PRE>
on  incoming  RGBA color values.  See _cmnd(ConvolutionFilter2D).

</PRE>
<H2>GL_CULL_FACE If enabled, cull polygons based on their winding  in</H2><PRE>

</PRE>
<H2>window  coordinates.   See _cmnd(CullFace).  GL_DEPTH_TEST If en­</H2><PRE>
abled, do depth comparisons and update  the  depth  buffer.  Note
that  even  if the depth buffer exists and the depth mask is non-
zero, the depth buffer is not updated if the depth test  is  dis­
abled. See _cmnd(DepthFunc) and

</PRE>
<H2>_cmnd(DepthRange).   GL_DITHER   If  enabled, dither color compo­</H2><PRE>
nents or indices before they are written  to  the  color  buffer.

</PRE>
<H2>GL_FOG  If enabled, blend a fog color into the posttexturing col­</H2><PRE>

</PRE>
<H2>or.  See _cmnd(Fog).  GL_HISTOGRAM If enabled, histogram incoming</H2><PRE>

</PRE>
<H2>RGBA  color  values.  See _cmnd(Histogram).  GL_INDEX_LOGIC_OP If</H2><PRE>
enabled, apply the currently selected logical  operation  to  the
incoming index and color buffer indices. See

</PRE>
<H2>_cmnd(LogicOp).   GL_LIGHTi  If  enabled,  include light i in the</H2><PRE>
evaluation of the lighting equation.  See  _cmnd(LightModel)  and

</PRE>
<H2>_cmnd(Light).   GL_LIGHTING  If enabled, use the current lighting</H2><PRE>
parameters to compute the vertex color or index.  Otherwise, sim­
ply associate the current color or index with each vertex. See
_cmnd(Material),     _cmnd(LightModel),     and     _cmnd(Light).

</PRE>
<H2>GL_LINE_SMOOTH If enabled, draw  lines  with  correct  filtering.</H2><PRE>
Otherwise,    draw    aliased   lines.    See   _cmnd(LineWidth).

</PRE>
<H2>GL_LINE_STIPPLE If enabled, use the current line stipple  pattern</H2><PRE>

</PRE>
<H2>when  drawing  lines. See _cmnd(LineStipple).  GL_MAP1_COLOR_4 If</H2><PRE>
enabled, calls to _cmnd(EvalCoord1), _cmnd(EvalMesh1),  and  _cm­
nd(EvalPoint1)    generate   RGBA   values.    See   _cmnd(Map1).

</PRE>
<H2>GL_MAP1_INDEX  If  enabled,  calls  to  _cmnd(EvalCoord1),   _cm­</H2><PRE>
nd(EvalMesh1), and _cmnd(EvalPoint1) generate color indices.  See

</PRE>
<H2>_cmnd(Map1).  GL_MAP1_NORMAL If enabled, calls  to  _cmnd(EvalCo­</H2><PRE>
ord1),  _cmnd(EvalMesh1), and _cmnd(EvalPoint1) generate normals.

</PRE>
<H2>See _cmnd(Map1).  GL_MAP1_TEXTURE_COORD_1 If  enabled,  calls  to</H2><PRE>
_cmnd(EvalCoord1), _cmnd(EvalMesh1), and _cmnd(EvalPoint1) gener­
ate     <I>s</I>     texture     coordinates.      See      _cmnd(Map1).
nd(EvalCoord2),  _cmnd(EvalMesh2), and _cmnd(EvalPoint2) generate

</PRE>
<H2>RGBA values.  See _cmnd(Map2).  GL_MAP2_INDEX If  enabled,  calls</H2><PRE>
to  _cmnd(EvalCoord2),  _cmnd(EvalMesh2),  and  _cmnd(EvalPoint2)

</PRE>
<H2>generate color indices.  See _cmnd(Map2).  GL_MAP2_NORMAL If  en­</H2><PRE>
abled,  calls  to  _cmnd(EvalCoord2),  _cmnd(EvalMesh2), and _cm­
nd(EvalPoint2)    generate     normals.      See     _cmnd(Map2).

</PRE>
<H2>GL_MAP2_TEXTURE_COORD_1  If  enabled, calls to _cmnd(EvalCoord2),</H2><PRE>
_cmnd(EvalMesh2), and _cmnd(EvalPoint2) generate <I>s</I> texture  coor­

</PRE>
<H2>dinates.   See  _cmnd(Map2).  GL_MAP2_TEXTURE_COORD_2 If enabled,</H2><PRE>
calls to  _cmnd(EvalCoord2),  _cmnd(EvalMesh2),  and  _cmnd(Eval­
Point2)  generate  <I>s</I> and <I>t</I> texture coordinates.  See _cmnd(Map2).

</PRE>
<H2>GL_MAP2_TEXTURE_COORD_3 If enabled, calls  to  _cmnd(EvalCoord2),</H2><PRE>
_cmnd(EvalMesh2), and _cmnd(EvalPoint2) generate <I>s</I>, <I>t</I>, and <I>r</I> tex­

</PRE>
<H2>ture coordinates.  See _cmnd(Map2).   GL_MAP2_TEXTURE_COORD_4  If</H2><PRE>
enabled,  calls  to _cmnd(EvalCoord2), _cmnd(EvalMesh2), and _cm­
nd(EvalPoint2) generate <I>s</I>, <I>t</I>, <I>r</I>, and <I>q</I> texture coordinates.   See

</PRE>
<H2>_cmnd(Map2).  GL_MAP2_VERTEX_3 If enabled, calls to _cmnd(EvalCo­</H2><PRE>
ord2), _cmnd(EvalMesh2), and _cmnd(EvalPoint2) generate <I>x</I>, <I>y</I>, and

</PRE>
<H2>z  vertex coordinates.  See _cmnd(Map2).  GL_MAP2_VERTEX_4 If en­</H2><PRE>
abled, calls to  _cmnd(EvalCoord2),  _cmnd(EvalMesh2),  and  _cm­
nd(EvalPoint2) generate homogeneous <I>x</I>, <I>y</I>, <I>z</I>, and <I>w</I> vertex coordi­

</PRE>
<H2>nates.  See _cmnd(Map2).  GL_MINMAX If enabled, compute the mini­</H2><PRE>
mum  and  maximum values of incoming RGBA color values.  See _cm­

</PRE>
<H2>nd(Minmax).  GL_NORMALIZE If enabled,  normal  vectors  specified</H2><PRE>
with  _cmnd(Normal)  are  scaled to unit length after transforma­

</PRE>
<H2>tion. See _cmnd(Normal).  GL_POINT_SMOOTH If enabled, draw points</H2><PRE>
with proper filtering.  Otherwise, draw aliased points.  See _cm­

</PRE>
<H2>nd(PointSize).  GL_POLYGON_OFFSET_FILL If  enabled,  and  if  the</H2><PRE>

</PRE>
<H2>polygon  is rendered in GL_FILL mode, an offset is added to depth</H2><PRE>
values of a polygon's fragments before the  depth  comparison  is

</PRE>
<H2>performed.   See _cmnd(PolygonOffset).  GL_POLYGON_OFFSET_LINE If</H2><PRE>

</PRE>
<H2>enabled, and if the polygon is rendered in GL_LINE mode, an  off­</H2><PRE>
set  is added to depth values of a polygon's fragments before the
depth  comparison   is   performed.   See   _cmnd(PolygonOffset).

</PRE>
<H2>GL_POLYGON_OFFSET_POINT  If  enabled, an offset is added to depth</H2><PRE>
values of a polygon's fragments before the  depth  comparison  is

</PRE>
<H2>performed,  if the polygon is rendered in GL_POINT mode. See _cm­</H2><PRE>

</PRE>
<H2>nd(PolygonOffset).  GL_POLYGON_SMOOTH If enabled,  draw  polygons</H2><PRE>
with  proper  filtering.   Otherwise,  draw aliased polygons. For
correct anti-aliased polygons, an alpha buffer is needed and  the

</PRE>
<H2>polygons must be sorted front to back.  GL_POLYGON_STIPPLE If en­</H2><PRE>
abled, use the current polygon  stipple  pattern  when  rendering
polygons.                See               _cmnd(PolygonStipple).

</PRE>
<H2>GL_POST_COLOR_MATRIX_COLOR_TABLE  If  enabled,  preform  a  color</H2><PRE>
table  lookup on RGBA color values after color matrix transforma­

</PRE>
<H2>tion.  See _cmnd(ColorTable).  GL_POST_CONVOLUTION_COLOR_TABLE If</H2><PRE>
enabled,  preform a color table lookup on RGBA color values after

</PRE>
<H2>convolution.  See _cmnd(ColorTable).   GL_RESCALE_NORMAL  If  en­</H2><PRE>
abled,  normal vectors specified with _cmnd(Normal) are scaled to
unit   length   after    transformation.    See    _cmnd(Normal).

</PRE>
<H2>GL_SEPARABLE_2D If enabled, perform a two-dimensional convolution</H2><PRE>
operation using a separable convolution filter on  incoming  RGBA
If  enabled,  the <I>r</I> texture coordinate is computed using the tex­
ture generation function defined with _cmnd(TexGen).   Otherwise,
the  current  <I>r</I>  texture  coordinate is used.  See _cmnd(TexGen).

</PRE>
<H2>GL_TEXTURE_GEN_S If enabled, the s texture coordinate is computed</H2><PRE>
using the texture generation function defined with _cmnd(TexGen).
Otherwise, the current <I>s</I> texture coordinate is  used.   See  _cm­

</PRE>
<H2>nd(TexGen).   GL_TEXTURE_GEN_T  If enabled, the t texture coordi­</H2><PRE>
nate is computed using the texture  generation  function  defined
with  _cmnd(TexGen).  Otherwise, the current <I>t</I> texture coordinate

</PRE>
<H2>is    used.     See    _cmnd(TexGen).     GL_POLYGON_OFFSET_FILL,</H2><PRE>

</PRE>
<H2>GL_POLYGON_OFFSET_LINE,                  GL_POLYGON_OFFSET_POINT,</H2><PRE>

</PRE>
<H2>GL_COLOR_LOGIC_OP, and GL_INDEX_LOGIC_OP are  available  only  if</H2><PRE>

</PRE>
<H2>the  GL  version  is  1.1  or  greater.   GL_RESCALE_NORMAL,  and</H2><PRE>

</PRE>
<H2>GL_TEXTURE_3D are available only if the  GL  version  is  1.2  or</H2><PRE>

</PRE>
<H2>greater.   GL_COLOR_TABLE,  GL_CONVOLUTION_1D, GL_CONVOLUTION_2D,</H2><PRE>

</PRE>
<H2>GL_HISTOGRAM,    GL_MINMAX,     GL_POST_COLOR_MATRIX_COLOR_TABLE,</H2><PRE>

</PRE>
<H2>GL_POST_CONVOLUTION_COLOR_TABLE,  and  GL_SEPARABLE_2D are avail­</H2><PRE>

</PRE>
<H2>able only if GL_ARB_imaging is returned from _cmnd(Get)  with  an</H2><PRE>

</PRE>
<H2>argument  of GL_EXTENSIONS.  If GL_ARB_multitexture is supported,</H2><PRE>

</PRE>
<H2>GL_TEXTURE_1D,  GL_TEXTURE_2D,  GL_TEXTURE_3D,  GL_TEXTURE_GEN_S,</H2><PRE>

</PRE>
<H2>GL_TEXTURE_GEN_T,  GL_TEXTURE_GEN_R,  and GL_TEXTURE_GEN_Q enable</H2><PRE>
or disable the respective state for the active texture unit spec­

</PRE>
<H2>ified with _cmnd(ActiveTextureARB).  GL_INVALID_ENUM is generated</H2><PRE>
if  _param1  is  not  one  of  the  values   listed   previously.

</PRE>
<H2>GL_INVALID_OPERATION  is generated if _cmnd(Enable) or _cmnd(Dis­</H2><PRE>
able) is executed between the execution of _cmnd(Begin)  and  the
corresponding  execution of _cmnd(End).  _cmnd(ActiveTextureARB),
_cmnd(AlphaFunc), _cmnd(BlendFunc), _cmnd(ClipPlane),  _cmnd(Col­
orMaterial),      _cmnd(CullFace),     _cmnd(DepthFunc),     _cm­
nd(DepthRange), _cmnd(EnableClientState), _cmnd(Fog), _cmnd(Get),
_cmnd(IsEnabled),     _cmnd(Light),    _cmnd(LightModel),    _cm­
nd(LineWidth), _cmnd(LineStipple),  _cmnd(LogicOp),  _cmnd(Map1),
_cmnd(Map2),  _cmnd(Material),  _cmnd(Normal),  _cmnd(PointSize),
_cmnd(PolygonMode), _cmnd(PolygonOffset),  _cmnd(PolygonStipple),
_cmnd(Scissor),  _cmnd(StencilFunc), _cmnd(StencilOp), _cmnd(Tex­
Gen), _cmnd(TexImage1D), _cmnd(TexImage2D), _cmnd(TexImage3D)
















@


1.1.1.1
log
@win32-x11 source tree update March 26, 2001
@
text
@@
